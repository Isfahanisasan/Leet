/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_src_components_about_editor_js"],{

/***/ "(app-pages-browser)/./node_modules/@phigoro/editorjs-toc/dist/bundle.js":
/*!***********************************************************!*\
  !*** ./node_modules/@phigoro/editorjs-toc/dist/bundle.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("!function(e,t){ true?module.exports=t():0}(self,(()=>(()=>{\"use strict\";var e={424:(e,t,n)=>{n.d(t,{Z:()=>s});var r=n(81),o=n.n(r),a=n(645),i=n.n(a)()(o());i.push([e.id,\"a:link { text-decoration: none; }\\na:hover { text-decoration: underline; }\\n\\n.toc-wrapper {\\n  padding: 0.6em 0 3px;\\n}\\n\\n.toc-paragraph {\\n    display: block;\\n    line-height: 2;\\n}\\n\\n.toc-l-1 {\\n    padding-left: 0;\\n}\\n\\n.toc-l-2 {\\n    padding-left: 1.0em;\\n}\\n\\n.toc-l-3 {\\n    padding-left: 2.0em;\\n}\\n\\n.toc-l-4 {\\n    padding-left: 3.0em;\\n}\\n\\n.toc-l-5 {\\n    padding-left: 4.0em;\\n}\\n\\n.toc-l-6 {\\n    padding-left: 5.0em;\\n}\\n\",\"\"]);const s=i},645:e=>{e.exports=function(e){var t=[];return t.toString=function(){return this.map((function(t){var n=\"\",r=void 0!==t[5];return t[4]&&(n+=\"@supports (\".concat(t[4],\") {\")),t[2]&&(n+=\"@media \".concat(t[2],\" {\")),r&&(n+=\"@layer\".concat(t[5].length>0?\" \".concat(t[5]):\"\",\" {\")),n+=e(t),r&&(n+=\"}\"),t[2]&&(n+=\"}\"),t[4]&&(n+=\"}\"),n})).join(\"\")},t.i=function(e,n,r,o,a){\"string\"==typeof e&&(e=[[null,e,void 0]]);var i={};if(r)for(var s=0;s<this.length;s++){var c=this[s][0];null!=c&&(i[c]=!0)}for(var d=0;d<e.length;d++){var l=[].concat(e[d]);r&&i[l[0]]||(void 0!==a&&(void 0===l[5]||(l[1]=\"@layer\".concat(l[5].length>0?\" \".concat(l[5]):\"\",\" {\").concat(l[1],\"}\")),l[5]=a),n&&(l[2]?(l[1]=\"@media \".concat(l[2],\" {\").concat(l[1],\"}\"),l[2]=n):l[2]=n),o&&(l[4]?(l[1]=\"@supports (\".concat(l[4],\") {\").concat(l[1],\"}\"),l[4]=o):l[4]=\"\".concat(o)),t.push(l))}},t}},81:e=>{e.exports=function(e){return e[1]}},379:e=>{var t=[];function n(e){for(var n=-1,r=0;r<t.length;r++)if(t[r].identifier===e){n=r;break}return n}function r(e,r){for(var a={},i=[],s=0;s<e.length;s++){var c=e[s],d=r.base?c[0]+r.base:c[0],l=a[d]||0,p=\"\".concat(d,\" \").concat(l);a[d]=l+1;var u=n(p),h={css:c[1],media:c[2],sourceMap:c[3],supports:c[4],layer:c[5]};if(-1!==u)t[u].references++,t[u].updater(h);else{var f=o(h,r);r.byIndex=s,t.splice(s,0,{identifier:p,updater:f,references:1})}i.push(p)}return i}function o(e,t){var n=t.domAPI(t);return n.update(e),function(t){if(t){if(t.css===e.css&&t.media===e.media&&t.sourceMap===e.sourceMap&&t.supports===e.supports&&t.layer===e.layer)return;n.update(e=t)}else n.remove()}}e.exports=function(e,o){var a=r(e=e||[],o=o||{});return function(e){e=e||[];for(var i=0;i<a.length;i++){var s=n(a[i]);t[s].references--}for(var c=r(e,o),d=0;d<a.length;d++){var l=n(a[d]);0===t[l].references&&(t[l].updater(),t.splice(l,1))}a=c}}},569:e=>{var t={};e.exports=function(e,n){var r=function(e){if(void 0===t[e]){var n=document.querySelector(e);if(window.HTMLIFrameElement&&n instanceof window.HTMLIFrameElement)try{n=n.contentDocument.head}catch(e){n=null}t[e]=n}return t[e]}(e);if(!r)throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");r.appendChild(n)}},216:e=>{e.exports=function(e){var t=document.createElement(\"style\");return e.setAttributes(t,e.attributes),e.insert(t,e.options),t}},565:(e,t,n)=>{e.exports=function(e){var t=n.nc;t&&e.setAttribute(\"nonce\",t)}},795:e=>{e.exports=function(e){if(\"undefined\"==typeof document)return{update:function(){},remove:function(){}};var t=e.insertStyleElement(e);return{update:function(n){!function(e,t,n){var r=\"\";n.supports&&(r+=\"@supports (\".concat(n.supports,\") {\")),n.media&&(r+=\"@media \".concat(n.media,\" {\"));var o=void 0!==n.layer;o&&(r+=\"@layer\".concat(n.layer.length>0?\" \".concat(n.layer):\"\",\" {\")),r+=n.css,o&&(r+=\"}\"),n.media&&(r+=\"}\"),n.supports&&(r+=\"}\");var a=n.sourceMap;a&&\"undefined\"!=typeof btoa&&(r+=\"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(a)))),\" */\")),t.styleTagTransform(r,e,t.options)}(t,e,n)},remove:function(){!function(e){if(null===e.parentNode)return!1;e.parentNode.removeChild(e)}(t)}}}},589:e=>{e.exports=function(e,t){if(t.styleSheet)t.styleSheet.cssText=e;else{for(;t.firstChild;)t.removeChild(t.firstChild);t.appendChild(document.createTextNode(e))}}}},t={};function n(r){var o=t[r];if(void 0!==o)return o.exports;var a=t[r]={id:r,exports:{}};return e[r](a,a.exports,n),a.exports}n.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return n.d(t,{a:t}),t},n.d=(e,t)=>{for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),n.nc=void 0;var r={};return(()=>{n.d(r,{default:()=>m});var e=n(379),t=n.n(e),o=n(795),a=n.n(o),i=n(569),s=n.n(i),c=n(565),d=n.n(c),l=n(216),p=n.n(l),u=n(589),h=n.n(u),f=n(424),v={};v.styleTagTransform=h(),v.setAttributes=d(),v.insert=s().bind(null,\"head\"),v.domAPI=a(),v.insertStyleElement=p(),t()(f.Z,v),f.Z&&f.Z.locals&&f.Z.locals;class m{static get toolbox(){return{title:\"TOC\",icon:'<svg viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\\n                      <g id=\"SVGRepo_bgCarrier\" stroke-width=\"0\"></g><g id=\"SVGRepo_tracerCarrier\" stroke-linecap=\"round\" stroke-linejoin=\"round\"></g><g id=\"SVGRepo_iconCarrier\"> <rect x=\"4\" y=\"4\" width=\"16\" height=\"16\" rx=\"3\" stroke=\"#000000\" stroke-width=\"2\"></rect> <path d=\"M16 10L8 10\" stroke=\"#000000\" stroke-width=\"2\" stroke-linecap=\"round\"></path> <path d=\"M16 14L8 14\" stroke=\"#000000\" stroke-width=\"2\" stroke-linecap=\"round\"></path> \\n                      </g></svg>'}}constructor({data:e,api:t,block:n}){this.api=t,this.data=e,this.block=n,this.wrapper=void 0,this.data.items=e.items||[]}render(){return this.wrapper=document.createElement(\"div\"),this.wrapper.id=this.block.id,this.wrapper.classList.add(\"toc-wrapper\"),this.data.items.length<1&&this._getHeadings(),this._createTOC(),this.wrapper}static get isReadOnlySupported(){return!0}_getHeadings(){this.data.items=[];for(var e=this.api.blocks.getBlocksCount(),t=0;t<e;t++){var n=this.api.blocks.getBlockByIndex(t);if(\"header\"==n.name&&n.holder.innerText){var r=n.holder.childNodes[0].childNodes[0].nodeName;r=parseInt(r.replace(\"H\",\"\"));var o={id:Math.random().toString(36).substring(2,12),reference:n.id,text:n.holder.innerText,level:r};this.data.items.push(o)}}this._createTOC()}_createTOC(){const e=\"/\"+new URL(window.location.href).search,t=this.data.items;if(this.wrapper.innerHTML=\"\",t.length<1){var n=document.createElement(\"p\");return n.innerHTML=this.api.i18n.t(\"No headings found\"),void this.wrapper.appendChild(n)}for(const n of t){var r=document.createElement(\"a\");r.classList.add(\"toc-paragraph\",\"toc-l-\"+n.level),r.textContent=n.text,r.setAttribute(\"href\",e+\"#\"+n.reference),r.addEventListener(\"click\",(e=>{e.preventDefault(),document.getElementById(e.target.hash.substring(1))?.scrollIntoView({behavior:\"smooth\",block:\"start\",inline:\"start\"}),location.hash=e.target.hash})),this.wrapper.appendChild(r)}}renderSettings(){return[{icon:'<svg width=\"17\" height=\"15\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 489.645 489.645\">\\n                      <path d=\"M460.656,132.911c-58.7-122.1-212.2-166.5-331.8-104.1c-9.4,5.2-13.5,16.6-8.3,27c5.2,9.4,16.6,13.5,27,8.3\\n                          c99.9-52,227.4-14.9,276.7,86.3c65.4,134.3-19,236.7-87.4,274.6c-93.1,51.7-211.2,17.4-267.6-70.7l69.3,14.5\\n                          c10.4,2.1,21.8-4.2,23.9-15.6c2.1-10.4-4.2-21.8-15.6-23.9l-122.8-25c-20.6-2-25,16.6-23.9,22.9l15.6,123.8\\n                          c1,10.4,9.4,17.7,19.8,17.7c12.8,0,20.8-12.5,19.8-23.9l-6-50.5c57.4,70.8,170.3,131.2,307.4,68.2\\n                          C414.856,432.511,548.256,314.811,460.656,132.911z\"/>\\n                  </svg>',name:\"refresh\",label:this.api.i18n.t(\"Refresh\"),toggle:\"toc\",onActivate:()=>{this._getHeadings()}}]}save(e){return{items:this.data.items}}}})(),r.default})()));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcGhpZ29yby9lZGl0b3Jqcy10b2MvZGlzdC9idW5kbGUuanMiLCJtYXBwaW5ncyI6IkFBQUEsZUFBZSxLQUFpRCxvQkFBb0IsQ0FBcUcsQ0FBQyxpQkFBaUIsYUFBYSxPQUFPLGNBQWMsT0FBTyxRQUFRLEVBQUUsOENBQThDLHVCQUF1Qix3QkFBd0IsWUFBWSw2QkFBNkIsa0JBQWtCLHlCQUF5QixHQUFHLG9CQUFvQixxQkFBcUIscUJBQXFCLEdBQUcsY0FBYyxzQkFBc0IsR0FBRyxjQUFjLDBCQUEwQixHQUFHLGNBQWMsMEJBQTBCLEdBQUcsY0FBYywwQkFBMEIsR0FBRyxjQUFjLDBCQUEwQixHQUFHLGNBQWMsMEJBQTBCLEdBQUcsU0FBUyxVQUFVLFNBQVMsc0JBQXNCLFNBQVMsNkJBQTZCLDZCQUE2Qix5QkFBeUIsK0NBQStDLHVDQUF1QyxnRUFBZ0UscUJBQXFCLGVBQWUsZUFBZSxLQUFLLFlBQVkseUJBQXlCLDBDQUEwQyxTQUFTLGlCQUFpQixjQUFjLEtBQUssaUJBQWlCLG1CQUFtQixZQUFZLFdBQVcsS0FBSyxzQkFBc0Isb0dBQW9HLGlCQUFpQixvREFBb0QsaUJBQWlCLGdFQUFnRSxpQkFBaUIsMENBQTBDLElBQUksUUFBUSxzQkFBc0IsYUFBYSxTQUFTLFNBQVMsY0FBYyxpQkFBaUIsV0FBVyw0QkFBNEIsSUFBSSxNQUFNLFNBQVMsZ0JBQWdCLFlBQVksVUFBVSxXQUFXLEtBQUssNEVBQTRFLFNBQVMsY0FBYyw2REFBNkQsNENBQTRDLEtBQUssYUFBYSwwQkFBMEIsb0NBQW9DLEVBQUUsVUFBVSxTQUFTLGdCQUFnQixrQkFBa0IsK0JBQStCLE1BQU0sa0hBQWtILGNBQWMsaUJBQWlCLHdCQUF3Qix1QkFBdUIsRUFBRSxtQkFBbUIsUUFBUSxZQUFZLFdBQVcsS0FBSyxjQUFjLGtCQUFrQixxQkFBcUIsV0FBVyxLQUFLLGNBQWMsb0RBQW9ELE1BQU0sU0FBUyxTQUFTLHdCQUF3QixrQkFBa0Isa0JBQWtCLGdDQUFnQyx1RUFBdUUseUJBQXlCLFNBQVMsT0FBTyxPQUFPLFlBQVksSUFBSSxpSUFBaUksa0JBQWtCLFNBQVMsc0JBQXNCLHNDQUFzQyxnRUFBZ0UsZUFBZSxzQkFBc0IsV0FBVyw4QkFBOEIsU0FBUyxzQkFBc0IsdUNBQXVDLG1CQUFtQixzQkFBc0IsOEJBQThCLE9BQU8sbUJBQW1CLGlCQUFpQixTQUFTLG9EQUFvRCw2Q0FBNkMsSUFBSSx1QkFBdUIsa0VBQWtFLHNCQUFzQixrQkFBa0IscUJBQXFCLEdBQUcsa0JBQWtCLCtFQUErRSxpSEFBaUgsUUFBUSxtQkFBbUIsYUFBYSxnQ0FBZ0MsNEJBQTRCLE9BQU8sU0FBUyx3QkFBd0IsdUNBQXVDLEtBQUssS0FBSyxhQUFhLDZCQUE2Qiw2Q0FBNkMsTUFBTSxjQUFjLFdBQVcsK0JBQStCLFlBQVksaUJBQWlCLHFDQUFxQyxRQUFRLDBDQUEwQyxjQUFjLElBQUksSUFBSSxhQUFhLCtEQUErRCx1QkFBdUIsRUFBRSxrRUFBa0UsU0FBUyxZQUFZLE9BQU8sY0FBYyxFQUFFLDhIQUE4SCx3SkFBd0osUUFBUSxxQkFBcUIsT0FBTyw0akJBQTRqQixhQUFhLHFCQUFxQixFQUFFLG9GQUFvRixTQUFTLHVNQUF1TSxpQ0FBaUMsU0FBUyxlQUFlLG1CQUFtQiwrQ0FBK0MsSUFBSSxLQUFLLHlDQUF5Qyx5Q0FBeUMsb0RBQW9ELDhCQUE4QixPQUFPLDhGQUE4Rix5QkFBeUIsa0JBQWtCLGFBQWEsbUVBQW1FLHlDQUF5QyxrQ0FBa0MseUZBQXlGLGtCQUFrQixrQ0FBa0MsZ0pBQWdKLHdGQUF3RiwrQ0FBK0MsOEJBQThCLGdDQUFnQyxpQkFBaUIsUUFBUSxxeUJBQXF5QixxQkFBcUIsRUFBRSxRQUFRLE9BQU8seUJBQXlCLGNBQWMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BwaGlnb3JvL2VkaXRvcmpzLXRvYy9kaXN0L2J1bmRsZS5qcz9lNWQ2Il0sInNvdXJjZXNDb250ZW50IjpbIiFmdW5jdGlvbihlLHQpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPXQoKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtdLHQpOlwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzP2V4cG9ydHMuVE9DPXQoKTplLlRPQz10KCl9KHNlbGYsKCgpPT4oKCk9PntcInVzZSBzdHJpY3RcIjt2YXIgZT17NDI0OihlLHQsbik9PntuLmQodCx7WjooKT0+c30pO3ZhciByPW4oODEpLG89bi5uKHIpLGE9big2NDUpLGk9bi5uKGEpKCkobygpKTtpLnB1c2goW2UuaWQsXCJhOmxpbmsgeyB0ZXh0LWRlY29yYXRpb246IG5vbmU7IH1cXG5hOmhvdmVyIHsgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7IH1cXG5cXG4udG9jLXdyYXBwZXIge1xcbiAgcGFkZGluZzogMC42ZW0gMCAzcHg7XFxufVxcblxcbi50b2MtcGFyYWdyYXBoIHtcXG4gICAgZGlzcGxheTogYmxvY2s7XFxuICAgIGxpbmUtaGVpZ2h0OiAyO1xcbn1cXG5cXG4udG9jLWwtMSB7XFxuICAgIHBhZGRpbmctbGVmdDogMDtcXG59XFxuXFxuLnRvYy1sLTIge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDEuMGVtO1xcbn1cXG5cXG4udG9jLWwtMyB7XFxuICAgIHBhZGRpbmctbGVmdDogMi4wZW07XFxufVxcblxcbi50b2MtbC00IHtcXG4gICAgcGFkZGluZy1sZWZ0OiAzLjBlbTtcXG59XFxuXFxuLnRvYy1sLTUge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDQuMGVtO1xcbn1cXG5cXG4udG9jLWwtNiB7XFxuICAgIHBhZGRpbmctbGVmdDogNS4wZW07XFxufVxcblwiLFwiXCJdKTtjb25zdCBzPWl9LDY0NTplPT57ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe3ZhciB0PVtdO3JldHVybiB0LnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWFwKChmdW5jdGlvbih0KXt2YXIgbj1cIlwiLHI9dm9pZCAwIT09dFs1XTtyZXR1cm4gdFs0XSYmKG4rPVwiQHN1cHBvcnRzIChcIi5jb25jYXQodFs0XSxcIikge1wiKSksdFsyXSYmKG4rPVwiQG1lZGlhIFwiLmNvbmNhdCh0WzJdLFwiIHtcIikpLHImJihuKz1cIkBsYXllclwiLmNvbmNhdCh0WzVdLmxlbmd0aD4wP1wiIFwiLmNvbmNhdCh0WzVdKTpcIlwiLFwiIHtcIikpLG4rPWUodCksciYmKG4rPVwifVwiKSx0WzJdJiYobis9XCJ9XCIpLHRbNF0mJihuKz1cIn1cIiksbn0pKS5qb2luKFwiXCIpfSx0Lmk9ZnVuY3Rpb24oZSxuLHIsbyxhKXtcInN0cmluZ1wiPT10eXBlb2YgZSYmKGU9W1tudWxsLGUsdm9pZCAwXV0pO3ZhciBpPXt9O2lmKHIpZm9yKHZhciBzPTA7czx0aGlzLmxlbmd0aDtzKyspe3ZhciBjPXRoaXNbc11bMF07bnVsbCE9YyYmKGlbY109ITApfWZvcih2YXIgZD0wO2Q8ZS5sZW5ndGg7ZCsrKXt2YXIgbD1bXS5jb25jYXQoZVtkXSk7ciYmaVtsWzBdXXx8KHZvaWQgMCE9PWEmJih2b2lkIDA9PT1sWzVdfHwobFsxXT1cIkBsYXllclwiLmNvbmNhdChsWzVdLmxlbmd0aD4wP1wiIFwiLmNvbmNhdChsWzVdKTpcIlwiLFwiIHtcIikuY29uY2F0KGxbMV0sXCJ9XCIpKSxsWzVdPWEpLG4mJihsWzJdPyhsWzFdPVwiQG1lZGlhIFwiLmNvbmNhdChsWzJdLFwiIHtcIikuY29uY2F0KGxbMV0sXCJ9XCIpLGxbMl09bik6bFsyXT1uKSxvJiYobFs0XT8obFsxXT1cIkBzdXBwb3J0cyAoXCIuY29uY2F0KGxbNF0sXCIpIHtcIikuY29uY2F0KGxbMV0sXCJ9XCIpLGxbNF09byk6bFs0XT1cIlwiLmNvbmNhdChvKSksdC5wdXNoKGwpKX19LHR9fSw4MTplPT57ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe3JldHVybiBlWzFdfX0sMzc5OmU9Pnt2YXIgdD1bXTtmdW5jdGlvbiBuKGUpe2Zvcih2YXIgbj0tMSxyPTA7cjx0Lmxlbmd0aDtyKyspaWYodFtyXS5pZGVudGlmaWVyPT09ZSl7bj1yO2JyZWFrfXJldHVybiBufWZ1bmN0aW9uIHIoZSxyKXtmb3IodmFyIGE9e30saT1bXSxzPTA7czxlLmxlbmd0aDtzKyspe3ZhciBjPWVbc10sZD1yLmJhc2U/Y1swXStyLmJhc2U6Y1swXSxsPWFbZF18fDAscD1cIlwiLmNvbmNhdChkLFwiIFwiKS5jb25jYXQobCk7YVtkXT1sKzE7dmFyIHU9bihwKSxoPXtjc3M6Y1sxXSxtZWRpYTpjWzJdLHNvdXJjZU1hcDpjWzNdLHN1cHBvcnRzOmNbNF0sbGF5ZXI6Y1s1XX07aWYoLTEhPT11KXRbdV0ucmVmZXJlbmNlcysrLHRbdV0udXBkYXRlcihoKTtlbHNle3ZhciBmPW8oaCxyKTtyLmJ5SW5kZXg9cyx0LnNwbGljZShzLDAse2lkZW50aWZpZXI6cCx1cGRhdGVyOmYscmVmZXJlbmNlczoxfSl9aS5wdXNoKHApfXJldHVybiBpfWZ1bmN0aW9uIG8oZSx0KXt2YXIgbj10LmRvbUFQSSh0KTtyZXR1cm4gbi51cGRhdGUoZSksZnVuY3Rpb24odCl7aWYodCl7aWYodC5jc3M9PT1lLmNzcyYmdC5tZWRpYT09PWUubWVkaWEmJnQuc291cmNlTWFwPT09ZS5zb3VyY2VNYXAmJnQuc3VwcG9ydHM9PT1lLnN1cHBvcnRzJiZ0LmxheWVyPT09ZS5sYXllcilyZXR1cm47bi51cGRhdGUoZT10KX1lbHNlIG4ucmVtb3ZlKCl9fWUuZXhwb3J0cz1mdW5jdGlvbihlLG8pe3ZhciBhPXIoZT1lfHxbXSxvPW98fHt9KTtyZXR1cm4gZnVuY3Rpb24oZSl7ZT1lfHxbXTtmb3IodmFyIGk9MDtpPGEubGVuZ3RoO2krKyl7dmFyIHM9bihhW2ldKTt0W3NdLnJlZmVyZW5jZXMtLX1mb3IodmFyIGM9cihlLG8pLGQ9MDtkPGEubGVuZ3RoO2QrKyl7dmFyIGw9bihhW2RdKTswPT09dFtsXS5yZWZlcmVuY2VzJiYodFtsXS51cGRhdGVyKCksdC5zcGxpY2UobCwxKSl9YT1jfX19LDU2OTplPT57dmFyIHQ9e307ZS5leHBvcnRzPWZ1bmN0aW9uKGUsbil7dmFyIHI9ZnVuY3Rpb24oZSl7aWYodm9pZCAwPT09dFtlXSl7dmFyIG49ZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlKTtpZih3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQmJm4gaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpdHJ5e249bi5jb250ZW50RG9jdW1lbnQuaGVhZH1jYXRjaChlKXtuPW51bGx9dFtlXT1ufXJldHVybiB0W2VdfShlKTtpZighcil0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydCcgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO3IuYXBwZW5kQ2hpbGQobil9fSwyMTY6ZT0+e2UuZXhwb3J0cz1mdW5jdGlvbihlKXt2YXIgdD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7cmV0dXJuIGUuc2V0QXR0cmlidXRlcyh0LGUuYXR0cmlidXRlcyksZS5pbnNlcnQodCxlLm9wdGlvbnMpLHR9fSw1NjU6KGUsdCxuKT0+e2UuZXhwb3J0cz1mdW5jdGlvbihlKXt2YXIgdD1uLm5jO3QmJmUuc2V0QXR0cmlidXRlKFwibm9uY2VcIix0KX19LDc5NTplPT57ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBkb2N1bWVudClyZXR1cm57dXBkYXRlOmZ1bmN0aW9uKCl7fSxyZW1vdmU6ZnVuY3Rpb24oKXt9fTt2YXIgdD1lLmluc2VydFN0eWxlRWxlbWVudChlKTtyZXR1cm57dXBkYXRlOmZ1bmN0aW9uKG4peyFmdW5jdGlvbihlLHQsbil7dmFyIHI9XCJcIjtuLnN1cHBvcnRzJiYocis9XCJAc3VwcG9ydHMgKFwiLmNvbmNhdChuLnN1cHBvcnRzLFwiKSB7XCIpKSxuLm1lZGlhJiYocis9XCJAbWVkaWEgXCIuY29uY2F0KG4ubWVkaWEsXCIge1wiKSk7dmFyIG89dm9pZCAwIT09bi5sYXllcjtvJiYocis9XCJAbGF5ZXJcIi5jb25jYXQobi5sYXllci5sZW5ndGg+MD9cIiBcIi5jb25jYXQobi5sYXllcik6XCJcIixcIiB7XCIpKSxyKz1uLmNzcyxvJiYocis9XCJ9XCIpLG4ubWVkaWEmJihyKz1cIn1cIiksbi5zdXBwb3J0cyYmKHIrPVwifVwiKTt2YXIgYT1uLnNvdXJjZU1hcDthJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgYnRvYSYmKHIrPVwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIi5jb25jYXQoYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoYSkpKSksXCIgKi9cIikpLHQuc3R5bGVUYWdUcmFuc2Zvcm0ocixlLHQub3B0aW9ucyl9KHQsZSxuKX0scmVtb3ZlOmZ1bmN0aW9uKCl7IWZ1bmN0aW9uKGUpe2lmKG51bGw9PT1lLnBhcmVudE5vZGUpcmV0dXJuITE7ZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGUpfSh0KX19fX0sNTg5OmU9PntlLmV4cG9ydHM9ZnVuY3Rpb24oZSx0KXtpZih0LnN0eWxlU2hlZXQpdC5zdHlsZVNoZWV0LmNzc1RleHQ9ZTtlbHNle2Zvcig7dC5maXJzdENoaWxkOyl0LnJlbW92ZUNoaWxkKHQuZmlyc3RDaGlsZCk7dC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShlKSl9fX19LHQ9e307ZnVuY3Rpb24gbihyKXt2YXIgbz10W3JdO2lmKHZvaWQgMCE9PW8pcmV0dXJuIG8uZXhwb3J0czt2YXIgYT10W3JdPXtpZDpyLGV4cG9ydHM6e319O3JldHVybiBlW3JdKGEsYS5leHBvcnRzLG4pLGEuZXhwb3J0c31uLm49ZT0+e3ZhciB0PWUmJmUuX19lc01vZHVsZT8oKT0+ZS5kZWZhdWx0OigpPT5lO3JldHVybiBuLmQodCx7YTp0fSksdH0sbi5kPShlLHQpPT57Zm9yKHZhciByIGluIHQpbi5vKHQscikmJiFuLm8oZSxyKSYmT2JqZWN0LmRlZmluZVByb3BlcnR5KGUscix7ZW51bWVyYWJsZTohMCxnZXQ6dFtyXX0pfSxuLm89KGUsdCk9Pk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpLG4ubmM9dm9pZCAwO3ZhciByPXt9O3JldHVybigoKT0+e24uZChyLHtkZWZhdWx0OigpPT5tfSk7dmFyIGU9bigzNzkpLHQ9bi5uKGUpLG89big3OTUpLGE9bi5uKG8pLGk9big1NjkpLHM9bi5uKGkpLGM9big1NjUpLGQ9bi5uKGMpLGw9bigyMTYpLHA9bi5uKGwpLHU9big1ODkpLGg9bi5uKHUpLGY9big0MjQpLHY9e307di5zdHlsZVRhZ1RyYW5zZm9ybT1oKCksdi5zZXRBdHRyaWJ1dGVzPWQoKSx2Lmluc2VydD1zKCkuYmluZChudWxsLFwiaGVhZFwiKSx2LmRvbUFQST1hKCksdi5pbnNlcnRTdHlsZUVsZW1lbnQ9cCgpLHQoKShmLlosdiksZi5aJiZmLloubG9jYWxzJiZmLloubG9jYWxzO2NsYXNzIG17c3RhdGljIGdldCB0b29sYm94KCl7cmV0dXJue3RpdGxlOlwiVE9DXCIsaWNvbjonPHN2ZyB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgZmlsbD1cIm5vbmVcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+XFxuICAgICAgICAgICAgICAgICAgICAgIDxnIGlkPVwiU1ZHUmVwb19iZ0NhcnJpZXJcIiBzdHJva2Utd2lkdGg9XCIwXCI+PC9nPjxnIGlkPVwiU1ZHUmVwb190cmFjZXJDYXJyaWVyXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+PC9nPjxnIGlkPVwiU1ZHUmVwb19pY29uQ2FycmllclwiPiA8cmVjdCB4PVwiNFwiIHk9XCI0XCIgd2lkdGg9XCIxNlwiIGhlaWdodD1cIjE2XCIgcng9XCIzXCIgc3Ryb2tlPVwiIzAwMDAwMFwiIHN0cm9rZS13aWR0aD1cIjJcIj48L3JlY3Q+IDxwYXRoIGQ9XCJNMTYgMTBMOCAxMFwiIHN0cm9rZT1cIiMwMDAwMDBcIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiPjwvcGF0aD4gPHBhdGggZD1cIk0xNiAxNEw4IDE0XCIgc3Ryb2tlPVwiIzAwMDAwMFwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCI+PC9wYXRoPiBcXG4gICAgICAgICAgICAgICAgICAgICAgPC9nPjwvc3ZnPid9fWNvbnN0cnVjdG9yKHtkYXRhOmUsYXBpOnQsYmxvY2s6bn0pe3RoaXMuYXBpPXQsdGhpcy5kYXRhPWUsdGhpcy5ibG9jaz1uLHRoaXMud3JhcHBlcj12b2lkIDAsdGhpcy5kYXRhLml0ZW1zPWUuaXRlbXN8fFtdfXJlbmRlcigpe3JldHVybiB0aGlzLndyYXBwZXI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSx0aGlzLndyYXBwZXIuaWQ9dGhpcy5ibG9jay5pZCx0aGlzLndyYXBwZXIuY2xhc3NMaXN0LmFkZChcInRvYy13cmFwcGVyXCIpLHRoaXMuZGF0YS5pdGVtcy5sZW5ndGg8MSYmdGhpcy5fZ2V0SGVhZGluZ3MoKSx0aGlzLl9jcmVhdGVUT0MoKSx0aGlzLndyYXBwZXJ9c3RhdGljIGdldCBpc1JlYWRPbmx5U3VwcG9ydGVkKCl7cmV0dXJuITB9X2dldEhlYWRpbmdzKCl7dGhpcy5kYXRhLml0ZW1zPVtdO2Zvcih2YXIgZT10aGlzLmFwaS5ibG9ja3MuZ2V0QmxvY2tzQ291bnQoKSx0PTA7dDxlO3QrKyl7dmFyIG49dGhpcy5hcGkuYmxvY2tzLmdldEJsb2NrQnlJbmRleCh0KTtpZihcImhlYWRlclwiPT1uLm5hbWUmJm4uaG9sZGVyLmlubmVyVGV4dCl7dmFyIHI9bi5ob2xkZXIuY2hpbGROb2Rlc1swXS5jaGlsZE5vZGVzWzBdLm5vZGVOYW1lO3I9cGFyc2VJbnQoci5yZXBsYWNlKFwiSFwiLFwiXCIpKTt2YXIgbz17aWQ6TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsMTIpLHJlZmVyZW5jZTpuLmlkLHRleHQ6bi5ob2xkZXIuaW5uZXJUZXh0LGxldmVsOnJ9O3RoaXMuZGF0YS5pdGVtcy5wdXNoKG8pfX10aGlzLl9jcmVhdGVUT0MoKX1fY3JlYXRlVE9DKCl7Y29uc3QgZT1cIi9cIituZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKS5zZWFyY2gsdD10aGlzLmRhdGEuaXRlbXM7aWYodGhpcy53cmFwcGVyLmlubmVySFRNTD1cIlwiLHQubGVuZ3RoPDEpe3ZhciBuPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJwXCIpO3JldHVybiBuLmlubmVySFRNTD10aGlzLmFwaS5pMThuLnQoXCJObyBoZWFkaW5ncyBmb3VuZFwiKSx2b2lkIHRoaXMud3JhcHBlci5hcHBlbmRDaGlsZChuKX1mb3IoY29uc3QgbiBvZiB0KXt2YXIgcj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtyLmNsYXNzTGlzdC5hZGQoXCJ0b2MtcGFyYWdyYXBoXCIsXCJ0b2MtbC1cIituLmxldmVsKSxyLnRleHRDb250ZW50PW4udGV4dCxyLnNldEF0dHJpYnV0ZShcImhyZWZcIixlK1wiI1wiK24ucmVmZXJlbmNlKSxyLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLChlPT57ZS5wcmV2ZW50RGVmYXVsdCgpLGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGUudGFyZ2V0Lmhhc2guc3Vic3RyaW5nKDEpKT8uc2Nyb2xsSW50b1ZpZXcoe2JlaGF2aW9yOlwic21vb3RoXCIsYmxvY2s6XCJzdGFydFwiLGlubGluZTpcInN0YXJ0XCJ9KSxsb2NhdGlvbi5oYXNoPWUudGFyZ2V0Lmhhc2h9KSksdGhpcy53cmFwcGVyLmFwcGVuZENoaWxkKHIpfX1yZW5kZXJTZXR0aW5ncygpe3JldHVyblt7aWNvbjonPHN2ZyB3aWR0aD1cIjE3XCIgaGVpZ2h0PVwiMTVcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmlld0JveD1cIjAgMCA0ODkuNjQ1IDQ4OS42NDVcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgPHBhdGggZD1cIk00NjAuNjU2LDEzMi45MTFjLTU4LjctMTIyLjEtMjEyLjItMTY2LjUtMzMxLjgtMTA0LjFjLTkuNCw1LjItMTMuNSwxNi42LTguMywyN2M1LjIsOS40LDE2LjYsMTMuNSwyNyw4LjNcXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGM5OS45LTUyLDIyNy40LTE0LjksMjc2LjcsODYuM2M2NS40LDEzNC4zLTE5LDIzNi43LTg3LjQsMjc0LjZjLTkzLjEsNTEuNy0yMTEuMiwxNy40LTI2Ny42LTcwLjdsNjkuMywxNC41XFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjMTAuNCwyLjEsMjEuOC00LjIsMjMuOS0xNS42YzIuMS0xMC40LTQuMi0yMS44LTE1LjYtMjMuOWwtMTIyLjgtMjVjLTIwLjYtMi0yNSwxNi42LTIzLjksMjIuOWwxNS42LDEyMy44XFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjMSwxMC40LDkuNCwxNy43LDE5LjgsMTcuN2MxMi44LDAsMjAuOC0xMi41LDE5LjgtMjMuOWwtNi01MC41YzU3LjQsNzAuOCwxNzAuMywxMzEuMiwzMDcuNCw2OC4yXFxuICAgICAgICAgICAgICAgICAgICAgICAgICBDNDE0Ljg1Niw0MzIuNTExLDU0OC4yNTYsMzE0LjgxMSw0NjAuNjU2LDEzMi45MTF6XCIvPlxcbiAgICAgICAgICAgICAgICAgIDwvc3ZnPicsbmFtZTpcInJlZnJlc2hcIixsYWJlbDp0aGlzLmFwaS5pMThuLnQoXCJSZWZyZXNoXCIpLHRvZ2dsZTpcInRvY1wiLG9uQWN0aXZhdGU6KCk9Pnt0aGlzLl9nZXRIZWFkaW5ncygpfX1dfXNhdmUoZSl7cmV0dXJue2l0ZW1zOnRoaXMuZGF0YS5pdGVtc319fX0pKCksci5kZWZhdWx0fSkoKSkpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@phigoro/editorjs-toc/dist/bundle.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/editorjs-alert/dist/bundle.js":
/*!****************************************************!*\
  !*** ./node_modules/editorjs-alert/dist/bundle.js ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/*! For license information please see bundle.js.LICENSE.txt */\n!function(e,t){ true?module.exports=t():0}(self,(()=>(()=>{var e={800:(e,t,r)=>{\"use strict\";r.d(t,{Z:()=>c});var n=r(81),o=r.n(n),a=r(645),i=r.n(a)()(o());i.push([e.id,\".cdx-alert{position:relative;padding:10px;border-radius:5px;margin-bottom:10px}.cdx-alert-primary{background-color:#ebf8ff;border:1px solid #4299e1;color:#2b6cb0}.cdx-alert-secondary{background-color:#f7fafc;border:1px solid #cbd5e0;color:#222731}.cdx-alert-info{background-color:#e6fdff;border:1px solid #4cd4ce;color:#00727c}.cdx-alert-success{background-color:#f0fff4;border:1px solid #68d391;color:#2f855a}.cdx-alert-warning{background-color:#fffaf0;border:1px solid #ed8936;color:#c05621}.cdx-alert-danger{background-color:#fff5f5;border:1px solid #fc8181;color:#c53030}.cdx-alert-light{background-color:#fff;border:1px solid #edf2f7;color:#1a202c}.cdx-alert-dark{background-color:#2d3748;border:1px solid #1a202c;color:#d3d3d3}.cdx-alert-align-left{text-align:left}.cdx-alert-align-center{text-align:center}.cdx-alert-align-right{text-align:right}.cdx-alert__message{outline:none}.cdx-alert [contentEditable=true][data-placeholder]::before{position:absolute;content:attr(data-placeholder);color:#707684;font-weight:normal;opacity:0}.cdx-alert [contentEditable=true][data-placeholder]:empty::before{opacity:1}.cdx-alert [contentEditable=true][data-placeholder]:empty:focus::before{opacity:0}.ce-popover__item[data-item-name=alert-primary] .ce-popover__item-icon svg #background{fill:#ebf8ff;stroke:#4299e1}.ce-popover__item[data-item-name=alert-primary] .ce-popover__item-icon svg #content{fill:#2b6cb0}.ce-popover__item[data-item-name=alert-secondary] .ce-popover__item-icon svg #background{fill:#f7fafc;stroke:#cbd5e0}.ce-popover__item[data-item-name=alert-secondary] .ce-popover__item-icon svg #content{fill:#222731}.ce-popover__item[data-item-name=alert-info] .ce-popover__item-icon svg #background{fill:#e6fdff;stroke:#4cd4ce}.ce-popover__item[data-item-name=alert-info] .ce-popover__item-icon svg #content{fill:#00727c}.ce-popover__item[data-item-name=alert-success] .ce-popover__item-icon svg #background{fill:#f0fff4;stroke:#68d391}.ce-popover__item[data-item-name=alert-success] .ce-popover__item-icon svg #content{fill:#2f855a}.ce-popover__item[data-item-name=alert-warning] .ce-popover__item-icon svg #background{fill:#fffaf0;stroke:#ed8936}.ce-popover__item[data-item-name=alert-warning] .ce-popover__item-icon svg #content{fill:#c05621}.ce-popover__item[data-item-name=alert-danger] .ce-popover__item-icon svg #background{fill:#fff5f5;stroke:#fc8181}.ce-popover__item[data-item-name=alert-danger] .ce-popover__item-icon svg #content{fill:#c53030}.ce-popover__item[data-item-name=alert-light] .ce-popover__item-icon svg #background{fill:#fff;stroke:#edf2f7}.ce-popover__item[data-item-name=alert-light] .ce-popover__item-icon svg #content{fill:#1a202c}.ce-popover__item[data-item-name=alert-dark] .ce-popover__item-icon svg #background{fill:#2d3748;stroke:#1a202c}.ce-popover__item[data-item-name=alert-dark] .ce-popover__item-icon svg #content{fill:#d3d3d3}\",\"\"]);const c=i},645:e=>{\"use strict\";e.exports=function(e){var t=[];return t.toString=function(){return this.map((function(t){var r=\"\",n=void 0!==t[5];return t[4]&&(r+=\"@supports (\".concat(t[4],\") {\")),t[2]&&(r+=\"@media \".concat(t[2],\" {\")),n&&(r+=\"@layer\".concat(t[5].length>0?\" \".concat(t[5]):\"\",\" {\")),r+=e(t),n&&(r+=\"}\"),t[2]&&(r+=\"}\"),t[4]&&(r+=\"}\"),r})).join(\"\")},t.i=function(e,r,n,o,a){\"string\"==typeof e&&(e=[[null,e,void 0]]);var i={};if(n)for(var c=0;c<this.length;c++){var l=this[c][0];null!=l&&(i[l]=!0)}for(var s=0;s<e.length;s++){var p=[].concat(e[s]);n&&i[p[0]]||(void 0!==a&&(void 0===p[5]||(p[1]=\"@layer\".concat(p[5].length>0?\" \".concat(p[5]):\"\",\" {\").concat(p[1],\"}\")),p[5]=a),r&&(p[2]?(p[1]=\"@media \".concat(p[2],\" {\").concat(p[1],\"}\"),p[2]=r):p[2]=r),o&&(p[4]?(p[1]=\"@supports (\".concat(p[4],\") {\").concat(p[1],\"}\"),p[4]=o):p[4]=\"\".concat(o)),t.push(p))}},t}},81:e=>{\"use strict\";e.exports=function(e){return e[1]}},620:(e,t,r)=>{\"use strict\";var n=r(379),o=r.n(n),a=r(795),i=r.n(a),c=r(569),l=r.n(c),s=r(565),p=r.n(s),d=r(216),u=r.n(d),f=r(589),g=r.n(f),m=r(800),v={};v.styleTagTransform=g(),v.setAttributes=p(),v.insert=l().bind(null,\"head\"),v.domAPI=i(),v.insertStyleElement=u(),o()(m.Z,v),m.Z&&m.Z.locals&&m.Z.locals},379:e=>{\"use strict\";var t=[];function r(e){for(var r=-1,n=0;n<t.length;n++)if(t[n].identifier===e){r=n;break}return r}function n(e,n){for(var a={},i=[],c=0;c<e.length;c++){var l=e[c],s=n.base?l[0]+n.base:l[0],p=a[s]||0,d=\"\".concat(s,\" \").concat(p);a[s]=p+1;var u=r(d),f={css:l[1],media:l[2],sourceMap:l[3],supports:l[4],layer:l[5]};if(-1!==u)t[u].references++,t[u].updater(f);else{var g=o(f,n);n.byIndex=c,t.splice(c,0,{identifier:d,updater:g,references:1})}i.push(d)}return i}function o(e,t){var r=t.domAPI(t);return r.update(e),function(t){if(t){if(t.css===e.css&&t.media===e.media&&t.sourceMap===e.sourceMap&&t.supports===e.supports&&t.layer===e.layer)return;r.update(e=t)}else r.remove()}}e.exports=function(e,o){var a=n(e=e||[],o=o||{});return function(e){e=e||[];for(var i=0;i<a.length;i++){var c=r(a[i]);t[c].references--}for(var l=n(e,o),s=0;s<a.length;s++){var p=r(a[s]);0===t[p].references&&(t[p].updater(),t.splice(p,1))}a=l}}},569:e=>{\"use strict\";var t={};e.exports=function(e,r){var n=function(e){if(void 0===t[e]){var r=document.querySelector(e);if(window.HTMLIFrameElement&&r instanceof window.HTMLIFrameElement)try{r=r.contentDocument.head}catch(e){r=null}t[e]=r}return t[e]}(e);if(!n)throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");n.appendChild(r)}},216:e=>{\"use strict\";e.exports=function(e){var t=document.createElement(\"style\");return e.setAttributes(t,e.attributes),e.insert(t,e.options),t}},565:(e,t,r)=>{\"use strict\";e.exports=function(e){var t=r.nc;t&&e.setAttribute(\"nonce\",t)}},795:e=>{\"use strict\";e.exports=function(e){if(\"undefined\"==typeof document)return{update:function(){},remove:function(){}};var t=e.insertStyleElement(e);return{update:function(r){!function(e,t,r){var n=\"\";r.supports&&(n+=\"@supports (\".concat(r.supports,\") {\")),r.media&&(n+=\"@media \".concat(r.media,\" {\"));var o=void 0!==r.layer;o&&(n+=\"@layer\".concat(r.layer.length>0?\" \".concat(r.layer):\"\",\" {\")),n+=r.css,o&&(n+=\"}\"),r.media&&(n+=\"}\"),r.supports&&(n+=\"}\");var a=r.sourceMap;a&&\"undefined\"!=typeof btoa&&(n+=\"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(a)))),\" */\")),t.styleTagTransform(n,e,t.options)}(t,e,r)},remove:function(){!function(e){if(null===e.parentNode)return!1;e.parentNode.removeChild(e)}(t)}}}},589:e=>{\"use strict\";e.exports=function(e,t){if(t.styleSheet)t.styleSheet.cssText=e;else{for(;t.firstChild;)t.removeChild(t.firstChild);t.appendChild(document.createTextNode(e))}}},749:e=>{e.exports='<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M18 7L6 7\"></path><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M18 17H6\"></path><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M16 12L8 12\"></path></svg>'},454:e=>{e.exports='<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M17 7L5 7\"></path><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M17 17H5\"></path><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M13 12L5 12\"></path></svg>'},431:e=>{e.exports='<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M19 7L7 7\"></path><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M19 17H7\"></path><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M19 12L11 12\"></path></svg>'},654:e=>{e.exports='<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M5 12a7 7 90 0 1 14 0 7 7 90 0 1-14 0zM12 9.02v-.01M12 12v3\"></path></svg>'},338:e=>{e.exports='<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\"><rect id=\"background\" width=\"18\" height=\"18\" x=\"3\" y=\"3\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1\" rx=\"4\"></rect><path id=\"content\" fill=\"currentColor\" stroke-width=\"0\" d=\"m15.579 16.9-1.042-2.25H10.15L9.11 16.9H7.113L11.697 7h1.266l4.612 9.9h-1.998Zm-4.613-4.05h2.755l-1.377-2.953-1.379 2.953Z\"></path></svg>'}},t={};function r(n){var o=t[n];if(void 0!==o)return o.exports;var a=t[n]={id:n,exports:{}};return e[n](a,a.exports,r),a.exports}r.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return r.d(t,{a:t}),t},r.d=(e,t)=>{for(var n in t)r.o(t,n)&&!r.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r.nc=void 0;var n={};return(()=>{\"use strict\";r.d(n,{default:()=>_});var e=r(654),t=r.n(e),o=r(338),a=r.n(o),i=r(454),c=r.n(i),l=r(749),s=r.n(l),p=r(431),d=r.n(p);function u(e){return u=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&\"function\"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?\"symbol\":typeof e},u(e)}function f(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function g(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?f(Object(r),!0).forEach((function(t){m(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):f(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function m(e,t,r){return(t=b(t))in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function v(e){return function(e){if(Array.isArray(e))return h(e)}(e)||function(e){if(\"undefined\"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e[\"@@iterator\"])return Array.from(e)}(e)||function(e,t){if(e){if(\"string\"==typeof e)return h(e,t);var r=Object.prototype.toString.call(e).slice(8,-1);return\"Object\"===r&&e.constructor&&(r=e.constructor.name),\"Map\"===r||\"Set\"===r?Array.from(e):\"Arguments\"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?h(e,t):void 0}}(e)||function(){throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")}()}function h(e,t){(null==t||t>e.length)&&(t=e.length);for(var r=0,n=new Array(t);r<t;r++)n[r]=e[r];return n}function y(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(e,b(n.key),n)}}function b(e){var t=function(e,t){if(\"object\"!==u(e)||null===e)return e;var r=e[Symbol.toPrimitive];if(void 0!==r){var n=r.call(e,\"string\");if(\"object\"!==u(n))return n;throw new TypeError(\"@@toPrimitive must return a primitive value.\")}return String(e)}(e);return\"symbol\"===u(t)?t:String(t)}r(620).toString();var _=function(){function e(t){var r=t.data,n=t.config,o=t.api,a=t.readOnly;!function(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,e),this.api=o,this.alertTypes=n.alertTypes||e.ALERT_TYPES,this.defaultType=n.defaultType||e.DEFAULT_TYPE,this.defaultAlign=n.defaultAlign||e.DEFAULT_ALIGN_TYPE,this.messagePlaceholder=n.messagePlaceholder||e.DEFAULT_MESSAGE_PLACEHOLDER,this.data={type:this.alertTypes.includes(r.type)?r.type:this.defaultType,align:e.ALIGN_TYPES.includes(r.align)?r.align:this.defaultAlign,message:r.message||\"\"},this.container=void 0,this.readOnly=a}var r,n,o;return r=e,n=[{key:\"CSS\",get:function(){return{wrapper:\"cdx-alert\",wrapperForType:function(e){return\"cdx-alert-\".concat(e)},wrapperForAlignType:function(e){return\"cdx-alert-align-\".concat(e)},message:\"cdx-alert__message\"}}},{key:\"render\",value:function(){var e=[this.CSS.wrapper,this.CSS.wrapperForType(this.data.type),this.CSS.wrapperForAlignType(this.data.align)];this.container=this._make(\"div\",e);var t=this._make(\"div\",[this.CSS.message],{contentEditable:!this.readOnly,innerHTML:this.data.message});return t.dataset.placeholder=this.messagePlaceholder,this.container.appendChild(t),this.container}},{key:\"renderSettings\",value:function(){var t=this,r=this.alertTypes.map((function(e){return{icon:a(),name:\"alert-\".concat(e),label:t._getFormattedName(e),toggle:\"alert\",isActive:t.data.type===e,onActivate:function(){t._changeAlertType(e)}}})),n=e.ALIGN_TYPES.map((function(e){return{icon:\"left\"==e?c():\"center\"==e?s():\"right\"==e?d():IconAlign_left,name:\"align-\".concat(e),label:t._getFormattedName(e),toggle:\"align\",isActive:t.data.align===e,onActivate:function(){t._changeAlignType(e)}}}));return[].concat(v(r),v(n))}},{key:\"_getFormattedName\",value:function(e){return this.api.i18n.t(e.charAt(0).toUpperCase()+e.slice(1))}},{key:\"_changeAlertType\",value:function(e){var t=this;this.data.type=e,this.alertTypes.forEach((function(r){var n=t.CSS.wrapperForType(r);t.container.classList.remove(n),e===r&&t.container.classList.add(n)}))}},{key:\"_changeAlignType\",value:function(t){var r=this;this.data.align=t,e.ALIGN_TYPES.forEach((function(e){var n=r.CSS.wrapperForAlignType(e);r.container.classList.remove(n),t===e&&r.container.classList.add(n)}))}},{key:\"save\",value:function(e){var t=e.querySelector(\".\".concat(this.CSS.message));return g(g({},this.data),{},{message:t.innerHTML})}},{key:\"_make\",value:function(e){var t,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},o=document.createElement(e);for(var a in Array.isArray(r)?(t=o.classList).add.apply(t,v(r)):r&&o.classList.add(r),n)o[a]=n[a];return o}},{key:\"onPaste\",value:function(e){var t=e.detail.data;this.data={type:this.defaultType,message:t.innerHTML||\"\"}}}],o=[{key:\"toolbox\",get:function(){return{icon:t(),title:\"Alert\"}}},{key:\"enableLineBreaks\",get:function(){return!0}},{key:\"DEFAULT_TYPE\",get:function(){return\"info\"}},{key:\"DEFAULT_ALIGN_TYPE\",get:function(){return\"left\"}},{key:\"DEFAULT_MESSAGE_PLACEHOLDER\",get:function(){return\"Type here...\"}},{key:\"ALERT_TYPES\",get:function(){return[\"primary\",\"secondary\",\"info\",\"success\",\"warning\",\"danger\",\"light\",\"dark\"]}},{key:\"ALIGN_TYPES\",get:function(){return[\"left\",\"center\",\"right\"]}},{key:\"isReadOnlySupported\",get:function(){return!0}},{key:\"conversionConfig\",get:function(){var e=this;return{export:function(e){return e.message},import:function(t){return{message:t,type:e.DEFAULT_TYPE,alignType:e.DEFAULT_ALIGN_TYPE}}}}},{key:\"sanitize\",get:function(){return{message:!0,type:!1,alignType:!1}}}],n&&y(r.prototype,n),o&&y(r,o),Object.defineProperty(r,\"prototype\",{writable:!1}),e}()})(),n.default})()));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9lZGl0b3Jqcy1hbGVydC9kaXN0L2J1bmRsZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGVBQWUsS0FBaUQsb0JBQW9CLENBQXlHLENBQUMsaUJBQWlCLE9BQU8sY0FBYyxhQUFhLE9BQU8sUUFBUSxFQUFFLDhDQUE4Qyx5QkFBeUIsa0JBQWtCLGFBQWEsa0JBQWtCLG1CQUFtQixtQkFBbUIseUJBQXlCLHlCQUF5QixjQUFjLHFCQUFxQix5QkFBeUIseUJBQXlCLGNBQWMsZ0JBQWdCLHlCQUF5Qix5QkFBeUIsY0FBYyxtQkFBbUIseUJBQXlCLHlCQUF5QixjQUFjLG1CQUFtQix5QkFBeUIseUJBQXlCLGNBQWMsa0JBQWtCLHlCQUF5Qix5QkFBeUIsY0FBYyxpQkFBaUIsc0JBQXNCLHlCQUF5QixjQUFjLGdCQUFnQix5QkFBeUIseUJBQXlCLGNBQWMsc0JBQXNCLGdCQUFnQix3QkFBd0Isa0JBQWtCLHVCQUF1QixpQkFBaUIsb0JBQW9CLGFBQWEsNERBQTRELGtCQUFrQiwrQkFBK0IsY0FBYyxtQkFBbUIsVUFBVSxrRUFBa0UsVUFBVSx3RUFBd0UsVUFBVSx1RkFBdUYsYUFBYSxlQUFlLG9GQUFvRixhQUFhLHlGQUF5RixhQUFhLGVBQWUsc0ZBQXNGLGFBQWEsb0ZBQW9GLGFBQWEsZUFBZSxpRkFBaUYsYUFBYSx1RkFBdUYsYUFBYSxlQUFlLG9GQUFvRixhQUFhLHVGQUF1RixhQUFhLGVBQWUsb0ZBQW9GLGFBQWEsc0ZBQXNGLGFBQWEsZUFBZSxtRkFBbUYsYUFBYSxxRkFBcUYsVUFBVSxlQUFlLGtGQUFrRixhQUFhLG9GQUFvRixhQUFhLGVBQWUsaUZBQWlGLGFBQWEsT0FBTyxVQUFVLFNBQVMsYUFBYSxzQkFBc0IsU0FBUyw2QkFBNkIsNkJBQTZCLHlCQUF5QiwrQ0FBK0MsdUNBQXVDLGdFQUFnRSxxQkFBcUIsZUFBZSxlQUFlLEtBQUssWUFBWSx5QkFBeUIsMENBQTBDLFNBQVMsaUJBQWlCLGNB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YSxjQUFjLEVBQUUsb0JBQW9CLEdBQUcsRUFBRSw4QkFBOEIsK0hBQStILDZCQUE2QixrR0FBa0csVUFBVSxFQUFFLGdDQUFnQyxvQkFBb0IsV0FBVyxnREFBZ0QsTUFBTSw2QkFBNkIsT0FBTyx5QkFBeUIsRUFBRSxzQ0FBc0MsVUFBVSxFQUFFLGtDQUFrQyxjQUFjLEVBQUUsd0NBQXdDLGNBQWMsRUFBRSxpREFBaUQsc0JBQXNCLEVBQUUsaUNBQWlDLGtGQUFrRixFQUFFLGlDQUFpQyxpQ0FBaUMsRUFBRSx5Q0FBeUMsVUFBVSxFQUFFLHNDQUFzQyxXQUFXLE9BQU8sbUJBQW1CLGlCQUFpQixvQkFBb0IsT0FBTyxpRUFBaUUsRUFBRSw4QkFBOEIsT0FBTyxrQ0FBa0MscUVBQXFFLFlBQVksSUFBSSxHQUFHLGNBQWMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2VkaXRvcmpzLWFsZXJ0L2Rpc3QvYnVuZGxlLmpzP2NiZWYiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIEZvciBsaWNlbnNlIGluZm9ybWF0aW9uIHBsZWFzZSBzZWUgYnVuZGxlLmpzLkxJQ0VOU0UudHh0ICovXG4hZnVuY3Rpb24oZSx0KXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz10KCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXSx0KTpcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9leHBvcnRzLkFsZXJ0PXQoKTplLkFsZXJ0PXQoKX0oc2VsZiwoKCk9PigoKT0+e3ZhciBlPXs4MDA6KGUsdCxyKT0+e1widXNlIHN0cmljdFwiO3IuZCh0LHtaOigpPT5jfSk7dmFyIG49cig4MSksbz1yLm4obiksYT1yKDY0NSksaT1yLm4oYSkoKShvKCkpO2kucHVzaChbZS5pZCxcIi5jZHgtYWxlcnR7cG9zaXRpb246cmVsYXRpdmU7cGFkZGluZzoxMHB4O2JvcmRlci1yYWRpdXM6NXB4O21hcmdpbi1ib3R0b206MTBweH0uY2R4LWFsZXJ0LXByaW1hcnl7YmFja2dyb3VuZC1jb2xvcjojZWJmOGZmO2JvcmRlcjoxcHggc29saWQgIzQyOTllMTtjb2xvcjojMmI2Y2IwfS5jZHgtYWxlcnQtc2Vjb25kYXJ5e2JhY2tncm91bmQtY29sb3I6I2Y3ZmFmYztib3JkZXI6MXB4IHNvbGlkICNjYmQ1ZTA7Y29sb3I6IzIyMjczMX0uY2R4LWFsZXJ0LWluZm97YmFja2dyb3VuZC1jb2xvcjojZTZmZGZmO2JvcmRlcjoxcHggc29saWQgIzRjZDRjZTtjb2xvcjojMDA3MjdjfS5jZHgtYWxlcnQtc3VjY2Vzc3tiYWNrZ3JvdW5kLWNvbG9yOiNmMGZmZjQ7Ym9yZGVyOjFweCBzb2xpZCAjNjhkMzkxO2NvbG9yOiMyZjg1NWF9LmNkeC1hbGVydC13YXJuaW5ne2JhY2tncm91bmQtY29sb3I6I2ZmZmFmMDtib3JkZXI6MXB4IHNvbGlkICNlZDg5MzY7Y29sb3I6I2MwNTYyMX0uY2R4LWFsZXJ0LWRhbmdlcntiYWNrZ3JvdW5kLWNvbG9yOiNmZmY1ZjU7Ym9yZGVyOjFweCBzb2xpZCAjZmM4MTgxO2NvbG9yOiNjNTMwMzB9LmNkeC1hbGVydC1saWdodHtiYWNrZ3JvdW5kLWNvbG9yOiNmZmY7Ym9yZGVyOjFweCBzb2xpZCAjZWRmMmY3O2NvbG9yOiMxYTIwMmN9LmNkeC1hbGVydC1kYXJre2JhY2tncm91bmQtY29sb3I6IzJkMzc0ODtib3JkZXI6MXB4IHNvbGlkICMxYTIwMmM7Y29sb3I6I2QzZDNkM30uY2R4LWFsZXJ0LWFsaWduLWxlZnR7dGV4dC1hbGlnbjpsZWZ0fS5jZHgtYWxlcnQtYWxpZ24tY2VudGVye3RleHQtYWxpZ246Y2VudGVyfS5jZHgtYWxlcnQtYWxpZ24tcmlnaHR7dGV4dC1hbGlnbjpyaWdodH0uY2R4LWFsZXJ0X19tZXNzYWdle291dGxpbmU6bm9uZX0uY2R4LWFsZXJ0IFtjb250ZW50RWRpdGFibGU9dHJ1ZV1bZGF0YS1wbGFjZWhvbGRlcl06OmJlZm9yZXtwb3NpdGlvbjphYnNvbHV0ZTtjb250ZW50OmF0dHIoZGF0YS1wbGFjZWhvbGRlcik7Y29sb3I6IzcwNzY4NDtmb250LXdlaWdodDpub3JtYWw7b3BhY2l0eTowfS5jZHgtYWxlcnQgW2NvbnRlbnRFZGl0YWJsZT10cnVlXVtkYXRhLXBsYWNlaG9sZGVyXTplbXB0eTo6YmVmb3Jle29wYWNpdHk6MX0uY2R4LWFsZXJ0IFtjb250ZW50RWRpdGFibGU9dHJ1ZV1bZGF0YS1wbGFjZWhvbGRlcl06ZW1wdHk6Zm9jdXM6OmJlZm9yZXtvcGFjaXR5OjB9LmNlLXBvcG92ZXJfX2l0ZW1bZGF0YS1pdGVtLW5hbWU9YWxlcnQtcHJpbWFyeV0gLmNlLXBvcG92ZXJfX2l0ZW0taWNvbiBzdmcgI2JhY2tncm91bmR7ZmlsbDojZWJmOGZmO3N0cm9rZTojNDI5OWUxfS5jZS1wb3BvdmVyX19pdGVtW2RhdGEtaXRlbS1uYW1lPWFsZXJ0LXByaW1hcnldIC5jZS1wb3BvdmVyX19pdGVtLWljb24gc3ZnICNjb250ZW50e2ZpbGw6IzJiNmNiMH0uY2UtcG9wb3Zlcl9faXRlbVtkYXRhLWl0ZW0tbmFtZT1hbGVydC1zZWNvbmRhcnldIC5jZS1wb3BvdmVyX19pdGVtLWljb24gc3ZnICNiYWNrZ3JvdW5ke2ZpbGw6I2Y3ZmFmYztzdHJva2U6I2NiZDVlMH0uY2UtcG9wb3Zlcl9faXRlbVtkYXRhLWl0ZW0tbmFtZT1hbGVydC1zZWNvbmRhcnldIC5jZS1wb3BvdmVyX19pdGVtLWljb24gc3ZnICNjb250ZW50e2ZpbGw6IzIyMjczMX0uY2UtcG9wb3Zlcl9faXRlbVtkYXRhLWl0ZW0tbmFtZT1hbGVydC1pbmZvXSAuY2UtcG9wb3Zlcl9faXRlbS1pY29uIHN2ZyAjYmFja2dyb3VuZHtmaWxsOiNlNmZkZmY7c3Ryb2tlOiM0Y2Q0Y2V9LmNlLXBvcG92ZXJfX2l0ZW1bZGF0YS1pdGVtLW5hbWU9YWxlcnQtaW5mb10gLmNlLXBvcG92ZXJfX2l0ZW0taWNvbiBzdmcgI2NvbnRlbnR7ZmlsbDojMDA3MjdjfS5jZS1wb3BvdmVyX19pdGVtW2RhdGEtaXRlbS1uYW1lPWFsZXJ0LXN1Y2Nlc3NdIC5jZS1wb3BvdmVyX19pdGVtLWljb24gc3ZnICNiYWNrZ3JvdW5ke2ZpbGw6I2YwZmZmNDtzdHJva2U6IzY4ZDM5MX0uY2UtcG9wb3Zlcl9faXRlbVtkYXRhLWl0ZW0tbmFtZT1hbGVydC1zdWNjZXNzXSAuY2UtcG9wb3Zlcl9faXRlbS1pY29uIHN2ZyAjY29udGVudHtmaWxsOiMyZjg1NWF9LmNlLXBvcG92ZXJfX2l0ZW1bZGF0YS1pdGVtLW5hbWU9YWxlcnQtd2FybmluZ10gLmNlLXBvcG92ZXJfX2l0ZW0taWNvbiBzdmcgI2JhY2tncm91bmR7ZmlsbDojZmZmYWYwO3N0cm9rZTojZWQ4OTM2fS5jZS1wb3BvdmVyX19pdGVtW2RhdGEtaXRlbS1uYW1lPWFsZXJ0LXdhcm5pbmddIC5jZS1wb3BvdmVyX19pdGVtLWljb24gc3ZnICNjb250ZW50e2ZpbGw6I2MwNTYyMX0uY2UtcG9wb3Zlcl9faXRlbVtkYXRhLWl0ZW0tbmFtZT1hbGVydC1kYW5nZXJdIC5jZS1wb3BvdmVyX19pdGVtLWljb24gc3ZnICNiYWNrZ3JvdW5ke2ZpbGw6I2ZmZjVmNTtzdHJva2U6I2ZjODE4MX0uY2UtcG9wb3Zlcl9faXRlbVtkYXRhLWl0ZW0tbmFtZT1hbGVydC1kYW5nZXJdIC5jZS1wb3BvdmVyX19pdGVtLWljb24gc3ZnICNjb250ZW50e2ZpbGw6I2M1MzAzMH0uY2UtcG9wb3Zlcl9faXRlbVtkYXRhLWl0ZW0tbmFtZT1hbGVydC1saWdodF0gLmNlLXBvcG92ZXJfX2l0ZW0taWNvbiBzdmcgI2JhY2tncm91bmR7ZmlsbDojZmZmO3N0cm9rZTojZWRmMmY3fS5jZS1wb3BvdmVyX19pdGVtW2RhdGEtaXRlbS1uYW1lPWFsZXJ0LWxpZ2h0XSAuY2UtcG9wb3Zlcl9faXRlbS1pY29uIHN2ZyAjY29udGVudHtmaWxsOiMxYTIwMmN9LmNlLXBvcG92ZXJfX2l0ZW1bZGF0YS1pdGVtLW5hbWU9YWxlcnQtZGFya10gLmNlLXBvcG92ZXJfX2l0ZW0taWNvbiBzdmcgI2JhY2tncm91bmR7ZmlsbDojMmQzNzQ4O3N0cm9rZTojMWEyMDJjfS5jZS1wb3BvdmVyX19pdGVtW2RhdGEtaXRlbS1uYW1lPWFsZXJ0LWRhcmtdIC5jZS1wb3BvdmVyX19pdGVtLWljb24gc3ZnICNjb250ZW50e2ZpbGw6I2QzZDNkM31cIixcIlwiXSk7Y29uc3QgYz1pfSw2NDU6ZT0+e1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz1mdW5jdGlvbihlKXt2YXIgdD1bXTtyZXR1cm4gdC50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLm1hcCgoZnVuY3Rpb24odCl7dmFyIHI9XCJcIixuPXZvaWQgMCE9PXRbNV07cmV0dXJuIHRbNF0mJihyKz1cIkBzdXBwb3J0cyAoXCIuY29uY2F0KHRbNF0sXCIpIHtcIikpLHRbMl0mJihyKz1cIkBtZWRpYSBcIi5jb25jYXQodFsyXSxcIiB7XCIpKSxuJiYocis9XCJAbGF5ZXJcIi5jb25jYXQodFs1XS5sZW5ndGg+MD9cIiBcIi5jb25jYXQodFs1XSk6XCJcIixcIiB7XCIpKSxyKz1lKHQpLG4mJihyKz1cIn1cIiksdFsyXSYmKHIrPVwifVwiKSx0WzRdJiYocis9XCJ9XCIpLHJ9KSkuam9pbihcIlwiKX0sdC5pPWZ1bmN0aW9uKGUscixuLG8sYSl7XCJzdHJpbmdcIj09dHlwZW9mIGUmJihlPVtbbnVsbCxlLHZvaWQgMF1dKTt2YXIgaT17fTtpZihuKWZvcih2YXIgYz0wO2M8dGhpcy5sZW5ndGg7YysrKXt2YXIgbD10aGlzW2NdWzBdO251bGwhPWwmJihpW2xdPSEwKX1mb3IodmFyIHM9MDtzPGUubGVuZ3RoO3MrKyl7dmFyIHA9W10uY29uY2F0KGVbc10pO24mJmlbcFswXV18fCh2b2lkIDAhPT1hJiYodm9pZCAwPT09cFs1XXx8KHBbMV09XCJAbGF5ZXJcIi5jb25jYXQocFs1XS5sZW5ndGg+MD9cIiBcIi5jb25jYXQocFs1XSk6XCJcIixcIiB7XCIpLmNvbmNhdChwWzFdLFwifVwiKSkscFs1XT1hKSxyJiYocFsyXT8ocFsxXT1cIkBtZWRpYSBcIi5jb25jYXQocFsyXSxcIiB7XCIpLmNvbmNhdChwWzFdLFwifVwiKSxwWzJdPXIpOnBbMl09ciksbyYmKHBbNF0/KHBbMV09XCJAc3VwcG9ydHMgKFwiLmNvbmNhdChwWzRdLFwiKSB7XCIpLmNvbmNhdChwWzFdLFwifVwiKSxwWzRdPW8pOnBbNF09XCJcIi5jb25jYXQobykpLHQucHVzaChwKSl9fSx0fX0sODE6ZT0+e1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz1mdW5jdGlvbihlKXtyZXR1cm4gZVsxXX19LDYyMDooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIG49cigzNzkpLG89ci5uKG4pLGE9cig3OTUpLGk9ci5uKGEpLGM9cig1NjkpLGw9ci5uKGMpLHM9cig1NjUpLHA9ci5uKHMpLGQ9cigyMTYpLHU9ci5uKGQpLGY9cig1ODkpLGc9ci5uKGYpLG09cig4MDApLHY9e307di5zdHlsZVRhZ1RyYW5zZm9ybT1nKCksdi5zZXRBdHRyaWJ1dGVzPXAoKSx2Lmluc2VydD1sKCkuYmluZChudWxsLFwiaGVhZFwiKSx2LmRvbUFQST1pKCksdi5pbnNlcnRTdHlsZUVsZW1lbnQ9dSgpLG8oKShtLlosdiksbS5aJiZtLloubG9jYWxzJiZtLloubG9jYWxzfSwzNzk6ZT0+e1widXNlIHN0cmljdFwiO3ZhciB0PVtdO2Z1bmN0aW9uIHIoZSl7Zm9yKHZhciByPS0xLG49MDtuPHQubGVuZ3RoO24rKylpZih0W25dLmlkZW50aWZpZXI9PT1lKXtyPW47YnJlYWt9cmV0dXJuIHJ9ZnVuY3Rpb24gbihlLG4pe2Zvcih2YXIgYT17fSxpPVtdLGM9MDtjPGUubGVuZ3RoO2MrKyl7dmFyIGw9ZVtjXSxzPW4uYmFzZT9sWzBdK24uYmFzZTpsWzBdLHA9YVtzXXx8MCxkPVwiXCIuY29uY2F0KHMsXCIgXCIpLmNvbmNhdChwKTthW3NdPXArMTt2YXIgdT1yKGQpLGY9e2NzczpsWzFdLG1lZGlhOmxbMl0sc291cmNlTWFwOmxbM10sc3VwcG9ydHM6bFs0XSxsYXllcjpsWzVdfTtpZigtMSE9PXUpdFt1XS5yZWZlcmVuY2VzKyssdFt1XS51cGRhdGVyKGYpO2Vsc2V7dmFyIGc9byhmLG4pO24uYnlJbmRleD1jLHQuc3BsaWNlKGMsMCx7aWRlbnRpZmllcjpkLHVwZGF0ZXI6ZyxyZWZlcmVuY2VzOjF9KX1pLnB1c2goZCl9cmV0dXJuIGl9ZnVuY3Rpb24gbyhlLHQpe3ZhciByPXQuZG9tQVBJKHQpO3JldHVybiByLnVwZGF0ZShlKSxmdW5jdGlvbih0KXtpZih0KXtpZih0LmNzcz09PWUuY3NzJiZ0Lm1lZGlhPT09ZS5tZWRpYSYmdC5zb3VyY2VNYXA9PT1lLnNvdXJjZU1hcCYmdC5zdXBwb3J0cz09PWUuc3VwcG9ydHMmJnQubGF5ZXI9PT1lLmxheWVyKXJldHVybjtyLnVwZGF0ZShlPXQpfWVsc2Ugci5yZW1vdmUoKX19ZS5leHBvcnRzPWZ1bmN0aW9uKGUsbyl7dmFyIGE9bihlPWV8fFtdLG89b3x8e30pO3JldHVybiBmdW5jdGlvbihlKXtlPWV8fFtdO2Zvcih2YXIgaT0wO2k8YS5sZW5ndGg7aSsrKXt2YXIgYz1yKGFbaV0pO3RbY10ucmVmZXJlbmNlcy0tfWZvcih2YXIgbD1uKGUsbykscz0wO3M8YS5sZW5ndGg7cysrKXt2YXIgcD1yKGFbc10pOzA9PT10W3BdLnJlZmVyZW5jZXMmJih0W3BdLnVwZGF0ZXIoKSx0LnNwbGljZShwLDEpKX1hPWx9fX0sNTY5OmU9PntcInVzZSBzdHJpY3RcIjt2YXIgdD17fTtlLmV4cG9ydHM9ZnVuY3Rpb24oZSxyKXt2YXIgbj1mdW5jdGlvbihlKXtpZih2b2lkIDA9PT10W2VdKXt2YXIgcj1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKGUpO2lmKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCYmciBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCl0cnl7cj1yLmNvbnRlbnREb2N1bWVudC5oZWFkfWNhdGNoKGUpe3I9bnVsbH10W2VdPXJ9cmV0dXJuIHRbZV19KGUpO2lmKCFuKXRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0JyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7bi5hcHBlbmRDaGlsZChyKX19LDIxNjplPT57XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe3ZhciB0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtyZXR1cm4gZS5zZXRBdHRyaWJ1dGVzKHQsZS5hdHRyaWJ1dGVzKSxlLmluc2VydCh0LGUub3B0aW9ucyksdH19LDU2NTooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe3ZhciB0PXIubmM7dCYmZS5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLHQpfX0sNzk1OmU9PntcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9ZnVuY3Rpb24oZSl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIGRvY3VtZW50KXJldHVybnt1cGRhdGU6ZnVuY3Rpb24oKXt9LHJlbW92ZTpmdW5jdGlvbigpe319O3ZhciB0PWUuaW5zZXJ0U3R5bGVFbGVtZW50KGUpO3JldHVybnt1cGRhdGU6ZnVuY3Rpb24ocil7IWZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1cIlwiO3Iuc3VwcG9ydHMmJihuKz1cIkBzdXBwb3J0cyAoXCIuY29uY2F0KHIuc3VwcG9ydHMsXCIpIHtcIikpLHIubWVkaWEmJihuKz1cIkBtZWRpYSBcIi5jb25jYXQoci5tZWRpYSxcIiB7XCIpKTt2YXIgbz12b2lkIDAhPT1yLmxheWVyO28mJihuKz1cIkBsYXllclwiLmNvbmNhdChyLmxheWVyLmxlbmd0aD4wP1wiIFwiLmNvbmNhdChyLmxheWVyKTpcIlwiLFwiIHtcIikpLG4rPXIuY3NzLG8mJihuKz1cIn1cIiksci5tZWRpYSYmKG4rPVwifVwiKSxyLnN1cHBvcnRzJiYobis9XCJ9XCIpO3ZhciBhPXIuc291cmNlTWFwO2EmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBidG9hJiYobis9XCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiLmNvbmNhdChidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShhKSkpKSxcIiAqL1wiKSksdC5zdHlsZVRhZ1RyYW5zZm9ybShuLGUsdC5vcHRpb25zKX0odCxlLHIpfSxyZW1vdmU6ZnVuY3Rpb24oKXshZnVuY3Rpb24oZSl7aWYobnVsbD09PWUucGFyZW50Tm9kZSlyZXR1cm4hMTtlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZSl9KHQpfX19fSw1ODk6ZT0+e1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz1mdW5jdGlvbihlLHQpe2lmKHQuc3R5bGVTaGVldCl0LnN0eWxlU2hlZXQuY3NzVGV4dD1lO2Vsc2V7Zm9yKDt0LmZpcnN0Q2hpbGQ7KXQucmVtb3ZlQ2hpbGQodC5maXJzdENoaWxkKTt0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGUpKX19fSw3NDk6ZT0+e2UuZXhwb3J0cz0nPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTE4IDdMNiA3XCI+PC9wYXRoPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk0xOCAxN0g2XCI+PC9wYXRoPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk0xNiAxMkw4IDEyXCI+PC9wYXRoPjwvc3ZnPid9LDQ1NDplPT57ZS5leHBvcnRzPSc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNMTcgN0w1IDdcIj48L3BhdGg+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTE3IDE3SDVcIj48L3BhdGg+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTEzIDEyTDUgMTJcIj48L3BhdGg+PC9zdmc+J30sNDMxOmU9PntlLmV4cG9ydHM9JzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk0xOSA3TDcgN1wiPjwvcGF0aD48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNMTkgMTdIN1wiPjwvcGF0aD48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNMTkgMTJMMTEgMTJcIj48L3BhdGg+PC9zdmc+J30sNjU0OmU9PntlLmV4cG9ydHM9JzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk01IDEyYTcgNyA5MCAwIDEgMTQgMCA3IDcgOTAgMCAxLTE0IDB6TTEyIDkuMDJ2LS4wMU0xMiAxMnYzXCI+PC9wYXRoPjwvc3ZnPid9LDMzODplPT57ZS5leHBvcnRzPSc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHJlY3QgaWQ9XCJiYWNrZ3JvdW5kXCIgd2lkdGg9XCIxOFwiIGhlaWdodD1cIjE4XCIgeD1cIjNcIiB5PVwiM1wiIGZpbGw9XCJub25lXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLXdpZHRoPVwiMVwiIHJ4PVwiNFwiPjwvcmVjdD48cGF0aCBpZD1cImNvbnRlbnRcIiBmaWxsPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLXdpZHRoPVwiMFwiIGQ9XCJtMTUuNTc5IDE2LjktMS4wNDItMi4yNUgxMC4xNUw5LjExIDE2LjlINy4xMTNMMTEuNjk3IDdoMS4yNjZsNC42MTIgOS45aC0xLjk5OFptLTQuNjEzLTQuMDVoMi43NTVsLTEuMzc3LTIuOTUzLTEuMzc5IDIuOTUzWlwiPjwvcGF0aD48L3N2Zz4nfX0sdD17fTtmdW5jdGlvbiByKG4pe3ZhciBvPXRbbl07aWYodm9pZCAwIT09bylyZXR1cm4gby5leHBvcnRzO3ZhciBhPXRbbl09e2lkOm4sZXhwb3J0czp7fX07cmV0dXJuIGVbbl0oYSxhLmV4cG9ydHMsciksYS5leHBvcnRzfXIubj1lPT57dmFyIHQ9ZSYmZS5fX2VzTW9kdWxlPygpPT5lLmRlZmF1bHQ6KCk9PmU7cmV0dXJuIHIuZCh0LHthOnR9KSx0fSxyLmQ9KGUsdCk9Pntmb3IodmFyIG4gaW4gdClyLm8odCxuKSYmIXIubyhlLG4pJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxuLHtlbnVtZXJhYmxlOiEwLGdldDp0W25dfSl9LHIubz0oZSx0KT0+T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCksci5uYz12b2lkIDA7dmFyIG49e307cmV0dXJuKCgpPT57XCJ1c2Ugc3RyaWN0XCI7ci5kKG4se2RlZmF1bHQ6KCk9Pl99KTt2YXIgZT1yKDY1NCksdD1yLm4oZSksbz1yKDMzOCksYT1yLm4obyksaT1yKDQ1NCksYz1yLm4oaSksbD1yKDc0OSkscz1yLm4obCkscD1yKDQzMSksZD1yLm4ocCk7ZnVuY3Rpb24gdShlKXtyZXR1cm4gdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24oZSl7cmV0dXJuIHR5cGVvZiBlfTpmdW5jdGlvbihlKXtyZXR1cm4gZSYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZlLmNvbnN0cnVjdG9yPT09U3ltYm9sJiZlIT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiBlfSx1KGUpfWZ1bmN0aW9uIGYoZSx0KXt2YXIgcj1PYmplY3Qua2V5cyhlKTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgbj1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO3QmJihuPW4uZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLHQpLmVudW1lcmFibGV9KSkpLHIucHVzaC5hcHBseShyLG4pfXJldHVybiByfWZ1bmN0aW9uIGcoZSl7Zm9yKHZhciB0PTE7dDxhcmd1bWVudHMubGVuZ3RoO3QrKyl7dmFyIHI9bnVsbCE9YXJndW1lbnRzW3RdP2FyZ3VtZW50c1t0XTp7fTt0JTI/ZihPYmplY3QociksITApLmZvckVhY2goKGZ1bmN0aW9uKHQpe20oZSx0LHJbdF0pfSkpOk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzP09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMocikpOmYoT2JqZWN0KHIpKS5mb3JFYWNoKChmdW5jdGlvbih0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iocix0KSl9KSl9cmV0dXJuIGV9ZnVuY3Rpb24gbShlLHQscil7cmV0dXJuKHQ9Yih0KSlpbiBlP09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse3ZhbHVlOnIsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTplW3RdPXIsZX1mdW5jdGlvbiB2KGUpe3JldHVybiBmdW5jdGlvbihlKXtpZihBcnJheS5pc0FycmF5KGUpKXJldHVybiBoKGUpfShlKXx8ZnVuY3Rpb24oZSl7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmbnVsbCE9ZVtTeW1ib2wuaXRlcmF0b3JdfHxudWxsIT1lW1wiQEBpdGVyYXRvclwiXSlyZXR1cm4gQXJyYXkuZnJvbShlKX0oZSl8fGZ1bmN0aW9uKGUsdCl7aWYoZSl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpcmV0dXJuIGgoZSx0KTt2YXIgcj1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSkuc2xpY2UoOCwtMSk7cmV0dXJuXCJPYmplY3RcIj09PXImJmUuY29uc3RydWN0b3ImJihyPWUuY29uc3RydWN0b3IubmFtZSksXCJNYXBcIj09PXJ8fFwiU2V0XCI9PT1yP0FycmF5LmZyb20oZSk6XCJBcmd1bWVudHNcIj09PXJ8fC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KHIpP2goZSx0KTp2b2lkIDB9fShlKXx8ZnVuY3Rpb24oKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKX0oKX1mdW5jdGlvbiBoKGUsdCl7KG51bGw9PXR8fHQ+ZS5sZW5ndGgpJiYodD1lLmxlbmd0aCk7Zm9yKHZhciByPTAsbj1uZXcgQXJyYXkodCk7cjx0O3IrKyluW3JdPWVbcl07cmV0dXJuIG59ZnVuY3Rpb24geShlLHQpe2Zvcih2YXIgcj0wO3I8dC5sZW5ndGg7cisrKXt2YXIgbj10W3JdO24uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIG4mJihuLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxiKG4ua2V5KSxuKX19ZnVuY3Rpb24gYihlKXt2YXIgdD1mdW5jdGlvbihlLHQpe2lmKFwib2JqZWN0XCIhPT11KGUpfHxudWxsPT09ZSlyZXR1cm4gZTt2YXIgcj1lW1N5bWJvbC50b1ByaW1pdGl2ZV07aWYodm9pZCAwIT09cil7dmFyIG49ci5jYWxsKGUsXCJzdHJpbmdcIik7aWYoXCJvYmplY3RcIiE9PXUobikpcmV0dXJuIG47dGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpfXJldHVybiBTdHJpbmcoZSl9KGUpO3JldHVyblwic3ltYm9sXCI9PT11KHQpP3Q6U3RyaW5nKHQpfXIoNjIwKS50b1N0cmluZygpO3ZhciBfPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0KXt2YXIgcj10LmRhdGEsbj10LmNvbmZpZyxvPXQuYXBpLGE9dC5yZWFkT25seTshZnVuY3Rpb24oZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfSh0aGlzLGUpLHRoaXMuYXBpPW8sdGhpcy5hbGVydFR5cGVzPW4uYWxlcnRUeXBlc3x8ZS5BTEVSVF9UWVBFUyx0aGlzLmRlZmF1bHRUeXBlPW4uZGVmYXVsdFR5cGV8fGUuREVGQVVMVF9UWVBFLHRoaXMuZGVmYXVsdEFsaWduPW4uZGVmYXVsdEFsaWdufHxlLkRFRkFVTFRfQUxJR05fVFlQRSx0aGlzLm1lc3NhZ2VQbGFjZWhvbGRlcj1uLm1lc3NhZ2VQbGFjZWhvbGRlcnx8ZS5ERUZBVUxUX01FU1NBR0VfUExBQ0VIT0xERVIsdGhpcy5kYXRhPXt0eXBlOnRoaXMuYWxlcnRUeXBlcy5pbmNsdWRlcyhyLnR5cGUpP3IudHlwZTp0aGlzLmRlZmF1bHRUeXBlLGFsaWduOmUuQUxJR05fVFlQRVMuaW5jbHVkZXMoci5hbGlnbik/ci5hbGlnbjp0aGlzLmRlZmF1bHRBbGlnbixtZXNzYWdlOnIubWVzc2FnZXx8XCJcIn0sdGhpcy5jb250YWluZXI9dm9pZCAwLHRoaXMucmVhZE9ubHk9YX12YXIgcixuLG87cmV0dXJuIHI9ZSxuPVt7a2V5OlwiQ1NTXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJue3dyYXBwZXI6XCJjZHgtYWxlcnRcIix3cmFwcGVyRm9yVHlwZTpmdW5jdGlvbihlKXtyZXR1cm5cImNkeC1hbGVydC1cIi5jb25jYXQoZSl9LHdyYXBwZXJGb3JBbGlnblR5cGU6ZnVuY3Rpb24oZSl7cmV0dXJuXCJjZHgtYWxlcnQtYWxpZ24tXCIuY29uY2F0KGUpfSxtZXNzYWdlOlwiY2R4LWFsZXJ0X19tZXNzYWdlXCJ9fX0se2tleTpcInJlbmRlclwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9W3RoaXMuQ1NTLndyYXBwZXIsdGhpcy5DU1Mud3JhcHBlckZvclR5cGUodGhpcy5kYXRhLnR5cGUpLHRoaXMuQ1NTLndyYXBwZXJGb3JBbGlnblR5cGUodGhpcy5kYXRhLmFsaWduKV07dGhpcy5jb250YWluZXI9dGhpcy5fbWFrZShcImRpdlwiLGUpO3ZhciB0PXRoaXMuX21ha2UoXCJkaXZcIixbdGhpcy5DU1MubWVzc2FnZV0se2NvbnRlbnRFZGl0YWJsZTohdGhpcy5yZWFkT25seSxpbm5lckhUTUw6dGhpcy5kYXRhLm1lc3NhZ2V9KTtyZXR1cm4gdC5kYXRhc2V0LnBsYWNlaG9sZGVyPXRoaXMubWVzc2FnZVBsYWNlaG9sZGVyLHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHQpLHRoaXMuY29udGFpbmVyfX0se2tleTpcInJlbmRlclNldHRpbmdzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLHI9dGhpcy5hbGVydFR5cGVzLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJue2ljb246YSgpLG5hbWU6XCJhbGVydC1cIi5jb25jYXQoZSksbGFiZWw6dC5fZ2V0Rm9ybWF0dGVkTmFtZShlKSx0b2dnbGU6XCJhbGVydFwiLGlzQWN0aXZlOnQuZGF0YS50eXBlPT09ZSxvbkFjdGl2YXRlOmZ1bmN0aW9uKCl7dC5fY2hhbmdlQWxlcnRUeXBlKGUpfX19KSksbj1lLkFMSUdOX1RZUEVTLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJue2ljb246XCJsZWZ0XCI9PWU/YygpOlwiY2VudGVyXCI9PWU/cygpOlwicmlnaHRcIj09ZT9kKCk6SWNvbkFsaWduX2xlZnQsbmFtZTpcImFsaWduLVwiLmNvbmNhdChlKSxsYWJlbDp0Ll9nZXRGb3JtYXR0ZWROYW1lKGUpLHRvZ2dsZTpcImFsaWduXCIsaXNBY3RpdmU6dC5kYXRhLmFsaWduPT09ZSxvbkFjdGl2YXRlOmZ1bmN0aW9uKCl7dC5fY2hhbmdlQWxpZ25UeXBlKGUpfX19KSk7cmV0dXJuW10uY29uY2F0KHYociksdihuKSl9fSx7a2V5OlwiX2dldEZvcm1hdHRlZE5hbWVcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5hcGkuaTE4bi50KGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrZS5zbGljZSgxKSl9fSx7a2V5OlwiX2NoYW5nZUFsZXJ0VHlwZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7dGhpcy5kYXRhLnR5cGU9ZSx0aGlzLmFsZXJ0VHlwZXMuZm9yRWFjaCgoZnVuY3Rpb24ocil7dmFyIG49dC5DU1Mud3JhcHBlckZvclR5cGUocik7dC5jb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZShuKSxlPT09ciYmdC5jb250YWluZXIuY2xhc3NMaXN0LmFkZChuKX0pKX19LHtrZXk6XCJfY2hhbmdlQWxpZ25UeXBlXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIHI9dGhpczt0aGlzLmRhdGEuYWxpZ249dCxlLkFMSUdOX1RZUEVTLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciBuPXIuQ1NTLndyYXBwZXJGb3JBbGlnblR5cGUoZSk7ci5jb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZShuKSx0PT09ZSYmci5jb250YWluZXIuY2xhc3NMaXN0LmFkZChuKX0pKX19LHtrZXk6XCJzYXZlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5xdWVyeVNlbGVjdG9yKFwiLlwiLmNvbmNhdCh0aGlzLkNTUy5tZXNzYWdlKSk7cmV0dXJuIGcoZyh7fSx0aGlzLmRhdGEpLHt9LHttZXNzYWdlOnQuaW5uZXJIVE1MfSl9fSx7a2V5OlwiX21ha2VcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdCxyPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTpudWxsLG49YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOnt9LG89ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChlKTtmb3IodmFyIGEgaW4gQXJyYXkuaXNBcnJheShyKT8odD1vLmNsYXNzTGlzdCkuYWRkLmFwcGx5KHQsdihyKSk6ciYmby5jbGFzc0xpc3QuYWRkKHIpLG4pb1thXT1uW2FdO3JldHVybiBvfX0se2tleTpcIm9uUGFzdGVcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1lLmRldGFpbC5kYXRhO3RoaXMuZGF0YT17dHlwZTp0aGlzLmRlZmF1bHRUeXBlLG1lc3NhZ2U6dC5pbm5lckhUTUx8fFwiXCJ9fX1dLG89W3trZXk6XCJ0b29sYm94XCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJue2ljb246dCgpLHRpdGxlOlwiQWxlcnRcIn19fSx7a2V5OlwiZW5hYmxlTGluZUJyZWFrc1wiLGdldDpmdW5jdGlvbigpe3JldHVybiEwfX0se2tleTpcIkRFRkFVTFRfVFlQRVwiLGdldDpmdW5jdGlvbigpe3JldHVyblwiaW5mb1wifX0se2tleTpcIkRFRkFVTFRfQUxJR05fVFlQRVwiLGdldDpmdW5jdGlvbigpe3JldHVyblwibGVmdFwifX0se2tleTpcIkRFRkFVTFRfTUVTU0FHRV9QTEFDRUhPTERFUlwiLGdldDpmdW5jdGlvbigpe3JldHVyblwiVHlwZSBoZXJlLi4uXCJ9fSx7a2V5OlwiQUxFUlRfVFlQRVNcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm5bXCJwcmltYXJ5XCIsXCJzZWNvbmRhcnlcIixcImluZm9cIixcInN1Y2Nlc3NcIixcIndhcm5pbmdcIixcImRhbmdlclwiLFwibGlnaHRcIixcImRhcmtcIl19fSx7a2V5OlwiQUxJR05fVFlQRVNcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm5bXCJsZWZ0XCIsXCJjZW50ZXJcIixcInJpZ2h0XCJdfX0se2tleTpcImlzUmVhZE9ubHlTdXBwb3J0ZWRcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4hMH19LHtrZXk6XCJjb252ZXJzaW9uQ29uZmlnXCIsZ2V0OmZ1bmN0aW9uKCl7dmFyIGU9dGhpcztyZXR1cm57ZXhwb3J0OmZ1bmN0aW9uKGUpe3JldHVybiBlLm1lc3NhZ2V9LGltcG9ydDpmdW5jdGlvbih0KXtyZXR1cm57bWVzc2FnZTp0LHR5cGU6ZS5ERUZBVUxUX1RZUEUsYWxpZ25UeXBlOmUuREVGQVVMVF9BTElHTl9UWVBFfX19fX0se2tleTpcInNhbml0aXplXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJue21lc3NhZ2U6ITAsdHlwZTohMSxhbGlnblR5cGU6ITF9fX1dLG4mJnkoci5wcm90b3R5cGUsbiksbyYmeShyLG8pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwicHJvdG90eXBlXCIse3dyaXRhYmxlOiExfSksZX0oKX0pKCksbi5kZWZhdWx0fSkoKSkpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/editorjs-alert/dist/bundle.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/editorjs-change-case/dist/bundle.js":
/*!**********************************************************!*\
  !*** ./node_modules/editorjs-change-case/dist/bundle.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("!function(t,e){ true?module.exports=e():0}(window,function(){return function(t){var e={};function n(o){if(e[o])return e[o].exports;var r=e[o]={i:o,l:!1,exports:{}};return t[o].call(r.exports,r,r.exports,n),r.l=!0,r.exports}return n.m=t,n.c=e,n.d=function(t,e,o){n.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:o})},n.r=function(t){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(t,\"__esModule\",{value:!0})},n.t=function(t,e){if(1&e&&(t=n(t)),8&e)return t;if(4&e&&\"object\"==typeof t&&t&&t.__esModule)return t;var o=Object.create(null);if(n.r(o),Object.defineProperty(o,\"default\",{enumerable:!0,value:t}),2&e&&\"string\"!=typeof t)for(var r in t)n.d(o,r,function(e){return t[e]}.bind(null,r));return o},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,\"a\",e),e},n.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},n.p=\"/\",n(n.s=5)}([function(t,e,n){var o=n(1);\"string\"==typeof o&&(o=[[t.i,o,\"\"]]);var r={hmr:!0,transform:void 0,insertInto:void 0};n(3)(o,r);o.locals&&(t.exports=o.locals)},function(t,e,n){(t.exports=n(2)(!1)).push([t.i,\".change-case-action {\\n    z-index: 90;\\n    user-select: none;\\n    -moz-user-select: none;\\n    -khtml-user-select: none;\\n    -webkit-user-select: none;\\n    -o-user-select: none;    \\n}\\n\\n.change-case-tool {\\n    display: -webkit-box;\\n    display: -ms-flexbox;\\n    display: flex;\\n    padding: 5px 10px;\\n    font-size: 14px;\\n    line-height: 20px;\\n    font-weight: 500;\\n    cursor: pointer;\\n    -webkit-box-align: center;\\n    -ms-flex-align: center;\\n    align-items: center;\\n}\\n\\n.change-case-tool:hover {\\n    background: #eff2f5;\\n}\\n\\n.change-case-toolbar__label {\\n    color: #707684;\\n    font-size: 11px;\\n    font-weight: 500;\\n    letter-spacing: .33px;\\n    padding: 10px 10px 5px;\\n    text-transform: uppercase;\\n    cursor: pointer;\\n}\",\"\"])},function(t,e){t.exports=function(t){var e=[];return e.toString=function(){return this.map(function(e){var n=function(t,e){var n=t[1]||\"\",o=t[3];if(!o)return n;if(e&&\"function\"==typeof btoa){var r=(s=o,\"/*# sourceMappingURL=data:application/json;charset=utf-8;base64,\"+btoa(unescape(encodeURIComponent(JSON.stringify(s))))+\" */\"),i=o.sources.map(function(t){return\"/*# sourceURL=\"+o.sourceRoot+t+\" */\"});return[n].concat(i).concat([r]).join(\"\\n\")}var s;return[n].join(\"\\n\")}(e,t);return e[2]?\"@media \"+e[2]+\"{\"+n+\"}\":n}).join(\"\")},e.i=function(t,n){\"string\"==typeof t&&(t=[[null,t,\"\"]]);for(var o={},r=0;r<this.length;r++){var i=this[r][0];\"number\"==typeof i&&(o[i]=!0)}for(r=0;r<t.length;r++){var s=t[r];\"number\"==typeof s[0]&&o[s[0]]||(n&&!s[2]?s[2]=n:n&&(s[2]=\"(\"+s[2]+\") and (\"+n+\")\"),e.push(s))}},e}},function(t,e,n){var o,r,i={},s=(o=function(){return window&&document&&document.all&&!window.atob},function(){return void 0===r&&(r=o.apply(this,arguments)),r}),a=function(t){var e={};return function(t){if(\"function\"==typeof t)return t();if(void 0===e[t]){var n=function(t){return document.querySelector(t)}.call(this,t);if(window.HTMLIFrameElement&&n instanceof window.HTMLIFrameElement)try{n=n.contentDocument.head}catch(t){n=null}e[t]=n}return e[t]}}(),c=null,l=0,u=[],f=n(4);function p(t,e){for(var n=0;n<t.length;n++){var o=t[n],r=i[o.id];if(r){r.refs++;for(var s=0;s<r.parts.length;s++)r.parts[s](o.parts[s]);for(;s<o.parts.length;s++)r.parts.push(g(o.parts[s],e))}else{var a=[];for(s=0;s<o.parts.length;s++)a.push(g(o.parts[s],e));i[o.id]={id:o.id,refs:1,parts:a}}}}function d(t,e){for(var n=[],o={},r=0;r<t.length;r++){var i=t[r],s=e.base?i[0]+e.base:i[0],a={css:i[1],media:i[2],sourceMap:i[3]};o[s]?o[s].parts.push(a):n.push(o[s]={id:s,parts:[a]})}return n}function h(t,e){var n=a(t.insertInto);if(!n)throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");var o=u[u.length-1];if(\"top\"===t.insertAt)o?o.nextSibling?n.insertBefore(e,o.nextSibling):n.appendChild(e):n.insertBefore(e,n.firstChild),u.push(e);else if(\"bottom\"===t.insertAt)n.appendChild(e);else{if(\"object\"!=typeof t.insertAt||!t.insertAt.before)throw new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");var r=a(t.insertInto+\" \"+t.insertAt.before);n.insertBefore(e,r)}}function v(t){if(null===t.parentNode)return!1;t.parentNode.removeChild(t);var e=u.indexOf(t);e>=0&&u.splice(e,1)}function b(t){var e=document.createElement(\"style\");return void 0===t.attrs.type&&(t.attrs.type=\"text/css\"),y(e,t.attrs),h(t,e),e}function y(t,e){Object.keys(e).forEach(function(n){t.setAttribute(n,e[n])})}function g(t,e){var n,o,r,i;if(e.transform&&t.css){if(!(i=e.transform(t.css)))return function(){};t.css=i}if(e.singleton){var s=l++;n=c||(c=b(e)),o=x.bind(null,n,s,!1),r=x.bind(null,n,s,!0)}else t.sourceMap&&\"function\"==typeof URL&&\"function\"==typeof URL.createObjectURL&&\"function\"==typeof URL.revokeObjectURL&&\"function\"==typeof Blob&&\"function\"==typeof btoa?(n=function(t){var e=document.createElement(\"link\");return void 0===t.attrs.type&&(t.attrs.type=\"text/css\"),t.attrs.rel=\"stylesheet\",y(e,t.attrs),h(t,e),e}(e),o=function(t,e,n){var o=n.css,r=n.sourceMap,i=void 0===e.convertToAbsoluteUrls&&r;(e.convertToAbsoluteUrls||i)&&(o=f(o));r&&(o+=\"\\n/*# sourceMappingURL=data:application/json;base64,\"+btoa(unescape(encodeURIComponent(JSON.stringify(r))))+\" */\");var s=new Blob([o],{type:\"text/css\"}),a=t.href;t.href=URL.createObjectURL(s),a&&URL.revokeObjectURL(a)}.bind(null,n,e),r=function(){v(n),n.href&&URL.revokeObjectURL(n.href)}):(n=b(e),o=function(t,e){var n=e.css,o=e.media;o&&t.setAttribute(\"media\",o);if(t.styleSheet)t.styleSheet.cssText=n;else{for(;t.firstChild;)t.removeChild(t.firstChild);t.appendChild(document.createTextNode(n))}}.bind(null,n),r=function(){v(n)});return o(t),function(e){if(e){if(e.css===t.css&&e.media===t.media&&e.sourceMap===t.sourceMap)return;o(t=e)}else r()}}t.exports=function(t,e){if(\"undefined\"!=typeof DEBUG&&DEBUG&&\"object\"!=typeof document)throw new Error(\"The style-loader cannot be used in a non-browser environment\");(e=e||{}).attrs=\"object\"==typeof e.attrs?e.attrs:{},e.singleton||\"boolean\"==typeof e.singleton||(e.singleton=s()),e.insertInto||(e.insertInto=\"head\"),e.insertAt||(e.insertAt=\"bottom\");var n=d(t,e);return p(n,e),function(t){for(var o=[],r=0;r<n.length;r++){var s=n[r];(a=i[s.id]).refs--,o.push(a)}t&&p(d(t,e),e);for(r=0;r<o.length;r++){var a;if(0===(a=o[r]).refs){for(var c=0;c<a.parts.length;c++)a.parts[c]();delete i[a.id]}}}};var m,C=(m=[],function(t,e){return m[t]=e,m.filter(Boolean).join(\"\\n\")});function x(t,e,n,o){var r=n?\"\":o.css;if(t.styleSheet)t.styleSheet.cssText=C(e,r);else{var i=document.createTextNode(r),s=t.childNodes;s[e]&&t.removeChild(s[e]),s.length?t.insertBefore(i,s[e]):t.appendChild(i)}}},function(t,e){t.exports=function(t){var e=\"undefined\"!=typeof window&&window.location;if(!e)throw new Error(\"fixUrls requires window.location\");if(!t||\"string\"!=typeof t)return t;var n=e.protocol+\"//\"+e.host,o=n+e.pathname.replace(/\\/[^\\/]*$/,\"/\");return t.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi,function(t,e){var r,i=e.trim().replace(/^\"(.*)\"$/,function(t,e){return e}).replace(/^'(.*)'$/,function(t,e){return e});return/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(i)?t:(r=0===i.indexOf(\"//\")?i:0===i.indexOf(\"/\")?n+i:o+i.replace(/^\\.\\//,\"\"),\"url(\"+JSON.stringify(r)+\")\")})}},function(t,e,n){\"use strict\";n.r(e);n(0);function o(t,e){for(var n=0;n<e.length;n++){var o=e[n];o.enumerable=o.enumerable||!1,o.configurable=!0,\"value\"in o&&(o.writable=!0),Object.defineProperty(t,o.key,o)}}function r(t,e,n){return e&&o(t.prototype,e),n&&o(t,n),t}n.d(e,\"default\",function(){return i});var i=function(){function t(e){var n=e.config,o=e.api;!function(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}(this,t),this.api=o,this.button=null,this.optionButtons=[],this._state=!0,this.selectedText=null,this.range=null,this._settings=n,this.CSS={actions:\"change-case-action\",toolbarLabel:\"change-case-toolbar__label\",tool:\"change-case-tool\",toolbarBtnActive:this.api.styles.settingsButtonActive,inlineButton:this.api.styles.inlineToolButton},this.caseOptions={titleCase:\"Title Case\",lowerCase:\"lower case\",upperCase:\"UPPER CASE\",localeLowerCase:\"local lower cas\",localeUpperCase:\"LCALE UPPER CASE\",sentenceCase:\"Sentence case\",toggleCase:\"tOOGLE cASE\"}}return r(t,[{key:\"state\",get:function(){return this._state}}],[{key:\"isInline\",get:function(){return!0}}]),r(t,[{key:\"render\",value:function(){return this.button=document.createElement(\"button\"),this.button.type=\"button\",this.button.innerHTML='\\n            <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"h-5 w-5\" fill=\"none\" viewBox=\"0 0 100 100\" stroke=\"currentColor\">\\n            <path d=\"m46.099 74.271-3.6868-13.686h-18.523l-3.6868 13.686h-11.605l17.934-57.653h13.17l18.001 57.653zm-6.2632-23.813q-5.0972-18.612-5.7524-21.056c-0.42199-1.6168-0.73293-2.9077-0.91061-3.8477q-1.1105 5.0133-6.5741 24.828z\" stroke-width=\"1.1797\"/>\\n            <path d=\"m87.355 74.271-2.4938-8.4556h-12.529l-2.4938 8.4556h-7.8496l12.131-35.619h8.9087l12.176 35.619zm-4.2365-14.712q-3.4478-11.499-3.891-13.009c-0.28544-0.99887-0.49576-1.7964-0.61595-2.3772q-0.75116 3.0973-4.4469 15.339z\" stroke-width=\".76265\"/>\\n            </svg>',this.button.classList.add(this.CSS.inlineButton),this.button}},{key:\"checkState\",value:function(t){t.anchorNode}},{key:\"convertCase\",value:function(t,e){var n=this;if(t){var o=t.cloneContents();o&&(o.childNodes.forEach(function(t){if(\"#text\"===t.nodeName)switch(e){case\"titleCase\":t.textContent=t.textContent.replace(/\\w\\S*/g,function(t){return t.charAt(0).toUpperCase()+t.slice(1,t.length).toLowerCase()});break;case\"lowerCase\":t.textContent=function(t){return t.toLowerCase()}(t.textContent);break;case\"upperCase\":t.textContent=function(t){return t.toUpperCase()}(t.textContent);break;case\"localeLowerCase\":t.textContent=function(t,e){return t.toLocaleLowerCase(e)}(t.textContent,n._settings.locale);break;case\"localeUpperCase\":t.textContent=function(t,e){return t.toLocaleUpperCase(e)}(t.textContent,n._settings.locale);break;case\"sentenceCase\":t.textContent=function(t){return t.charAt(0).toUpperCase()+t.slice(1,t.length).toLowerCase()}(t.textContent);break;case\"toggleCase\":t.textContent=function(t){return t.replace(/\\w\\S*/g,function(t){return t.charAt(0).toLowerCase()+t.slice(1,t.length).toUpperCase()})}(t.textContent)}}),t.extractContents(),t.insertNode(o),this.api.inlineToolbar.close())}}},{key:\"surround\",value:function(t){this.selectedText=t.cloneContents(),this.actions.hidden=!this.actions.hidden,this.range=this.actions.hidden?null:t,this.state=!this.actions.hidden}},{key:\"renderActions\",value:function(){var t=this;this.actions=document.createElement(\"div\"),this.actions.classList.add(this.CSS.actions);var e=document.createElement(\"div\");e.classList.add(this.CSS.toolbarLabel),e.innerHTML=\"Change Case\",this.actions.appendChild(e),this.optionButtons=Object.keys(this.caseOptions).map(function(e){var n=document.createElement(\"div\");return n.classList.add(t.CSS.tool),n.dataset.mode=e,n.innerHTML=t.caseOptions[e],n});var n=!0,o=!1,r=void 0;try{for(var i,s=function(){var e=i.value;t.actions.appendChild(e),t.api.listeners.on(e,\"click\",function(){t.convertCase(t.range,e.dataset.mode)})},a=this.optionButtons[Symbol.iterator]();!(n=(i=a.next()).done);n=!0)s()}catch(t){o=!0,r=t}finally{try{n||null==a.return||a.return()}finally{if(o)throw r}}return this.actions.hidden=!0,this.actions}},{key:\"destroy\",value:function(){var t=!0,e=!1,n=void 0;try{for(var o,r=this.optionButtons[Symbol.iterator]();!(t=(o=r.next()).done);t=!0){var i=o.value;this.api.listeners.off(i,\"click\")}}catch(t){e=!0,n=t}finally{try{t||null==r.return||r.return()}finally{if(e)throw n}}}},{key:\"state\",set:function(t){this._state=t,this.button.classList.toggle(this.CSS.toolbarBtnActive,t)}},{key:\"title\",get:function(){return\"Change Case\"}}]),t}()}])});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9lZGl0b3Jqcy1jaGFuZ2UtY2FzZS9kaXN0L2J1bmRsZS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxlQUFlLEtBQWlELG9CQUFvQixDQUFtSCxDQUFDLG1CQUFtQixtQkFBbUIsU0FBUyxjQUFjLDRCQUE0QixZQUFZLHFCQUFxQiwyREFBMkQsdUNBQXVDLHFDQUFxQyxvQkFBb0IsRUFBRSxpQkFBaUIsNEZBQTRGLGVBQWUsd0NBQXdDLFNBQVMsRUFBRSxtQkFBbUIsOEJBQThCLHFEQUFxRCwwQkFBMEIsNkNBQTZDLHNCQUFzQiw2REFBNkQsWUFBWSxlQUFlLFNBQVMsaUJBQWlCLGlDQUFpQyxpQkFBaUIsWUFBWSxVQUFVLHNCQUFzQixtQkFBbUIsaURBQWlELGtCQUFrQixrQkFBa0IsV0FBVyxxQ0FBcUMsT0FBTywyQ0FBMkMsVUFBVSwrQkFBK0IsaUJBQWlCLHFEQUFxRCxrQkFBa0Isd0JBQXdCLDZCQUE2QiwrQkFBK0IsZ0NBQWdDLCtCQUErQixHQUFHLHVCQUF1QiwyQkFBMkIsMkJBQTJCLG9CQUFvQix3QkFBd0Isc0JBQXNCLHdCQUF3Qix1QkFBdUIsc0JBQXNCLGdDQUFnQyw2QkFBNkIsMEJBQTBCLEdBQUcsNkJBQTZCLDBCQUEwQixHQUFHLGlDQUFpQyxxQkFBcUIsc0JBQXNCLHVCQUF1Qiw0QkFBNEIsNkJBQTZCLGdDQUFnQyxzQkFBc0IsR0FBRyxPQUFPLGVBQWUsc0JBQXNCLFNBQVMsNkJBQTZCLDRCQUE0QixvQkFBb0Isc0JBQXNCLGVBQWUsK0JBQStCLHVEQUF1RCxjQUFjLGtHQUFrRyw0Q0FBNEMsRUFBRSwyQ0FBMkMsTUFBTSxxQkFBcUIsTUFBTSw2QkFBNkIsTUFBTSxJQUFJLFdBQVcsbUJBQW1CLHNDQUFzQyxZQUFZLEtBQUssY0FBYyxLQUFLLGlCQUFpQiw4QkFBOEIsUUFBUSxXQUFXLEtBQUssV0FBVyxnR0FBZ0csSUFBSSxpQkFBaUIsWUFBWSxpQkFBaUIsb0RBQW9ELFlBQVksaURB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YXNlL2Rpc3QvYnVuZGxlLmpzPzhkYTciXSwic291cmNlc0NvbnRlbnQiOlsiIWZ1bmN0aW9uKHQsZSl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9ZSgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW10sZSk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/ZXhwb3J0cy5DaGFuZ2VDYXNlPWUoKTp0LkNoYW5nZUNhc2U9ZSgpfSh3aW5kb3csZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCl7dmFyIGU9e307ZnVuY3Rpb24gbihvKXtpZihlW29dKXJldHVybiBlW29dLmV4cG9ydHM7dmFyIHI9ZVtvXT17aTpvLGw6ITEsZXhwb3J0czp7fX07cmV0dXJuIHRbb10uY2FsbChyLmV4cG9ydHMscixyLmV4cG9ydHMsbiksci5sPSEwLHIuZXhwb3J0c31yZXR1cm4gbi5tPXQsbi5jPWUsbi5kPWZ1bmN0aW9uKHQsZSxvKXtuLm8odCxlKXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsZSx7ZW51bWVyYWJsZTohMCxnZXQ6b30pfSxuLnI9ZnVuY3Rpb24odCl7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLnRvU3RyaW5nVGFnJiZPYmplY3QuZGVmaW5lUHJvcGVydHkodCxTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOlwiTW9kdWxlXCJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX0sbi50PWZ1bmN0aW9uKHQsZSl7aWYoMSZlJiYodD1uKHQpKSw4JmUpcmV0dXJuIHQ7aWYoNCZlJiZcIm9iamVjdFwiPT10eXBlb2YgdCYmdCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O3ZhciBvPU9iamVjdC5jcmVhdGUobnVsbCk7aWYobi5yKG8pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOiEwLHZhbHVlOnR9KSwyJmUmJlwic3RyaW5nXCIhPXR5cGVvZiB0KWZvcih2YXIgciBpbiB0KW4uZChvLHIsZnVuY3Rpb24oZSl7cmV0dXJuIHRbZV19LmJpbmQobnVsbCxyKSk7cmV0dXJuIG99LG4ubj1mdW5jdGlvbih0KXt2YXIgZT10JiZ0Ll9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gdC5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiB0fTtyZXR1cm4gbi5kKGUsXCJhXCIsZSksZX0sbi5vPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LGUpfSxuLnA9XCIvXCIsbihuLnM9NSl9KFtmdW5jdGlvbih0LGUsbil7dmFyIG89bigxKTtcInN0cmluZ1wiPT10eXBlb2YgbyYmKG89W1t0LmksbyxcIlwiXV0pO3ZhciByPXtobXI6ITAsdHJhbnNmb3JtOnZvaWQgMCxpbnNlcnRJbnRvOnZvaWQgMH07bigzKShvLHIpO28ubG9jYWxzJiYodC5leHBvcnRzPW8ubG9jYWxzKX0sZnVuY3Rpb24odCxlLG4peyh0LmV4cG9ydHM9bigyKSghMSkpLnB1c2goW3QuaSxcIi5jaGFuZ2UtY2FzZS1hY3Rpb24ge1xcbiAgICB6LWluZGV4OiA5MDtcXG4gICAgdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAgIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAgIC1raHRtbC11c2VyLXNlbGVjdDogbm9uZTtcXG4gICAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXG4gICAgLW8tdXNlci1zZWxlY3Q6IG5vbmU7ICAgIFxcbn1cXG5cXG4uY2hhbmdlLWNhc2UtdG9vbCB7XFxuICAgIGRpc3BsYXk6IC13ZWJraXQtYm94O1xcbiAgICBkaXNwbGF5OiAtbXMtZmxleGJveDtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgcGFkZGluZzogNXB4IDEwcHg7XFxuICAgIGZvbnQtc2l6ZTogMTRweDtcXG4gICAgbGluZS1oZWlnaHQ6IDIwcHg7XFxuICAgIGZvbnQtd2VpZ2h0OiA1MDA7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gICAgLXdlYmtpdC1ib3gtYWxpZ246IGNlbnRlcjtcXG4gICAgLW1zLWZsZXgtYWxpZ246IGNlbnRlcjtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG59XFxuXFxuLmNoYW5nZS1jYXNlLXRvb2w6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kOiAjZWZmMmY1O1xcbn1cXG5cXG4uY2hhbmdlLWNhc2UtdG9vbGJhcl9fbGFiZWwge1xcbiAgICBjb2xvcjogIzcwNzY4NDtcXG4gICAgZm9udC1zaXplOiAxMXB4O1xcbiAgICBmb250LXdlaWdodDogNTAwO1xcbiAgICBsZXR0ZXItc3BhY2luZzogLjMzcHg7XFxuICAgIHBhZGRpbmc6IDEwcHggMTBweCA1cHg7XFxuICAgIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG59XCIsXCJcIl0pfSxmdW5jdGlvbih0LGUpe3QuZXhwb3J0cz1mdW5jdGlvbih0KXt2YXIgZT1bXTtyZXR1cm4gZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLm1hcChmdW5jdGlvbihlKXt2YXIgbj1mdW5jdGlvbih0LGUpe3ZhciBuPXRbMV18fFwiXCIsbz10WzNdO2lmKCFvKXJldHVybiBuO2lmKGUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGJ0b2Epe3ZhciByPShzPW8sXCIvKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIrYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkocykpKSkrXCIgKi9cIiksaT1vLnNvdXJjZXMubWFwKGZ1bmN0aW9uKHQpe3JldHVyblwiLyojIHNvdXJjZVVSTD1cIitvLnNvdXJjZVJvb3QrdCtcIiAqL1wifSk7cmV0dXJuW25dLmNvbmNhdChpKS5jb25jYXQoW3JdKS5qb2luKFwiXFxuXCIpfXZhciBzO3JldHVybltuXS5qb2luKFwiXFxuXCIpfShlLHQpO3JldHVybiBlWzJdP1wiQG1lZGlhIFwiK2VbMl0rXCJ7XCIrbitcIn1cIjpufSkuam9pbihcIlwiKX0sZS5pPWZ1bmN0aW9uKHQsbil7XCJzdHJpbmdcIj09dHlwZW9mIHQmJih0PVtbbnVsbCx0LFwiXCJdXSk7Zm9yKHZhciBvPXt9LHI9MDtyPHRoaXMubGVuZ3RoO3IrKyl7dmFyIGk9dGhpc1tyXVswXTtcIm51bWJlclwiPT10eXBlb2YgaSYmKG9baV09ITApfWZvcihyPTA7cjx0Lmxlbmd0aDtyKyspe3ZhciBzPXRbcl07XCJudW1iZXJcIj09dHlwZW9mIHNbMF0mJm9bc1swXV18fChuJiYhc1syXT9zWzJdPW46biYmKHNbMl09XCIoXCIrc1syXStcIikgYW5kIChcIituK1wiKVwiKSxlLnB1c2gocykpfX0sZX19LGZ1bmN0aW9uKHQsZSxuKXt2YXIgbyxyLGk9e30scz0obz1mdW5jdGlvbigpe3JldHVybiB3aW5kb3cmJmRvY3VtZW50JiZkb2N1bWVudC5hbGwmJiF3aW5kb3cuYXRvYn0sZnVuY3Rpb24oKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9by5hcHBseSh0aGlzLGFyZ3VtZW50cykpLHJ9KSxhPWZ1bmN0aW9uKHQpe3ZhciBlPXt9O3JldHVybiBmdW5jdGlvbih0KXtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiB0KXJldHVybiB0KCk7aWYodm9pZCAwPT09ZVt0XSl7dmFyIG49ZnVuY3Rpb24odCl7cmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodCl9LmNhbGwodGhpcyx0KTtpZih3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQmJm4gaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpdHJ5e249bi5jb250ZW50RG9jdW1lbnQuaGVhZH1jYXRjaCh0KXtuPW51bGx9ZVt0XT1ufXJldHVybiBlW3RdfX0oKSxjPW51bGwsbD0wLHU9W10sZj1uKDQpO2Z1bmN0aW9uIHAodCxlKXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIG89dFtuXSxyPWlbby5pZF07aWYocil7ci5yZWZzKys7Zm9yKHZhciBzPTA7czxyLnBhcnRzLmxlbmd0aDtzKyspci5wYXJ0c1tzXShvLnBhcnRzW3NdKTtmb3IoO3M8by5wYXJ0cy5sZW5ndGg7cysrKXIucGFydHMucHVzaChnKG8ucGFydHNbc10sZSkpfWVsc2V7dmFyIGE9W107Zm9yKHM9MDtzPG8ucGFydHMubGVuZ3RoO3MrKylhLnB1c2goZyhvLnBhcnRzW3NdLGUpKTtpW28uaWRdPXtpZDpvLmlkLHJlZnM6MSxwYXJ0czphfX19fWZ1bmN0aW9uIGQodCxlKXtmb3IodmFyIG49W10sbz17fSxyPTA7cjx0Lmxlbmd0aDtyKyspe3ZhciBpPXRbcl0scz1lLmJhc2U/aVswXStlLmJhc2U6aVswXSxhPXtjc3M6aVsxXSxtZWRpYTppWzJdLHNvdXJjZU1hcDppWzNdfTtvW3NdP29bc10ucGFydHMucHVzaChhKTpuLnB1c2gob1tzXT17aWQ6cyxwYXJ0czpbYV19KX1yZXR1cm4gbn1mdW5jdGlvbiBoKHQsZSl7dmFyIG49YSh0Lmluc2VydEludG8pO2lmKCFuKXRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0SW50bycgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO3ZhciBvPXVbdS5sZW5ndGgtMV07aWYoXCJ0b3BcIj09PXQuaW5zZXJ0QXQpbz9vLm5leHRTaWJsaW5nP24uaW5zZXJ0QmVmb3JlKGUsby5uZXh0U2libGluZyk6bi5hcHBlbmRDaGlsZChlKTpuLmluc2VydEJlZm9yZShlLG4uZmlyc3RDaGlsZCksdS5wdXNoKGUpO2Vsc2UgaWYoXCJib3R0b21cIj09PXQuaW5zZXJ0QXQpbi5hcHBlbmRDaGlsZChlKTtlbHNle2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0Lmluc2VydEF0fHwhdC5pbnNlcnRBdC5iZWZvcmUpdGhyb3cgbmV3IEVycm9yKFwiW1N0eWxlIExvYWRlcl1cXG5cXG4gSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdpbnNlcnRBdCcgKCdvcHRpb25zLmluc2VydEF0JykgZm91bmQuXFxuIE11c3QgYmUgJ3RvcCcsICdib3R0b20nLCBvciBPYmplY3QuXFxuIChodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlciNpbnNlcnRhdClcXG5cIik7dmFyIHI9YSh0Lmluc2VydEludG8rXCIgXCIrdC5pbnNlcnRBdC5iZWZvcmUpO24uaW5zZXJ0QmVmb3JlKGUscil9fWZ1bmN0aW9uIHYodCl7aWYobnVsbD09PXQucGFyZW50Tm9kZSlyZXR1cm4hMTt0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodCk7dmFyIGU9dS5pbmRleE9mKHQpO2U+PTAmJnUuc3BsaWNlKGUsMSl9ZnVuY3Rpb24gYih0KXt2YXIgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7cmV0dXJuIHZvaWQgMD09PXQuYXR0cnMudHlwZSYmKHQuYXR0cnMudHlwZT1cInRleHQvY3NzXCIpLHkoZSx0LmF0dHJzKSxoKHQsZSksZX1mdW5jdGlvbiB5KHQsZSl7T2JqZWN0LmtleXMoZSkuZm9yRWFjaChmdW5jdGlvbihuKXt0LnNldEF0dHJpYnV0ZShuLGVbbl0pfSl9ZnVuY3Rpb24gZyh0LGUpe3ZhciBuLG8scixpO2lmKGUudHJhbnNmb3JtJiZ0LmNzcyl7aWYoIShpPWUudHJhbnNmb3JtKHQuY3NzKSkpcmV0dXJuIGZ1bmN0aW9uKCl7fTt0LmNzcz1pfWlmKGUuc2luZ2xldG9uKXt2YXIgcz1sKys7bj1jfHwoYz1iKGUpKSxvPXguYmluZChudWxsLG4scywhMSkscj14LmJpbmQobnVsbCxuLHMsITApfWVsc2UgdC5zb3VyY2VNYXAmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFVSTCYmXCJmdW5jdGlvblwiPT10eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCYmXCJmdW5jdGlvblwiPT10eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCYmXCJmdW5jdGlvblwiPT10eXBlb2YgQmxvYiYmXCJmdW5jdGlvblwiPT10eXBlb2YgYnRvYT8obj1mdW5jdGlvbih0KXt2YXIgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtyZXR1cm4gdm9pZCAwPT09dC5hdHRycy50eXBlJiYodC5hdHRycy50eXBlPVwidGV4dC9jc3NcIiksdC5hdHRycy5yZWw9XCJzdHlsZXNoZWV0XCIseShlLHQuYXR0cnMpLGgodCxlKSxlfShlKSxvPWZ1bmN0aW9uKHQsZSxuKXt2YXIgbz1uLmNzcyxyPW4uc291cmNlTWFwLGk9dm9pZCAwPT09ZS5jb252ZXJ0VG9BYnNvbHV0ZVVybHMmJnI7KGUuY29udmVydFRvQWJzb2x1dGVVcmxzfHxpKSYmKG89ZihvKSk7ciYmKG8rPVwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIitidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShyKSkpKStcIiAqL1wiKTt2YXIgcz1uZXcgQmxvYihbb10se3R5cGU6XCJ0ZXh0L2Nzc1wifSksYT10LmhyZWY7dC5ocmVmPVVSTC5jcmVhdGVPYmplY3RVUkwocyksYSYmVVJMLnJldm9rZU9iamVjdFVSTChhKX0uYmluZChudWxsLG4sZSkscj1mdW5jdGlvbigpe3Yobiksbi5ocmVmJiZVUkwucmV2b2tlT2JqZWN0VVJMKG4uaHJlZil9KToobj1iKGUpLG89ZnVuY3Rpb24odCxlKXt2YXIgbj1lLmNzcyxvPWUubWVkaWE7byYmdC5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLG8pO2lmKHQuc3R5bGVTaGVldCl0LnN0eWxlU2hlZXQuY3NzVGV4dD1uO2Vsc2V7Zm9yKDt0LmZpcnN0Q2hpbGQ7KXQucmVtb3ZlQ2hpbGQodC5maXJzdENoaWxkKTt0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG4pKX19LmJpbmQobnVsbCxuKSxyPWZ1bmN0aW9uKCl7dihuKX0pO3JldHVybiBvKHQpLGZ1bmN0aW9uKGUpe2lmKGUpe2lmKGUuY3NzPT09dC5jc3MmJmUubWVkaWE9PT10Lm1lZGlhJiZlLnNvdXJjZU1hcD09PXQuc291cmNlTWFwKXJldHVybjtvKHQ9ZSl9ZWxzZSByKCl9fXQuZXhwb3J0cz1mdW5jdGlvbih0LGUpe2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBERUJVRyYmREVCVUcmJlwib2JqZWN0XCIhPXR5cGVvZiBkb2N1bWVudCl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7KGU9ZXx8e30pLmF0dHJzPVwib2JqZWN0XCI9PXR5cGVvZiBlLmF0dHJzP2UuYXR0cnM6e30sZS5zaW5nbGV0b258fFwiYm9vbGVhblwiPT10eXBlb2YgZS5zaW5nbGV0b258fChlLnNpbmdsZXRvbj1zKCkpLGUuaW5zZXJ0SW50b3x8KGUuaW5zZXJ0SW50bz1cImhlYWRcIiksZS5pbnNlcnRBdHx8KGUuaW5zZXJ0QXQ9XCJib3R0b21cIik7dmFyIG49ZCh0LGUpO3JldHVybiBwKG4sZSksZnVuY3Rpb24odCl7Zm9yKHZhciBvPVtdLHI9MDtyPG4ubGVuZ3RoO3IrKyl7dmFyIHM9bltyXTsoYT1pW3MuaWRdKS5yZWZzLS0sby5wdXNoKGEpfXQmJnAoZCh0LGUpLGUpO2ZvcihyPTA7cjxvLmxlbmd0aDtyKyspe3ZhciBhO2lmKDA9PT0oYT1vW3JdKS5yZWZzKXtmb3IodmFyIGM9MDtjPGEucGFydHMubGVuZ3RoO2MrKylhLnBhcnRzW2NdKCk7ZGVsZXRlIGlbYS5pZF19fX19O3ZhciBtLEM9KG09W10sZnVuY3Rpb24odCxlKXtyZXR1cm4gbVt0XT1lLG0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCJcXG5cIil9KTtmdW5jdGlvbiB4KHQsZSxuLG8pe3ZhciByPW4/XCJcIjpvLmNzcztpZih0LnN0eWxlU2hlZXQpdC5zdHlsZVNoZWV0LmNzc1RleHQ9QyhlLHIpO2Vsc2V7dmFyIGk9ZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocikscz10LmNoaWxkTm9kZXM7c1tlXSYmdC5yZW1vdmVDaGlsZChzW2VdKSxzLmxlbmd0aD90Lmluc2VydEJlZm9yZShpLHNbZV0pOnQuYXBwZW5kQ2hpbGQoaSl9fX0sZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7dmFyIGU9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyYmd2luZG93LmxvY2F0aW9uO2lmKCFlKXRocm93IG5ldyBFcnJvcihcImZpeFVybHMgcmVxdWlyZXMgd2luZG93LmxvY2F0aW9uXCIpO2lmKCF0fHxcInN0cmluZ1wiIT10eXBlb2YgdClyZXR1cm4gdDt2YXIgbj1lLnByb3RvY29sK1wiLy9cIitlLmhvc3Qsbz1uK2UucGF0aG5hbWUucmVwbGFjZSgvXFwvW15cXC9dKiQvLFwiL1wiKTtyZXR1cm4gdC5yZXBsYWNlKC91cmxcXHMqXFwoKCg/OlteKShdfFxcKCg/OlteKShdK3xcXChbXikoXSpcXCkpKlxcKSkqKVxcKS9naSxmdW5jdGlvbih0LGUpe3ZhciByLGk9ZS50cmltKCkucmVwbGFjZSgvXlwiKC4qKVwiJC8sZnVuY3Rpb24odCxlKXtyZXR1cm4gZX0pLnJlcGxhY2UoL14nKC4qKSckLyxmdW5jdGlvbih0LGUpe3JldHVybiBlfSk7cmV0dXJuL14oI3xkYXRhOnxodHRwOlxcL1xcL3xodHRwczpcXC9cXC98ZmlsZTpcXC9cXC9cXC98XFxzKiQpL2kudGVzdChpKT90OihyPTA9PT1pLmluZGV4T2YoXCIvL1wiKT9pOjA9PT1pLmluZGV4T2YoXCIvXCIpP24raTpvK2kucmVwbGFjZSgvXlxcLlxcLy8sXCJcIiksXCJ1cmwoXCIrSlNPTi5zdHJpbmdpZnkocikrXCIpXCIpfSl9fSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7bi5yKGUpO24oMCk7ZnVuY3Rpb24gbyh0LGUpe2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgbz1lW25dO28uZW51bWVyYWJsZT1vLmVudW1lcmFibGV8fCExLG8uY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIG8mJihvLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxvLmtleSxvKX19ZnVuY3Rpb24gcih0LGUsbil7cmV0dXJuIGUmJm8odC5wcm90b3R5cGUsZSksbiYmbyh0LG4pLHR9bi5kKGUsXCJkZWZhdWx0XCIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pO3ZhciBpPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChlKXt2YXIgbj1lLmNvbmZpZyxvPWUuYXBpOyFmdW5jdGlvbih0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMsdCksdGhpcy5hcGk9byx0aGlzLmJ1dHRvbj1udWxsLHRoaXMub3B0aW9uQnV0dG9ucz1bXSx0aGlzLl9zdGF0ZT0hMCx0aGlzLnNlbGVjdGVkVGV4dD1udWxsLHRoaXMucmFuZ2U9bnVsbCx0aGlzLl9zZXR0aW5ncz1uLHRoaXMuQ1NTPXthY3Rpb25zOlwiY2hhbmdlLWNhc2UtYWN0aW9uXCIsdG9vbGJhckxhYmVsOlwiY2hhbmdlLWNhc2UtdG9vbGJhcl9fbGFiZWxcIix0b29sOlwiY2hhbmdlLWNhc2UtdG9vbFwiLHRvb2xiYXJCdG5BY3RpdmU6dGhpcy5hcGkuc3R5bGVzLnNldHRpbmdzQnV0dG9uQWN0aXZlLGlubGluZUJ1dHRvbjp0aGlzLmFwaS5zdHlsZXMuaW5saW5lVG9vbEJ1dHRvbn0sdGhpcy5jYXNlT3B0aW9ucz17dGl0bGVDYXNlOlwiVGl0bGUgQ2FzZVwiLGxvd2VyQ2FzZTpcImxvd2VyIGNhc2VcIix1cHBlckNhc2U6XCJVUFBFUiBDQVNFXCIsbG9jYWxlTG93ZXJDYXNlOlwibG9jYWzDqSBsb3dlciBjYXPDqVwiLGxvY2FsZVVwcGVyQ2FzZTpcIkzDtkNBTEUgVVBQRVIgQ0FTRVwiLHNlbnRlbmNlQ2FzZTpcIlNlbnRlbmNlIGNhc2VcIix0b2dnbGVDYXNlOlwidE9PR0xFIGNBU0VcIn19cmV0dXJuIHIodCxbe2tleTpcInN0YXRlXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3N0YXRlfX1dLFt7a2V5OlwiaXNJbmxpbmVcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4hMH19XSkscih0LFt7a2V5OlwicmVuZGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5idXR0b249ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKSx0aGlzLmJ1dHRvbi50eXBlPVwiYnV0dG9uXCIsdGhpcy5idXR0b24uaW5uZXJIVE1MPSdcXG4gICAgICAgICAgICA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImgtNSB3LTVcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMTAwIDEwMFwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiPlxcbiAgICAgICAgICAgIDxwYXRoIGQ9XCJtNDYuMDk5IDc0LjI3MS0zLjY4NjgtMTMuNjg2aC0xOC41MjNsLTMuNjg2OCAxMy42ODZoLTExLjYwNWwxNy45MzQtNTcuNjUzaDEzLjE3bDE4LjAwMSA1Ny42NTN6bS02LjI2MzItMjMuODEzcS01LjA5NzItMTguNjEyLTUuNzUyNC0yMS4wNTZjLTAuNDIxOTktMS42MTY4LTAuNzMyOTMtMi45MDc3LTAuOTEwNjEtMy44NDc3cS0xLjExMDUgNS4wMTMzLTYuNTc0MSAyNC44Mjh6XCIgc3Ryb2tlLXdpZHRoPVwiMS4xNzk3XCIvPlxcbiAgICAgICAgICAgIDxwYXRoIGQ9XCJtODcuMzU1IDc0LjI3MS0yLjQ5MzgtOC40NTU2aC0xMi41MjlsLTIuNDkzOCA4LjQ1NTZoLTcuODQ5NmwxMi4xMzEtMzUuNjE5aDguOTA4N2wxMi4xNzYgMzUuNjE5em0tNC4yMzY1LTE0LjcxMnEtMy40NDc4LTExLjQ5OS0zLjg5MS0xMy4wMDljLTAuMjg1NDQtMC45OTg4Ny0wLjQ5NTc2LTEuNzk2NC0wLjYxNTk1LTIuMzc3MnEtMC43NTExNiAzLjA5NzMtNC40NDY5IDE1LjMzOXpcIiBzdHJva2Utd2lkdGg9XCIuNzYyNjVcIi8+XFxuICAgICAgICAgICAgPC9zdmc+Jyx0aGlzLmJ1dHRvbi5jbGFzc0xpc3QuYWRkKHRoaXMuQ1NTLmlubGluZUJ1dHRvbiksdGhpcy5idXR0b259fSx7a2V5OlwiY2hlY2tTdGF0ZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3QuYW5jaG9yTm9kZX19LHtrZXk6XCJjb252ZXJ0Q2FzZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcztpZih0KXt2YXIgbz10LmNsb25lQ29udGVudHMoKTtvJiYoby5jaGlsZE5vZGVzLmZvckVhY2goZnVuY3Rpb24odCl7aWYoXCIjdGV4dFwiPT09dC5ub2RlTmFtZSlzd2l0Y2goZSl7Y2FzZVwidGl0bGVDYXNlXCI6dC50ZXh0Q29udGVudD10LnRleHRDb250ZW50LnJlcGxhY2UoL1xcd1xcUyovZyxmdW5jdGlvbih0KXtyZXR1cm4gdC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSt0LnNsaWNlKDEsdC5sZW5ndGgpLnRvTG93ZXJDYXNlKCl9KTticmVhaztjYXNlXCJsb3dlckNhc2VcIjp0LnRleHRDb250ZW50PWZ1bmN0aW9uKHQpe3JldHVybiB0LnRvTG93ZXJDYXNlKCl9KHQudGV4dENvbnRlbnQpO2JyZWFrO2Nhc2VcInVwcGVyQ2FzZVwiOnQudGV4dENvbnRlbnQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQudG9VcHBlckNhc2UoKX0odC50ZXh0Q29udGVudCk7YnJlYWs7Y2FzZVwibG9jYWxlTG93ZXJDYXNlXCI6dC50ZXh0Q29udGVudD1mdW5jdGlvbih0LGUpe3JldHVybiB0LnRvTG9jYWxlTG93ZXJDYXNlKGUpfSh0LnRleHRDb250ZW50LG4uX3NldHRpbmdzLmxvY2FsZSk7YnJlYWs7Y2FzZVwibG9jYWxlVXBwZXJDYXNlXCI6dC50ZXh0Q29udGVudD1mdW5jdGlvbih0LGUpe3JldHVybiB0LnRvTG9jYWxlVXBwZXJDYXNlKGUpfSh0LnRleHRDb250ZW50LG4uX3NldHRpbmdzLmxvY2FsZSk7YnJlYWs7Y2FzZVwic2VudGVuY2VDYXNlXCI6dC50ZXh0Q29udGVudD1mdW5jdGlvbih0KXtyZXR1cm4gdC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSt0LnNsaWNlKDEsdC5sZW5ndGgpLnRvTG93ZXJDYXNlKCl9KHQudGV4dENvbnRlbnQpO2JyZWFrO2Nhc2VcInRvZ2dsZUNhc2VcIjp0LnRleHRDb250ZW50PWZ1bmN0aW9uKHQpe3JldHVybiB0LnJlcGxhY2UoL1xcd1xcUyovZyxmdW5jdGlvbih0KXtyZXR1cm4gdC5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSt0LnNsaWNlKDEsdC5sZW5ndGgpLnRvVXBwZXJDYXNlKCl9KX0odC50ZXh0Q29udGVudCl9fSksdC5leHRyYWN0Q29udGVudHMoKSx0Lmluc2VydE5vZGUobyksdGhpcy5hcGkuaW5saW5lVG9vbGJhci5jbG9zZSgpKX19fSx7a2V5Olwic3Vycm91bmRcIix2YWx1ZTpmdW5jdGlvbih0KXt0aGlzLnNlbGVjdGVkVGV4dD10LmNsb25lQ29udGVudHMoKSx0aGlzLmFjdGlvbnMuaGlkZGVuPSF0aGlzLmFjdGlvbnMuaGlkZGVuLHRoaXMucmFuZ2U9dGhpcy5hY3Rpb25zLmhpZGRlbj9udWxsOnQsdGhpcy5zdGF0ZT0hdGhpcy5hY3Rpb25zLmhpZGRlbn19LHtrZXk6XCJyZW5kZXJBY3Rpb25zXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3RoaXMuYWN0aW9ucz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLHRoaXMuYWN0aW9ucy5jbGFzc0xpc3QuYWRkKHRoaXMuQ1NTLmFjdGlvbnMpO3ZhciBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7ZS5jbGFzc0xpc3QuYWRkKHRoaXMuQ1NTLnRvb2xiYXJMYWJlbCksZS5pbm5lckhUTUw9XCJDaGFuZ2UgQ2FzZVwiLHRoaXMuYWN0aW9ucy5hcHBlbmRDaGlsZChlKSx0aGlzLm9wdGlvbkJ1dHRvbnM9T2JqZWN0LmtleXModGhpcy5jYXNlT3B0aW9ucykubWFwKGZ1bmN0aW9uKGUpe3ZhciBuPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7cmV0dXJuIG4uY2xhc3NMaXN0LmFkZCh0LkNTUy50b29sKSxuLmRhdGFzZXQubW9kZT1lLG4uaW5uZXJIVE1MPXQuY2FzZU9wdGlvbnNbZV0sbn0pO3ZhciBuPSEwLG89ITEscj12b2lkIDA7dHJ5e2Zvcih2YXIgaSxzPWZ1bmN0aW9uKCl7dmFyIGU9aS52YWx1ZTt0LmFjdGlvbnMuYXBwZW5kQ2hpbGQoZSksdC5hcGkubGlzdGVuZXJzLm9uKGUsXCJjbGlja1wiLGZ1bmN0aW9uKCl7dC5jb252ZXJ0Q2FzZSh0LnJhbmdlLGUuZGF0YXNldC5tb2RlKX0pfSxhPXRoaXMub3B0aW9uQnV0dG9uc1tTeW1ib2wuaXRlcmF0b3JdKCk7IShuPShpPWEubmV4dCgpKS5kb25lKTtuPSEwKXMoKX1jYXRjaCh0KXtvPSEwLHI9dH1maW5hbGx5e3RyeXtufHxudWxsPT1hLnJldHVybnx8YS5yZXR1cm4oKX1maW5hbGx5e2lmKG8pdGhyb3cgcn19cmV0dXJuIHRoaXMuYWN0aW9ucy5oaWRkZW49ITAsdGhpcy5hY3Rpb25zfX0se2tleTpcImRlc3Ryb3lcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PSEwLGU9ITEsbj12b2lkIDA7dHJ5e2Zvcih2YXIgbyxyPXRoaXMub3B0aW9uQnV0dG9uc1tTeW1ib2wuaXRlcmF0b3JdKCk7ISh0PShvPXIubmV4dCgpKS5kb25lKTt0PSEwKXt2YXIgaT1vLnZhbHVlO3RoaXMuYXBpLmxpc3RlbmVycy5vZmYoaSxcImNsaWNrXCIpfX1jYXRjaCh0KXtlPSEwLG49dH1maW5hbGx5e3RyeXt0fHxudWxsPT1yLnJldHVybnx8ci5yZXR1cm4oKX1maW5hbGx5e2lmKGUpdGhyb3cgbn19fX0se2tleTpcInN0YXRlXCIsc2V0OmZ1bmN0aW9uKHQpe3RoaXMuX3N0YXRlPXQsdGhpcy5idXR0b24uY2xhc3NMaXN0LnRvZ2dsZSh0aGlzLkNTUy50b29sYmFyQnRuQWN0aXZlLHQpfX0se2tleTpcInRpdGxlXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuXCJDaGFuZ2UgQ2FzZVwifX1dKSx0fSgpfV0pfSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/editorjs-change-case/dist/bundle.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/editorjs-inline-template/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/editorjs-inline-template/dist/index.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("!function(e,t){ true?module.exports=t():0}(window,(function(){return function(e){var t={};function n(r){if(t[r])return t[r].exports;var o=t[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,n),o.l=!0,o.exports}return n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&\"object\"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,\"default\",{enumerable:!0,value:e}),2&t&&\"string\"!=typeof e)for(var o in e)n.d(r,o,function(t){return e[t]}.bind(null,o));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,\"a\",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p=\"\",n(n.s=0)}([function(e,t,n){\"use strict\";n.r(t),n.d(t,\"TemplateInlineTool\",(function(){return s}));var r,o,i=function(e,t,n){if(!t.has(e))throw new TypeError(\"attempted to set private field on non-instance\");return t.set(e,n),n},u=function(e,t){if(!t.has(e))throw new TypeError(\"attempted to get private field on non-instance\");return t.get(e)};class s{constructor({api:e,config:t}){r.set(this,void 0),o.set(this,void 0),i(this,r,e),t&&\"html\"in t&&i(this,o,t)}static get isInline(){return!0}static get title(){return\"Template\"}get shortcut(){return\"CMD+I\"}checkState(){return!1}render(){var e;const t=document.createElement(\"button\");return t.classList.add(u(this,r).styles.inlineToolButton),t.type=\"button\",t.innerHTML=null!==(e=u(this,o).buttonHTML)&&void 0!==e?e:'\\n        <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"ionicon\" viewBox=\"0 0 512 512\">\\n          <path d=\"M336 64h32a48 48 0 0148 48v320a48 48 0 01-48 48H144a48 48 0 01-48-48V112a48 48 0 0148-48h32\" fill=\"none\" stroke=\"currentColor\" stroke-linejoin=\"round\" stroke-width=\"32\"/>\\n          <rect x=\"176\" y=\"32\" width=\"160\" height=\"64\" rx=\"26.13\" ry=\"26.13\" fill=\"none\" stroke=\"currentColor\" stroke-linejoin=\"round\" stroke-width=\"32\"/>\\n        </svg>\\n      ',t}surround(){s.isSurroundEnabled&&(document.execCommand(\"insertHTML\",!1,u(this,o).html),s.isSurroundEnabled=!1,setTimeout(()=>s.isSurroundEnabled=!0))}}r=new WeakMap,o=new WeakMap,s.isSurroundEnabled=!0}])}));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9lZGl0b3Jqcy1pbmxpbmUtdGVtcGxhdGUvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxlQUFlLEtBQWlELG9CQUFvQixDQUEySSxDQUFDLG9CQUFvQixtQkFBbUIsU0FBUyxjQUFjLDRCQUE0QixZQUFZLHFCQUFxQiwyREFBMkQsdUNBQXVDLHFDQUFxQyxvQkFBb0IsRUFBRSxpQkFBaUIsNEZBQTRGLGVBQWUsd0NBQXdDLFNBQVMsRUFBRSxtQkFBbUIsOEJBQThCLHFEQUFxRCwwQkFBMEIsNkNBQTZDLHNCQUFzQiw2REFBNkQsWUFBWSxlQUFlLFNBQVMsaUJBQWlCLGlDQUFpQyxpQkFBaUIsWUFBWSxVQUFVLHNCQUFzQixtQkFBbUIsaURBQWlELGlCQUFpQixrQkFBa0IsYUFBYSw4Q0FBOEMsU0FBUyxHQUFHLDBCQUEwQixtRkFBbUYsb0JBQW9CLGlCQUFpQixtRkFBbUYsaUJBQWlCLFFBQVEsYUFBYSxlQUFlLEVBQUUsNkVBQTZFLHNCQUFzQixTQUFTLG1CQUFtQixpQkFBaUIsZUFBZSxjQUFjLGFBQWEsU0FBUyxTQUFTLE1BQU0seUNBQXlDLG9sQkFBb2xCLFdBQVcsMklBQTJJLG1EQUFtRCxHQUFHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9lZGl0b3Jqcy1pbmxpbmUtdGVtcGxhdGUvZGlzdC9pbmRleC5qcz9jMzcwIl0sInNvdXJjZXNDb250ZW50IjpbIiFmdW5jdGlvbihlLHQpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPXQoKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtdLHQpOlwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzP2V4cG9ydHMuRWRpdG9ySlNJbmxpbmVUZW1wbGF0ZT10KCk6ZS5FZGl0b3JKU0lubGluZVRlbXBsYXRlPXQoKX0od2luZG93LChmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihlKXt2YXIgdD17fTtmdW5jdGlvbiBuKHIpe2lmKHRbcl0pcmV0dXJuIHRbcl0uZXhwb3J0czt2YXIgbz10W3JdPXtpOnIsbDohMSxleHBvcnRzOnt9fTtyZXR1cm4gZVtyXS5jYWxsKG8uZXhwb3J0cyxvLG8uZXhwb3J0cyxuKSxvLmw9ITAsby5leHBvcnRzfXJldHVybiBuLm09ZSxuLmM9dCxuLmQ9ZnVuY3Rpb24oZSx0LHIpe24ubyhlLHQpfHxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHtlbnVtZXJhYmxlOiEwLGdldDpyfSl9LG4ucj1mdW5jdGlvbihlKXtcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJNb2R1bGVcIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfSxuLnQ9ZnVuY3Rpb24oZSx0KXtpZigxJnQmJihlPW4oZSkpLDgmdClyZXR1cm4gZTtpZig0JnQmJlwib2JqZWN0XCI9PXR5cGVvZiBlJiZlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIHI9T2JqZWN0LmNyZWF0ZShudWxsKTtpZihuLnIociksT2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJkZWZhdWx0XCIse2VudW1lcmFibGU6ITAsdmFsdWU6ZX0pLDImdCYmXCJzdHJpbmdcIiE9dHlwZW9mIGUpZm9yKHZhciBvIGluIGUpbi5kKHIsbyxmdW5jdGlvbih0KXtyZXR1cm4gZVt0XX0uYmluZChudWxsLG8pKTtyZXR1cm4gcn0sbi5uPWZ1bmN0aW9uKGUpe3ZhciB0PWUmJmUuX19lc01vZHVsZT9mdW5jdGlvbigpe3JldHVybiBlLmRlZmF1bHR9OmZ1bmN0aW9uKCl7cmV0dXJuIGV9O3JldHVybiBuLmQodCxcImFcIix0KSx0fSxuLm89ZnVuY3Rpb24oZSx0KXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCl9LG4ucD1cIlwiLG4obi5zPTApfShbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO24ucih0KSxuLmQodCxcIlRlbXBsYXRlSW5saW5lVG9vbFwiLChmdW5jdGlvbigpe3JldHVybiBzfSkpO3ZhciByLG8saT1mdW5jdGlvbihlLHQsbil7aWYoIXQuaGFzKGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJhdHRlbXB0ZWQgdG8gc2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlXCIpO3JldHVybiB0LnNldChlLG4pLG59LHU9ZnVuY3Rpb24oZSx0KXtpZighdC5oYXMoZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcImF0dGVtcHRlZCB0byBnZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2VcIik7cmV0dXJuIHQuZ2V0KGUpfTtjbGFzcyBze2NvbnN0cnVjdG9yKHthcGk6ZSxjb25maWc6dH0pe3Iuc2V0KHRoaXMsdm9pZCAwKSxvLnNldCh0aGlzLHZvaWQgMCksaSh0aGlzLHIsZSksdCYmXCJodG1sXCJpbiB0JiZpKHRoaXMsbyx0KX1zdGF0aWMgZ2V0IGlzSW5saW5lKCl7cmV0dXJuITB9c3RhdGljIGdldCB0aXRsZSgpe3JldHVyblwiVGVtcGxhdGVcIn1nZXQgc2hvcnRjdXQoKXtyZXR1cm5cIkNNRCtJXCJ9Y2hlY2tTdGF0ZSgpe3JldHVybiExfXJlbmRlcigpe3ZhciBlO2NvbnN0IHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtyZXR1cm4gdC5jbGFzc0xpc3QuYWRkKHUodGhpcyxyKS5zdHlsZXMuaW5saW5lVG9vbEJ1dHRvbiksdC50eXBlPVwiYnV0dG9uXCIsdC5pbm5lckhUTUw9bnVsbCE9PShlPXUodGhpcyxvKS5idXR0b25IVE1MKSYmdm9pZCAwIT09ZT9lOidcXG4gICAgICAgIDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiaW9uaWNvblwiIHZpZXdCb3g9XCIwIDAgNTEyIDUxMlwiPlxcbiAgICAgICAgICA8cGF0aCBkPVwiTTMzNiA2NGgzMmE0OCA0OCAwIDAxNDggNDh2MzIwYTQ4IDQ4IDAgMDEtNDggNDhIMTQ0YTQ4IDQ4IDAgMDEtNDgtNDhWMTEyYTQ4IDQ4IDAgMDE0OC00OGgzMlwiIGZpbGw9XCJub25lXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIzMlwiLz5cXG4gICAgICAgICAgPHJlY3QgeD1cIjE3NlwiIHk9XCIzMlwiIHdpZHRoPVwiMTYwXCIgaGVpZ2h0PVwiNjRcIiByeD1cIjI2LjEzXCIgcnk9XCIyNi4xM1wiIGZpbGw9XCJub25lXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIzMlwiLz5cXG4gICAgICAgIDwvc3ZnPlxcbiAgICAgICcsdH1zdXJyb3VuZCgpe3MuaXNTdXJyb3VuZEVuYWJsZWQmJihkb2N1bWVudC5leGVjQ29tbWFuZChcImluc2VydEhUTUxcIiwhMSx1KHRoaXMsbykuaHRtbCkscy5pc1N1cnJvdW5kRW5hYmxlZD0hMSxzZXRUaW1lb3V0KCgpPT5zLmlzU3Vycm91bmRFbmFibGVkPSEwKSl9fXI9bmV3IFdlYWtNYXAsbz1uZXcgV2Vha01hcCxzLmlzU3Vycm91bmRFbmFibGVkPSEwfV0pfSkpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/editorjs-inline-template/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/editorjs-latex/src/index.js":
/*!**************************************************!*\
  !*** ./node_modules/editorjs-latex/src/index.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("const katex = __webpack_require__(/*! katex */ \"(app-pages-browser)/./node_modules/katex/dist/katex.js\");\n\n/*\n              EditorJS LaTeX\n      Created By: MD Gaziur Rahman Noor\n    Adds LaTex block support to EditorJS\n*/\nclass EJLaTeX {\n    constructor({ data, config }) {\n        this.data = data.math;\n\n        if (config && config.css) {\n            this.addCss(config.css);\n        }\n    }\n\n    static get toolbox() {\n        return {\n            title: \"Math\",\n            icon: '<svg id=\"Layer_1\" enable-background=\"new 0 0 506.1 506.1\" height=\"512\" viewBox=\"0 0 506.1 506.1\" width=\"512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"m489.609 0h-473.118c-9.108 0-16.491 7.383-16.491 16.491v473.118c0 9.107 7.383 16.491 16.491 16.491h473.119c9.107 0 16.49-7.383 16.49-16.491v-473.118c0-9.108-7.383-16.491-16.491-16.491zm-16.49 473.118h-440.138v-440.137h440.138z\"/><path d=\"m367.278 240.136v-62.051c0-8.836-7.163-16-16-16s-16 7.164-16 16v147.377c0 15.024 18.993 21.77 28.457 10.03 34.691 18.107 77.146-6.988 77.146-46.831.001-37.966-39-63.416-73.603-48.525zm20.802 69.327c-11.47 0-20.802-9.332-20.802-20.802s9.332-20.802 20.802-20.802 20.802 9.332 20.802 20.802-9.332 20.802-20.802 20.802z\"/><path d=\"m112.397 200.262h-14.014c-8.836 0-16 7.164-16 16s7.164 16 16 16h14.014c8.291 0 15.037 6.746 15.037 15.037v4.998c-30.589-10.389-62.216 12.536-62.216 44.609 0 34.402 35.954 57.331 67.13 42.629 10.128 9.747 27.086 2.537 27.086-11.521v-80.715c0-25.936-21.101-47.037-47.037-47.037zm-.071 111.752c-8.331 0-15.108-6.777-15.108-15.108s6.777-15.108 15.108-15.108 15.108 6.777 15.108 15.108-6.778 15.108-15.108 15.108z\"/><path d=\"m287.786 243.114c-6.248-6.248-16.379-6.249-22.627 0l-18.11 18.11-18.11-18.11c-6.249-6.249-16.379-6.249-22.627 0-6.249 6.249-6.249 16.379 0 22.627l18.11 18.11-18.11 18.11c-6.248 6.248-6.248 16.379 0 22.627s16.378 6.249 22.627 0l18.11-18.11 18.11 18.11c6.246 6.248 16.377 6.249 22.627 0 6.249-6.249 6.249-16.379 0-22.627l-18.11-18.11 18.11-18.11c6.249-6.248 6.249-16.379 0-22.627z\"/></svg>'\n        };\n    }\n\n    render() {\n        const wrapper = document.createElement('div');\n        const preview = document.createElement('p');\n        const input = document.createElement('input');\n        if (typeof katex === \"undefined\") {\n            let errorMessageSpan = document.createElement(\"span\");\n            errorMessageSpan.className = \"errorMessage\";\n            errorMessageSpan.innerText = \"[Error] KaTeX is not found! Add KaTeX to this webpage to continue!\";\n\n            return errorMessageSpan;\n        }\n\n        wrapper.classList.add('math-input-wrapper');\n        preview.classList.add('math-preview');\n        input.classList.add('math-input');\n\n        // Load the data if exists\n        input.value = this.data ? this.data : '';\n\n        // Set the placeholder text for LaTeX expression input\n        input.setAttribute(\"placeholder\", \"Enter LaTeX here\");\n\n        // Will render LaTeX if there is any in saved data\n        katex.render(input.value, preview, {\n            throwOnError: false\n        });\n\n        input.addEventListener('keyup', (e) => {\n            // Prevent default actions\n            e.preventDefault();\n\n            // Render LaTeX expression\n            katex.render(input.value, preview, {\n                throwOnError: false\n            });\n        });\n\n        wrapper.appendChild(preview);\n        wrapper.appendChild(input);\n        return wrapper;\n    }\n\n    save(blockContent) {\n        return {\n            math: blockContent.childNodes[1].value\n        };\n    }\n\n    static get isReadOnlySupported() {\n        return true;\n    }\n\n    addCss(cssRules) {\n        const head = document.head;\n        let css = document.createElement('style');\n        if (css.styleSheet) {\n            css.styleSheet.cssText = cssRules; // Support for IE\n        } else {\n            css.appendChild(document.createTextNode(cssRules)); // Support for the rest\n        }\n\n        head.appendChild(css);\n    }\n}\n\n// Expose the class globally if this class is being used inside a browser\nif (typeof window !== \"undefined\") {\n  window.EJLaTeX = EJLaTeX;\n}\nmodule.exports = EJLaTeX;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9lZGl0b3Jqcy1sYXRleC9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsY0FBYyxtQkFBTyxDQUFDLHFFQUFPOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0MsVUFBVTtBQUNWLGdFQUFnRTtBQUNoRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZWRpdG9yanMtbGF0ZXgvc3JjL2luZGV4LmpzPzY1MjAiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qga2F0ZXggPSByZXF1aXJlKCdrYXRleCcpO1xuXG4vKlxuICAgICAgICAgICAgICBFZGl0b3JKUyBMYVRlWFxuICAgICAgQ3JlYXRlZCBCeTogTUQgR2F6aXVyIFJhaG1hbiBOb29yXG4gICAgQWRkcyBMYVRleCBibG9jayBzdXBwb3J0IHRvIEVkaXRvckpTXG4qL1xuY2xhc3MgRUpMYVRlWCB7XG4gICAgY29uc3RydWN0b3IoeyBkYXRhLCBjb25maWcgfSkge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhLm1hdGg7XG5cbiAgICAgICAgaWYgKGNvbmZpZyAmJiBjb25maWcuY3NzKSB7XG4gICAgICAgICAgICB0aGlzLmFkZENzcyhjb25maWcuY3NzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBnZXQgdG9vbGJveCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRpdGxlOiBcIk1hdGhcIixcbiAgICAgICAgICAgIGljb246ICc8c3ZnIGlkPVwiTGF5ZXJfMVwiIGVuYWJsZS1iYWNrZ3JvdW5kPVwibmV3IDAgMCA1MDYuMSA1MDYuMVwiIGhlaWdodD1cIjUxMlwiIHZpZXdCb3g9XCIwIDAgNTA2LjEgNTA2LjFcIiB3aWR0aD1cIjUxMlwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48cGF0aCBkPVwibTQ4OS42MDkgMGgtNDczLjExOGMtOS4xMDggMC0xNi40OTEgNy4zODMtMTYuNDkxIDE2LjQ5MXY0NzMuMTE4YzAgOS4xMDcgNy4zODMgMTYuNDkxIDE2LjQ5MSAxNi40OTFoNDczLjExOWM5LjEwNyAwIDE2LjQ5LTcuMzgzIDE2LjQ5LTE2LjQ5MXYtNDczLjExOGMwLTkuMTA4LTcuMzgzLTE2LjQ5MS0xNi40OTEtMTYuNDkxem0tMTYuNDkgNDczLjExOGgtNDQwLjEzOHYtNDQwLjEzN2g0NDAuMTM4elwiLz48cGF0aCBkPVwibTM2Ny4yNzggMjQwLjEzNnYtNjIuMDUxYzAtOC44MzYtNy4xNjMtMTYtMTYtMTZzLTE2IDcuMTY0LTE2IDE2djE0Ny4zNzdjMCAxNS4wMjQgMTguOTkzIDIxLjc3IDI4LjQ1NyAxMC4wMyAzNC42OTEgMTguMTA3IDc3LjE0Ni02Ljk4OCA3Ny4xNDYtNDYuODMxLjAwMS0zNy45NjYtMzktNjMuNDE2LTczLjYwMy00OC41MjV6bTIwLjgwMiA2OS4zMjdjLTExLjQ3IDAtMjAuODAyLTkuMzMyLTIwLjgwMi0yMC44MDJzOS4zMzItMjAuODAyIDIwLjgwMi0yMC44MDIgMjAuODAyIDkuMzMyIDIwLjgwMiAyMC44MDItOS4zMzIgMjAuODAyLTIwLjgwMiAyMC44MDJ6XCIvPjxwYXRoIGQ9XCJtMTEyLjM5NyAyMDAuMjYyaC0xNC4wMTRjLTguODM2IDAtMTYgNy4xNjQtMTYgMTZzNy4xNjQgMTYgMTYgMTZoMTQuMDE0YzguMjkxIDAgMTUuMDM3IDYuNzQ2IDE1LjAzNyAxNS4wMzd2NC45OThjLTMwLjU4OS0xMC4zODktNjIuMjE2IDEyLjUzNi02Mi4yMTYgNDQuNjA5IDAgMzQuNDAyIDM1Ljk1NCA1Ny4zMzEgNjcuMTMgNDIuNjI5IDEwLjEyOCA5Ljc0NyAyNy4wODYgMi41MzcgMjcuMDg2LTExLjUyMXYtODAuNzE1YzAtMjUuOTM2LTIxLjEwMS00Ny4wMzctNDcuMDM3LTQ3LjAzN3ptLS4wNzEgMTExLjc1MmMtOC4zMzEgMC0xNS4xMDgtNi43NzctMTUuMTA4LTE1LjEwOHM2Ljc3Ny0xNS4xMDggMTUuMTA4LTE1LjEwOCAxNS4xMDggNi43NzcgMTUuMTA4IDE1LjEwOC02Ljc3OCAxNS4xMDgtMTUuMTA4IDE1LjEwOHpcIi8+PHBhdGggZD1cIm0yODcuNzg2IDI0My4xMTRjLTYuMjQ4LTYuMjQ4LTE2LjM3OS02LjI0OS0yMi42MjcgMGwtMTguMTEgMTguMTEtMTguMTEtMTguMTFjLTYuMjQ5LTYuMjQ5LTE2LjM3OS02LjI0OS0yMi42MjcgMC02LjI0OSA2LjI0OS02LjI0OSAxNi4zNzkgMCAyMi42MjdsMTguMTEgMTguMTEtMTguMTEgMTguMTFjLTYuMjQ4IDYuMjQ4LTYuMjQ4IDE2LjM3OSAwIDIyLjYyN3MxNi4zNzggNi4yNDkgMjIuNjI3IDBsMTguMTEtMTguMTEgMTguMTEgMTguMTFjNi4yNDYgNi4yNDggMTYuMzc3IDYuMjQ5IDIyLjYyNyAwIDYuMjQ5LTYuMjQ5IDYuMjQ5LTE2LjM3OSAwLTIyLjYyN2wtMTguMTEtMTguMTEgMTguMTEtMTguMTFjNi4yNDktNi4yNDggNi4yNDktMTYuMzc5IDAtMjIuNjI3elwiLz48L3N2Zz4nXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB3cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGNvbnN0IHByZXZpZXcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBrYXRleCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgbGV0IGVycm9yTWVzc2FnZVNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZVNwYW4uY2xhc3NOYW1lID0gXCJlcnJvck1lc3NhZ2VcIjtcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZVNwYW4uaW5uZXJUZXh0ID0gXCJbRXJyb3JdIEthVGVYIGlzIG5vdCBmb3VuZCEgQWRkIEthVGVYIHRvIHRoaXMgd2VicGFnZSB0byBjb250aW51ZSFcIjtcblxuICAgICAgICAgICAgcmV0dXJuIGVycm9yTWVzc2FnZVNwYW47XG4gICAgICAgIH1cblxuICAgICAgICB3cmFwcGVyLmNsYXNzTGlzdC5hZGQoJ21hdGgtaW5wdXQtd3JhcHBlcicpO1xuICAgICAgICBwcmV2aWV3LmNsYXNzTGlzdC5hZGQoJ21hdGgtcHJldmlldycpO1xuICAgICAgICBpbnB1dC5jbGFzc0xpc3QuYWRkKCdtYXRoLWlucHV0Jyk7XG5cbiAgICAgICAgLy8gTG9hZCB0aGUgZGF0YSBpZiBleGlzdHNcbiAgICAgICAgaW5wdXQudmFsdWUgPSB0aGlzLmRhdGEgPyB0aGlzLmRhdGEgOiAnJztcblxuICAgICAgICAvLyBTZXQgdGhlIHBsYWNlaG9sZGVyIHRleHQgZm9yIExhVGVYIGV4cHJlc3Npb24gaW5wdXRcbiAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKFwicGxhY2Vob2xkZXJcIiwgXCJFbnRlciBMYVRlWCBoZXJlXCIpO1xuXG4gICAgICAgIC8vIFdpbGwgcmVuZGVyIExhVGVYIGlmIHRoZXJlIGlzIGFueSBpbiBzYXZlZCBkYXRhXG4gICAgICAgIGthdGV4LnJlbmRlcihpbnB1dC52YWx1ZSwgcHJldmlldywge1xuICAgICAgICAgICAgdGhyb3dPbkVycm9yOiBmYWxzZVxuICAgICAgICB9KTtcblxuICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIChlKSA9PiB7XG4gICAgICAgICAgICAvLyBQcmV2ZW50IGRlZmF1bHQgYWN0aW9uc1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICAvLyBSZW5kZXIgTGFUZVggZXhwcmVzc2lvblxuICAgICAgICAgICAga2F0ZXgucmVuZGVyKGlucHV0LnZhbHVlLCBwcmV2aWV3LCB7XG4gICAgICAgICAgICAgICAgdGhyb3dPbkVycm9yOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQocHJldmlldyk7XG4gICAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQoaW5wdXQpO1xuICAgICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG5cbiAgICBzYXZlKGJsb2NrQ29udGVudCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWF0aDogYmxvY2tDb250ZW50LmNoaWxkTm9kZXNbMV0udmFsdWVcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0IGlzUmVhZE9ubHlTdXBwb3J0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGFkZENzcyhjc3NSdWxlcykge1xuICAgICAgICBjb25zdCBoZWFkID0gZG9jdW1lbnQuaGVhZDtcbiAgICAgICAgbGV0IGNzcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgIGlmIChjc3Muc3R5bGVTaGVldCkge1xuICAgICAgICAgICAgY3NzLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzc1J1bGVzOyAvLyBTdXBwb3J0IGZvciBJRVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3NzLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzc1J1bGVzKSk7IC8vIFN1cHBvcnQgZm9yIHRoZSByZXN0XG4gICAgICAgIH1cblxuICAgICAgICBoZWFkLmFwcGVuZENoaWxkKGNzcyk7XG4gICAgfVxufVxuXG4vLyBFeHBvc2UgdGhlIGNsYXNzIGdsb2JhbGx5IGlmIHRoaXMgY2xhc3MgaXMgYmVpbmcgdXNlZCBpbnNpZGUgYSBicm93c2VyXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICB3aW5kb3cuRUpMYVRlWCA9IEVKTGFUZVg7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEVKTGFUZVg7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/editorjs-latex/src/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/katex/dist/katex.js":
/*!******************************************!*\
  !*** ./node_modules/katex/dist/katex.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})((typeof self !== 'undefined' ? self : this), function() {\nreturn /******/ (function() { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \t// The require scope\n/******/ \tvar __nested_webpack_require_514__ = {};\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/define property getters */\n/******/ \t!function() {\n/******/ \t\t// define getter functions for harmony exports\n/******/ \t\t__nested_webpack_require_514__.d = function(exports, definition) {\n/******/ \t\t\tfor(var key in definition) {\n/******/ \t\t\t\tif(__nested_webpack_require_514__.o(definition, key) && !__nested_webpack_require_514__.o(exports, key)) {\n/******/ \t\t\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n/******/ \t\t\t\t}\n/******/ \t\t\t}\n/******/ \t\t};\n/******/ \t}();\n/******/ \t\n/******/ \t/* webpack/runtime/hasOwnProperty shorthand */\n/******/ \t!function() {\n/******/ \t\t__nested_webpack_require_514__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }\n/******/ \t}();\n/******/ \t\n/************************************************************************/\nvar __nested_webpack_exports__ = {};\n\n// EXPORTS\n__nested_webpack_require_514__.d(__nested_webpack_exports__, {\n  \"default\": function() { return /* binding */ katex_webpack; }\n});\n\n;// CONCATENATED MODULE: ./src/ParseError.js\n\n\n/**\n * This is the ParseError class, which is the main error thrown by KaTeX\n * functions when something has gone wrong. This is used to distinguish internal\n * errors from errors in the expression that the user provided.\n *\n * If possible, a caller should provide a Token or ParseNode with information\n * about where in the source string the problem occurred.\n */\nclass ParseError {\n  // Error start position based on passed-in Token or ParseNode.\n  // Length of affected text based on passed-in Token or ParseNode.\n  // The underlying error message without any context added.\n  constructor(message, // The error message\n  token // An object providing position information\n  ) {\n    this.name = void 0;\n    this.position = void 0;\n    this.length = void 0;\n    this.rawMessage = void 0;\n    let error = \"KaTeX parse error: \" + message;\n    let start;\n    let end;\n    const loc = token && token.loc;\n\n    if (loc && loc.start <= loc.end) {\n      // If we have the input and a position, make the error a bit fancier\n      // Get the input\n      const input = loc.lexer.input; // Prepend some information\n\n      start = loc.start;\n      end = loc.end;\n\n      if (start === input.length) {\n        error += \" at end of input: \";\n      } else {\n        error += \" at position \" + (start + 1) + \": \";\n      } // Underline token in question using combining underscores\n\n\n      const underlined = input.slice(start, end).replace(/[^]/g, \"$&\\u0332\"); // Extract some context from the input and add it to the error\n\n      let left;\n\n      if (start > 15) {\n        left = \"\" + input.slice(start - 15, start);\n      } else {\n        left = input.slice(0, start);\n      }\n\n      let right;\n\n      if (end + 15 < input.length) {\n        right = input.slice(end, end + 15) + \"\";\n      } else {\n        right = input.slice(end);\n      }\n\n      error += left + underlined + right;\n    } // Some hackery to make ParseError a prototype of Error\n    // See http://stackoverflow.com/a/8460753\n    // $FlowFixMe\n\n\n    const self = new Error(error);\n    self.name = \"ParseError\"; // $FlowFixMe\n\n    self.__proto__ = ParseError.prototype;\n    self.position = start;\n\n    if (start != null && end != null) {\n      self.length = end - start;\n    }\n\n    self.rawMessage = message;\n    return self;\n  }\n\n} // $FlowFixMe More hackery\n\n\nParseError.prototype.__proto__ = Error.prototype;\n/* harmony default export */ var src_ParseError = (ParseError);\n;// CONCATENATED MODULE: ./src/utils.js\n/**\n * This file contains a list of utility functions which are useful in other\n * files.\n */\n\n/**\n * Return whether an element is contained in a list\n */\nconst contains = function (list, elem) {\n  return list.indexOf(elem) !== -1;\n};\n/**\n * Provide a default value if a setting is undefined\n * NOTE: Couldn't use `T` as the output type due to facebook/flow#5022.\n */\n\n\nconst deflt = function (setting, defaultIfUndefined) {\n  return setting === undefined ? defaultIfUndefined : setting;\n}; // hyphenate and escape adapted from Facebook's React under Apache 2 license\n\n\nconst uppercase = /([A-Z])/g;\n\nconst hyphenate = function (str) {\n  return str.replace(uppercase, \"-$1\").toLowerCase();\n};\n\nconst ESCAPE_LOOKUP = {\n  \"&\": \"&amp;\",\n  \">\": \"&gt;\",\n  \"<\": \"&lt;\",\n  \"\\\"\": \"&quot;\",\n  \"'\": \"&#x27;\"\n};\nconst ESCAPE_REGEX = /[&><\"']/g;\n/**\n * Escapes text to prevent scripting attacks.\n */\n\nfunction utils_escape(text) {\n  return String(text).replace(ESCAPE_REGEX, match => ESCAPE_LOOKUP[match]);\n}\n/**\n * Sometimes we want to pull out the innermost element of a group. In most\n * cases, this will just be the group itself, but when ordgroups and colors have\n * a single element, we want to pull that out.\n */\n\n\nconst getBaseElem = function (group) {\n  if (group.type === \"ordgroup\") {\n    if (group.body.length === 1) {\n      return getBaseElem(group.body[0]);\n    } else {\n      return group;\n    }\n  } else if (group.type === \"color\") {\n    if (group.body.length === 1) {\n      return getBaseElem(group.body[0]);\n    } else {\n      return group;\n    }\n  } else if (group.type === \"font\") {\n    return getBaseElem(group.body);\n  } else {\n    return group;\n  }\n};\n/**\n * TeXbook algorithms often reference \"character boxes\", which are simply groups\n * with a single character in them. To decide if something is a character box,\n * we find its innermost group, and see if it is a single character.\n */\n\n\nconst isCharacterBox = function (group) {\n  const baseElem = getBaseElem(group); // These are all they types of groups which hold single characters\n\n  return baseElem.type === \"mathord\" || baseElem.type === \"textord\" || baseElem.type === \"atom\";\n};\n\nconst assert = function (value) {\n  if (!value) {\n    throw new Error('Expected non-null, but got ' + String(value));\n  }\n\n  return value;\n};\n/**\n * Return the protocol of a URL, or \"_relative\" if the URL does not specify a\n * protocol (and thus is relative), or `null` if URL has invalid protocol\n * (so should be outright rejected).\n */\n\nconst protocolFromUrl = function (url) {\n  // Check for possible leading protocol.\n  // https://url.spec.whatwg.org/#url-parsing strips leading whitespace\n  // (U+20) or C0 control (U+00-U+1F) characters.\n  // eslint-disable-next-line no-control-regex\n  const protocol = /^[\\x00-\\x20]*([^\\\\/#?]*?)(:|&#0*58|&#x0*3a|&colon)/i.exec(url);\n\n  if (!protocol) {\n    return \"_relative\";\n  } // Reject weird colons\n\n\n  if (protocol[2] !== \":\") {\n    return null;\n  } // Reject invalid characters in scheme according to\n  // https://datatracker.ietf.org/doc/html/rfc3986#section-3.1\n\n\n  if (!/^[a-zA-Z][a-zA-Z0-9+\\-.]*$/.test(protocol[1])) {\n    return null;\n  } // Lowercase the protocol\n\n\n  return protocol[1].toLowerCase();\n};\n/* harmony default export */ var utils = ({\n  contains,\n  deflt,\n  escape: utils_escape,\n  hyphenate,\n  getBaseElem,\n  isCharacterBox,\n  protocolFromUrl\n});\n;// CONCATENATED MODULE: ./src/Settings.js\n/* eslint no-console:0 */\n\n/**\n * This is a module for storing settings passed into KaTeX. It correctly handles\n * default settings.\n */\n\n\n\n// TODO: automatically generate documentation\n// TODO: check all properties on Settings exist\n// TODO: check the type of a property on Settings matches\nconst SETTINGS_SCHEMA = {\n  displayMode: {\n    type: \"boolean\",\n    description: \"Render math in display mode, which puts the math in \" + \"display style (so \\\\int and \\\\sum are large, for example), and \" + \"centers the math on the page on its own line.\",\n    cli: \"-d, --display-mode\"\n  },\n  output: {\n    type: {\n      enum: [\"htmlAndMathml\", \"html\", \"mathml\"]\n    },\n    description: \"Determines the markup language of the output.\",\n    cli: \"-F, --format <type>\"\n  },\n  leqno: {\n    type: \"boolean\",\n    description: \"Render display math in leqno style (left-justified tags).\"\n  },\n  fleqn: {\n    type: \"boolean\",\n    description: \"Render display math flush left.\"\n  },\n  throwOnError: {\n    type: \"boolean\",\n    default: true,\n    cli: \"-t, --no-throw-on-error\",\n    cliDescription: \"Render errors (in the color given by --error-color) ins\" + \"tead of throwing a ParseError exception when encountering an error.\"\n  },\n  errorColor: {\n    type: \"string\",\n    default: \"#cc0000\",\n    cli: \"-c, --error-color <color>\",\n    cliDescription: \"A color string given in the format 'rgb' or 'rrggbb' \" + \"(no #). This option determines the color of errors rendered by the \" + \"-t option.\",\n    cliProcessor: color => \"#\" + color\n  },\n  macros: {\n    type: \"object\",\n    cli: \"-m, --macro <def>\",\n    cliDescription: \"Define custom macro of the form '\\\\foo:expansion' (use \" + \"multiple -m arguments for multiple macros).\",\n    cliDefault: [],\n    cliProcessor: (def, defs) => {\n      defs.push(def);\n      return defs;\n    }\n  },\n  minRuleThickness: {\n    type: \"number\",\n    description: \"Specifies a minimum thickness, in ems, for fraction lines,\" + \" `\\\\sqrt` top lines, `{array}` vertical lines, `\\\\hline`, \" + \"`\\\\hdashline`, `\\\\underline`, `\\\\overline`, and the borders of \" + \"`\\\\fbox`, `\\\\boxed`, and `\\\\fcolorbox`.\",\n    processor: t => Math.max(0, t),\n    cli: \"--min-rule-thickness <size>\",\n    cliProcessor: parseFloat\n  },\n  colorIsTextColor: {\n    type: \"boolean\",\n    description: \"Makes \\\\color behave like LaTeX's 2-argument \\\\textcolor, \" + \"instead of LaTeX's one-argument \\\\color mode change.\",\n    cli: \"-b, --color-is-text-color\"\n  },\n  strict: {\n    type: [{\n      enum: [\"warn\", \"ignore\", \"error\"]\n    }, \"boolean\", \"function\"],\n    description: \"Turn on strict / LaTeX faithfulness mode, which throws an \" + \"error if the input uses features that are not supported by LaTeX.\",\n    cli: \"-S, --strict\",\n    cliDefault: false\n  },\n  trust: {\n    type: [\"boolean\", \"function\"],\n    description: \"Trust the input, enabling all HTML features such as \\\\url.\",\n    cli: \"-T, --trust\"\n  },\n  maxSize: {\n    type: \"number\",\n    default: Infinity,\n    description: \"If non-zero, all user-specified sizes, e.g. in \" + \"\\\\rule{500em}{500em}, will be capped to maxSize ems. Otherwise, \" + \"elements and spaces can be arbitrarily large\",\n    processor: s => Math.max(0, s),\n    cli: \"-s, --max-size <n>\",\n    cliProcessor: parseInt\n  },\n  maxExpand: {\n    type: \"number\",\n    default: 1000,\n    description: \"Limit the number of macro expansions to the specified \" + \"number, to prevent e.g. infinite macro loops. If set to Infinity, \" + \"the macro expander will try to fully expand as in LaTeX.\",\n    processor: n => Math.max(0, n),\n    cli: \"-e, --max-expand <n>\",\n    cliProcessor: n => n === \"Infinity\" ? Infinity : parseInt(n)\n  },\n  globalGroup: {\n    type: \"boolean\",\n    cli: false\n  }\n};\n\nfunction getDefaultValue(schema) {\n  if (schema.default) {\n    return schema.default;\n  }\n\n  const type = schema.type;\n  const defaultType = Array.isArray(type) ? type[0] : type;\n\n  if (typeof defaultType !== 'string') {\n    return defaultType.enum[0];\n  }\n\n  switch (defaultType) {\n    case 'boolean':\n      return false;\n\n    case 'string':\n      return '';\n\n    case 'number':\n      return 0;\n\n    case 'object':\n      return {};\n  }\n}\n/**\n * The main Settings object\n *\n * The current options stored are:\n *  - displayMode: Whether the expression should be typeset as inline math\n *                 (false, the default), meaning that the math starts in\n *                 \\textstyle and is placed in an inline-block); or as display\n *                 math (true), meaning that the math starts in \\displaystyle\n *                 and is placed in a block with vertical margin.\n */\n\n\nclass Settings {\n  constructor(options) {\n    this.displayMode = void 0;\n    this.output = void 0;\n    this.leqno = void 0;\n    this.fleqn = void 0;\n    this.throwOnError = void 0;\n    this.errorColor = void 0;\n    this.macros = void 0;\n    this.minRuleThickness = void 0;\n    this.colorIsTextColor = void 0;\n    this.strict = void 0;\n    this.trust = void 0;\n    this.maxSize = void 0;\n    this.maxExpand = void 0;\n    this.globalGroup = void 0;\n    // allow null options\n    options = options || {};\n\n    for (const prop in SETTINGS_SCHEMA) {\n      if (SETTINGS_SCHEMA.hasOwnProperty(prop)) {\n        // $FlowFixMe\n        const schema = SETTINGS_SCHEMA[prop]; // TODO: validate options\n        // $FlowFixMe\n\n        this[prop] = options[prop] !== undefined ? schema.processor ? schema.processor(options[prop]) : options[prop] : getDefaultValue(schema);\n      }\n    }\n  }\n  /**\n   * Report nonstrict (non-LaTeX-compatible) input.\n   * Can safely not be called if `this.strict` is false in JavaScript.\n   */\n\n\n  reportNonstrict(errorCode, errorMsg, token) {\n    let strict = this.strict;\n\n    if (typeof strict === \"function\") {\n      // Allow return value of strict function to be boolean or string\n      // (or null/undefined, meaning no further processing).\n      strict = strict(errorCode, errorMsg, token);\n    }\n\n    if (!strict || strict === \"ignore\") {\n      return;\n    } else if (strict === true || strict === \"error\") {\n      throw new src_ParseError(\"LaTeX-incompatible input and strict mode is set to 'error': \" + (errorMsg + \" [\" + errorCode + \"]\"), token);\n    } else if (strict === \"warn\") {\n      typeof console !== \"undefined\" && console.warn(\"LaTeX-incompatible input and strict mode is set to 'warn': \" + (errorMsg + \" [\" + errorCode + \"]\"));\n    } else {\n      // won't happen in type-safe code\n      typeof console !== \"undefined\" && console.warn(\"LaTeX-incompatible input and strict mode is set to \" + (\"unrecognized '\" + strict + \"': \" + errorMsg + \" [\" + errorCode + \"]\"));\n    }\n  }\n  /**\n   * Check whether to apply strict (LaTeX-adhering) behavior for unusual\n   * input (like `\\\\`).  Unlike `nonstrict`, will not throw an error;\n   * instead, \"error\" translates to a return value of `true`, while \"ignore\"\n   * translates to a return value of `false`.  May still print a warning:\n   * \"warn\" prints a warning and returns `false`.\n   * This is for the second category of `errorCode`s listed in the README.\n   */\n\n\n  useStrictBehavior(errorCode, errorMsg, token) {\n    let strict = this.strict;\n\n    if (typeof strict === \"function\") {\n      // Allow return value of strict function to be boolean or string\n      // (or null/undefined, meaning no further processing).\n      // But catch any exceptions thrown by function, treating them\n      // like \"error\".\n      try {\n        strict = strict(errorCode, errorMsg, token);\n      } catch (error) {\n        strict = \"error\";\n      }\n    }\n\n    if (!strict || strict === \"ignore\") {\n      return false;\n    } else if (strict === true || strict === \"error\") {\n      return true;\n    } else if (strict === \"warn\") {\n      typeof console !== \"undefined\" && console.warn(\"LaTeX-incompatible input and strict mode is set to 'warn': \" + (errorMsg + \" [\" + errorCode + \"]\"));\n      return false;\n    } else {\n      // won't happen in type-safe code\n      typeof console !== \"undefined\" && console.warn(\"LaTeX-incompatible input and strict mode is set to \" + (\"unrecognized '\" + strict + \"': \" + errorMsg + \" [\" + errorCode + \"]\"));\n      return false;\n    }\n  }\n  /**\n   * Check whether to test potentially dangerous input, and return\n   * `true` (trusted) or `false` (untrusted).  The sole argument `context`\n   * should be an object with `command` field specifying the relevant LaTeX\n   * command (as a string starting with `\\`), and any other arguments, etc.\n   * If `context` has a `url` field, a `protocol` field will automatically\n   * get added by this function (changing the specified object).\n   */\n\n\n  isTrusted(context) {\n    if (context.url && !context.protocol) {\n      const protocol = utils.protocolFromUrl(context.url);\n\n      if (protocol == null) {\n        return false;\n      }\n\n      context.protocol = protocol;\n    }\n\n    const trust = typeof this.trust === \"function\" ? this.trust(context) : this.trust;\n    return Boolean(trust);\n  }\n\n}\n;// CONCATENATED MODULE: ./src/Style.js\n/**\n * This file contains information and classes for the various kinds of styles\n * used in TeX. It provides a generic `Style` class, which holds information\n * about a specific style. It then provides instances of all the different kinds\n * of styles possible, and provides functions to move between them and get\n * information about them.\n */\n\n/**\n * The main style class. Contains a unique id for the style, a size (which is\n * the same for cramped and uncramped version of a style), and a cramped flag.\n */\nclass Style {\n  constructor(id, size, cramped) {\n    this.id = void 0;\n    this.size = void 0;\n    this.cramped = void 0;\n    this.id = id;\n    this.size = size;\n    this.cramped = cramped;\n  }\n  /**\n   * Get the style of a superscript given a base in the current style.\n   */\n\n\n  sup() {\n    return styles[sup[this.id]];\n  }\n  /**\n   * Get the style of a subscript given a base in the current style.\n   */\n\n\n  sub() {\n    return styles[sub[this.id]];\n  }\n  /**\n   * Get the style of a fraction numerator given the fraction in the current\n   * style.\n   */\n\n\n  fracNum() {\n    return styles[fracNum[this.id]];\n  }\n  /**\n   * Get the style of a fraction denominator given the fraction in the current\n   * style.\n   */\n\n\n  fracDen() {\n    return styles[fracDen[this.id]];\n  }\n  /**\n   * Get the cramped version of a style (in particular, cramping a cramped style\n   * doesn't change the style).\n   */\n\n\n  cramp() {\n    return styles[cramp[this.id]];\n  }\n  /**\n   * Get a text or display version of this style.\n   */\n\n\n  text() {\n    return styles[Style_text[this.id]];\n  }\n  /**\n   * Return true if this style is tightly spaced (scriptstyle/scriptscriptstyle)\n   */\n\n\n  isTight() {\n    return this.size >= 2;\n  }\n\n} // Export an interface for type checking, but don't expose the implementation.\n// This way, no more styles can be generated.\n\n\n// IDs of the different styles\nconst D = 0;\nconst Dc = 1;\nconst T = 2;\nconst Tc = 3;\nconst S = 4;\nconst Sc = 5;\nconst SS = 6;\nconst SSc = 7; // Instances of the different styles\n\nconst styles = [new Style(D, 0, false), new Style(Dc, 0, true), new Style(T, 1, false), new Style(Tc, 1, true), new Style(S, 2, false), new Style(Sc, 2, true), new Style(SS, 3, false), new Style(SSc, 3, true)]; // Lookup tables for switching from one style to another\n\nconst sup = [S, Sc, S, Sc, SS, SSc, SS, SSc];\nconst sub = [Sc, Sc, Sc, Sc, SSc, SSc, SSc, SSc];\nconst fracNum = [T, Tc, S, Sc, SS, SSc, SS, SSc];\nconst fracDen = [Tc, Tc, Sc, Sc, SSc, SSc, SSc, SSc];\nconst cramp = [Dc, Dc, Tc, Tc, Sc, Sc, SSc, SSc];\nconst Style_text = [D, Dc, T, Tc, T, Tc, T, Tc]; // We only export some of the styles.\n\n/* harmony default export */ var src_Style = ({\n  DISPLAY: styles[D],\n  TEXT: styles[T],\n  SCRIPT: styles[S],\n  SCRIPTSCRIPT: styles[SS]\n});\n;// CONCATENATED MODULE: ./src/unicodeScripts.js\n/*\n * This file defines the Unicode scripts and script families that we\n * support. To add new scripts or families, just add a new entry to the\n * scriptData array below. Adding scripts to the scriptData array allows\n * characters from that script to appear in \\text{} environments.\n */\n\n/**\n * Each script or script family has a name and an array of blocks.\n * Each block is an array of two numbers which specify the start and\n * end points (inclusive) of a block of Unicode codepoints.\n */\n\n/**\n * Unicode block data for the families of scripts we support in \\text{}.\n * Scripts only need to appear here if they do not have font metrics.\n */\nconst scriptData = [{\n  // Latin characters beyond the Latin-1 characters we have metrics for.\n  // Needed for Czech, Hungarian and Turkish text, for example.\n  name: 'latin',\n  blocks: [[0x0100, 0x024f], // Latin Extended-A and Latin Extended-B\n  [0x0300, 0x036f] // Combining Diacritical marks\n  ]\n}, {\n  // The Cyrillic script used by Russian and related languages.\n  // A Cyrillic subset used to be supported as explicitly defined\n  // symbols in symbols.js\n  name: 'cyrillic',\n  blocks: [[0x0400, 0x04ff]]\n}, {\n  // Armenian\n  name: 'armenian',\n  blocks: [[0x0530, 0x058F]]\n}, {\n  // The Brahmic scripts of South and Southeast Asia\n  // Devanagari (0900097F)\n  // Bengali (098009FF)\n  // Gurmukhi (0A000A7F)\n  // Gujarati (0A800AFF)\n  // Oriya (0B000B7F)\n  // Tamil (0B800BFF)\n  // Telugu (0C000C7F)\n  // Kannada (0C800CFF)\n  // Malayalam (0D000D7F)\n  // Sinhala (0D800DFF)\n  // Thai (0E000E7F)\n  // Lao (0E800EFF)\n  // Tibetan (0F000FFF)\n  // Myanmar (1000109F)\n  name: 'brahmic',\n  blocks: [[0x0900, 0x109F]]\n}, {\n  name: 'georgian',\n  blocks: [[0x10A0, 0x10ff]]\n}, {\n  // Chinese and Japanese.\n  // The \"k\" in cjk is for Korean, but we've separated Korean out\n  name: \"cjk\",\n  blocks: [[0x3000, 0x30FF], // CJK symbols and punctuation, Hiragana, Katakana\n  [0x4E00, 0x9FAF], // CJK ideograms\n  [0xFF00, 0xFF60] // Fullwidth punctuation\n  // TODO: add halfwidth Katakana and Romanji glyphs\n  ]\n}, {\n  // Korean\n  name: 'hangul',\n  blocks: [[0xAC00, 0xD7AF]]\n}];\n/**\n * Given a codepoint, return the name of the script or script family\n * it is from, or null if it is not part of a known block\n */\n\nfunction scriptFromCodepoint(codepoint) {\n  for (let i = 0; i < scriptData.length; i++) {\n    const script = scriptData[i];\n\n    for (let i = 0; i < script.blocks.length; i++) {\n      const block = script.blocks[i];\n\n      if (codepoint >= block[0] && codepoint <= block[1]) {\n        return script.name;\n      }\n    }\n  }\n\n  return null;\n}\n/**\n * A flattened version of all the supported blocks in a single array.\n * This is an optimization to make supportedCodepoint() fast.\n */\n\nconst allBlocks = [];\nscriptData.forEach(s => s.blocks.forEach(b => allBlocks.push(...b)));\n/**\n * Given a codepoint, return true if it falls within one of the\n * scripts or script families defined above and false otherwise.\n *\n * Micro benchmarks shows that this is faster than\n * /[\\u3000-\\u30FF\\u4E00-\\u9FAF\\uFF00-\\uFF60\\uAC00-\\uD7AF\\u0900-\\u109F]/.test()\n * in Firefox, Chrome and Node.\n */\n\nfunction supportedCodepoint(codepoint) {\n  for (let i = 0; i < allBlocks.length; i += 2) {\n    if (codepoint >= allBlocks[i] && codepoint <= allBlocks[i + 1]) {\n      return true;\n    }\n  }\n\n  return false;\n}\n;// CONCATENATED MODULE: ./src/svgGeometry.js\n/**\n * This file provides support to domTree.js and delimiter.js.\n * It's a storehouse of path geometry for SVG images.\n */\n// In all paths below, the viewBox-to-em scale is 1000:1.\nconst hLinePad = 80; // padding above a sqrt vinculum. Prevents image cropping.\n// The vinculum of a \\sqrt can be made thicker by a KaTeX rendering option.\n// Think of variable extraVinculum as two detours in the SVG path.\n// The detour begins at the lower left of the area labeled extraVinculum below.\n// The detour proceeds one extraVinculum distance up and slightly to the right,\n// displacing the radiused corner between surd and vinculum. The radius is\n// traversed as usual, then the detour resumes. It goes right, to the end of\n// the very long vinculum, then down one extraVinculum distance,\n// after which it resumes regular path geometry for the radical.\n\n/*                                                  vinculum\n                                                   /\n         /extraVinculum\n        / 0.04em (40 unit) std vinculum thickness\n       / /\n      / /\n     / /\\\n    / / surd\n*/\n\nconst sqrtMain = function (extraVinculum, hLinePad) {\n  // sqrtMain path geometry is from glyph U221A in the font KaTeX Main\n  return \"M95,\" + (622 + extraVinculum + hLinePad) + \"\\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\\nc69,-144,104.5,-217.7,106.5,-221\\nl\" + extraVinculum / 2.075 + \" -\" + extraVinculum + \"\\nc5.3,-9.3,12,-14,20,-14\\nH400000v\" + (40 + extraVinculum) + \"H845.2724\\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\\nM\" + (834 + extraVinculum) + \" \" + hLinePad + \"h400000v\" + (40 + extraVinculum) + \"h-400000z\";\n};\n\nconst sqrtSize1 = function (extraVinculum, hLinePad) {\n  // size1 is from glyph U221A in the font KaTeX_Size1-Regular\n  return \"M263,\" + (601 + extraVinculum + hLinePad) + \"c0.7,0,18,39.7,52,119\\nc34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120\\nc340,-704.7,510.7,-1060.3,512,-1067\\nl\" + extraVinculum / 2.084 + \" -\" + extraVinculum + \"\\nc4.7,-7.3,11,-11,19,-11\\nH40000v\" + (40 + extraVinculum) + \"H1012.3\\ns-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232\\nc-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1\\ns-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26\\nc-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z\\nM\" + (1001 + extraVinculum) + \" \" + hLinePad + \"h400000v\" + (40 + extraVinculum) + \"h-400000z\";\n};\n\nconst sqrtSize2 = function (extraVinculum, hLinePad) {\n  // size2 is from glyph U221A in the font KaTeX_Size2-Regular\n  return \"M983 \" + (10 + extraVinculum + hLinePad) + \"\\nl\" + extraVinculum / 3.13 + \" -\" + extraVinculum + \"\\nc4,-6.7,10,-10,18,-10 H400000v\" + (40 + extraVinculum) + \"\\nH1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7\\ns-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744\\nc-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30\\nc26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722\\nc56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5\\nc53.7,-170.3,84.5,-266.8,92.5,-289.5z\\nM\" + (1001 + extraVinculum) + \" \" + hLinePad + \"h400000v\" + (40 + extraVinculum) + \"h-400000z\";\n};\n\nconst sqrtSize3 = function (extraVinculum, hLinePad) {\n  // size3 is from glyph U221A in the font KaTeX_Size3-Regular\n  return \"M424,\" + (2398 + extraVinculum + hLinePad) + \"\\nc-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514\\nc0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20\\ns-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121\\ns209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081\\nl\" + extraVinculum / 4.223 + \" -\" + extraVinculum + \"c4,-6.7,10,-10,18,-10 H400000\\nv\" + (40 + extraVinculum) + \"H1014.6\\ns-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185\\nc-2,6,-10,9,-24,9\\nc-8,0,-12,-0.7,-12,-2z M\" + (1001 + extraVinculum) + \" \" + hLinePad + \"\\nh400000v\" + (40 + extraVinculum) + \"h-400000z\";\n};\n\nconst sqrtSize4 = function (extraVinculum, hLinePad) {\n  // size4 is from glyph U221A in the font KaTeX_Size4-Regular\n  return \"M473,\" + (2713 + extraVinculum + hLinePad) + \"\\nc339.3,-1799.3,509.3,-2700,510,-2702 l\" + extraVinculum / 5.298 + \" -\" + extraVinculum + \"\\nc3.3,-7.3,9.3,-11,18,-11 H400000v\" + (40 + extraVinculum) + \"H1017.7\\ns-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9\\nc-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200\\nc0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26\\ns76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,\\n606zM\" + (1001 + extraVinculum) + \" \" + hLinePad + \"h400000v\" + (40 + extraVinculum) + \"H1017.7z\";\n};\n\nconst phasePath = function (y) {\n  const x = y / 2; // x coordinate at top of angle\n\n  return \"M400000 \" + y + \" H0 L\" + x + \" 0 l65 45 L145 \" + (y - 80) + \" H400000z\";\n};\n\nconst sqrtTall = function (extraVinculum, hLinePad, viewBoxHeight) {\n  // sqrtTall is from glyph U23B7 in the font KaTeX_Size4-Regular\n  // One path edge has a variable length. It runs vertically from the vinculum\n  // to a point near (14 units) the bottom of the surd. The vinculum\n  // is normally 40 units thick. So the length of the line in question is:\n  const vertSegment = viewBoxHeight - 54 - hLinePad - extraVinculum;\n  return \"M702 \" + (extraVinculum + hLinePad) + \"H400000\" + (40 + extraVinculum) + \"\\nH742v\" + vertSegment + \"l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1\\nh-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170\\nc-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667\\n219 661 l218 661zM702 \" + hLinePad + \"H400000v\" + (40 + extraVinculum) + \"H742z\";\n};\n\nconst sqrtPath = function (size, extraVinculum, viewBoxHeight) {\n  extraVinculum = 1000 * extraVinculum; // Convert from document ems to viewBox.\n\n  let path = \"\";\n\n  switch (size) {\n    case \"sqrtMain\":\n      path = sqrtMain(extraVinculum, hLinePad);\n      break;\n\n    case \"sqrtSize1\":\n      path = sqrtSize1(extraVinculum, hLinePad);\n      break;\n\n    case \"sqrtSize2\":\n      path = sqrtSize2(extraVinculum, hLinePad);\n      break;\n\n    case \"sqrtSize3\":\n      path = sqrtSize3(extraVinculum, hLinePad);\n      break;\n\n    case \"sqrtSize4\":\n      path = sqrtSize4(extraVinculum, hLinePad);\n      break;\n\n    case \"sqrtTall\":\n      path = sqrtTall(extraVinculum, hLinePad, viewBoxHeight);\n  }\n\n  return path;\n};\nconst innerPath = function (name, height) {\n  // The inner part of stretchy tall delimiters\n  switch (name) {\n    case \"\\u239c\":\n      return \"M291 0 H417 V\" + height + \" H291z M291 0 H417 V\" + height + \" H291z\";\n\n    case \"\\u2223\":\n      return \"M145 0 H188 V\" + height + \" H145z M145 0 H188 V\" + height + \" H145z\";\n\n    case \"\\u2225\":\n      return \"M145 0 H188 V\" + height + \" H145z M145 0 H188 V\" + height + \" H145z\" + (\"M367 0 H410 V\" + height + \" H367z M367 0 H410 V\" + height + \" H367z\");\n\n    case \"\\u239f\":\n      return \"M457 0 H583 V\" + height + \" H457z M457 0 H583 V\" + height + \" H457z\";\n\n    case \"\\u23a2\":\n      return \"M319 0 H403 V\" + height + \" H319z M319 0 H403 V\" + height + \" H319z\";\n\n    case \"\\u23a5\":\n      return \"M263 0 H347 V\" + height + \" H263z M263 0 H347 V\" + height + \" H263z\";\n\n    case \"\\u23aa\":\n      return \"M384 0 H504 V\" + height + \" H384z M384 0 H504 V\" + height + \" H384z\";\n\n    case \"\\u23d0\":\n      return \"M312 0 H355 V\" + height + \" H312z M312 0 H355 V\" + height + \" H312z\";\n\n    case \"\\u2016\":\n      return \"M257 0 H300 V\" + height + \" H257z M257 0 H300 V\" + height + \" H257z\" + (\"M478 0 H521 V\" + height + \" H478z M478 0 H521 V\" + height + \" H478z\");\n\n    default:\n      return \"\";\n  }\n};\nconst path = {\n  // The doubleleftarrow geometry is from glyph U+21D0 in the font KaTeX Main\n  doubleleftarrow: \"M262 157\\nl10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3\\n 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28\\n 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5\\nc2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5\\n 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87\\n-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7\\n-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z\\nm8 0v40h399730v-40zm0 194v40h399730v-40z\",\n  // doublerightarrow is from glyph U+21D2 in font KaTeX Main\n  doublerightarrow: \"M399738 392l\\n-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5\\n 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88\\n-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68\\n-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18\\n-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782\\nc-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3\\n-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z\",\n  // leftarrow is from glyph U+2190 in font KaTeX Main\n  leftarrow: \"M400000 241H110l3-3c68.7-52.7 113.7-120\\n 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8\\n-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247\\nc-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208\\n 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3\\n 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202\\n l-3-3h399890zM100 241v40h399900v-40z\",\n  // overbrace is from glyphs U+23A9/23A8/23A7 in font KaTeX_Size4-Regular\n  leftbrace: \"M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117\\n-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7\\n 5-6 9-10 13-.7 1-7.3 1-20 1H6z\",\n  leftbraceunder: \"M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13\\n 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688\\n 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7\\n-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z\",\n  // overgroup is from the MnSymbol package (public domain)\n  leftgroup: \"M400000 80\\nH435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0\\n 435 0h399565z\",\n  leftgroupunder: \"M400000 262\\nH435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219\\n 435 219h399565z\",\n  // Harpoons are from glyph U+21BD in font KaTeX Main\n  leftharpoon: \"M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3\\n-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5\\n-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7\\n-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z\",\n  leftharpoonplus: \"M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5\\n 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3\\n-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7\\n-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z\\nm0 0v40h400000v-40z\",\n  leftharpoondown: \"M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333\\n 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5\\n 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667\\n-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z\",\n  leftharpoondownplus: \"M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12\\n 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7\\n-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0\\nv40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z\",\n  // hook is from glyph U+21A9 in font KaTeX Main\n  lefthook: \"M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5\\n-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3\\n-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21\\n 71.5 23h399859zM103 281v-40h399897v40z\",\n  leftlinesegment: \"M40 281 V428 H0 V94 H40 V241 H400000 v40z\\nM40 281 V428 H0 V94 H40 V241 H400000 v40z\",\n  leftmapsto: \"M40 281 V448H0V74H40V241H400000v40z\\nM40 281 V448H0V74H40V241H400000v40z\",\n  // tofrom is from glyph U+21C4 in font KaTeX AMS Regular\n  leftToFrom: \"M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23\\n-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8\\nc28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3\\n 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z\",\n  longequal: \"M0 50 h400000 v40H0z m0 194h40000v40H0z\\nM0 50 h400000 v40H0z m0 194h40000v40H0z\",\n  midbrace: \"M200428 334\\nc-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14\\n-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7\\n 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11\\n 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z\",\n  midbraceunder: \"M199572 214\\nc100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14\\n 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3\\n 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0\\n-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z\",\n  oiintSize1: \"M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6\\n-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z\\nm368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8\\n60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z\",\n  oiintSize2: \"M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8\\n-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z\\nm502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2\\nc0 110 84 276 504 276s502.4-166 502.4-276z\",\n  oiiintSize1: \"M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6\\n-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z\\nm525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0\\n85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z\",\n  oiiintSize2: \"M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8\\n-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z\\nm770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1\\nc0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z\",\n  rightarrow: \"M0 241v40h399891c-47.3 35.3-84 78-110 128\\n-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20\\n 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7\\n 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85\\n-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\\n 151.7 139 205zm0 0v40h399900v-40z\",\n  rightbrace: \"M400000 542l\\n-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5\\ns-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1\\nc124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z\",\n  rightbraceunder: \"M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3\\n 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237\\n-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z\",\n  rightgroup: \"M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0\\n 3-1 3-3v-38c-76-158-257-219-435-219H0z\",\n  rightgroupunder: \"M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18\\n 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z\",\n  rightharpoon: \"M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3\\n-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2\\n-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58\\n 69.2 92 94.5zm0 0v40h399900v-40z\",\n  rightharpoonplus: \"M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11\\n-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7\\n 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z\\nm0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z\",\n  rightharpoondown: \"M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8\\n 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5\\n-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95\\n-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z\",\n  rightharpoondownplus: \"M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8\\n 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3\\n 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3\\n-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z\\nm0-194v40h400000v-40zm0 0v40h400000v-40z\",\n  righthook: \"M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3\\n 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0\\n-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21\\n 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z\",\n  rightlinesegment: \"M399960 241 V94 h40 V428 h-40 V281 H0 v-40z\\nM399960 241 V94 h40 V428 h-40 V281 H0 v-40z\",\n  rightToFrom: \"M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23\\n 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32\\n-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142\\n-167z M100 147v40h399900v-40zM0 341v40h399900v-40z\",\n  // twoheadleftarrow is from glyph U+219E in font KaTeX AMS Regular\n  twoheadleftarrow: \"M0 167c68 40\\n 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69\\n-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3\\n-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19\\n-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101\\n 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z\",\n  twoheadrightarrow: \"M400000 167\\nc-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3\\n 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42\\n 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333\\n-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70\\n 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z\",\n  // tilde1 is a modified version of a glyph from the MnSymbol package\n  tilde1: \"M200 55.538c-77 0-168 73.953-177 73.953-3 0-7\\n-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0\\n 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0\\n 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128\\n-68.267.847-113-73.952-191-73.952z\",\n  // ditto tilde2, tilde3, & tilde4\n  tilde2: \"M344 55.266c-142 0-300.638 81.316-311.5 86.418\\n-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9\\n 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114\\nc1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751\\n 181.476 676 181.476c-149 0-189-126.21-332-126.21z\",\n  tilde3: \"M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457\\n-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0\\n 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697\\n 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696\\n -338 0-409-156.573-744-156.573z\",\n  tilde4: \"M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345\\n-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409\\n 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9\\n 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409\\n -175.236-744-175.236z\",\n  // vec is from glyph U+20D7 in font KaTeX Main\n  vec: \"M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\\nc-16-25.333-24-45-24-59z\",\n  // widehat1 is a modified version of a glyph from the MnSymbol package\n  widehat1: \"M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22\\nc-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z\",\n  // ditto widehat2, widehat3, & widehat4\n  widehat2: \"M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10\\n-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z\",\n  widehat3: \"M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10\\n-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z\",\n  widehat4: \"M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10\\n-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z\",\n  // widecheck paths are all inverted versions of widehat\n  widecheck1: \"M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,\\n-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z\",\n  widecheck2: \"M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\\n-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z\",\n  widecheck3: \"M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\\n-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z\",\n  widecheck4: \"M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\\n-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z\",\n  // The next ten paths support reaction arrows from the mhchem package.\n  // Arrows for \\ce{<-->} are offset from xAxis by 0.22ex, per mhchem in LaTeX\n  // baraboveleftarrow is mostly from glyph U+2190 in font KaTeX Main\n  baraboveleftarrow: \"M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202\\nc4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5\\nc-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130\\ns-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47\\n121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6\\ns2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11\\nc0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z\\nM100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z\",\n  // rightarrowabovebar is mostly from glyph U+2192, KaTeX Main\n  rightarrowabovebar: \"M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32\\n-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0\\n13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39\\n-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5\\n-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\\n151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z\",\n  // The short left harpoon has 0.5em (i.e. 500 units) kern on the left end.\n  // Ref from mhchem.sty: \\rlap{\\raisebox{-.22ex}{$\\kern0.5em\n  baraboveshortleftharpoon: \"M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17\\nc2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21\\nc-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40\\nc-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z\\nM0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z\",\n  rightharpoonaboveshortbar: \"M0,241 l0,40c399126,0,399993,0,399993,0\\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\\nM0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z\",\n  shortbaraboveleftharpoon: \"M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,\\n1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,\\n-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z\\nM93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z\",\n  shortrightharpoonabovebar: \"M53,241l0,40c398570,0,399437,0,399437,0\\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\\nM500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z\"\n};\nconst tallDelim = function (label, midHeight) {\n  switch (label) {\n    case \"lbrack\":\n      return \"M403 1759 V84 H666 V0 H319 V1759 v\" + midHeight + \" v1759 h347 v-84\\nH403z M403 1759 V0 H319 V1759 v\" + midHeight + \" v1759 h84z\";\n\n    case \"rbrack\":\n      return \"M347 1759 V0 H0 V84 H263 V1759 v\" + midHeight + \" v1759 H0 v84 H347z\\nM347 1759 V0 H263 V1759 v\" + midHeight + \" v1759 h84z\";\n\n    case \"vert\":\n      return \"M145 15 v585 v\" + midHeight + \" v585 c2.667,10,9.667,15,21,15\\nc10,0,16.667,-5,20,-15 v-585 v\" + -midHeight + \" v-585 c-2.667,-10,-9.667,-15,-21,-15\\nc-10,0,-16.667,5,-20,15z M188 15 H145 v585 v\" + midHeight + \" v585 h43z\";\n\n    case \"doublevert\":\n      return \"M145 15 v585 v\" + midHeight + \" v585 c2.667,10,9.667,15,21,15\\nc10,0,16.667,-5,20,-15 v-585 v\" + -midHeight + \" v-585 c-2.667,-10,-9.667,-15,-21,-15\\nc-10,0,-16.667,5,-20,15z M188 15 H145 v585 v\" + midHeight + \" v585 h43z\\nM367 15 v585 v\" + midHeight + \" v585 c2.667,10,9.667,15,21,15\\nc10,0,16.667,-5,20,-15 v-585 v\" + -midHeight + \" v-585 c-2.667,-10,-9.667,-15,-21,-15\\nc-10,0,-16.667,5,-20,15z M410 15 H367 v585 v\" + midHeight + \" v585 h43z\";\n\n    case \"lfloor\":\n      return \"M319 602 V0 H403 V602 v\" + midHeight + \" v1715 h263 v84 H319z\\nMM319 602 V0 H403 V602 v\" + midHeight + \" v1715 H319z\";\n\n    case \"rfloor\":\n      return \"M319 602 V0 H403 V602 v\" + midHeight + \" v1799 H0 v-84 H319z\\nMM319 602 V0 H403 V602 v\" + midHeight + \" v1715 H319z\";\n\n    case \"lceil\":\n      return \"M403 1759 V84 H666 V0 H319 V1759 v\" + midHeight + \" v602 h84z\\nM403 1759 V0 H319 V1759 v\" + midHeight + \" v602 h84z\";\n\n    case \"rceil\":\n      return \"M347 1759 V0 H0 V84 H263 V1759 v\" + midHeight + \" v602 h84z\\nM347 1759 V0 h-84 V1759 v\" + midHeight + \" v602 h84z\";\n\n    case \"lparen\":\n      return \"M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1\\nc-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,\\n-36,557 l0,\" + (midHeight + 84) + \"c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,\\n949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9\\nc0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,\\n-544.7,-112.5,-882c-2,-104,-3,-167,-3,-189\\nl0,-\" + (midHeight + 92) + \"c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,\\n-210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z\";\n\n    case \"rparen\":\n      return \"M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,\\n63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5\\nc11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0,\" + (midHeight + 9) + \"\\nc-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664\\nc-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11\\nc0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17\\nc242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558\\nl0,-\" + (midHeight + 144) + \"c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,\\n-470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z\";\n\n    default:\n      // We should not ever get here.\n      throw new Error(\"Unknown stretchy delimiter.\");\n  }\n};\n;// CONCATENATED MODULE: ./src/tree.js\n\n\n/**\n * This node represents a document fragment, which contains elements, but when\n * placed into the DOM doesn't have any representation itself. It only contains\n * children and doesn't have any DOM node properties.\n */\nclass DocumentFragment {\n  // HtmlDomNode\n  // Never used; needed for satisfying interface.\n  constructor(children) {\n    this.children = void 0;\n    this.classes = void 0;\n    this.height = void 0;\n    this.depth = void 0;\n    this.maxFontSize = void 0;\n    this.style = void 0;\n    this.children = children;\n    this.classes = [];\n    this.height = 0;\n    this.depth = 0;\n    this.maxFontSize = 0;\n    this.style = {};\n  }\n\n  hasClass(className) {\n    return utils.contains(this.classes, className);\n  }\n  /** Convert the fragment into a node. */\n\n\n  toNode() {\n    const frag = document.createDocumentFragment();\n\n    for (let i = 0; i < this.children.length; i++) {\n      frag.appendChild(this.children[i].toNode());\n    }\n\n    return frag;\n  }\n  /** Convert the fragment into HTML markup. */\n\n\n  toMarkup() {\n    let markup = \"\"; // Simply concatenate the markup for the children together.\n\n    for (let i = 0; i < this.children.length; i++) {\n      markup += this.children[i].toMarkup();\n    }\n\n    return markup;\n  }\n  /**\n   * Converts the math node into a string, similar to innerText. Applies to\n   * MathDomNode's only.\n   */\n\n\n  toText() {\n    // To avoid this, we would subclass documentFragment separately for\n    // MathML, but polyfills for subclassing is expensive per PR 1469.\n    // $FlowFixMe: Only works for ChildType = MathDomNode.\n    const toText = child => child.toText();\n\n    return this.children.map(toText).join(\"\");\n  }\n\n}\n;// CONCATENATED MODULE: ./src/fontMetricsData.js\n// This file is GENERATED by buildMetrics.sh. DO NOT MODIFY.\n/* harmony default export */ var fontMetricsData = ({\n  \"AMS-Regular\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"65\": [0, 0.68889, 0, 0, 0.72222],\n    \"66\": [0, 0.68889, 0, 0, 0.66667],\n    \"67\": [0, 0.68889, 0, 0, 0.72222],\n    \"68\": [0, 0.68889, 0, 0, 0.72222],\n    \"69\": [0, 0.68889, 0, 0, 0.66667],\n    \"70\": [0, 0.68889, 0, 0, 0.61111],\n    \"71\": [0, 0.68889, 0, 0, 0.77778],\n    \"72\": [0, 0.68889, 0, 0, 0.77778],\n    \"73\": [0, 0.68889, 0, 0, 0.38889],\n    \"74\": [0.16667, 0.68889, 0, 0, 0.5],\n    \"75\": [0, 0.68889, 0, 0, 0.77778],\n    \"76\": [0, 0.68889, 0, 0, 0.66667],\n    \"77\": [0, 0.68889, 0, 0, 0.94445],\n    \"78\": [0, 0.68889, 0, 0, 0.72222],\n    \"79\": [0.16667, 0.68889, 0, 0, 0.77778],\n    \"80\": [0, 0.68889, 0, 0, 0.61111],\n    \"81\": [0.16667, 0.68889, 0, 0, 0.77778],\n    \"82\": [0, 0.68889, 0, 0, 0.72222],\n    \"83\": [0, 0.68889, 0, 0, 0.55556],\n    \"84\": [0, 0.68889, 0, 0, 0.66667],\n    \"85\": [0, 0.68889, 0, 0, 0.72222],\n    \"86\": [0, 0.68889, 0, 0, 0.72222],\n    \"87\": [0, 0.68889, 0, 0, 1.0],\n    \"88\": [0, 0.68889, 0, 0, 0.72222],\n    \"89\": [0, 0.68889, 0, 0, 0.72222],\n    \"90\": [0, 0.68889, 0, 0, 0.66667],\n    \"107\": [0, 0.68889, 0, 0, 0.55556],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"165\": [0, 0.675, 0.025, 0, 0.75],\n    \"174\": [0.15559, 0.69224, 0, 0, 0.94666],\n    \"240\": [0, 0.68889, 0, 0, 0.55556],\n    \"295\": [0, 0.68889, 0, 0, 0.54028],\n    \"710\": [0, 0.825, 0, 0, 2.33334],\n    \"732\": [0, 0.9, 0, 0, 2.33334],\n    \"770\": [0, 0.825, 0, 0, 2.33334],\n    \"771\": [0, 0.9, 0, 0, 2.33334],\n    \"989\": [0.08167, 0.58167, 0, 0, 0.77778],\n    \"1008\": [0, 0.43056, 0.04028, 0, 0.66667],\n    \"8245\": [0, 0.54986, 0, 0, 0.275],\n    \"8463\": [0, 0.68889, 0, 0, 0.54028],\n    \"8487\": [0, 0.68889, 0, 0, 0.72222],\n    \"8498\": [0, 0.68889, 0, 0, 0.55556],\n    \"8502\": [0, 0.68889, 0, 0, 0.66667],\n    \"8503\": [0, 0.68889, 0, 0, 0.44445],\n    \"8504\": [0, 0.68889, 0, 0, 0.66667],\n    \"8513\": [0, 0.68889, 0, 0, 0.63889],\n    \"8592\": [-0.03598, 0.46402, 0, 0, 0.5],\n    \"8594\": [-0.03598, 0.46402, 0, 0, 0.5],\n    \"8602\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8603\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8606\": [0.01354, 0.52239, 0, 0, 1.0],\n    \"8608\": [0.01354, 0.52239, 0, 0, 1.0],\n    \"8610\": [0.01354, 0.52239, 0, 0, 1.11111],\n    \"8611\": [0.01354, 0.52239, 0, 0, 1.11111],\n    \"8619\": [0, 0.54986, 0, 0, 1.0],\n    \"8620\": [0, 0.54986, 0, 0, 1.0],\n    \"8621\": [-0.13313, 0.37788, 0, 0, 1.38889],\n    \"8622\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8624\": [0, 0.69224, 0, 0, 0.5],\n    \"8625\": [0, 0.69224, 0, 0, 0.5],\n    \"8630\": [0, 0.43056, 0, 0, 1.0],\n    \"8631\": [0, 0.43056, 0, 0, 1.0],\n    \"8634\": [0.08198, 0.58198, 0, 0, 0.77778],\n    \"8635\": [0.08198, 0.58198, 0, 0, 0.77778],\n    \"8638\": [0.19444, 0.69224, 0, 0, 0.41667],\n    \"8639\": [0.19444, 0.69224, 0, 0, 0.41667],\n    \"8642\": [0.19444, 0.69224, 0, 0, 0.41667],\n    \"8643\": [0.19444, 0.69224, 0, 0, 0.41667],\n    \"8644\": [0.1808, 0.675, 0, 0, 1.0],\n    \"8646\": [0.1808, 0.675, 0, 0, 1.0],\n    \"8647\": [0.1808, 0.675, 0, 0, 1.0],\n    \"8648\": [0.19444, 0.69224, 0, 0, 0.83334],\n    \"8649\": [0.1808, 0.675, 0, 0, 1.0],\n    \"8650\": [0.19444, 0.69224, 0, 0, 0.83334],\n    \"8651\": [0.01354, 0.52239, 0, 0, 1.0],\n    \"8652\": [0.01354, 0.52239, 0, 0, 1.0],\n    \"8653\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8654\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8655\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8666\": [0.13667, 0.63667, 0, 0, 1.0],\n    \"8667\": [0.13667, 0.63667, 0, 0, 1.0],\n    \"8669\": [-0.13313, 0.37788, 0, 0, 1.0],\n    \"8672\": [-0.064, 0.437, 0, 0, 1.334],\n    \"8674\": [-0.064, 0.437, 0, 0, 1.334],\n    \"8705\": [0, 0.825, 0, 0, 0.5],\n    \"8708\": [0, 0.68889, 0, 0, 0.55556],\n    \"8709\": [0.08167, 0.58167, 0, 0, 0.77778],\n    \"8717\": [0, 0.43056, 0, 0, 0.42917],\n    \"8722\": [-0.03598, 0.46402, 0, 0, 0.5],\n    \"8724\": [0.08198, 0.69224, 0, 0, 0.77778],\n    \"8726\": [0.08167, 0.58167, 0, 0, 0.77778],\n    \"8733\": [0, 0.69224, 0, 0, 0.77778],\n    \"8736\": [0, 0.69224, 0, 0, 0.72222],\n    \"8737\": [0, 0.69224, 0, 0, 0.72222],\n    \"8738\": [0.03517, 0.52239, 0, 0, 0.72222],\n    \"8739\": [0.08167, 0.58167, 0, 0, 0.22222],\n    \"8740\": [0.25142, 0.74111, 0, 0, 0.27778],\n    \"8741\": [0.08167, 0.58167, 0, 0, 0.38889],\n    \"8742\": [0.25142, 0.74111, 0, 0, 0.5],\n    \"8756\": [0, 0.69224, 0, 0, 0.66667],\n    \"8757\": [0, 0.69224, 0, 0, 0.66667],\n    \"8764\": [-0.13313, 0.36687, 0, 0, 0.77778],\n    \"8765\": [-0.13313, 0.37788, 0, 0, 0.77778],\n    \"8769\": [-0.13313, 0.36687, 0, 0, 0.77778],\n    \"8770\": [-0.03625, 0.46375, 0, 0, 0.77778],\n    \"8774\": [0.30274, 0.79383, 0, 0, 0.77778],\n    \"8776\": [-0.01688, 0.48312, 0, 0, 0.77778],\n    \"8778\": [0.08167, 0.58167, 0, 0, 0.77778],\n    \"8782\": [0.06062, 0.54986, 0, 0, 0.77778],\n    \"8783\": [0.06062, 0.54986, 0, 0, 0.77778],\n    \"8785\": [0.08198, 0.58198, 0, 0, 0.77778],\n    \"8786\": [0.08198, 0.58198, 0, 0, 0.77778],\n    \"8787\": [0.08198, 0.58198, 0, 0, 0.77778],\n    \"8790\": [0, 0.69224, 0, 0, 0.77778],\n    \"8791\": [0.22958, 0.72958, 0, 0, 0.77778],\n    \"8796\": [0.08198, 0.91667, 0, 0, 0.77778],\n    \"8806\": [0.25583, 0.75583, 0, 0, 0.77778],\n    \"8807\": [0.25583, 0.75583, 0, 0, 0.77778],\n    \"8808\": [0.25142, 0.75726, 0, 0, 0.77778],\n    \"8809\": [0.25142, 0.75726, 0, 0, 0.77778],\n    \"8812\": [0.25583, 0.75583, 0, 0, 0.5],\n    \"8814\": [0.20576, 0.70576, 0, 0, 0.77778],\n    \"8815\": [0.20576, 0.70576, 0, 0, 0.77778],\n    \"8816\": [0.30274, 0.79383, 0, 0, 0.77778],\n    \"8817\": [0.30274, 0.79383, 0, 0, 0.77778],\n    \"8818\": [0.22958, 0.72958, 0, 0, 0.77778],\n    \"8819\": [0.22958, 0.72958, 0, 0, 0.77778],\n    \"8822\": [0.1808, 0.675, 0, 0, 0.77778],\n    \"8823\": [0.1808, 0.675, 0, 0, 0.77778],\n    \"8828\": [0.13667, 0.63667, 0, 0, 0.77778],\n    \"8829\": [0.13667, 0.63667, 0, 0, 0.77778],\n    \"8830\": [0.22958, 0.72958, 0, 0, 0.77778],\n    \"8831\": [0.22958, 0.72958, 0, 0, 0.77778],\n    \"8832\": [0.20576, 0.70576, 0, 0, 0.77778],\n    \"8833\": [0.20576, 0.70576, 0, 0, 0.77778],\n    \"8840\": [0.30274, 0.79383, 0, 0, 0.77778],\n    \"8841\": [0.30274, 0.79383, 0, 0, 0.77778],\n    \"8842\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"8843\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"8847\": [0.03517, 0.54986, 0, 0, 0.77778],\n    \"8848\": [0.03517, 0.54986, 0, 0, 0.77778],\n    \"8858\": [0.08198, 0.58198, 0, 0, 0.77778],\n    \"8859\": [0.08198, 0.58198, 0, 0, 0.77778],\n    \"8861\": [0.08198, 0.58198, 0, 0, 0.77778],\n    \"8862\": [0, 0.675, 0, 0, 0.77778],\n    \"8863\": [0, 0.675, 0, 0, 0.77778],\n    \"8864\": [0, 0.675, 0, 0, 0.77778],\n    \"8865\": [0, 0.675, 0, 0, 0.77778],\n    \"8872\": [0, 0.69224, 0, 0, 0.61111],\n    \"8873\": [0, 0.69224, 0, 0, 0.72222],\n    \"8874\": [0, 0.69224, 0, 0, 0.88889],\n    \"8876\": [0, 0.68889, 0, 0, 0.61111],\n    \"8877\": [0, 0.68889, 0, 0, 0.61111],\n    \"8878\": [0, 0.68889, 0, 0, 0.72222],\n    \"8879\": [0, 0.68889, 0, 0, 0.72222],\n    \"8882\": [0.03517, 0.54986, 0, 0, 0.77778],\n    \"8883\": [0.03517, 0.54986, 0, 0, 0.77778],\n    \"8884\": [0.13667, 0.63667, 0, 0, 0.77778],\n    \"8885\": [0.13667, 0.63667, 0, 0, 0.77778],\n    \"8888\": [0, 0.54986, 0, 0, 1.11111],\n    \"8890\": [0.19444, 0.43056, 0, 0, 0.55556],\n    \"8891\": [0.19444, 0.69224, 0, 0, 0.61111],\n    \"8892\": [0.19444, 0.69224, 0, 0, 0.61111],\n    \"8901\": [0, 0.54986, 0, 0, 0.27778],\n    \"8903\": [0.08167, 0.58167, 0, 0, 0.77778],\n    \"8905\": [0.08167, 0.58167, 0, 0, 0.77778],\n    \"8906\": [0.08167, 0.58167, 0, 0, 0.77778],\n    \"8907\": [0, 0.69224, 0, 0, 0.77778],\n    \"8908\": [0, 0.69224, 0, 0, 0.77778],\n    \"8909\": [-0.03598, 0.46402, 0, 0, 0.77778],\n    \"8910\": [0, 0.54986, 0, 0, 0.76042],\n    \"8911\": [0, 0.54986, 0, 0, 0.76042],\n    \"8912\": [0.03517, 0.54986, 0, 0, 0.77778],\n    \"8913\": [0.03517, 0.54986, 0, 0, 0.77778],\n    \"8914\": [0, 0.54986, 0, 0, 0.66667],\n    \"8915\": [0, 0.54986, 0, 0, 0.66667],\n    \"8916\": [0, 0.69224, 0, 0, 0.66667],\n    \"8918\": [0.0391, 0.5391, 0, 0, 0.77778],\n    \"8919\": [0.0391, 0.5391, 0, 0, 0.77778],\n    \"8920\": [0.03517, 0.54986, 0, 0, 1.33334],\n    \"8921\": [0.03517, 0.54986, 0, 0, 1.33334],\n    \"8922\": [0.38569, 0.88569, 0, 0, 0.77778],\n    \"8923\": [0.38569, 0.88569, 0, 0, 0.77778],\n    \"8926\": [0.13667, 0.63667, 0, 0, 0.77778],\n    \"8927\": [0.13667, 0.63667, 0, 0, 0.77778],\n    \"8928\": [0.30274, 0.79383, 0, 0, 0.77778],\n    \"8929\": [0.30274, 0.79383, 0, 0, 0.77778],\n    \"8934\": [0.23222, 0.74111, 0, 0, 0.77778],\n    \"8935\": [0.23222, 0.74111, 0, 0, 0.77778],\n    \"8936\": [0.23222, 0.74111, 0, 0, 0.77778],\n    \"8937\": [0.23222, 0.74111, 0, 0, 0.77778],\n    \"8938\": [0.20576, 0.70576, 0, 0, 0.77778],\n    \"8939\": [0.20576, 0.70576, 0, 0, 0.77778],\n    \"8940\": [0.30274, 0.79383, 0, 0, 0.77778],\n    \"8941\": [0.30274, 0.79383, 0, 0, 0.77778],\n    \"8994\": [0.19444, 0.69224, 0, 0, 0.77778],\n    \"8995\": [0.19444, 0.69224, 0, 0, 0.77778],\n    \"9416\": [0.15559, 0.69224, 0, 0, 0.90222],\n    \"9484\": [0, 0.69224, 0, 0, 0.5],\n    \"9488\": [0, 0.69224, 0, 0, 0.5],\n    \"9492\": [0, 0.37788, 0, 0, 0.5],\n    \"9496\": [0, 0.37788, 0, 0, 0.5],\n    \"9585\": [0.19444, 0.68889, 0, 0, 0.88889],\n    \"9586\": [0.19444, 0.74111, 0, 0, 0.88889],\n    \"9632\": [0, 0.675, 0, 0, 0.77778],\n    \"9633\": [0, 0.675, 0, 0, 0.77778],\n    \"9650\": [0, 0.54986, 0, 0, 0.72222],\n    \"9651\": [0, 0.54986, 0, 0, 0.72222],\n    \"9654\": [0.03517, 0.54986, 0, 0, 0.77778],\n    \"9660\": [0, 0.54986, 0, 0, 0.72222],\n    \"9661\": [0, 0.54986, 0, 0, 0.72222],\n    \"9664\": [0.03517, 0.54986, 0, 0, 0.77778],\n    \"9674\": [0.11111, 0.69224, 0, 0, 0.66667],\n    \"9733\": [0.19444, 0.69224, 0, 0, 0.94445],\n    \"10003\": [0, 0.69224, 0, 0, 0.83334],\n    \"10016\": [0, 0.69224, 0, 0, 0.83334],\n    \"10731\": [0.11111, 0.69224, 0, 0, 0.66667],\n    \"10846\": [0.19444, 0.75583, 0, 0, 0.61111],\n    \"10877\": [0.13667, 0.63667, 0, 0, 0.77778],\n    \"10878\": [0.13667, 0.63667, 0, 0, 0.77778],\n    \"10885\": [0.25583, 0.75583, 0, 0, 0.77778],\n    \"10886\": [0.25583, 0.75583, 0, 0, 0.77778],\n    \"10887\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"10888\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"10889\": [0.26167, 0.75726, 0, 0, 0.77778],\n    \"10890\": [0.26167, 0.75726, 0, 0, 0.77778],\n    \"10891\": [0.48256, 0.98256, 0, 0, 0.77778],\n    \"10892\": [0.48256, 0.98256, 0, 0, 0.77778],\n    \"10901\": [0.13667, 0.63667, 0, 0, 0.77778],\n    \"10902\": [0.13667, 0.63667, 0, 0, 0.77778],\n    \"10933\": [0.25142, 0.75726, 0, 0, 0.77778],\n    \"10934\": [0.25142, 0.75726, 0, 0, 0.77778],\n    \"10935\": [0.26167, 0.75726, 0, 0, 0.77778],\n    \"10936\": [0.26167, 0.75726, 0, 0, 0.77778],\n    \"10937\": [0.26167, 0.75726, 0, 0, 0.77778],\n    \"10938\": [0.26167, 0.75726, 0, 0, 0.77778],\n    \"10949\": [0.25583, 0.75583, 0, 0, 0.77778],\n    \"10950\": [0.25583, 0.75583, 0, 0, 0.77778],\n    \"10955\": [0.28481, 0.79383, 0, 0, 0.77778],\n    \"10956\": [0.28481, 0.79383, 0, 0, 0.77778],\n    \"57350\": [0.08167, 0.58167, 0, 0, 0.22222],\n    \"57351\": [0.08167, 0.58167, 0, 0, 0.38889],\n    \"57352\": [0.08167, 0.58167, 0, 0, 0.77778],\n    \"57353\": [0, 0.43056, 0.04028, 0, 0.66667],\n    \"57356\": [0.25142, 0.75726, 0, 0, 0.77778],\n    \"57357\": [0.25142, 0.75726, 0, 0, 0.77778],\n    \"57358\": [0.41951, 0.91951, 0, 0, 0.77778],\n    \"57359\": [0.30274, 0.79383, 0, 0, 0.77778],\n    \"57360\": [0.30274, 0.79383, 0, 0, 0.77778],\n    \"57361\": [0.41951, 0.91951, 0, 0, 0.77778],\n    \"57366\": [0.25142, 0.75726, 0, 0, 0.77778],\n    \"57367\": [0.25142, 0.75726, 0, 0, 0.77778],\n    \"57368\": [0.25142, 0.75726, 0, 0, 0.77778],\n    \"57369\": [0.25142, 0.75726, 0, 0, 0.77778],\n    \"57370\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"57371\": [0.13597, 0.63597, 0, 0, 0.77778]\n  },\n  \"Caligraphic-Regular\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"65\": [0, 0.68333, 0, 0.19445, 0.79847],\n    \"66\": [0, 0.68333, 0.03041, 0.13889, 0.65681],\n    \"67\": [0, 0.68333, 0.05834, 0.13889, 0.52653],\n    \"68\": [0, 0.68333, 0.02778, 0.08334, 0.77139],\n    \"69\": [0, 0.68333, 0.08944, 0.11111, 0.52778],\n    \"70\": [0, 0.68333, 0.09931, 0.11111, 0.71875],\n    \"71\": [0.09722, 0.68333, 0.0593, 0.11111, 0.59487],\n    \"72\": [0, 0.68333, 0.00965, 0.11111, 0.84452],\n    \"73\": [0, 0.68333, 0.07382, 0, 0.54452],\n    \"74\": [0.09722, 0.68333, 0.18472, 0.16667, 0.67778],\n    \"75\": [0, 0.68333, 0.01445, 0.05556, 0.76195],\n    \"76\": [0, 0.68333, 0, 0.13889, 0.68972],\n    \"77\": [0, 0.68333, 0, 0.13889, 1.2009],\n    \"78\": [0, 0.68333, 0.14736, 0.08334, 0.82049],\n    \"79\": [0, 0.68333, 0.02778, 0.11111, 0.79611],\n    \"80\": [0, 0.68333, 0.08222, 0.08334, 0.69556],\n    \"81\": [0.09722, 0.68333, 0, 0.11111, 0.81667],\n    \"82\": [0, 0.68333, 0, 0.08334, 0.8475],\n    \"83\": [0, 0.68333, 0.075, 0.13889, 0.60556],\n    \"84\": [0, 0.68333, 0.25417, 0, 0.54464],\n    \"85\": [0, 0.68333, 0.09931, 0.08334, 0.62583],\n    \"86\": [0, 0.68333, 0.08222, 0, 0.61278],\n    \"87\": [0, 0.68333, 0.08222, 0.08334, 0.98778],\n    \"88\": [0, 0.68333, 0.14643, 0.13889, 0.7133],\n    \"89\": [0.09722, 0.68333, 0.08222, 0.08334, 0.66834],\n    \"90\": [0, 0.68333, 0.07944, 0.13889, 0.72473],\n    \"160\": [0, 0, 0, 0, 0.25]\n  },\n  \"Fraktur-Regular\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"33\": [0, 0.69141, 0, 0, 0.29574],\n    \"34\": [0, 0.69141, 0, 0, 0.21471],\n    \"38\": [0, 0.69141, 0, 0, 0.73786],\n    \"39\": [0, 0.69141, 0, 0, 0.21201],\n    \"40\": [0.24982, 0.74947, 0, 0, 0.38865],\n    \"41\": [0.24982, 0.74947, 0, 0, 0.38865],\n    \"42\": [0, 0.62119, 0, 0, 0.27764],\n    \"43\": [0.08319, 0.58283, 0, 0, 0.75623],\n    \"44\": [0, 0.10803, 0, 0, 0.27764],\n    \"45\": [0.08319, 0.58283, 0, 0, 0.75623],\n    \"46\": [0, 0.10803, 0, 0, 0.27764],\n    \"47\": [0.24982, 0.74947, 0, 0, 0.50181],\n    \"48\": [0, 0.47534, 0, 0, 0.50181],\n    \"49\": [0, 0.47534, 0, 0, 0.50181],\n    \"50\": [0, 0.47534, 0, 0, 0.50181],\n    \"51\": [0.18906, 0.47534, 0, 0, 0.50181],\n    \"52\": [0.18906, 0.47534, 0, 0, 0.50181],\n    \"53\": [0.18906, 0.47534, 0, 0, 0.50181],\n    \"54\": [0, 0.69141, 0, 0, 0.50181],\n    \"55\": [0.18906, 0.47534, 0, 0, 0.50181],\n    \"56\": [0, 0.69141, 0, 0, 0.50181],\n    \"57\": [0.18906, 0.47534, 0, 0, 0.50181],\n    \"58\": [0, 0.47534, 0, 0, 0.21606],\n    \"59\": [0.12604, 0.47534, 0, 0, 0.21606],\n    \"61\": [-0.13099, 0.36866, 0, 0, 0.75623],\n    \"63\": [0, 0.69141, 0, 0, 0.36245],\n    \"65\": [0, 0.69141, 0, 0, 0.7176],\n    \"66\": [0, 0.69141, 0, 0, 0.88397],\n    \"67\": [0, 0.69141, 0, 0, 0.61254],\n    \"68\": [0, 0.69141, 0, 0, 0.83158],\n    \"69\": [0, 0.69141, 0, 0, 0.66278],\n    \"70\": [0.12604, 0.69141, 0, 0, 0.61119],\n    \"71\": [0, 0.69141, 0, 0, 0.78539],\n    \"72\": [0.06302, 0.69141, 0, 0, 0.7203],\n    \"73\": [0, 0.69141, 0, 0, 0.55448],\n    \"74\": [0.12604, 0.69141, 0, 0, 0.55231],\n    \"75\": [0, 0.69141, 0, 0, 0.66845],\n    \"76\": [0, 0.69141, 0, 0, 0.66602],\n    \"77\": [0, 0.69141, 0, 0, 1.04953],\n    \"78\": [0, 0.69141, 0, 0, 0.83212],\n    \"79\": [0, 0.69141, 0, 0, 0.82699],\n    \"80\": [0.18906, 0.69141, 0, 0, 0.82753],\n    \"81\": [0.03781, 0.69141, 0, 0, 0.82699],\n    \"82\": [0, 0.69141, 0, 0, 0.82807],\n    \"83\": [0, 0.69141, 0, 0, 0.82861],\n    \"84\": [0, 0.69141, 0, 0, 0.66899],\n    \"85\": [0, 0.69141, 0, 0, 0.64576],\n    \"86\": [0, 0.69141, 0, 0, 0.83131],\n    \"87\": [0, 0.69141, 0, 0, 1.04602],\n    \"88\": [0, 0.69141, 0, 0, 0.71922],\n    \"89\": [0.18906, 0.69141, 0, 0, 0.83293],\n    \"90\": [0.12604, 0.69141, 0, 0, 0.60201],\n    \"91\": [0.24982, 0.74947, 0, 0, 0.27764],\n    \"93\": [0.24982, 0.74947, 0, 0, 0.27764],\n    \"94\": [0, 0.69141, 0, 0, 0.49965],\n    \"97\": [0, 0.47534, 0, 0, 0.50046],\n    \"98\": [0, 0.69141, 0, 0, 0.51315],\n    \"99\": [0, 0.47534, 0, 0, 0.38946],\n    \"100\": [0, 0.62119, 0, 0, 0.49857],\n    \"101\": [0, 0.47534, 0, 0, 0.40053],\n    \"102\": [0.18906, 0.69141, 0, 0, 0.32626],\n    \"103\": [0.18906, 0.47534, 0, 0, 0.5037],\n    \"104\": [0.18906, 0.69141, 0, 0, 0.52126],\n    \"105\": [0, 0.69141, 0, 0, 0.27899],\n    \"106\": [0, 0.69141, 0, 0, 0.28088],\n    \"107\": [0, 0.69141, 0, 0, 0.38946],\n    \"108\": [0, 0.69141, 0, 0, 0.27953],\n    \"109\": [0, 0.47534, 0, 0, 0.76676],\n    \"110\": [0, 0.47534, 0, 0, 0.52666],\n    \"111\": [0, 0.47534, 0, 0, 0.48885],\n    \"112\": [0.18906, 0.52396, 0, 0, 0.50046],\n    \"113\": [0.18906, 0.47534, 0, 0, 0.48912],\n    \"114\": [0, 0.47534, 0, 0, 0.38919],\n    \"115\": [0, 0.47534, 0, 0, 0.44266],\n    \"116\": [0, 0.62119, 0, 0, 0.33301],\n    \"117\": [0, 0.47534, 0, 0, 0.5172],\n    \"118\": [0, 0.52396, 0, 0, 0.5118],\n    \"119\": [0, 0.52396, 0, 0, 0.77351],\n    \"120\": [0.18906, 0.47534, 0, 0, 0.38865],\n    \"121\": [0.18906, 0.47534, 0, 0, 0.49884],\n    \"122\": [0.18906, 0.47534, 0, 0, 0.39054],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"8216\": [0, 0.69141, 0, 0, 0.21471],\n    \"8217\": [0, 0.69141, 0, 0, 0.21471],\n    \"58112\": [0, 0.62119, 0, 0, 0.49749],\n    \"58113\": [0, 0.62119, 0, 0, 0.4983],\n    \"58114\": [0.18906, 0.69141, 0, 0, 0.33328],\n    \"58115\": [0.18906, 0.69141, 0, 0, 0.32923],\n    \"58116\": [0.18906, 0.47534, 0, 0, 0.50343],\n    \"58117\": [0, 0.69141, 0, 0, 0.33301],\n    \"58118\": [0, 0.62119, 0, 0, 0.33409],\n    \"58119\": [0, 0.47534, 0, 0, 0.50073]\n  },\n  \"Main-Bold\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"33\": [0, 0.69444, 0, 0, 0.35],\n    \"34\": [0, 0.69444, 0, 0, 0.60278],\n    \"35\": [0.19444, 0.69444, 0, 0, 0.95833],\n    \"36\": [0.05556, 0.75, 0, 0, 0.575],\n    \"37\": [0.05556, 0.75, 0, 0, 0.95833],\n    \"38\": [0, 0.69444, 0, 0, 0.89444],\n    \"39\": [0, 0.69444, 0, 0, 0.31944],\n    \"40\": [0.25, 0.75, 0, 0, 0.44722],\n    \"41\": [0.25, 0.75, 0, 0, 0.44722],\n    \"42\": [0, 0.75, 0, 0, 0.575],\n    \"43\": [0.13333, 0.63333, 0, 0, 0.89444],\n    \"44\": [0.19444, 0.15556, 0, 0, 0.31944],\n    \"45\": [0, 0.44444, 0, 0, 0.38333],\n    \"46\": [0, 0.15556, 0, 0, 0.31944],\n    \"47\": [0.25, 0.75, 0, 0, 0.575],\n    \"48\": [0, 0.64444, 0, 0, 0.575],\n    \"49\": [0, 0.64444, 0, 0, 0.575],\n    \"50\": [0, 0.64444, 0, 0, 0.575],\n    \"51\": [0, 0.64444, 0, 0, 0.575],\n    \"52\": [0, 0.64444, 0, 0, 0.575],\n    \"53\": [0, 0.64444, 0, 0, 0.575],\n    \"54\": [0, 0.64444, 0, 0, 0.575],\n    \"55\": [0, 0.64444, 0, 0, 0.575],\n    \"56\": [0, 0.64444, 0, 0, 0.575],\n    \"57\": [0, 0.64444, 0, 0, 0.575],\n    \"58\": [0, 0.44444, 0, 0, 0.31944],\n    \"59\": [0.19444, 0.44444, 0, 0, 0.31944],\n    \"60\": [0.08556, 0.58556, 0, 0, 0.89444],\n    \"61\": [-0.10889, 0.39111, 0, 0, 0.89444],\n    \"62\": [0.08556, 0.58556, 0, 0, 0.89444],\n    \"63\": [0, 0.69444, 0, 0, 0.54305],\n    \"64\": [0, 0.69444, 0, 0, 0.89444],\n    \"65\": [0, 0.68611, 0, 0, 0.86944],\n    \"66\": [0, 0.68611, 0, 0, 0.81805],\n    \"67\": [0, 0.68611, 0, 0, 0.83055],\n    \"68\": [0, 0.68611, 0, 0, 0.88194],\n    \"69\": [0, 0.68611, 0, 0, 0.75555],\n    \"70\": [0, 0.68611, 0, 0, 0.72361],\n    \"71\": [0, 0.68611, 0, 0, 0.90416],\n    \"72\": [0, 0.68611, 0, 0, 0.9],\n    \"73\": [0, 0.68611, 0, 0, 0.43611],\n    \"74\": [0, 0.68611, 0, 0, 0.59444],\n    \"75\": [0, 0.68611, 0, 0, 0.90138],\n    \"76\": [0, 0.68611, 0, 0, 0.69166],\n    \"77\": [0, 0.68611, 0, 0, 1.09166],\n    \"78\": [0, 0.68611, 0, 0, 0.9],\n    \"79\": [0, 0.68611, 0, 0, 0.86388],\n    \"80\": [0, 0.68611, 0, 0, 0.78611],\n    \"81\": [0.19444, 0.68611, 0, 0, 0.86388],\n    \"82\": [0, 0.68611, 0, 0, 0.8625],\n    \"83\": [0, 0.68611, 0, 0, 0.63889],\n    \"84\": [0, 0.68611, 0, 0, 0.8],\n    \"85\": [0, 0.68611, 0, 0, 0.88472],\n    \"86\": [0, 0.68611, 0.01597, 0, 0.86944],\n    \"87\": [0, 0.68611, 0.01597, 0, 1.18888],\n    \"88\": [0, 0.68611, 0, 0, 0.86944],\n    \"89\": [0, 0.68611, 0.02875, 0, 0.86944],\n    \"90\": [0, 0.68611, 0, 0, 0.70277],\n    \"91\": [0.25, 0.75, 0, 0, 0.31944],\n    \"92\": [0.25, 0.75, 0, 0, 0.575],\n    \"93\": [0.25, 0.75, 0, 0, 0.31944],\n    \"94\": [0, 0.69444, 0, 0, 0.575],\n    \"95\": [0.31, 0.13444, 0.03194, 0, 0.575],\n    \"97\": [0, 0.44444, 0, 0, 0.55902],\n    \"98\": [0, 0.69444, 0, 0, 0.63889],\n    \"99\": [0, 0.44444, 0, 0, 0.51111],\n    \"100\": [0, 0.69444, 0, 0, 0.63889],\n    \"101\": [0, 0.44444, 0, 0, 0.52708],\n    \"102\": [0, 0.69444, 0.10903, 0, 0.35139],\n    \"103\": [0.19444, 0.44444, 0.01597, 0, 0.575],\n    \"104\": [0, 0.69444, 0, 0, 0.63889],\n    \"105\": [0, 0.69444, 0, 0, 0.31944],\n    \"106\": [0.19444, 0.69444, 0, 0, 0.35139],\n    \"107\": [0, 0.69444, 0, 0, 0.60694],\n    \"108\": [0, 0.69444, 0, 0, 0.31944],\n    \"109\": [0, 0.44444, 0, 0, 0.95833],\n    \"110\": [0, 0.44444, 0, 0, 0.63889],\n    \"111\": [0, 0.44444, 0, 0, 0.575],\n    \"112\": [0.19444, 0.44444, 0, 0, 0.63889],\n    \"113\": [0.19444, 0.44444, 0, 0, 0.60694],\n    \"114\": [0, 0.44444, 0, 0, 0.47361],\n    \"115\": [0, 0.44444, 0, 0, 0.45361],\n    \"116\": [0, 0.63492, 0, 0, 0.44722],\n    \"117\": [0, 0.44444, 0, 0, 0.63889],\n    \"118\": [0, 0.44444, 0.01597, 0, 0.60694],\n    \"119\": [0, 0.44444, 0.01597, 0, 0.83055],\n    \"120\": [0, 0.44444, 0, 0, 0.60694],\n    \"121\": [0.19444, 0.44444, 0.01597, 0, 0.60694],\n    \"122\": [0, 0.44444, 0, 0, 0.51111],\n    \"123\": [0.25, 0.75, 0, 0, 0.575],\n    \"124\": [0.25, 0.75, 0, 0, 0.31944],\n    \"125\": [0.25, 0.75, 0, 0, 0.575],\n    \"126\": [0.35, 0.34444, 0, 0, 0.575],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"163\": [0, 0.69444, 0, 0, 0.86853],\n    \"168\": [0, 0.69444, 0, 0, 0.575],\n    \"172\": [0, 0.44444, 0, 0, 0.76666],\n    \"176\": [0, 0.69444, 0, 0, 0.86944],\n    \"177\": [0.13333, 0.63333, 0, 0, 0.89444],\n    \"184\": [0.17014, 0, 0, 0, 0.51111],\n    \"198\": [0, 0.68611, 0, 0, 1.04166],\n    \"215\": [0.13333, 0.63333, 0, 0, 0.89444],\n    \"216\": [0.04861, 0.73472, 0, 0, 0.89444],\n    \"223\": [0, 0.69444, 0, 0, 0.59722],\n    \"230\": [0, 0.44444, 0, 0, 0.83055],\n    \"247\": [0.13333, 0.63333, 0, 0, 0.89444],\n    \"248\": [0.09722, 0.54167, 0, 0, 0.575],\n    \"305\": [0, 0.44444, 0, 0, 0.31944],\n    \"338\": [0, 0.68611, 0, 0, 1.16944],\n    \"339\": [0, 0.44444, 0, 0, 0.89444],\n    \"567\": [0.19444, 0.44444, 0, 0, 0.35139],\n    \"710\": [0, 0.69444, 0, 0, 0.575],\n    \"711\": [0, 0.63194, 0, 0, 0.575],\n    \"713\": [0, 0.59611, 0, 0, 0.575],\n    \"714\": [0, 0.69444, 0, 0, 0.575],\n    \"715\": [0, 0.69444, 0, 0, 0.575],\n    \"728\": [0, 0.69444, 0, 0, 0.575],\n    \"729\": [0, 0.69444, 0, 0, 0.31944],\n    \"730\": [0, 0.69444, 0, 0, 0.86944],\n    \"732\": [0, 0.69444, 0, 0, 0.575],\n    \"733\": [0, 0.69444, 0, 0, 0.575],\n    \"915\": [0, 0.68611, 0, 0, 0.69166],\n    \"916\": [0, 0.68611, 0, 0, 0.95833],\n    \"920\": [0, 0.68611, 0, 0, 0.89444],\n    \"923\": [0, 0.68611, 0, 0, 0.80555],\n    \"926\": [0, 0.68611, 0, 0, 0.76666],\n    \"928\": [0, 0.68611, 0, 0, 0.9],\n    \"931\": [0, 0.68611, 0, 0, 0.83055],\n    \"933\": [0, 0.68611, 0, 0, 0.89444],\n    \"934\": [0, 0.68611, 0, 0, 0.83055],\n    \"936\": [0, 0.68611, 0, 0, 0.89444],\n    \"937\": [0, 0.68611, 0, 0, 0.83055],\n    \"8211\": [0, 0.44444, 0.03194, 0, 0.575],\n    \"8212\": [0, 0.44444, 0.03194, 0, 1.14999],\n    \"8216\": [0, 0.69444, 0, 0, 0.31944],\n    \"8217\": [0, 0.69444, 0, 0, 0.31944],\n    \"8220\": [0, 0.69444, 0, 0, 0.60278],\n    \"8221\": [0, 0.69444, 0, 0, 0.60278],\n    \"8224\": [0.19444, 0.69444, 0, 0, 0.51111],\n    \"8225\": [0.19444, 0.69444, 0, 0, 0.51111],\n    \"8242\": [0, 0.55556, 0, 0, 0.34444],\n    \"8407\": [0, 0.72444, 0.15486, 0, 0.575],\n    \"8463\": [0, 0.69444, 0, 0, 0.66759],\n    \"8465\": [0, 0.69444, 0, 0, 0.83055],\n    \"8467\": [0, 0.69444, 0, 0, 0.47361],\n    \"8472\": [0.19444, 0.44444, 0, 0, 0.74027],\n    \"8476\": [0, 0.69444, 0, 0, 0.83055],\n    \"8501\": [0, 0.69444, 0, 0, 0.70277],\n    \"8592\": [-0.10889, 0.39111, 0, 0, 1.14999],\n    \"8593\": [0.19444, 0.69444, 0, 0, 0.575],\n    \"8594\": [-0.10889, 0.39111, 0, 0, 1.14999],\n    \"8595\": [0.19444, 0.69444, 0, 0, 0.575],\n    \"8596\": [-0.10889, 0.39111, 0, 0, 1.14999],\n    \"8597\": [0.25, 0.75, 0, 0, 0.575],\n    \"8598\": [0.19444, 0.69444, 0, 0, 1.14999],\n    \"8599\": [0.19444, 0.69444, 0, 0, 1.14999],\n    \"8600\": [0.19444, 0.69444, 0, 0, 1.14999],\n    \"8601\": [0.19444, 0.69444, 0, 0, 1.14999],\n    \"8636\": [-0.10889, 0.39111, 0, 0, 1.14999],\n    \"8637\": [-0.10889, 0.39111, 0, 0, 1.14999],\n    \"8640\": [-0.10889, 0.39111, 0, 0, 1.14999],\n    \"8641\": [-0.10889, 0.39111, 0, 0, 1.14999],\n    \"8656\": [-0.10889, 0.39111, 0, 0, 1.14999],\n    \"8657\": [0.19444, 0.69444, 0, 0, 0.70277],\n    \"8658\": [-0.10889, 0.39111, 0, 0, 1.14999],\n    \"8659\": [0.19444, 0.69444, 0, 0, 0.70277],\n    \"8660\": [-0.10889, 0.39111, 0, 0, 1.14999],\n    \"8661\": [0.25, 0.75, 0, 0, 0.70277],\n    \"8704\": [0, 0.69444, 0, 0, 0.63889],\n    \"8706\": [0, 0.69444, 0.06389, 0, 0.62847],\n    \"8707\": [0, 0.69444, 0, 0, 0.63889],\n    \"8709\": [0.05556, 0.75, 0, 0, 0.575],\n    \"8711\": [0, 0.68611, 0, 0, 0.95833],\n    \"8712\": [0.08556, 0.58556, 0, 0, 0.76666],\n    \"8715\": [0.08556, 0.58556, 0, 0, 0.76666],\n    \"8722\": [0.13333, 0.63333, 0, 0, 0.89444],\n    \"8723\": [0.13333, 0.63333, 0, 0, 0.89444],\n    \"8725\": [0.25, 0.75, 0, 0, 0.575],\n    \"8726\": [0.25, 0.75, 0, 0, 0.575],\n    \"8727\": [-0.02778, 0.47222, 0, 0, 0.575],\n    \"8728\": [-0.02639, 0.47361, 0, 0, 0.575],\n    \"8729\": [-0.02639, 0.47361, 0, 0, 0.575],\n    \"8730\": [0.18, 0.82, 0, 0, 0.95833],\n    \"8733\": [0, 0.44444, 0, 0, 0.89444],\n    \"8734\": [0, 0.44444, 0, 0, 1.14999],\n    \"8736\": [0, 0.69224, 0, 0, 0.72222],\n    \"8739\": [0.25, 0.75, 0, 0, 0.31944],\n    \"8741\": [0.25, 0.75, 0, 0, 0.575],\n    \"8743\": [0, 0.55556, 0, 0, 0.76666],\n    \"8744\": [0, 0.55556, 0, 0, 0.76666],\n    \"8745\": [0, 0.55556, 0, 0, 0.76666],\n    \"8746\": [0, 0.55556, 0, 0, 0.76666],\n    \"8747\": [0.19444, 0.69444, 0.12778, 0, 0.56875],\n    \"8764\": [-0.10889, 0.39111, 0, 0, 0.89444],\n    \"8768\": [0.19444, 0.69444, 0, 0, 0.31944],\n    \"8771\": [0.00222, 0.50222, 0, 0, 0.89444],\n    \"8773\": [0.027, 0.638, 0, 0, 0.894],\n    \"8776\": [0.02444, 0.52444, 0, 0, 0.89444],\n    \"8781\": [0.00222, 0.50222, 0, 0, 0.89444],\n    \"8801\": [0.00222, 0.50222, 0, 0, 0.89444],\n    \"8804\": [0.19667, 0.69667, 0, 0, 0.89444],\n    \"8805\": [0.19667, 0.69667, 0, 0, 0.89444],\n    \"8810\": [0.08556, 0.58556, 0, 0, 1.14999],\n    \"8811\": [0.08556, 0.58556, 0, 0, 1.14999],\n    \"8826\": [0.08556, 0.58556, 0, 0, 0.89444],\n    \"8827\": [0.08556, 0.58556, 0, 0, 0.89444],\n    \"8834\": [0.08556, 0.58556, 0, 0, 0.89444],\n    \"8835\": [0.08556, 0.58556, 0, 0, 0.89444],\n    \"8838\": [0.19667, 0.69667, 0, 0, 0.89444],\n    \"8839\": [0.19667, 0.69667, 0, 0, 0.89444],\n    \"8846\": [0, 0.55556, 0, 0, 0.76666],\n    \"8849\": [0.19667, 0.69667, 0, 0, 0.89444],\n    \"8850\": [0.19667, 0.69667, 0, 0, 0.89444],\n    \"8851\": [0, 0.55556, 0, 0, 0.76666],\n    \"8852\": [0, 0.55556, 0, 0, 0.76666],\n    \"8853\": [0.13333, 0.63333, 0, 0, 0.89444],\n    \"8854\": [0.13333, 0.63333, 0, 0, 0.89444],\n    \"8855\": [0.13333, 0.63333, 0, 0, 0.89444],\n    \"8856\": [0.13333, 0.63333, 0, 0, 0.89444],\n    \"8857\": [0.13333, 0.63333, 0, 0, 0.89444],\n    \"8866\": [0, 0.69444, 0, 0, 0.70277],\n    \"8867\": [0, 0.69444, 0, 0, 0.70277],\n    \"8868\": [0, 0.69444, 0, 0, 0.89444],\n    \"8869\": [0, 0.69444, 0, 0, 0.89444],\n    \"8900\": [-0.02639, 0.47361, 0, 0, 0.575],\n    \"8901\": [-0.02639, 0.47361, 0, 0, 0.31944],\n    \"8902\": [-0.02778, 0.47222, 0, 0, 0.575],\n    \"8968\": [0.25, 0.75, 0, 0, 0.51111],\n    \"8969\": [0.25, 0.75, 0, 0, 0.51111],\n    \"8970\": [0.25, 0.75, 0, 0, 0.51111],\n    \"8971\": [0.25, 0.75, 0, 0, 0.51111],\n    \"8994\": [-0.13889, 0.36111, 0, 0, 1.14999],\n    \"8995\": [-0.13889, 0.36111, 0, 0, 1.14999],\n    \"9651\": [0.19444, 0.69444, 0, 0, 1.02222],\n    \"9657\": [-0.02778, 0.47222, 0, 0, 0.575],\n    \"9661\": [0.19444, 0.69444, 0, 0, 1.02222],\n    \"9667\": [-0.02778, 0.47222, 0, 0, 0.575],\n    \"9711\": [0.19444, 0.69444, 0, 0, 1.14999],\n    \"9824\": [0.12963, 0.69444, 0, 0, 0.89444],\n    \"9825\": [0.12963, 0.69444, 0, 0, 0.89444],\n    \"9826\": [0.12963, 0.69444, 0, 0, 0.89444],\n    \"9827\": [0.12963, 0.69444, 0, 0, 0.89444],\n    \"9837\": [0, 0.75, 0, 0, 0.44722],\n    \"9838\": [0.19444, 0.69444, 0, 0, 0.44722],\n    \"9839\": [0.19444, 0.69444, 0, 0, 0.44722],\n    \"10216\": [0.25, 0.75, 0, 0, 0.44722],\n    \"10217\": [0.25, 0.75, 0, 0, 0.44722],\n    \"10815\": [0, 0.68611, 0, 0, 0.9],\n    \"10927\": [0.19667, 0.69667, 0, 0, 0.89444],\n    \"10928\": [0.19667, 0.69667, 0, 0, 0.89444],\n    \"57376\": [0.19444, 0.69444, 0, 0, 0]\n  },\n  \"Main-BoldItalic\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"33\": [0, 0.69444, 0.11417, 0, 0.38611],\n    \"34\": [0, 0.69444, 0.07939, 0, 0.62055],\n    \"35\": [0.19444, 0.69444, 0.06833, 0, 0.94444],\n    \"37\": [0.05556, 0.75, 0.12861, 0, 0.94444],\n    \"38\": [0, 0.69444, 0.08528, 0, 0.88555],\n    \"39\": [0, 0.69444, 0.12945, 0, 0.35555],\n    \"40\": [0.25, 0.75, 0.15806, 0, 0.47333],\n    \"41\": [0.25, 0.75, 0.03306, 0, 0.47333],\n    \"42\": [0, 0.75, 0.14333, 0, 0.59111],\n    \"43\": [0.10333, 0.60333, 0.03306, 0, 0.88555],\n    \"44\": [0.19444, 0.14722, 0, 0, 0.35555],\n    \"45\": [0, 0.44444, 0.02611, 0, 0.41444],\n    \"46\": [0, 0.14722, 0, 0, 0.35555],\n    \"47\": [0.25, 0.75, 0.15806, 0, 0.59111],\n    \"48\": [0, 0.64444, 0.13167, 0, 0.59111],\n    \"49\": [0, 0.64444, 0.13167, 0, 0.59111],\n    \"50\": [0, 0.64444, 0.13167, 0, 0.59111],\n    \"51\": [0, 0.64444, 0.13167, 0, 0.59111],\n    \"52\": [0.19444, 0.64444, 0.13167, 0, 0.59111],\n    \"53\": [0, 0.64444, 0.13167, 0, 0.59111],\n    \"54\": [0, 0.64444, 0.13167, 0, 0.59111],\n    \"55\": [0.19444, 0.64444, 0.13167, 0, 0.59111],\n    \"56\": [0, 0.64444, 0.13167, 0, 0.59111],\n    \"57\": [0, 0.64444, 0.13167, 0, 0.59111],\n    \"58\": [0, 0.44444, 0.06695, 0, 0.35555],\n    \"59\": [0.19444, 0.44444, 0.06695, 0, 0.35555],\n    \"61\": [-0.10889, 0.39111, 0.06833, 0, 0.88555],\n    \"63\": [0, 0.69444, 0.11472, 0, 0.59111],\n    \"64\": [0, 0.69444, 0.09208, 0, 0.88555],\n    \"65\": [0, 0.68611, 0, 0, 0.86555],\n    \"66\": [0, 0.68611, 0.0992, 0, 0.81666],\n    \"67\": [0, 0.68611, 0.14208, 0, 0.82666],\n    \"68\": [0, 0.68611, 0.09062, 0, 0.87555],\n    \"69\": [0, 0.68611, 0.11431, 0, 0.75666],\n    \"70\": [0, 0.68611, 0.12903, 0, 0.72722],\n    \"71\": [0, 0.68611, 0.07347, 0, 0.89527],\n    \"72\": [0, 0.68611, 0.17208, 0, 0.8961],\n    \"73\": [0, 0.68611, 0.15681, 0, 0.47166],\n    \"74\": [0, 0.68611, 0.145, 0, 0.61055],\n    \"75\": [0, 0.68611, 0.14208, 0, 0.89499],\n    \"76\": [0, 0.68611, 0, 0, 0.69777],\n    \"77\": [0, 0.68611, 0.17208, 0, 1.07277],\n    \"78\": [0, 0.68611, 0.17208, 0, 0.8961],\n    \"79\": [0, 0.68611, 0.09062, 0, 0.85499],\n    \"80\": [0, 0.68611, 0.0992, 0, 0.78721],\n    \"81\": [0.19444, 0.68611, 0.09062, 0, 0.85499],\n    \"82\": [0, 0.68611, 0.02559, 0, 0.85944],\n    \"83\": [0, 0.68611, 0.11264, 0, 0.64999],\n    \"84\": [0, 0.68611, 0.12903, 0, 0.7961],\n    \"85\": [0, 0.68611, 0.17208, 0, 0.88083],\n    \"86\": [0, 0.68611, 0.18625, 0, 0.86555],\n    \"87\": [0, 0.68611, 0.18625, 0, 1.15999],\n    \"88\": [0, 0.68611, 0.15681, 0, 0.86555],\n    \"89\": [0, 0.68611, 0.19803, 0, 0.86555],\n    \"90\": [0, 0.68611, 0.14208, 0, 0.70888],\n    \"91\": [0.25, 0.75, 0.1875, 0, 0.35611],\n    \"93\": [0.25, 0.75, 0.09972, 0, 0.35611],\n    \"94\": [0, 0.69444, 0.06709, 0, 0.59111],\n    \"95\": [0.31, 0.13444, 0.09811, 0, 0.59111],\n    \"97\": [0, 0.44444, 0.09426, 0, 0.59111],\n    \"98\": [0, 0.69444, 0.07861, 0, 0.53222],\n    \"99\": [0, 0.44444, 0.05222, 0, 0.53222],\n    \"100\": [0, 0.69444, 0.10861, 0, 0.59111],\n    \"101\": [0, 0.44444, 0.085, 0, 0.53222],\n    \"102\": [0.19444, 0.69444, 0.21778, 0, 0.4],\n    \"103\": [0.19444, 0.44444, 0.105, 0, 0.53222],\n    \"104\": [0, 0.69444, 0.09426, 0, 0.59111],\n    \"105\": [0, 0.69326, 0.11387, 0, 0.35555],\n    \"106\": [0.19444, 0.69326, 0.1672, 0, 0.35555],\n    \"107\": [0, 0.69444, 0.11111, 0, 0.53222],\n    \"108\": [0, 0.69444, 0.10861, 0, 0.29666],\n    \"109\": [0, 0.44444, 0.09426, 0, 0.94444],\n    \"110\": [0, 0.44444, 0.09426, 0, 0.64999],\n    \"111\": [0, 0.44444, 0.07861, 0, 0.59111],\n    \"112\": [0.19444, 0.44444, 0.07861, 0, 0.59111],\n    \"113\": [0.19444, 0.44444, 0.105, 0, 0.53222],\n    \"114\": [0, 0.44444, 0.11111, 0, 0.50167],\n    \"115\": [0, 0.44444, 0.08167, 0, 0.48694],\n    \"116\": [0, 0.63492, 0.09639, 0, 0.385],\n    \"117\": [0, 0.44444, 0.09426, 0, 0.62055],\n    \"118\": [0, 0.44444, 0.11111, 0, 0.53222],\n    \"119\": [0, 0.44444, 0.11111, 0, 0.76777],\n    \"120\": [0, 0.44444, 0.12583, 0, 0.56055],\n    \"121\": [0.19444, 0.44444, 0.105, 0, 0.56166],\n    \"122\": [0, 0.44444, 0.13889, 0, 0.49055],\n    \"126\": [0.35, 0.34444, 0.11472, 0, 0.59111],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"168\": [0, 0.69444, 0.11473, 0, 0.59111],\n    \"176\": [0, 0.69444, 0, 0, 0.94888],\n    \"184\": [0.17014, 0, 0, 0, 0.53222],\n    \"198\": [0, 0.68611, 0.11431, 0, 1.02277],\n    \"216\": [0.04861, 0.73472, 0.09062, 0, 0.88555],\n    \"223\": [0.19444, 0.69444, 0.09736, 0, 0.665],\n    \"230\": [0, 0.44444, 0.085, 0, 0.82666],\n    \"248\": [0.09722, 0.54167, 0.09458, 0, 0.59111],\n    \"305\": [0, 0.44444, 0.09426, 0, 0.35555],\n    \"338\": [0, 0.68611, 0.11431, 0, 1.14054],\n    \"339\": [0, 0.44444, 0.085, 0, 0.82666],\n    \"567\": [0.19444, 0.44444, 0.04611, 0, 0.385],\n    \"710\": [0, 0.69444, 0.06709, 0, 0.59111],\n    \"711\": [0, 0.63194, 0.08271, 0, 0.59111],\n    \"713\": [0, 0.59444, 0.10444, 0, 0.59111],\n    \"714\": [0, 0.69444, 0.08528, 0, 0.59111],\n    \"715\": [0, 0.69444, 0, 0, 0.59111],\n    \"728\": [0, 0.69444, 0.10333, 0, 0.59111],\n    \"729\": [0, 0.69444, 0.12945, 0, 0.35555],\n    \"730\": [0, 0.69444, 0, 0, 0.94888],\n    \"732\": [0, 0.69444, 0.11472, 0, 0.59111],\n    \"733\": [0, 0.69444, 0.11472, 0, 0.59111],\n    \"915\": [0, 0.68611, 0.12903, 0, 0.69777],\n    \"916\": [0, 0.68611, 0, 0, 0.94444],\n    \"920\": [0, 0.68611, 0.09062, 0, 0.88555],\n    \"923\": [0, 0.68611, 0, 0, 0.80666],\n    \"926\": [0, 0.68611, 0.15092, 0, 0.76777],\n    \"928\": [0, 0.68611, 0.17208, 0, 0.8961],\n    \"931\": [0, 0.68611, 0.11431, 0, 0.82666],\n    \"933\": [0, 0.68611, 0.10778, 0, 0.88555],\n    \"934\": [0, 0.68611, 0.05632, 0, 0.82666],\n    \"936\": [0, 0.68611, 0.10778, 0, 0.88555],\n    \"937\": [0, 0.68611, 0.0992, 0, 0.82666],\n    \"8211\": [0, 0.44444, 0.09811, 0, 0.59111],\n    \"8212\": [0, 0.44444, 0.09811, 0, 1.18221],\n    \"8216\": [0, 0.69444, 0.12945, 0, 0.35555],\n    \"8217\": [0, 0.69444, 0.12945, 0, 0.35555],\n    \"8220\": [0, 0.69444, 0.16772, 0, 0.62055],\n    \"8221\": [0, 0.69444, 0.07939, 0, 0.62055]\n  },\n  \"Main-Italic\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"33\": [0, 0.69444, 0.12417, 0, 0.30667],\n    \"34\": [0, 0.69444, 0.06961, 0, 0.51444],\n    \"35\": [0.19444, 0.69444, 0.06616, 0, 0.81777],\n    \"37\": [0.05556, 0.75, 0.13639, 0, 0.81777],\n    \"38\": [0, 0.69444, 0.09694, 0, 0.76666],\n    \"39\": [0, 0.69444, 0.12417, 0, 0.30667],\n    \"40\": [0.25, 0.75, 0.16194, 0, 0.40889],\n    \"41\": [0.25, 0.75, 0.03694, 0, 0.40889],\n    \"42\": [0, 0.75, 0.14917, 0, 0.51111],\n    \"43\": [0.05667, 0.56167, 0.03694, 0, 0.76666],\n    \"44\": [0.19444, 0.10556, 0, 0, 0.30667],\n    \"45\": [0, 0.43056, 0.02826, 0, 0.35778],\n    \"46\": [0, 0.10556, 0, 0, 0.30667],\n    \"47\": [0.25, 0.75, 0.16194, 0, 0.51111],\n    \"48\": [0, 0.64444, 0.13556, 0, 0.51111],\n    \"49\": [0, 0.64444, 0.13556, 0, 0.51111],\n    \"50\": [0, 0.64444, 0.13556, 0, 0.51111],\n    \"51\": [0, 0.64444, 0.13556, 0, 0.51111],\n    \"52\": [0.19444, 0.64444, 0.13556, 0, 0.51111],\n    \"53\": [0, 0.64444, 0.13556, 0, 0.51111],\n    \"54\": [0, 0.64444, 0.13556, 0, 0.51111],\n    \"55\": [0.19444, 0.64444, 0.13556, 0, 0.51111],\n    \"56\": [0, 0.64444, 0.13556, 0, 0.51111],\n    \"57\": [0, 0.64444, 0.13556, 0, 0.51111],\n    \"58\": [0, 0.43056, 0.0582, 0, 0.30667],\n    \"59\": [0.19444, 0.43056, 0.0582, 0, 0.30667],\n    \"61\": [-0.13313, 0.36687, 0.06616, 0, 0.76666],\n    \"63\": [0, 0.69444, 0.1225, 0, 0.51111],\n    \"64\": [0, 0.69444, 0.09597, 0, 0.76666],\n    \"65\": [0, 0.68333, 0, 0, 0.74333],\n    \"66\": [0, 0.68333, 0.10257, 0, 0.70389],\n    \"67\": [0, 0.68333, 0.14528, 0, 0.71555],\n    \"68\": [0, 0.68333, 0.09403, 0, 0.755],\n    \"69\": [0, 0.68333, 0.12028, 0, 0.67833],\n    \"70\": [0, 0.68333, 0.13305, 0, 0.65277],\n    \"71\": [0, 0.68333, 0.08722, 0, 0.77361],\n    \"72\": [0, 0.68333, 0.16389, 0, 0.74333],\n    \"73\": [0, 0.68333, 0.15806, 0, 0.38555],\n    \"74\": [0, 0.68333, 0.14028, 0, 0.525],\n    \"75\": [0, 0.68333, 0.14528, 0, 0.76888],\n    \"76\": [0, 0.68333, 0, 0, 0.62722],\n    \"77\": [0, 0.68333, 0.16389, 0, 0.89666],\n    \"78\": [0, 0.68333, 0.16389, 0, 0.74333],\n    \"79\": [0, 0.68333, 0.09403, 0, 0.76666],\n    \"80\": [0, 0.68333, 0.10257, 0, 0.67833],\n    \"81\": [0.19444, 0.68333, 0.09403, 0, 0.76666],\n    \"82\": [0, 0.68333, 0.03868, 0, 0.72944],\n    \"83\": [0, 0.68333, 0.11972, 0, 0.56222],\n    \"84\": [0, 0.68333, 0.13305, 0, 0.71555],\n    \"85\": [0, 0.68333, 0.16389, 0, 0.74333],\n    \"86\": [0, 0.68333, 0.18361, 0, 0.74333],\n    \"87\": [0, 0.68333, 0.18361, 0, 0.99888],\n    \"88\": [0, 0.68333, 0.15806, 0, 0.74333],\n    \"89\": [0, 0.68333, 0.19383, 0, 0.74333],\n    \"90\": [0, 0.68333, 0.14528, 0, 0.61333],\n    \"91\": [0.25, 0.75, 0.1875, 0, 0.30667],\n    \"93\": [0.25, 0.75, 0.10528, 0, 0.30667],\n    \"94\": [0, 0.69444, 0.06646, 0, 0.51111],\n    \"95\": [0.31, 0.12056, 0.09208, 0, 0.51111],\n    \"97\": [0, 0.43056, 0.07671, 0, 0.51111],\n    \"98\": [0, 0.69444, 0.06312, 0, 0.46],\n    \"99\": [0, 0.43056, 0.05653, 0, 0.46],\n    \"100\": [0, 0.69444, 0.10333, 0, 0.51111],\n    \"101\": [0, 0.43056, 0.07514, 0, 0.46],\n    \"102\": [0.19444, 0.69444, 0.21194, 0, 0.30667],\n    \"103\": [0.19444, 0.43056, 0.08847, 0, 0.46],\n    \"104\": [0, 0.69444, 0.07671, 0, 0.51111],\n    \"105\": [0, 0.65536, 0.1019, 0, 0.30667],\n    \"106\": [0.19444, 0.65536, 0.14467, 0, 0.30667],\n    \"107\": [0, 0.69444, 0.10764, 0, 0.46],\n    \"108\": [0, 0.69444, 0.10333, 0, 0.25555],\n    \"109\": [0, 0.43056, 0.07671, 0, 0.81777],\n    \"110\": [0, 0.43056, 0.07671, 0, 0.56222],\n    \"111\": [0, 0.43056, 0.06312, 0, 0.51111],\n    \"112\": [0.19444, 0.43056, 0.06312, 0, 0.51111],\n    \"113\": [0.19444, 0.43056, 0.08847, 0, 0.46],\n    \"114\": [0, 0.43056, 0.10764, 0, 0.42166],\n    \"115\": [0, 0.43056, 0.08208, 0, 0.40889],\n    \"116\": [0, 0.61508, 0.09486, 0, 0.33222],\n    \"117\": [0, 0.43056, 0.07671, 0, 0.53666],\n    \"118\": [0, 0.43056, 0.10764, 0, 0.46],\n    \"119\": [0, 0.43056, 0.10764, 0, 0.66444],\n    \"120\": [0, 0.43056, 0.12042, 0, 0.46389],\n    \"121\": [0.19444, 0.43056, 0.08847, 0, 0.48555],\n    \"122\": [0, 0.43056, 0.12292, 0, 0.40889],\n    \"126\": [0.35, 0.31786, 0.11585, 0, 0.51111],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"168\": [0, 0.66786, 0.10474, 0, 0.51111],\n    \"176\": [0, 0.69444, 0, 0, 0.83129],\n    \"184\": [0.17014, 0, 0, 0, 0.46],\n    \"198\": [0, 0.68333, 0.12028, 0, 0.88277],\n    \"216\": [0.04861, 0.73194, 0.09403, 0, 0.76666],\n    \"223\": [0.19444, 0.69444, 0.10514, 0, 0.53666],\n    \"230\": [0, 0.43056, 0.07514, 0, 0.71555],\n    \"248\": [0.09722, 0.52778, 0.09194, 0, 0.51111],\n    \"338\": [0, 0.68333, 0.12028, 0, 0.98499],\n    \"339\": [0, 0.43056, 0.07514, 0, 0.71555],\n    \"710\": [0, 0.69444, 0.06646, 0, 0.51111],\n    \"711\": [0, 0.62847, 0.08295, 0, 0.51111],\n    \"713\": [0, 0.56167, 0.10333, 0, 0.51111],\n    \"714\": [0, 0.69444, 0.09694, 0, 0.51111],\n    \"715\": [0, 0.69444, 0, 0, 0.51111],\n    \"728\": [0, 0.69444, 0.10806, 0, 0.51111],\n    \"729\": [0, 0.66786, 0.11752, 0, 0.30667],\n    \"730\": [0, 0.69444, 0, 0, 0.83129],\n    \"732\": [0, 0.66786, 0.11585, 0, 0.51111],\n    \"733\": [0, 0.69444, 0.1225, 0, 0.51111],\n    \"915\": [0, 0.68333, 0.13305, 0, 0.62722],\n    \"916\": [0, 0.68333, 0, 0, 0.81777],\n    \"920\": [0, 0.68333, 0.09403, 0, 0.76666],\n    \"923\": [0, 0.68333, 0, 0, 0.69222],\n    \"926\": [0, 0.68333, 0.15294, 0, 0.66444],\n    \"928\": [0, 0.68333, 0.16389, 0, 0.74333],\n    \"931\": [0, 0.68333, 0.12028, 0, 0.71555],\n    \"933\": [0, 0.68333, 0.11111, 0, 0.76666],\n    \"934\": [0, 0.68333, 0.05986, 0, 0.71555],\n    \"936\": [0, 0.68333, 0.11111, 0, 0.76666],\n    \"937\": [0, 0.68333, 0.10257, 0, 0.71555],\n    \"8211\": [0, 0.43056, 0.09208, 0, 0.51111],\n    \"8212\": [0, 0.43056, 0.09208, 0, 1.02222],\n    \"8216\": [0, 0.69444, 0.12417, 0, 0.30667],\n    \"8217\": [0, 0.69444, 0.12417, 0, 0.30667],\n    \"8220\": [0, 0.69444, 0.1685, 0, 0.51444],\n    \"8221\": [0, 0.69444, 0.06961, 0, 0.51444],\n    \"8463\": [0, 0.68889, 0, 0, 0.54028]\n  },\n  \"Main-Regular\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"33\": [0, 0.69444, 0, 0, 0.27778],\n    \"34\": [0, 0.69444, 0, 0, 0.5],\n    \"35\": [0.19444, 0.69444, 0, 0, 0.83334],\n    \"36\": [0.05556, 0.75, 0, 0, 0.5],\n    \"37\": [0.05556, 0.75, 0, 0, 0.83334],\n    \"38\": [0, 0.69444, 0, 0, 0.77778],\n    \"39\": [0, 0.69444, 0, 0, 0.27778],\n    \"40\": [0.25, 0.75, 0, 0, 0.38889],\n    \"41\": [0.25, 0.75, 0, 0, 0.38889],\n    \"42\": [0, 0.75, 0, 0, 0.5],\n    \"43\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"44\": [0.19444, 0.10556, 0, 0, 0.27778],\n    \"45\": [0, 0.43056, 0, 0, 0.33333],\n    \"46\": [0, 0.10556, 0, 0, 0.27778],\n    \"47\": [0.25, 0.75, 0, 0, 0.5],\n    \"48\": [0, 0.64444, 0, 0, 0.5],\n    \"49\": [0, 0.64444, 0, 0, 0.5],\n    \"50\": [0, 0.64444, 0, 0, 0.5],\n    \"51\": [0, 0.64444, 0, 0, 0.5],\n    \"52\": [0, 0.64444, 0, 0, 0.5],\n    \"53\": [0, 0.64444, 0, 0, 0.5],\n    \"54\": [0, 0.64444, 0, 0, 0.5],\n    \"55\": [0, 0.64444, 0, 0, 0.5],\n    \"56\": [0, 0.64444, 0, 0, 0.5],\n    \"57\": [0, 0.64444, 0, 0, 0.5],\n    \"58\": [0, 0.43056, 0, 0, 0.27778],\n    \"59\": [0.19444, 0.43056, 0, 0, 0.27778],\n    \"60\": [0.0391, 0.5391, 0, 0, 0.77778],\n    \"61\": [-0.13313, 0.36687, 0, 0, 0.77778],\n    \"62\": [0.0391, 0.5391, 0, 0, 0.77778],\n    \"63\": [0, 0.69444, 0, 0, 0.47222],\n    \"64\": [0, 0.69444, 0, 0, 0.77778],\n    \"65\": [0, 0.68333, 0, 0, 0.75],\n    \"66\": [0, 0.68333, 0, 0, 0.70834],\n    \"67\": [0, 0.68333, 0, 0, 0.72222],\n    \"68\": [0, 0.68333, 0, 0, 0.76389],\n    \"69\": [0, 0.68333, 0, 0, 0.68056],\n    \"70\": [0, 0.68333, 0, 0, 0.65278],\n    \"71\": [0, 0.68333, 0, 0, 0.78472],\n    \"72\": [0, 0.68333, 0, 0, 0.75],\n    \"73\": [0, 0.68333, 0, 0, 0.36111],\n    \"74\": [0, 0.68333, 0, 0, 0.51389],\n    \"75\": [0, 0.68333, 0, 0, 0.77778],\n    \"76\": [0, 0.68333, 0, 0, 0.625],\n    \"77\": [0, 0.68333, 0, 0, 0.91667],\n    \"78\": [0, 0.68333, 0, 0, 0.75],\n    \"79\": [0, 0.68333, 0, 0, 0.77778],\n    \"80\": [0, 0.68333, 0, 0, 0.68056],\n    \"81\": [0.19444, 0.68333, 0, 0, 0.77778],\n    \"82\": [0, 0.68333, 0, 0, 0.73611],\n    \"83\": [0, 0.68333, 0, 0, 0.55556],\n    \"84\": [0, 0.68333, 0, 0, 0.72222],\n    \"85\": [0, 0.68333, 0, 0, 0.75],\n    \"86\": [0, 0.68333, 0.01389, 0, 0.75],\n    \"87\": [0, 0.68333, 0.01389, 0, 1.02778],\n    \"88\": [0, 0.68333, 0, 0, 0.75],\n    \"89\": [0, 0.68333, 0.025, 0, 0.75],\n    \"90\": [0, 0.68333, 0, 0, 0.61111],\n    \"91\": [0.25, 0.75, 0, 0, 0.27778],\n    \"92\": [0.25, 0.75, 0, 0, 0.5],\n    \"93\": [0.25, 0.75, 0, 0, 0.27778],\n    \"94\": [0, 0.69444, 0, 0, 0.5],\n    \"95\": [0.31, 0.12056, 0.02778, 0, 0.5],\n    \"97\": [0, 0.43056, 0, 0, 0.5],\n    \"98\": [0, 0.69444, 0, 0, 0.55556],\n    \"99\": [0, 0.43056, 0, 0, 0.44445],\n    \"100\": [0, 0.69444, 0, 0, 0.55556],\n    \"101\": [0, 0.43056, 0, 0, 0.44445],\n    \"102\": [0, 0.69444, 0.07778, 0, 0.30556],\n    \"103\": [0.19444, 0.43056, 0.01389, 0, 0.5],\n    \"104\": [0, 0.69444, 0, 0, 0.55556],\n    \"105\": [0, 0.66786, 0, 0, 0.27778],\n    \"106\": [0.19444, 0.66786, 0, 0, 0.30556],\n    \"107\": [0, 0.69444, 0, 0, 0.52778],\n    \"108\": [0, 0.69444, 0, 0, 0.27778],\n    \"109\": [0, 0.43056, 0, 0, 0.83334],\n    \"110\": [0, 0.43056, 0, 0, 0.55556],\n    \"111\": [0, 0.43056, 0, 0, 0.5],\n    \"112\": [0.19444, 0.43056, 0, 0, 0.55556],\n    \"113\": [0.19444, 0.43056, 0, 0, 0.52778],\n    \"114\": [0, 0.43056, 0, 0, 0.39167],\n    \"115\": [0, 0.43056, 0, 0, 0.39445],\n    \"116\": [0, 0.61508, 0, 0, 0.38889],\n    \"117\": [0, 0.43056, 0, 0, 0.55556],\n    \"118\": [0, 0.43056, 0.01389, 0, 0.52778],\n    \"119\": [0, 0.43056, 0.01389, 0, 0.72222],\n    \"120\": [0, 0.43056, 0, 0, 0.52778],\n    \"121\": [0.19444, 0.43056, 0.01389, 0, 0.52778],\n    \"122\": [0, 0.43056, 0, 0, 0.44445],\n    \"123\": [0.25, 0.75, 0, 0, 0.5],\n    \"124\": [0.25, 0.75, 0, 0, 0.27778],\n    \"125\": [0.25, 0.75, 0, 0, 0.5],\n    \"126\": [0.35, 0.31786, 0, 0, 0.5],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"163\": [0, 0.69444, 0, 0, 0.76909],\n    \"167\": [0.19444, 0.69444, 0, 0, 0.44445],\n    \"168\": [0, 0.66786, 0, 0, 0.5],\n    \"172\": [0, 0.43056, 0, 0, 0.66667],\n    \"176\": [0, 0.69444, 0, 0, 0.75],\n    \"177\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"182\": [0.19444, 0.69444, 0, 0, 0.61111],\n    \"184\": [0.17014, 0, 0, 0, 0.44445],\n    \"198\": [0, 0.68333, 0, 0, 0.90278],\n    \"215\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"216\": [0.04861, 0.73194, 0, 0, 0.77778],\n    \"223\": [0, 0.69444, 0, 0, 0.5],\n    \"230\": [0, 0.43056, 0, 0, 0.72222],\n    \"247\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"248\": [0.09722, 0.52778, 0, 0, 0.5],\n    \"305\": [0, 0.43056, 0, 0, 0.27778],\n    \"338\": [0, 0.68333, 0, 0, 1.01389],\n    \"339\": [0, 0.43056, 0, 0, 0.77778],\n    \"567\": [0.19444, 0.43056, 0, 0, 0.30556],\n    \"710\": [0, 0.69444, 0, 0, 0.5],\n    \"711\": [0, 0.62847, 0, 0, 0.5],\n    \"713\": [0, 0.56778, 0, 0, 0.5],\n    \"714\": [0, 0.69444, 0, 0, 0.5],\n    \"715\": [0, 0.69444, 0, 0, 0.5],\n    \"728\": [0, 0.69444, 0, 0, 0.5],\n    \"729\": [0, 0.66786, 0, 0, 0.27778],\n    \"730\": [0, 0.69444, 0, 0, 0.75],\n    \"732\": [0, 0.66786, 0, 0, 0.5],\n    \"733\": [0, 0.69444, 0, 0, 0.5],\n    \"915\": [0, 0.68333, 0, 0, 0.625],\n    \"916\": [0, 0.68333, 0, 0, 0.83334],\n    \"920\": [0, 0.68333, 0, 0, 0.77778],\n    \"923\": [0, 0.68333, 0, 0, 0.69445],\n    \"926\": [0, 0.68333, 0, 0, 0.66667],\n    \"928\": [0, 0.68333, 0, 0, 0.75],\n    \"931\": [0, 0.68333, 0, 0, 0.72222],\n    \"933\": [0, 0.68333, 0, 0, 0.77778],\n    \"934\": [0, 0.68333, 0, 0, 0.72222],\n    \"936\": [0, 0.68333, 0, 0, 0.77778],\n    \"937\": [0, 0.68333, 0, 0, 0.72222],\n    \"8211\": [0, 0.43056, 0.02778, 0, 0.5],\n    \"8212\": [0, 0.43056, 0.02778, 0, 1.0],\n    \"8216\": [0, 0.69444, 0, 0, 0.27778],\n    \"8217\": [0, 0.69444, 0, 0, 0.27778],\n    \"8220\": [0, 0.69444, 0, 0, 0.5],\n    \"8221\": [0, 0.69444, 0, 0, 0.5],\n    \"8224\": [0.19444, 0.69444, 0, 0, 0.44445],\n    \"8225\": [0.19444, 0.69444, 0, 0, 0.44445],\n    \"8230\": [0, 0.123, 0, 0, 1.172],\n    \"8242\": [0, 0.55556, 0, 0, 0.275],\n    \"8407\": [0, 0.71444, 0.15382, 0, 0.5],\n    \"8463\": [0, 0.68889, 0, 0, 0.54028],\n    \"8465\": [0, 0.69444, 0, 0, 0.72222],\n    \"8467\": [0, 0.69444, 0, 0.11111, 0.41667],\n    \"8472\": [0.19444, 0.43056, 0, 0.11111, 0.63646],\n    \"8476\": [0, 0.69444, 0, 0, 0.72222],\n    \"8501\": [0, 0.69444, 0, 0, 0.61111],\n    \"8592\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8593\": [0.19444, 0.69444, 0, 0, 0.5],\n    \"8594\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8595\": [0.19444, 0.69444, 0, 0, 0.5],\n    \"8596\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8597\": [0.25, 0.75, 0, 0, 0.5],\n    \"8598\": [0.19444, 0.69444, 0, 0, 1.0],\n    \"8599\": [0.19444, 0.69444, 0, 0, 1.0],\n    \"8600\": [0.19444, 0.69444, 0, 0, 1.0],\n    \"8601\": [0.19444, 0.69444, 0, 0, 1.0],\n    \"8614\": [0.011, 0.511, 0, 0, 1.0],\n    \"8617\": [0.011, 0.511, 0, 0, 1.126],\n    \"8618\": [0.011, 0.511, 0, 0, 1.126],\n    \"8636\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8637\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8640\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8641\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8652\": [0.011, 0.671, 0, 0, 1.0],\n    \"8656\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8657\": [0.19444, 0.69444, 0, 0, 0.61111],\n    \"8658\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8659\": [0.19444, 0.69444, 0, 0, 0.61111],\n    \"8660\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8661\": [0.25, 0.75, 0, 0, 0.61111],\n    \"8704\": [0, 0.69444, 0, 0, 0.55556],\n    \"8706\": [0, 0.69444, 0.05556, 0.08334, 0.5309],\n    \"8707\": [0, 0.69444, 0, 0, 0.55556],\n    \"8709\": [0.05556, 0.75, 0, 0, 0.5],\n    \"8711\": [0, 0.68333, 0, 0, 0.83334],\n    \"8712\": [0.0391, 0.5391, 0, 0, 0.66667],\n    \"8715\": [0.0391, 0.5391, 0, 0, 0.66667],\n    \"8722\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"8723\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"8725\": [0.25, 0.75, 0, 0, 0.5],\n    \"8726\": [0.25, 0.75, 0, 0, 0.5],\n    \"8727\": [-0.03472, 0.46528, 0, 0, 0.5],\n    \"8728\": [-0.05555, 0.44445, 0, 0, 0.5],\n    \"8729\": [-0.05555, 0.44445, 0, 0, 0.5],\n    \"8730\": [0.2, 0.8, 0, 0, 0.83334],\n    \"8733\": [0, 0.43056, 0, 0, 0.77778],\n    \"8734\": [0, 0.43056, 0, 0, 1.0],\n    \"8736\": [0, 0.69224, 0, 0, 0.72222],\n    \"8739\": [0.25, 0.75, 0, 0, 0.27778],\n    \"8741\": [0.25, 0.75, 0, 0, 0.5],\n    \"8743\": [0, 0.55556, 0, 0, 0.66667],\n    \"8744\": [0, 0.55556, 0, 0, 0.66667],\n    \"8745\": [0, 0.55556, 0, 0, 0.66667],\n    \"8746\": [0, 0.55556, 0, 0, 0.66667],\n    \"8747\": [0.19444, 0.69444, 0.11111, 0, 0.41667],\n    \"8764\": [-0.13313, 0.36687, 0, 0, 0.77778],\n    \"8768\": [0.19444, 0.69444, 0, 0, 0.27778],\n    \"8771\": [-0.03625, 0.46375, 0, 0, 0.77778],\n    \"8773\": [-0.022, 0.589, 0, 0, 0.778],\n    \"8776\": [-0.01688, 0.48312, 0, 0, 0.77778],\n    \"8781\": [-0.03625, 0.46375, 0, 0, 0.77778],\n    \"8784\": [-0.133, 0.673, 0, 0, 0.778],\n    \"8801\": [-0.03625, 0.46375, 0, 0, 0.77778],\n    \"8804\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"8805\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"8810\": [0.0391, 0.5391, 0, 0, 1.0],\n    \"8811\": [0.0391, 0.5391, 0, 0, 1.0],\n    \"8826\": [0.0391, 0.5391, 0, 0, 0.77778],\n    \"8827\": [0.0391, 0.5391, 0, 0, 0.77778],\n    \"8834\": [0.0391, 0.5391, 0, 0, 0.77778],\n    \"8835\": [0.0391, 0.5391, 0, 0, 0.77778],\n    \"8838\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"8839\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"8846\": [0, 0.55556, 0, 0, 0.66667],\n    \"8849\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"8850\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"8851\": [0, 0.55556, 0, 0, 0.66667],\n    \"8852\": [0, 0.55556, 0, 0, 0.66667],\n    \"8853\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"8854\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"8855\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"8856\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"8857\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"8866\": [0, 0.69444, 0, 0, 0.61111],\n    \"8867\": [0, 0.69444, 0, 0, 0.61111],\n    \"8868\": [0, 0.69444, 0, 0, 0.77778],\n    \"8869\": [0, 0.69444, 0, 0, 0.77778],\n    \"8872\": [0.249, 0.75, 0, 0, 0.867],\n    \"8900\": [-0.05555, 0.44445, 0, 0, 0.5],\n    \"8901\": [-0.05555, 0.44445, 0, 0, 0.27778],\n    \"8902\": [-0.03472, 0.46528, 0, 0, 0.5],\n    \"8904\": [0.005, 0.505, 0, 0, 0.9],\n    \"8942\": [0.03, 0.903, 0, 0, 0.278],\n    \"8943\": [-0.19, 0.313, 0, 0, 1.172],\n    \"8945\": [-0.1, 0.823, 0, 0, 1.282],\n    \"8968\": [0.25, 0.75, 0, 0, 0.44445],\n    \"8969\": [0.25, 0.75, 0, 0, 0.44445],\n    \"8970\": [0.25, 0.75, 0, 0, 0.44445],\n    \"8971\": [0.25, 0.75, 0, 0, 0.44445],\n    \"8994\": [-0.14236, 0.35764, 0, 0, 1.0],\n    \"8995\": [-0.14236, 0.35764, 0, 0, 1.0],\n    \"9136\": [0.244, 0.744, 0, 0, 0.412],\n    \"9137\": [0.244, 0.745, 0, 0, 0.412],\n    \"9651\": [0.19444, 0.69444, 0, 0, 0.88889],\n    \"9657\": [-0.03472, 0.46528, 0, 0, 0.5],\n    \"9661\": [0.19444, 0.69444, 0, 0, 0.88889],\n    \"9667\": [-0.03472, 0.46528, 0, 0, 0.5],\n    \"9711\": [0.19444, 0.69444, 0, 0, 1.0],\n    \"9824\": [0.12963, 0.69444, 0, 0, 0.77778],\n    \"9825\": [0.12963, 0.69444, 0, 0, 0.77778],\n    \"9826\": [0.12963, 0.69444, 0, 0, 0.77778],\n    \"9827\": [0.12963, 0.69444, 0, 0, 0.77778],\n    \"9837\": [0, 0.75, 0, 0, 0.38889],\n    \"9838\": [0.19444, 0.69444, 0, 0, 0.38889],\n    \"9839\": [0.19444, 0.69444, 0, 0, 0.38889],\n    \"10216\": [0.25, 0.75, 0, 0, 0.38889],\n    \"10217\": [0.25, 0.75, 0, 0, 0.38889],\n    \"10222\": [0.244, 0.744, 0, 0, 0.412],\n    \"10223\": [0.244, 0.745, 0, 0, 0.412],\n    \"10229\": [0.011, 0.511, 0, 0, 1.609],\n    \"10230\": [0.011, 0.511, 0, 0, 1.638],\n    \"10231\": [0.011, 0.511, 0, 0, 1.859],\n    \"10232\": [0.024, 0.525, 0, 0, 1.609],\n    \"10233\": [0.024, 0.525, 0, 0, 1.638],\n    \"10234\": [0.024, 0.525, 0, 0, 1.858],\n    \"10236\": [0.011, 0.511, 0, 0, 1.638],\n    \"10815\": [0, 0.68333, 0, 0, 0.75],\n    \"10927\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"10928\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"57376\": [0.19444, 0.69444, 0, 0, 0]\n  },\n  \"Math-BoldItalic\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"48\": [0, 0.44444, 0, 0, 0.575],\n    \"49\": [0, 0.44444, 0, 0, 0.575],\n    \"50\": [0, 0.44444, 0, 0, 0.575],\n    \"51\": [0.19444, 0.44444, 0, 0, 0.575],\n    \"52\": [0.19444, 0.44444, 0, 0, 0.575],\n    \"53\": [0.19444, 0.44444, 0, 0, 0.575],\n    \"54\": [0, 0.64444, 0, 0, 0.575],\n    \"55\": [0.19444, 0.44444, 0, 0, 0.575],\n    \"56\": [0, 0.64444, 0, 0, 0.575],\n    \"57\": [0.19444, 0.44444, 0, 0, 0.575],\n    \"65\": [0, 0.68611, 0, 0, 0.86944],\n    \"66\": [0, 0.68611, 0.04835, 0, 0.8664],\n    \"67\": [0, 0.68611, 0.06979, 0, 0.81694],\n    \"68\": [0, 0.68611, 0.03194, 0, 0.93812],\n    \"69\": [0, 0.68611, 0.05451, 0, 0.81007],\n    \"70\": [0, 0.68611, 0.15972, 0, 0.68889],\n    \"71\": [0, 0.68611, 0, 0, 0.88673],\n    \"72\": [0, 0.68611, 0.08229, 0, 0.98229],\n    \"73\": [0, 0.68611, 0.07778, 0, 0.51111],\n    \"74\": [0, 0.68611, 0.10069, 0, 0.63125],\n    \"75\": [0, 0.68611, 0.06979, 0, 0.97118],\n    \"76\": [0, 0.68611, 0, 0, 0.75555],\n    \"77\": [0, 0.68611, 0.11424, 0, 1.14201],\n    \"78\": [0, 0.68611, 0.11424, 0, 0.95034],\n    \"79\": [0, 0.68611, 0.03194, 0, 0.83666],\n    \"80\": [0, 0.68611, 0.15972, 0, 0.72309],\n    \"81\": [0.19444, 0.68611, 0, 0, 0.86861],\n    \"82\": [0, 0.68611, 0.00421, 0, 0.87235],\n    \"83\": [0, 0.68611, 0.05382, 0, 0.69271],\n    \"84\": [0, 0.68611, 0.15972, 0, 0.63663],\n    \"85\": [0, 0.68611, 0.11424, 0, 0.80027],\n    \"86\": [0, 0.68611, 0.25555, 0, 0.67778],\n    \"87\": [0, 0.68611, 0.15972, 0, 1.09305],\n    \"88\": [0, 0.68611, 0.07778, 0, 0.94722],\n    \"89\": [0, 0.68611, 0.25555, 0, 0.67458],\n    \"90\": [0, 0.68611, 0.06979, 0, 0.77257],\n    \"97\": [0, 0.44444, 0, 0, 0.63287],\n    \"98\": [0, 0.69444, 0, 0, 0.52083],\n    \"99\": [0, 0.44444, 0, 0, 0.51342],\n    \"100\": [0, 0.69444, 0, 0, 0.60972],\n    \"101\": [0, 0.44444, 0, 0, 0.55361],\n    \"102\": [0.19444, 0.69444, 0.11042, 0, 0.56806],\n    \"103\": [0.19444, 0.44444, 0.03704, 0, 0.5449],\n    \"104\": [0, 0.69444, 0, 0, 0.66759],\n    \"105\": [0, 0.69326, 0, 0, 0.4048],\n    \"106\": [0.19444, 0.69326, 0.0622, 0, 0.47083],\n    \"107\": [0, 0.69444, 0.01852, 0, 0.6037],\n    \"108\": [0, 0.69444, 0.0088, 0, 0.34815],\n    \"109\": [0, 0.44444, 0, 0, 1.0324],\n    \"110\": [0, 0.44444, 0, 0, 0.71296],\n    \"111\": [0, 0.44444, 0, 0, 0.58472],\n    \"112\": [0.19444, 0.44444, 0, 0, 0.60092],\n    \"113\": [0.19444, 0.44444, 0.03704, 0, 0.54213],\n    \"114\": [0, 0.44444, 0.03194, 0, 0.5287],\n    \"115\": [0, 0.44444, 0, 0, 0.53125],\n    \"116\": [0, 0.63492, 0, 0, 0.41528],\n    \"117\": [0, 0.44444, 0, 0, 0.68102],\n    \"118\": [0, 0.44444, 0.03704, 0, 0.56666],\n    \"119\": [0, 0.44444, 0.02778, 0, 0.83148],\n    \"120\": [0, 0.44444, 0, 0, 0.65903],\n    \"121\": [0.19444, 0.44444, 0.03704, 0, 0.59028],\n    \"122\": [0, 0.44444, 0.04213, 0, 0.55509],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"915\": [0, 0.68611, 0.15972, 0, 0.65694],\n    \"916\": [0, 0.68611, 0, 0, 0.95833],\n    \"920\": [0, 0.68611, 0.03194, 0, 0.86722],\n    \"923\": [0, 0.68611, 0, 0, 0.80555],\n    \"926\": [0, 0.68611, 0.07458, 0, 0.84125],\n    \"928\": [0, 0.68611, 0.08229, 0, 0.98229],\n    \"931\": [0, 0.68611, 0.05451, 0, 0.88507],\n    \"933\": [0, 0.68611, 0.15972, 0, 0.67083],\n    \"934\": [0, 0.68611, 0, 0, 0.76666],\n    \"936\": [0, 0.68611, 0.11653, 0, 0.71402],\n    \"937\": [0, 0.68611, 0.04835, 0, 0.8789],\n    \"945\": [0, 0.44444, 0, 0, 0.76064],\n    \"946\": [0.19444, 0.69444, 0.03403, 0, 0.65972],\n    \"947\": [0.19444, 0.44444, 0.06389, 0, 0.59003],\n    \"948\": [0, 0.69444, 0.03819, 0, 0.52222],\n    \"949\": [0, 0.44444, 0, 0, 0.52882],\n    \"950\": [0.19444, 0.69444, 0.06215, 0, 0.50833],\n    \"951\": [0.19444, 0.44444, 0.03704, 0, 0.6],\n    \"952\": [0, 0.69444, 0.03194, 0, 0.5618],\n    \"953\": [0, 0.44444, 0, 0, 0.41204],\n    \"954\": [0, 0.44444, 0, 0, 0.66759],\n    \"955\": [0, 0.69444, 0, 0, 0.67083],\n    \"956\": [0.19444, 0.44444, 0, 0, 0.70787],\n    \"957\": [0, 0.44444, 0.06898, 0, 0.57685],\n    \"958\": [0.19444, 0.69444, 0.03021, 0, 0.50833],\n    \"959\": [0, 0.44444, 0, 0, 0.58472],\n    \"960\": [0, 0.44444, 0.03704, 0, 0.68241],\n    \"961\": [0.19444, 0.44444, 0, 0, 0.6118],\n    \"962\": [0.09722, 0.44444, 0.07917, 0, 0.42361],\n    \"963\": [0, 0.44444, 0.03704, 0, 0.68588],\n    \"964\": [0, 0.44444, 0.13472, 0, 0.52083],\n    \"965\": [0, 0.44444, 0.03704, 0, 0.63055],\n    \"966\": [0.19444, 0.44444, 0, 0, 0.74722],\n    \"967\": [0.19444, 0.44444, 0, 0, 0.71805],\n    \"968\": [0.19444, 0.69444, 0.03704, 0, 0.75833],\n    \"969\": [0, 0.44444, 0.03704, 0, 0.71782],\n    \"977\": [0, 0.69444, 0, 0, 0.69155],\n    \"981\": [0.19444, 0.69444, 0, 0, 0.7125],\n    \"982\": [0, 0.44444, 0.03194, 0, 0.975],\n    \"1009\": [0.19444, 0.44444, 0, 0, 0.6118],\n    \"1013\": [0, 0.44444, 0, 0, 0.48333],\n    \"57649\": [0, 0.44444, 0, 0, 0.39352],\n    \"57911\": [0.19444, 0.44444, 0, 0, 0.43889]\n  },\n  \"Math-Italic\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"48\": [0, 0.43056, 0, 0, 0.5],\n    \"49\": [0, 0.43056, 0, 0, 0.5],\n    \"50\": [0, 0.43056, 0, 0, 0.5],\n    \"51\": [0.19444, 0.43056, 0, 0, 0.5],\n    \"52\": [0.19444, 0.43056, 0, 0, 0.5],\n    \"53\": [0.19444, 0.43056, 0, 0, 0.5],\n    \"54\": [0, 0.64444, 0, 0, 0.5],\n    \"55\": [0.19444, 0.43056, 0, 0, 0.5],\n    \"56\": [0, 0.64444, 0, 0, 0.5],\n    \"57\": [0.19444, 0.43056, 0, 0, 0.5],\n    \"65\": [0, 0.68333, 0, 0.13889, 0.75],\n    \"66\": [0, 0.68333, 0.05017, 0.08334, 0.75851],\n    \"67\": [0, 0.68333, 0.07153, 0.08334, 0.71472],\n    \"68\": [0, 0.68333, 0.02778, 0.05556, 0.82792],\n    \"69\": [0, 0.68333, 0.05764, 0.08334, 0.7382],\n    \"70\": [0, 0.68333, 0.13889, 0.08334, 0.64306],\n    \"71\": [0, 0.68333, 0, 0.08334, 0.78625],\n    \"72\": [0, 0.68333, 0.08125, 0.05556, 0.83125],\n    \"73\": [0, 0.68333, 0.07847, 0.11111, 0.43958],\n    \"74\": [0, 0.68333, 0.09618, 0.16667, 0.55451],\n    \"75\": [0, 0.68333, 0.07153, 0.05556, 0.84931],\n    \"76\": [0, 0.68333, 0, 0.02778, 0.68056],\n    \"77\": [0, 0.68333, 0.10903, 0.08334, 0.97014],\n    \"78\": [0, 0.68333, 0.10903, 0.08334, 0.80347],\n    \"79\": [0, 0.68333, 0.02778, 0.08334, 0.76278],\n    \"80\": [0, 0.68333, 0.13889, 0.08334, 0.64201],\n    \"81\": [0.19444, 0.68333, 0, 0.08334, 0.79056],\n    \"82\": [0, 0.68333, 0.00773, 0.08334, 0.75929],\n    \"83\": [0, 0.68333, 0.05764, 0.08334, 0.6132],\n    \"84\": [0, 0.68333, 0.13889, 0.08334, 0.58438],\n    \"85\": [0, 0.68333, 0.10903, 0.02778, 0.68278],\n    \"86\": [0, 0.68333, 0.22222, 0, 0.58333],\n    \"87\": [0, 0.68333, 0.13889, 0, 0.94445],\n    \"88\": [0, 0.68333, 0.07847, 0.08334, 0.82847],\n    \"89\": [0, 0.68333, 0.22222, 0, 0.58056],\n    \"90\": [0, 0.68333, 0.07153, 0.08334, 0.68264],\n    \"97\": [0, 0.43056, 0, 0, 0.52859],\n    \"98\": [0, 0.69444, 0, 0, 0.42917],\n    \"99\": [0, 0.43056, 0, 0.05556, 0.43276],\n    \"100\": [0, 0.69444, 0, 0.16667, 0.52049],\n    \"101\": [0, 0.43056, 0, 0.05556, 0.46563],\n    \"102\": [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],\n    \"103\": [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],\n    \"104\": [0, 0.69444, 0, 0, 0.57616],\n    \"105\": [0, 0.65952, 0, 0, 0.34451],\n    \"106\": [0.19444, 0.65952, 0.05724, 0, 0.41181],\n    \"107\": [0, 0.69444, 0.03148, 0, 0.5206],\n    \"108\": [0, 0.69444, 0.01968, 0.08334, 0.29838],\n    \"109\": [0, 0.43056, 0, 0, 0.87801],\n    \"110\": [0, 0.43056, 0, 0, 0.60023],\n    \"111\": [0, 0.43056, 0, 0.05556, 0.48472],\n    \"112\": [0.19444, 0.43056, 0, 0.08334, 0.50313],\n    \"113\": [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],\n    \"114\": [0, 0.43056, 0.02778, 0.05556, 0.45116],\n    \"115\": [0, 0.43056, 0, 0.05556, 0.46875],\n    \"116\": [0, 0.61508, 0, 0.08334, 0.36111],\n    \"117\": [0, 0.43056, 0, 0.02778, 0.57246],\n    \"118\": [0, 0.43056, 0.03588, 0.02778, 0.48472],\n    \"119\": [0, 0.43056, 0.02691, 0.08334, 0.71592],\n    \"120\": [0, 0.43056, 0, 0.02778, 0.57153],\n    \"121\": [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],\n    \"122\": [0, 0.43056, 0.04398, 0.05556, 0.46505],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"915\": [0, 0.68333, 0.13889, 0.08334, 0.61528],\n    \"916\": [0, 0.68333, 0, 0.16667, 0.83334],\n    \"920\": [0, 0.68333, 0.02778, 0.08334, 0.76278],\n    \"923\": [0, 0.68333, 0, 0.16667, 0.69445],\n    \"926\": [0, 0.68333, 0.07569, 0.08334, 0.74236],\n    \"928\": [0, 0.68333, 0.08125, 0.05556, 0.83125],\n    \"931\": [0, 0.68333, 0.05764, 0.08334, 0.77986],\n    \"933\": [0, 0.68333, 0.13889, 0.05556, 0.58333],\n    \"934\": [0, 0.68333, 0, 0.08334, 0.66667],\n    \"936\": [0, 0.68333, 0.11, 0.05556, 0.61222],\n    \"937\": [0, 0.68333, 0.05017, 0.08334, 0.7724],\n    \"945\": [0, 0.43056, 0.0037, 0.02778, 0.6397],\n    \"946\": [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],\n    \"947\": [0.19444, 0.43056, 0.05556, 0, 0.51773],\n    \"948\": [0, 0.69444, 0.03785, 0.05556, 0.44444],\n    \"949\": [0, 0.43056, 0, 0.08334, 0.46632],\n    \"950\": [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],\n    \"951\": [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],\n    \"952\": [0, 0.69444, 0.02778, 0.08334, 0.46944],\n    \"953\": [0, 0.43056, 0, 0.05556, 0.35394],\n    \"954\": [0, 0.43056, 0, 0, 0.57616],\n    \"955\": [0, 0.69444, 0, 0, 0.58334],\n    \"956\": [0.19444, 0.43056, 0, 0.02778, 0.60255],\n    \"957\": [0, 0.43056, 0.06366, 0.02778, 0.49398],\n    \"958\": [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],\n    \"959\": [0, 0.43056, 0, 0.05556, 0.48472],\n    \"960\": [0, 0.43056, 0.03588, 0, 0.57003],\n    \"961\": [0.19444, 0.43056, 0, 0.08334, 0.51702],\n    \"962\": [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],\n    \"963\": [0, 0.43056, 0.03588, 0, 0.57141],\n    \"964\": [0, 0.43056, 0.1132, 0.02778, 0.43715],\n    \"965\": [0, 0.43056, 0.03588, 0.02778, 0.54028],\n    \"966\": [0.19444, 0.43056, 0, 0.08334, 0.65417],\n    \"967\": [0.19444, 0.43056, 0, 0.05556, 0.62569],\n    \"968\": [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],\n    \"969\": [0, 0.43056, 0.03588, 0, 0.62245],\n    \"977\": [0, 0.69444, 0, 0.08334, 0.59144],\n    \"981\": [0.19444, 0.69444, 0, 0.08334, 0.59583],\n    \"982\": [0, 0.43056, 0.02778, 0, 0.82813],\n    \"1009\": [0.19444, 0.43056, 0, 0.08334, 0.51702],\n    \"1013\": [0, 0.43056, 0, 0.05556, 0.4059],\n    \"57649\": [0, 0.43056, 0, 0.02778, 0.32246],\n    \"57911\": [0.19444, 0.43056, 0, 0.08334, 0.38403]\n  },\n  \"SansSerif-Bold\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"33\": [0, 0.69444, 0, 0, 0.36667],\n    \"34\": [0, 0.69444, 0, 0, 0.55834],\n    \"35\": [0.19444, 0.69444, 0, 0, 0.91667],\n    \"36\": [0.05556, 0.75, 0, 0, 0.55],\n    \"37\": [0.05556, 0.75, 0, 0, 1.02912],\n    \"38\": [0, 0.69444, 0, 0, 0.83056],\n    \"39\": [0, 0.69444, 0, 0, 0.30556],\n    \"40\": [0.25, 0.75, 0, 0, 0.42778],\n    \"41\": [0.25, 0.75, 0, 0, 0.42778],\n    \"42\": [0, 0.75, 0, 0, 0.55],\n    \"43\": [0.11667, 0.61667, 0, 0, 0.85556],\n    \"44\": [0.10556, 0.13056, 0, 0, 0.30556],\n    \"45\": [0, 0.45833, 0, 0, 0.36667],\n    \"46\": [0, 0.13056, 0, 0, 0.30556],\n    \"47\": [0.25, 0.75, 0, 0, 0.55],\n    \"48\": [0, 0.69444, 0, 0, 0.55],\n    \"49\": [0, 0.69444, 0, 0, 0.55],\n    \"50\": [0, 0.69444, 0, 0, 0.55],\n    \"51\": [0, 0.69444, 0, 0, 0.55],\n    \"52\": [0, 0.69444, 0, 0, 0.55],\n    \"53\": [0, 0.69444, 0, 0, 0.55],\n    \"54\": [0, 0.69444, 0, 0, 0.55],\n    \"55\": [0, 0.69444, 0, 0, 0.55],\n    \"56\": [0, 0.69444, 0, 0, 0.55],\n    \"57\": [0, 0.69444, 0, 0, 0.55],\n    \"58\": [0, 0.45833, 0, 0, 0.30556],\n    \"59\": [0.10556, 0.45833, 0, 0, 0.30556],\n    \"61\": [-0.09375, 0.40625, 0, 0, 0.85556],\n    \"63\": [0, 0.69444, 0, 0, 0.51945],\n    \"64\": [0, 0.69444, 0, 0, 0.73334],\n    \"65\": [0, 0.69444, 0, 0, 0.73334],\n    \"66\": [0, 0.69444, 0, 0, 0.73334],\n    \"67\": [0, 0.69444, 0, 0, 0.70278],\n    \"68\": [0, 0.69444, 0, 0, 0.79445],\n    \"69\": [0, 0.69444, 0, 0, 0.64167],\n    \"70\": [0, 0.69444, 0, 0, 0.61111],\n    \"71\": [0, 0.69444, 0, 0, 0.73334],\n    \"72\": [0, 0.69444, 0, 0, 0.79445],\n    \"73\": [0, 0.69444, 0, 0, 0.33056],\n    \"74\": [0, 0.69444, 0, 0, 0.51945],\n    \"75\": [0, 0.69444, 0, 0, 0.76389],\n    \"76\": [0, 0.69444, 0, 0, 0.58056],\n    \"77\": [0, 0.69444, 0, 0, 0.97778],\n    \"78\": [0, 0.69444, 0, 0, 0.79445],\n    \"79\": [0, 0.69444, 0, 0, 0.79445],\n    \"80\": [0, 0.69444, 0, 0, 0.70278],\n    \"81\": [0.10556, 0.69444, 0, 0, 0.79445],\n    \"82\": [0, 0.69444, 0, 0, 0.70278],\n    \"83\": [0, 0.69444, 0, 0, 0.61111],\n    \"84\": [0, 0.69444, 0, 0, 0.73334],\n    \"85\": [0, 0.69444, 0, 0, 0.76389],\n    \"86\": [0, 0.69444, 0.01528, 0, 0.73334],\n    \"87\": [0, 0.69444, 0.01528, 0, 1.03889],\n    \"88\": [0, 0.69444, 0, 0, 0.73334],\n    \"89\": [0, 0.69444, 0.0275, 0, 0.73334],\n    \"90\": [0, 0.69444, 0, 0, 0.67223],\n    \"91\": [0.25, 0.75, 0, 0, 0.34306],\n    \"93\": [0.25, 0.75, 0, 0, 0.34306],\n    \"94\": [0, 0.69444, 0, 0, 0.55],\n    \"95\": [0.35, 0.10833, 0.03056, 0, 0.55],\n    \"97\": [0, 0.45833, 0, 0, 0.525],\n    \"98\": [0, 0.69444, 0, 0, 0.56111],\n    \"99\": [0, 0.45833, 0, 0, 0.48889],\n    \"100\": [0, 0.69444, 0, 0, 0.56111],\n    \"101\": [0, 0.45833, 0, 0, 0.51111],\n    \"102\": [0, 0.69444, 0.07639, 0, 0.33611],\n    \"103\": [0.19444, 0.45833, 0.01528, 0, 0.55],\n    \"104\": [0, 0.69444, 0, 0, 0.56111],\n    \"105\": [0, 0.69444, 0, 0, 0.25556],\n    \"106\": [0.19444, 0.69444, 0, 0, 0.28611],\n    \"107\": [0, 0.69444, 0, 0, 0.53056],\n    \"108\": [0, 0.69444, 0, 0, 0.25556],\n    \"109\": [0, 0.45833, 0, 0, 0.86667],\n    \"110\": [0, 0.45833, 0, 0, 0.56111],\n    \"111\": [0, 0.45833, 0, 0, 0.55],\n    \"112\": [0.19444, 0.45833, 0, 0, 0.56111],\n    \"113\": [0.19444, 0.45833, 0, 0, 0.56111],\n    \"114\": [0, 0.45833, 0.01528, 0, 0.37222],\n    \"115\": [0, 0.45833, 0, 0, 0.42167],\n    \"116\": [0, 0.58929, 0, 0, 0.40417],\n    \"117\": [0, 0.45833, 0, 0, 0.56111],\n    \"118\": [0, 0.45833, 0.01528, 0, 0.5],\n    \"119\": [0, 0.45833, 0.01528, 0, 0.74445],\n    \"120\": [0, 0.45833, 0, 0, 0.5],\n    \"121\": [0.19444, 0.45833, 0.01528, 0, 0.5],\n    \"122\": [0, 0.45833, 0, 0, 0.47639],\n    \"126\": [0.35, 0.34444, 0, 0, 0.55],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"168\": [0, 0.69444, 0, 0, 0.55],\n    \"176\": [0, 0.69444, 0, 0, 0.73334],\n    \"180\": [0, 0.69444, 0, 0, 0.55],\n    \"184\": [0.17014, 0, 0, 0, 0.48889],\n    \"305\": [0, 0.45833, 0, 0, 0.25556],\n    \"567\": [0.19444, 0.45833, 0, 0, 0.28611],\n    \"710\": [0, 0.69444, 0, 0, 0.55],\n    \"711\": [0, 0.63542, 0, 0, 0.55],\n    \"713\": [0, 0.63778, 0, 0, 0.55],\n    \"728\": [0, 0.69444, 0, 0, 0.55],\n    \"729\": [0, 0.69444, 0, 0, 0.30556],\n    \"730\": [0, 0.69444, 0, 0, 0.73334],\n    \"732\": [0, 0.69444, 0, 0, 0.55],\n    \"733\": [0, 0.69444, 0, 0, 0.55],\n    \"915\": [0, 0.69444, 0, 0, 0.58056],\n    \"916\": [0, 0.69444, 0, 0, 0.91667],\n    \"920\": [0, 0.69444, 0, 0, 0.85556],\n    \"923\": [0, 0.69444, 0, 0, 0.67223],\n    \"926\": [0, 0.69444, 0, 0, 0.73334],\n    \"928\": [0, 0.69444, 0, 0, 0.79445],\n    \"931\": [0, 0.69444, 0, 0, 0.79445],\n    \"933\": [0, 0.69444, 0, 0, 0.85556],\n    \"934\": [0, 0.69444, 0, 0, 0.79445],\n    \"936\": [0, 0.69444, 0, 0, 0.85556],\n    \"937\": [0, 0.69444, 0, 0, 0.79445],\n    \"8211\": [0, 0.45833, 0.03056, 0, 0.55],\n    \"8212\": [0, 0.45833, 0.03056, 0, 1.10001],\n    \"8216\": [0, 0.69444, 0, 0, 0.30556],\n    \"8217\": [0, 0.69444, 0, 0, 0.30556],\n    \"8220\": [0, 0.69444, 0, 0, 0.55834],\n    \"8221\": [0, 0.69444, 0, 0, 0.55834]\n  },\n  \"SansSerif-Italic\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"33\": [0, 0.69444, 0.05733, 0, 0.31945],\n    \"34\": [0, 0.69444, 0.00316, 0, 0.5],\n    \"35\": [0.19444, 0.69444, 0.05087, 0, 0.83334],\n    \"36\": [0.05556, 0.75, 0.11156, 0, 0.5],\n    \"37\": [0.05556, 0.75, 0.03126, 0, 0.83334],\n    \"38\": [0, 0.69444, 0.03058, 0, 0.75834],\n    \"39\": [0, 0.69444, 0.07816, 0, 0.27778],\n    \"40\": [0.25, 0.75, 0.13164, 0, 0.38889],\n    \"41\": [0.25, 0.75, 0.02536, 0, 0.38889],\n    \"42\": [0, 0.75, 0.11775, 0, 0.5],\n    \"43\": [0.08333, 0.58333, 0.02536, 0, 0.77778],\n    \"44\": [0.125, 0.08333, 0, 0, 0.27778],\n    \"45\": [0, 0.44444, 0.01946, 0, 0.33333],\n    \"46\": [0, 0.08333, 0, 0, 0.27778],\n    \"47\": [0.25, 0.75, 0.13164, 0, 0.5],\n    \"48\": [0, 0.65556, 0.11156, 0, 0.5],\n    \"49\": [0, 0.65556, 0.11156, 0, 0.5],\n    \"50\": [0, 0.65556, 0.11156, 0, 0.5],\n    \"51\": [0, 0.65556, 0.11156, 0, 0.5],\n    \"52\": [0, 0.65556, 0.11156, 0, 0.5],\n    \"53\": [0, 0.65556, 0.11156, 0, 0.5],\n    \"54\": [0, 0.65556, 0.11156, 0, 0.5],\n    \"55\": [0, 0.65556, 0.11156, 0, 0.5],\n    \"56\": [0, 0.65556, 0.11156, 0, 0.5],\n    \"57\": [0, 0.65556, 0.11156, 0, 0.5],\n    \"58\": [0, 0.44444, 0.02502, 0, 0.27778],\n    \"59\": [0.125, 0.44444, 0.02502, 0, 0.27778],\n    \"61\": [-0.13, 0.37, 0.05087, 0, 0.77778],\n    \"63\": [0, 0.69444, 0.11809, 0, 0.47222],\n    \"64\": [0, 0.69444, 0.07555, 0, 0.66667],\n    \"65\": [0, 0.69444, 0, 0, 0.66667],\n    \"66\": [0, 0.69444, 0.08293, 0, 0.66667],\n    \"67\": [0, 0.69444, 0.11983, 0, 0.63889],\n    \"68\": [0, 0.69444, 0.07555, 0, 0.72223],\n    \"69\": [0, 0.69444, 0.11983, 0, 0.59722],\n    \"70\": [0, 0.69444, 0.13372, 0, 0.56945],\n    \"71\": [0, 0.69444, 0.11983, 0, 0.66667],\n    \"72\": [0, 0.69444, 0.08094, 0, 0.70834],\n    \"73\": [0, 0.69444, 0.13372, 0, 0.27778],\n    \"74\": [0, 0.69444, 0.08094, 0, 0.47222],\n    \"75\": [0, 0.69444, 0.11983, 0, 0.69445],\n    \"76\": [0, 0.69444, 0, 0, 0.54167],\n    \"77\": [0, 0.69444, 0.08094, 0, 0.875],\n    \"78\": [0, 0.69444, 0.08094, 0, 0.70834],\n    \"79\": [0, 0.69444, 0.07555, 0, 0.73611],\n    \"80\": [0, 0.69444, 0.08293, 0, 0.63889],\n    \"81\": [0.125, 0.69444, 0.07555, 0, 0.73611],\n    \"82\": [0, 0.69444, 0.08293, 0, 0.64584],\n    \"83\": [0, 0.69444, 0.09205, 0, 0.55556],\n    \"84\": [0, 0.69444, 0.13372, 0, 0.68056],\n    \"85\": [0, 0.69444, 0.08094, 0, 0.6875],\n    \"86\": [0, 0.69444, 0.1615, 0, 0.66667],\n    \"87\": [0, 0.69444, 0.1615, 0, 0.94445],\n    \"88\": [0, 0.69444, 0.13372, 0, 0.66667],\n    \"89\": [0, 0.69444, 0.17261, 0, 0.66667],\n    \"90\": [0, 0.69444, 0.11983, 0, 0.61111],\n    \"91\": [0.25, 0.75, 0.15942, 0, 0.28889],\n    \"93\": [0.25, 0.75, 0.08719, 0, 0.28889],\n    \"94\": [0, 0.69444, 0.0799, 0, 0.5],\n    \"95\": [0.35, 0.09444, 0.08616, 0, 0.5],\n    \"97\": [0, 0.44444, 0.00981, 0, 0.48056],\n    \"98\": [0, 0.69444, 0.03057, 0, 0.51667],\n    \"99\": [0, 0.44444, 0.08336, 0, 0.44445],\n    \"100\": [0, 0.69444, 0.09483, 0, 0.51667],\n    \"101\": [0, 0.44444, 0.06778, 0, 0.44445],\n    \"102\": [0, 0.69444, 0.21705, 0, 0.30556],\n    \"103\": [0.19444, 0.44444, 0.10836, 0, 0.5],\n    \"104\": [0, 0.69444, 0.01778, 0, 0.51667],\n    \"105\": [0, 0.67937, 0.09718, 0, 0.23889],\n    \"106\": [0.19444, 0.67937, 0.09162, 0, 0.26667],\n    \"107\": [0, 0.69444, 0.08336, 0, 0.48889],\n    \"108\": [0, 0.69444, 0.09483, 0, 0.23889],\n    \"109\": [0, 0.44444, 0.01778, 0, 0.79445],\n    \"110\": [0, 0.44444, 0.01778, 0, 0.51667],\n    \"111\": [0, 0.44444, 0.06613, 0, 0.5],\n    \"112\": [0.19444, 0.44444, 0.0389, 0, 0.51667],\n    \"113\": [0.19444, 0.44444, 0.04169, 0, 0.51667],\n    \"114\": [0, 0.44444, 0.10836, 0, 0.34167],\n    \"115\": [0, 0.44444, 0.0778, 0, 0.38333],\n    \"116\": [0, 0.57143, 0.07225, 0, 0.36111],\n    \"117\": [0, 0.44444, 0.04169, 0, 0.51667],\n    \"118\": [0, 0.44444, 0.10836, 0, 0.46111],\n    \"119\": [0, 0.44444, 0.10836, 0, 0.68334],\n    \"120\": [0, 0.44444, 0.09169, 0, 0.46111],\n    \"121\": [0.19444, 0.44444, 0.10836, 0, 0.46111],\n    \"122\": [0, 0.44444, 0.08752, 0, 0.43472],\n    \"126\": [0.35, 0.32659, 0.08826, 0, 0.5],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"168\": [0, 0.67937, 0.06385, 0, 0.5],\n    \"176\": [0, 0.69444, 0, 0, 0.73752],\n    \"184\": [0.17014, 0, 0, 0, 0.44445],\n    \"305\": [0, 0.44444, 0.04169, 0, 0.23889],\n    \"567\": [0.19444, 0.44444, 0.04169, 0, 0.26667],\n    \"710\": [0, 0.69444, 0.0799, 0, 0.5],\n    \"711\": [0, 0.63194, 0.08432, 0, 0.5],\n    \"713\": [0, 0.60889, 0.08776, 0, 0.5],\n    \"714\": [0, 0.69444, 0.09205, 0, 0.5],\n    \"715\": [0, 0.69444, 0, 0, 0.5],\n    \"728\": [0, 0.69444, 0.09483, 0, 0.5],\n    \"729\": [0, 0.67937, 0.07774, 0, 0.27778],\n    \"730\": [0, 0.69444, 0, 0, 0.73752],\n    \"732\": [0, 0.67659, 0.08826, 0, 0.5],\n    \"733\": [0, 0.69444, 0.09205, 0, 0.5],\n    \"915\": [0, 0.69444, 0.13372, 0, 0.54167],\n    \"916\": [0, 0.69444, 0, 0, 0.83334],\n    \"920\": [0, 0.69444, 0.07555, 0, 0.77778],\n    \"923\": [0, 0.69444, 0, 0, 0.61111],\n    \"926\": [0, 0.69444, 0.12816, 0, 0.66667],\n    \"928\": [0, 0.69444, 0.08094, 0, 0.70834],\n    \"931\": [0, 0.69444, 0.11983, 0, 0.72222],\n    \"933\": [0, 0.69444, 0.09031, 0, 0.77778],\n    \"934\": [0, 0.69444, 0.04603, 0, 0.72222],\n    \"936\": [0, 0.69444, 0.09031, 0, 0.77778],\n    \"937\": [0, 0.69444, 0.08293, 0, 0.72222],\n    \"8211\": [0, 0.44444, 0.08616, 0, 0.5],\n    \"8212\": [0, 0.44444, 0.08616, 0, 1.0],\n    \"8216\": [0, 0.69444, 0.07816, 0, 0.27778],\n    \"8217\": [0, 0.69444, 0.07816, 0, 0.27778],\n    \"8220\": [0, 0.69444, 0.14205, 0, 0.5],\n    \"8221\": [0, 0.69444, 0.00316, 0, 0.5]\n  },\n  \"SansSerif-Regular\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"33\": [0, 0.69444, 0, 0, 0.31945],\n    \"34\": [0, 0.69444, 0, 0, 0.5],\n    \"35\": [0.19444, 0.69444, 0, 0, 0.83334],\n    \"36\": [0.05556, 0.75, 0, 0, 0.5],\n    \"37\": [0.05556, 0.75, 0, 0, 0.83334],\n    \"38\": [0, 0.69444, 0, 0, 0.75834],\n    \"39\": [0, 0.69444, 0, 0, 0.27778],\n    \"40\": [0.25, 0.75, 0, 0, 0.38889],\n    \"41\": [0.25, 0.75, 0, 0, 0.38889],\n    \"42\": [0, 0.75, 0, 0, 0.5],\n    \"43\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"44\": [0.125, 0.08333, 0, 0, 0.27778],\n    \"45\": [0, 0.44444, 0, 0, 0.33333],\n    \"46\": [0, 0.08333, 0, 0, 0.27778],\n    \"47\": [0.25, 0.75, 0, 0, 0.5],\n    \"48\": [0, 0.65556, 0, 0, 0.5],\n    \"49\": [0, 0.65556, 0, 0, 0.5],\n    \"50\": [0, 0.65556, 0, 0, 0.5],\n    \"51\": [0, 0.65556, 0, 0, 0.5],\n    \"52\": [0, 0.65556, 0, 0, 0.5],\n    \"53\": [0, 0.65556, 0, 0, 0.5],\n    \"54\": [0, 0.65556, 0, 0, 0.5],\n    \"55\": [0, 0.65556, 0, 0, 0.5],\n    \"56\": [0, 0.65556, 0, 0, 0.5],\n    \"57\": [0, 0.65556, 0, 0, 0.5],\n    \"58\": [0, 0.44444, 0, 0, 0.27778],\n    \"59\": [0.125, 0.44444, 0, 0, 0.27778],\n    \"61\": [-0.13, 0.37, 0, 0, 0.77778],\n    \"63\": [0, 0.69444, 0, 0, 0.47222],\n    \"64\": [0, 0.69444, 0, 0, 0.66667],\n    \"65\": [0, 0.69444, 0, 0, 0.66667],\n    \"66\": [0, 0.69444, 0, 0, 0.66667],\n    \"67\": [0, 0.69444, 0, 0, 0.63889],\n    \"68\": [0, 0.69444, 0, 0, 0.72223],\n    \"69\": [0, 0.69444, 0, 0, 0.59722],\n    \"70\": [0, 0.69444, 0, 0, 0.56945],\n    \"71\": [0, 0.69444, 0, 0, 0.66667],\n    \"72\": [0, 0.69444, 0, 0, 0.70834],\n    \"73\": [0, 0.69444, 0, 0, 0.27778],\n    \"74\": [0, 0.69444, 0, 0, 0.47222],\n    \"75\": [0, 0.69444, 0, 0, 0.69445],\n    \"76\": [0, 0.69444, 0, 0, 0.54167],\n    \"77\": [0, 0.69444, 0, 0, 0.875],\n    \"78\": [0, 0.69444, 0, 0, 0.70834],\n    \"79\": [0, 0.69444, 0, 0, 0.73611],\n    \"80\": [0, 0.69444, 0, 0, 0.63889],\n    \"81\": [0.125, 0.69444, 0, 0, 0.73611],\n    \"82\": [0, 0.69444, 0, 0, 0.64584],\n    \"83\": [0, 0.69444, 0, 0, 0.55556],\n    \"84\": [0, 0.69444, 0, 0, 0.68056],\n    \"85\": [0, 0.69444, 0, 0, 0.6875],\n    \"86\": [0, 0.69444, 0.01389, 0, 0.66667],\n    \"87\": [0, 0.69444, 0.01389, 0, 0.94445],\n    \"88\": [0, 0.69444, 0, 0, 0.66667],\n    \"89\": [0, 0.69444, 0.025, 0, 0.66667],\n    \"90\": [0, 0.69444, 0, 0, 0.61111],\n    \"91\": [0.25, 0.75, 0, 0, 0.28889],\n    \"93\": [0.25, 0.75, 0, 0, 0.28889],\n    \"94\": [0, 0.69444, 0, 0, 0.5],\n    \"95\": [0.35, 0.09444, 0.02778, 0, 0.5],\n    \"97\": [0, 0.44444, 0, 0, 0.48056],\n    \"98\": [0, 0.69444, 0, 0, 0.51667],\n    \"99\": [0, 0.44444, 0, 0, 0.44445],\n    \"100\": [0, 0.69444, 0, 0, 0.51667],\n    \"101\": [0, 0.44444, 0, 0, 0.44445],\n    \"102\": [0, 0.69444, 0.06944, 0, 0.30556],\n    \"103\": [0.19444, 0.44444, 0.01389, 0, 0.5],\n    \"104\": [0, 0.69444, 0, 0, 0.51667],\n    \"105\": [0, 0.67937, 0, 0, 0.23889],\n    \"106\": [0.19444, 0.67937, 0, 0, 0.26667],\n    \"107\": [0, 0.69444, 0, 0, 0.48889],\n    \"108\": [0, 0.69444, 0, 0, 0.23889],\n    \"109\": [0, 0.44444, 0, 0, 0.79445],\n    \"110\": [0, 0.44444, 0, 0, 0.51667],\n    \"111\": [0, 0.44444, 0, 0, 0.5],\n    \"112\": [0.19444, 0.44444, 0, 0, 0.51667],\n    \"113\": [0.19444, 0.44444, 0, 0, 0.51667],\n    \"114\": [0, 0.44444, 0.01389, 0, 0.34167],\n    \"115\": [0, 0.44444, 0, 0, 0.38333],\n    \"116\": [0, 0.57143, 0, 0, 0.36111],\n    \"117\": [0, 0.44444, 0, 0, 0.51667],\n    \"118\": [0, 0.44444, 0.01389, 0, 0.46111],\n    \"119\": [0, 0.44444, 0.01389, 0, 0.68334],\n    \"120\": [0, 0.44444, 0, 0, 0.46111],\n    \"121\": [0.19444, 0.44444, 0.01389, 0, 0.46111],\n    \"122\": [0, 0.44444, 0, 0, 0.43472],\n    \"126\": [0.35, 0.32659, 0, 0, 0.5],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"168\": [0, 0.67937, 0, 0, 0.5],\n    \"176\": [0, 0.69444, 0, 0, 0.66667],\n    \"184\": [0.17014, 0, 0, 0, 0.44445],\n    \"305\": [0, 0.44444, 0, 0, 0.23889],\n    \"567\": [0.19444, 0.44444, 0, 0, 0.26667],\n    \"710\": [0, 0.69444, 0, 0, 0.5],\n    \"711\": [0, 0.63194, 0, 0, 0.5],\n    \"713\": [0, 0.60889, 0, 0, 0.5],\n    \"714\": [0, 0.69444, 0, 0, 0.5],\n    \"715\": [0, 0.69444, 0, 0, 0.5],\n    \"728\": [0, 0.69444, 0, 0, 0.5],\n    \"729\": [0, 0.67937, 0, 0, 0.27778],\n    \"730\": [0, 0.69444, 0, 0, 0.66667],\n    \"732\": [0, 0.67659, 0, 0, 0.5],\n    \"733\": [0, 0.69444, 0, 0, 0.5],\n    \"915\": [0, 0.69444, 0, 0, 0.54167],\n    \"916\": [0, 0.69444, 0, 0, 0.83334],\n    \"920\": [0, 0.69444, 0, 0, 0.77778],\n    \"923\": [0, 0.69444, 0, 0, 0.61111],\n    \"926\": [0, 0.69444, 0, 0, 0.66667],\n    \"928\": [0, 0.69444, 0, 0, 0.70834],\n    \"931\": [0, 0.69444, 0, 0, 0.72222],\n    \"933\": [0, 0.69444, 0, 0, 0.77778],\n    \"934\": [0, 0.69444, 0, 0, 0.72222],\n    \"936\": [0, 0.69444, 0, 0, 0.77778],\n    \"937\": [0, 0.69444, 0, 0, 0.72222],\n    \"8211\": [0, 0.44444, 0.02778, 0, 0.5],\n    \"8212\": [0, 0.44444, 0.02778, 0, 1.0],\n    \"8216\": [0, 0.69444, 0, 0, 0.27778],\n    \"8217\": [0, 0.69444, 0, 0, 0.27778],\n    \"8220\": [0, 0.69444, 0, 0, 0.5],\n    \"8221\": [0, 0.69444, 0, 0, 0.5]\n  },\n  \"Script-Regular\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"65\": [0, 0.7, 0.22925, 0, 0.80253],\n    \"66\": [0, 0.7, 0.04087, 0, 0.90757],\n    \"67\": [0, 0.7, 0.1689, 0, 0.66619],\n    \"68\": [0, 0.7, 0.09371, 0, 0.77443],\n    \"69\": [0, 0.7, 0.18583, 0, 0.56162],\n    \"70\": [0, 0.7, 0.13634, 0, 0.89544],\n    \"71\": [0, 0.7, 0.17322, 0, 0.60961],\n    \"72\": [0, 0.7, 0.29694, 0, 0.96919],\n    \"73\": [0, 0.7, 0.19189, 0, 0.80907],\n    \"74\": [0.27778, 0.7, 0.19189, 0, 1.05159],\n    \"75\": [0, 0.7, 0.31259, 0, 0.91364],\n    \"76\": [0, 0.7, 0.19189, 0, 0.87373],\n    \"77\": [0, 0.7, 0.15981, 0, 1.08031],\n    \"78\": [0, 0.7, 0.3525, 0, 0.9015],\n    \"79\": [0, 0.7, 0.08078, 0, 0.73787],\n    \"80\": [0, 0.7, 0.08078, 0, 1.01262],\n    \"81\": [0, 0.7, 0.03305, 0, 0.88282],\n    \"82\": [0, 0.7, 0.06259, 0, 0.85],\n    \"83\": [0, 0.7, 0.19189, 0, 0.86767],\n    \"84\": [0, 0.7, 0.29087, 0, 0.74697],\n    \"85\": [0, 0.7, 0.25815, 0, 0.79996],\n    \"86\": [0, 0.7, 0.27523, 0, 0.62204],\n    \"87\": [0, 0.7, 0.27523, 0, 0.80532],\n    \"88\": [0, 0.7, 0.26006, 0, 0.94445],\n    \"89\": [0, 0.7, 0.2939, 0, 0.70961],\n    \"90\": [0, 0.7, 0.24037, 0, 0.8212],\n    \"160\": [0, 0, 0, 0, 0.25]\n  },\n  \"Size1-Regular\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"40\": [0.35001, 0.85, 0, 0, 0.45834],\n    \"41\": [0.35001, 0.85, 0, 0, 0.45834],\n    \"47\": [0.35001, 0.85, 0, 0, 0.57778],\n    \"91\": [0.35001, 0.85, 0, 0, 0.41667],\n    \"92\": [0.35001, 0.85, 0, 0, 0.57778],\n    \"93\": [0.35001, 0.85, 0, 0, 0.41667],\n    \"123\": [0.35001, 0.85, 0, 0, 0.58334],\n    \"125\": [0.35001, 0.85, 0, 0, 0.58334],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"710\": [0, 0.72222, 0, 0, 0.55556],\n    \"732\": [0, 0.72222, 0, 0, 0.55556],\n    \"770\": [0, 0.72222, 0, 0, 0.55556],\n    \"771\": [0, 0.72222, 0, 0, 0.55556],\n    \"8214\": [-0.00099, 0.601, 0, 0, 0.77778],\n    \"8593\": [1e-05, 0.6, 0, 0, 0.66667],\n    \"8595\": [1e-05, 0.6, 0, 0, 0.66667],\n    \"8657\": [1e-05, 0.6, 0, 0, 0.77778],\n    \"8659\": [1e-05, 0.6, 0, 0, 0.77778],\n    \"8719\": [0.25001, 0.75, 0, 0, 0.94445],\n    \"8720\": [0.25001, 0.75, 0, 0, 0.94445],\n    \"8721\": [0.25001, 0.75, 0, 0, 1.05556],\n    \"8730\": [0.35001, 0.85, 0, 0, 1.0],\n    \"8739\": [-0.00599, 0.606, 0, 0, 0.33333],\n    \"8741\": [-0.00599, 0.606, 0, 0, 0.55556],\n    \"8747\": [0.30612, 0.805, 0.19445, 0, 0.47222],\n    \"8748\": [0.306, 0.805, 0.19445, 0, 0.47222],\n    \"8749\": [0.306, 0.805, 0.19445, 0, 0.47222],\n    \"8750\": [0.30612, 0.805, 0.19445, 0, 0.47222],\n    \"8896\": [0.25001, 0.75, 0, 0, 0.83334],\n    \"8897\": [0.25001, 0.75, 0, 0, 0.83334],\n    \"8898\": [0.25001, 0.75, 0, 0, 0.83334],\n    \"8899\": [0.25001, 0.75, 0, 0, 0.83334],\n    \"8968\": [0.35001, 0.85, 0, 0, 0.47222],\n    \"8969\": [0.35001, 0.85, 0, 0, 0.47222],\n    \"8970\": [0.35001, 0.85, 0, 0, 0.47222],\n    \"8971\": [0.35001, 0.85, 0, 0, 0.47222],\n    \"9168\": [-0.00099, 0.601, 0, 0, 0.66667],\n    \"10216\": [0.35001, 0.85, 0, 0, 0.47222],\n    \"10217\": [0.35001, 0.85, 0, 0, 0.47222],\n    \"10752\": [0.25001, 0.75, 0, 0, 1.11111],\n    \"10753\": [0.25001, 0.75, 0, 0, 1.11111],\n    \"10754\": [0.25001, 0.75, 0, 0, 1.11111],\n    \"10756\": [0.25001, 0.75, 0, 0, 0.83334],\n    \"10758\": [0.25001, 0.75, 0, 0, 0.83334]\n  },\n  \"Size2-Regular\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"40\": [0.65002, 1.15, 0, 0, 0.59722],\n    \"41\": [0.65002, 1.15, 0, 0, 0.59722],\n    \"47\": [0.65002, 1.15, 0, 0, 0.81111],\n    \"91\": [0.65002, 1.15, 0, 0, 0.47222],\n    \"92\": [0.65002, 1.15, 0, 0, 0.81111],\n    \"93\": [0.65002, 1.15, 0, 0, 0.47222],\n    \"123\": [0.65002, 1.15, 0, 0, 0.66667],\n    \"125\": [0.65002, 1.15, 0, 0, 0.66667],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"710\": [0, 0.75, 0, 0, 1.0],\n    \"732\": [0, 0.75, 0, 0, 1.0],\n    \"770\": [0, 0.75, 0, 0, 1.0],\n    \"771\": [0, 0.75, 0, 0, 1.0],\n    \"8719\": [0.55001, 1.05, 0, 0, 1.27778],\n    \"8720\": [0.55001, 1.05, 0, 0, 1.27778],\n    \"8721\": [0.55001, 1.05, 0, 0, 1.44445],\n    \"8730\": [0.65002, 1.15, 0, 0, 1.0],\n    \"8747\": [0.86225, 1.36, 0.44445, 0, 0.55556],\n    \"8748\": [0.862, 1.36, 0.44445, 0, 0.55556],\n    \"8749\": [0.862, 1.36, 0.44445, 0, 0.55556],\n    \"8750\": [0.86225, 1.36, 0.44445, 0, 0.55556],\n    \"8896\": [0.55001, 1.05, 0, 0, 1.11111],\n    \"8897\": [0.55001, 1.05, 0, 0, 1.11111],\n    \"8898\": [0.55001, 1.05, 0, 0, 1.11111],\n    \"8899\": [0.55001, 1.05, 0, 0, 1.11111],\n    \"8968\": [0.65002, 1.15, 0, 0, 0.52778],\n    \"8969\": [0.65002, 1.15, 0, 0, 0.52778],\n    \"8970\": [0.65002, 1.15, 0, 0, 0.52778],\n    \"8971\": [0.65002, 1.15, 0, 0, 0.52778],\n    \"10216\": [0.65002, 1.15, 0, 0, 0.61111],\n    \"10217\": [0.65002, 1.15, 0, 0, 0.61111],\n    \"10752\": [0.55001, 1.05, 0, 0, 1.51112],\n    \"10753\": [0.55001, 1.05, 0, 0, 1.51112],\n    \"10754\": [0.55001, 1.05, 0, 0, 1.51112],\n    \"10756\": [0.55001, 1.05, 0, 0, 1.11111],\n    \"10758\": [0.55001, 1.05, 0, 0, 1.11111]\n  },\n  \"Size3-Regular\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"40\": [0.95003, 1.45, 0, 0, 0.73611],\n    \"41\": [0.95003, 1.45, 0, 0, 0.73611],\n    \"47\": [0.95003, 1.45, 0, 0, 1.04445],\n    \"91\": [0.95003, 1.45, 0, 0, 0.52778],\n    \"92\": [0.95003, 1.45, 0, 0, 1.04445],\n    \"93\": [0.95003, 1.45, 0, 0, 0.52778],\n    \"123\": [0.95003, 1.45, 0, 0, 0.75],\n    \"125\": [0.95003, 1.45, 0, 0, 0.75],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"710\": [0, 0.75, 0, 0, 1.44445],\n    \"732\": [0, 0.75, 0, 0, 1.44445],\n    \"770\": [0, 0.75, 0, 0, 1.44445],\n    \"771\": [0, 0.75, 0, 0, 1.44445],\n    \"8730\": [0.95003, 1.45, 0, 0, 1.0],\n    \"8968\": [0.95003, 1.45, 0, 0, 0.58334],\n    \"8969\": [0.95003, 1.45, 0, 0, 0.58334],\n    \"8970\": [0.95003, 1.45, 0, 0, 0.58334],\n    \"8971\": [0.95003, 1.45, 0, 0, 0.58334],\n    \"10216\": [0.95003, 1.45, 0, 0, 0.75],\n    \"10217\": [0.95003, 1.45, 0, 0, 0.75]\n  },\n  \"Size4-Regular\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"40\": [1.25003, 1.75, 0, 0, 0.79167],\n    \"41\": [1.25003, 1.75, 0, 0, 0.79167],\n    \"47\": [1.25003, 1.75, 0, 0, 1.27778],\n    \"91\": [1.25003, 1.75, 0, 0, 0.58334],\n    \"92\": [1.25003, 1.75, 0, 0, 1.27778],\n    \"93\": [1.25003, 1.75, 0, 0, 0.58334],\n    \"123\": [1.25003, 1.75, 0, 0, 0.80556],\n    \"125\": [1.25003, 1.75, 0, 0, 0.80556],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"710\": [0, 0.825, 0, 0, 1.8889],\n    \"732\": [0, 0.825, 0, 0, 1.8889],\n    \"770\": [0, 0.825, 0, 0, 1.8889],\n    \"771\": [0, 0.825, 0, 0, 1.8889],\n    \"8730\": [1.25003, 1.75, 0, 0, 1.0],\n    \"8968\": [1.25003, 1.75, 0, 0, 0.63889],\n    \"8969\": [1.25003, 1.75, 0, 0, 0.63889],\n    \"8970\": [1.25003, 1.75, 0, 0, 0.63889],\n    \"8971\": [1.25003, 1.75, 0, 0, 0.63889],\n    \"9115\": [0.64502, 1.155, 0, 0, 0.875],\n    \"9116\": [1e-05, 0.6, 0, 0, 0.875],\n    \"9117\": [0.64502, 1.155, 0, 0, 0.875],\n    \"9118\": [0.64502, 1.155, 0, 0, 0.875],\n    \"9119\": [1e-05, 0.6, 0, 0, 0.875],\n    \"9120\": [0.64502, 1.155, 0, 0, 0.875],\n    \"9121\": [0.64502, 1.155, 0, 0, 0.66667],\n    \"9122\": [-0.00099, 0.601, 0, 0, 0.66667],\n    \"9123\": [0.64502, 1.155, 0, 0, 0.66667],\n    \"9124\": [0.64502, 1.155, 0, 0, 0.66667],\n    \"9125\": [-0.00099, 0.601, 0, 0, 0.66667],\n    \"9126\": [0.64502, 1.155, 0, 0, 0.66667],\n    \"9127\": [1e-05, 0.9, 0, 0, 0.88889],\n    \"9128\": [0.65002, 1.15, 0, 0, 0.88889],\n    \"9129\": [0.90001, 0, 0, 0, 0.88889],\n    \"9130\": [0, 0.3, 0, 0, 0.88889],\n    \"9131\": [1e-05, 0.9, 0, 0, 0.88889],\n    \"9132\": [0.65002, 1.15, 0, 0, 0.88889],\n    \"9133\": [0.90001, 0, 0, 0, 0.88889],\n    \"9143\": [0.88502, 0.915, 0, 0, 1.05556],\n    \"10216\": [1.25003, 1.75, 0, 0, 0.80556],\n    \"10217\": [1.25003, 1.75, 0, 0, 0.80556],\n    \"57344\": [-0.00499, 0.605, 0, 0, 1.05556],\n    \"57345\": [-0.00499, 0.605, 0, 0, 1.05556],\n    \"57680\": [0, 0.12, 0, 0, 0.45],\n    \"57681\": [0, 0.12, 0, 0, 0.45],\n    \"57682\": [0, 0.12, 0, 0, 0.45],\n    \"57683\": [0, 0.12, 0, 0, 0.45]\n  },\n  \"Typewriter-Regular\": {\n    \"32\": [0, 0, 0, 0, 0.525],\n    \"33\": [0, 0.61111, 0, 0, 0.525],\n    \"34\": [0, 0.61111, 0, 0, 0.525],\n    \"35\": [0, 0.61111, 0, 0, 0.525],\n    \"36\": [0.08333, 0.69444, 0, 0, 0.525],\n    \"37\": [0.08333, 0.69444, 0, 0, 0.525],\n    \"38\": [0, 0.61111, 0, 0, 0.525],\n    \"39\": [0, 0.61111, 0, 0, 0.525],\n    \"40\": [0.08333, 0.69444, 0, 0, 0.525],\n    \"41\": [0.08333, 0.69444, 0, 0, 0.525],\n    \"42\": [0, 0.52083, 0, 0, 0.525],\n    \"43\": [-0.08056, 0.53055, 0, 0, 0.525],\n    \"44\": [0.13889, 0.125, 0, 0, 0.525],\n    \"45\": [-0.08056, 0.53055, 0, 0, 0.525],\n    \"46\": [0, 0.125, 0, 0, 0.525],\n    \"47\": [0.08333, 0.69444, 0, 0, 0.525],\n    \"48\": [0, 0.61111, 0, 0, 0.525],\n    \"49\": [0, 0.61111, 0, 0, 0.525],\n    \"50\": [0, 0.61111, 0, 0, 0.525],\n    \"51\": [0, 0.61111, 0, 0, 0.525],\n    \"52\": [0, 0.61111, 0, 0, 0.525],\n    \"53\": [0, 0.61111, 0, 0, 0.525],\n    \"54\": [0, 0.61111, 0, 0, 0.525],\n    \"55\": [0, 0.61111, 0, 0, 0.525],\n    \"56\": [0, 0.61111, 0, 0, 0.525],\n    \"57\": [0, 0.61111, 0, 0, 0.525],\n    \"58\": [0, 0.43056, 0, 0, 0.525],\n    \"59\": [0.13889, 0.43056, 0, 0, 0.525],\n    \"60\": [-0.05556, 0.55556, 0, 0, 0.525],\n    \"61\": [-0.19549, 0.41562, 0, 0, 0.525],\n    \"62\": [-0.05556, 0.55556, 0, 0, 0.525],\n    \"63\": [0, 0.61111, 0, 0, 0.525],\n    \"64\": [0, 0.61111, 0, 0, 0.525],\n    \"65\": [0, 0.61111, 0, 0, 0.525],\n    \"66\": [0, 0.61111, 0, 0, 0.525],\n    \"67\": [0, 0.61111, 0, 0, 0.525],\n    \"68\": [0, 0.61111, 0, 0, 0.525],\n    \"69\": [0, 0.61111, 0, 0, 0.525],\n    \"70\": [0, 0.61111, 0, 0, 0.525],\n    \"71\": [0, 0.61111, 0, 0, 0.525],\n    \"72\": [0, 0.61111, 0, 0, 0.525],\n    \"73\": [0, 0.61111, 0, 0, 0.525],\n    \"74\": [0, 0.61111, 0, 0, 0.525],\n    \"75\": [0, 0.61111, 0, 0, 0.525],\n    \"76\": [0, 0.61111, 0, 0, 0.525],\n    \"77\": [0, 0.61111, 0, 0, 0.525],\n    \"78\": [0, 0.61111, 0, 0, 0.525],\n    \"79\": [0, 0.61111, 0, 0, 0.525],\n    \"80\": [0, 0.61111, 0, 0, 0.525],\n    \"81\": [0.13889, 0.61111, 0, 0, 0.525],\n    \"82\": [0, 0.61111, 0, 0, 0.525],\n    \"83\": [0, 0.61111, 0, 0, 0.525],\n    \"84\": [0, 0.61111, 0, 0, 0.525],\n    \"85\": [0, 0.61111, 0, 0, 0.525],\n    \"86\": [0, 0.61111, 0, 0, 0.525],\n    \"87\": [0, 0.61111, 0, 0, 0.525],\n    \"88\": [0, 0.61111, 0, 0, 0.525],\n    \"89\": [0, 0.61111, 0, 0, 0.525],\n    \"90\": [0, 0.61111, 0, 0, 0.525],\n    \"91\": [0.08333, 0.69444, 0, 0, 0.525],\n    \"92\": [0.08333, 0.69444, 0, 0, 0.525],\n    \"93\": [0.08333, 0.69444, 0, 0, 0.525],\n    \"94\": [0, 0.61111, 0, 0, 0.525],\n    \"95\": [0.09514, 0, 0, 0, 0.525],\n    \"96\": [0, 0.61111, 0, 0, 0.525],\n    \"97\": [0, 0.43056, 0, 0, 0.525],\n    \"98\": [0, 0.61111, 0, 0, 0.525],\n    \"99\": [0, 0.43056, 0, 0, 0.525],\n    \"100\": [0, 0.61111, 0, 0, 0.525],\n    \"101\": [0, 0.43056, 0, 0, 0.525],\n    \"102\": [0, 0.61111, 0, 0, 0.525],\n    \"103\": [0.22222, 0.43056, 0, 0, 0.525],\n    \"104\": [0, 0.61111, 0, 0, 0.525],\n    \"105\": [0, 0.61111, 0, 0, 0.525],\n    \"106\": [0.22222, 0.61111, 0, 0, 0.525],\n    \"107\": [0, 0.61111, 0, 0, 0.525],\n    \"108\": [0, 0.61111, 0, 0, 0.525],\n    \"109\": [0, 0.43056, 0, 0, 0.525],\n    \"110\": [0, 0.43056, 0, 0, 0.525],\n    \"111\": [0, 0.43056, 0, 0, 0.525],\n    \"112\": [0.22222, 0.43056, 0, 0, 0.525],\n    \"113\": [0.22222, 0.43056, 0, 0, 0.525],\n    \"114\": [0, 0.43056, 0, 0, 0.525],\n    \"115\": [0, 0.43056, 0, 0, 0.525],\n    \"116\": [0, 0.55358, 0, 0, 0.525],\n    \"117\": [0, 0.43056, 0, 0, 0.525],\n    \"118\": [0, 0.43056, 0, 0, 0.525],\n    \"119\": [0, 0.43056, 0, 0, 0.525],\n    \"120\": [0, 0.43056, 0, 0, 0.525],\n    \"121\": [0.22222, 0.43056, 0, 0, 0.525],\n    \"122\": [0, 0.43056, 0, 0, 0.525],\n    \"123\": [0.08333, 0.69444, 0, 0, 0.525],\n    \"124\": [0.08333, 0.69444, 0, 0, 0.525],\n    \"125\": [0.08333, 0.69444, 0, 0, 0.525],\n    \"126\": [0, 0.61111, 0, 0, 0.525],\n    \"127\": [0, 0.61111, 0, 0, 0.525],\n    \"160\": [0, 0, 0, 0, 0.525],\n    \"176\": [0, 0.61111, 0, 0, 0.525],\n    \"184\": [0.19445, 0, 0, 0, 0.525],\n    \"305\": [0, 0.43056, 0, 0, 0.525],\n    \"567\": [0.22222, 0.43056, 0, 0, 0.525],\n    \"711\": [0, 0.56597, 0, 0, 0.525],\n    \"713\": [0, 0.56555, 0, 0, 0.525],\n    \"714\": [0, 0.61111, 0, 0, 0.525],\n    \"715\": [0, 0.61111, 0, 0, 0.525],\n    \"728\": [0, 0.61111, 0, 0, 0.525],\n    \"730\": [0, 0.61111, 0, 0, 0.525],\n    \"770\": [0, 0.61111, 0, 0, 0.525],\n    \"771\": [0, 0.61111, 0, 0, 0.525],\n    \"776\": [0, 0.61111, 0, 0, 0.525],\n    \"915\": [0, 0.61111, 0, 0, 0.525],\n    \"916\": [0, 0.61111, 0, 0, 0.525],\n    \"920\": [0, 0.61111, 0, 0, 0.525],\n    \"923\": [0, 0.61111, 0, 0, 0.525],\n    \"926\": [0, 0.61111, 0, 0, 0.525],\n    \"928\": [0, 0.61111, 0, 0, 0.525],\n    \"931\": [0, 0.61111, 0, 0, 0.525],\n    \"933\": [0, 0.61111, 0, 0, 0.525],\n    \"934\": [0, 0.61111, 0, 0, 0.525],\n    \"936\": [0, 0.61111, 0, 0, 0.525],\n    \"937\": [0, 0.61111, 0, 0, 0.525],\n    \"8216\": [0, 0.61111, 0, 0, 0.525],\n    \"8217\": [0, 0.61111, 0, 0, 0.525],\n    \"8242\": [0, 0.61111, 0, 0, 0.525],\n    \"9251\": [0.11111, 0.21944, 0, 0, 0.525]\n  }\n});\n;// CONCATENATED MODULE: ./src/fontMetrics.js\n\n\n/**\n * This file contains metrics regarding fonts and individual symbols. The sigma\n * and xi variables, as well as the metricMap map contain data extracted from\n * TeX, TeX font metrics, and the TTF files. These data are then exposed via the\n * `metrics` variable and the getCharacterMetrics function.\n */\n// In TeX, there are actually three sets of dimensions, one for each of\n// textstyle (size index 5 and higher: >=9pt), scriptstyle (size index 3 and 4:\n// 7-8pt), and scriptscriptstyle (size index 1 and 2: 5-6pt).  These are\n// provided in the arrays below, in that order.\n//\n// The font metrics are stored in fonts cmsy10, cmsy7, and cmsy5 respectively.\n// This was determined by running the following script:\n//\n//     latex -interaction=nonstopmode \\\n//     '\\documentclass{article}\\usepackage{amsmath}\\begin{document}' \\\n//     '$a$ \\expandafter\\show\\the\\textfont2' \\\n//     '\\expandafter\\show\\the\\scriptfont2' \\\n//     '\\expandafter\\show\\the\\scriptscriptfont2' \\\n//     '\\stop'\n//\n// The metrics themselves were retrieved using the following commands:\n//\n//     tftopl cmsy10\n//     tftopl cmsy7\n//     tftopl cmsy5\n//\n// The output of each of these commands is quite lengthy.  The only part we\n// care about is the FONTDIMEN section. Each value is measured in EMs.\nconst sigmasAndXis = {\n  slant: [0.250, 0.250, 0.250],\n  // sigma1\n  space: [0.000, 0.000, 0.000],\n  // sigma2\n  stretch: [0.000, 0.000, 0.000],\n  // sigma3\n  shrink: [0.000, 0.000, 0.000],\n  // sigma4\n  xHeight: [0.431, 0.431, 0.431],\n  // sigma5\n  quad: [1.000, 1.171, 1.472],\n  // sigma6\n  extraSpace: [0.000, 0.000, 0.000],\n  // sigma7\n  num1: [0.677, 0.732, 0.925],\n  // sigma8\n  num2: [0.394, 0.384, 0.387],\n  // sigma9\n  num3: [0.444, 0.471, 0.504],\n  // sigma10\n  denom1: [0.686, 0.752, 1.025],\n  // sigma11\n  denom2: [0.345, 0.344, 0.532],\n  // sigma12\n  sup1: [0.413, 0.503, 0.504],\n  // sigma13\n  sup2: [0.363, 0.431, 0.404],\n  // sigma14\n  sup3: [0.289, 0.286, 0.294],\n  // sigma15\n  sub1: [0.150, 0.143, 0.200],\n  // sigma16\n  sub2: [0.247, 0.286, 0.400],\n  // sigma17\n  supDrop: [0.386, 0.353, 0.494],\n  // sigma18\n  subDrop: [0.050, 0.071, 0.100],\n  // sigma19\n  delim1: [2.390, 1.700, 1.980],\n  // sigma20\n  delim2: [1.010, 1.157, 1.420],\n  // sigma21\n  axisHeight: [0.250, 0.250, 0.250],\n  // sigma22\n  // These font metrics are extracted from TeX by using tftopl on cmex10.tfm;\n  // they correspond to the font parameters of the extension fonts (family 3).\n  // See the TeXbook, page 441. In AMSTeX, the extension fonts scale; to\n  // match cmex7, we'd use cmex7.tfm values for script and scriptscript\n  // values.\n  defaultRuleThickness: [0.04, 0.049, 0.049],\n  // xi8; cmex7: 0.049\n  bigOpSpacing1: [0.111, 0.111, 0.111],\n  // xi9\n  bigOpSpacing2: [0.166, 0.166, 0.166],\n  // xi10\n  bigOpSpacing3: [0.2, 0.2, 0.2],\n  // xi11\n  bigOpSpacing4: [0.6, 0.611, 0.611],\n  // xi12; cmex7: 0.611\n  bigOpSpacing5: [0.1, 0.143, 0.143],\n  // xi13; cmex7: 0.143\n  // The \\sqrt rule width is taken from the height of the surd character.\n  // Since we use the same font at all sizes, this thickness doesn't scale.\n  sqrtRuleThickness: [0.04, 0.04, 0.04],\n  // This value determines how large a pt is, for metrics which are defined\n  // in terms of pts.\n  // This value is also used in katex.scss; if you change it make sure the\n  // values match.\n  ptPerEm: [10.0, 10.0, 10.0],\n  // The space between adjacent `|` columns in an array definition. From\n  // `\\showthe\\doublerulesep` in LaTeX. Equals 2.0 / ptPerEm.\n  doubleRuleSep: [0.2, 0.2, 0.2],\n  // The width of separator lines in {array} environments. From\n  // `\\showthe\\arrayrulewidth` in LaTeX. Equals 0.4 / ptPerEm.\n  arrayRuleWidth: [0.04, 0.04, 0.04],\n  // Two values from LaTeX source2e:\n  fboxsep: [0.3, 0.3, 0.3],\n  //        3 pt / ptPerEm\n  fboxrule: [0.04, 0.04, 0.04] // 0.4 pt / ptPerEm\n\n}; // This map contains a mapping from font name and character code to character\n// metrics, including height, depth, italic correction, and skew (kern from the\n// character to the corresponding \\skewchar)\n// This map is generated via `make metrics`. It should not be changed manually.\n\n // These are very rough approximations.  We default to Times New Roman which\n// should have Latin-1 and Cyrillic characters, but may not depending on the\n// operating system.  The metrics do not account for extra height from the\n// accents.  In the case of Cyrillic characters which have both ascenders and\n// descenders we prefer approximations with ascenders, primarily to prevent\n// the fraction bar or root line from intersecting the glyph.\n// TODO(kevinb) allow union of multiple glyph metrics for better accuracy.\n\nconst extraCharacterMap = {\n  // Latin-1\n  '': 'A',\n  '': 'D',\n  '': 'o',\n  '': 'a',\n  '': 'd',\n  '': 'o',\n  // Cyrillic\n  '': 'A',\n  '': 'B',\n  '': 'B',\n  '': 'F',\n  '': 'A',\n  '': 'E',\n  '': 'K',\n  '': '3',\n  '': 'N',\n  '': 'N',\n  '': 'K',\n  '': 'N',\n  '': 'M',\n  '': 'H',\n  '': 'O',\n  '': 'N',\n  '': 'P',\n  '': 'C',\n  '': 'T',\n  '': 'y',\n  '': 'O',\n  '': 'X',\n  '': 'U',\n  '': 'h',\n  '': 'W',\n  '': 'W',\n  '': 'B',\n  '': 'X',\n  '': 'B',\n  '': '3',\n  '': 'X',\n  '': 'R',\n  '': 'a',\n  '': 'b',\n  '': 'a',\n  '': 'r',\n  '': 'y',\n  '': 'e',\n  '': 'm',\n  '': 'e',\n  '': 'n',\n  '': 'n',\n  '': 'n',\n  '': 'n',\n  '': 'm',\n  '': 'n',\n  '': 'o',\n  '': 'n',\n  '': 'p',\n  '': 'c',\n  '': 'o',\n  '': 'y',\n  '': 'b',\n  '': 'x',\n  '': 'n',\n  '': 'n',\n  '': 'w',\n  '': 'w',\n  '': 'a',\n  '': 'm',\n  '': 'a',\n  '': 'e',\n  '': 'm',\n  '': 'r'\n};\n\n/**\n * This function adds new font metrics to default metricMap\n * It can also override existing metrics\n */\nfunction setFontMetrics(fontName, metrics) {\n  fontMetricsData[fontName] = metrics;\n}\n/**\n * This function is a convenience function for looking up information in the\n * metricMap table. It takes a character as a string, and a font.\n *\n * Note: the `width` property may be undefined if fontMetricsData.js wasn't\n * built using `Make extended_metrics`.\n */\n\nfunction getCharacterMetrics(character, font, mode) {\n  if (!fontMetricsData[font]) {\n    throw new Error(\"Font metrics not found for font: \" + font + \".\");\n  }\n\n  let ch = character.charCodeAt(0);\n  let metrics = fontMetricsData[font][ch];\n\n  if (!metrics && character[0] in extraCharacterMap) {\n    ch = extraCharacterMap[character[0]].charCodeAt(0);\n    metrics = fontMetricsData[font][ch];\n  }\n\n  if (!metrics && mode === 'text') {\n    // We don't typically have font metrics for Asian scripts.\n    // But since we support them in text mode, we need to return\n    // some sort of metrics.\n    // So if the character is in a script we support but we\n    // don't have metrics for it, just use the metrics for\n    // the Latin capital letter M. This is close enough because\n    // we (currently) only care about the height of the glyph\n    // not its width.\n    if (supportedCodepoint(ch)) {\n      metrics = fontMetricsData[font][77]; // 77 is the charcode for 'M'\n    }\n  }\n\n  if (metrics) {\n    return {\n      depth: metrics[0],\n      height: metrics[1],\n      italic: metrics[2],\n      skew: metrics[3],\n      width: metrics[4]\n    };\n  }\n}\nconst fontMetricsBySizeIndex = {};\n/**\n * Get the font metrics for a given size.\n */\n\nfunction getGlobalMetrics(size) {\n  let sizeIndex;\n\n  if (size >= 5) {\n    sizeIndex = 0;\n  } else if (size >= 3) {\n    sizeIndex = 1;\n  } else {\n    sizeIndex = 2;\n  }\n\n  if (!fontMetricsBySizeIndex[sizeIndex]) {\n    const metrics = fontMetricsBySizeIndex[sizeIndex] = {\n      cssEmPerMu: sigmasAndXis.quad[sizeIndex] / 18\n    };\n\n    for (const key in sigmasAndXis) {\n      if (sigmasAndXis.hasOwnProperty(key)) {\n        metrics[key] = sigmasAndXis[key][sizeIndex];\n      }\n    }\n  }\n\n  return fontMetricsBySizeIndex[sizeIndex];\n}\n;// CONCATENATED MODULE: ./src/Options.js\n/**\n * This file contains information about the options that the Parser carries\n * around with it while parsing. Data is held in an `Options` object, and when\n * recursing, a new `Options` object can be created with the `.with*` and\n * `.reset` functions.\n */\n\nconst sizeStyleMap = [// Each element contains [textsize, scriptsize, scriptscriptsize].\n// The size mappings are taken from TeX with \\normalsize=10pt.\n[1, 1, 1], // size1: [5, 5, 5]              \\tiny\n[2, 1, 1], // size2: [6, 5, 5]\n[3, 1, 1], // size3: [7, 5, 5]              \\scriptsize\n[4, 2, 1], // size4: [8, 6, 5]              \\footnotesize\n[5, 2, 1], // size5: [9, 6, 5]              \\small\n[6, 3, 1], // size6: [10, 7, 5]             \\normalsize\n[7, 4, 2], // size7: [12, 8, 6]             \\large\n[8, 6, 3], // size8: [14.4, 10, 7]          \\Large\n[9, 7, 6], // size9: [17.28, 12, 10]        \\LARGE\n[10, 8, 7], // size10: [20.74, 14.4, 12]     \\huge\n[11, 10, 9] // size11: [24.88, 20.74, 17.28] \\HUGE\n];\nconst sizeMultipliers = [// fontMetrics.js:getGlobalMetrics also uses size indexes, so if\n// you change size indexes, change that function.\n0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.2, 1.44, 1.728, 2.074, 2.488];\n\nconst sizeAtStyle = function (size, style) {\n  return style.size < 2 ? size : sizeStyleMap[size - 1][style.size - 1];\n}; // In these types, \"\" (empty string) means \"no change\".\n\n\n/**\n * This is the main options class. It contains the current style, size, color,\n * and font.\n *\n * Options objects should not be modified. To create a new Options with\n * different properties, call a `.having*` method.\n */\nclass Options {\n  // A font family applies to a group of fonts (i.e. SansSerif), while a font\n  // represents a specific font (i.e. SansSerif Bold).\n  // See: https://tex.stackexchange.com/questions/22350/difference-between-textrm-and-mathrm\n\n  /**\n   * The base size index.\n   */\n  constructor(data) {\n    this.style = void 0;\n    this.color = void 0;\n    this.size = void 0;\n    this.textSize = void 0;\n    this.phantom = void 0;\n    this.font = void 0;\n    this.fontFamily = void 0;\n    this.fontWeight = void 0;\n    this.fontShape = void 0;\n    this.sizeMultiplier = void 0;\n    this.maxSize = void 0;\n    this.minRuleThickness = void 0;\n    this._fontMetrics = void 0;\n    this.style = data.style;\n    this.color = data.color;\n    this.size = data.size || Options.BASESIZE;\n    this.textSize = data.textSize || this.size;\n    this.phantom = !!data.phantom;\n    this.font = data.font || \"\";\n    this.fontFamily = data.fontFamily || \"\";\n    this.fontWeight = data.fontWeight || '';\n    this.fontShape = data.fontShape || '';\n    this.sizeMultiplier = sizeMultipliers[this.size - 1];\n    this.maxSize = data.maxSize;\n    this.minRuleThickness = data.minRuleThickness;\n    this._fontMetrics = undefined;\n  }\n  /**\n   * Returns a new options object with the same properties as \"this\".  Properties\n   * from \"extension\" will be copied to the new options object.\n   */\n\n\n  extend(extension) {\n    const data = {\n      style: this.style,\n      size: this.size,\n      textSize: this.textSize,\n      color: this.color,\n      phantom: this.phantom,\n      font: this.font,\n      fontFamily: this.fontFamily,\n      fontWeight: this.fontWeight,\n      fontShape: this.fontShape,\n      maxSize: this.maxSize,\n      minRuleThickness: this.minRuleThickness\n    };\n\n    for (const key in extension) {\n      if (extension.hasOwnProperty(key)) {\n        data[key] = extension[key];\n      }\n    }\n\n    return new Options(data);\n  }\n  /**\n   * Return an options object with the given style. If `this.style === style`,\n   * returns `this`.\n   */\n\n\n  havingStyle(style) {\n    if (this.style === style) {\n      return this;\n    } else {\n      return this.extend({\n        style: style,\n        size: sizeAtStyle(this.textSize, style)\n      });\n    }\n  }\n  /**\n   * Return an options object with a cramped version of the current style. If\n   * the current style is cramped, returns `this`.\n   */\n\n\n  havingCrampedStyle() {\n    return this.havingStyle(this.style.cramp());\n  }\n  /**\n   * Return an options object with the given size and in at least `\\textstyle`.\n   * Returns `this` if appropriate.\n   */\n\n\n  havingSize(size) {\n    if (this.size === size && this.textSize === size) {\n      return this;\n    } else {\n      return this.extend({\n        style: this.style.text(),\n        size: size,\n        textSize: size,\n        sizeMultiplier: sizeMultipliers[size - 1]\n      });\n    }\n  }\n  /**\n   * Like `this.havingSize(BASESIZE).havingStyle(style)`. If `style` is omitted,\n   * changes to at least `\\textstyle`.\n   */\n\n\n  havingBaseStyle(style) {\n    style = style || this.style.text();\n    const wantSize = sizeAtStyle(Options.BASESIZE, style);\n\n    if (this.size === wantSize && this.textSize === Options.BASESIZE && this.style === style) {\n      return this;\n    } else {\n      return this.extend({\n        style: style,\n        size: wantSize\n      });\n    }\n  }\n  /**\n   * Remove the effect of sizing changes such as \\Huge.\n   * Keep the effect of the current style, such as \\scriptstyle.\n   */\n\n\n  havingBaseSizing() {\n    let size;\n\n    switch (this.style.id) {\n      case 4:\n      case 5:\n        size = 3; // normalsize in scriptstyle\n\n        break;\n\n      case 6:\n      case 7:\n        size = 1; // normalsize in scriptscriptstyle\n\n        break;\n\n      default:\n        size = 6;\n      // normalsize in textstyle or displaystyle\n    }\n\n    return this.extend({\n      style: this.style.text(),\n      size: size\n    });\n  }\n  /**\n   * Create a new options object with the given color.\n   */\n\n\n  withColor(color) {\n    return this.extend({\n      color: color\n    });\n  }\n  /**\n   * Create a new options object with \"phantom\" set to true.\n   */\n\n\n  withPhantom() {\n    return this.extend({\n      phantom: true\n    });\n  }\n  /**\n   * Creates a new options object with the given math font or old text font.\n   * @type {[type]}\n   */\n\n\n  withFont(font) {\n    return this.extend({\n      font\n    });\n  }\n  /**\n   * Create a new options objects with the given fontFamily.\n   */\n\n\n  withTextFontFamily(fontFamily) {\n    return this.extend({\n      fontFamily,\n      font: \"\"\n    });\n  }\n  /**\n   * Creates a new options object with the given font weight\n   */\n\n\n  withTextFontWeight(fontWeight) {\n    return this.extend({\n      fontWeight,\n      font: \"\"\n    });\n  }\n  /**\n   * Creates a new options object with the given font weight\n   */\n\n\n  withTextFontShape(fontShape) {\n    return this.extend({\n      fontShape,\n      font: \"\"\n    });\n  }\n  /**\n   * Return the CSS sizing classes required to switch from enclosing options\n   * `oldOptions` to `this`. Returns an array of classes.\n   */\n\n\n  sizingClasses(oldOptions) {\n    if (oldOptions.size !== this.size) {\n      return [\"sizing\", \"reset-size\" + oldOptions.size, \"size\" + this.size];\n    } else {\n      return [];\n    }\n  }\n  /**\n   * Return the CSS sizing classes required to switch to the base size. Like\n   * `this.havingSize(BASESIZE).sizingClasses(this)`.\n   */\n\n\n  baseSizingClasses() {\n    if (this.size !== Options.BASESIZE) {\n      return [\"sizing\", \"reset-size\" + this.size, \"size\" + Options.BASESIZE];\n    } else {\n      return [];\n    }\n  }\n  /**\n   * Return the font metrics for this size.\n   */\n\n\n  fontMetrics() {\n    if (!this._fontMetrics) {\n      this._fontMetrics = getGlobalMetrics(this.size);\n    }\n\n    return this._fontMetrics;\n  }\n  /**\n   * Gets the CSS color of the current options object\n   */\n\n\n  getColor() {\n    if (this.phantom) {\n      return \"transparent\";\n    } else {\n      return this.color;\n    }\n  }\n\n}\n\nOptions.BASESIZE = 6;\n/* harmony default export */ var src_Options = (Options);\n;// CONCATENATED MODULE: ./src/units.js\n/**\n * This file does conversion between units.  In particular, it provides\n * calculateSize to convert other units into ems.\n */\n\n // This table gives the number of TeX pts in one of each *absolute* TeX unit.\n// Thus, multiplying a length by this number converts the length from units\n// into pts.  Dividing the result by ptPerEm gives the number of ems\n// *assuming* a font size of ptPerEm (normal size, normal style).\n\nconst ptPerUnit = {\n  // https://en.wikibooks.org/wiki/LaTeX/Lengths and\n  // https://tex.stackexchange.com/a/8263\n  \"pt\": 1,\n  // TeX point\n  \"mm\": 7227 / 2540,\n  // millimeter\n  \"cm\": 7227 / 254,\n  // centimeter\n  \"in\": 72.27,\n  // inch\n  \"bp\": 803 / 800,\n  // big (PostScript) points\n  \"pc\": 12,\n  // pica\n  \"dd\": 1238 / 1157,\n  // didot\n  \"cc\": 14856 / 1157,\n  // cicero (12 didot)\n  \"nd\": 685 / 642,\n  // new didot\n  \"nc\": 1370 / 107,\n  // new cicero (12 new didot)\n  \"sp\": 1 / 65536,\n  // scaled point (TeX's internal smallest unit)\n  // https://tex.stackexchange.com/a/41371\n  \"px\": 803 / 800 // \\pdfpxdimen defaults to 1 bp in pdfTeX and LuaTeX\n\n}; // Dictionary of relative units, for fast validity testing.\n\nconst relativeUnit = {\n  \"ex\": true,\n  \"em\": true,\n  \"mu\": true\n};\n\n/**\n * Determine whether the specified unit (either a string defining the unit\n * or a \"size\" parse node containing a unit field) is valid.\n */\nconst validUnit = function (unit) {\n  if (typeof unit !== \"string\") {\n    unit = unit.unit;\n  }\n\n  return unit in ptPerUnit || unit in relativeUnit || unit === \"ex\";\n};\n/*\n * Convert a \"size\" parse node (with numeric \"number\" and string \"unit\" fields,\n * as parsed by functions.js argType \"size\") into a CSS em value for the\n * current style/scale.  `options` gives the current options.\n */\n\nconst calculateSize = function (sizeValue, options) {\n  let scale;\n\n  if (sizeValue.unit in ptPerUnit) {\n    // Absolute units\n    scale = ptPerUnit[sizeValue.unit] // Convert unit to pt\n    / options.fontMetrics().ptPerEm // Convert pt to CSS em\n    / options.sizeMultiplier; // Unscale to make absolute units\n  } else if (sizeValue.unit === \"mu\") {\n    // `mu` units scale with scriptstyle/scriptscriptstyle.\n    scale = options.fontMetrics().cssEmPerMu;\n  } else {\n    // Other relative units always refer to the *textstyle* font\n    // in the current size.\n    let unitOptions;\n\n    if (options.style.isTight()) {\n      // isTight() means current style is script/scriptscript.\n      unitOptions = options.havingStyle(options.style.text());\n    } else {\n      unitOptions = options;\n    } // TODO: In TeX these units are relative to the quad of the current\n    // *text* font, e.g. cmr10. KaTeX instead uses values from the\n    // comparably-sized *Computer Modern symbol* font. At 10pt, these\n    // match. At 7pt and 5pt, they differ: cmr7=1.138894, cmsy7=1.170641;\n    // cmr5=1.361133, cmsy5=1.472241. Consider $\\scriptsize a\\kern1emb$.\n    // TeX \\showlists shows a kern of 1.13889 * fontsize;\n    // KaTeX shows a kern of 1.171 * fontsize.\n\n\n    if (sizeValue.unit === \"ex\") {\n      scale = unitOptions.fontMetrics().xHeight;\n    } else if (sizeValue.unit === \"em\") {\n      scale = unitOptions.fontMetrics().quad;\n    } else {\n      throw new src_ParseError(\"Invalid unit: '\" + sizeValue.unit + \"'\");\n    }\n\n    if (unitOptions !== options) {\n      scale *= unitOptions.sizeMultiplier / options.sizeMultiplier;\n    }\n  }\n\n  return Math.min(sizeValue.number * scale, options.maxSize);\n};\n/**\n * Round `n` to 4 decimal places, or to the nearest 1/10,000th em. See\n * https://github.com/KaTeX/KaTeX/pull/2460.\n */\n\nconst makeEm = function (n) {\n  return +n.toFixed(4) + \"em\";\n};\n;// CONCATENATED MODULE: ./src/domTree.js\n/**\n * These objects store the data about the DOM nodes we create, as well as some\n * extra data. They can then be transformed into real DOM nodes with the\n * `toNode` function or HTML markup using `toMarkup`. They are useful for both\n * storing extra properties on the nodes, as well as providing a way to easily\n * work with the DOM.\n *\n * Similar functions for working with MathML nodes exist in mathMLTree.js.\n *\n * TODO: refactor `span` and `anchor` into common superclass when\n * target environments support class inheritance\n */\n\n\n\n\n\n\n/**\n * Create an HTML className based on a list of classes. In addition to joining\n * with spaces, we also remove empty classes.\n */\nconst createClass = function (classes) {\n  return classes.filter(cls => cls).join(\" \");\n};\n\nconst initNode = function (classes, options, style) {\n  this.classes = classes || [];\n  this.attributes = {};\n  this.height = 0;\n  this.depth = 0;\n  this.maxFontSize = 0;\n  this.style = style || {};\n\n  if (options) {\n    if (options.style.isTight()) {\n      this.classes.push(\"mtight\");\n    }\n\n    const color = options.getColor();\n\n    if (color) {\n      this.style.color = color;\n    }\n  }\n};\n/**\n * Convert into an HTML node\n */\n\n\nconst toNode = function (tagName) {\n  const node = document.createElement(tagName); // Apply the class\n\n  node.className = createClass(this.classes); // Apply inline styles\n\n  for (const style in this.style) {\n    if (this.style.hasOwnProperty(style)) {\n      // $FlowFixMe Flow doesn't seem to understand span.style's type.\n      node.style[style] = this.style[style];\n    }\n  } // Apply attributes\n\n\n  for (const attr in this.attributes) {\n    if (this.attributes.hasOwnProperty(attr)) {\n      node.setAttribute(attr, this.attributes[attr]);\n    }\n  } // Append the children, also as HTML nodes\n\n\n  for (let i = 0; i < this.children.length; i++) {\n    node.appendChild(this.children[i].toNode());\n  }\n\n  return node;\n};\n/**\n * Convert into an HTML markup string\n */\n\n\nconst toMarkup = function (tagName) {\n  let markup = \"<\" + tagName; // Add the class\n\n  if (this.classes.length) {\n    markup += \" class=\\\"\" + utils.escape(createClass(this.classes)) + \"\\\"\";\n  }\n\n  let styles = \"\"; // Add the styles, after hyphenation\n\n  for (const style in this.style) {\n    if (this.style.hasOwnProperty(style)) {\n      styles += utils.hyphenate(style) + \":\" + this.style[style] + \";\";\n    }\n  }\n\n  if (styles) {\n    markup += \" style=\\\"\" + utils.escape(styles) + \"\\\"\";\n  } // Add the attributes\n\n\n  for (const attr in this.attributes) {\n    if (this.attributes.hasOwnProperty(attr)) {\n      markup += \" \" + attr + \"=\\\"\" + utils.escape(this.attributes[attr]) + \"\\\"\";\n    }\n  }\n\n  markup += \">\"; // Add the markup of the children, also as markup\n\n  for (let i = 0; i < this.children.length; i++) {\n    markup += this.children[i].toMarkup();\n  }\n\n  markup += \"</\" + tagName + \">\";\n  return markup;\n}; // Making the type below exact with all optional fields doesn't work due to\n// - https://github.com/facebook/flow/issues/4582\n// - https://github.com/facebook/flow/issues/5688\n// However, since *all* fields are optional, $Shape<> works as suggested in 5688\n// above.\n// This type does not include all CSS properties. Additional properties should\n// be added as needed.\n\n\n/**\n * This node represents a span node, with a className, a list of children, and\n * an inline style. It also contains information about its height, depth, and\n * maxFontSize.\n *\n * Represents two types with different uses: SvgSpan to wrap an SVG and DomSpan\n * otherwise. This typesafety is important when HTML builders access a span's\n * children.\n */\nclass Span {\n  constructor(classes, children, options, style) {\n    this.children = void 0;\n    this.attributes = void 0;\n    this.classes = void 0;\n    this.height = void 0;\n    this.depth = void 0;\n    this.width = void 0;\n    this.maxFontSize = void 0;\n    this.style = void 0;\n    initNode.call(this, classes, options, style);\n    this.children = children || [];\n  }\n  /**\n   * Sets an arbitrary attribute on the span. Warning: use this wisely. Not\n   * all browsers support attributes the same, and having too many custom\n   * attributes is probably bad.\n   */\n\n\n  setAttribute(attribute, value) {\n    this.attributes[attribute] = value;\n  }\n\n  hasClass(className) {\n    return utils.contains(this.classes, className);\n  }\n\n  toNode() {\n    return toNode.call(this, \"span\");\n  }\n\n  toMarkup() {\n    return toMarkup.call(this, \"span\");\n  }\n\n}\n/**\n * This node represents an anchor (<a>) element with a hyperlink.  See `span`\n * for further details.\n */\n\nclass Anchor {\n  constructor(href, classes, children, options) {\n    this.children = void 0;\n    this.attributes = void 0;\n    this.classes = void 0;\n    this.height = void 0;\n    this.depth = void 0;\n    this.maxFontSize = void 0;\n    this.style = void 0;\n    initNode.call(this, classes, options);\n    this.children = children || [];\n    this.setAttribute('href', href);\n  }\n\n  setAttribute(attribute, value) {\n    this.attributes[attribute] = value;\n  }\n\n  hasClass(className) {\n    return utils.contains(this.classes, className);\n  }\n\n  toNode() {\n    return toNode.call(this, \"a\");\n  }\n\n  toMarkup() {\n    return toMarkup.call(this, \"a\");\n  }\n\n}\n/**\n * This node represents an image embed (<img>) element.\n */\n\nclass Img {\n  constructor(src, alt, style) {\n    this.src = void 0;\n    this.alt = void 0;\n    this.classes = void 0;\n    this.height = void 0;\n    this.depth = void 0;\n    this.maxFontSize = void 0;\n    this.style = void 0;\n    this.alt = alt;\n    this.src = src;\n    this.classes = [\"mord\"];\n    this.style = style;\n  }\n\n  hasClass(className) {\n    return utils.contains(this.classes, className);\n  }\n\n  toNode() {\n    const node = document.createElement(\"img\");\n    node.src = this.src;\n    node.alt = this.alt;\n    node.className = \"mord\"; // Apply inline styles\n\n    for (const style in this.style) {\n      if (this.style.hasOwnProperty(style)) {\n        // $FlowFixMe\n        node.style[style] = this.style[style];\n      }\n    }\n\n    return node;\n  }\n\n  toMarkup() {\n    let markup = \"<img src=\\\"\" + utils.escape(this.src) + \"\\\"\" + (\" alt=\\\"\" + utils.escape(this.alt) + \"\\\"\"); // Add the styles, after hyphenation\n\n    let styles = \"\";\n\n    for (const style in this.style) {\n      if (this.style.hasOwnProperty(style)) {\n        styles += utils.hyphenate(style) + \":\" + this.style[style] + \";\";\n      }\n    }\n\n    if (styles) {\n      markup += \" style=\\\"\" + utils.escape(styles) + \"\\\"\";\n    }\n\n    markup += \"'/>\";\n    return markup;\n  }\n\n}\nconst iCombinations = {\n  '': '\\u0131\\u0302',\n  '': '\\u0131\\u0308',\n  '': '\\u0131\\u0301',\n  // '': '\\u0131\\u0304', // enable when we add Extended Latin\n  '': '\\u0131\\u0300'\n};\n/**\n * A symbol node contains information about a single symbol. It either renders\n * to a single text node, or a span with a single text node in it, depending on\n * whether it has CSS classes, styles, or needs italic correction.\n */\n\nclass SymbolNode {\n  constructor(text, height, depth, italic, skew, width, classes, style) {\n    this.text = void 0;\n    this.height = void 0;\n    this.depth = void 0;\n    this.italic = void 0;\n    this.skew = void 0;\n    this.width = void 0;\n    this.maxFontSize = void 0;\n    this.classes = void 0;\n    this.style = void 0;\n    this.text = text;\n    this.height = height || 0;\n    this.depth = depth || 0;\n    this.italic = italic || 0;\n    this.skew = skew || 0;\n    this.width = width || 0;\n    this.classes = classes || [];\n    this.style = style || {};\n    this.maxFontSize = 0; // Mark text from non-Latin scripts with specific classes so that we\n    // can specify which fonts to use.  This allows us to render these\n    // characters with a serif font in situations where the browser would\n    // either default to a sans serif or render a placeholder character.\n    // We use CSS class names like cjk_fallback, hangul_fallback and\n    // brahmic_fallback. See ./unicodeScripts.js for the set of possible\n    // script names\n\n    const script = scriptFromCodepoint(this.text.charCodeAt(0));\n\n    if (script) {\n      this.classes.push(script + \"_fallback\");\n    }\n\n    if (/[]/.test(this.text)) {\n      // add  when we add Extended Latin\n      this.text = iCombinations[this.text];\n    }\n  }\n\n  hasClass(className) {\n    return utils.contains(this.classes, className);\n  }\n  /**\n   * Creates a text node or span from a symbol node. Note that a span is only\n   * created if it is needed.\n   */\n\n\n  toNode() {\n    const node = document.createTextNode(this.text);\n    let span = null;\n\n    if (this.italic > 0) {\n      span = document.createElement(\"span\");\n      span.style.marginRight = makeEm(this.italic);\n    }\n\n    if (this.classes.length > 0) {\n      span = span || document.createElement(\"span\");\n      span.className = createClass(this.classes);\n    }\n\n    for (const style in this.style) {\n      if (this.style.hasOwnProperty(style)) {\n        span = span || document.createElement(\"span\"); // $FlowFixMe Flow doesn't seem to understand span.style's type.\n\n        span.style[style] = this.style[style];\n      }\n    }\n\n    if (span) {\n      span.appendChild(node);\n      return span;\n    } else {\n      return node;\n    }\n  }\n  /**\n   * Creates markup for a symbol node.\n   */\n\n\n  toMarkup() {\n    // TODO(alpert): More duplication than I'd like from\n    // span.prototype.toMarkup and symbolNode.prototype.toNode...\n    let needsSpan = false;\n    let markup = \"<span\";\n\n    if (this.classes.length) {\n      needsSpan = true;\n      markup += \" class=\\\"\";\n      markup += utils.escape(createClass(this.classes));\n      markup += \"\\\"\";\n    }\n\n    let styles = \"\";\n\n    if (this.italic > 0) {\n      styles += \"margin-right:\" + this.italic + \"em;\";\n    }\n\n    for (const style in this.style) {\n      if (this.style.hasOwnProperty(style)) {\n        styles += utils.hyphenate(style) + \":\" + this.style[style] + \";\";\n      }\n    }\n\n    if (styles) {\n      needsSpan = true;\n      markup += \" style=\\\"\" + utils.escape(styles) + \"\\\"\";\n    }\n\n    const escaped = utils.escape(this.text);\n\n    if (needsSpan) {\n      markup += \">\";\n      markup += escaped;\n      markup += \"</span>\";\n      return markup;\n    } else {\n      return escaped;\n    }\n  }\n\n}\n/**\n * SVG nodes are used to render stretchy wide elements.\n */\n\nclass SvgNode {\n  constructor(children, attributes) {\n    this.children = void 0;\n    this.attributes = void 0;\n    this.children = children || [];\n    this.attributes = attributes || {};\n  }\n\n  toNode() {\n    const svgNS = \"http://www.w3.org/2000/svg\";\n    const node = document.createElementNS(svgNS, \"svg\"); // Apply attributes\n\n    for (const attr in this.attributes) {\n      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {\n        node.setAttribute(attr, this.attributes[attr]);\n      }\n    }\n\n    for (let i = 0; i < this.children.length; i++) {\n      node.appendChild(this.children[i].toNode());\n    }\n\n    return node;\n  }\n\n  toMarkup() {\n    let markup = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\"\"; // Apply attributes\n\n    for (const attr in this.attributes) {\n      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {\n        markup += \" \" + attr + \"=\\\"\" + utils.escape(this.attributes[attr]) + \"\\\"\";\n      }\n    }\n\n    markup += \">\";\n\n    for (let i = 0; i < this.children.length; i++) {\n      markup += this.children[i].toMarkup();\n    }\n\n    markup += \"</svg>\";\n    return markup;\n  }\n\n}\nclass PathNode {\n  constructor(pathName, alternate) {\n    this.pathName = void 0;\n    this.alternate = void 0;\n    this.pathName = pathName;\n    this.alternate = alternate; // Used only for \\sqrt, \\phase, & tall delims\n  }\n\n  toNode() {\n    const svgNS = \"http://www.w3.org/2000/svg\";\n    const node = document.createElementNS(svgNS, \"path\");\n\n    if (this.alternate) {\n      node.setAttribute(\"d\", this.alternate);\n    } else {\n      node.setAttribute(\"d\", path[this.pathName]);\n    }\n\n    return node;\n  }\n\n  toMarkup() {\n    if (this.alternate) {\n      return \"<path d=\\\"\" + utils.escape(this.alternate) + \"\\\"/>\";\n    } else {\n      return \"<path d=\\\"\" + utils.escape(path[this.pathName]) + \"\\\"/>\";\n    }\n  }\n\n}\nclass LineNode {\n  constructor(attributes) {\n    this.attributes = void 0;\n    this.attributes = attributes || {};\n  }\n\n  toNode() {\n    const svgNS = \"http://www.w3.org/2000/svg\";\n    const node = document.createElementNS(svgNS, \"line\"); // Apply attributes\n\n    for (const attr in this.attributes) {\n      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {\n        node.setAttribute(attr, this.attributes[attr]);\n      }\n    }\n\n    return node;\n  }\n\n  toMarkup() {\n    let markup = \"<line\";\n\n    for (const attr in this.attributes) {\n      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {\n        markup += \" \" + attr + \"=\\\"\" + utils.escape(this.attributes[attr]) + \"\\\"\";\n      }\n    }\n\n    markup += \"/>\";\n    return markup;\n  }\n\n}\nfunction assertSymbolDomNode(group) {\n  if (group instanceof SymbolNode) {\n    return group;\n  } else {\n    throw new Error(\"Expected symbolNode but got \" + String(group) + \".\");\n  }\n}\nfunction assertSpan(group) {\n  if (group instanceof Span) {\n    return group;\n  } else {\n    throw new Error(\"Expected span<HtmlDomNode> but got \" + String(group) + \".\");\n  }\n}\n;// CONCATENATED MODULE: ./src/symbols.js\n/**\n * This file holds a list of all no-argument functions and single-character\n * symbols (like 'a' or ';').\n *\n * For each of the symbols, there are three properties they can have:\n * - font (required): the font to be used for this symbol. Either \"main\" (the\n     normal font), or \"ams\" (the ams fonts).\n * - group (required): the ParseNode group type the symbol should have (i.e.\n     \"textord\", \"mathord\", etc).\n     See https://github.com/KaTeX/KaTeX/wiki/Examining-TeX#group-types\n * - replace: the character that this symbol or function should be\n *   replaced with (i.e. \"\\phi\" has a replace value of \"\\u03d5\", the phi\n *   character in the main font).\n *\n * The outermost map in the table indicates what mode the symbols should be\n * accepted in (e.g. \"math\" or \"text\").\n */\n// Some of these have a \"-token\" suffix since these are also used as `ParseNode`\n// types for raw text tokens, and we want to avoid conflicts with higher-level\n// `ParseNode` types. These `ParseNode`s are constructed within `Parser` by\n// looking up the `symbols` map.\nconst ATOMS = {\n  \"bin\": 1,\n  \"close\": 1,\n  \"inner\": 1,\n  \"open\": 1,\n  \"punct\": 1,\n  \"rel\": 1\n};\nconst NON_ATOMS = {\n  \"accent-token\": 1,\n  \"mathord\": 1,\n  \"op-token\": 1,\n  \"spacing\": 1,\n  \"textord\": 1\n};\nconst symbols = {\n  \"math\": {},\n  \"text\": {}\n};\n/* harmony default export */ var src_symbols = (symbols);\n/** `acceptUnicodeChar = true` is only applicable if `replace` is set. */\n\nfunction defineSymbol(mode, font, group, replace, name, acceptUnicodeChar) {\n  symbols[mode][name] = {\n    font,\n    group,\n    replace\n  };\n\n  if (acceptUnicodeChar && replace) {\n    symbols[mode][replace] = symbols[mode][name];\n  }\n} // Some abbreviations for commonly used strings.\n// This helps minify the code, and also spotting typos using jshint.\n// modes:\n\nconst math = \"math\";\nconst symbols_text = \"text\"; // fonts:\n\nconst main = \"main\";\nconst ams = \"ams\"; // groups:\n\nconst accent = \"accent-token\";\nconst bin = \"bin\";\nconst symbols_close = \"close\";\nconst inner = \"inner\";\nconst mathord = \"mathord\";\nconst op = \"op-token\";\nconst symbols_open = \"open\";\nconst punct = \"punct\";\nconst rel = \"rel\";\nconst spacing = \"spacing\";\nconst textord = \"textord\"; // Now comes the symbol table\n// Relation Symbols\n\ndefineSymbol(math, main, rel, \"\\u2261\", \"\\\\equiv\", true);\ndefineSymbol(math, main, rel, \"\\u227a\", \"\\\\prec\", true);\ndefineSymbol(math, main, rel, \"\\u227b\", \"\\\\succ\", true);\ndefineSymbol(math, main, rel, \"\\u223c\", \"\\\\sim\", true);\ndefineSymbol(math, main, rel, \"\\u22a5\", \"\\\\perp\");\ndefineSymbol(math, main, rel, \"\\u2aaf\", \"\\\\preceq\", true);\ndefineSymbol(math, main, rel, \"\\u2ab0\", \"\\\\succeq\", true);\ndefineSymbol(math, main, rel, \"\\u2243\", \"\\\\simeq\", true);\ndefineSymbol(math, main, rel, \"\\u2223\", \"\\\\mid\", true);\ndefineSymbol(math, main, rel, \"\\u226a\", \"\\\\ll\", true);\ndefineSymbol(math, main, rel, \"\\u226b\", \"\\\\gg\", true);\ndefineSymbol(math, main, rel, \"\\u224d\", \"\\\\asymp\", true);\ndefineSymbol(math, main, rel, \"\\u2225\", \"\\\\parallel\");\ndefineSymbol(math, main, rel, \"\\u22c8\", \"\\\\bowtie\", true);\ndefineSymbol(math, main, rel, \"\\u2323\", \"\\\\smile\", true);\ndefineSymbol(math, main, rel, \"\\u2291\", \"\\\\sqsubseteq\", true);\ndefineSymbol(math, main, rel, \"\\u2292\", \"\\\\sqsupseteq\", true);\ndefineSymbol(math, main, rel, \"\\u2250\", \"\\\\doteq\", true);\ndefineSymbol(math, main, rel, \"\\u2322\", \"\\\\frown\", true);\ndefineSymbol(math, main, rel, \"\\u220b\", \"\\\\ni\", true);\ndefineSymbol(math, main, rel, \"\\u221d\", \"\\\\propto\", true);\ndefineSymbol(math, main, rel, \"\\u22a2\", \"\\\\vdash\", true);\ndefineSymbol(math, main, rel, \"\\u22a3\", \"\\\\dashv\", true);\ndefineSymbol(math, main, rel, \"\\u220b\", \"\\\\owns\"); // Punctuation\n\ndefineSymbol(math, main, punct, \"\\u002e\", \"\\\\ldotp\");\ndefineSymbol(math, main, punct, \"\\u22c5\", \"\\\\cdotp\"); // Misc Symbols\n\ndefineSymbol(math, main, textord, \"\\u0023\", \"\\\\#\");\ndefineSymbol(symbols_text, main, textord, \"\\u0023\", \"\\\\#\");\ndefineSymbol(math, main, textord, \"\\u0026\", \"\\\\&\");\ndefineSymbol(symbols_text, main, textord, \"\\u0026\", \"\\\\&\");\ndefineSymbol(math, main, textord, \"\\u2135\", \"\\\\aleph\", true);\ndefineSymbol(math, main, textord, \"\\u2200\", \"\\\\forall\", true);\ndefineSymbol(math, main, textord, \"\\u210f\", \"\\\\hbar\", true);\ndefineSymbol(math, main, textord, \"\\u2203\", \"\\\\exists\", true);\ndefineSymbol(math, main, textord, \"\\u2207\", \"\\\\nabla\", true);\ndefineSymbol(math, main, textord, \"\\u266d\", \"\\\\flat\", true);\ndefineSymbol(math, main, textord, \"\\u2113\", \"\\\\ell\", true);\ndefineSymbol(math, main, textord, \"\\u266e\", \"\\\\natural\", true);\ndefineSymbol(math, main, textord, \"\\u2663\", \"\\\\clubsuit\", true);\ndefineSymbol(math, main, textord, \"\\u2118\", \"\\\\wp\", true);\ndefineSymbol(math, main, textord, \"\\u266f\", \"\\\\sharp\", true);\ndefineSymbol(math, main, textord, \"\\u2662\", \"\\\\diamondsuit\", true);\ndefineSymbol(math, main, textord, \"\\u211c\", \"\\\\Re\", true);\ndefineSymbol(math, main, textord, \"\\u2661\", \"\\\\heartsuit\", true);\ndefineSymbol(math, main, textord, \"\\u2111\", \"\\\\Im\", true);\ndefineSymbol(math, main, textord, \"\\u2660\", \"\\\\spadesuit\", true);\ndefineSymbol(math, main, textord, \"\\u00a7\", \"\\\\S\", true);\ndefineSymbol(symbols_text, main, textord, \"\\u00a7\", \"\\\\S\");\ndefineSymbol(math, main, textord, \"\\u00b6\", \"\\\\P\", true);\ndefineSymbol(symbols_text, main, textord, \"\\u00b6\", \"\\\\P\"); // Math and Text\n\ndefineSymbol(math, main, textord, \"\\u2020\", \"\\\\dag\");\ndefineSymbol(symbols_text, main, textord, \"\\u2020\", \"\\\\dag\");\ndefineSymbol(symbols_text, main, textord, \"\\u2020\", \"\\\\textdagger\");\ndefineSymbol(math, main, textord, \"\\u2021\", \"\\\\ddag\");\ndefineSymbol(symbols_text, main, textord, \"\\u2021\", \"\\\\ddag\");\ndefineSymbol(symbols_text, main, textord, \"\\u2021\", \"\\\\textdaggerdbl\"); // Large Delimiters\n\ndefineSymbol(math, main, symbols_close, \"\\u23b1\", \"\\\\rmoustache\", true);\ndefineSymbol(math, main, symbols_open, \"\\u23b0\", \"\\\\lmoustache\", true);\ndefineSymbol(math, main, symbols_close, \"\\u27ef\", \"\\\\rgroup\", true);\ndefineSymbol(math, main, symbols_open, \"\\u27ee\", \"\\\\lgroup\", true); // Binary Operators\n\ndefineSymbol(math, main, bin, \"\\u2213\", \"\\\\mp\", true);\ndefineSymbol(math, main, bin, \"\\u2296\", \"\\\\ominus\", true);\ndefineSymbol(math, main, bin, \"\\u228e\", \"\\\\uplus\", true);\ndefineSymbol(math, main, bin, \"\\u2293\", \"\\\\sqcap\", true);\ndefineSymbol(math, main, bin, \"\\u2217\", \"\\\\ast\");\ndefineSymbol(math, main, bin, \"\\u2294\", \"\\\\sqcup\", true);\ndefineSymbol(math, main, bin, \"\\u25ef\", \"\\\\bigcirc\", true);\ndefineSymbol(math, main, bin, \"\\u2219\", \"\\\\bullet\", true);\ndefineSymbol(math, main, bin, \"\\u2021\", \"\\\\ddagger\");\ndefineSymbol(math, main, bin, \"\\u2240\", \"\\\\wr\", true);\ndefineSymbol(math, main, bin, \"\\u2a3f\", \"\\\\amalg\");\ndefineSymbol(math, main, bin, \"\\u0026\", \"\\\\And\"); // from amsmath\n// Arrow Symbols\n\ndefineSymbol(math, main, rel, \"\\u27f5\", \"\\\\longleftarrow\", true);\ndefineSymbol(math, main, rel, \"\\u21d0\", \"\\\\Leftarrow\", true);\ndefineSymbol(math, main, rel, \"\\u27f8\", \"\\\\Longleftarrow\", true);\ndefineSymbol(math, main, rel, \"\\u27f6\", \"\\\\longrightarrow\", true);\ndefineSymbol(math, main, rel, \"\\u21d2\", \"\\\\Rightarrow\", true);\ndefineSymbol(math, main, rel, \"\\u27f9\", \"\\\\Longrightarrow\", true);\ndefineSymbol(math, main, rel, \"\\u2194\", \"\\\\leftrightarrow\", true);\ndefineSymbol(math, main, rel, \"\\u27f7\", \"\\\\longleftrightarrow\", true);\ndefineSymbol(math, main, rel, \"\\u21d4\", \"\\\\Leftrightarrow\", true);\ndefineSymbol(math, main, rel, \"\\u27fa\", \"\\\\Longleftrightarrow\", true);\ndefineSymbol(math, main, rel, \"\\u21a6\", \"\\\\mapsto\", true);\ndefineSymbol(math, main, rel, \"\\u27fc\", \"\\\\longmapsto\", true);\ndefineSymbol(math, main, rel, \"\\u2197\", \"\\\\nearrow\", true);\ndefineSymbol(math, main, rel, \"\\u21a9\", \"\\\\hookleftarrow\", true);\ndefineSymbol(math, main, rel, \"\\u21aa\", \"\\\\hookrightarrow\", true);\ndefineSymbol(math, main, rel, \"\\u2198\", \"\\\\searrow\", true);\ndefineSymbol(math, main, rel, \"\\u21bc\", \"\\\\leftharpoonup\", true);\ndefineSymbol(math, main, rel, \"\\u21c0\", \"\\\\rightharpoonup\", true);\ndefineSymbol(math, main, rel, \"\\u2199\", \"\\\\swarrow\", true);\ndefineSymbol(math, main, rel, \"\\u21bd\", \"\\\\leftharpoondown\", true);\ndefineSymbol(math, main, rel, \"\\u21c1\", \"\\\\rightharpoondown\", true);\ndefineSymbol(math, main, rel, \"\\u2196\", \"\\\\nwarrow\", true);\ndefineSymbol(math, main, rel, \"\\u21cc\", \"\\\\rightleftharpoons\", true); // AMS Negated Binary Relations\n\ndefineSymbol(math, ams, rel, \"\\u226e\", \"\\\\nless\", true); // Symbol names preceded by \"@\" each have a corresponding macro.\n\ndefineSymbol(math, ams, rel, \"\\ue010\", \"\\\\@nleqslant\");\ndefineSymbol(math, ams, rel, \"\\ue011\", \"\\\\@nleqq\");\ndefineSymbol(math, ams, rel, \"\\u2a87\", \"\\\\lneq\", true);\ndefineSymbol(math, ams, rel, \"\\u2268\", \"\\\\lneqq\", true);\ndefineSymbol(math, ams, rel, \"\\ue00c\", \"\\\\@lvertneqq\");\ndefineSymbol(math, ams, rel, \"\\u22e6\", \"\\\\lnsim\", true);\ndefineSymbol(math, ams, rel, \"\\u2a89\", \"\\\\lnapprox\", true);\ndefineSymbol(math, ams, rel, \"\\u2280\", \"\\\\nprec\", true); // unicode-math maps \\u22e0 to \\npreccurlyeq. We'll use the AMS synonym.\n\ndefineSymbol(math, ams, rel, \"\\u22e0\", \"\\\\npreceq\", true);\ndefineSymbol(math, ams, rel, \"\\u22e8\", \"\\\\precnsim\", true);\ndefineSymbol(math, ams, rel, \"\\u2ab9\", \"\\\\precnapprox\", true);\ndefineSymbol(math, ams, rel, \"\\u2241\", \"\\\\nsim\", true);\ndefineSymbol(math, ams, rel, \"\\ue006\", \"\\\\@nshortmid\");\ndefineSymbol(math, ams, rel, \"\\u2224\", \"\\\\nmid\", true);\ndefineSymbol(math, ams, rel, \"\\u22ac\", \"\\\\nvdash\", true);\ndefineSymbol(math, ams, rel, \"\\u22ad\", \"\\\\nvDash\", true);\ndefineSymbol(math, ams, rel, \"\\u22ea\", \"\\\\ntriangleleft\");\ndefineSymbol(math, ams, rel, \"\\u22ec\", \"\\\\ntrianglelefteq\", true);\ndefineSymbol(math, ams, rel, \"\\u228a\", \"\\\\subsetneq\", true);\ndefineSymbol(math, ams, rel, \"\\ue01a\", \"\\\\@varsubsetneq\");\ndefineSymbol(math, ams, rel, \"\\u2acb\", \"\\\\subsetneqq\", true);\ndefineSymbol(math, ams, rel, \"\\ue017\", \"\\\\@varsubsetneqq\");\ndefineSymbol(math, ams, rel, \"\\u226f\", \"\\\\ngtr\", true);\ndefineSymbol(math, ams, rel, \"\\ue00f\", \"\\\\@ngeqslant\");\ndefineSymbol(math, ams, rel, \"\\ue00e\", \"\\\\@ngeqq\");\ndefineSymbol(math, ams, rel, \"\\u2a88\", \"\\\\gneq\", true);\ndefineSymbol(math, ams, rel, \"\\u2269\", \"\\\\gneqq\", true);\ndefineSymbol(math, ams, rel, \"\\ue00d\", \"\\\\@gvertneqq\");\ndefineSymbol(math, ams, rel, \"\\u22e7\", \"\\\\gnsim\", true);\ndefineSymbol(math, ams, rel, \"\\u2a8a\", \"\\\\gnapprox\", true);\ndefineSymbol(math, ams, rel, \"\\u2281\", \"\\\\nsucc\", true); // unicode-math maps \\u22e1 to \\nsucccurlyeq. We'll use the AMS synonym.\n\ndefineSymbol(math, ams, rel, \"\\u22e1\", \"\\\\nsucceq\", true);\ndefineSymbol(math, ams, rel, \"\\u22e9\", \"\\\\succnsim\", true);\ndefineSymbol(math, ams, rel, \"\\u2aba\", \"\\\\succnapprox\", true); // unicode-math maps \\u2246 to \\simneqq. We'll use the AMS synonym.\n\ndefineSymbol(math, ams, rel, \"\\u2246\", \"\\\\ncong\", true);\ndefineSymbol(math, ams, rel, \"\\ue007\", \"\\\\@nshortparallel\");\ndefineSymbol(math, ams, rel, \"\\u2226\", \"\\\\nparallel\", true);\ndefineSymbol(math, ams, rel, \"\\u22af\", \"\\\\nVDash\", true);\ndefineSymbol(math, ams, rel, \"\\u22eb\", \"\\\\ntriangleright\");\ndefineSymbol(math, ams, rel, \"\\u22ed\", \"\\\\ntrianglerighteq\", true);\ndefineSymbol(math, ams, rel, \"\\ue018\", \"\\\\@nsupseteqq\");\ndefineSymbol(math, ams, rel, \"\\u228b\", \"\\\\supsetneq\", true);\ndefineSymbol(math, ams, rel, \"\\ue01b\", \"\\\\@varsupsetneq\");\ndefineSymbol(math, ams, rel, \"\\u2acc\", \"\\\\supsetneqq\", true);\ndefineSymbol(math, ams, rel, \"\\ue019\", \"\\\\@varsupsetneqq\");\ndefineSymbol(math, ams, rel, \"\\u22ae\", \"\\\\nVdash\", true);\ndefineSymbol(math, ams, rel, \"\\u2ab5\", \"\\\\precneqq\", true);\ndefineSymbol(math, ams, rel, \"\\u2ab6\", \"\\\\succneqq\", true);\ndefineSymbol(math, ams, rel, \"\\ue016\", \"\\\\@nsubseteqq\");\ndefineSymbol(math, ams, bin, \"\\u22b4\", \"\\\\unlhd\");\ndefineSymbol(math, ams, bin, \"\\u22b5\", \"\\\\unrhd\"); // AMS Negated Arrows\n\ndefineSymbol(math, ams, rel, \"\\u219a\", \"\\\\nleftarrow\", true);\ndefineSymbol(math, ams, rel, \"\\u219b\", \"\\\\nrightarrow\", true);\ndefineSymbol(math, ams, rel, \"\\u21cd\", \"\\\\nLeftarrow\", true);\ndefineSymbol(math, ams, rel, \"\\u21cf\", \"\\\\nRightarrow\", true);\ndefineSymbol(math, ams, rel, \"\\u21ae\", \"\\\\nleftrightarrow\", true);\ndefineSymbol(math, ams, rel, \"\\u21ce\", \"\\\\nLeftrightarrow\", true); // AMS Misc\n\ndefineSymbol(math, ams, rel, \"\\u25b3\", \"\\\\vartriangle\");\ndefineSymbol(math, ams, textord, \"\\u210f\", \"\\\\hslash\");\ndefineSymbol(math, ams, textord, \"\\u25bd\", \"\\\\triangledown\");\ndefineSymbol(math, ams, textord, \"\\u25ca\", \"\\\\lozenge\");\ndefineSymbol(math, ams, textord, \"\\u24c8\", \"\\\\circledS\");\ndefineSymbol(math, ams, textord, \"\\u00ae\", \"\\\\circledR\");\ndefineSymbol(symbols_text, ams, textord, \"\\u00ae\", \"\\\\circledR\");\ndefineSymbol(math, ams, textord, \"\\u2221\", \"\\\\measuredangle\", true);\ndefineSymbol(math, ams, textord, \"\\u2204\", \"\\\\nexists\");\ndefineSymbol(math, ams, textord, \"\\u2127\", \"\\\\mho\");\ndefineSymbol(math, ams, textord, \"\\u2132\", \"\\\\Finv\", true);\ndefineSymbol(math, ams, textord, \"\\u2141\", \"\\\\Game\", true);\ndefineSymbol(math, ams, textord, \"\\u2035\", \"\\\\backprime\");\ndefineSymbol(math, ams, textord, \"\\u25b2\", \"\\\\blacktriangle\");\ndefineSymbol(math, ams, textord, \"\\u25bc\", \"\\\\blacktriangledown\");\ndefineSymbol(math, ams, textord, \"\\u25a0\", \"\\\\blacksquare\");\ndefineSymbol(math, ams, textord, \"\\u29eb\", \"\\\\blacklozenge\");\ndefineSymbol(math, ams, textord, \"\\u2605\", \"\\\\bigstar\");\ndefineSymbol(math, ams, textord, \"\\u2222\", \"\\\\sphericalangle\", true);\ndefineSymbol(math, ams, textord, \"\\u2201\", \"\\\\complement\", true); // unicode-math maps U+F0 to \\matheth. We map to AMS function \\eth\n\ndefineSymbol(math, ams, textord, \"\\u00f0\", \"\\\\eth\", true);\ndefineSymbol(symbols_text, main, textord, \"\\u00f0\", \"\\u00f0\");\ndefineSymbol(math, ams, textord, \"\\u2571\", \"\\\\diagup\");\ndefineSymbol(math, ams, textord, \"\\u2572\", \"\\\\diagdown\");\ndefineSymbol(math, ams, textord, \"\\u25a1\", \"\\\\square\");\ndefineSymbol(math, ams, textord, \"\\u25a1\", \"\\\\Box\");\ndefineSymbol(math, ams, textord, \"\\u25ca\", \"\\\\Diamond\"); // unicode-math maps U+A5 to \\mathyen. We map to AMS function \\yen\n\ndefineSymbol(math, ams, textord, \"\\u00a5\", \"\\\\yen\", true);\ndefineSymbol(symbols_text, ams, textord, \"\\u00a5\", \"\\\\yen\", true);\ndefineSymbol(math, ams, textord, \"\\u2713\", \"\\\\checkmark\", true);\ndefineSymbol(symbols_text, ams, textord, \"\\u2713\", \"\\\\checkmark\"); // AMS Hebrew\n\ndefineSymbol(math, ams, textord, \"\\u2136\", \"\\\\beth\", true);\ndefineSymbol(math, ams, textord, \"\\u2138\", \"\\\\daleth\", true);\ndefineSymbol(math, ams, textord, \"\\u2137\", \"\\\\gimel\", true); // AMS Greek\n\ndefineSymbol(math, ams, textord, \"\\u03dd\", \"\\\\digamma\", true);\ndefineSymbol(math, ams, textord, \"\\u03f0\", \"\\\\varkappa\"); // AMS Delimiters\n\ndefineSymbol(math, ams, symbols_open, \"\\u250c\", \"\\\\@ulcorner\", true);\ndefineSymbol(math, ams, symbols_close, \"\\u2510\", \"\\\\@urcorner\", true);\ndefineSymbol(math, ams, symbols_open, \"\\u2514\", \"\\\\@llcorner\", true);\ndefineSymbol(math, ams, symbols_close, \"\\u2518\", \"\\\\@lrcorner\", true); // AMS Binary Relations\n\ndefineSymbol(math, ams, rel, \"\\u2266\", \"\\\\leqq\", true);\ndefineSymbol(math, ams, rel, \"\\u2a7d\", \"\\\\leqslant\", true);\ndefineSymbol(math, ams, rel, \"\\u2a95\", \"\\\\eqslantless\", true);\ndefineSymbol(math, ams, rel, \"\\u2272\", \"\\\\lesssim\", true);\ndefineSymbol(math, ams, rel, \"\\u2a85\", \"\\\\lessapprox\", true);\ndefineSymbol(math, ams, rel, \"\\u224a\", \"\\\\approxeq\", true);\ndefineSymbol(math, ams, bin, \"\\u22d6\", \"\\\\lessdot\");\ndefineSymbol(math, ams, rel, \"\\u22d8\", \"\\\\lll\", true);\ndefineSymbol(math, ams, rel, \"\\u2276\", \"\\\\lessgtr\", true);\ndefineSymbol(math, ams, rel, \"\\u22da\", \"\\\\lesseqgtr\", true);\ndefineSymbol(math, ams, rel, \"\\u2a8b\", \"\\\\lesseqqgtr\", true);\ndefineSymbol(math, ams, rel, \"\\u2251\", \"\\\\doteqdot\");\ndefineSymbol(math, ams, rel, \"\\u2253\", \"\\\\risingdotseq\", true);\ndefineSymbol(math, ams, rel, \"\\u2252\", \"\\\\fallingdotseq\", true);\ndefineSymbol(math, ams, rel, \"\\u223d\", \"\\\\backsim\", true);\ndefineSymbol(math, ams, rel, \"\\u22cd\", \"\\\\backsimeq\", true);\ndefineSymbol(math, ams, rel, \"\\u2ac5\", \"\\\\subseteqq\", true);\ndefineSymbol(math, ams, rel, \"\\u22d0\", \"\\\\Subset\", true);\ndefineSymbol(math, ams, rel, \"\\u228f\", \"\\\\sqsubset\", true);\ndefineSymbol(math, ams, rel, \"\\u227c\", \"\\\\preccurlyeq\", true);\ndefineSymbol(math, ams, rel, \"\\u22de\", \"\\\\curlyeqprec\", true);\ndefineSymbol(math, ams, rel, \"\\u227e\", \"\\\\precsim\", true);\ndefineSymbol(math, ams, rel, \"\\u2ab7\", \"\\\\precapprox\", true);\ndefineSymbol(math, ams, rel, \"\\u22b2\", \"\\\\vartriangleleft\");\ndefineSymbol(math, ams, rel, \"\\u22b4\", \"\\\\trianglelefteq\");\ndefineSymbol(math, ams, rel, \"\\u22a8\", \"\\\\vDash\", true);\ndefineSymbol(math, ams, rel, \"\\u22aa\", \"\\\\Vvdash\", true);\ndefineSymbol(math, ams, rel, \"\\u2323\", \"\\\\smallsmile\");\ndefineSymbol(math, ams, rel, \"\\u2322\", \"\\\\smallfrown\");\ndefineSymbol(math, ams, rel, \"\\u224f\", \"\\\\bumpeq\", true);\ndefineSymbol(math, ams, rel, \"\\u224e\", \"\\\\Bumpeq\", true);\ndefineSymbol(math, ams, rel, \"\\u2267\", \"\\\\geqq\", true);\ndefineSymbol(math, ams, rel, \"\\u2a7e\", \"\\\\geqslant\", true);\ndefineSymbol(math, ams, rel, \"\\u2a96\", \"\\\\eqslantgtr\", true);\ndefineSymbol(math, ams, rel, \"\\u2273\", \"\\\\gtrsim\", true);\ndefineSymbol(math, ams, rel, \"\\u2a86\", \"\\\\gtrapprox\", true);\ndefineSymbol(math, ams, bin, \"\\u22d7\", \"\\\\gtrdot\");\ndefineSymbol(math, ams, rel, \"\\u22d9\", \"\\\\ggg\", true);\ndefineSymbol(math, ams, rel, \"\\u2277\", \"\\\\gtrless\", true);\ndefineSymbol(math, ams, rel, \"\\u22db\", \"\\\\gtreqless\", true);\ndefineSymbol(math, ams, rel, \"\\u2a8c\", \"\\\\gtreqqless\", true);\ndefineSymbol(math, ams, rel, \"\\u2256\", \"\\\\eqcirc\", true);\ndefineSymbol(math, ams, rel, \"\\u2257\", \"\\\\circeq\", true);\ndefineSymbol(math, ams, rel, \"\\u225c\", \"\\\\triangleq\", true);\ndefineSymbol(math, ams, rel, \"\\u223c\", \"\\\\thicksim\");\ndefineSymbol(math, ams, rel, \"\\u2248\", \"\\\\thickapprox\");\ndefineSymbol(math, ams, rel, \"\\u2ac6\", \"\\\\supseteqq\", true);\ndefineSymbol(math, ams, rel, \"\\u22d1\", \"\\\\Supset\", true);\ndefineSymbol(math, ams, rel, \"\\u2290\", \"\\\\sqsupset\", true);\ndefineSymbol(math, ams, rel, \"\\u227d\", \"\\\\succcurlyeq\", true);\ndefineSymbol(math, ams, rel, \"\\u22df\", \"\\\\curlyeqsucc\", true);\ndefineSymbol(math, ams, rel, \"\\u227f\", \"\\\\succsim\", true);\ndefineSymbol(math, ams, rel, \"\\u2ab8\", \"\\\\succapprox\", true);\ndefineSymbol(math, ams, rel, \"\\u22b3\", \"\\\\vartriangleright\");\ndefineSymbol(math, ams, rel, \"\\u22b5\", \"\\\\trianglerighteq\");\ndefineSymbol(math, ams, rel, \"\\u22a9\", \"\\\\Vdash\", true);\ndefineSymbol(math, ams, rel, \"\\u2223\", \"\\\\shortmid\");\ndefineSymbol(math, ams, rel, \"\\u2225\", \"\\\\shortparallel\");\ndefineSymbol(math, ams, rel, \"\\u226c\", \"\\\\between\", true);\ndefineSymbol(math, ams, rel, \"\\u22d4\", \"\\\\pitchfork\", true);\ndefineSymbol(math, ams, rel, \"\\u221d\", \"\\\\varpropto\");\ndefineSymbol(math, ams, rel, \"\\u25c0\", \"\\\\blacktriangleleft\"); // unicode-math says that \\therefore is a mathord atom.\n// We kept the amssymb atom type, which is rel.\n\ndefineSymbol(math, ams, rel, \"\\u2234\", \"\\\\therefore\", true);\ndefineSymbol(math, ams, rel, \"\\u220d\", \"\\\\backepsilon\");\ndefineSymbol(math, ams, rel, \"\\u25b6\", \"\\\\blacktriangleright\"); // unicode-math says that \\because is a mathord atom.\n// We kept the amssymb atom type, which is rel.\n\ndefineSymbol(math, ams, rel, \"\\u2235\", \"\\\\because\", true);\ndefineSymbol(math, ams, rel, \"\\u22d8\", \"\\\\llless\");\ndefineSymbol(math, ams, rel, \"\\u22d9\", \"\\\\gggtr\");\ndefineSymbol(math, ams, bin, \"\\u22b2\", \"\\\\lhd\");\ndefineSymbol(math, ams, bin, \"\\u22b3\", \"\\\\rhd\");\ndefineSymbol(math, ams, rel, \"\\u2242\", \"\\\\eqsim\", true);\ndefineSymbol(math, main, rel, \"\\u22c8\", \"\\\\Join\");\ndefineSymbol(math, ams, rel, \"\\u2251\", \"\\\\Doteq\", true); // AMS Binary Operators\n\ndefineSymbol(math, ams, bin, \"\\u2214\", \"\\\\dotplus\", true);\ndefineSymbol(math, ams, bin, \"\\u2216\", \"\\\\smallsetminus\");\ndefineSymbol(math, ams, bin, \"\\u22d2\", \"\\\\Cap\", true);\ndefineSymbol(math, ams, bin, \"\\u22d3\", \"\\\\Cup\", true);\ndefineSymbol(math, ams, bin, \"\\u2a5e\", \"\\\\doublebarwedge\", true);\ndefineSymbol(math, ams, bin, \"\\u229f\", \"\\\\boxminus\", true);\ndefineSymbol(math, ams, bin, \"\\u229e\", \"\\\\boxplus\", true);\ndefineSymbol(math, ams, bin, \"\\u22c7\", \"\\\\divideontimes\", true);\ndefineSymbol(math, ams, bin, \"\\u22c9\", \"\\\\ltimes\", true);\ndefineSymbol(math, ams, bin, \"\\u22ca\", \"\\\\rtimes\", true);\ndefineSymbol(math, ams, bin, \"\\u22cb\", \"\\\\leftthreetimes\", true);\ndefineSymbol(math, ams, bin, \"\\u22cc\", \"\\\\rightthreetimes\", true);\ndefineSymbol(math, ams, bin, \"\\u22cf\", \"\\\\curlywedge\", true);\ndefineSymbol(math, ams, bin, \"\\u22ce\", \"\\\\curlyvee\", true);\ndefineSymbol(math, ams, bin, \"\\u229d\", \"\\\\circleddash\", true);\ndefineSymbol(math, ams, bin, \"\\u229b\", \"\\\\circledast\", true);\ndefineSymbol(math, ams, bin, \"\\u22c5\", \"\\\\centerdot\");\ndefineSymbol(math, ams, bin, \"\\u22ba\", \"\\\\intercal\", true);\ndefineSymbol(math, ams, bin, \"\\u22d2\", \"\\\\doublecap\");\ndefineSymbol(math, ams, bin, \"\\u22d3\", \"\\\\doublecup\");\ndefineSymbol(math, ams, bin, \"\\u22a0\", \"\\\\boxtimes\", true); // AMS Arrows\n// Note: unicode-math maps \\u21e2 to their own function \\rightdasharrow.\n// We'll map it to AMS function \\dashrightarrow. It produces the same atom.\n\ndefineSymbol(math, ams, rel, \"\\u21e2\", \"\\\\dashrightarrow\", true); // unicode-math maps \\u21e0 to \\leftdasharrow. We'll use the AMS synonym.\n\ndefineSymbol(math, ams, rel, \"\\u21e0\", \"\\\\dashleftarrow\", true);\ndefineSymbol(math, ams, rel, \"\\u21c7\", \"\\\\leftleftarrows\", true);\ndefineSymbol(math, ams, rel, \"\\u21c6\", \"\\\\leftrightarrows\", true);\ndefineSymbol(math, ams, rel, \"\\u21da\", \"\\\\Lleftarrow\", true);\ndefineSymbol(math, ams, rel, \"\\u219e\", \"\\\\twoheadleftarrow\", true);\ndefineSymbol(math, ams, rel, \"\\u21a2\", \"\\\\leftarrowtail\", true);\ndefineSymbol(math, ams, rel, \"\\u21ab\", \"\\\\looparrowleft\", true);\ndefineSymbol(math, ams, rel, \"\\u21cb\", \"\\\\leftrightharpoons\", true);\ndefineSymbol(math, ams, rel, \"\\u21b6\", \"\\\\curvearrowleft\", true); // unicode-math maps \\u21ba to \\acwopencirclearrow. We'll use the AMS synonym.\n\ndefineSymbol(math, ams, rel, \"\\u21ba\", \"\\\\circlearrowleft\", true);\ndefineSymbol(math, ams, rel, \"\\u21b0\", \"\\\\Lsh\", true);\ndefineSymbol(math, ams, rel, \"\\u21c8\", \"\\\\upuparrows\", true);\ndefineSymbol(math, ams, rel, \"\\u21bf\", \"\\\\upharpoonleft\", true);\ndefineSymbol(math, ams, rel, \"\\u21c3\", \"\\\\downharpoonleft\", true);\ndefineSymbol(math, main, rel, \"\\u22b6\", \"\\\\origof\", true); // not in font\n\ndefineSymbol(math, main, rel, \"\\u22b7\", \"\\\\imageof\", true); // not in font\n\ndefineSymbol(math, ams, rel, \"\\u22b8\", \"\\\\multimap\", true);\ndefineSymbol(math, ams, rel, \"\\u21ad\", \"\\\\leftrightsquigarrow\", true);\ndefineSymbol(math, ams, rel, \"\\u21c9\", \"\\\\rightrightarrows\", true);\ndefineSymbol(math, ams, rel, \"\\u21c4\", \"\\\\rightleftarrows\", true);\ndefineSymbol(math, ams, rel, \"\\u21a0\", \"\\\\twoheadrightarrow\", true);\ndefineSymbol(math, ams, rel, \"\\u21a3\", \"\\\\rightarrowtail\", true);\ndefineSymbol(math, ams, rel, \"\\u21ac\", \"\\\\looparrowright\", true);\ndefineSymbol(math, ams, rel, \"\\u21b7\", \"\\\\curvearrowright\", true); // unicode-math maps \\u21bb to \\cwopencirclearrow. We'll use the AMS synonym.\n\ndefineSymbol(math, ams, rel, \"\\u21bb\", \"\\\\circlearrowright\", true);\ndefineSymbol(math, ams, rel, \"\\u21b1\", \"\\\\Rsh\", true);\ndefineSymbol(math, ams, rel, \"\\u21ca\", \"\\\\downdownarrows\", true);\ndefineSymbol(math, ams, rel, \"\\u21be\", \"\\\\upharpoonright\", true);\ndefineSymbol(math, ams, rel, \"\\u21c2\", \"\\\\downharpoonright\", true);\ndefineSymbol(math, ams, rel, \"\\u21dd\", \"\\\\rightsquigarrow\", true);\ndefineSymbol(math, ams, rel, \"\\u21dd\", \"\\\\leadsto\");\ndefineSymbol(math, ams, rel, \"\\u21db\", \"\\\\Rrightarrow\", true);\ndefineSymbol(math, ams, rel, \"\\u21be\", \"\\\\restriction\");\ndefineSymbol(math, main, textord, \"\\u2018\", \"`\");\ndefineSymbol(math, main, textord, \"$\", \"\\\\$\");\ndefineSymbol(symbols_text, main, textord, \"$\", \"\\\\$\");\ndefineSymbol(symbols_text, main, textord, \"$\", \"\\\\textdollar\");\ndefineSymbol(math, main, textord, \"%\", \"\\\\%\");\ndefineSymbol(symbols_text, main, textord, \"%\", \"\\\\%\");\ndefineSymbol(math, main, textord, \"_\", \"\\\\_\");\ndefineSymbol(symbols_text, main, textord, \"_\", \"\\\\_\");\ndefineSymbol(symbols_text, main, textord, \"_\", \"\\\\textunderscore\");\ndefineSymbol(math, main, textord, \"\\u2220\", \"\\\\angle\", true);\ndefineSymbol(math, main, textord, \"\\u221e\", \"\\\\infty\", true);\ndefineSymbol(math, main, textord, \"\\u2032\", \"\\\\prime\");\ndefineSymbol(math, main, textord, \"\\u25b3\", \"\\\\triangle\");\ndefineSymbol(math, main, textord, \"\\u0393\", \"\\\\Gamma\", true);\ndefineSymbol(math, main, textord, \"\\u0394\", \"\\\\Delta\", true);\ndefineSymbol(math, main, textord, \"\\u0398\", \"\\\\Theta\", true);\ndefineSymbol(math, main, textord, \"\\u039b\", \"\\\\Lambda\", true);\ndefineSymbol(math, main, textord, \"\\u039e\", \"\\\\Xi\", true);\ndefineSymbol(math, main, textord, \"\\u03a0\", \"\\\\Pi\", true);\ndefineSymbol(math, main, textord, \"\\u03a3\", \"\\\\Sigma\", true);\ndefineSymbol(math, main, textord, \"\\u03a5\", \"\\\\Upsilon\", true);\ndefineSymbol(math, main, textord, \"\\u03a6\", \"\\\\Phi\", true);\ndefineSymbol(math, main, textord, \"\\u03a8\", \"\\\\Psi\", true);\ndefineSymbol(math, main, textord, \"\\u03a9\", \"\\\\Omega\", true);\ndefineSymbol(math, main, textord, \"A\", \"\\u0391\");\ndefineSymbol(math, main, textord, \"B\", \"\\u0392\");\ndefineSymbol(math, main, textord, \"E\", \"\\u0395\");\ndefineSymbol(math, main, textord, \"Z\", \"\\u0396\");\ndefineSymbol(math, main, textord, \"H\", \"\\u0397\");\ndefineSymbol(math, main, textord, \"I\", \"\\u0399\");\ndefineSymbol(math, main, textord, \"K\", \"\\u039A\");\ndefineSymbol(math, main, textord, \"M\", \"\\u039C\");\ndefineSymbol(math, main, textord, \"N\", \"\\u039D\");\ndefineSymbol(math, main, textord, \"O\", \"\\u039F\");\ndefineSymbol(math, main, textord, \"P\", \"\\u03A1\");\ndefineSymbol(math, main, textord, \"T\", \"\\u03A4\");\ndefineSymbol(math, main, textord, \"X\", \"\\u03A7\");\ndefineSymbol(math, main, textord, \"\\u00ac\", \"\\\\neg\", true);\ndefineSymbol(math, main, textord, \"\\u00ac\", \"\\\\lnot\");\ndefineSymbol(math, main, textord, \"\\u22a4\", \"\\\\top\");\ndefineSymbol(math, main, textord, \"\\u22a5\", \"\\\\bot\");\ndefineSymbol(math, main, textord, \"\\u2205\", \"\\\\emptyset\");\ndefineSymbol(math, ams, textord, \"\\u2205\", \"\\\\varnothing\");\ndefineSymbol(math, main, mathord, \"\\u03b1\", \"\\\\alpha\", true);\ndefineSymbol(math, main, mathord, \"\\u03b2\", \"\\\\beta\", true);\ndefineSymbol(math, main, mathord, \"\\u03b3\", \"\\\\gamma\", true);\ndefineSymbol(math, main, mathord, \"\\u03b4\", \"\\\\delta\", true);\ndefineSymbol(math, main, mathord, \"\\u03f5\", \"\\\\epsilon\", true);\ndefineSymbol(math, main, mathord, \"\\u03b6\", \"\\\\zeta\", true);\ndefineSymbol(math, main, mathord, \"\\u03b7\", \"\\\\eta\", true);\ndefineSymbol(math, main, mathord, \"\\u03b8\", \"\\\\theta\", true);\ndefineSymbol(math, main, mathord, \"\\u03b9\", \"\\\\iota\", true);\ndefineSymbol(math, main, mathord, \"\\u03ba\", \"\\\\kappa\", true);\ndefineSymbol(math, main, mathord, \"\\u03bb\", \"\\\\lambda\", true);\ndefineSymbol(math, main, mathord, \"\\u03bc\", \"\\\\mu\", true);\ndefineSymbol(math, main, mathord, \"\\u03bd\", \"\\\\nu\", true);\ndefineSymbol(math, main, mathord, \"\\u03be\", \"\\\\xi\", true);\ndefineSymbol(math, main, mathord, \"\\u03bf\", \"\\\\omicron\", true);\ndefineSymbol(math, main, mathord, \"\\u03c0\", \"\\\\pi\", true);\ndefineSymbol(math, main, mathord, \"\\u03c1\", \"\\\\rho\", true);\ndefineSymbol(math, main, mathord, \"\\u03c3\", \"\\\\sigma\", true);\ndefineSymbol(math, main, mathord, \"\\u03c4\", \"\\\\tau\", true);\ndefineSymbol(math, main, mathord, \"\\u03c5\", \"\\\\upsilon\", true);\ndefineSymbol(math, main, mathord, \"\\u03d5\", \"\\\\phi\", true);\ndefineSymbol(math, main, mathord, \"\\u03c7\", \"\\\\chi\", true);\ndefineSymbol(math, main, mathord, \"\\u03c8\", \"\\\\psi\", true);\ndefineSymbol(math, main, mathord, \"\\u03c9\", \"\\\\omega\", true);\ndefineSymbol(math, main, mathord, \"\\u03b5\", \"\\\\varepsilon\", true);\ndefineSymbol(math, main, mathord, \"\\u03d1\", \"\\\\vartheta\", true);\ndefineSymbol(math, main, mathord, \"\\u03d6\", \"\\\\varpi\", true);\ndefineSymbol(math, main, mathord, \"\\u03f1\", \"\\\\varrho\", true);\ndefineSymbol(math, main, mathord, \"\\u03c2\", \"\\\\varsigma\", true);\ndefineSymbol(math, main, mathord, \"\\u03c6\", \"\\\\varphi\", true);\ndefineSymbol(math, main, bin, \"\\u2217\", \"*\", true);\ndefineSymbol(math, main, bin, \"+\", \"+\");\ndefineSymbol(math, main, bin, \"\\u2212\", \"-\", true);\ndefineSymbol(math, main, bin, \"\\u22c5\", \"\\\\cdot\", true);\ndefineSymbol(math, main, bin, \"\\u2218\", \"\\\\circ\", true);\ndefineSymbol(math, main, bin, \"\\u00f7\", \"\\\\div\", true);\ndefineSymbol(math, main, bin, \"\\u00b1\", \"\\\\pm\", true);\ndefineSymbol(math, main, bin, \"\\u00d7\", \"\\\\times\", true);\ndefineSymbol(math, main, bin, \"\\u2229\", \"\\\\cap\", true);\ndefineSymbol(math, main, bin, \"\\u222a\", \"\\\\cup\", true);\ndefineSymbol(math, main, bin, \"\\u2216\", \"\\\\setminus\", true);\ndefineSymbol(math, main, bin, \"\\u2227\", \"\\\\land\");\ndefineSymbol(math, main, bin, \"\\u2228\", \"\\\\lor\");\ndefineSymbol(math, main, bin, \"\\u2227\", \"\\\\wedge\", true);\ndefineSymbol(math, main, bin, \"\\u2228\", \"\\\\vee\", true);\ndefineSymbol(math, main, textord, \"\\u221a\", \"\\\\surd\");\ndefineSymbol(math, main, symbols_open, \"\\u27e8\", \"\\\\langle\", true);\ndefineSymbol(math, main, symbols_open, \"\\u2223\", \"\\\\lvert\");\ndefineSymbol(math, main, symbols_open, \"\\u2225\", \"\\\\lVert\");\ndefineSymbol(math, main, symbols_close, \"?\", \"?\");\ndefineSymbol(math, main, symbols_close, \"!\", \"!\");\ndefineSymbol(math, main, symbols_close, \"\\u27e9\", \"\\\\rangle\", true);\ndefineSymbol(math, main, symbols_close, \"\\u2223\", \"\\\\rvert\");\ndefineSymbol(math, main, symbols_close, \"\\u2225\", \"\\\\rVert\");\ndefineSymbol(math, main, rel, \"=\", \"=\");\ndefineSymbol(math, main, rel, \":\", \":\");\ndefineSymbol(math, main, rel, \"\\u2248\", \"\\\\approx\", true);\ndefineSymbol(math, main, rel, \"\\u2245\", \"\\\\cong\", true);\ndefineSymbol(math, main, rel, \"\\u2265\", \"\\\\ge\");\ndefineSymbol(math, main, rel, \"\\u2265\", \"\\\\geq\", true);\ndefineSymbol(math, main, rel, \"\\u2190\", \"\\\\gets\");\ndefineSymbol(math, main, rel, \">\", \"\\\\gt\", true);\ndefineSymbol(math, main, rel, \"\\u2208\", \"\\\\in\", true);\ndefineSymbol(math, main, rel, \"\\ue020\", \"\\\\@not\");\ndefineSymbol(math, main, rel, \"\\u2282\", \"\\\\subset\", true);\ndefineSymbol(math, main, rel, \"\\u2283\", \"\\\\supset\", true);\ndefineSymbol(math, main, rel, \"\\u2286\", \"\\\\subseteq\", true);\ndefineSymbol(math, main, rel, \"\\u2287\", \"\\\\supseteq\", true);\ndefineSymbol(math, ams, rel, \"\\u2288\", \"\\\\nsubseteq\", true);\ndefineSymbol(math, ams, rel, \"\\u2289\", \"\\\\nsupseteq\", true);\ndefineSymbol(math, main, rel, \"\\u22a8\", \"\\\\models\");\ndefineSymbol(math, main, rel, \"\\u2190\", \"\\\\leftarrow\", true);\ndefineSymbol(math, main, rel, \"\\u2264\", \"\\\\le\");\ndefineSymbol(math, main, rel, \"\\u2264\", \"\\\\leq\", true);\ndefineSymbol(math, main, rel, \"<\", \"\\\\lt\", true);\ndefineSymbol(math, main, rel, \"\\u2192\", \"\\\\rightarrow\", true);\ndefineSymbol(math, main, rel, \"\\u2192\", \"\\\\to\");\ndefineSymbol(math, ams, rel, \"\\u2271\", \"\\\\ngeq\", true);\ndefineSymbol(math, ams, rel, \"\\u2270\", \"\\\\nleq\", true);\ndefineSymbol(math, main, spacing, \"\\u00a0\", \"\\\\ \");\ndefineSymbol(math, main, spacing, \"\\u00a0\", \"\\\\space\"); // Ref: LaTeX Source 2e: \\DeclareRobustCommand{\\nobreakspace}{%\n\ndefineSymbol(math, main, spacing, \"\\u00a0\", \"\\\\nobreakspace\");\ndefineSymbol(symbols_text, main, spacing, \"\\u00a0\", \"\\\\ \");\ndefineSymbol(symbols_text, main, spacing, \"\\u00a0\", \" \");\ndefineSymbol(symbols_text, main, spacing, \"\\u00a0\", \"\\\\space\");\ndefineSymbol(symbols_text, main, spacing, \"\\u00a0\", \"\\\\nobreakspace\");\ndefineSymbol(math, main, spacing, null, \"\\\\nobreak\");\ndefineSymbol(math, main, spacing, null, \"\\\\allowbreak\");\ndefineSymbol(math, main, punct, \",\", \",\");\ndefineSymbol(math, main, punct, \";\", \";\");\ndefineSymbol(math, ams, bin, \"\\u22bc\", \"\\\\barwedge\", true);\ndefineSymbol(math, ams, bin, \"\\u22bb\", \"\\\\veebar\", true);\ndefineSymbol(math, main, bin, \"\\u2299\", \"\\\\odot\", true);\ndefineSymbol(math, main, bin, \"\\u2295\", \"\\\\oplus\", true);\ndefineSymbol(math, main, bin, \"\\u2297\", \"\\\\otimes\", true);\ndefineSymbol(math, main, textord, \"\\u2202\", \"\\\\partial\", true);\ndefineSymbol(math, main, bin, \"\\u2298\", \"\\\\oslash\", true);\ndefineSymbol(math, ams, bin, \"\\u229a\", \"\\\\circledcirc\", true);\ndefineSymbol(math, ams, bin, \"\\u22a1\", \"\\\\boxdot\", true);\ndefineSymbol(math, main, bin, \"\\u25b3\", \"\\\\bigtriangleup\");\ndefineSymbol(math, main, bin, \"\\u25bd\", \"\\\\bigtriangledown\");\ndefineSymbol(math, main, bin, \"\\u2020\", \"\\\\dagger\");\ndefineSymbol(math, main, bin, \"\\u22c4\", \"\\\\diamond\");\ndefineSymbol(math, main, bin, \"\\u22c6\", \"\\\\star\");\ndefineSymbol(math, main, bin, \"\\u25c3\", \"\\\\triangleleft\");\ndefineSymbol(math, main, bin, \"\\u25b9\", \"\\\\triangleright\");\ndefineSymbol(math, main, symbols_open, \"{\", \"\\\\{\");\ndefineSymbol(symbols_text, main, textord, \"{\", \"\\\\{\");\ndefineSymbol(symbols_text, main, textord, \"{\", \"\\\\textbraceleft\");\ndefineSymbol(math, main, symbols_close, \"}\", \"\\\\}\");\ndefineSymbol(symbols_text, main, textord, \"}\", \"\\\\}\");\ndefineSymbol(symbols_text, main, textord, \"}\", \"\\\\textbraceright\");\ndefineSymbol(math, main, symbols_open, \"{\", \"\\\\lbrace\");\ndefineSymbol(math, main, symbols_close, \"}\", \"\\\\rbrace\");\ndefineSymbol(math, main, symbols_open, \"[\", \"\\\\lbrack\", true);\ndefineSymbol(symbols_text, main, textord, \"[\", \"\\\\lbrack\", true);\ndefineSymbol(math, main, symbols_close, \"]\", \"\\\\rbrack\", true);\ndefineSymbol(symbols_text, main, textord, \"]\", \"\\\\rbrack\", true);\ndefineSymbol(math, main, symbols_open, \"(\", \"\\\\lparen\", true);\ndefineSymbol(math, main, symbols_close, \")\", \"\\\\rparen\", true);\ndefineSymbol(symbols_text, main, textord, \"<\", \"\\\\textless\", true); // in T1 fontenc\n\ndefineSymbol(symbols_text, main, textord, \">\", \"\\\\textgreater\", true); // in T1 fontenc\n\ndefineSymbol(math, main, symbols_open, \"\\u230a\", \"\\\\lfloor\", true);\ndefineSymbol(math, main, symbols_close, \"\\u230b\", \"\\\\rfloor\", true);\ndefineSymbol(math, main, symbols_open, \"\\u2308\", \"\\\\lceil\", true);\ndefineSymbol(math, main, symbols_close, \"\\u2309\", \"\\\\rceil\", true);\ndefineSymbol(math, main, textord, \"\\\\\", \"\\\\backslash\");\ndefineSymbol(math, main, textord, \"\\u2223\", \"|\");\ndefineSymbol(math, main, textord, \"\\u2223\", \"\\\\vert\");\ndefineSymbol(symbols_text, main, textord, \"|\", \"\\\\textbar\", true); // in T1 fontenc\n\ndefineSymbol(math, main, textord, \"\\u2225\", \"\\\\|\");\ndefineSymbol(math, main, textord, \"\\u2225\", \"\\\\Vert\");\ndefineSymbol(symbols_text, main, textord, \"\\u2225\", \"\\\\textbardbl\");\ndefineSymbol(symbols_text, main, textord, \"~\", \"\\\\textasciitilde\");\ndefineSymbol(symbols_text, main, textord, \"\\\\\", \"\\\\textbackslash\");\ndefineSymbol(symbols_text, main, textord, \"^\", \"\\\\textasciicircum\");\ndefineSymbol(math, main, rel, \"\\u2191\", \"\\\\uparrow\", true);\ndefineSymbol(math, main, rel, \"\\u21d1\", \"\\\\Uparrow\", true);\ndefineSymbol(math, main, rel, \"\\u2193\", \"\\\\downarrow\", true);\ndefineSymbol(math, main, rel, \"\\u21d3\", \"\\\\Downarrow\", true);\ndefineSymbol(math, main, rel, \"\\u2195\", \"\\\\updownarrow\", true);\ndefineSymbol(math, main, rel, \"\\u21d5\", \"\\\\Updownarrow\", true);\ndefineSymbol(math, main, op, \"\\u2210\", \"\\\\coprod\");\ndefineSymbol(math, main, op, \"\\u22c1\", \"\\\\bigvee\");\ndefineSymbol(math, main, op, \"\\u22c0\", \"\\\\bigwedge\");\ndefineSymbol(math, main, op, \"\\u2a04\", \"\\\\biguplus\");\ndefineSymbol(math, main, op, \"\\u22c2\", \"\\\\bigcap\");\ndefineSymbol(math, main, op, \"\\u22c3\", \"\\\\bigcup\");\ndefineSymbol(math, main, op, \"\\u222b\", \"\\\\int\");\ndefineSymbol(math, main, op, \"\\u222b\", \"\\\\intop\");\ndefineSymbol(math, main, op, \"\\u222c\", \"\\\\iint\");\ndefineSymbol(math, main, op, \"\\u222d\", \"\\\\iiint\");\ndefineSymbol(math, main, op, \"\\u220f\", \"\\\\prod\");\ndefineSymbol(math, main, op, \"\\u2211\", \"\\\\sum\");\ndefineSymbol(math, main, op, \"\\u2a02\", \"\\\\bigotimes\");\ndefineSymbol(math, main, op, \"\\u2a01\", \"\\\\bigoplus\");\ndefineSymbol(math, main, op, \"\\u2a00\", \"\\\\bigodot\");\ndefineSymbol(math, main, op, \"\\u222e\", \"\\\\oint\");\ndefineSymbol(math, main, op, \"\\u222f\", \"\\\\oiint\");\ndefineSymbol(math, main, op, \"\\u2230\", \"\\\\oiiint\");\ndefineSymbol(math, main, op, \"\\u2a06\", \"\\\\bigsqcup\");\ndefineSymbol(math, main, op, \"\\u222b\", \"\\\\smallint\");\ndefineSymbol(symbols_text, main, inner, \"\\u2026\", \"\\\\textellipsis\");\ndefineSymbol(math, main, inner, \"\\u2026\", \"\\\\mathellipsis\");\ndefineSymbol(symbols_text, main, inner, \"\\u2026\", \"\\\\ldots\", true);\ndefineSymbol(math, main, inner, \"\\u2026\", \"\\\\ldots\", true);\ndefineSymbol(math, main, inner, \"\\u22ef\", \"\\\\@cdots\", true);\ndefineSymbol(math, main, inner, \"\\u22f1\", \"\\\\ddots\", true);\ndefineSymbol(math, main, textord, \"\\u22ee\", \"\\\\varvdots\"); // \\vdots is a macro\n\ndefineSymbol(math, main, accent, \"\\u02ca\", \"\\\\acute\");\ndefineSymbol(math, main, accent, \"\\u02cb\", \"\\\\grave\");\ndefineSymbol(math, main, accent, \"\\u00a8\", \"\\\\ddot\");\ndefineSymbol(math, main, accent, \"\\u007e\", \"\\\\tilde\");\ndefineSymbol(math, main, accent, \"\\u02c9\", \"\\\\bar\");\ndefineSymbol(math, main, accent, \"\\u02d8\", \"\\\\breve\");\ndefineSymbol(math, main, accent, \"\\u02c7\", \"\\\\check\");\ndefineSymbol(math, main, accent, \"\\u005e\", \"\\\\hat\");\ndefineSymbol(math, main, accent, \"\\u20d7\", \"\\\\vec\");\ndefineSymbol(math, main, accent, \"\\u02d9\", \"\\\\dot\");\ndefineSymbol(math, main, accent, \"\\u02da\", \"\\\\mathring\"); // \\imath and \\jmath should be invariant to \\mathrm, \\mathbf, etc., so use PUA\n\ndefineSymbol(math, main, mathord, \"\\ue131\", \"\\\\@imath\");\ndefineSymbol(math, main, mathord, \"\\ue237\", \"\\\\@jmath\");\ndefineSymbol(math, main, textord, \"\\u0131\", \"\\u0131\");\ndefineSymbol(math, main, textord, \"\\u0237\", \"\\u0237\");\ndefineSymbol(symbols_text, main, textord, \"\\u0131\", \"\\\\i\", true);\ndefineSymbol(symbols_text, main, textord, \"\\u0237\", \"\\\\j\", true);\ndefineSymbol(symbols_text, main, textord, \"\\u00df\", \"\\\\ss\", true);\ndefineSymbol(symbols_text, main, textord, \"\\u00e6\", \"\\\\ae\", true);\ndefineSymbol(symbols_text, main, textord, \"\\u0153\", \"\\\\oe\", true);\ndefineSymbol(symbols_text, main, textord, \"\\u00f8\", \"\\\\o\", true);\ndefineSymbol(symbols_text, main, textord, \"\\u00c6\", \"\\\\AE\", true);\ndefineSymbol(symbols_text, main, textord, \"\\u0152\", \"\\\\OE\", true);\ndefineSymbol(symbols_text, main, textord, \"\\u00d8\", \"\\\\O\", true);\ndefineSymbol(symbols_text, main, accent, \"\\u02ca\", \"\\\\'\"); // acute\n\ndefineSymbol(symbols_text, main, accent, \"\\u02cb\", \"\\\\`\"); // grave\n\ndefineSymbol(symbols_text, main, accent, \"\\u02c6\", \"\\\\^\"); // circumflex\n\ndefineSymbol(symbols_text, main, accent, \"\\u02dc\", \"\\\\~\"); // tilde\n\ndefineSymbol(symbols_text, main, accent, \"\\u02c9\", \"\\\\=\"); // macron\n\ndefineSymbol(symbols_text, main, accent, \"\\u02d8\", \"\\\\u\"); // breve\n\ndefineSymbol(symbols_text, main, accent, \"\\u02d9\", \"\\\\.\"); // dot above\n\ndefineSymbol(symbols_text, main, accent, \"\\u00b8\", \"\\\\c\"); // cedilla\n\ndefineSymbol(symbols_text, main, accent, \"\\u02da\", \"\\\\r\"); // ring above\n\ndefineSymbol(symbols_text, main, accent, \"\\u02c7\", \"\\\\v\"); // caron\n\ndefineSymbol(symbols_text, main, accent, \"\\u00a8\", '\\\\\"'); // diaresis\n\ndefineSymbol(symbols_text, main, accent, \"\\u02dd\", \"\\\\H\"); // double acute\n\ndefineSymbol(symbols_text, main, accent, \"\\u25ef\", \"\\\\textcircled\"); // \\bigcirc glyph\n// These ligatures are detected and created in Parser.js's `formLigatures`.\n\nconst ligatures = {\n  \"--\": true,\n  \"---\": true,\n  \"``\": true,\n  \"''\": true\n};\ndefineSymbol(symbols_text, main, textord, \"\\u2013\", \"--\", true);\ndefineSymbol(symbols_text, main, textord, \"\\u2013\", \"\\\\textendash\");\ndefineSymbol(symbols_text, main, textord, \"\\u2014\", \"---\", true);\ndefineSymbol(symbols_text, main, textord, \"\\u2014\", \"\\\\textemdash\");\ndefineSymbol(symbols_text, main, textord, \"\\u2018\", \"`\", true);\ndefineSymbol(symbols_text, main, textord, \"\\u2018\", \"\\\\textquoteleft\");\ndefineSymbol(symbols_text, main, textord, \"\\u2019\", \"'\", true);\ndefineSymbol(symbols_text, main, textord, \"\\u2019\", \"\\\\textquoteright\");\ndefineSymbol(symbols_text, main, textord, \"\\u201c\", \"``\", true);\ndefineSymbol(symbols_text, main, textord, \"\\u201c\", \"\\\\textquotedblleft\");\ndefineSymbol(symbols_text, main, textord, \"\\u201d\", \"''\", true);\ndefineSymbol(symbols_text, main, textord, \"\\u201d\", \"\\\\textquotedblright\"); //  \\degree from gensymb package\n\ndefineSymbol(math, main, textord, \"\\u00b0\", \"\\\\degree\", true);\ndefineSymbol(symbols_text, main, textord, \"\\u00b0\", \"\\\\degree\"); // \\textdegree from inputenc package\n\ndefineSymbol(symbols_text, main, textord, \"\\u00b0\", \"\\\\textdegree\", true); // TODO: In LaTeX, \\pounds can generate a different character in text and math\n// mode, but among our fonts, only Main-Regular defines this character \"163\".\n\ndefineSymbol(math, main, textord, \"\\u00a3\", \"\\\\pounds\");\ndefineSymbol(math, main, textord, \"\\u00a3\", \"\\\\mathsterling\", true);\ndefineSymbol(symbols_text, main, textord, \"\\u00a3\", \"\\\\pounds\");\ndefineSymbol(symbols_text, main, textord, \"\\u00a3\", \"\\\\textsterling\", true);\ndefineSymbol(math, ams, textord, \"\\u2720\", \"\\\\maltese\");\ndefineSymbol(symbols_text, ams, textord, \"\\u2720\", \"\\\\maltese\"); // There are lots of symbols which are the same, so we add them in afterwards.\n// All of these are textords in math mode\n\nconst mathTextSymbols = \"0123456789/@.\\\"\";\n\nfor (let i = 0; i < mathTextSymbols.length; i++) {\n  const ch = mathTextSymbols.charAt(i);\n  defineSymbol(math, main, textord, ch, ch);\n} // All of these are textords in text mode\n\n\nconst textSymbols = \"0123456789!@*()-=+\\\";:?/.,\";\n\nfor (let i = 0; i < textSymbols.length; i++) {\n  const ch = textSymbols.charAt(i);\n  defineSymbol(symbols_text, main, textord, ch, ch);\n} // All of these are textords in text mode, and mathords in math mode\n\n\nconst letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n\nfor (let i = 0; i < letters.length; i++) {\n  const ch = letters.charAt(i);\n  defineSymbol(math, main, mathord, ch, ch);\n  defineSymbol(symbols_text, main, textord, ch, ch);\n} // Blackboard bold and script letters in Unicode range\n\n\ndefineSymbol(math, ams, textord, \"C\", \"\\u2102\"); // blackboard bold\n\ndefineSymbol(symbols_text, ams, textord, \"C\", \"\\u2102\");\ndefineSymbol(math, ams, textord, \"H\", \"\\u210D\");\ndefineSymbol(symbols_text, ams, textord, \"H\", \"\\u210D\");\ndefineSymbol(math, ams, textord, \"N\", \"\\u2115\");\ndefineSymbol(symbols_text, ams, textord, \"N\", \"\\u2115\");\ndefineSymbol(math, ams, textord, \"P\", \"\\u2119\");\ndefineSymbol(symbols_text, ams, textord, \"P\", \"\\u2119\");\ndefineSymbol(math, ams, textord, \"Q\", \"\\u211A\");\ndefineSymbol(symbols_text, ams, textord, \"Q\", \"\\u211A\");\ndefineSymbol(math, ams, textord, \"R\", \"\\u211D\");\ndefineSymbol(symbols_text, ams, textord, \"R\", \"\\u211D\");\ndefineSymbol(math, ams, textord, \"Z\", \"\\u2124\");\ndefineSymbol(symbols_text, ams, textord, \"Z\", \"\\u2124\");\ndefineSymbol(math, main, mathord, \"h\", \"\\u210E\"); // italic h, Planck constant\n\ndefineSymbol(symbols_text, main, mathord, \"h\", \"\\u210E\"); // The next loop loads wide (surrogate pair) characters.\n// We support some letters in the Unicode range U+1D400 to U+1D7FF,\n// Mathematical Alphanumeric Symbols.\n// Some editors do not deal well with wide characters. So don't write the\n// string into this file. Instead, create the string from the surrogate pair.\n\nlet wideChar = \"\";\n\nfor (let i = 0; i < letters.length; i++) {\n  const ch = letters.charAt(i); // The hex numbers in the next line are a surrogate pair.\n  // 0xD835 is the high surrogate for all letters in the range we support.\n  // 0xDC00 is the low surrogate for bold A.\n\n  wideChar = String.fromCharCode(0xD835, 0xDC00 + i); // A-Z a-z bold\n\n  defineSymbol(math, main, mathord, ch, wideChar);\n  defineSymbol(symbols_text, main, textord, ch, wideChar);\n  wideChar = String.fromCharCode(0xD835, 0xDC34 + i); // A-Z a-z italic\n\n  defineSymbol(math, main, mathord, ch, wideChar);\n  defineSymbol(symbols_text, main, textord, ch, wideChar);\n  wideChar = String.fromCharCode(0xD835, 0xDC68 + i); // A-Z a-z bold italic\n\n  defineSymbol(math, main, mathord, ch, wideChar);\n  defineSymbol(symbols_text, main, textord, ch, wideChar);\n  wideChar = String.fromCharCode(0xD835, 0xDD04 + i); // A-Z a-z Fraktur\n\n  defineSymbol(math, main, mathord, ch, wideChar);\n  defineSymbol(symbols_text, main, textord, ch, wideChar);\n  wideChar = String.fromCharCode(0xD835, 0xDD6C + i); // A-Z a-z bold Fraktur\n\n  defineSymbol(math, main, mathord, ch, wideChar);\n  defineSymbol(symbols_text, main, textord, ch, wideChar);\n  wideChar = String.fromCharCode(0xD835, 0xDDA0 + i); // A-Z a-z sans-serif\n\n  defineSymbol(math, main, mathord, ch, wideChar);\n  defineSymbol(symbols_text, main, textord, ch, wideChar);\n  wideChar = String.fromCharCode(0xD835, 0xDDD4 + i); // A-Z a-z sans bold\n\n  defineSymbol(math, main, mathord, ch, wideChar);\n  defineSymbol(symbols_text, main, textord, ch, wideChar);\n  wideChar = String.fromCharCode(0xD835, 0xDE08 + i); // A-Z a-z sans italic\n\n  defineSymbol(math, main, mathord, ch, wideChar);\n  defineSymbol(symbols_text, main, textord, ch, wideChar);\n  wideChar = String.fromCharCode(0xD835, 0xDE70 + i); // A-Z a-z monospace\n\n  defineSymbol(math, main, mathord, ch, wideChar);\n  defineSymbol(symbols_text, main, textord, ch, wideChar);\n\n  if (i < 26) {\n    // KaTeX fonts have only capital letters for blackboard bold and script.\n    // See exception for k below.\n    wideChar = String.fromCharCode(0xD835, 0xDD38 + i); // A-Z double struck\n\n    defineSymbol(math, main, mathord, ch, wideChar);\n    defineSymbol(symbols_text, main, textord, ch, wideChar);\n    wideChar = String.fromCharCode(0xD835, 0xDC9C + i); // A-Z script\n\n    defineSymbol(math, main, mathord, ch, wideChar);\n    defineSymbol(symbols_text, main, textord, ch, wideChar);\n  } // TODO: Add bold script when it is supported by a KaTeX font.\n\n} // \"k\" is the only double struck lower case letter in the KaTeX fonts.\n\n\nwideChar = String.fromCharCode(0xD835, 0xDD5C); // k double struck\n\ndefineSymbol(math, main, mathord, \"k\", wideChar);\ndefineSymbol(symbols_text, main, textord, \"k\", wideChar); // Next, some wide character numerals\n\nfor (let i = 0; i < 10; i++) {\n  const ch = i.toString();\n  wideChar = String.fromCharCode(0xD835, 0xDFCE + i); // 0-9 bold\n\n  defineSymbol(math, main, mathord, ch, wideChar);\n  defineSymbol(symbols_text, main, textord, ch, wideChar);\n  wideChar = String.fromCharCode(0xD835, 0xDFE2 + i); // 0-9 sans serif\n\n  defineSymbol(math, main, mathord, ch, wideChar);\n  defineSymbol(symbols_text, main, textord, ch, wideChar);\n  wideChar = String.fromCharCode(0xD835, 0xDFEC + i); // 0-9 bold sans\n\n  defineSymbol(math, main, mathord, ch, wideChar);\n  defineSymbol(symbols_text, main, textord, ch, wideChar);\n  wideChar = String.fromCharCode(0xD835, 0xDFF6 + i); // 0-9 monospace\n\n  defineSymbol(math, main, mathord, ch, wideChar);\n  defineSymbol(symbols_text, main, textord, ch, wideChar);\n} // We add these Latin-1 letters as symbols for backwards-compatibility,\n// but they are not actually in the font, nor are they supported by the\n// Unicode accent mechanism, so they fall back to Times font and look ugly.\n// TODO(edemaine): Fix this.\n\n\nconst extraLatin = \"\\u00d0\\u00de\\u00fe\";\n\nfor (let i = 0; i < extraLatin.length; i++) {\n  const ch = extraLatin.charAt(i);\n  defineSymbol(math, main, mathord, ch, ch);\n  defineSymbol(symbols_text, main, textord, ch, ch);\n}\n;// CONCATENATED MODULE: ./src/wide-character.js\n/**\n * This file provides support for Unicode range U+1D400 to U+1D7FF,\n * Mathematical Alphanumeric Symbols.\n *\n * Function wideCharacterFont takes a wide character as input and returns\n * the font information necessary to render it properly.\n */\n\n/**\n * Data below is from https://www.unicode.org/charts/PDF/U1D400.pdf\n * That document sorts characters into groups by font type, say bold or italic.\n *\n * In the arrays below, each subarray consists three elements:\n *      * The CSS class of that group when in math mode.\n *      * The CSS class of that group when in text mode.\n *      * The font name, so that KaTeX can get font metrics.\n */\n\nconst wideLatinLetterData = [[\"mathbf\", \"textbf\", \"Main-Bold\"], // A-Z bold upright\n[\"mathbf\", \"textbf\", \"Main-Bold\"], // a-z bold upright\n[\"mathnormal\", \"textit\", \"Math-Italic\"], // A-Z italic\n[\"mathnormal\", \"textit\", \"Math-Italic\"], // a-z italic\n[\"boldsymbol\", \"boldsymbol\", \"Main-BoldItalic\"], // A-Z bold italic\n[\"boldsymbol\", \"boldsymbol\", \"Main-BoldItalic\"], // a-z bold italic\n// Map fancy A-Z letters to script, not calligraphic.\n// This aligns with unicode-math and math fonts (except Cambria Math).\n[\"mathscr\", \"textscr\", \"Script-Regular\"], // A-Z script\n[\"\", \"\", \"\"], // a-z script.  No font\n[\"\", \"\", \"\"], // A-Z bold script. No font\n[\"\", \"\", \"\"], // a-z bold script. No font\n[\"mathfrak\", \"textfrak\", \"Fraktur-Regular\"], // A-Z Fraktur\n[\"mathfrak\", \"textfrak\", \"Fraktur-Regular\"], // a-z Fraktur\n[\"mathbb\", \"textbb\", \"AMS-Regular\"], // A-Z double-struck\n[\"mathbb\", \"textbb\", \"AMS-Regular\"], // k double-struck\n// Note that we are using a bold font, but font metrics for regular Fraktur.\n[\"mathboldfrak\", \"textboldfrak\", \"Fraktur-Regular\"], // A-Z bold Fraktur\n[\"mathboldfrak\", \"textboldfrak\", \"Fraktur-Regular\"], // a-z bold Fraktur\n[\"mathsf\", \"textsf\", \"SansSerif-Regular\"], // A-Z sans-serif\n[\"mathsf\", \"textsf\", \"SansSerif-Regular\"], // a-z sans-serif\n[\"mathboldsf\", \"textboldsf\", \"SansSerif-Bold\"], // A-Z bold sans-serif\n[\"mathboldsf\", \"textboldsf\", \"SansSerif-Bold\"], // a-z bold sans-serif\n[\"mathitsf\", \"textitsf\", \"SansSerif-Italic\"], // A-Z italic sans-serif\n[\"mathitsf\", \"textitsf\", \"SansSerif-Italic\"], // a-z italic sans-serif\n[\"\", \"\", \"\"], // A-Z bold italic sans. No font\n[\"\", \"\", \"\"], // a-z bold italic sans. No font\n[\"mathtt\", \"texttt\", \"Typewriter-Regular\"], // A-Z monospace\n[\"mathtt\", \"texttt\", \"Typewriter-Regular\"] // a-z monospace\n];\nconst wideNumeralData = [[\"mathbf\", \"textbf\", \"Main-Bold\"], // 0-9 bold\n[\"\", \"\", \"\"], // 0-9 double-struck. No KaTeX font.\n[\"mathsf\", \"textsf\", \"SansSerif-Regular\"], // 0-9 sans-serif\n[\"mathboldsf\", \"textboldsf\", \"SansSerif-Bold\"], // 0-9 bold sans-serif\n[\"mathtt\", \"texttt\", \"Typewriter-Regular\"] // 0-9 monospace\n];\nconst wideCharacterFont = function (wideChar, mode) {\n  // IE doesn't support codePointAt(). So work with the surrogate pair.\n  const H = wideChar.charCodeAt(0); // high surrogate\n\n  const L = wideChar.charCodeAt(1); // low surrogate\n\n  const codePoint = (H - 0xD800) * 0x400 + (L - 0xDC00) + 0x10000;\n  const j = mode === \"math\" ? 0 : 1; // column index for CSS class.\n\n  if (0x1D400 <= codePoint && codePoint < 0x1D6A4) {\n    // wideLatinLetterData contains exactly 26 chars on each row.\n    // So we can calculate the relevant row. No traverse necessary.\n    const i = Math.floor((codePoint - 0x1D400) / 26);\n    return [wideLatinLetterData[i][2], wideLatinLetterData[i][j]];\n  } else if (0x1D7CE <= codePoint && codePoint <= 0x1D7FF) {\n    // Numerals, ten per row.\n    const i = Math.floor((codePoint - 0x1D7CE) / 10);\n    return [wideNumeralData[i][2], wideNumeralData[i][j]];\n  } else if (codePoint === 0x1D6A5 || codePoint === 0x1D6A6) {\n    // dotless i or j\n    return [wideLatinLetterData[0][2], wideLatinLetterData[0][j]];\n  } else if (0x1D6A6 < codePoint && codePoint < 0x1D7CE) {\n    // Greek letters. Not supported, yet.\n    return [\"\", \"\"];\n  } else {\n    // We don't support any wide characters outside 1D4001D7FF.\n    throw new src_ParseError(\"Unsupported character: \" + wideChar);\n  }\n};\n;// CONCATENATED MODULE: ./src/buildCommon.js\n/* eslint no-console:0 */\n\n/**\n * This module contains general functions that can be used for building\n * different kinds of domTree nodes in a consistent manner.\n */\n\n\n\n\n\n\n\n/**\n * Looks up the given symbol in fontMetrics, after applying any symbol\n * replacements defined in symbol.js\n */\nconst lookupSymbol = function (value, // TODO(#963): Use a union type for this.\nfontName, mode) {\n  // Replace the value with its replaced value from symbol.js\n  if (src_symbols[mode][value] && src_symbols[mode][value].replace) {\n    value = src_symbols[mode][value].replace;\n  }\n\n  return {\n    value: value,\n    metrics: getCharacterMetrics(value, fontName, mode)\n  };\n};\n/**\n * Makes a symbolNode after translation via the list of symbols in symbols.js.\n * Correctly pulls out metrics for the character, and optionally takes a list of\n * classes to be attached to the node.\n *\n * TODO: make argument order closer to makeSpan\n * TODO: add a separate argument for math class (e.g. `mop`, `mbin`), which\n * should if present come first in `classes`.\n * TODO(#953): Make `options` mandatory and always pass it in.\n */\n\n\nconst makeSymbol = function (value, fontName, mode, options, classes) {\n  const lookup = lookupSymbol(value, fontName, mode);\n  const metrics = lookup.metrics;\n  value = lookup.value;\n  let symbolNode;\n\n  if (metrics) {\n    let italic = metrics.italic;\n\n    if (mode === \"text\" || options && options.font === \"mathit\") {\n      italic = 0;\n    }\n\n    symbolNode = new SymbolNode(value, metrics.height, metrics.depth, italic, metrics.skew, metrics.width, classes);\n  } else {\n    // TODO(emily): Figure out a good way to only print this in development\n    typeof console !== \"undefined\" && console.warn(\"No character metrics \" + (\"for '\" + value + \"' in style '\" + fontName + \"' and mode '\" + mode + \"'\"));\n    symbolNode = new SymbolNode(value, 0, 0, 0, 0, 0, classes);\n  }\n\n  if (options) {\n    symbolNode.maxFontSize = options.sizeMultiplier;\n\n    if (options.style.isTight()) {\n      symbolNode.classes.push(\"mtight\");\n    }\n\n    const color = options.getColor();\n\n    if (color) {\n      symbolNode.style.color = color;\n    }\n  }\n\n  return symbolNode;\n};\n/**\n * Makes a symbol in Main-Regular or AMS-Regular.\n * Used for rel, bin, open, close, inner, and punct.\n */\n\n\nconst mathsym = function (value, mode, options, classes) {\n  if (classes === void 0) {\n    classes = [];\n  }\n\n  // Decide what font to render the symbol in by its entry in the symbols\n  // table.\n  // Have a special case for when the value = \\ because the \\ is used as a\n  // textord in unsupported command errors but cannot be parsed as a regular\n  // text ordinal and is therefore not present as a symbol in the symbols\n  // table for text, as well as a special case for boldsymbol because it\n  // can be used for bold + and -\n  if (options.font === \"boldsymbol\" && lookupSymbol(value, \"Main-Bold\", mode).metrics) {\n    return makeSymbol(value, \"Main-Bold\", mode, options, classes.concat([\"mathbf\"]));\n  } else if (value === \"\\\\\" || src_symbols[mode][value].font === \"main\") {\n    return makeSymbol(value, \"Main-Regular\", mode, options, classes);\n  } else {\n    return makeSymbol(value, \"AMS-Regular\", mode, options, classes.concat([\"amsrm\"]));\n  }\n};\n/**\n * Determines which of the two font names (Main-Bold and Math-BoldItalic) and\n * corresponding style tags (mathbf or boldsymbol) to use for font \"boldsymbol\",\n * depending on the symbol.  Use this function instead of fontMap for font\n * \"boldsymbol\".\n */\n\n\nconst boldsymbol = function (value, mode, options, classes, type) {\n  if (type !== \"textord\" && lookupSymbol(value, \"Math-BoldItalic\", mode).metrics) {\n    return {\n      fontName: \"Math-BoldItalic\",\n      fontClass: \"boldsymbol\"\n    };\n  } else {\n    // Some glyphs do not exist in Math-BoldItalic so we need to use\n    // Main-Bold instead.\n    return {\n      fontName: \"Main-Bold\",\n      fontClass: \"mathbf\"\n    };\n  }\n};\n/**\n * Makes either a mathord or textord in the correct font and color.\n */\n\n\nconst makeOrd = function (group, options, type) {\n  const mode = group.mode;\n  const text = group.text;\n  const classes = [\"mord\"]; // Math mode or Old font (i.e. \\rm)\n\n  const isFont = mode === \"math\" || mode === \"text\" && options.font;\n  const fontOrFamily = isFont ? options.font : options.fontFamily;\n  let wideFontName = \"\";\n  let wideFontClass = \"\";\n\n  if (text.charCodeAt(0) === 0xD835) {\n    [wideFontName, wideFontClass] = wideCharacterFont(text, mode);\n  }\n\n  if (wideFontName.length > 0) {\n    // surrogate pairs get special treatment\n    return makeSymbol(text, wideFontName, mode, options, classes.concat(wideFontClass));\n  } else if (fontOrFamily) {\n    let fontName;\n    let fontClasses;\n\n    if (fontOrFamily === \"boldsymbol\") {\n      const fontData = boldsymbol(text, mode, options, classes, type);\n      fontName = fontData.fontName;\n      fontClasses = [fontData.fontClass];\n    } else if (isFont) {\n      fontName = fontMap[fontOrFamily].fontName;\n      fontClasses = [fontOrFamily];\n    } else {\n      fontName = retrieveTextFontName(fontOrFamily, options.fontWeight, options.fontShape);\n      fontClasses = [fontOrFamily, options.fontWeight, options.fontShape];\n    }\n\n    if (lookupSymbol(text, fontName, mode).metrics) {\n      return makeSymbol(text, fontName, mode, options, classes.concat(fontClasses));\n    } else if (ligatures.hasOwnProperty(text) && fontName.slice(0, 10) === \"Typewriter\") {\n      // Deconstruct ligatures in monospace fonts (\\texttt, \\tt).\n      const parts = [];\n\n      for (let i = 0; i < text.length; i++) {\n        parts.push(makeSymbol(text[i], fontName, mode, options, classes.concat(fontClasses)));\n      }\n\n      return makeFragment(parts);\n    }\n  } // Makes a symbol in the default font for mathords and textords.\n\n\n  if (type === \"mathord\") {\n    return makeSymbol(text, \"Math-Italic\", mode, options, classes.concat([\"mathnormal\"]));\n  } else if (type === \"textord\") {\n    const font = src_symbols[mode][text] && src_symbols[mode][text].font;\n\n    if (font === \"ams\") {\n      const fontName = retrieveTextFontName(\"amsrm\", options.fontWeight, options.fontShape);\n      return makeSymbol(text, fontName, mode, options, classes.concat(\"amsrm\", options.fontWeight, options.fontShape));\n    } else if (font === \"main\" || !font) {\n      const fontName = retrieveTextFontName(\"textrm\", options.fontWeight, options.fontShape);\n      return makeSymbol(text, fontName, mode, options, classes.concat(options.fontWeight, options.fontShape));\n    } else {\n      // fonts added by plugins\n      const fontName = retrieveTextFontName(font, options.fontWeight, options.fontShape); // We add font name as a css class\n\n      return makeSymbol(text, fontName, mode, options, classes.concat(fontName, options.fontWeight, options.fontShape));\n    }\n  } else {\n    throw new Error(\"unexpected type: \" + type + \" in makeOrd\");\n  }\n};\n/**\n * Returns true if subsequent symbolNodes have the same classes, skew, maxFont,\n * and styles.\n */\n\n\nconst canCombine = (prev, next) => {\n  if (createClass(prev.classes) !== createClass(next.classes) || prev.skew !== next.skew || prev.maxFontSize !== next.maxFontSize) {\n    return false;\n  } // If prev and next both are just \"mbin\"s or \"mord\"s we don't combine them\n  // so that the proper spacing can be preserved.\n\n\n  if (prev.classes.length === 1) {\n    const cls = prev.classes[0];\n\n    if (cls === \"mbin\" || cls === \"mord\") {\n      return false;\n    }\n  }\n\n  for (const style in prev.style) {\n    if (prev.style.hasOwnProperty(style) && prev.style[style] !== next.style[style]) {\n      return false;\n    }\n  }\n\n  for (const style in next.style) {\n    if (next.style.hasOwnProperty(style) && prev.style[style] !== next.style[style]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\n * Combine consecutive domTree.symbolNodes into a single symbolNode.\n * Note: this function mutates the argument.\n */\n\n\nconst tryCombineChars = chars => {\n  for (let i = 0; i < chars.length - 1; i++) {\n    const prev = chars[i];\n    const next = chars[i + 1];\n\n    if (prev instanceof SymbolNode && next instanceof SymbolNode && canCombine(prev, next)) {\n      prev.text += next.text;\n      prev.height = Math.max(prev.height, next.height);\n      prev.depth = Math.max(prev.depth, next.depth); // Use the last character's italic correction since we use\n      // it to add padding to the right of the span created from\n      // the combined characters.\n\n      prev.italic = next.italic;\n      chars.splice(i + 1, 1);\n      i--;\n    }\n  }\n\n  return chars;\n};\n/**\n * Calculate the height, depth, and maxFontSize of an element based on its\n * children.\n */\n\n\nconst sizeElementFromChildren = function (elem) {\n  let height = 0;\n  let depth = 0;\n  let maxFontSize = 0;\n\n  for (let i = 0; i < elem.children.length; i++) {\n    const child = elem.children[i];\n\n    if (child.height > height) {\n      height = child.height;\n    }\n\n    if (child.depth > depth) {\n      depth = child.depth;\n    }\n\n    if (child.maxFontSize > maxFontSize) {\n      maxFontSize = child.maxFontSize;\n    }\n  }\n\n  elem.height = height;\n  elem.depth = depth;\n  elem.maxFontSize = maxFontSize;\n};\n/**\n * Makes a span with the given list of classes, list of children, and options.\n *\n * TODO(#953): Ensure that `options` is always provided (currently some call\n * sites don't pass it) and make the type below mandatory.\n * TODO: add a separate argument for math class (e.g. `mop`, `mbin`), which\n * should if present come first in `classes`.\n */\n\n\nconst makeSpan = function (classes, children, options, style) {\n  const span = new Span(classes, children, options, style);\n  sizeElementFromChildren(span);\n  return span;\n}; // SVG one is simpler -- doesn't require height, depth, max-font setting.\n// This is also a separate method for typesafety.\n\n\nconst makeSvgSpan = (classes, children, options, style) => new Span(classes, children, options, style);\n\nconst makeLineSpan = function (className, options, thickness) {\n  const line = makeSpan([className], [], options);\n  line.height = Math.max(thickness || options.fontMetrics().defaultRuleThickness, options.minRuleThickness);\n  line.style.borderBottomWidth = makeEm(line.height);\n  line.maxFontSize = 1.0;\n  return line;\n};\n/**\n * Makes an anchor with the given href, list of classes, list of children,\n * and options.\n */\n\n\nconst makeAnchor = function (href, classes, children, options) {\n  const anchor = new Anchor(href, classes, children, options);\n  sizeElementFromChildren(anchor);\n  return anchor;\n};\n/**\n * Makes a document fragment with the given list of children.\n */\n\n\nconst makeFragment = function (children) {\n  const fragment = new DocumentFragment(children);\n  sizeElementFromChildren(fragment);\n  return fragment;\n};\n/**\n * Wraps group in a span if it's a document fragment, allowing to apply classes\n * and styles\n */\n\n\nconst wrapFragment = function (group, options) {\n  if (group instanceof DocumentFragment) {\n    return makeSpan([], [group], options);\n  }\n\n  return group;\n}; // These are exact object types to catch typos in the names of the optional fields.\n\n\n// Computes the updated `children` list and the overall depth.\n//\n// This helper function for makeVList makes it easier to enforce type safety by\n// allowing early exits (returns) in the logic.\nconst getVListChildrenAndDepth = function (params) {\n  if (params.positionType === \"individualShift\") {\n    const oldChildren = params.children;\n    const children = [oldChildren[0]]; // Add in kerns to the list of params.children to get each element to be\n    // shifted to the correct specified shift\n\n    const depth = -oldChildren[0].shift - oldChildren[0].elem.depth;\n    let currPos = depth;\n\n    for (let i = 1; i < oldChildren.length; i++) {\n      const diff = -oldChildren[i].shift - currPos - oldChildren[i].elem.depth;\n      const size = diff - (oldChildren[i - 1].elem.height + oldChildren[i - 1].elem.depth);\n      currPos = currPos + diff;\n      children.push({\n        type: \"kern\",\n        size\n      });\n      children.push(oldChildren[i]);\n    }\n\n    return {\n      children,\n      depth\n    };\n  }\n\n  let depth;\n\n  if (params.positionType === \"top\") {\n    // We always start at the bottom, so calculate the bottom by adding up\n    // all the sizes\n    let bottom = params.positionData;\n\n    for (let i = 0; i < params.children.length; i++) {\n      const child = params.children[i];\n      bottom -= child.type === \"kern\" ? child.size : child.elem.height + child.elem.depth;\n    }\n\n    depth = bottom;\n  } else if (params.positionType === \"bottom\") {\n    depth = -params.positionData;\n  } else {\n    const firstChild = params.children[0];\n\n    if (firstChild.type !== \"elem\") {\n      throw new Error('First child must have type \"elem\".');\n    }\n\n    if (params.positionType === \"shift\") {\n      depth = -firstChild.elem.depth - params.positionData;\n    } else if (params.positionType === \"firstBaseline\") {\n      depth = -firstChild.elem.depth;\n    } else {\n      throw new Error(\"Invalid positionType \" + params.positionType + \".\");\n    }\n  }\n\n  return {\n    children: params.children,\n    depth\n  };\n};\n/**\n * Makes a vertical list by stacking elements and kerns on top of each other.\n * Allows for many different ways of specifying the positioning method.\n *\n * See VListParam documentation above.\n */\n\n\nconst makeVList = function (params, options) {\n  const {\n    children,\n    depth\n  } = getVListChildrenAndDepth(params); // Create a strut that is taller than any list item. The strut is added to\n  // each item, where it will determine the item's baseline. Since it has\n  // `overflow:hidden`, the strut's top edge will sit on the item's line box's\n  // top edge and the strut's bottom edge will sit on the item's baseline,\n  // with no additional line-height spacing. This allows the item baseline to\n  // be positioned precisely without worrying about font ascent and\n  // line-height.\n\n  let pstrutSize = 0;\n\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i];\n\n    if (child.type === \"elem\") {\n      const elem = child.elem;\n      pstrutSize = Math.max(pstrutSize, elem.maxFontSize, elem.height);\n    }\n  }\n\n  pstrutSize += 2;\n  const pstrut = makeSpan([\"pstrut\"], []);\n  pstrut.style.height = makeEm(pstrutSize); // Create a new list of actual children at the correct offsets\n\n  const realChildren = [];\n  let minPos = depth;\n  let maxPos = depth;\n  let currPos = depth;\n\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i];\n\n    if (child.type === \"kern\") {\n      currPos += child.size;\n    } else {\n      const elem = child.elem;\n      const classes = child.wrapperClasses || [];\n      const style = child.wrapperStyle || {};\n      const childWrap = makeSpan(classes, [pstrut, elem], undefined, style);\n      childWrap.style.top = makeEm(-pstrutSize - currPos - elem.depth);\n\n      if (child.marginLeft) {\n        childWrap.style.marginLeft = child.marginLeft;\n      }\n\n      if (child.marginRight) {\n        childWrap.style.marginRight = child.marginRight;\n      }\n\n      realChildren.push(childWrap);\n      currPos += elem.height + elem.depth;\n    }\n\n    minPos = Math.min(minPos, currPos);\n    maxPos = Math.max(maxPos, currPos);\n  } // The vlist contents go in a table-cell with `vertical-align:bottom`.\n  // This cell's bottom edge will determine the containing table's baseline\n  // without overly expanding the containing line-box.\n\n\n  const vlist = makeSpan([\"vlist\"], realChildren);\n  vlist.style.height = makeEm(maxPos); // A second row is used if necessary to represent the vlist's depth.\n\n  let rows;\n\n  if (minPos < 0) {\n    // We will define depth in an empty span with display: table-cell.\n    // It should render with the height that we define. But Chrome, in\n    // contenteditable mode only, treats that span as if it contains some\n    // text content. And that min-height over-rides our desired height.\n    // So we put another empty span inside the depth strut span.\n    const emptySpan = makeSpan([], []);\n    const depthStrut = makeSpan([\"vlist\"], [emptySpan]);\n    depthStrut.style.height = makeEm(-minPos); // Safari wants the first row to have inline content; otherwise it\n    // puts the bottom of the *second* row on the baseline.\n\n    const topStrut = makeSpan([\"vlist-s\"], [new SymbolNode(\"\\u200b\")]);\n    rows = [makeSpan([\"vlist-r\"], [vlist, topStrut]), makeSpan([\"vlist-r\"], [depthStrut])];\n  } else {\n    rows = [makeSpan([\"vlist-r\"], [vlist])];\n  }\n\n  const vtable = makeSpan([\"vlist-t\"], rows);\n\n  if (rows.length === 2) {\n    vtable.classes.push(\"vlist-t2\");\n  }\n\n  vtable.height = maxPos;\n  vtable.depth = -minPos;\n  return vtable;\n}; // Glue is a concept from TeX which is a flexible space between elements in\n// either a vertical or horizontal list. In KaTeX, at least for now, it's\n// static space between elements in a horizontal layout.\n\n\nconst makeGlue = (measurement, options) => {\n  // Make an empty span for the space\n  const rule = makeSpan([\"mspace\"], [], options);\n  const size = calculateSize(measurement, options);\n  rule.style.marginRight = makeEm(size);\n  return rule;\n}; // Takes font options, and returns the appropriate fontLookup name\n\n\nconst retrieveTextFontName = function (fontFamily, fontWeight, fontShape) {\n  let baseFontName = \"\";\n\n  switch (fontFamily) {\n    case \"amsrm\":\n      baseFontName = \"AMS\";\n      break;\n\n    case \"textrm\":\n      baseFontName = \"Main\";\n      break;\n\n    case \"textsf\":\n      baseFontName = \"SansSerif\";\n      break;\n\n    case \"texttt\":\n      baseFontName = \"Typewriter\";\n      break;\n\n    default:\n      baseFontName = fontFamily;\n    // use fonts added by a plugin\n  }\n\n  let fontStylesName;\n\n  if (fontWeight === \"textbf\" && fontShape === \"textit\") {\n    fontStylesName = \"BoldItalic\";\n  } else if (fontWeight === \"textbf\") {\n    fontStylesName = \"Bold\";\n  } else if (fontWeight === \"textit\") {\n    fontStylesName = \"Italic\";\n  } else {\n    fontStylesName = \"Regular\";\n  }\n\n  return baseFontName + \"-\" + fontStylesName;\n};\n/**\n * Maps TeX font commands to objects containing:\n * - variant: string used for \"mathvariant\" attribute in buildMathML.js\n * - fontName: the \"style\" parameter to fontMetrics.getCharacterMetrics\n */\n// A map between tex font commands an MathML mathvariant attribute values\n\n\nconst fontMap = {\n  // styles\n  \"mathbf\": {\n    variant: \"bold\",\n    fontName: \"Main-Bold\"\n  },\n  \"mathrm\": {\n    variant: \"normal\",\n    fontName: \"Main-Regular\"\n  },\n  \"textit\": {\n    variant: \"italic\",\n    fontName: \"Main-Italic\"\n  },\n  \"mathit\": {\n    variant: \"italic\",\n    fontName: \"Main-Italic\"\n  },\n  \"mathnormal\": {\n    variant: \"italic\",\n    fontName: \"Math-Italic\"\n  },\n  // \"boldsymbol\" is missing because they require the use of multiple fonts:\n  // Math-BoldItalic and Main-Bold.  This is handled by a special case in\n  // makeOrd which ends up calling boldsymbol.\n  // families\n  \"mathbb\": {\n    variant: \"double-struck\",\n    fontName: \"AMS-Regular\"\n  },\n  \"mathcal\": {\n    variant: \"script\",\n    fontName: \"Caligraphic-Regular\"\n  },\n  \"mathfrak\": {\n    variant: \"fraktur\",\n    fontName: \"Fraktur-Regular\"\n  },\n  \"mathscr\": {\n    variant: \"script\",\n    fontName: \"Script-Regular\"\n  },\n  \"mathsf\": {\n    variant: \"sans-serif\",\n    fontName: \"SansSerif-Regular\"\n  },\n  \"mathtt\": {\n    variant: \"monospace\",\n    fontName: \"Typewriter-Regular\"\n  }\n};\nconst svgData = {\n  //   path, width, height\n  vec: [\"vec\", 0.471, 0.714],\n  // values from the font glyph\n  oiintSize1: [\"oiintSize1\", 0.957, 0.499],\n  // oval to overlay the integrand\n  oiintSize2: [\"oiintSize2\", 1.472, 0.659],\n  oiiintSize1: [\"oiiintSize1\", 1.304, 0.499],\n  oiiintSize2: [\"oiiintSize2\", 1.98, 0.659]\n};\n\nconst staticSvg = function (value, options) {\n  // Create a span with inline SVG for the element.\n  const [pathName, width, height] = svgData[value];\n  const path = new PathNode(pathName);\n  const svgNode = new SvgNode([path], {\n    \"width\": makeEm(width),\n    \"height\": makeEm(height),\n    // Override CSS rule `.katex svg { width: 100% }`\n    \"style\": \"width:\" + makeEm(width),\n    \"viewBox\": \"0 0 \" + 1000 * width + \" \" + 1000 * height,\n    \"preserveAspectRatio\": \"xMinYMin\"\n  });\n  const span = makeSvgSpan([\"overlay\"], [svgNode], options);\n  span.height = height;\n  span.style.height = makeEm(height);\n  span.style.width = makeEm(width);\n  return span;\n};\n\n/* harmony default export */ var buildCommon = ({\n  fontMap,\n  makeSymbol,\n  mathsym,\n  makeSpan,\n  makeSvgSpan,\n  makeLineSpan,\n  makeAnchor,\n  makeFragment,\n  wrapFragment,\n  makeVList,\n  makeOrd,\n  makeGlue,\n  staticSvg,\n  svgData,\n  tryCombineChars\n});\n;// CONCATENATED MODULE: ./src/spacingData.js\n/**\n * Describes spaces between different classes of atoms.\n */\nconst thinspace = {\n  number: 3,\n  unit: \"mu\"\n};\nconst mediumspace = {\n  number: 4,\n  unit: \"mu\"\n};\nconst thickspace = {\n  number: 5,\n  unit: \"mu\"\n}; // Making the type below exact with all optional fields doesn't work due to\n// - https://github.com/facebook/flow/issues/4582\n// - https://github.com/facebook/flow/issues/5688\n// However, since *all* fields are optional, $Shape<> works as suggested in 5688\n// above.\n\n// Spacing relationships for display and text styles\nconst spacings = {\n  mord: {\n    mop: thinspace,\n    mbin: mediumspace,\n    mrel: thickspace,\n    minner: thinspace\n  },\n  mop: {\n    mord: thinspace,\n    mop: thinspace,\n    mrel: thickspace,\n    minner: thinspace\n  },\n  mbin: {\n    mord: mediumspace,\n    mop: mediumspace,\n    mopen: mediumspace,\n    minner: mediumspace\n  },\n  mrel: {\n    mord: thickspace,\n    mop: thickspace,\n    mopen: thickspace,\n    minner: thickspace\n  },\n  mopen: {},\n  mclose: {\n    mop: thinspace,\n    mbin: mediumspace,\n    mrel: thickspace,\n    minner: thinspace\n  },\n  mpunct: {\n    mord: thinspace,\n    mop: thinspace,\n    mrel: thickspace,\n    mopen: thinspace,\n    mclose: thinspace,\n    mpunct: thinspace,\n    minner: thinspace\n  },\n  minner: {\n    mord: thinspace,\n    mop: thinspace,\n    mbin: mediumspace,\n    mrel: thickspace,\n    mopen: thinspace,\n    mpunct: thinspace,\n    minner: thinspace\n  }\n}; // Spacing relationships for script and scriptscript styles\n\nconst tightSpacings = {\n  mord: {\n    mop: thinspace\n  },\n  mop: {\n    mord: thinspace,\n    mop: thinspace\n  },\n  mbin: {},\n  mrel: {},\n  mopen: {},\n  mclose: {\n    mop: thinspace\n  },\n  mpunct: {},\n  minner: {\n    mop: thinspace\n  }\n};\n;// CONCATENATED MODULE: ./src/defineFunction.js\n/** Context provided to function handlers for error messages. */\n// Note: reverse the order of the return type union will cause a flow error.\n// See https://github.com/facebook/flow/issues/3663.\n// More general version of `HtmlBuilder` for nodes (e.g. \\sum, accent types)\n// whose presence impacts super/subscripting. In this case, ParseNode<\"supsub\">\n// delegates its HTML building to the HtmlBuilder corresponding to these nodes.\n\n/**\n * Final function spec for use at parse time.\n * This is almost identical to `FunctionPropSpec`, except it\n * 1. includes the function handler, and\n * 2. requires all arguments except argTypes.\n * It is generated by `defineFunction()` below.\n */\n\n/**\n * All registered functions.\n * `functions.js` just exports this same dictionary again and makes it public.\n * `Parser.js` requires this dictionary.\n */\nconst _functions = {};\n/**\n * All HTML builders. Should be only used in the `define*` and the `build*ML`\n * functions.\n */\n\nconst _htmlGroupBuilders = {};\n/**\n * All MathML builders. Should be only used in the `define*` and the `build*ML`\n * functions.\n */\n\nconst _mathmlGroupBuilders = {};\nfunction defineFunction(_ref) {\n  let {\n    type,\n    names,\n    props,\n    handler,\n    htmlBuilder,\n    mathmlBuilder\n  } = _ref;\n  // Set default values of functions\n  const data = {\n    type,\n    numArgs: props.numArgs,\n    argTypes: props.argTypes,\n    allowedInArgument: !!props.allowedInArgument,\n    allowedInText: !!props.allowedInText,\n    allowedInMath: props.allowedInMath === undefined ? true : props.allowedInMath,\n    numOptionalArgs: props.numOptionalArgs || 0,\n    infix: !!props.infix,\n    primitive: !!props.primitive,\n    handler: handler\n  };\n\n  for (let i = 0; i < names.length; ++i) {\n    _functions[names[i]] = data;\n  }\n\n  if (type) {\n    if (htmlBuilder) {\n      _htmlGroupBuilders[type] = htmlBuilder;\n    }\n\n    if (mathmlBuilder) {\n      _mathmlGroupBuilders[type] = mathmlBuilder;\n    }\n  }\n}\n/**\n * Use this to register only the HTML and MathML builders for a function (e.g.\n * if the function's ParseNode is generated in Parser.js rather than via a\n * stand-alone handler provided to `defineFunction`).\n */\n\nfunction defineFunctionBuilders(_ref2) {\n  let {\n    type,\n    htmlBuilder,\n    mathmlBuilder\n  } = _ref2;\n  defineFunction({\n    type,\n    names: [],\n    props: {\n      numArgs: 0\n    },\n\n    handler() {\n      throw new Error('Should never be called.');\n    },\n\n    htmlBuilder,\n    mathmlBuilder\n  });\n}\nconst normalizeArgument = function (arg) {\n  return arg.type === \"ordgroup\" && arg.body.length === 1 ? arg.body[0] : arg;\n}; // Since the corresponding buildHTML/buildMathML function expects a\n// list of elements, we normalize for different kinds of arguments\n\nconst ordargument = function (arg) {\n  return arg.type === \"ordgroup\" ? arg.body : [arg];\n};\n;// CONCATENATED MODULE: ./src/buildHTML.js\n/**\n * This file does the main work of building a domTree structure from a parse\n * tree. The entry point is the `buildHTML` function, which takes a parse tree.\n * Then, the buildExpression, buildGroup, and various groupBuilders functions\n * are called, to produce a final HTML tree.\n */\n\n\n\n\n\n\n\n\n\nconst buildHTML_makeSpan = buildCommon.makeSpan; // Binary atoms (first class `mbin`) change into ordinary atoms (`mord`)\n// depending on their surroundings. See TeXbook pg. 442-446, Rules 5 and 6,\n// and the text before Rule 19.\n\nconst binLeftCanceller = [\"leftmost\", \"mbin\", \"mopen\", \"mrel\", \"mop\", \"mpunct\"];\nconst binRightCanceller = [\"rightmost\", \"mrel\", \"mclose\", \"mpunct\"];\nconst styleMap = {\n  \"display\": src_Style.DISPLAY,\n  \"text\": src_Style.TEXT,\n  \"script\": src_Style.SCRIPT,\n  \"scriptscript\": src_Style.SCRIPTSCRIPT\n};\nconst DomEnum = {\n  mord: \"mord\",\n  mop: \"mop\",\n  mbin: \"mbin\",\n  mrel: \"mrel\",\n  mopen: \"mopen\",\n  mclose: \"mclose\",\n  mpunct: \"mpunct\",\n  minner: \"minner\"\n};\n\n/**\n * Take a list of nodes, build them in order, and return a list of the built\n * nodes. documentFragments are flattened into their contents, so the\n * returned list contains no fragments. `isRealGroup` is true if `expression`\n * is a real group (no atoms will be added on either side), as opposed to\n * a partial group (e.g. one created by \\color). `surrounding` is an array\n * consisting type of nodes that will be added to the left and right.\n */\nconst buildExpression = function (expression, options, isRealGroup, surrounding) {\n  if (surrounding === void 0) {\n    surrounding = [null, null];\n  }\n\n  // Parse expressions into `groups`.\n  const groups = [];\n\n  for (let i = 0; i < expression.length; i++) {\n    const output = buildGroup(expression[i], options);\n\n    if (output instanceof DocumentFragment) {\n      const children = output.children;\n      groups.push(...children);\n    } else {\n      groups.push(output);\n    }\n  } // Combine consecutive domTree.symbolNodes into a single symbolNode.\n\n\n  buildCommon.tryCombineChars(groups); // If `expression` is a partial group, let the parent handle spacings\n  // to avoid processing groups multiple times.\n\n  if (!isRealGroup) {\n    return groups;\n  }\n\n  let glueOptions = options;\n\n  if (expression.length === 1) {\n    const node = expression[0];\n\n    if (node.type === \"sizing\") {\n      glueOptions = options.havingSize(node.size);\n    } else if (node.type === \"styling\") {\n      glueOptions = options.havingStyle(styleMap[node.style]);\n    }\n  } // Dummy spans for determining spacings between surrounding atoms.\n  // If `expression` has no atoms on the left or right, class \"leftmost\"\n  // or \"rightmost\", respectively, is used to indicate it.\n\n\n  const dummyPrev = buildHTML_makeSpan([surrounding[0] || \"leftmost\"], [], options);\n  const dummyNext = buildHTML_makeSpan([surrounding[1] || \"rightmost\"], [], options); // TODO: These code assumes that a node's math class is the first element\n  // of its `classes` array. A later cleanup should ensure this, for\n  // instance by changing the signature of `makeSpan`.\n  // Before determining what spaces to insert, perform bin cancellation.\n  // Binary operators change to ordinary symbols in some contexts.\n\n  const isRoot = isRealGroup === \"root\";\n  traverseNonSpaceNodes(groups, (node, prev) => {\n    const prevType = prev.classes[0];\n    const type = node.classes[0];\n\n    if (prevType === \"mbin\" && utils.contains(binRightCanceller, type)) {\n      prev.classes[0] = \"mord\";\n    } else if (type === \"mbin\" && utils.contains(binLeftCanceller, prevType)) {\n      node.classes[0] = \"mord\";\n    }\n  }, {\n    node: dummyPrev\n  }, dummyNext, isRoot);\n  traverseNonSpaceNodes(groups, (node, prev) => {\n    const prevType = getTypeOfDomTree(prev);\n    const type = getTypeOfDomTree(node); // 'mtight' indicates that the node is script or scriptscript style.\n\n    const space = prevType && type ? node.hasClass(\"mtight\") ? tightSpacings[prevType][type] : spacings[prevType][type] : null;\n\n    if (space) {\n      // Insert glue (spacing) after the `prev`.\n      return buildCommon.makeGlue(space, glueOptions);\n    }\n  }, {\n    node: dummyPrev\n  }, dummyNext, isRoot);\n  return groups;\n}; // Depth-first traverse non-space `nodes`, calling `callback` with the current and\n// previous node as arguments, optionally returning a node to insert after the\n// previous node. `prev` is an object with the previous node and `insertAfter`\n// function to insert after it. `next` is a node that will be added to the right.\n// Used for bin cancellation and inserting spacings.\n\nconst traverseNonSpaceNodes = function (nodes, callback, prev, next, isRoot) {\n  if (next) {\n    // temporarily append the right node, if exists\n    nodes.push(next);\n  }\n\n  let i = 0;\n\n  for (; i < nodes.length; i++) {\n    const node = nodes[i];\n    const partialGroup = checkPartialGroup(node);\n\n    if (partialGroup) {\n      // Recursive DFS\n      // $FlowFixMe: make nodes a $ReadOnlyArray by returning a new array\n      traverseNonSpaceNodes(partialGroup.children, callback, prev, null, isRoot);\n      continue;\n    } // Ignore explicit spaces (e.g., \\;, \\,) when determining what implicit\n    // spacing should go between atoms of different classes\n\n\n    const nonspace = !node.hasClass(\"mspace\");\n\n    if (nonspace) {\n      const result = callback(node, prev.node);\n\n      if (result) {\n        if (prev.insertAfter) {\n          prev.insertAfter(result);\n        } else {\n          // insert at front\n          nodes.unshift(result);\n          i++;\n        }\n      }\n    }\n\n    if (nonspace) {\n      prev.node = node;\n    } else if (isRoot && node.hasClass(\"newline\")) {\n      prev.node = buildHTML_makeSpan([\"leftmost\"]); // treat like beginning of line\n    }\n\n    prev.insertAfter = (index => n => {\n      nodes.splice(index + 1, 0, n);\n      i++;\n    })(i);\n  }\n\n  if (next) {\n    nodes.pop();\n  }\n}; // Check if given node is a partial group, i.e., does not affect spacing around.\n\n\nconst checkPartialGroup = function (node) {\n  if (node instanceof DocumentFragment || node instanceof Anchor || node instanceof Span && node.hasClass(\"enclosing\")) {\n    return node;\n  }\n\n  return null;\n}; // Return the outermost node of a domTree.\n\n\nconst getOutermostNode = function (node, side) {\n  const partialGroup = checkPartialGroup(node);\n\n  if (partialGroup) {\n    const children = partialGroup.children;\n\n    if (children.length) {\n      if (side === \"right\") {\n        return getOutermostNode(children[children.length - 1], \"right\");\n      } else if (side === \"left\") {\n        return getOutermostNode(children[0], \"left\");\n      }\n    }\n  }\n\n  return node;\n}; // Return math atom class (mclass) of a domTree.\n// If `side` is given, it will get the type of the outermost node at given side.\n\n\nconst getTypeOfDomTree = function (node, side) {\n  if (!node) {\n    return null;\n  }\n\n  if (side) {\n    node = getOutermostNode(node, side);\n  } // This makes a lot of assumptions as to where the type of atom\n  // appears.  We should do a better job of enforcing this.\n\n\n  return DomEnum[node.classes[0]] || null;\n};\nconst makeNullDelimiter = function (options, classes) {\n  const moreClasses = [\"nulldelimiter\"].concat(options.baseSizingClasses());\n  return buildHTML_makeSpan(classes.concat(moreClasses));\n};\n/**\n * buildGroup is the function that takes a group and calls the correct groupType\n * function for it. It also handles the interaction of size and style changes\n * between parents and children.\n */\n\nconst buildGroup = function (group, options, baseOptions) {\n  if (!group) {\n    return buildHTML_makeSpan();\n  }\n\n  if (_htmlGroupBuilders[group.type]) {\n    // Call the groupBuilders function\n    // $FlowFixMe\n    let groupNode = _htmlGroupBuilders[group.type](group, options); // If the size changed between the parent and the current group, account\n    // for that size difference.\n\n    if (baseOptions && options.size !== baseOptions.size) {\n      groupNode = buildHTML_makeSpan(options.sizingClasses(baseOptions), [groupNode], options);\n      const multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier;\n      groupNode.height *= multiplier;\n      groupNode.depth *= multiplier;\n    }\n\n    return groupNode;\n  } else {\n    throw new src_ParseError(\"Got group of unknown type: '\" + group.type + \"'\");\n  }\n};\n/**\n * Combine an array of HTML DOM nodes (e.g., the output of `buildExpression`)\n * into an unbreakable HTML node of class .base, with proper struts to\n * guarantee correct vertical extent.  `buildHTML` calls this repeatedly to\n * make up the entire expression as a sequence of unbreakable units.\n */\n\nfunction buildHTMLUnbreakable(children, options) {\n  // Compute height and depth of this chunk.\n  const body = buildHTML_makeSpan([\"base\"], children, options); // Add strut, which ensures that the top of the HTML element falls at\n  // the height of the expression, and the bottom of the HTML element\n  // falls at the depth of the expression.\n\n  const strut = buildHTML_makeSpan([\"strut\"]);\n  strut.style.height = makeEm(body.height + body.depth);\n\n  if (body.depth) {\n    strut.style.verticalAlign = makeEm(-body.depth);\n  }\n\n  body.children.unshift(strut);\n  return body;\n}\n/**\n * Take an entire parse tree, and build it into an appropriate set of HTML\n * nodes.\n */\n\n\nfunction buildHTML(tree, options) {\n  // Strip off outer tag wrapper for processing below.\n  let tag = null;\n\n  if (tree.length === 1 && tree[0].type === \"tag\") {\n    tag = tree[0].tag;\n    tree = tree[0].body;\n  } // Build the expression contained in the tree\n\n\n  const expression = buildExpression(tree, options, \"root\");\n  let eqnNum;\n\n  if (expression.length === 2 && expression[1].hasClass(\"tag\")) {\n    // An environment with automatic equation numbers, e.g. {gather}.\n    eqnNum = expression.pop();\n  }\n\n  const children = []; // Create one base node for each chunk between potential line breaks.\n  // The TeXBook [p.173] says \"A formula will be broken only after a\n  // relation symbol like $=$ or $<$ or $\\rightarrow$, or after a binary\n  // operation symbol like $+$ or $-$ or $\\times$, where the relation or\n  // binary operation is on the ``outer level'' of the formula (i.e., not\n  // enclosed in {...} and not part of an \\over construction).\"\n\n  let parts = [];\n\n  for (let i = 0; i < expression.length; i++) {\n    parts.push(expression[i]);\n\n    if (expression[i].hasClass(\"mbin\") || expression[i].hasClass(\"mrel\") || expression[i].hasClass(\"allowbreak\")) {\n      // Put any post-operator glue on same line as operator.\n      // Watch for \\nobreak along the way, and stop at \\newline.\n      let nobreak = false;\n\n      while (i < expression.length - 1 && expression[i + 1].hasClass(\"mspace\") && !expression[i + 1].hasClass(\"newline\")) {\n        i++;\n        parts.push(expression[i]);\n\n        if (expression[i].hasClass(\"nobreak\")) {\n          nobreak = true;\n        }\n      } // Don't allow break if \\nobreak among the post-operator glue.\n\n\n      if (!nobreak) {\n        children.push(buildHTMLUnbreakable(parts, options));\n        parts = [];\n      }\n    } else if (expression[i].hasClass(\"newline\")) {\n      // Write the line except the newline\n      parts.pop();\n\n      if (parts.length > 0) {\n        children.push(buildHTMLUnbreakable(parts, options));\n        parts = [];\n      } // Put the newline at the top level\n\n\n      children.push(expression[i]);\n    }\n  }\n\n  if (parts.length > 0) {\n    children.push(buildHTMLUnbreakable(parts, options));\n  } // Now, if there was a tag, build it too and append it as a final child.\n\n\n  let tagChild;\n\n  if (tag) {\n    tagChild = buildHTMLUnbreakable(buildExpression(tag, options, true));\n    tagChild.classes = [\"tag\"];\n    children.push(tagChild);\n  } else if (eqnNum) {\n    children.push(eqnNum);\n  }\n\n  const htmlNode = buildHTML_makeSpan([\"katex-html\"], children);\n  htmlNode.setAttribute(\"aria-hidden\", \"true\"); // Adjust the strut of the tag to be the maximum height of all children\n  // (the height of the enclosing htmlNode) for proper vertical alignment.\n\n  if (tagChild) {\n    const strut = tagChild.children[0];\n    strut.style.height = makeEm(htmlNode.height + htmlNode.depth);\n\n    if (htmlNode.depth) {\n      strut.style.verticalAlign = makeEm(-htmlNode.depth);\n    }\n  }\n\n  return htmlNode;\n}\n;// CONCATENATED MODULE: ./src/mathMLTree.js\n/**\n * These objects store data about MathML nodes. This is the MathML equivalent\n * of the types in domTree.js. Since MathML handles its own rendering, and\n * since we're mainly using MathML to improve accessibility, we don't manage\n * any of the styling state that the plain DOM nodes do.\n *\n * The `toNode` and `toMarkup` functions work similarly to how they do in\n * domTree.js, creating namespaced DOM nodes and HTML text markup respectively.\n */\n\n\n\n\nfunction newDocumentFragment(children) {\n  return new DocumentFragment(children);\n}\n/**\n * This node represents a general purpose MathML node of any type. The\n * constructor requires the type of node to create (for example, `\"mo\"` or\n * `\"mspace\"`, corresponding to `<mo>` and `<mspace>` tags).\n */\n\nclass MathNode {\n  constructor(type, children, classes) {\n    this.type = void 0;\n    this.attributes = void 0;\n    this.children = void 0;\n    this.classes = void 0;\n    this.type = type;\n    this.attributes = {};\n    this.children = children || [];\n    this.classes = classes || [];\n  }\n  /**\n   * Sets an attribute on a MathML node. MathML depends on attributes to convey a\n   * semantic content, so this is used heavily.\n   */\n\n\n  setAttribute(name, value) {\n    this.attributes[name] = value;\n  }\n  /**\n   * Gets an attribute on a MathML node.\n   */\n\n\n  getAttribute(name) {\n    return this.attributes[name];\n  }\n  /**\n   * Converts the math node into a MathML-namespaced DOM element.\n   */\n\n\n  toNode() {\n    const node = document.createElementNS(\"http://www.w3.org/1998/Math/MathML\", this.type);\n\n    for (const attr in this.attributes) {\n      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {\n        node.setAttribute(attr, this.attributes[attr]);\n      }\n    }\n\n    if (this.classes.length > 0) {\n      node.className = createClass(this.classes);\n    }\n\n    for (let i = 0; i < this.children.length; i++) {\n      node.appendChild(this.children[i].toNode());\n    }\n\n    return node;\n  }\n  /**\n   * Converts the math node into an HTML markup string.\n   */\n\n\n  toMarkup() {\n    let markup = \"<\" + this.type; // Add the attributes\n\n    for (const attr in this.attributes) {\n      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {\n        markup += \" \" + attr + \"=\\\"\";\n        markup += utils.escape(this.attributes[attr]);\n        markup += \"\\\"\";\n      }\n    }\n\n    if (this.classes.length > 0) {\n      markup += \" class =\\\"\" + utils.escape(createClass(this.classes)) + \"\\\"\";\n    }\n\n    markup += \">\";\n\n    for (let i = 0; i < this.children.length; i++) {\n      markup += this.children[i].toMarkup();\n    }\n\n    markup += \"</\" + this.type + \">\";\n    return markup;\n  }\n  /**\n   * Converts the math node into a string, similar to innerText, but escaped.\n   */\n\n\n  toText() {\n    return this.children.map(child => child.toText()).join(\"\");\n  }\n\n}\n/**\n * This node represents a piece of text.\n */\n\nclass TextNode {\n  constructor(text) {\n    this.text = void 0;\n    this.text = text;\n  }\n  /**\n   * Converts the text node into a DOM text node.\n   */\n\n\n  toNode() {\n    return document.createTextNode(this.text);\n  }\n  /**\n   * Converts the text node into escaped HTML markup\n   * (representing the text itself).\n   */\n\n\n  toMarkup() {\n    return utils.escape(this.toText());\n  }\n  /**\n   * Converts the text node into a string\n   * (representing the text itself).\n   */\n\n\n  toText() {\n    return this.text;\n  }\n\n}\n/**\n * This node represents a space, but may render as <mspace.../> or as text,\n * depending on the width.\n */\n\nclass SpaceNode {\n  /**\n   * Create a Space node with width given in CSS ems.\n   */\n  constructor(width) {\n    this.width = void 0;\n    this.character = void 0;\n    this.width = width; // See https://www.w3.org/TR/2000/WD-MathML2-20000328/chapter6.html\n    // for a table of space-like characters.  We use Unicode\n    // representations instead of &LongNames; as it's not clear how to\n    // make the latter via document.createTextNode.\n\n    if (width >= 0.05555 && width <= 0.05556) {\n      this.character = \"\\u200a\"; // &VeryThinSpace;\n    } else if (width >= 0.1666 && width <= 0.1667) {\n      this.character = \"\\u2009\"; // &ThinSpace;\n    } else if (width >= 0.2222 && width <= 0.2223) {\n      this.character = \"\\u2005\"; // &MediumSpace;\n    } else if (width >= 0.2777 && width <= 0.2778) {\n      this.character = \"\\u2005\\u200a\"; // &ThickSpace;\n    } else if (width >= -0.05556 && width <= -0.05555) {\n      this.character = \"\\u200a\\u2063\"; // &NegativeVeryThinSpace;\n    } else if (width >= -0.1667 && width <= -0.1666) {\n      this.character = \"\\u2009\\u2063\"; // &NegativeThinSpace;\n    } else if (width >= -0.2223 && width <= -0.2222) {\n      this.character = \"\\u205f\\u2063\"; // &NegativeMediumSpace;\n    } else if (width >= -0.2778 && width <= -0.2777) {\n      this.character = \"\\u2005\\u2063\"; // &NegativeThickSpace;\n    } else {\n      this.character = null;\n    }\n  }\n  /**\n   * Converts the math node into a MathML-namespaced DOM element.\n   */\n\n\n  toNode() {\n    if (this.character) {\n      return document.createTextNode(this.character);\n    } else {\n      const node = document.createElementNS(\"http://www.w3.org/1998/Math/MathML\", \"mspace\");\n      node.setAttribute(\"width\", makeEm(this.width));\n      return node;\n    }\n  }\n  /**\n   * Converts the math node into an HTML markup string.\n   */\n\n\n  toMarkup() {\n    if (this.character) {\n      return \"<mtext>\" + this.character + \"</mtext>\";\n    } else {\n      return \"<mspace width=\\\"\" + makeEm(this.width) + \"\\\"/>\";\n    }\n  }\n  /**\n   * Converts the math node into a string, similar to innerText.\n   */\n\n\n  toText() {\n    if (this.character) {\n      return this.character;\n    } else {\n      return \" \";\n    }\n  }\n\n}\n\n/* harmony default export */ var mathMLTree = ({\n  MathNode,\n  TextNode,\n  SpaceNode,\n  newDocumentFragment\n});\n;// CONCATENATED MODULE: ./src/buildMathML.js\n/**\n * This file converts a parse tree into a corresponding MathML tree. The main\n * entry point is the `buildMathML` function, which takes a parse tree from the\n * parser.\n */\n\n\n\n\n\n\n\n\n\n/**\n * Takes a symbol and converts it into a MathML text node after performing\n * optional replacement from symbols.js.\n */\nconst makeText = function (text, mode, options) {\n  if (src_symbols[mode][text] && src_symbols[mode][text].replace && text.charCodeAt(0) !== 0xD835 && !(ligatures.hasOwnProperty(text) && options && (options.fontFamily && options.fontFamily.slice(4, 6) === \"tt\" || options.font && options.font.slice(4, 6) === \"tt\"))) {\n    text = src_symbols[mode][text].replace;\n  }\n\n  return new mathMLTree.TextNode(text);\n};\n/**\n * Wrap the given array of nodes in an <mrow> node if needed, i.e.,\n * unless the array has length 1.  Always returns a single node.\n */\n\nconst makeRow = function (body) {\n  if (body.length === 1) {\n    return body[0];\n  } else {\n    return new mathMLTree.MathNode(\"mrow\", body);\n  }\n};\n/**\n * Returns the math variant as a string or null if none is required.\n */\n\nconst getVariant = function (group, options) {\n  // Handle \\text... font specifiers as best we can.\n  // MathML has a limited list of allowable mathvariant specifiers; see\n  // https://www.w3.org/TR/MathML3/chapter3.html#presm.commatt\n  if (options.fontFamily === \"texttt\") {\n    return \"monospace\";\n  } else if (options.fontFamily === \"textsf\") {\n    if (options.fontShape === \"textit\" && options.fontWeight === \"textbf\") {\n      return \"sans-serif-bold-italic\";\n    } else if (options.fontShape === \"textit\") {\n      return \"sans-serif-italic\";\n    } else if (options.fontWeight === \"textbf\") {\n      return \"bold-sans-serif\";\n    } else {\n      return \"sans-serif\";\n    }\n  } else if (options.fontShape === \"textit\" && options.fontWeight === \"textbf\") {\n    return \"bold-italic\";\n  } else if (options.fontShape === \"textit\") {\n    return \"italic\";\n  } else if (options.fontWeight === \"textbf\") {\n    return \"bold\";\n  }\n\n  const font = options.font;\n\n  if (!font || font === \"mathnormal\") {\n    return null;\n  }\n\n  const mode = group.mode;\n\n  if (font === \"mathit\") {\n    return \"italic\";\n  } else if (font === \"boldsymbol\") {\n    return group.type === \"textord\" ? \"bold\" : \"bold-italic\";\n  } else if (font === \"mathbf\") {\n    return \"bold\";\n  } else if (font === \"mathbb\") {\n    return \"double-struck\";\n  } else if (font === \"mathfrak\") {\n    return \"fraktur\";\n  } else if (font === \"mathscr\" || font === \"mathcal\") {\n    // MathML makes no distinction between script and calligraphic\n    return \"script\";\n  } else if (font === \"mathsf\") {\n    return \"sans-serif\";\n  } else if (font === \"mathtt\") {\n    return \"monospace\";\n  }\n\n  let text = group.text;\n\n  if (utils.contains([\"\\\\imath\", \"\\\\jmath\"], text)) {\n    return null;\n  }\n\n  if (src_symbols[mode][text] && src_symbols[mode][text].replace) {\n    text = src_symbols[mode][text].replace;\n  }\n\n  const fontName = buildCommon.fontMap[font].fontName;\n\n  if (getCharacterMetrics(text, fontName, mode)) {\n    return buildCommon.fontMap[font].variant;\n  }\n\n  return null;\n};\n/**\n * Takes a list of nodes, builds them, and returns a list of the generated\n * MathML nodes.  Also combine consecutive <mtext> outputs into a single\n * <mtext> tag.\n */\n\nconst buildMathML_buildExpression = function (expression, options, isOrdgroup) {\n  if (expression.length === 1) {\n    const group = buildMathML_buildGroup(expression[0], options);\n\n    if (isOrdgroup && group instanceof MathNode && group.type === \"mo\") {\n      // When TeX writers want to suppress spacing on an operator,\n      // they often put the operator by itself inside braces.\n      group.setAttribute(\"lspace\", \"0em\");\n      group.setAttribute(\"rspace\", \"0em\");\n    }\n\n    return [group];\n  }\n\n  const groups = [];\n  let lastGroup;\n\n  for (let i = 0; i < expression.length; i++) {\n    const group = buildMathML_buildGroup(expression[i], options);\n\n    if (group instanceof MathNode && lastGroup instanceof MathNode) {\n      // Concatenate adjacent <mtext>s\n      if (group.type === 'mtext' && lastGroup.type === 'mtext' && group.getAttribute('mathvariant') === lastGroup.getAttribute('mathvariant')) {\n        lastGroup.children.push(...group.children);\n        continue; // Concatenate adjacent <mn>s\n      } else if (group.type === 'mn' && lastGroup.type === 'mn') {\n        lastGroup.children.push(...group.children);\n        continue; // Concatenate <mn>...</mn> followed by <mi>.</mi>\n      } else if (group.type === 'mi' && group.children.length === 1 && lastGroup.type === 'mn') {\n        const child = group.children[0];\n\n        if (child instanceof TextNode && child.text === '.') {\n          lastGroup.children.push(...group.children);\n          continue;\n        }\n      } else if (lastGroup.type === 'mi' && lastGroup.children.length === 1) {\n        const lastChild = lastGroup.children[0];\n\n        if (lastChild instanceof TextNode && lastChild.text === '\\u0338' && (group.type === 'mo' || group.type === 'mi' || group.type === 'mn')) {\n          const child = group.children[0];\n\n          if (child instanceof TextNode && child.text.length > 0) {\n            // Overlay with combining character long solidus\n            child.text = child.text.slice(0, 1) + \"\\u0338\" + child.text.slice(1);\n            groups.pop();\n          }\n        }\n      }\n    }\n\n    groups.push(group);\n    lastGroup = group;\n  }\n\n  return groups;\n};\n/**\n * Equivalent to buildExpression, but wraps the elements in an <mrow>\n * if there's more than one.  Returns a single node instead of an array.\n */\n\nconst buildExpressionRow = function (expression, options, isOrdgroup) {\n  return makeRow(buildMathML_buildExpression(expression, options, isOrdgroup));\n};\n/**\n * Takes a group from the parser and calls the appropriate groupBuilders function\n * on it to produce a MathML node.\n */\n\nconst buildMathML_buildGroup = function (group, options) {\n  if (!group) {\n    return new mathMLTree.MathNode(\"mrow\");\n  }\n\n  if (_mathmlGroupBuilders[group.type]) {\n    // Call the groupBuilders function\n    // $FlowFixMe\n    const result = _mathmlGroupBuilders[group.type](group, options); // $FlowFixMe\n\n    return result;\n  } else {\n    throw new src_ParseError(\"Got group of unknown type: '\" + group.type + \"'\");\n  }\n};\n/**\n * Takes a full parse tree and settings and builds a MathML representation of\n * it. In particular, we put the elements from building the parse tree into a\n * <semantics> tag so we can also include that TeX source as an annotation.\n *\n * Note that we actually return a domTree element with a `<math>` inside it so\n * we can do appropriate styling.\n */\n\nfunction buildMathML(tree, texExpression, options, isDisplayMode, forMathmlOnly) {\n  const expression = buildMathML_buildExpression(tree, options); // TODO: Make a pass thru the MathML similar to buildHTML.traverseNonSpaceNodes\n  // and add spacing nodes. This is necessary only adjacent to math operators\n  // like \\sin or \\lim or to subsup elements that contain math operators.\n  // MathML takes care of the other spacing issues.\n  // Wrap up the expression in an mrow so it is presented in the semantics\n  // tag correctly, unless it's a single <mrow> or <mtable>.\n\n  let wrapper;\n\n  if (expression.length === 1 && expression[0] instanceof MathNode && utils.contains([\"mrow\", \"mtable\"], expression[0].type)) {\n    wrapper = expression[0];\n  } else {\n    wrapper = new mathMLTree.MathNode(\"mrow\", expression);\n  } // Build a TeX annotation of the source\n\n\n  const annotation = new mathMLTree.MathNode(\"annotation\", [new mathMLTree.TextNode(texExpression)]);\n  annotation.setAttribute(\"encoding\", \"application/x-tex\");\n  const semantics = new mathMLTree.MathNode(\"semantics\", [wrapper, annotation]);\n  const math = new mathMLTree.MathNode(\"math\", [semantics]);\n  math.setAttribute(\"xmlns\", \"http://www.w3.org/1998/Math/MathML\");\n\n  if (isDisplayMode) {\n    math.setAttribute(\"display\", \"block\");\n  } // You can't style <math> nodes, so we wrap the node in a span.\n  // NOTE: The span class is not typed to have <math> nodes as children, and\n  // we don't want to make the children type more generic since the children\n  // of span are expected to have more fields in `buildHtml` contexts.\n\n\n  const wrapperClass = forMathmlOnly ? \"katex\" : \"katex-mathml\"; // $FlowFixMe\n\n  return buildCommon.makeSpan([wrapperClass], [math]);\n}\n;// CONCATENATED MODULE: ./src/buildTree.js\n\n\n\n\n\n\n\nconst optionsFromSettings = function (settings) {\n  return new src_Options({\n    style: settings.displayMode ? src_Style.DISPLAY : src_Style.TEXT,\n    maxSize: settings.maxSize,\n    minRuleThickness: settings.minRuleThickness\n  });\n};\n\nconst displayWrap = function (node, settings) {\n  if (settings.displayMode) {\n    const classes = [\"katex-display\"];\n\n    if (settings.leqno) {\n      classes.push(\"leqno\");\n    }\n\n    if (settings.fleqn) {\n      classes.push(\"fleqn\");\n    }\n\n    node = buildCommon.makeSpan(classes, [node]);\n  }\n\n  return node;\n};\n\nconst buildTree = function (tree, expression, settings) {\n  const options = optionsFromSettings(settings);\n  let katexNode;\n\n  if (settings.output === \"mathml\") {\n    return buildMathML(tree, expression, options, settings.displayMode, true);\n  } else if (settings.output === \"html\") {\n    const htmlNode = buildHTML(tree, options);\n    katexNode = buildCommon.makeSpan([\"katex\"], [htmlNode]);\n  } else {\n    const mathMLNode = buildMathML(tree, expression, options, settings.displayMode, false);\n    const htmlNode = buildHTML(tree, options);\n    katexNode = buildCommon.makeSpan([\"katex\"], [mathMLNode, htmlNode]);\n  }\n\n  return displayWrap(katexNode, settings);\n};\nconst buildHTMLTree = function (tree, expression, settings) {\n  const options = optionsFromSettings(settings);\n  const htmlNode = buildHTML(tree, options);\n  const katexNode = buildCommon.makeSpan([\"katex\"], [htmlNode]);\n  return displayWrap(katexNode, settings);\n};\n/* harmony default export */ var src_buildTree = ((/* unused pure expression or super */ null && (0)));\n;// CONCATENATED MODULE: ./src/stretchy.js\n/**\n * This file provides support to buildMathML.js and buildHTML.js\n * for stretchy wide elements rendered from SVG files\n * and other CSS trickery.\n */\n\n\n\n\n\nconst stretchyCodePoint = {\n  widehat: \"^\",\n  widecheck: \"\",\n  widetilde: \"~\",\n  utilde: \"~\",\n  overleftarrow: \"\\u2190\",\n  underleftarrow: \"\\u2190\",\n  xleftarrow: \"\\u2190\",\n  overrightarrow: \"\\u2192\",\n  underrightarrow: \"\\u2192\",\n  xrightarrow: \"\\u2192\",\n  underbrace: \"\\u23df\",\n  overbrace: \"\\u23de\",\n  overgroup: \"\\u23e0\",\n  undergroup: \"\\u23e1\",\n  overleftrightarrow: \"\\u2194\",\n  underleftrightarrow: \"\\u2194\",\n  xleftrightarrow: \"\\u2194\",\n  Overrightarrow: \"\\u21d2\",\n  xRightarrow: \"\\u21d2\",\n  overleftharpoon: \"\\u21bc\",\n  xleftharpoonup: \"\\u21bc\",\n  overrightharpoon: \"\\u21c0\",\n  xrightharpoonup: \"\\u21c0\",\n  xLeftarrow: \"\\u21d0\",\n  xLeftrightarrow: \"\\u21d4\",\n  xhookleftarrow: \"\\u21a9\",\n  xhookrightarrow: \"\\u21aa\",\n  xmapsto: \"\\u21a6\",\n  xrightharpoondown: \"\\u21c1\",\n  xleftharpoondown: \"\\u21bd\",\n  xrightleftharpoons: \"\\u21cc\",\n  xleftrightharpoons: \"\\u21cb\",\n  xtwoheadleftarrow: \"\\u219e\",\n  xtwoheadrightarrow: \"\\u21a0\",\n  xlongequal: \"=\",\n  xtofrom: \"\\u21c4\",\n  xrightleftarrows: \"\\u21c4\",\n  xrightequilibrium: \"\\u21cc\",\n  // Not a perfect match.\n  xleftequilibrium: \"\\u21cb\",\n  // None better available.\n  \"\\\\cdrightarrow\": \"\\u2192\",\n  \"\\\\cdleftarrow\": \"\\u2190\",\n  \"\\\\cdlongequal\": \"=\"\n};\n\nconst mathMLnode = function (label) {\n  const node = new mathMLTree.MathNode(\"mo\", [new mathMLTree.TextNode(stretchyCodePoint[label.replace(/^\\\\/, '')])]);\n  node.setAttribute(\"stretchy\", \"true\");\n  return node;\n}; // Many of the KaTeX SVG images have been adapted from glyphs in KaTeX fonts.\n// Copyright (c) 2009-2010, Design Science, Inc. (<www.mathjax.org>)\n// Copyright (c) 2014-2017 Khan Academy (<www.khanacademy.org>)\n// Licensed under the SIL Open Font License, Version 1.1.\n// See \\nhttp://scripts.sil.org/OFL\n// Very Long SVGs\n//    Many of the KaTeX stretchy wide elements use a long SVG image and an\n//    overflow: hidden tactic to achieve a stretchy image while avoiding\n//    distortion of arrowheads or brace corners.\n//    The SVG typically contains a very long (400 em) arrow.\n//    The SVG is in a container span that has overflow: hidden, so the span\n//    acts like a window that exposes only part of the  SVG.\n//    The SVG always has a longer, thinner aspect ratio than the container span.\n//    After the SVG fills 100% of the height of the container span,\n//    there is a long arrow shaft left over. That left-over shaft is not shown.\n//    Instead, it is sliced off because the span's CSS has overflow: hidden.\n//    Thus, the reader sees an arrow that matches the subject matter width\n//    without distortion.\n//    Some functions, such as \\cancel, need to vary their aspect ratio. These\n//    functions do not get the overflow SVG treatment.\n// Second Brush Stroke\n//    Low resolution monitors struggle to display images in fine detail.\n//    So browsers apply anti-aliasing. A long straight arrow shaft therefore\n//    will sometimes appear as if it has a blurred edge.\n//    To mitigate this, these SVG files contain a second \"brush-stroke\" on the\n//    arrow shafts. That is, a second long thin rectangular SVG path has been\n//    written directly on top of each arrow shaft. This reinforcement causes\n//    some of the screen pixels to display as black instead of the anti-aliased\n//    gray pixel that a  single path would generate. So we get arrow shafts\n//    whose edges appear to be sharper.\n// In the katexImagesData object just below, the dimensions all\n// correspond to path geometry inside the relevant SVG.\n// For example, \\overrightarrow uses the same arrowhead as glyph U+2192\n// from the KaTeX Main font. The scaling factor is 1000.\n// That is, inside the font, that arrowhead is 522 units tall, which\n// corresponds to 0.522 em inside the document.\n\n\nconst katexImagesData = {\n  //   path(s), minWidth, height, align\n  overrightarrow: [[\"rightarrow\"], 0.888, 522, \"xMaxYMin\"],\n  overleftarrow: [[\"leftarrow\"], 0.888, 522, \"xMinYMin\"],\n  underrightarrow: [[\"rightarrow\"], 0.888, 522, \"xMaxYMin\"],\n  underleftarrow: [[\"leftarrow\"], 0.888, 522, \"xMinYMin\"],\n  xrightarrow: [[\"rightarrow\"], 1.469, 522, \"xMaxYMin\"],\n  \"\\\\cdrightarrow\": [[\"rightarrow\"], 3.0, 522, \"xMaxYMin\"],\n  // CD minwwidth2.5pc\n  xleftarrow: [[\"leftarrow\"], 1.469, 522, \"xMinYMin\"],\n  \"\\\\cdleftarrow\": [[\"leftarrow\"], 3.0, 522, \"xMinYMin\"],\n  Overrightarrow: [[\"doublerightarrow\"], 0.888, 560, \"xMaxYMin\"],\n  xRightarrow: [[\"doublerightarrow\"], 1.526, 560, \"xMaxYMin\"],\n  xLeftarrow: [[\"doubleleftarrow\"], 1.526, 560, \"xMinYMin\"],\n  overleftharpoon: [[\"leftharpoon\"], 0.888, 522, \"xMinYMin\"],\n  xleftharpoonup: [[\"leftharpoon\"], 0.888, 522, \"xMinYMin\"],\n  xleftharpoondown: [[\"leftharpoondown\"], 0.888, 522, \"xMinYMin\"],\n  overrightharpoon: [[\"rightharpoon\"], 0.888, 522, \"xMaxYMin\"],\n  xrightharpoonup: [[\"rightharpoon\"], 0.888, 522, \"xMaxYMin\"],\n  xrightharpoondown: [[\"rightharpoondown\"], 0.888, 522, \"xMaxYMin\"],\n  xlongequal: [[\"longequal\"], 0.888, 334, \"xMinYMin\"],\n  \"\\\\cdlongequal\": [[\"longequal\"], 3.0, 334, \"xMinYMin\"],\n  xtwoheadleftarrow: [[\"twoheadleftarrow\"], 0.888, 334, \"xMinYMin\"],\n  xtwoheadrightarrow: [[\"twoheadrightarrow\"], 0.888, 334, \"xMaxYMin\"],\n  overleftrightarrow: [[\"leftarrow\", \"rightarrow\"], 0.888, 522],\n  overbrace: [[\"leftbrace\", \"midbrace\", \"rightbrace\"], 1.6, 548],\n  underbrace: [[\"leftbraceunder\", \"midbraceunder\", \"rightbraceunder\"], 1.6, 548],\n  underleftrightarrow: [[\"leftarrow\", \"rightarrow\"], 0.888, 522],\n  xleftrightarrow: [[\"leftarrow\", \"rightarrow\"], 1.75, 522],\n  xLeftrightarrow: [[\"doubleleftarrow\", \"doublerightarrow\"], 1.75, 560],\n  xrightleftharpoons: [[\"leftharpoondownplus\", \"rightharpoonplus\"], 1.75, 716],\n  xleftrightharpoons: [[\"leftharpoonplus\", \"rightharpoondownplus\"], 1.75, 716],\n  xhookleftarrow: [[\"leftarrow\", \"righthook\"], 1.08, 522],\n  xhookrightarrow: [[\"lefthook\", \"rightarrow\"], 1.08, 522],\n  overlinesegment: [[\"leftlinesegment\", \"rightlinesegment\"], 0.888, 522],\n  underlinesegment: [[\"leftlinesegment\", \"rightlinesegment\"], 0.888, 522],\n  overgroup: [[\"leftgroup\", \"rightgroup\"], 0.888, 342],\n  undergroup: [[\"leftgroupunder\", \"rightgroupunder\"], 0.888, 342],\n  xmapsto: [[\"leftmapsto\", \"rightarrow\"], 1.5, 522],\n  xtofrom: [[\"leftToFrom\", \"rightToFrom\"], 1.75, 528],\n  // The next three arrows are from the mhchem package.\n  // In mhchem.sty, min-length is 2.0em. But these arrows might appear in the\n  // document as \\xrightarrow or \\xrightleftharpoons. Those have\n  // min-length = 1.75em, so we set min-length on these next three to match.\n  xrightleftarrows: [[\"baraboveleftarrow\", \"rightarrowabovebar\"], 1.75, 901],\n  xrightequilibrium: [[\"baraboveshortleftharpoon\", \"rightharpoonaboveshortbar\"], 1.75, 716],\n  xleftequilibrium: [[\"shortbaraboveleftharpoon\", \"shortrightharpoonabovebar\"], 1.75, 716]\n};\n\nconst groupLength = function (arg) {\n  if (arg.type === \"ordgroup\") {\n    return arg.body.length;\n  } else {\n    return 1;\n  }\n};\n\nconst svgSpan = function (group, options) {\n  // Create a span with inline SVG for the element.\n  function buildSvgSpan_() {\n    let viewBoxWidth = 400000; // default\n\n    const label = group.label.slice(1);\n\n    if (utils.contains([\"widehat\", \"widecheck\", \"widetilde\", \"utilde\"], label)) {\n      // Each type in the `if` statement corresponds to one of the ParseNode\n      // types below. This narrowing is required to access `grp.base`.\n      // $FlowFixMe\n      const grp = group; // There are four SVG images available for each function.\n      // Choose a taller image when there are more characters.\n\n      const numChars = groupLength(grp.base);\n      let viewBoxHeight;\n      let pathName;\n      let height;\n\n      if (numChars > 5) {\n        if (label === \"widehat\" || label === \"widecheck\") {\n          viewBoxHeight = 420;\n          viewBoxWidth = 2364;\n          height = 0.42;\n          pathName = label + \"4\";\n        } else {\n          viewBoxHeight = 312;\n          viewBoxWidth = 2340;\n          height = 0.34;\n          pathName = \"tilde4\";\n        }\n      } else {\n        const imgIndex = [1, 1, 2, 2, 3, 3][numChars];\n\n        if (label === \"widehat\" || label === \"widecheck\") {\n          viewBoxWidth = [0, 1062, 2364, 2364, 2364][imgIndex];\n          viewBoxHeight = [0, 239, 300, 360, 420][imgIndex];\n          height = [0, 0.24, 0.3, 0.3, 0.36, 0.42][imgIndex];\n          pathName = label + imgIndex;\n        } else {\n          viewBoxWidth = [0, 600, 1033, 2339, 2340][imgIndex];\n          viewBoxHeight = [0, 260, 286, 306, 312][imgIndex];\n          height = [0, 0.26, 0.286, 0.3, 0.306, 0.34][imgIndex];\n          pathName = \"tilde\" + imgIndex;\n        }\n      }\n\n      const path = new PathNode(pathName);\n      const svgNode = new SvgNode([path], {\n        \"width\": \"100%\",\n        \"height\": makeEm(height),\n        \"viewBox\": \"0 0 \" + viewBoxWidth + \" \" + viewBoxHeight,\n        \"preserveAspectRatio\": \"none\"\n      });\n      return {\n        span: buildCommon.makeSvgSpan([], [svgNode], options),\n        minWidth: 0,\n        height\n      };\n    } else {\n      const spans = [];\n      const data = katexImagesData[label];\n      const [paths, minWidth, viewBoxHeight] = data;\n      const height = viewBoxHeight / 1000;\n      const numSvgChildren = paths.length;\n      let widthClasses;\n      let aligns;\n\n      if (numSvgChildren === 1) {\n        // $FlowFixMe: All these cases must be of the 4-tuple type.\n        const align1 = data[3];\n        widthClasses = [\"hide-tail\"];\n        aligns = [align1];\n      } else if (numSvgChildren === 2) {\n        widthClasses = [\"halfarrow-left\", \"halfarrow-right\"];\n        aligns = [\"xMinYMin\", \"xMaxYMin\"];\n      } else if (numSvgChildren === 3) {\n        widthClasses = [\"brace-left\", \"brace-center\", \"brace-right\"];\n        aligns = [\"xMinYMin\", \"xMidYMin\", \"xMaxYMin\"];\n      } else {\n        throw new Error(\"Correct katexImagesData or update code here to support\\n                    \" + numSvgChildren + \" children.\");\n      }\n\n      for (let i = 0; i < numSvgChildren; i++) {\n        const path = new PathNode(paths[i]);\n        const svgNode = new SvgNode([path], {\n          \"width\": \"400em\",\n          \"height\": makeEm(height),\n          \"viewBox\": \"0 0 \" + viewBoxWidth + \" \" + viewBoxHeight,\n          \"preserveAspectRatio\": aligns[i] + \" slice\"\n        });\n        const span = buildCommon.makeSvgSpan([widthClasses[i]], [svgNode], options);\n\n        if (numSvgChildren === 1) {\n          return {\n            span,\n            minWidth,\n            height\n          };\n        } else {\n          span.style.height = makeEm(height);\n          spans.push(span);\n        }\n      }\n\n      return {\n        span: buildCommon.makeSpan([\"stretchy\"], spans, options),\n        minWidth,\n        height\n      };\n    }\n  } // buildSvgSpan_()\n\n\n  const {\n    span,\n    minWidth,\n    height\n  } = buildSvgSpan_(); // Note that we are returning span.depth = 0.\n  // Any adjustments relative to the baseline must be done in buildHTML.\n\n  span.height = height;\n  span.style.height = makeEm(height);\n\n  if (minWidth > 0) {\n    span.style.minWidth = makeEm(minWidth);\n  }\n\n  return span;\n};\n\nconst encloseSpan = function (inner, label, topPad, bottomPad, options) {\n  // Return an image span for \\cancel, \\bcancel, \\xcancel, \\fbox, or \\angl\n  let img;\n  const totalHeight = inner.height + inner.depth + topPad + bottomPad;\n\n  if (/fbox|color|angl/.test(label)) {\n    img = buildCommon.makeSpan([\"stretchy\", label], [], options);\n\n    if (label === \"fbox\") {\n      const color = options.color && options.getColor();\n\n      if (color) {\n        img.style.borderColor = color;\n      }\n    }\n  } else {\n    // \\cancel, \\bcancel, or \\xcancel\n    // Since \\cancel's SVG is inline and it omits the viewBox attribute,\n    // its stroke-width will not vary with span area.\n    const lines = [];\n\n    if (/^[bx]cancel$/.test(label)) {\n      lines.push(new LineNode({\n        \"x1\": \"0\",\n        \"y1\": \"0\",\n        \"x2\": \"100%\",\n        \"y2\": \"100%\",\n        \"stroke-width\": \"0.046em\"\n      }));\n    }\n\n    if (/^x?cancel$/.test(label)) {\n      lines.push(new LineNode({\n        \"x1\": \"0\",\n        \"y1\": \"100%\",\n        \"x2\": \"100%\",\n        \"y2\": \"0\",\n        \"stroke-width\": \"0.046em\"\n      }));\n    }\n\n    const svgNode = new SvgNode(lines, {\n      \"width\": \"100%\",\n      \"height\": makeEm(totalHeight)\n    });\n    img = buildCommon.makeSvgSpan([], [svgNode], options);\n  }\n\n  img.height = totalHeight;\n  img.style.height = makeEm(totalHeight);\n  return img;\n};\n\n/* harmony default export */ var stretchy = ({\n  encloseSpan,\n  mathMLnode,\n  svgSpan\n});\n;// CONCATENATED MODULE: ./src/parseNode.js\n\n\n/**\n * Asserts that the node is of the given type and returns it with stricter\n * typing. Throws if the node's type does not match.\n */\nfunction assertNodeType(node, type) {\n  if (!node || node.type !== type) {\n    throw new Error(\"Expected node of type \" + type + \", but got \" + (node ? \"node of type \" + node.type : String(node)));\n  } // $FlowFixMe, >=0.125\n\n\n  return node;\n}\n/**\n * Returns the node more strictly typed iff it is of the given type. Otherwise,\n * returns null.\n */\n\nfunction assertSymbolNodeType(node) {\n  const typedNode = checkSymbolNodeType(node);\n\n  if (!typedNode) {\n    throw new Error(\"Expected node of symbol group type, but got \" + (node ? \"node of type \" + node.type : String(node)));\n  }\n\n  return typedNode;\n}\n/**\n * Returns the node more strictly typed iff it is of the given type. Otherwise,\n * returns null.\n */\n\nfunction checkSymbolNodeType(node) {\n  if (node && (node.type === \"atom\" || NON_ATOMS.hasOwnProperty(node.type))) {\n    // $FlowFixMe\n    return node;\n  }\n\n  return null;\n}\n;// CONCATENATED MODULE: ./src/functions/accent.js\n\n\n\n\n\n\n\n\n\n\n// NOTE: Unlike most `htmlBuilder`s, this one handles not only \"accent\", but\n// also \"supsub\" since an accent can affect super/subscripting.\nconst htmlBuilder = (grp, options) => {\n  // Accents are handled in the TeXbook pg. 443, rule 12.\n  let base;\n  let group;\n  let supSubGroup;\n\n  if (grp && grp.type === \"supsub\") {\n    // If our base is a character box, and we have superscripts and\n    // subscripts, the supsub will defer to us. In particular, we want\n    // to attach the superscripts and subscripts to the inner body (so\n    // that the position of the superscripts and subscripts won't be\n    // affected by the height of the accent). We accomplish this by\n    // sticking the base of the accent into the base of the supsub, and\n    // rendering that, while keeping track of where the accent is.\n    // The real accent group is the base of the supsub group\n    group = assertNodeType(grp.base, \"accent\"); // The character box is the base of the accent group\n\n    base = group.base; // Stick the character box into the base of the supsub group\n\n    grp.base = base; // Rerender the supsub group with its new base, and store that\n    // result.\n\n    supSubGroup = assertSpan(buildGroup(grp, options)); // reset original base\n\n    grp.base = group;\n  } else {\n    group = assertNodeType(grp, \"accent\");\n    base = group.base;\n  } // Build the base group\n\n\n  const body = buildGroup(base, options.havingCrampedStyle()); // Does the accent need to shift for the skew of a character?\n\n  const mustShift = group.isShifty && utils.isCharacterBox(base); // Calculate the skew of the accent. This is based on the line \"If the\n  // nucleus is not a single character, let s = 0; otherwise set s to the\n  // kern amount for the nucleus followed by the \\skewchar of its font.\"\n  // Note that our skew metrics are just the kern between each character\n  // and the skewchar.\n\n  let skew = 0;\n\n  if (mustShift) {\n    // If the base is a character box, then we want the skew of the\n    // innermost character. To do that, we find the innermost character:\n    const baseChar = utils.getBaseElem(base); // Then, we render its group to get the symbol inside it\n\n    const baseGroup = buildGroup(baseChar, options.havingCrampedStyle()); // Finally, we pull the skew off of the symbol.\n\n    skew = assertSymbolDomNode(baseGroup).skew; // Note that we now throw away baseGroup, because the layers we\n    // removed with getBaseElem might contain things like \\color which\n    // we can't get rid of.\n    // TODO(emily): Find a better way to get the skew\n  }\n\n  const accentBelow = group.label === \"\\\\c\"; // calculate the amount of space between the body and the accent\n\n  let clearance = accentBelow ? body.height + body.depth : Math.min(body.height, options.fontMetrics().xHeight); // Build the accent\n\n  let accentBody;\n\n  if (!group.isStretchy) {\n    let accent;\n    let width;\n\n    if (group.label === \"\\\\vec\") {\n      // Before version 0.9, \\vec used the combining font glyph U+20D7.\n      // But browsers, especially Safari, are not consistent in how they\n      // render combining characters when not preceded by a character.\n      // So now we use an SVG.\n      // If Safari reforms, we should consider reverting to the glyph.\n      accent = buildCommon.staticSvg(\"vec\", options);\n      width = buildCommon.svgData.vec[1];\n    } else {\n      accent = buildCommon.makeOrd({\n        mode: group.mode,\n        text: group.label\n      }, options, \"textord\");\n      accent = assertSymbolDomNode(accent); // Remove the italic correction of the accent, because it only serves to\n      // shift the accent over to a place we don't want.\n\n      accent.italic = 0;\n      width = accent.width;\n\n      if (accentBelow) {\n        clearance += accent.depth;\n      }\n    }\n\n    accentBody = buildCommon.makeSpan([\"accent-body\"], [accent]); // \"Full\" accents expand the width of the resulting symbol to be\n    // at least the width of the accent, and overlap directly onto the\n    // character without any vertical offset.\n\n    const accentFull = group.label === \"\\\\textcircled\";\n\n    if (accentFull) {\n      accentBody.classes.push('accent-full');\n      clearance = body.height;\n    } // Shift the accent over by the skew.\n\n\n    let left = skew; // CSS defines `.katex .accent .accent-body:not(.accent-full) { width: 0 }`\n    // so that the accent doesn't contribute to the bounding box.\n    // We need to shift the character by its width (effectively half\n    // its width) to compensate.\n\n    if (!accentFull) {\n      left -= width / 2;\n    }\n\n    accentBody.style.left = makeEm(left); // \\textcircled uses the \\bigcirc glyph, so it needs some\n    // vertical adjustment to match LaTeX.\n\n    if (group.label === \"\\\\textcircled\") {\n      accentBody.style.top = \".2em\";\n    }\n\n    accentBody = buildCommon.makeVList({\n      positionType: \"firstBaseline\",\n      children: [{\n        type: \"elem\",\n        elem: body\n      }, {\n        type: \"kern\",\n        size: -clearance\n      }, {\n        type: \"elem\",\n        elem: accentBody\n      }]\n    }, options);\n  } else {\n    accentBody = stretchy.svgSpan(group, options);\n    accentBody = buildCommon.makeVList({\n      positionType: \"firstBaseline\",\n      children: [{\n        type: \"elem\",\n        elem: body\n      }, {\n        type: \"elem\",\n        elem: accentBody,\n        wrapperClasses: [\"svg-align\"],\n        wrapperStyle: skew > 0 ? {\n          width: \"calc(100% - \" + makeEm(2 * skew) + \")\",\n          marginLeft: makeEm(2 * skew)\n        } : undefined\n      }]\n    }, options);\n  }\n\n  const accentWrap = buildCommon.makeSpan([\"mord\", \"accent\"], [accentBody], options);\n\n  if (supSubGroup) {\n    // Here, we replace the \"base\" child of the supsub with our newly\n    // generated accent.\n    supSubGroup.children[0] = accentWrap; // Since we don't rerun the height calculation after replacing the\n    // accent, we manually recalculate height.\n\n    supSubGroup.height = Math.max(accentWrap.height, supSubGroup.height); // Accents should always be ords, even when their innards are not.\n\n    supSubGroup.classes[0] = \"mord\";\n    return supSubGroup;\n  } else {\n    return accentWrap;\n  }\n};\n\nconst mathmlBuilder = (group, options) => {\n  const accentNode = group.isStretchy ? stretchy.mathMLnode(group.label) : new mathMLTree.MathNode(\"mo\", [makeText(group.label, group.mode)]);\n  const node = new mathMLTree.MathNode(\"mover\", [buildMathML_buildGroup(group.base, options), accentNode]);\n  node.setAttribute(\"accent\", \"true\");\n  return node;\n};\n\nconst NON_STRETCHY_ACCENT_REGEX = new RegExp([\"\\\\acute\", \"\\\\grave\", \"\\\\ddot\", \"\\\\tilde\", \"\\\\bar\", \"\\\\breve\", \"\\\\check\", \"\\\\hat\", \"\\\\vec\", \"\\\\dot\", \"\\\\mathring\"].map(accent => \"\\\\\" + accent).join(\"|\")); // Accents\n\ndefineFunction({\n  type: \"accent\",\n  names: [\"\\\\acute\", \"\\\\grave\", \"\\\\ddot\", \"\\\\tilde\", \"\\\\bar\", \"\\\\breve\", \"\\\\check\", \"\\\\hat\", \"\\\\vec\", \"\\\\dot\", \"\\\\mathring\", \"\\\\widecheck\", \"\\\\widehat\", \"\\\\widetilde\", \"\\\\overrightarrow\", \"\\\\overleftarrow\", \"\\\\Overrightarrow\", \"\\\\overleftrightarrow\", \"\\\\overgroup\", \"\\\\overlinesegment\", \"\\\\overleftharpoon\", \"\\\\overrightharpoon\"],\n  props: {\n    numArgs: 1\n  },\n  handler: (context, args) => {\n    const base = normalizeArgument(args[0]);\n    const isStretchy = !NON_STRETCHY_ACCENT_REGEX.test(context.funcName);\n    const isShifty = !isStretchy || context.funcName === \"\\\\widehat\" || context.funcName === \"\\\\widetilde\" || context.funcName === \"\\\\widecheck\";\n    return {\n      type: \"accent\",\n      mode: context.parser.mode,\n      label: context.funcName,\n      isStretchy: isStretchy,\n      isShifty: isShifty,\n      base: base\n    };\n  },\n  htmlBuilder,\n  mathmlBuilder\n}); // Text-mode accents\n\ndefineFunction({\n  type: \"accent\",\n  names: [\"\\\\'\", \"\\\\`\", \"\\\\^\", \"\\\\~\", \"\\\\=\", \"\\\\u\", \"\\\\.\", '\\\\\"', \"\\\\c\", \"\\\\r\", \"\\\\H\", \"\\\\v\", \"\\\\textcircled\"],\n  props: {\n    numArgs: 1,\n    allowedInText: true,\n    allowedInMath: true,\n    // unless in strict mode\n    argTypes: [\"primitive\"]\n  },\n  handler: (context, args) => {\n    const base = args[0];\n    let mode = context.parser.mode;\n\n    if (mode === \"math\") {\n      context.parser.settings.reportNonstrict(\"mathVsTextAccents\", \"LaTeX's accent \" + context.funcName + \" works only in text mode\");\n      mode = \"text\";\n    }\n\n    return {\n      type: \"accent\",\n      mode: mode,\n      label: context.funcName,\n      isStretchy: false,\n      isShifty: true,\n      base: base\n    };\n  },\n  htmlBuilder,\n  mathmlBuilder\n});\n;// CONCATENATED MODULE: ./src/functions/accentunder.js\n// Horizontal overlap functions\n\n\n\n\n\n\ndefineFunction({\n  type: \"accentUnder\",\n  names: [\"\\\\underleftarrow\", \"\\\\underrightarrow\", \"\\\\underleftrightarrow\", \"\\\\undergroup\", \"\\\\underlinesegment\", \"\\\\utilde\"],\n  props: {\n    numArgs: 1\n  },\n  handler: (_ref, args) => {\n    let {\n      parser,\n      funcName\n    } = _ref;\n    const base = args[0];\n    return {\n      type: \"accentUnder\",\n      mode: parser.mode,\n      label: funcName,\n      base: base\n    };\n  },\n  htmlBuilder: (group, options) => {\n    // Treat under accents much like underlines.\n    const innerGroup = buildGroup(group.base, options);\n    const accentBody = stretchy.svgSpan(group, options);\n    const kern = group.label === \"\\\\utilde\" ? 0.12 : 0; // Generate the vlist, with the appropriate kerns\n\n    const vlist = buildCommon.makeVList({\n      positionType: \"top\",\n      positionData: innerGroup.height,\n      children: [{\n        type: \"elem\",\n        elem: accentBody,\n        wrapperClasses: [\"svg-align\"]\n      }, {\n        type: \"kern\",\n        size: kern\n      }, {\n        type: \"elem\",\n        elem: innerGroup\n      }]\n    }, options);\n    return buildCommon.makeSpan([\"mord\", \"accentunder\"], [vlist], options);\n  },\n  mathmlBuilder: (group, options) => {\n    const accentNode = stretchy.mathMLnode(group.label);\n    const node = new mathMLTree.MathNode(\"munder\", [buildMathML_buildGroup(group.base, options), accentNode]);\n    node.setAttribute(\"accentunder\", \"true\");\n    return node;\n  }\n});\n;// CONCATENATED MODULE: ./src/functions/arrow.js\n\n\n\n\n\n\n\n// Helper function\nconst paddedNode = group => {\n  const node = new mathMLTree.MathNode(\"mpadded\", group ? [group] : []);\n  node.setAttribute(\"width\", \"+0.6em\");\n  node.setAttribute(\"lspace\", \"0.3em\");\n  return node;\n}; // Stretchy arrows with an optional argument\n\n\ndefineFunction({\n  type: \"xArrow\",\n  names: [\"\\\\xleftarrow\", \"\\\\xrightarrow\", \"\\\\xLeftarrow\", \"\\\\xRightarrow\", \"\\\\xleftrightarrow\", \"\\\\xLeftrightarrow\", \"\\\\xhookleftarrow\", \"\\\\xhookrightarrow\", \"\\\\xmapsto\", \"\\\\xrightharpoondown\", \"\\\\xrightharpoonup\", \"\\\\xleftharpoondown\", \"\\\\xleftharpoonup\", \"\\\\xrightleftharpoons\", \"\\\\xleftrightharpoons\", \"\\\\xlongequal\", \"\\\\xtwoheadrightarrow\", \"\\\\xtwoheadleftarrow\", \"\\\\xtofrom\", // The next 3 functions are here to support the mhchem extension.\n  // Direct use of these functions is discouraged and may break someday.\n  \"\\\\xrightleftarrows\", \"\\\\xrightequilibrium\", \"\\\\xleftequilibrium\", // The next 3 functions are here only to support the {CD} environment.\n  \"\\\\\\\\cdrightarrow\", \"\\\\\\\\cdleftarrow\", \"\\\\\\\\cdlongequal\"],\n  props: {\n    numArgs: 1,\n    numOptionalArgs: 1\n  },\n\n  handler(_ref, args, optArgs) {\n    let {\n      parser,\n      funcName\n    } = _ref;\n    return {\n      type: \"xArrow\",\n      mode: parser.mode,\n      label: funcName,\n      body: args[0],\n      below: optArgs[0]\n    };\n  },\n\n  // Flow is unable to correctly infer the type of `group`, even though it's\n  // unambiguously determined from the passed-in `type` above.\n  htmlBuilder(group, options) {\n    const style = options.style; // Build the argument groups in the appropriate style.\n    // Ref: amsmath.dtx:   \\hbox{$\\scriptstyle\\mkern#3mu{#6}\\mkern#4mu$}%\n    // Some groups can return document fragments.  Handle those by wrapping\n    // them in a span.\n\n    let newOptions = options.havingStyle(style.sup());\n    const upperGroup = buildCommon.wrapFragment(buildGroup(group.body, newOptions, options), options);\n    const arrowPrefix = group.label.slice(0, 2) === \"\\\\x\" ? \"x\" : \"cd\";\n    upperGroup.classes.push(arrowPrefix + \"-arrow-pad\");\n    let lowerGroup;\n\n    if (group.below) {\n      // Build the lower group\n      newOptions = options.havingStyle(style.sub());\n      lowerGroup = buildCommon.wrapFragment(buildGroup(group.below, newOptions, options), options);\n      lowerGroup.classes.push(arrowPrefix + \"-arrow-pad\");\n    }\n\n    const arrowBody = stretchy.svgSpan(group, options); // Re shift: Note that stretchy.svgSpan returned arrowBody.depth = 0.\n    // The point we want on the math axis is at 0.5 * arrowBody.height.\n\n    const arrowShift = -options.fontMetrics().axisHeight + 0.5 * arrowBody.height; // 2 mu kern. Ref: amsmath.dtx: #7\\if0#2\\else\\mkern#2mu\\fi\n\n    let upperShift = -options.fontMetrics().axisHeight - 0.5 * arrowBody.height - 0.111; // 0.111 em = 2 mu\n\n    if (upperGroup.depth > 0.25 || group.label === \"\\\\xleftequilibrium\") {\n      upperShift -= upperGroup.depth; // shift up if depth encroaches\n    } // Generate the vlist\n\n\n    let vlist;\n\n    if (lowerGroup) {\n      const lowerShift = -options.fontMetrics().axisHeight + lowerGroup.height + 0.5 * arrowBody.height + 0.111;\n      vlist = buildCommon.makeVList({\n        positionType: \"individualShift\",\n        children: [{\n          type: \"elem\",\n          elem: upperGroup,\n          shift: upperShift\n        }, {\n          type: \"elem\",\n          elem: arrowBody,\n          shift: arrowShift\n        }, {\n          type: \"elem\",\n          elem: lowerGroup,\n          shift: lowerShift\n        }]\n      }, options);\n    } else {\n      vlist = buildCommon.makeVList({\n        positionType: \"individualShift\",\n        children: [{\n          type: \"elem\",\n          elem: upperGroup,\n          shift: upperShift\n        }, {\n          type: \"elem\",\n          elem: arrowBody,\n          shift: arrowShift\n        }]\n      }, options);\n    } // $FlowFixMe: Replace this with passing \"svg-align\" into makeVList.\n\n\n    vlist.children[0].children[0].children[1].classes.push(\"svg-align\");\n    return buildCommon.makeSpan([\"mrel\", \"x-arrow\"], [vlist], options);\n  },\n\n  mathmlBuilder(group, options) {\n    const arrowNode = stretchy.mathMLnode(group.label);\n    arrowNode.setAttribute(\"minsize\", group.label.charAt(0) === \"x\" ? \"1.75em\" : \"3.0em\");\n    let node;\n\n    if (group.body) {\n      const upperNode = paddedNode(buildMathML_buildGroup(group.body, options));\n\n      if (group.below) {\n        const lowerNode = paddedNode(buildMathML_buildGroup(group.below, options));\n        node = new mathMLTree.MathNode(\"munderover\", [arrowNode, lowerNode, upperNode]);\n      } else {\n        node = new mathMLTree.MathNode(\"mover\", [arrowNode, upperNode]);\n      }\n    } else if (group.below) {\n      const lowerNode = paddedNode(buildMathML_buildGroup(group.below, options));\n      node = new mathMLTree.MathNode(\"munder\", [arrowNode, lowerNode]);\n    } else {\n      // This should never happen.\n      // Parser.js throws an error if there is no argument.\n      node = paddedNode();\n      node = new mathMLTree.MathNode(\"mover\", [arrowNode, node]);\n    }\n\n    return node;\n  }\n\n});\n;// CONCATENATED MODULE: ./src/functions/mclass.js\n\n\n\n\n\n\nconst mclass_makeSpan = buildCommon.makeSpan;\n\nfunction mclass_htmlBuilder(group, options) {\n  const elements = buildExpression(group.body, options, true);\n  return mclass_makeSpan([group.mclass], elements, options);\n}\n\nfunction mclass_mathmlBuilder(group, options) {\n  let node;\n  const inner = buildMathML_buildExpression(group.body, options);\n\n  if (group.mclass === \"minner\") {\n    node = new mathMLTree.MathNode(\"mpadded\", inner);\n  } else if (group.mclass === \"mord\") {\n    if (group.isCharacterBox) {\n      node = inner[0];\n      node.type = \"mi\";\n    } else {\n      node = new mathMLTree.MathNode(\"mi\", inner);\n    }\n  } else {\n    if (group.isCharacterBox) {\n      node = inner[0];\n      node.type = \"mo\";\n    } else {\n      node = new mathMLTree.MathNode(\"mo\", inner);\n    } // Set spacing based on what is the most likely adjacent atom type.\n    // See TeXbook p170.\n\n\n    if (group.mclass === \"mbin\") {\n      node.attributes.lspace = \"0.22em\"; // medium space\n\n      node.attributes.rspace = \"0.22em\";\n    } else if (group.mclass === \"mpunct\") {\n      node.attributes.lspace = \"0em\";\n      node.attributes.rspace = \"0.17em\"; // thinspace\n    } else if (group.mclass === \"mopen\" || group.mclass === \"mclose\") {\n      node.attributes.lspace = \"0em\";\n      node.attributes.rspace = \"0em\";\n    } else if (group.mclass === \"minner\") {\n      node.attributes.lspace = \"0.0556em\"; // 1 mu is the most likely option\n\n      node.attributes.width = \"+0.1111em\";\n    } // MathML <mo> default space is 5/18 em, so <mrel> needs no action.\n    // Ref: https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mo\n\n  }\n\n  return node;\n} // Math class commands except \\mathop\n\n\ndefineFunction({\n  type: \"mclass\",\n  names: [\"\\\\mathord\", \"\\\\mathbin\", \"\\\\mathrel\", \"\\\\mathopen\", \"\\\\mathclose\", \"\\\\mathpunct\", \"\\\\mathinner\"],\n  props: {\n    numArgs: 1,\n    primitive: true\n  },\n\n  handler(_ref, args) {\n    let {\n      parser,\n      funcName\n    } = _ref;\n    const body = args[0];\n    return {\n      type: \"mclass\",\n      mode: parser.mode,\n      mclass: \"m\" + funcName.slice(5),\n      // TODO(kevinb): don't prefix with 'm'\n      body: ordargument(body),\n      isCharacterBox: utils.isCharacterBox(body)\n    };\n  },\n\n  htmlBuilder: mclass_htmlBuilder,\n  mathmlBuilder: mclass_mathmlBuilder\n});\nconst binrelClass = arg => {\n  // \\binrel@ spacing varies with (bin|rel|ord) of the atom in the argument.\n  // (by rendering separately and with {}s before and after, and measuring\n  // the change in spacing).  We'll do roughly the same by detecting the\n  // atom type directly.\n  const atom = arg.type === \"ordgroup\" && arg.body.length ? arg.body[0] : arg;\n\n  if (atom.type === \"atom\" && (atom.family === \"bin\" || atom.family === \"rel\")) {\n    return \"m\" + atom.family;\n  } else {\n    return \"mord\";\n  }\n}; // \\@binrel{x}{y} renders like y but as mbin/mrel/mord if x is mbin/mrel/mord.\n// This is equivalent to \\binrel@{x}\\binrel@@{y} in AMSTeX.\n\ndefineFunction({\n  type: \"mclass\",\n  names: [\"\\\\@binrel\"],\n  props: {\n    numArgs: 2\n  },\n\n  handler(_ref2, args) {\n    let {\n      parser\n    } = _ref2;\n    return {\n      type: \"mclass\",\n      mode: parser.mode,\n      mclass: binrelClass(args[0]),\n      body: ordargument(args[1]),\n      isCharacterBox: utils.isCharacterBox(args[1])\n    };\n  }\n\n}); // Build a relation or stacked op by placing one symbol on top of another\n\ndefineFunction({\n  type: \"mclass\",\n  names: [\"\\\\stackrel\", \"\\\\overset\", \"\\\\underset\"],\n  props: {\n    numArgs: 2\n  },\n\n  handler(_ref3, args) {\n    let {\n      parser,\n      funcName\n    } = _ref3;\n    const baseArg = args[1];\n    const shiftedArg = args[0];\n    let mclass;\n\n    if (funcName !== \"\\\\stackrel\") {\n      // LaTeX applies \\binrel spacing to \\overset and \\underset.\n      mclass = binrelClass(baseArg);\n    } else {\n      mclass = \"mrel\"; // for \\stackrel\n    }\n\n    const baseOp = {\n      type: \"op\",\n      mode: baseArg.mode,\n      limits: true,\n      alwaysHandleSupSub: true,\n      parentIsSupSub: false,\n      symbol: false,\n      suppressBaseShift: funcName !== \"\\\\stackrel\",\n      body: ordargument(baseArg)\n    };\n    const supsub = {\n      type: \"supsub\",\n      mode: shiftedArg.mode,\n      base: baseOp,\n      sup: funcName === \"\\\\underset\" ? null : shiftedArg,\n      sub: funcName === \"\\\\underset\" ? shiftedArg : null\n    };\n    return {\n      type: \"mclass\",\n      mode: parser.mode,\n      mclass,\n      body: [supsub],\n      isCharacterBox: utils.isCharacterBox(supsub)\n    };\n  },\n\n  htmlBuilder: mclass_htmlBuilder,\n  mathmlBuilder: mclass_mathmlBuilder\n});\n;// CONCATENATED MODULE: ./src/functions/pmb.js\n\n\n\n\n\n\n// \\pmb is a simulation of bold font.\n// The version of \\pmb in ambsy.sty works by typesetting three copies\n// with small offsets. We use CSS text-shadow.\n// It's a hack. Not as good as a real bold font. Better than nothing.\ndefineFunction({\n  type: \"pmb\",\n  names: [\"\\\\pmb\"],\n  props: {\n    numArgs: 1,\n    allowedInText: true\n  },\n\n  handler(_ref, args) {\n    let {\n      parser\n    } = _ref;\n    return {\n      type: \"pmb\",\n      mode: parser.mode,\n      mclass: binrelClass(args[0]),\n      body: ordargument(args[0])\n    };\n  },\n\n  htmlBuilder(group, options) {\n    const elements = buildExpression(group.body, options, true);\n    const node = buildCommon.makeSpan([group.mclass], elements, options);\n    node.style.textShadow = \"0.02em 0.01em 0.04px\";\n    return node;\n  },\n\n  mathmlBuilder(group, style) {\n    const inner = buildMathML_buildExpression(group.body, style); // Wrap with an <mstyle> element.\n\n    const node = new mathMLTree.MathNode(\"mstyle\", inner);\n    node.setAttribute(\"style\", \"text-shadow: 0.02em 0.01em 0.04px\");\n    return node;\n  }\n\n});\n;// CONCATENATED MODULE: ./src/environments/cd.js\n\n\n\n\n\n\n\n\nconst cdArrowFunctionName = {\n  \">\": \"\\\\\\\\cdrightarrow\",\n  \"<\": \"\\\\\\\\cdleftarrow\",\n  \"=\": \"\\\\\\\\cdlongequal\",\n  \"A\": \"\\\\uparrow\",\n  \"V\": \"\\\\downarrow\",\n  \"|\": \"\\\\Vert\",\n  \".\": \"no arrow\"\n};\n\nconst newCell = () => {\n  // Create an empty cell, to be filled below with parse nodes.\n  // The parseTree from this module must be constructed like the\n  // one created by parseArray(), so an empty CD cell must\n  // be a ParseNode<\"styling\">. And CD is always displaystyle.\n  // So these values are fixed and flow can do implicit typing.\n  return {\n    type: \"styling\",\n    body: [],\n    mode: \"math\",\n    style: \"display\"\n  };\n};\n\nconst isStartOfArrow = node => {\n  return node.type === \"textord\" && node.text === \"@\";\n};\n\nconst isLabelEnd = (node, endChar) => {\n  return (node.type === \"mathord\" || node.type === \"atom\") && node.text === endChar;\n};\n\nfunction cdArrow(arrowChar, labels, parser) {\n  // Return a parse tree of an arrow and its labels.\n  // This acts in a way similar to a macro expansion.\n  const funcName = cdArrowFunctionName[arrowChar];\n\n  switch (funcName) {\n    case \"\\\\\\\\cdrightarrow\":\n    case \"\\\\\\\\cdleftarrow\":\n      return parser.callFunction(funcName, [labels[0]], [labels[1]]);\n\n    case \"\\\\uparrow\":\n    case \"\\\\downarrow\":\n      {\n        const leftLabel = parser.callFunction(\"\\\\\\\\cdleft\", [labels[0]], []);\n        const bareArrow = {\n          type: \"atom\",\n          text: funcName,\n          mode: \"math\",\n          family: \"rel\"\n        };\n        const sizedArrow = parser.callFunction(\"\\\\Big\", [bareArrow], []);\n        const rightLabel = parser.callFunction(\"\\\\\\\\cdright\", [labels[1]], []);\n        const arrowGroup = {\n          type: \"ordgroup\",\n          mode: \"math\",\n          body: [leftLabel, sizedArrow, rightLabel]\n        };\n        return parser.callFunction(\"\\\\\\\\cdparent\", [arrowGroup], []);\n      }\n\n    case \"\\\\\\\\cdlongequal\":\n      return parser.callFunction(\"\\\\\\\\cdlongequal\", [], []);\n\n    case \"\\\\Vert\":\n      {\n        const arrow = {\n          type: \"textord\",\n          text: \"\\\\Vert\",\n          mode: \"math\"\n        };\n        return parser.callFunction(\"\\\\Big\", [arrow], []);\n      }\n\n    default:\n      return {\n        type: \"textord\",\n        text: \" \",\n        mode: \"math\"\n      };\n  }\n}\n\nfunction parseCD(parser) {\n  // Get the array's parse nodes with \\\\ temporarily mapped to \\cr.\n  const parsedRows = [];\n  parser.gullet.beginGroup();\n  parser.gullet.macros.set(\"\\\\cr\", \"\\\\\\\\\\\\relax\");\n  parser.gullet.beginGroup();\n\n  while (true) {\n    // eslint-disable-line no-constant-condition\n    // Get the parse nodes for the next row.\n    parsedRows.push(parser.parseExpression(false, \"\\\\\\\\\"));\n    parser.gullet.endGroup();\n    parser.gullet.beginGroup();\n    const next = parser.fetch().text;\n\n    if (next === \"&\" || next === \"\\\\\\\\\") {\n      parser.consume();\n    } else if (next === \"\\\\end\") {\n      if (parsedRows[parsedRows.length - 1].length === 0) {\n        parsedRows.pop(); // final row ended in \\\\\n      }\n\n      break;\n    } else {\n      throw new src_ParseError(\"Expected \\\\\\\\ or \\\\cr or \\\\end\", parser.nextToken);\n    }\n  }\n\n  let row = [];\n  const body = [row]; // Loop thru the parse nodes. Collect them into cells and arrows.\n\n  for (let i = 0; i < parsedRows.length; i++) {\n    // Start a new row.\n    const rowNodes = parsedRows[i]; // Create the first cell.\n\n    let cell = newCell();\n\n    for (let j = 0; j < rowNodes.length; j++) {\n      if (!isStartOfArrow(rowNodes[j])) {\n        // If a parseNode is not an arrow, it goes into a cell.\n        cell.body.push(rowNodes[j]);\n      } else {\n        // Parse node j is an \"@\", the start of an arrow.\n        // Before starting on the arrow, push the cell into `row`.\n        row.push(cell); // Now collect parseNodes into an arrow.\n        // The character after \"@\" defines the arrow type.\n\n        j += 1;\n        const arrowChar = assertSymbolNodeType(rowNodes[j]).text; // Create two empty label nodes. We may or may not use them.\n\n        const labels = new Array(2);\n        labels[0] = {\n          type: \"ordgroup\",\n          mode: \"math\",\n          body: []\n        };\n        labels[1] = {\n          type: \"ordgroup\",\n          mode: \"math\",\n          body: []\n        }; // Process the arrow.\n\n        if (\"=|.\".indexOf(arrowChar) > -1) {// Three \"arrows\", ``@=`, `@|`, and `@.`, do not take labels.\n          // Do nothing here.\n        } else if (\"<>AV\".indexOf(arrowChar) > -1) {\n          // Four arrows, `@>>>`, `@<<<`, `@AAA`, and `@VVV`, each take\n          // two optional labels. E.g. the right-point arrow syntax is\n          // really:  @>{optional label}>{optional label}>\n          // Collect parseNodes into labels.\n          for (let labelNum = 0; labelNum < 2; labelNum++) {\n            let inLabel = true;\n\n            for (let k = j + 1; k < rowNodes.length; k++) {\n              if (isLabelEnd(rowNodes[k], arrowChar)) {\n                inLabel = false;\n                j = k;\n                break;\n              }\n\n              if (isStartOfArrow(rowNodes[k])) {\n                throw new src_ParseError(\"Missing a \" + arrowChar + \" character to complete a CD arrow.\", rowNodes[k]);\n              }\n\n              labels[labelNum].body.push(rowNodes[k]);\n            }\n\n            if (inLabel) {\n              // isLabelEnd never returned a true.\n              throw new src_ParseError(\"Missing a \" + arrowChar + \" character to complete a CD arrow.\", rowNodes[j]);\n            }\n          }\n        } else {\n          throw new src_ParseError(\"Expected one of \\\"<>AV=|.\\\" after @\", rowNodes[j]);\n        } // Now join the arrow to its labels.\n\n\n        const arrow = cdArrow(arrowChar, labels, parser); // Wrap the arrow in  ParseNode<\"styling\">.\n        // This is done to match parseArray() behavior.\n\n        const wrappedArrow = {\n          type: \"styling\",\n          body: [arrow],\n          mode: \"math\",\n          style: \"display\" // CD is always displaystyle.\n\n        };\n        row.push(wrappedArrow); // In CD's syntax, cells are implicit. That is, everything that\n        // is not an arrow gets collected into a cell. So create an empty\n        // cell now. It will collect upcoming parseNodes.\n\n        cell = newCell();\n      }\n    }\n\n    if (i % 2 === 0) {\n      // Even-numbered rows consist of: cell, arrow, cell, arrow, ... cell\n      // The last cell is not yet pushed into `row`, so:\n      row.push(cell);\n    } else {\n      // Odd-numbered rows consist of: vert arrow, empty cell, ... vert arrow\n      // Remove the empty cell that was placed at the beginning of `row`.\n      row.shift();\n    }\n\n    row = [];\n    body.push(row);\n  } // End row group\n\n\n  parser.gullet.endGroup(); // End array group defining \\\\\n\n  parser.gullet.endGroup(); // define column separation.\n\n  const cols = new Array(body[0].length).fill({\n    type: \"align\",\n    align: \"c\",\n    pregap: 0.25,\n    // CD package sets \\enskip between columns.\n    postgap: 0.25 // So pre and post each get half an \\enskip, i.e. 0.25em.\n\n  });\n  return {\n    type: \"array\",\n    mode: \"math\",\n    body,\n    arraystretch: 1,\n    addJot: true,\n    rowGaps: [null],\n    cols,\n    colSeparationType: \"CD\",\n    hLinesBeforeRow: new Array(body.length + 1).fill([])\n  };\n} // The functions below are not available for general use.\n// They are here only for internal use by the {CD} environment in placing labels\n// next to vertical arrows.\n// We don't need any such functions for horizontal arrows because we can reuse\n// the functionality that already exists for extensible arrows.\n\ndefineFunction({\n  type: \"cdlabel\",\n  names: [\"\\\\\\\\cdleft\", \"\\\\\\\\cdright\"],\n  props: {\n    numArgs: 1\n  },\n\n  handler(_ref, args) {\n    let {\n      parser,\n      funcName\n    } = _ref;\n    return {\n      type: \"cdlabel\",\n      mode: parser.mode,\n      side: funcName.slice(4),\n      label: args[0]\n    };\n  },\n\n  htmlBuilder(group, options) {\n    const newOptions = options.havingStyle(options.style.sup());\n    const label = buildCommon.wrapFragment(buildGroup(group.label, newOptions, options), options);\n    label.classes.push(\"cd-label-\" + group.side);\n    label.style.bottom = makeEm(0.8 - label.depth); // Zero out label height & depth, so vertical align of arrow is set\n    // by the arrow height, not by the label.\n\n    label.height = 0;\n    label.depth = 0;\n    return label;\n  },\n\n  mathmlBuilder(group, options) {\n    let label = new mathMLTree.MathNode(\"mrow\", [buildMathML_buildGroup(group.label, options)]);\n    label = new mathMLTree.MathNode(\"mpadded\", [label]);\n    label.setAttribute(\"width\", \"0\");\n\n    if (group.side === \"left\") {\n      label.setAttribute(\"lspace\", \"-1width\");\n    } // We have to guess at vertical alignment. We know the arrow is 1.8em tall,\n    // But we don't know the height or depth of the label.\n\n\n    label.setAttribute(\"voffset\", \"0.7em\");\n    label = new mathMLTree.MathNode(\"mstyle\", [label]);\n    label.setAttribute(\"displaystyle\", \"false\");\n    label.setAttribute(\"scriptlevel\", \"1\");\n    return label;\n  }\n\n});\ndefineFunction({\n  type: \"cdlabelparent\",\n  names: [\"\\\\\\\\cdparent\"],\n  props: {\n    numArgs: 1\n  },\n\n  handler(_ref2, args) {\n    let {\n      parser\n    } = _ref2;\n    return {\n      type: \"cdlabelparent\",\n      mode: parser.mode,\n      fragment: args[0]\n    };\n  },\n\n  htmlBuilder(group, options) {\n    // Wrap the vertical arrow and its labels.\n    // The parent gets position: relative. The child gets position: absolute.\n    // So CSS can locate the label correctly.\n    const parent = buildCommon.wrapFragment(buildGroup(group.fragment, options), options);\n    parent.classes.push(\"cd-vert-arrow\");\n    return parent;\n  },\n\n  mathmlBuilder(group, options) {\n    return new mathMLTree.MathNode(\"mrow\", [buildMathML_buildGroup(group.fragment, options)]);\n  }\n\n});\n;// CONCATENATED MODULE: ./src/functions/char.js\n\n\n // \\@char is an internal function that takes a grouped decimal argument like\n// {123} and converts into symbol with code 123.  It is used by the *macro*\n// \\char defined in macros.js.\n\ndefineFunction({\n  type: \"textord\",\n  names: [\"\\\\@char\"],\n  props: {\n    numArgs: 1,\n    allowedInText: true\n  },\n\n  handler(_ref, args) {\n    let {\n      parser\n    } = _ref;\n    const arg = assertNodeType(args[0], \"ordgroup\");\n    const group = arg.body;\n    let number = \"\";\n\n    for (let i = 0; i < group.length; i++) {\n      const node = assertNodeType(group[i], \"textord\");\n      number += node.text;\n    }\n\n    let code = parseInt(number);\n    let text;\n\n    if (isNaN(code)) {\n      throw new src_ParseError(\"\\\\@char has non-numeric argument \" + number); // If we drop IE support, the following code could be replaced with\n      // text = String.fromCodePoint(code)\n    } else if (code < 0 || code >= 0x10ffff) {\n      throw new src_ParseError(\"\\\\@char with invalid code point \" + number);\n    } else if (code <= 0xffff) {\n      text = String.fromCharCode(code);\n    } else {\n      // Astral code point; split into surrogate halves\n      code -= 0x10000;\n      text = String.fromCharCode((code >> 10) + 0xd800, (code & 0x3ff) + 0xdc00);\n    }\n\n    return {\n      type: \"textord\",\n      mode: parser.mode,\n      text: text\n    };\n  }\n\n});\n;// CONCATENATED MODULE: ./src/functions/color.js\n\n\n\n\n\n\n\nconst color_htmlBuilder = (group, options) => {\n  const elements = buildExpression(group.body, options.withColor(group.color), false); // \\color isn't supposed to affect the type of the elements it contains.\n  // To accomplish this, we wrap the results in a fragment, so the inner\n  // elements will be able to directly interact with their neighbors. For\n  // example, `\\color{red}{2 +} 3` has the same spacing as `2 + 3`\n\n  return buildCommon.makeFragment(elements);\n};\n\nconst color_mathmlBuilder = (group, options) => {\n  const inner = buildMathML_buildExpression(group.body, options.withColor(group.color));\n  const node = new mathMLTree.MathNode(\"mstyle\", inner);\n  node.setAttribute(\"mathcolor\", group.color);\n  return node;\n};\n\ndefineFunction({\n  type: \"color\",\n  names: [\"\\\\textcolor\"],\n  props: {\n    numArgs: 2,\n    allowedInText: true,\n    argTypes: [\"color\", \"original\"]\n  },\n\n  handler(_ref, args) {\n    let {\n      parser\n    } = _ref;\n    const color = assertNodeType(args[0], \"color-token\").color;\n    const body = args[1];\n    return {\n      type: \"color\",\n      mode: parser.mode,\n      color,\n      body: ordargument(body)\n    };\n  },\n\n  htmlBuilder: color_htmlBuilder,\n  mathmlBuilder: color_mathmlBuilder\n});\ndefineFunction({\n  type: \"color\",\n  names: [\"\\\\color\"],\n  props: {\n    numArgs: 1,\n    allowedInText: true,\n    argTypes: [\"color\"]\n  },\n\n  handler(_ref2, args) {\n    let {\n      parser,\n      breakOnTokenText\n    } = _ref2;\n    const color = assertNodeType(args[0], \"color-token\").color; // Set macro \\current@color in current namespace to store the current\n    // color, mimicking the behavior of color.sty.\n    // This is currently used just to correctly color a \\right\n    // that follows a \\color command.\n\n    parser.gullet.macros.set(\"\\\\current@color\", color); // Parse out the implicit body that should be colored.\n\n    const body = parser.parseExpression(true, breakOnTokenText);\n    return {\n      type: \"color\",\n      mode: parser.mode,\n      color,\n      body\n    };\n  },\n\n  htmlBuilder: color_htmlBuilder,\n  mathmlBuilder: color_mathmlBuilder\n});\n;// CONCATENATED MODULE: ./src/functions/cr.js\n// Row breaks within tabular environments, and line breaks at top level\n\n\n\n\n // \\DeclareRobustCommand\\\\{...\\@xnewline}\n\ndefineFunction({\n  type: \"cr\",\n  names: [\"\\\\\\\\\"],\n  props: {\n    numArgs: 0,\n    numOptionalArgs: 0,\n    allowedInText: true\n  },\n\n  handler(_ref, args, optArgs) {\n    let {\n      parser\n    } = _ref;\n    const size = parser.gullet.future().text === \"[\" ? parser.parseSizeGroup(true) : null;\n    const newLine = !parser.settings.displayMode || !parser.settings.useStrictBehavior(\"newLineInDisplayMode\", \"In LaTeX, \\\\\\\\ or \\\\newline \" + \"does nothing in display mode\");\n    return {\n      type: \"cr\",\n      mode: parser.mode,\n      newLine,\n      size: size && assertNodeType(size, \"size\").value\n    };\n  },\n\n  // The following builders are called only at the top level,\n  // not within tabular/array environments.\n  htmlBuilder(group, options) {\n    const span = buildCommon.makeSpan([\"mspace\"], [], options);\n\n    if (group.newLine) {\n      span.classes.push(\"newline\");\n\n      if (group.size) {\n        span.style.marginTop = makeEm(calculateSize(group.size, options));\n      }\n    }\n\n    return span;\n  },\n\n  mathmlBuilder(group, options) {\n    const node = new mathMLTree.MathNode(\"mspace\");\n\n    if (group.newLine) {\n      node.setAttribute(\"linebreak\", \"newline\");\n\n      if (group.size) {\n        node.setAttribute(\"height\", makeEm(calculateSize(group.size, options)));\n      }\n    }\n\n    return node;\n  }\n\n});\n;// CONCATENATED MODULE: ./src/functions/def.js\n\n\n\nconst globalMap = {\n  \"\\\\global\": \"\\\\global\",\n  \"\\\\long\": \"\\\\\\\\globallong\",\n  \"\\\\\\\\globallong\": \"\\\\\\\\globallong\",\n  \"\\\\def\": \"\\\\gdef\",\n  \"\\\\gdef\": \"\\\\gdef\",\n  \"\\\\edef\": \"\\\\xdef\",\n  \"\\\\xdef\": \"\\\\xdef\",\n  \"\\\\let\": \"\\\\\\\\globallet\",\n  \"\\\\futurelet\": \"\\\\\\\\globalfuture\"\n};\n\nconst checkControlSequence = tok => {\n  const name = tok.text;\n\n  if (/^(?:[\\\\{}$&#^_]|EOF)$/.test(name)) {\n    throw new src_ParseError(\"Expected a control sequence\", tok);\n  }\n\n  return name;\n};\n\nconst getRHS = parser => {\n  let tok = parser.gullet.popToken();\n\n  if (tok.text === \"=\") {\n    // consume optional equals\n    tok = parser.gullet.popToken();\n\n    if (tok.text === \" \") {\n      // consume one optional space\n      tok = parser.gullet.popToken();\n    }\n  }\n\n  return tok;\n};\n\nconst letCommand = (parser, name, tok, global) => {\n  let macro = parser.gullet.macros.get(tok.text);\n\n  if (macro == null) {\n    // don't expand it later even if a macro with the same name is defined\n    // e.g., \\let\\foo=\\frac \\def\\frac{\\relax} \\frac12\n    tok.noexpand = true;\n    macro = {\n      tokens: [tok],\n      numArgs: 0,\n      // reproduce the same behavior in expansion\n      unexpandable: !parser.gullet.isExpandable(tok.text)\n    };\n  }\n\n  parser.gullet.macros.set(name, macro, global);\n}; // <assignment> -> <non-macro assignment>|<macro assignment>\n// <non-macro assignment> -> <simple assignment>|\\global<non-macro assignment>\n// <macro assignment> -> <definition>|<prefix><macro assignment>\n// <prefix> -> \\global|\\long|\\outer\n\n\ndefineFunction({\n  type: \"internal\",\n  names: [\"\\\\global\", \"\\\\long\", \"\\\\\\\\globallong\" // cant be entered directly\n  ],\n  props: {\n    numArgs: 0,\n    allowedInText: true\n  },\n\n  handler(_ref) {\n    let {\n      parser,\n      funcName\n    } = _ref;\n    parser.consumeSpaces();\n    const token = parser.fetch();\n\n    if (globalMap[token.text]) {\n      // KaTeX doesn't have \\par, so ignore \\long\n      if (funcName === \"\\\\global\" || funcName === \"\\\\\\\\globallong\") {\n        token.text = globalMap[token.text];\n      }\n\n      return assertNodeType(parser.parseFunction(), \"internal\");\n    }\n\n    throw new src_ParseError(\"Invalid token after macro prefix\", token);\n  }\n\n}); // Basic support for macro definitions: \\def, \\gdef, \\edef, \\xdef\n// <definition> -> <def><control sequence><definition text>\n// <def> -> \\def|\\gdef|\\edef|\\xdef\n// <definition text> -> <parameter text><left brace><balanced text><right brace>\n\ndefineFunction({\n  type: \"internal\",\n  names: [\"\\\\def\", \"\\\\gdef\", \"\\\\edef\", \"\\\\xdef\"],\n  props: {\n    numArgs: 0,\n    allowedInText: true,\n    primitive: true\n  },\n\n  handler(_ref2) {\n    let {\n      parser,\n      funcName\n    } = _ref2;\n    let tok = parser.gullet.popToken();\n    const name = tok.text;\n\n    if (/^(?:[\\\\{}$&#^_]|EOF)$/.test(name)) {\n      throw new src_ParseError(\"Expected a control sequence\", tok);\n    }\n\n    let numArgs = 0;\n    let insert;\n    const delimiters = [[]]; // <parameter text> contains no braces\n\n    while (parser.gullet.future().text !== \"{\") {\n      tok = parser.gullet.popToken();\n\n      if (tok.text === \"#\") {\n        // If the very last character of the <parameter text> is #, so that\n        // this # is immediately followed by {, TeX will behave as if the {\n        // had been inserted at the right end of both the parameter text\n        // and the replacement text.\n        if (parser.gullet.future().text === \"{\") {\n          insert = parser.gullet.future();\n          delimiters[numArgs].push(\"{\");\n          break;\n        } // A parameter, the first appearance of # must be followed by 1,\n        // the next by 2, and so on; up to nine #s are allowed\n\n\n        tok = parser.gullet.popToken();\n\n        if (!/^[1-9]$/.test(tok.text)) {\n          throw new src_ParseError(\"Invalid argument number \\\"\" + tok.text + \"\\\"\");\n        }\n\n        if (parseInt(tok.text) !== numArgs + 1) {\n          throw new src_ParseError(\"Argument number \\\"\" + tok.text + \"\\\" out of order\");\n        }\n\n        numArgs++;\n        delimiters.push([]);\n      } else if (tok.text === \"EOF\") {\n        throw new src_ParseError(\"Expected a macro definition\");\n      } else {\n        delimiters[numArgs].push(tok.text);\n      }\n    } // replacement text, enclosed in '{' and '}' and properly nested\n\n\n    let {\n      tokens\n    } = parser.gullet.consumeArg();\n\n    if (insert) {\n      tokens.unshift(insert);\n    }\n\n    if (funcName === \"\\\\edef\" || funcName === \"\\\\xdef\") {\n      tokens = parser.gullet.expandTokens(tokens);\n      tokens.reverse(); // to fit in with stack order\n    } // Final arg is the expansion of the macro\n\n\n    parser.gullet.macros.set(name, {\n      tokens,\n      numArgs,\n      delimiters\n    }, funcName === globalMap[funcName]);\n    return {\n      type: \"internal\",\n      mode: parser.mode\n    };\n  }\n\n}); // <simple assignment> -> <let assignment>\n// <let assignment> -> \\futurelet<control sequence><token><token>\n//     | \\let<control sequence><equals><one optional space><token>\n// <equals> -> <optional spaces>|<optional spaces>=\n\ndefineFunction({\n  type: \"internal\",\n  names: [\"\\\\let\", \"\\\\\\\\globallet\" // cant be entered directly\n  ],\n  props: {\n    numArgs: 0,\n    allowedInText: true,\n    primitive: true\n  },\n\n  handler(_ref3) {\n    let {\n      parser,\n      funcName\n    } = _ref3;\n    const name = checkControlSequence(parser.gullet.popToken());\n    parser.gullet.consumeSpaces();\n    const tok = getRHS(parser);\n    letCommand(parser, name, tok, funcName === \"\\\\\\\\globallet\");\n    return {\n      type: \"internal\",\n      mode: parser.mode\n    };\n  }\n\n}); // ref: https://www.tug.org/TUGboat/tb09-3/tb22bechtolsheim.pdf\n\ndefineFunction({\n  type: \"internal\",\n  names: [\"\\\\futurelet\", \"\\\\\\\\globalfuture\" // cant be entered directly\n  ],\n  props: {\n    numArgs: 0,\n    allowedInText: true,\n    primitive: true\n  },\n\n  handler(_ref4) {\n    let {\n      parser,\n      funcName\n    } = _ref4;\n    const name = checkControlSequence(parser.gullet.popToken());\n    const middle = parser.gullet.popToken();\n    const tok = parser.gullet.popToken();\n    letCommand(parser, name, tok, funcName === \"\\\\\\\\globalfuture\");\n    parser.gullet.pushToken(tok);\n    parser.gullet.pushToken(middle);\n    return {\n      type: \"internal\",\n      mode: parser.mode\n    };\n  }\n\n});\n;// CONCATENATED MODULE: ./src/delimiter.js\n/**\n * This file deals with creating delimiters of various sizes. The TeXbook\n * discusses these routines on page 441-442, in the \"Another subroutine sets box\n * x to a specified variable delimiter\" paragraph.\n *\n * There are three main routines here. `makeSmallDelim` makes a delimiter in the\n * normal font, but in either text, script, or scriptscript style.\n * `makeLargeDelim` makes a delimiter in textstyle, but in one of the Size1,\n * Size2, Size3, or Size4 fonts. `makeStackedDelim` makes a delimiter out of\n * smaller pieces that are stacked on top of one another.\n *\n * The functions take a parameter `center`, which determines if the delimiter\n * should be centered around the axis.\n *\n * Then, there are three exposed functions. `sizedDelim` makes a delimiter in\n * one of the given sizes. This is used for things like `\\bigl`.\n * `customSizedDelim` makes a delimiter with a given total height+depth. It is\n * called in places like `\\sqrt`. `leftRightDelim` makes an appropriate\n * delimiter which surrounds an expression of a given height an depth. It is\n * used in `\\left` and `\\right`.\n */\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Get the metrics for a given symbol and font, after transformation (i.e.\n * after following replacement from symbols.js)\n */\nconst getMetrics = function (symbol, font, mode) {\n  const replace = src_symbols.math[symbol] && src_symbols.math[symbol].replace;\n  const metrics = getCharacterMetrics(replace || symbol, font, mode);\n\n  if (!metrics) {\n    throw new Error(\"Unsupported symbol \" + symbol + \" and font size \" + font + \".\");\n  }\n\n  return metrics;\n};\n/**\n * Puts a delimiter span in a given style, and adds appropriate height, depth,\n * and maxFontSizes.\n */\n\n\nconst styleWrap = function (delim, toStyle, options, classes) {\n  const newOptions = options.havingBaseStyle(toStyle);\n  const span = buildCommon.makeSpan(classes.concat(newOptions.sizingClasses(options)), [delim], options);\n  const delimSizeMultiplier = newOptions.sizeMultiplier / options.sizeMultiplier;\n  span.height *= delimSizeMultiplier;\n  span.depth *= delimSizeMultiplier;\n  span.maxFontSize = newOptions.sizeMultiplier;\n  return span;\n};\n\nconst centerSpan = function (span, options, style) {\n  const newOptions = options.havingBaseStyle(style);\n  const shift = (1 - options.sizeMultiplier / newOptions.sizeMultiplier) * options.fontMetrics().axisHeight;\n  span.classes.push(\"delimcenter\");\n  span.style.top = makeEm(shift);\n  span.height -= shift;\n  span.depth += shift;\n};\n/**\n * Makes a small delimiter. This is a delimiter that comes in the Main-Regular\n * font, but is restyled to either be in textstyle, scriptstyle, or\n * scriptscriptstyle.\n */\n\n\nconst makeSmallDelim = function (delim, style, center, options, mode, classes) {\n  const text = buildCommon.makeSymbol(delim, \"Main-Regular\", mode, options);\n  const span = styleWrap(text, style, options, classes);\n\n  if (center) {\n    centerSpan(span, options, style);\n  }\n\n  return span;\n};\n/**\n * Builds a symbol in the given font size (note size is an integer)\n */\n\n\nconst mathrmSize = function (value, size, mode, options) {\n  return buildCommon.makeSymbol(value, \"Size\" + size + \"-Regular\", mode, options);\n};\n/**\n * Makes a large delimiter. This is a delimiter that comes in the Size1, Size2,\n * Size3, or Size4 fonts. It is always rendered in textstyle.\n */\n\n\nconst makeLargeDelim = function (delim, size, center, options, mode, classes) {\n  const inner = mathrmSize(delim, size, mode, options);\n  const span = styleWrap(buildCommon.makeSpan([\"delimsizing\", \"size\" + size], [inner], options), src_Style.TEXT, options, classes);\n\n  if (center) {\n    centerSpan(span, options, src_Style.TEXT);\n  }\n\n  return span;\n};\n/**\n * Make a span from a font glyph with the given offset and in the given font.\n * This is used in makeStackedDelim to make the stacking pieces for the delimiter.\n */\n\n\nconst makeGlyphSpan = function (symbol, font, mode) {\n  let sizeClass; // Apply the correct CSS class to choose the right font.\n\n  if (font === \"Size1-Regular\") {\n    sizeClass = \"delim-size1\";\n  } else\n    /* if (font === \"Size4-Regular\") */\n    {\n      sizeClass = \"delim-size4\";\n    }\n\n  const corner = buildCommon.makeSpan([\"delimsizinginner\", sizeClass], [buildCommon.makeSpan([], [buildCommon.makeSymbol(symbol, font, mode)])]); // Since this will be passed into `makeVList` in the end, wrap the element\n  // in the appropriate tag that VList uses.\n\n  return {\n    type: \"elem\",\n    elem: corner\n  };\n};\n\nconst makeInner = function (ch, height, options) {\n  // Create a span with inline SVG for the inner part of a tall stacked delimiter.\n  const width = fontMetricsData[\"Size4-Regular\"][ch.charCodeAt(0)] ? fontMetricsData[\"Size4-Regular\"][ch.charCodeAt(0)][4] : fontMetricsData[\"Size1-Regular\"][ch.charCodeAt(0)][4];\n  const path = new PathNode(\"inner\", innerPath(ch, Math.round(1000 * height)));\n  const svgNode = new SvgNode([path], {\n    \"width\": makeEm(width),\n    \"height\": makeEm(height),\n    // Override CSS rule `.katex svg { width: 100% }`\n    \"style\": \"width:\" + makeEm(width),\n    \"viewBox\": \"0 0 \" + 1000 * width + \" \" + Math.round(1000 * height),\n    \"preserveAspectRatio\": \"xMinYMin\"\n  });\n  const span = buildCommon.makeSvgSpan([], [svgNode], options);\n  span.height = height;\n  span.style.height = makeEm(height);\n  span.style.width = makeEm(width);\n  return {\n    type: \"elem\",\n    elem: span\n  };\n}; // Helpers for makeStackedDelim\n\n\nconst lapInEms = 0.008;\nconst lap = {\n  type: \"kern\",\n  size: -1 * lapInEms\n};\nconst verts = [\"|\", \"\\\\lvert\", \"\\\\rvert\", \"\\\\vert\"];\nconst doubleVerts = [\"\\\\|\", \"\\\\lVert\", \"\\\\rVert\", \"\\\\Vert\"];\n/**\n * Make a stacked delimiter out of a given delimiter, with the total height at\n * least `heightTotal`. This routine is mentioned on page 442 of the TeXbook.\n */\n\nconst makeStackedDelim = function (delim, heightTotal, center, options, mode, classes) {\n  // There are four parts, the top, an optional middle, a repeated part, and a\n  // bottom.\n  let top;\n  let middle;\n  let repeat;\n  let bottom;\n  let svgLabel = \"\";\n  let viewBoxWidth = 0;\n  top = repeat = bottom = delim;\n  middle = null; // Also keep track of what font the delimiters are in\n\n  let font = \"Size1-Regular\"; // We set the parts and font based on the symbol. Note that we use\n  // '\\u23d0' instead of '|' and '\\u2016' instead of '\\\\|' for the\n  // repeats of the arrows\n\n  if (delim === \"\\\\uparrow\") {\n    repeat = bottom = \"\\u23d0\";\n  } else if (delim === \"\\\\Uparrow\") {\n    repeat = bottom = \"\\u2016\";\n  } else if (delim === \"\\\\downarrow\") {\n    top = repeat = \"\\u23d0\";\n  } else if (delim === \"\\\\Downarrow\") {\n    top = repeat = \"\\u2016\";\n  } else if (delim === \"\\\\updownarrow\") {\n    top = \"\\\\uparrow\";\n    repeat = \"\\u23d0\";\n    bottom = \"\\\\downarrow\";\n  } else if (delim === \"\\\\Updownarrow\") {\n    top = \"\\\\Uparrow\";\n    repeat = \"\\u2016\";\n    bottom = \"\\\\Downarrow\";\n  } else if (utils.contains(verts, delim)) {\n    repeat = \"\\u2223\";\n    svgLabel = \"vert\";\n    viewBoxWidth = 333;\n  } else if (utils.contains(doubleVerts, delim)) {\n    repeat = \"\\u2225\";\n    svgLabel = \"doublevert\";\n    viewBoxWidth = 556;\n  } else if (delim === \"[\" || delim === \"\\\\lbrack\") {\n    top = \"\\u23a1\";\n    repeat = \"\\u23a2\";\n    bottom = \"\\u23a3\";\n    font = \"Size4-Regular\";\n    svgLabel = \"lbrack\";\n    viewBoxWidth = 667;\n  } else if (delim === \"]\" || delim === \"\\\\rbrack\") {\n    top = \"\\u23a4\";\n    repeat = \"\\u23a5\";\n    bottom = \"\\u23a6\";\n    font = \"Size4-Regular\";\n    svgLabel = \"rbrack\";\n    viewBoxWidth = 667;\n  } else if (delim === \"\\\\lfloor\" || delim === \"\\u230a\") {\n    repeat = top = \"\\u23a2\";\n    bottom = \"\\u23a3\";\n    font = \"Size4-Regular\";\n    svgLabel = \"lfloor\";\n    viewBoxWidth = 667;\n  } else if (delim === \"\\\\lceil\" || delim === \"\\u2308\") {\n    top = \"\\u23a1\";\n    repeat = bottom = \"\\u23a2\";\n    font = \"Size4-Regular\";\n    svgLabel = \"lceil\";\n    viewBoxWidth = 667;\n  } else if (delim === \"\\\\rfloor\" || delim === \"\\u230b\") {\n    repeat = top = \"\\u23a5\";\n    bottom = \"\\u23a6\";\n    font = \"Size4-Regular\";\n    svgLabel = \"rfloor\";\n    viewBoxWidth = 667;\n  } else if (delim === \"\\\\rceil\" || delim === \"\\u2309\") {\n    top = \"\\u23a4\";\n    repeat = bottom = \"\\u23a5\";\n    font = \"Size4-Regular\";\n    svgLabel = \"rceil\";\n    viewBoxWidth = 667;\n  } else if (delim === \"(\" || delim === \"\\\\lparen\") {\n    top = \"\\u239b\";\n    repeat = \"\\u239c\";\n    bottom = \"\\u239d\";\n    font = \"Size4-Regular\";\n    svgLabel = \"lparen\";\n    viewBoxWidth = 875;\n  } else if (delim === \")\" || delim === \"\\\\rparen\") {\n    top = \"\\u239e\";\n    repeat = \"\\u239f\";\n    bottom = \"\\u23a0\";\n    font = \"Size4-Regular\";\n    svgLabel = \"rparen\";\n    viewBoxWidth = 875;\n  } else if (delim === \"\\\\{\" || delim === \"\\\\lbrace\") {\n    top = \"\\u23a7\";\n    middle = \"\\u23a8\";\n    bottom = \"\\u23a9\";\n    repeat = \"\\u23aa\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\}\" || delim === \"\\\\rbrace\") {\n    top = \"\\u23ab\";\n    middle = \"\\u23ac\";\n    bottom = \"\\u23ad\";\n    repeat = \"\\u23aa\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\lgroup\" || delim === \"\\u27ee\") {\n    top = \"\\u23a7\";\n    bottom = \"\\u23a9\";\n    repeat = \"\\u23aa\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\rgroup\" || delim === \"\\u27ef\") {\n    top = \"\\u23ab\";\n    bottom = \"\\u23ad\";\n    repeat = \"\\u23aa\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\lmoustache\" || delim === \"\\u23b0\") {\n    top = \"\\u23a7\";\n    bottom = \"\\u23ad\";\n    repeat = \"\\u23aa\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\rmoustache\" || delim === \"\\u23b1\") {\n    top = \"\\u23ab\";\n    bottom = \"\\u23a9\";\n    repeat = \"\\u23aa\";\n    font = \"Size4-Regular\";\n  } // Get the metrics of the four sections\n\n\n  const topMetrics = getMetrics(top, font, mode);\n  const topHeightTotal = topMetrics.height + topMetrics.depth;\n  const repeatMetrics = getMetrics(repeat, font, mode);\n  const repeatHeightTotal = repeatMetrics.height + repeatMetrics.depth;\n  const bottomMetrics = getMetrics(bottom, font, mode);\n  const bottomHeightTotal = bottomMetrics.height + bottomMetrics.depth;\n  let middleHeightTotal = 0;\n  let middleFactor = 1;\n\n  if (middle !== null) {\n    const middleMetrics = getMetrics(middle, font, mode);\n    middleHeightTotal = middleMetrics.height + middleMetrics.depth;\n    middleFactor = 2; // repeat symmetrically above and below middle\n  } // Calculate the minimal height that the delimiter can have.\n  // It is at least the size of the top, bottom, and optional middle combined.\n\n\n  const minHeight = topHeightTotal + bottomHeightTotal + middleHeightTotal; // Compute the number of copies of the repeat symbol we will need\n\n  const repeatCount = Math.max(0, Math.ceil((heightTotal - minHeight) / (middleFactor * repeatHeightTotal))); // Compute the total height of the delimiter including all the symbols\n\n  const realHeightTotal = minHeight + repeatCount * middleFactor * repeatHeightTotal; // The center of the delimiter is placed at the center of the axis. Note\n  // that in this context, \"center\" means that the delimiter should be\n  // centered around the axis in the current style, while normally it is\n  // centered around the axis in textstyle.\n\n  let axisHeight = options.fontMetrics().axisHeight;\n\n  if (center) {\n    axisHeight *= options.sizeMultiplier;\n  } // Calculate the depth\n\n\n  const depth = realHeightTotal / 2 - axisHeight; // Now, we start building the pieces that will go into the vlist\n  // Keep a list of the pieces of the stacked delimiter\n\n  const stack = [];\n\n  if (svgLabel.length > 0) {\n    // Instead of stacking glyphs, create a single SVG.\n    // This evades browser problems with imprecise positioning of spans.\n    const midHeight = realHeightTotal - topHeightTotal - bottomHeightTotal;\n    const viewBoxHeight = Math.round(realHeightTotal * 1000);\n    const pathStr = tallDelim(svgLabel, Math.round(midHeight * 1000));\n    const path = new PathNode(svgLabel, pathStr);\n    const width = (viewBoxWidth / 1000).toFixed(3) + \"em\";\n    const height = (viewBoxHeight / 1000).toFixed(3) + \"em\";\n    const svg = new SvgNode([path], {\n      \"width\": width,\n      \"height\": height,\n      \"viewBox\": \"0 0 \" + viewBoxWidth + \" \" + viewBoxHeight\n    });\n    const wrapper = buildCommon.makeSvgSpan([], [svg], options);\n    wrapper.height = viewBoxHeight / 1000;\n    wrapper.style.width = width;\n    wrapper.style.height = height;\n    stack.push({\n      type: \"elem\",\n      elem: wrapper\n    });\n  } else {\n    // Stack glyphs\n    // Start by adding the bottom symbol\n    stack.push(makeGlyphSpan(bottom, font, mode));\n    stack.push(lap); // overlap\n\n    if (middle === null) {\n      // The middle section will be an SVG. Make it an extra 0.016em tall.\n      // We'll overlap by 0.008em at top and bottom.\n      const innerHeight = realHeightTotal - topHeightTotal - bottomHeightTotal + 2 * lapInEms;\n      stack.push(makeInner(repeat, innerHeight, options));\n    } else {\n      // When there is a middle bit, we need the middle part and two repeated\n      // sections\n      const innerHeight = (realHeightTotal - topHeightTotal - bottomHeightTotal - middleHeightTotal) / 2 + 2 * lapInEms;\n      stack.push(makeInner(repeat, innerHeight, options)); // Now insert the middle of the brace.\n\n      stack.push(lap);\n      stack.push(makeGlyphSpan(middle, font, mode));\n      stack.push(lap);\n      stack.push(makeInner(repeat, innerHeight, options));\n    } // Add the top symbol\n\n\n    stack.push(lap);\n    stack.push(makeGlyphSpan(top, font, mode));\n  } // Finally, build the vlist\n\n\n  const newOptions = options.havingBaseStyle(src_Style.TEXT);\n  const inner = buildCommon.makeVList({\n    positionType: \"bottom\",\n    positionData: depth,\n    children: stack\n  }, newOptions);\n  return styleWrap(buildCommon.makeSpan([\"delimsizing\", \"mult\"], [inner], newOptions), src_Style.TEXT, options, classes);\n}; // All surds have 0.08em padding above the vinculum inside the SVG.\n// That keeps browser span height rounding error from pinching the line.\n\n\nconst vbPad = 80; // padding above the surd, measured inside the viewBox.\n\nconst emPad = 0.08; // padding, in ems, measured in the document.\n\nconst sqrtSvg = function (sqrtName, height, viewBoxHeight, extraVinculum, options) {\n  const path = sqrtPath(sqrtName, extraVinculum, viewBoxHeight);\n  const pathNode = new PathNode(sqrtName, path);\n  const svg = new SvgNode([pathNode], {\n    // Note: 1000:1 ratio of viewBox to document em width.\n    \"width\": \"400em\",\n    \"height\": makeEm(height),\n    \"viewBox\": \"0 0 400000 \" + viewBoxHeight,\n    \"preserveAspectRatio\": \"xMinYMin slice\"\n  });\n  return buildCommon.makeSvgSpan([\"hide-tail\"], [svg], options);\n};\n/**\n * Make a sqrt image of the given height,\n */\n\n\nconst makeSqrtImage = function (height, options) {\n  // Define a newOptions that removes the effect of size changes such as \\Huge.\n  // We don't pick different a height surd for \\Huge. For it, we scale up.\n  const newOptions = options.havingBaseSizing(); // Pick the desired surd glyph from a sequence of surds.\n\n  const delim = traverseSequence(\"\\\\surd\", height * newOptions.sizeMultiplier, stackLargeDelimiterSequence, newOptions);\n  let sizeMultiplier = newOptions.sizeMultiplier; // default\n  // The standard sqrt SVGs each have a 0.04em thick vinculum.\n  // If Settings.minRuleThickness is larger than that, we add extraVinculum.\n\n  const extraVinculum = Math.max(0, options.minRuleThickness - options.fontMetrics().sqrtRuleThickness); // Create a span containing an SVG image of a sqrt symbol.\n\n  let span;\n  let spanHeight = 0;\n  let texHeight = 0;\n  let viewBoxHeight = 0;\n  let advanceWidth; // We create viewBoxes with 80 units of \"padding\" above each surd.\n  // Then browser rounding error on the parent span height will not\n  // encroach on the ink of the vinculum. But that padding is not\n  // included in the TeX-like `height` used for calculation of\n  // vertical alignment. So texHeight = span.height < span.style.height.\n\n  if (delim.type === \"small\") {\n    // Get an SVG that is derived from glyph U+221A in font KaTeX-Main.\n    // 1000 unit normal glyph height.\n    viewBoxHeight = 1000 + 1000 * extraVinculum + vbPad;\n\n    if (height < 1.0) {\n      sizeMultiplier = 1.0; // mimic a \\textfont radical\n    } else if (height < 1.4) {\n      sizeMultiplier = 0.7; // mimic a \\scriptfont radical\n    }\n\n    spanHeight = (1.0 + extraVinculum + emPad) / sizeMultiplier;\n    texHeight = (1.00 + extraVinculum) / sizeMultiplier;\n    span = sqrtSvg(\"sqrtMain\", spanHeight, viewBoxHeight, extraVinculum, options);\n    span.style.minWidth = \"0.853em\";\n    advanceWidth = 0.833 / sizeMultiplier; // from the font.\n  } else if (delim.type === \"large\") {\n    // These SVGs come from fonts: KaTeX_Size1, _Size2, etc.\n    viewBoxHeight = (1000 + vbPad) * sizeToMaxHeight[delim.size];\n    texHeight = (sizeToMaxHeight[delim.size] + extraVinculum) / sizeMultiplier;\n    spanHeight = (sizeToMaxHeight[delim.size] + extraVinculum + emPad) / sizeMultiplier;\n    span = sqrtSvg(\"sqrtSize\" + delim.size, spanHeight, viewBoxHeight, extraVinculum, options);\n    span.style.minWidth = \"1.02em\";\n    advanceWidth = 1.0 / sizeMultiplier; // 1.0 from the font.\n  } else {\n    // Tall sqrt. In TeX, this would be stacked using multiple glyphs.\n    // We'll use a single SVG to accomplish the same thing.\n    spanHeight = height + extraVinculum + emPad;\n    texHeight = height + extraVinculum;\n    viewBoxHeight = Math.floor(1000 * height + extraVinculum) + vbPad;\n    span = sqrtSvg(\"sqrtTall\", spanHeight, viewBoxHeight, extraVinculum, options);\n    span.style.minWidth = \"0.742em\";\n    advanceWidth = 1.056;\n  }\n\n  span.height = texHeight;\n  span.style.height = makeEm(spanHeight);\n  return {\n    span,\n    advanceWidth,\n    // Calculate the actual line width.\n    // This actually should depend on the chosen font -- e.g. \\boldmath\n    // should use the thicker surd symbols from e.g. KaTeX_Main-Bold, and\n    // have thicker rules.\n    ruleWidth: (options.fontMetrics().sqrtRuleThickness + extraVinculum) * sizeMultiplier\n  };\n}; // There are three kinds of delimiters, delimiters that stack when they become\n// too large\n\n\nconst stackLargeDelimiters = [\"(\", \"\\\\lparen\", \")\", \"\\\\rparen\", \"[\", \"\\\\lbrack\", \"]\", \"\\\\rbrack\", \"\\\\{\", \"\\\\lbrace\", \"\\\\}\", \"\\\\rbrace\", \"\\\\lfloor\", \"\\\\rfloor\", \"\\u230a\", \"\\u230b\", \"\\\\lceil\", \"\\\\rceil\", \"\\u2308\", \"\\u2309\", \"\\\\surd\"]; // delimiters that always stack\n\nconst stackAlwaysDelimiters = [\"\\\\uparrow\", \"\\\\downarrow\", \"\\\\updownarrow\", \"\\\\Uparrow\", \"\\\\Downarrow\", \"\\\\Updownarrow\", \"|\", \"\\\\|\", \"\\\\vert\", \"\\\\Vert\", \"\\\\lvert\", \"\\\\rvert\", \"\\\\lVert\", \"\\\\rVert\", \"\\\\lgroup\", \"\\\\rgroup\", \"\\u27ee\", \"\\u27ef\", \"\\\\lmoustache\", \"\\\\rmoustache\", \"\\u23b0\", \"\\u23b1\"]; // and delimiters that never stack\n\nconst stackNeverDelimiters = [\"<\", \">\", \"\\\\langle\", \"\\\\rangle\", \"/\", \"\\\\backslash\", \"\\\\lt\", \"\\\\gt\"]; // Metrics of the different sizes. Found by looking at TeX's output of\n// $\\bigl| // \\Bigl| \\biggl| \\Biggl| \\showlists$\n// Used to create stacked delimiters of appropriate sizes in makeSizedDelim.\n\nconst sizeToMaxHeight = [0, 1.2, 1.8, 2.4, 3.0];\n/**\n * Used to create a delimiter of a specific size, where `size` is 1, 2, 3, or 4.\n */\n\nconst makeSizedDelim = function (delim, size, options, mode, classes) {\n  // < and > turn into \\langle and \\rangle in delimiters\n  if (delim === \"<\" || delim === \"\\\\lt\" || delim === \"\\u27e8\") {\n    delim = \"\\\\langle\";\n  } else if (delim === \">\" || delim === \"\\\\gt\" || delim === \"\\u27e9\") {\n    delim = \"\\\\rangle\";\n  } // Sized delimiters are never centered.\n\n\n  if (utils.contains(stackLargeDelimiters, delim) || utils.contains(stackNeverDelimiters, delim)) {\n    return makeLargeDelim(delim, size, false, options, mode, classes);\n  } else if (utils.contains(stackAlwaysDelimiters, delim)) {\n    return makeStackedDelim(delim, sizeToMaxHeight[size], false, options, mode, classes);\n  } else {\n    throw new src_ParseError(\"Illegal delimiter: '\" + delim + \"'\");\n  }\n};\n/**\n * There are three different sequences of delimiter sizes that the delimiters\n * follow depending on the kind of delimiter. This is used when creating custom\n * sized delimiters to decide whether to create a small, large, or stacked\n * delimiter.\n *\n * In real TeX, these sequences aren't explicitly defined, but are instead\n * defined inside the font metrics. Since there are only three sequences that\n * are possible for the delimiters that TeX defines, it is easier to just encode\n * them explicitly here.\n */\n\n\n// Delimiters that never stack try small delimiters and large delimiters only\nconst stackNeverDelimiterSequence = [{\n  type: \"small\",\n  style: src_Style.SCRIPTSCRIPT\n}, {\n  type: \"small\",\n  style: src_Style.SCRIPT\n}, {\n  type: \"small\",\n  style: src_Style.TEXT\n}, {\n  type: \"large\",\n  size: 1\n}, {\n  type: \"large\",\n  size: 2\n}, {\n  type: \"large\",\n  size: 3\n}, {\n  type: \"large\",\n  size: 4\n}]; // Delimiters that always stack try the small delimiters first, then stack\n\nconst stackAlwaysDelimiterSequence = [{\n  type: \"small\",\n  style: src_Style.SCRIPTSCRIPT\n}, {\n  type: \"small\",\n  style: src_Style.SCRIPT\n}, {\n  type: \"small\",\n  style: src_Style.TEXT\n}, {\n  type: \"stack\"\n}]; // Delimiters that stack when large try the small and then large delimiters, and\n// stack afterwards\n\nconst stackLargeDelimiterSequence = [{\n  type: \"small\",\n  style: src_Style.SCRIPTSCRIPT\n}, {\n  type: \"small\",\n  style: src_Style.SCRIPT\n}, {\n  type: \"small\",\n  style: src_Style.TEXT\n}, {\n  type: \"large\",\n  size: 1\n}, {\n  type: \"large\",\n  size: 2\n}, {\n  type: \"large\",\n  size: 3\n}, {\n  type: \"large\",\n  size: 4\n}, {\n  type: \"stack\"\n}];\n/**\n * Get the font used in a delimiter based on what kind of delimiter it is.\n * TODO(#963) Use more specific font family return type once that is introduced.\n */\n\nconst delimTypeToFont = function (type) {\n  if (type.type === \"small\") {\n    return \"Main-Regular\";\n  } else if (type.type === \"large\") {\n    return \"Size\" + type.size + \"-Regular\";\n  } else if (type.type === \"stack\") {\n    return \"Size4-Regular\";\n  } else {\n    throw new Error(\"Add support for delim type '\" + type.type + \"' here.\");\n  }\n};\n/**\n * Traverse a sequence of types of delimiters to decide what kind of delimiter\n * should be used to create a delimiter of the given height+depth.\n */\n\n\nconst traverseSequence = function (delim, height, sequence, options) {\n  // Here, we choose the index we should start at in the sequences. In smaller\n  // sizes (which correspond to larger numbers in style.size) we start earlier\n  // in the sequence. Thus, scriptscript starts at index 3-3=0, script starts\n  // at index 3-2=1, text starts at 3-1=2, and display starts at min(2,3-0)=2\n  const start = Math.min(2, 3 - options.style.size);\n\n  for (let i = start; i < sequence.length; i++) {\n    if (sequence[i].type === \"stack\") {\n      // This is always the last delimiter, so we just break the loop now.\n      break;\n    }\n\n    const metrics = getMetrics(delim, delimTypeToFont(sequence[i]), \"math\");\n    let heightDepth = metrics.height + metrics.depth; // Small delimiters are scaled down versions of the same font, so we\n    // account for the style change size.\n\n    if (sequence[i].type === \"small\") {\n      const newOptions = options.havingBaseStyle(sequence[i].style);\n      heightDepth *= newOptions.sizeMultiplier;\n    } // Check if the delimiter at this size works for the given height.\n\n\n    if (heightDepth > height) {\n      return sequence[i];\n    }\n  } // If we reached the end of the sequence, return the last sequence element.\n\n\n  return sequence[sequence.length - 1];\n};\n/**\n * Make a delimiter of a given height+depth, with optional centering. Here, we\n * traverse the sequences, and create a delimiter that the sequence tells us to.\n */\n\n\nconst makeCustomSizedDelim = function (delim, height, center, options, mode, classes) {\n  if (delim === \"<\" || delim === \"\\\\lt\" || delim === \"\\u27e8\") {\n    delim = \"\\\\langle\";\n  } else if (delim === \">\" || delim === \"\\\\gt\" || delim === \"\\u27e9\") {\n    delim = \"\\\\rangle\";\n  } // Decide what sequence to use\n\n\n  let sequence;\n\n  if (utils.contains(stackNeverDelimiters, delim)) {\n    sequence = stackNeverDelimiterSequence;\n  } else if (utils.contains(stackLargeDelimiters, delim)) {\n    sequence = stackLargeDelimiterSequence;\n  } else {\n    sequence = stackAlwaysDelimiterSequence;\n  } // Look through the sequence\n\n\n  const delimType = traverseSequence(delim, height, sequence, options); // Get the delimiter from font glyphs.\n  // Depending on the sequence element we decided on, call the\n  // appropriate function.\n\n  if (delimType.type === \"small\") {\n    return makeSmallDelim(delim, delimType.style, center, options, mode, classes);\n  } else if (delimType.type === \"large\") {\n    return makeLargeDelim(delim, delimType.size, center, options, mode, classes);\n  } else\n    /* if (delimType.type === \"stack\") */\n    {\n      return makeStackedDelim(delim, height, center, options, mode, classes);\n    }\n};\n/**\n * Make a delimiter for use with `\\left` and `\\right`, given a height and depth\n * of an expression that the delimiters surround.\n */\n\n\nconst makeLeftRightDelim = function (delim, height, depth, options, mode, classes) {\n  // We always center \\left/\\right delimiters, so the axis is always shifted\n  const axisHeight = options.fontMetrics().axisHeight * options.sizeMultiplier; // Taken from TeX source, tex.web, function make_left_right\n\n  const delimiterFactor = 901;\n  const delimiterExtend = 5.0 / options.fontMetrics().ptPerEm;\n  const maxDistFromAxis = Math.max(height - axisHeight, depth + axisHeight);\n  const totalHeight = Math.max( // In real TeX, calculations are done using integral values which are\n  // 65536 per pt, or 655360 per em. So, the division here truncates in\n  // TeX but doesn't here, producing different results. If we wanted to\n  // exactly match TeX's calculation, we could do\n  //   Math.floor(655360 * maxDistFromAxis / 500) *\n  //    delimiterFactor / 655360\n  // (To see the difference, compare\n  //    x^{x^{\\left(\\rule{0.1em}{0.68em}\\right)}}\n  // in TeX and KaTeX)\n  maxDistFromAxis / 500 * delimiterFactor, 2 * maxDistFromAxis - delimiterExtend); // Finally, we defer to `makeCustomSizedDelim` with our calculated total\n  // height\n\n  return makeCustomSizedDelim(delim, totalHeight, true, options, mode, classes);\n};\n\n/* harmony default export */ var delimiter = ({\n  sqrtImage: makeSqrtImage,\n  sizedDelim: makeSizedDelim,\n  sizeToMaxHeight: sizeToMaxHeight,\n  customSizedDelim: makeCustomSizedDelim,\n  leftRightDelim: makeLeftRightDelim\n});\n;// CONCATENATED MODULE: ./src/functions/delimsizing.js\n\n\n\n\n\n\n\n\n\n\n// Extra data needed for the delimiter handler down below\nconst delimiterSizes = {\n  \"\\\\bigl\": {\n    mclass: \"mopen\",\n    size: 1\n  },\n  \"\\\\Bigl\": {\n    mclass: \"mopen\",\n    size: 2\n  },\n  \"\\\\biggl\": {\n    mclass: \"mopen\",\n    size: 3\n  },\n  \"\\\\Biggl\": {\n    mclass: \"mopen\",\n    size: 4\n  },\n  \"\\\\bigr\": {\n    mclass: \"mclose\",\n    size: 1\n  },\n  \"\\\\Bigr\": {\n    mclass: \"mclose\",\n    size: 2\n  },\n  \"\\\\biggr\": {\n    mclass: \"mclose\",\n    size: 3\n  },\n  \"\\\\Biggr\": {\n    mclass: \"mclose\",\n    size: 4\n  },\n  \"\\\\bigm\": {\n    mclass: \"mrel\",\n    size: 1\n  },\n  \"\\\\Bigm\": {\n    mclass: \"mrel\",\n    size: 2\n  },\n  \"\\\\biggm\": {\n    mclass: \"mrel\",\n    size: 3\n  },\n  \"\\\\Biggm\": {\n    mclass: \"mrel\",\n    size: 4\n  },\n  \"\\\\big\": {\n    mclass: \"mord\",\n    size: 1\n  },\n  \"\\\\Big\": {\n    mclass: \"mord\",\n    size: 2\n  },\n  \"\\\\bigg\": {\n    mclass: \"mord\",\n    size: 3\n  },\n  \"\\\\Bigg\": {\n    mclass: \"mord\",\n    size: 4\n  }\n};\nconst delimiters = [\"(\", \"\\\\lparen\", \")\", \"\\\\rparen\", \"[\", \"\\\\lbrack\", \"]\", \"\\\\rbrack\", \"\\\\{\", \"\\\\lbrace\", \"\\\\}\", \"\\\\rbrace\", \"\\\\lfloor\", \"\\\\rfloor\", \"\\u230a\", \"\\u230b\", \"\\\\lceil\", \"\\\\rceil\", \"\\u2308\", \"\\u2309\", \"<\", \">\", \"\\\\langle\", \"\\u27e8\", \"\\\\rangle\", \"\\u27e9\", \"\\\\lt\", \"\\\\gt\", \"\\\\lvert\", \"\\\\rvert\", \"\\\\lVert\", \"\\\\rVert\", \"\\\\lgroup\", \"\\\\rgroup\", \"\\u27ee\", \"\\u27ef\", \"\\\\lmoustache\", \"\\\\rmoustache\", \"\\u23b0\", \"\\u23b1\", \"/\", \"\\\\backslash\", \"|\", \"\\\\vert\", \"\\\\|\", \"\\\\Vert\", \"\\\\uparrow\", \"\\\\Uparrow\", \"\\\\downarrow\", \"\\\\Downarrow\", \"\\\\updownarrow\", \"\\\\Updownarrow\", \".\"];\n\n// Delimiter functions\nfunction checkDelimiter(delim, context) {\n  const symDelim = checkSymbolNodeType(delim);\n\n  if (symDelim && utils.contains(delimiters, symDelim.text)) {\n    return symDelim;\n  } else if (symDelim) {\n    throw new src_ParseError(\"Invalid delimiter '\" + symDelim.text + \"' after '\" + context.funcName + \"'\", delim);\n  } else {\n    throw new src_ParseError(\"Invalid delimiter type '\" + delim.type + \"'\", delim);\n  }\n}\n\ndefineFunction({\n  type: \"delimsizing\",\n  names: [\"\\\\bigl\", \"\\\\Bigl\", \"\\\\biggl\", \"\\\\Biggl\", \"\\\\bigr\", \"\\\\Bigr\", \"\\\\biggr\", \"\\\\Biggr\", \"\\\\bigm\", \"\\\\Bigm\", \"\\\\biggm\", \"\\\\Biggm\", \"\\\\big\", \"\\\\Big\", \"\\\\bigg\", \"\\\\Bigg\"],\n  props: {\n    numArgs: 1,\n    argTypes: [\"primitive\"]\n  },\n  handler: (context, args) => {\n    const delim = checkDelimiter(args[0], context);\n    return {\n      type: \"delimsizing\",\n      mode: context.parser.mode,\n      size: delimiterSizes[context.funcName].size,\n      mclass: delimiterSizes[context.funcName].mclass,\n      delim: delim.text\n    };\n  },\n  htmlBuilder: (group, options) => {\n    if (group.delim === \".\") {\n      // Empty delimiters still count as elements, even though they don't\n      // show anything.\n      return buildCommon.makeSpan([group.mclass]);\n    } // Use delimiter.sizedDelim to generate the delimiter.\n\n\n    return delimiter.sizedDelim(group.delim, group.size, options, group.mode, [group.mclass]);\n  },\n  mathmlBuilder: group => {\n    const children = [];\n\n    if (group.delim !== \".\") {\n      children.push(makeText(group.delim, group.mode));\n    }\n\n    const node = new mathMLTree.MathNode(\"mo\", children);\n\n    if (group.mclass === \"mopen\" || group.mclass === \"mclose\") {\n      // Only some of the delimsizing functions act as fences, and they\n      // return \"mopen\" or \"mclose\" mclass.\n      node.setAttribute(\"fence\", \"true\");\n    } else {\n      // Explicitly disable fencing if it's not a fence, to override the\n      // defaults.\n      node.setAttribute(\"fence\", \"false\");\n    }\n\n    node.setAttribute(\"stretchy\", \"true\");\n    const size = makeEm(delimiter.sizeToMaxHeight[group.size]);\n    node.setAttribute(\"minsize\", size);\n    node.setAttribute(\"maxsize\", size);\n    return node;\n  }\n});\n\nfunction assertParsed(group) {\n  if (!group.body) {\n    throw new Error(\"Bug: The leftright ParseNode wasn't fully parsed.\");\n  }\n}\n\ndefineFunction({\n  type: \"leftright-right\",\n  names: [\"\\\\right\"],\n  props: {\n    numArgs: 1,\n    primitive: true\n  },\n  handler: (context, args) => {\n    // \\left case below triggers parsing of \\right in\n    //   `const right = parser.parseFunction();`\n    // uses this return value.\n    const color = context.parser.gullet.macros.get(\"\\\\current@color\");\n\n    if (color && typeof color !== \"string\") {\n      throw new src_ParseError(\"\\\\current@color set to non-string in \\\\right\");\n    }\n\n    return {\n      type: \"leftright-right\",\n      mode: context.parser.mode,\n      delim: checkDelimiter(args[0], context).text,\n      color // undefined if not set via \\color\n\n    };\n  }\n});\ndefineFunction({\n  type: \"leftright\",\n  names: [\"\\\\left\"],\n  props: {\n    numArgs: 1,\n    primitive: true\n  },\n  handler: (context, args) => {\n    const delim = checkDelimiter(args[0], context);\n    const parser = context.parser; // Parse out the implicit body\n\n    ++parser.leftrightDepth; // parseExpression stops before '\\\\right'\n\n    const body = parser.parseExpression(false);\n    --parser.leftrightDepth; // Check the next token\n\n    parser.expect(\"\\\\right\", false);\n    const right = assertNodeType(parser.parseFunction(), \"leftright-right\");\n    return {\n      type: \"leftright\",\n      mode: parser.mode,\n      body,\n      left: delim.text,\n      right: right.delim,\n      rightColor: right.color\n    };\n  },\n  htmlBuilder: (group, options) => {\n    assertParsed(group); // Build the inner expression\n\n    const inner = buildExpression(group.body, options, true, [\"mopen\", \"mclose\"]);\n    let innerHeight = 0;\n    let innerDepth = 0;\n    let hadMiddle = false; // Calculate its height and depth\n\n    for (let i = 0; i < inner.length; i++) {\n      // Property `isMiddle` not defined on `span`. See comment in\n      // \"middle\"'s htmlBuilder.\n      // $FlowFixMe\n      if (inner[i].isMiddle) {\n        hadMiddle = true;\n      } else {\n        innerHeight = Math.max(inner[i].height, innerHeight);\n        innerDepth = Math.max(inner[i].depth, innerDepth);\n      }\n    } // The size of delimiters is the same, regardless of what style we are\n    // in. Thus, to correctly calculate the size of delimiter we need around\n    // a group, we scale down the inner size based on the size.\n\n\n    innerHeight *= options.sizeMultiplier;\n    innerDepth *= options.sizeMultiplier;\n    let leftDelim;\n\n    if (group.left === \".\") {\n      // Empty delimiters in \\left and \\right make null delimiter spaces.\n      leftDelim = makeNullDelimiter(options, [\"mopen\"]);\n    } else {\n      // Otherwise, use leftRightDelim to generate the correct sized\n      // delimiter.\n      leftDelim = delimiter.leftRightDelim(group.left, innerHeight, innerDepth, options, group.mode, [\"mopen\"]);\n    } // Add it to the beginning of the expression\n\n\n    inner.unshift(leftDelim); // Handle middle delimiters\n\n    if (hadMiddle) {\n      for (let i = 1; i < inner.length; i++) {\n        const middleDelim = inner[i]; // Property `isMiddle` not defined on `span`. See comment in\n        // \"middle\"'s htmlBuilder.\n        // $FlowFixMe\n\n        const isMiddle = middleDelim.isMiddle;\n\n        if (isMiddle) {\n          // Apply the options that were active when \\middle was called\n          inner[i] = delimiter.leftRightDelim(isMiddle.delim, innerHeight, innerDepth, isMiddle.options, group.mode, []);\n        }\n      }\n    }\n\n    let rightDelim; // Same for the right delimiter, but using color specified by \\color\n\n    if (group.right === \".\") {\n      rightDelim = makeNullDelimiter(options, [\"mclose\"]);\n    } else {\n      const colorOptions = group.rightColor ? options.withColor(group.rightColor) : options;\n      rightDelim = delimiter.leftRightDelim(group.right, innerHeight, innerDepth, colorOptions, group.mode, [\"mclose\"]);\n    } // Add it to the end of the expression.\n\n\n    inner.push(rightDelim);\n    return buildCommon.makeSpan([\"minner\"], inner, options);\n  },\n  mathmlBuilder: (group, options) => {\n    assertParsed(group);\n    const inner = buildMathML_buildExpression(group.body, options);\n\n    if (group.left !== \".\") {\n      const leftNode = new mathMLTree.MathNode(\"mo\", [makeText(group.left, group.mode)]);\n      leftNode.setAttribute(\"fence\", \"true\");\n      inner.unshift(leftNode);\n    }\n\n    if (group.right !== \".\") {\n      const rightNode = new mathMLTree.MathNode(\"mo\", [makeText(group.right, group.mode)]);\n      rightNode.setAttribute(\"fence\", \"true\");\n\n      if (group.rightColor) {\n        rightNode.setAttribute(\"mathcolor\", group.rightColor);\n      }\n\n      inner.push(rightNode);\n    }\n\n    return makeRow(inner);\n  }\n});\ndefineFunction({\n  type: \"middle\",\n  names: [\"\\\\middle\"],\n  props: {\n    numArgs: 1,\n    primitive: true\n  },\n  handler: (context, args) => {\n    const delim = checkDelimiter(args[0], context);\n\n    if (!context.parser.leftrightDepth) {\n      throw new src_ParseError(\"\\\\middle without preceding \\\\left\", delim);\n    }\n\n    return {\n      type: \"middle\",\n      mode: context.parser.mode,\n      delim: delim.text\n    };\n  },\n  htmlBuilder: (group, options) => {\n    let middleDelim;\n\n    if (group.delim === \".\") {\n      middleDelim = makeNullDelimiter(options, []);\n    } else {\n      middleDelim = delimiter.sizedDelim(group.delim, 1, options, group.mode, []);\n      const isMiddle = {\n        delim: group.delim,\n        options\n      }; // Property `isMiddle` not defined on `span`. It is only used in\n      // this file above.\n      // TODO: Fix this violation of the `span` type and possibly rename\n      // things since `isMiddle` sounds like a boolean, but is a struct.\n      // $FlowFixMe\n\n      middleDelim.isMiddle = isMiddle;\n    }\n\n    return middleDelim;\n  },\n  mathmlBuilder: (group, options) => {\n    // A Firefox \\middle will stretch a character vertically only if it\n    // is in the fence part of the operator dictionary at:\n    // https://www.w3.org/TR/MathML3/appendixc.html.\n    // So we need to avoid U+2223 and use plain \"|\" instead.\n    const textNode = group.delim === \"\\\\vert\" || group.delim === \"|\" ? makeText(\"|\", \"text\") : makeText(group.delim, group.mode);\n    const middleNode = new mathMLTree.MathNode(\"mo\", [textNode]);\n    middleNode.setAttribute(\"fence\", \"true\"); // MathML gives 5/18em spacing to each <mo> element.\n    // \\middle should get delimiter spacing instead.\n\n    middleNode.setAttribute(\"lspace\", \"0.05em\");\n    middleNode.setAttribute(\"rspace\", \"0.05em\");\n    return middleNode;\n  }\n});\n;// CONCATENATED MODULE: ./src/functions/enclose.js\n\n\n\n\n\n\n\n\n\n\n\n\nconst enclose_htmlBuilder = (group, options) => {\n  // \\cancel, \\bcancel, \\xcancel, \\sout, \\fbox, \\colorbox, \\fcolorbox, \\phase\n  // Some groups can return document fragments.  Handle those by wrapping\n  // them in a span.\n  const inner = buildCommon.wrapFragment(buildGroup(group.body, options), options);\n  const label = group.label.slice(1);\n  let scale = options.sizeMultiplier;\n  let img;\n  let imgShift = 0; // In the LaTeX cancel package, line geometry is slightly different\n  // depending on whether the subject is wider than it is tall, or vice versa.\n  // We don't know the width of a group, so as a proxy, we test if\n  // the subject is a single character. This captures most of the\n  // subjects that should get the \"tall\" treatment.\n\n  const isSingleChar = utils.isCharacterBox(group.body);\n\n  if (label === \"sout\") {\n    img = buildCommon.makeSpan([\"stretchy\", \"sout\"]);\n    img.height = options.fontMetrics().defaultRuleThickness / scale;\n    imgShift = -0.5 * options.fontMetrics().xHeight;\n  } else if (label === \"phase\") {\n    // Set a couple of dimensions from the steinmetz package.\n    const lineWeight = calculateSize({\n      number: 0.6,\n      unit: \"pt\"\n    }, options);\n    const clearance = calculateSize({\n      number: 0.35,\n      unit: \"ex\"\n    }, options); // Prevent size changes like \\Huge from affecting line thickness\n\n    const newOptions = options.havingBaseSizing();\n    scale = scale / newOptions.sizeMultiplier;\n    const angleHeight = inner.height + inner.depth + lineWeight + clearance; // Reserve a left pad for the angle.\n\n    inner.style.paddingLeft = makeEm(angleHeight / 2 + lineWeight); // Create an SVG\n\n    const viewBoxHeight = Math.floor(1000 * angleHeight * scale);\n    const path = phasePath(viewBoxHeight);\n    const svgNode = new SvgNode([new PathNode(\"phase\", path)], {\n      \"width\": \"400em\",\n      \"height\": makeEm(viewBoxHeight / 1000),\n      \"viewBox\": \"0 0 400000 \" + viewBoxHeight,\n      \"preserveAspectRatio\": \"xMinYMin slice\"\n    }); // Wrap it in a span with overflow: hidden.\n\n    img = buildCommon.makeSvgSpan([\"hide-tail\"], [svgNode], options);\n    img.style.height = makeEm(angleHeight);\n    imgShift = inner.depth + lineWeight + clearance;\n  } else {\n    // Add horizontal padding\n    if (/cancel/.test(label)) {\n      if (!isSingleChar) {\n        inner.classes.push(\"cancel-pad\");\n      }\n    } else if (label === \"angl\") {\n      inner.classes.push(\"anglpad\");\n    } else {\n      inner.classes.push(\"boxpad\");\n    } // Add vertical padding\n\n\n    let topPad = 0;\n    let bottomPad = 0;\n    let ruleThickness = 0; // ref: cancel package: \\advance\\totalheight2\\p@ % \"+2\"\n\n    if (/box/.test(label)) {\n      ruleThickness = Math.max(options.fontMetrics().fboxrule, // default\n      options.minRuleThickness // User override.\n      );\n      topPad = options.fontMetrics().fboxsep + (label === \"colorbox\" ? 0 : ruleThickness);\n      bottomPad = topPad;\n    } else if (label === \"angl\") {\n      ruleThickness = Math.max(options.fontMetrics().defaultRuleThickness, options.minRuleThickness);\n      topPad = 4 * ruleThickness; // gap = 3  line, plus the line itself.\n\n      bottomPad = Math.max(0, 0.25 - inner.depth);\n    } else {\n      topPad = isSingleChar ? 0.2 : 0;\n      bottomPad = topPad;\n    }\n\n    img = stretchy.encloseSpan(inner, label, topPad, bottomPad, options);\n\n    if (/fbox|boxed|fcolorbox/.test(label)) {\n      img.style.borderStyle = \"solid\";\n      img.style.borderWidth = makeEm(ruleThickness);\n    } else if (label === \"angl\" && ruleThickness !== 0.049) {\n      img.style.borderTopWidth = makeEm(ruleThickness);\n      img.style.borderRightWidth = makeEm(ruleThickness);\n    }\n\n    imgShift = inner.depth + bottomPad;\n\n    if (group.backgroundColor) {\n      img.style.backgroundColor = group.backgroundColor;\n\n      if (group.borderColor) {\n        img.style.borderColor = group.borderColor;\n      }\n    }\n  }\n\n  let vlist;\n\n  if (group.backgroundColor) {\n    vlist = buildCommon.makeVList({\n      positionType: \"individualShift\",\n      children: [// Put the color background behind inner;\n      {\n        type: \"elem\",\n        elem: img,\n        shift: imgShift\n      }, {\n        type: \"elem\",\n        elem: inner,\n        shift: 0\n      }]\n    }, options);\n  } else {\n    const classes = /cancel|phase/.test(label) ? [\"svg-align\"] : [];\n    vlist = buildCommon.makeVList({\n      positionType: \"individualShift\",\n      children: [// Write the \\cancel stroke on top of inner.\n      {\n        type: \"elem\",\n        elem: inner,\n        shift: 0\n      }, {\n        type: \"elem\",\n        elem: img,\n        shift: imgShift,\n        wrapperClasses: classes\n      }]\n    }, options);\n  }\n\n  if (/cancel/.test(label)) {\n    // The cancel package documentation says that cancel lines add their height\n    // to the expression, but tests show that isn't how it actually works.\n    vlist.height = inner.height;\n    vlist.depth = inner.depth;\n  }\n\n  if (/cancel/.test(label) && !isSingleChar) {\n    // cancel does not create horiz space for its line extension.\n    return buildCommon.makeSpan([\"mord\", \"cancel-lap\"], [vlist], options);\n  } else {\n    return buildCommon.makeSpan([\"mord\"], [vlist], options);\n  }\n};\n\nconst enclose_mathmlBuilder = (group, options) => {\n  let fboxsep = 0;\n  const node = new mathMLTree.MathNode(group.label.indexOf(\"colorbox\") > -1 ? \"mpadded\" : \"menclose\", [buildMathML_buildGroup(group.body, options)]);\n\n  switch (group.label) {\n    case \"\\\\cancel\":\n      node.setAttribute(\"notation\", \"updiagonalstrike\");\n      break;\n\n    case \"\\\\bcancel\":\n      node.setAttribute(\"notation\", \"downdiagonalstrike\");\n      break;\n\n    case \"\\\\phase\":\n      node.setAttribute(\"notation\", \"phasorangle\");\n      break;\n\n    case \"\\\\sout\":\n      node.setAttribute(\"notation\", \"horizontalstrike\");\n      break;\n\n    case \"\\\\fbox\":\n      node.setAttribute(\"notation\", \"box\");\n      break;\n\n    case \"\\\\angl\":\n      node.setAttribute(\"notation\", \"actuarial\");\n      break;\n\n    case \"\\\\fcolorbox\":\n    case \"\\\\colorbox\":\n      // <menclose> doesn't have a good notation option. So use <mpadded>\n      // instead. Set some attributes that come included with <menclose>.\n      fboxsep = options.fontMetrics().fboxsep * options.fontMetrics().ptPerEm;\n      node.setAttribute(\"width\", \"+\" + 2 * fboxsep + \"pt\");\n      node.setAttribute(\"height\", \"+\" + 2 * fboxsep + \"pt\");\n      node.setAttribute(\"lspace\", fboxsep + \"pt\"); //\n\n      node.setAttribute(\"voffset\", fboxsep + \"pt\");\n\n      if (group.label === \"\\\\fcolorbox\") {\n        const thk = Math.max(options.fontMetrics().fboxrule, // default\n        options.minRuleThickness // user override\n        );\n        node.setAttribute(\"style\", \"border: \" + thk + \"em solid \" + String(group.borderColor));\n      }\n\n      break;\n\n    case \"\\\\xcancel\":\n      node.setAttribute(\"notation\", \"updiagonalstrike downdiagonalstrike\");\n      break;\n  }\n\n  if (group.backgroundColor) {\n    node.setAttribute(\"mathbackground\", group.backgroundColor);\n  }\n\n  return node;\n};\n\ndefineFunction({\n  type: \"enclose\",\n  names: [\"\\\\colorbox\"],\n  props: {\n    numArgs: 2,\n    allowedInText: true,\n    argTypes: [\"color\", \"text\"]\n  },\n\n  handler(_ref, args, optArgs) {\n    let {\n      parser,\n      funcName\n    } = _ref;\n    const color = assertNodeType(args[0], \"color-token\").color;\n    const body = args[1];\n    return {\n      type: \"enclose\",\n      mode: parser.mode,\n      label: funcName,\n      backgroundColor: color,\n      body\n    };\n  },\n\n  htmlBuilder: enclose_htmlBuilder,\n  mathmlBuilder: enclose_mathmlBuilder\n});\ndefineFunction({\n  type: \"enclose\",\n  names: [\"\\\\fcolorbox\"],\n  props: {\n    numArgs: 3,\n    allowedInText: true,\n    argTypes: [\"color\", \"color\", \"text\"]\n  },\n\n  handler(_ref2, args, optArgs) {\n    let {\n      parser,\n      funcName\n    } = _ref2;\n    const borderColor = assertNodeType(args[0], \"color-token\").color;\n    const backgroundColor = assertNodeType(args[1], \"color-token\").color;\n    const body = args[2];\n    return {\n      type: \"enclose\",\n      mode: parser.mode,\n      label: funcName,\n      backgroundColor,\n      borderColor,\n      body\n    };\n  },\n\n  htmlBuilder: enclose_htmlBuilder,\n  mathmlBuilder: enclose_mathmlBuilder\n});\ndefineFunction({\n  type: \"enclose\",\n  names: [\"\\\\fbox\"],\n  props: {\n    numArgs: 1,\n    argTypes: [\"hbox\"],\n    allowedInText: true\n  },\n\n  handler(_ref3, args) {\n    let {\n      parser\n    } = _ref3;\n    return {\n      type: \"enclose\",\n      mode: parser.mode,\n      label: \"\\\\fbox\",\n      body: args[0]\n    };\n  }\n\n});\ndefineFunction({\n  type: \"enclose\",\n  names: [\"\\\\cancel\", \"\\\\bcancel\", \"\\\\xcancel\", \"\\\\sout\", \"\\\\phase\"],\n  props: {\n    numArgs: 1\n  },\n\n  handler(_ref4, args) {\n    let {\n      parser,\n      funcName\n    } = _ref4;\n    const body = args[0];\n    return {\n      type: \"enclose\",\n      mode: parser.mode,\n      label: funcName,\n      body\n    };\n  },\n\n  htmlBuilder: enclose_htmlBuilder,\n  mathmlBuilder: enclose_mathmlBuilder\n});\ndefineFunction({\n  type: \"enclose\",\n  names: [\"\\\\angl\"],\n  props: {\n    numArgs: 1,\n    argTypes: [\"hbox\"],\n    allowedInText: false\n  },\n\n  handler(_ref5, args) {\n    let {\n      parser\n    } = _ref5;\n    return {\n      type: \"enclose\",\n      mode: parser.mode,\n      label: \"\\\\angl\",\n      body: args[0]\n    };\n  }\n\n});\n;// CONCATENATED MODULE: ./src/defineEnvironment.js\n\n\n/**\n * All registered environments.\n * `environments.js` exports this same dictionary again and makes it public.\n * `Parser.js` requires this dictionary via `environments.js`.\n */\nconst _environments = {};\nfunction defineEnvironment(_ref) {\n  let {\n    type,\n    names,\n    props,\n    handler,\n    htmlBuilder,\n    mathmlBuilder\n  } = _ref;\n  // Set default values of environments.\n  const data = {\n    type,\n    numArgs: props.numArgs || 0,\n    allowedInText: false,\n    numOptionalArgs: 0,\n    handler\n  };\n\n  for (let i = 0; i < names.length; ++i) {\n    // TODO: The value type of _environments should be a type union of all\n    // possible `EnvSpec<>` possibilities instead of `EnvSpec<*>`, which is\n    // an existential type.\n    _environments[names[i]] = data;\n  }\n\n  if (htmlBuilder) {\n    _htmlGroupBuilders[type] = htmlBuilder;\n  }\n\n  if (mathmlBuilder) {\n    _mathmlGroupBuilders[type] = mathmlBuilder;\n  }\n}\n;// CONCATENATED MODULE: ./src/defineMacro.js\n\n\n/**\n * All registered global/built-in macros.\n * `macros.js` exports this same dictionary again and makes it public.\n * `Parser.js` requires this dictionary via `macros.js`.\n */\nconst _macros = {}; // This function might one day accept an additional argument and do more things.\n\nfunction defineMacro(name, body) {\n  _macros[name] = body;\n}\n;// CONCATENATED MODULE: ./src/SourceLocation.js\n/**\n * Lexing or parsing positional information for error reporting.\n * This object is immutable.\n */\nclass SourceLocation {\n  // The + prefix indicates that these fields aren't writeable\n  // Lexer holding the input string.\n  // Start offset, zero-based inclusive.\n  // End offset, zero-based exclusive.\n  constructor(lexer, start, end) {\n    this.lexer = void 0;\n    this.start = void 0;\n    this.end = void 0;\n    this.lexer = lexer;\n    this.start = start;\n    this.end = end;\n  }\n  /**\n   * Merges two `SourceLocation`s from location providers, given they are\n   * provided in order of appearance.\n   * - Returns the first one's location if only the first is provided.\n   * - Returns a merged range of the first and the last if both are provided\n   *   and their lexers match.\n   * - Otherwise, returns null.\n   */\n\n\n  static range(first, second) {\n    if (!second) {\n      return first && first.loc;\n    } else if (!first || !first.loc || !second.loc || first.loc.lexer !== second.loc.lexer) {\n      return null;\n    } else {\n      return new SourceLocation(first.loc.lexer, first.loc.start, second.loc.end);\n    }\n  }\n\n}\n;// CONCATENATED MODULE: ./src/Token.js\n\n/**\n * Interface required to break circular dependency between Token, Lexer, and\n * ParseError.\n */\n\n/**\n * The resulting token returned from `lex`.\n *\n * It consists of the token text plus some position information.\n * The position information is essentially a range in an input string,\n * but instead of referencing the bare input string, we refer to the lexer.\n * That way it is possible to attach extra metadata to the input string,\n * like for example a file name or similar.\n *\n * The position information is optional, so it is OK to construct synthetic\n * tokens if appropriate. Not providing available position information may\n * lead to degraded error reporting, though.\n */\nclass Token {\n  // don't expand the token\n  // used in \\noexpand\n  constructor(text, // the text of this token\n  loc) {\n    this.text = void 0;\n    this.loc = void 0;\n    this.noexpand = void 0;\n    this.treatAsRelax = void 0;\n    this.text = text;\n    this.loc = loc;\n  }\n  /**\n   * Given a pair of tokens (this and endToken), compute a `Token` encompassing\n   * the whole input range enclosed by these two.\n   */\n\n\n  range(endToken, // last token of the range, inclusive\n  text // the text of the newly constructed token\n  ) {\n    return new Token(text, SourceLocation.range(this, endToken));\n  }\n\n}\n;// CONCATENATED MODULE: ./src/environments/array.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// Helper functions\nfunction getHLines(parser) {\n  // Return an array. The array length = number of hlines.\n  // Each element in the array tells if the line is dashed.\n  const hlineInfo = [];\n  parser.consumeSpaces();\n  let nxt = parser.fetch().text;\n\n  if (nxt === \"\\\\relax\") {\n    // \\relax is an artifact of the \\cr macro below\n    parser.consume();\n    parser.consumeSpaces();\n    nxt = parser.fetch().text;\n  }\n\n  while (nxt === \"\\\\hline\" || nxt === \"\\\\hdashline\") {\n    parser.consume();\n    hlineInfo.push(nxt === \"\\\\hdashline\");\n    parser.consumeSpaces();\n    nxt = parser.fetch().text;\n  }\n\n  return hlineInfo;\n}\n\nconst validateAmsEnvironmentContext = context => {\n  const settings = context.parser.settings;\n\n  if (!settings.displayMode) {\n    throw new src_ParseError(\"{\" + context.envName + \"} can be used only in\" + \" display mode.\");\n  }\n}; // autoTag (an argument to parseArray) can be one of three values:\n// * undefined: Regular (not-top-level) array; no tags on each row\n// * true: Automatic equation numbering, overridable by \\tag\n// * false: Tags allowed on each row, but no automatic numbering\n// This function *doesn't* work with the \"split\" environment name.\n\n\nfunction getAutoTag(name) {\n  if (name.indexOf(\"ed\") === -1) {\n    return name.indexOf(\"*\") === -1;\n  } // return undefined;\n\n}\n/**\n * Parse the body of the environment, with rows delimited by \\\\ and\n * columns delimited by &, and create a nested list in row-major order\n * with one group per cell.  If given an optional argument style\n * (\"text\", \"display\", etc.), then each cell is cast into that style.\n */\n\n\nfunction parseArray(parser, _ref, style) {\n  let {\n    hskipBeforeAndAfter,\n    addJot,\n    cols,\n    arraystretch,\n    colSeparationType,\n    autoTag,\n    singleRow,\n    emptySingleRow,\n    maxNumCols,\n    leqno\n  } = _ref;\n  parser.gullet.beginGroup();\n\n  if (!singleRow) {\n    // \\cr is equivalent to \\\\ without the optional size argument (see below)\n    // TODO: provide helpful error when \\cr is used outside array environment\n    parser.gullet.macros.set(\"\\\\cr\", \"\\\\\\\\\\\\relax\");\n  } // Get current arraystretch if it's not set by the environment\n\n\n  if (!arraystretch) {\n    const stretch = parser.gullet.expandMacroAsText(\"\\\\arraystretch\");\n\n    if (stretch == null) {\n      // Default \\arraystretch from lttab.dtx\n      arraystretch = 1;\n    } else {\n      arraystretch = parseFloat(stretch);\n\n      if (!arraystretch || arraystretch < 0) {\n        throw new src_ParseError(\"Invalid \\\\arraystretch: \" + stretch);\n      }\n    }\n  } // Start group for first cell\n\n\n  parser.gullet.beginGroup();\n  let row = [];\n  const body = [row];\n  const rowGaps = [];\n  const hLinesBeforeRow = [];\n  const tags = autoTag != null ? [] : undefined; // amsmath uses \\global\\@eqnswtrue and \\global\\@eqnswfalse to represent\n  // whether this row should have an equation number.  Simulate this with\n  // a \\@eqnsw macro set to 1 or 0.\n\n  function beginRow() {\n    if (autoTag) {\n      parser.gullet.macros.set(\"\\\\@eqnsw\", \"1\", true);\n    }\n  }\n\n  function endRow() {\n    if (tags) {\n      if (parser.gullet.macros.get(\"\\\\df@tag\")) {\n        tags.push(parser.subparse([new Token(\"\\\\df@tag\")]));\n        parser.gullet.macros.set(\"\\\\df@tag\", undefined, true);\n      } else {\n        tags.push(Boolean(autoTag) && parser.gullet.macros.get(\"\\\\@eqnsw\") === \"1\");\n      }\n    }\n  }\n\n  beginRow(); // Test for \\hline at the top of the array.\n\n  hLinesBeforeRow.push(getHLines(parser));\n\n  while (true) {\n    // eslint-disable-line no-constant-condition\n    // Parse each cell in its own group (namespace)\n    let cell = parser.parseExpression(false, singleRow ? \"\\\\end\" : \"\\\\\\\\\");\n    parser.gullet.endGroup();\n    parser.gullet.beginGroup();\n    cell = {\n      type: \"ordgroup\",\n      mode: parser.mode,\n      body: cell\n    };\n\n    if (style) {\n      cell = {\n        type: \"styling\",\n        mode: parser.mode,\n        style,\n        body: [cell]\n      };\n    }\n\n    row.push(cell);\n    const next = parser.fetch().text;\n\n    if (next === \"&\") {\n      if (maxNumCols && row.length === maxNumCols) {\n        if (singleRow || colSeparationType) {\n          // {equation} or {split}\n          throw new src_ParseError(\"Too many tab characters: &\", parser.nextToken);\n        } else {\n          // {array} environment\n          parser.settings.reportNonstrict(\"textEnv\", \"Too few columns \" + \"specified in the {array} column argument.\");\n        }\n      }\n\n      parser.consume();\n    } else if (next === \"\\\\end\") {\n      endRow(); // Arrays terminate newlines with `\\crcr` which consumes a `\\cr` if\n      // the last line is empty.  However, AMS environments keep the\n      // empty row if it's the only one.\n      // NOTE: Currently, `cell` is the last item added into `row`.\n\n      if (row.length === 1 && cell.type === \"styling\" && cell.body[0].body.length === 0 && (body.length > 1 || !emptySingleRow)) {\n        body.pop();\n      }\n\n      if (hLinesBeforeRow.length < body.length + 1) {\n        hLinesBeforeRow.push([]);\n      }\n\n      break;\n    } else if (next === \"\\\\\\\\\") {\n      parser.consume();\n      let size; // \\def\\Let@{\\let\\\\\\math@cr}\n      // \\def\\math@cr{...\\math@cr@}\n      // \\def\\math@cr@{\\new@ifnextchar[\\math@cr@@{\\math@cr@@[\\z@]}}\n      // \\def\\math@cr@@[#1]{...\\math@cr@@@...}\n      // \\def\\math@cr@@@{\\cr}\n\n      if (parser.gullet.future().text !== \" \") {\n        size = parser.parseSizeGroup(true);\n      }\n\n      rowGaps.push(size ? size.value : null);\n      endRow(); // check for \\hline(s) following the row separator\n\n      hLinesBeforeRow.push(getHLines(parser));\n      row = [];\n      body.push(row);\n      beginRow();\n    } else {\n      throw new src_ParseError(\"Expected & or \\\\\\\\ or \\\\cr or \\\\end\", parser.nextToken);\n    }\n  } // End cell group\n\n\n  parser.gullet.endGroup(); // End array group defining \\cr\n\n  parser.gullet.endGroup();\n  return {\n    type: \"array\",\n    mode: parser.mode,\n    addJot,\n    arraystretch,\n    body,\n    cols,\n    rowGaps,\n    hskipBeforeAndAfter,\n    hLinesBeforeRow,\n    colSeparationType,\n    tags,\n    leqno\n  };\n} // Decides on a style for cells in an array according to whether the given\n// environment name starts with the letter 'd'.\n\n\nfunction dCellStyle(envName) {\n  if (envName.slice(0, 1) === \"d\") {\n    return \"display\";\n  } else {\n    return \"text\";\n  }\n}\n\nconst array_htmlBuilder = function (group, options) {\n  let r;\n  let c;\n  const nr = group.body.length;\n  const hLinesBeforeRow = group.hLinesBeforeRow;\n  let nc = 0;\n  let body = new Array(nr);\n  const hlines = [];\n  const ruleThickness = Math.max( // From LaTeX \\showthe\\arrayrulewidth. Equals 0.04 em.\n  options.fontMetrics().arrayRuleWidth, options.minRuleThickness // User override.\n  ); // Horizontal spacing\n\n  const pt = 1 / options.fontMetrics().ptPerEm;\n  let arraycolsep = 5 * pt; // default value, i.e. \\arraycolsep in article.cls\n\n  if (group.colSeparationType && group.colSeparationType === \"small\") {\n    // We're in a {smallmatrix}. Default column space is \\thickspace,\n    // i.e. 5/18em = 0.2778em, per amsmath.dtx for {smallmatrix}.\n    // But that needs adjustment because LaTeX applies \\scriptstyle to the\n    // entire array, including the colspace, but this function applies\n    // \\scriptstyle only inside each element.\n    const localMultiplier = options.havingStyle(src_Style.SCRIPT).sizeMultiplier;\n    arraycolsep = 0.2778 * (localMultiplier / options.sizeMultiplier);\n  } // Vertical spacing\n\n\n  const baselineskip = group.colSeparationType === \"CD\" ? calculateSize({\n    number: 3,\n    unit: \"ex\"\n  }, options) : 12 * pt; // see size10.clo\n  // Default \\jot from ltmath.dtx\n  // TODO(edemaine): allow overriding \\jot via \\setlength (#687)\n\n  const jot = 3 * pt;\n  const arrayskip = group.arraystretch * baselineskip;\n  const arstrutHeight = 0.7 * arrayskip; // \\strutbox in ltfsstrc.dtx and\n\n  const arstrutDepth = 0.3 * arrayskip; // \\@arstrutbox in lttab.dtx\n\n  let totalHeight = 0; // Set a position for \\hline(s) at the top of the array, if any.\n\n  function setHLinePos(hlinesInGap) {\n    for (let i = 0; i < hlinesInGap.length; ++i) {\n      if (i > 0) {\n        totalHeight += 0.25;\n      }\n\n      hlines.push({\n        pos: totalHeight,\n        isDashed: hlinesInGap[i]\n      });\n    }\n  }\n\n  setHLinePos(hLinesBeforeRow[0]);\n\n  for (r = 0; r < group.body.length; ++r) {\n    const inrow = group.body[r];\n    let height = arstrutHeight; // \\@array adds an \\@arstrut\n\n    let depth = arstrutDepth; // to each tow (via the template)\n\n    if (nc < inrow.length) {\n      nc = inrow.length;\n    }\n\n    const outrow = new Array(inrow.length);\n\n    for (c = 0; c < inrow.length; ++c) {\n      const elt = buildGroup(inrow[c], options);\n\n      if (depth < elt.depth) {\n        depth = elt.depth;\n      }\n\n      if (height < elt.height) {\n        height = elt.height;\n      }\n\n      outrow[c] = elt;\n    }\n\n    const rowGap = group.rowGaps[r];\n    let gap = 0;\n\n    if (rowGap) {\n      gap = calculateSize(rowGap, options);\n\n      if (gap > 0) {\n        // \\@argarraycr\n        gap += arstrutDepth;\n\n        if (depth < gap) {\n          depth = gap; // \\@xargarraycr\n        }\n\n        gap = 0;\n      }\n    } // In AMS multiline environments such as aligned and gathered, rows\n    // correspond to lines that have additional \\jot added to the\n    // \\baselineskip via \\openup.\n\n\n    if (group.addJot) {\n      depth += jot;\n    }\n\n    outrow.height = height;\n    outrow.depth = depth;\n    totalHeight += height;\n    outrow.pos = totalHeight;\n    totalHeight += depth + gap; // \\@yargarraycr\n\n    body[r] = outrow; // Set a position for \\hline(s), if any.\n\n    setHLinePos(hLinesBeforeRow[r + 1]);\n  }\n\n  const offset = totalHeight / 2 + options.fontMetrics().axisHeight;\n  const colDescriptions = group.cols || [];\n  const cols = [];\n  let colSep;\n  let colDescrNum;\n  const tagSpans = [];\n\n  if (group.tags && group.tags.some(tag => tag)) {\n    // An environment with manual tags and/or automatic equation numbers.\n    // Create node(s), the latter of which trigger CSS counter increment.\n    for (r = 0; r < nr; ++r) {\n      const rw = body[r];\n      const shift = rw.pos - offset;\n      const tag = group.tags[r];\n      let tagSpan;\n\n      if (tag === true) {\n        // automatic numbering\n        tagSpan = buildCommon.makeSpan([\"eqn-num\"], [], options);\n      } else if (tag === false) {\n        // \\nonumber/\\notag or starred environment\n        tagSpan = buildCommon.makeSpan([], [], options);\n      } else {\n        // manual \\tag\n        tagSpan = buildCommon.makeSpan([], buildExpression(tag, options, true), options);\n      }\n\n      tagSpan.depth = rw.depth;\n      tagSpan.height = rw.height;\n      tagSpans.push({\n        type: \"elem\",\n        elem: tagSpan,\n        shift\n      });\n    }\n  }\n\n  for (c = 0, colDescrNum = 0; // Continue while either there are more columns or more column\n  // descriptions, so trailing separators don't get lost.\n  c < nc || colDescrNum < colDescriptions.length; ++c, ++colDescrNum) {\n    let colDescr = colDescriptions[colDescrNum] || {};\n    let firstSeparator = true;\n\n    while (colDescr.type === \"separator\") {\n      // If there is more than one separator in a row, add a space\n      // between them.\n      if (!firstSeparator) {\n        colSep = buildCommon.makeSpan([\"arraycolsep\"], []);\n        colSep.style.width = makeEm(options.fontMetrics().doubleRuleSep);\n        cols.push(colSep);\n      }\n\n      if (colDescr.separator === \"|\" || colDescr.separator === \":\") {\n        const lineType = colDescr.separator === \"|\" ? \"solid\" : \"dashed\";\n        const separator = buildCommon.makeSpan([\"vertical-separator\"], [], options);\n        separator.style.height = makeEm(totalHeight);\n        separator.style.borderRightWidth = makeEm(ruleThickness);\n        separator.style.borderRightStyle = lineType;\n        separator.style.margin = \"0 \" + makeEm(-ruleThickness / 2);\n        const shift = totalHeight - offset;\n\n        if (shift) {\n          separator.style.verticalAlign = makeEm(-shift);\n        }\n\n        cols.push(separator);\n      } else {\n        throw new src_ParseError(\"Invalid separator type: \" + colDescr.separator);\n      }\n\n      colDescrNum++;\n      colDescr = colDescriptions[colDescrNum] || {};\n      firstSeparator = false;\n    }\n\n    if (c >= nc) {\n      continue;\n    }\n\n    let sepwidth;\n\n    if (c > 0 || group.hskipBeforeAndAfter) {\n      sepwidth = utils.deflt(colDescr.pregap, arraycolsep);\n\n      if (sepwidth !== 0) {\n        colSep = buildCommon.makeSpan([\"arraycolsep\"], []);\n        colSep.style.width = makeEm(sepwidth);\n        cols.push(colSep);\n      }\n    }\n\n    let col = [];\n\n    for (r = 0; r < nr; ++r) {\n      const row = body[r];\n      const elem = row[c];\n\n      if (!elem) {\n        continue;\n      }\n\n      const shift = row.pos - offset;\n      elem.depth = row.depth;\n      elem.height = row.height;\n      col.push({\n        type: \"elem\",\n        elem: elem,\n        shift: shift\n      });\n    }\n\n    col = buildCommon.makeVList({\n      positionType: \"individualShift\",\n      children: col\n    }, options);\n    col = buildCommon.makeSpan([\"col-align-\" + (colDescr.align || \"c\")], [col]);\n    cols.push(col);\n\n    if (c < nc - 1 || group.hskipBeforeAndAfter) {\n      sepwidth = utils.deflt(colDescr.postgap, arraycolsep);\n\n      if (sepwidth !== 0) {\n        colSep = buildCommon.makeSpan([\"arraycolsep\"], []);\n        colSep.style.width = makeEm(sepwidth);\n        cols.push(colSep);\n      }\n    }\n  }\n\n  body = buildCommon.makeSpan([\"mtable\"], cols); // Add \\hline(s), if any.\n\n  if (hlines.length > 0) {\n    const line = buildCommon.makeLineSpan(\"hline\", options, ruleThickness);\n    const dashes = buildCommon.makeLineSpan(\"hdashline\", options, ruleThickness);\n    const vListElems = [{\n      type: \"elem\",\n      elem: body,\n      shift: 0\n    }];\n\n    while (hlines.length > 0) {\n      const hline = hlines.pop();\n      const lineShift = hline.pos - offset;\n\n      if (hline.isDashed) {\n        vListElems.push({\n          type: \"elem\",\n          elem: dashes,\n          shift: lineShift\n        });\n      } else {\n        vListElems.push({\n          type: \"elem\",\n          elem: line,\n          shift: lineShift\n        });\n      }\n    }\n\n    body = buildCommon.makeVList({\n      positionType: \"individualShift\",\n      children: vListElems\n    }, options);\n  }\n\n  if (tagSpans.length === 0) {\n    return buildCommon.makeSpan([\"mord\"], [body], options);\n  } else {\n    let eqnNumCol = buildCommon.makeVList({\n      positionType: \"individualShift\",\n      children: tagSpans\n    }, options);\n    eqnNumCol = buildCommon.makeSpan([\"tag\"], [eqnNumCol], options);\n    return buildCommon.makeFragment([body, eqnNumCol]);\n  }\n};\n\nconst alignMap = {\n  c: \"center \",\n  l: \"left \",\n  r: \"right \"\n};\n\nconst array_mathmlBuilder = function (group, options) {\n  const tbl = [];\n  const glue = new mathMLTree.MathNode(\"mtd\", [], [\"mtr-glue\"]);\n  const tag = new mathMLTree.MathNode(\"mtd\", [], [\"mml-eqn-num\"]);\n\n  for (let i = 0; i < group.body.length; i++) {\n    const rw = group.body[i];\n    const row = [];\n\n    for (let j = 0; j < rw.length; j++) {\n      row.push(new mathMLTree.MathNode(\"mtd\", [buildMathML_buildGroup(rw[j], options)]));\n    }\n\n    if (group.tags && group.tags[i]) {\n      row.unshift(glue);\n      row.push(glue);\n\n      if (group.leqno) {\n        row.unshift(tag);\n      } else {\n        row.push(tag);\n      }\n    }\n\n    tbl.push(new mathMLTree.MathNode(\"mtr\", row));\n  }\n\n  let table = new mathMLTree.MathNode(\"mtable\", tbl); // Set column alignment, row spacing, column spacing, and\n  // array lines by setting attributes on the table element.\n  // Set the row spacing. In MathML, we specify a gap distance.\n  // We do not use rowGap[] because MathML automatically increases\n  // cell height with the height/depth of the element content.\n  // LaTeX \\arraystretch multiplies the row baseline-to-baseline distance.\n  // We simulate this by adding (arraystretch - 1)em to the gap. This\n  // does a reasonable job of adjusting arrays containing 1 em tall content.\n  // The 0.16 and 0.09 values are found empirically. They produce an array\n  // similar to LaTeX and in which content does not interfere with \\hlines.\n\n  const gap = group.arraystretch === 0.5 ? 0.1 // {smallmatrix}, {subarray}\n  : 0.16 + group.arraystretch - 1 + (group.addJot ? 0.09 : 0);\n  table.setAttribute(\"rowspacing\", makeEm(gap)); // MathML table lines go only between cells.\n  // To place a line on an edge we'll use <menclose>, if necessary.\n\n  let menclose = \"\";\n  let align = \"\";\n\n  if (group.cols && group.cols.length > 0) {\n    // Find column alignment, column spacing, and  vertical lines.\n    const cols = group.cols;\n    let columnLines = \"\";\n    let prevTypeWasAlign = false;\n    let iStart = 0;\n    let iEnd = cols.length;\n\n    if (cols[0].type === \"separator\") {\n      menclose += \"top \";\n      iStart = 1;\n    }\n\n    if (cols[cols.length - 1].type === \"separator\") {\n      menclose += \"bottom \";\n      iEnd -= 1;\n    }\n\n    for (let i = iStart; i < iEnd; i++) {\n      if (cols[i].type === \"align\") {\n        align += alignMap[cols[i].align];\n\n        if (prevTypeWasAlign) {\n          columnLines += \"none \";\n        }\n\n        prevTypeWasAlign = true;\n      } else if (cols[i].type === \"separator\") {\n        // MathML accepts only single lines between cells.\n        // So we read only the first of consecutive separators.\n        if (prevTypeWasAlign) {\n          columnLines += cols[i].separator === \"|\" ? \"solid \" : \"dashed \";\n          prevTypeWasAlign = false;\n        }\n      }\n    }\n\n    table.setAttribute(\"columnalign\", align.trim());\n\n    if (/[sd]/.test(columnLines)) {\n      table.setAttribute(\"columnlines\", columnLines.trim());\n    }\n  } // Set column spacing.\n\n\n  if (group.colSeparationType === \"align\") {\n    const cols = group.cols || [];\n    let spacing = \"\";\n\n    for (let i = 1; i < cols.length; i++) {\n      spacing += i % 2 ? \"0em \" : \"1em \";\n    }\n\n    table.setAttribute(\"columnspacing\", spacing.trim());\n  } else if (group.colSeparationType === \"alignat\" || group.colSeparationType === \"gather\") {\n    table.setAttribute(\"columnspacing\", \"0em\");\n  } else if (group.colSeparationType === \"small\") {\n    table.setAttribute(\"columnspacing\", \"0.2778em\");\n  } else if (group.colSeparationType === \"CD\") {\n    table.setAttribute(\"columnspacing\", \"0.5em\");\n  } else {\n    table.setAttribute(\"columnspacing\", \"1em\");\n  } // Address \\hline and \\hdashline\n\n\n  let rowLines = \"\";\n  const hlines = group.hLinesBeforeRow;\n  menclose += hlines[0].length > 0 ? \"left \" : \"\";\n  menclose += hlines[hlines.length - 1].length > 0 ? \"right \" : \"\";\n\n  for (let i = 1; i < hlines.length - 1; i++) {\n    rowLines += hlines[i].length === 0 ? \"none \" // MathML accepts only a single line between rows. Read one element.\n    : hlines[i][0] ? \"dashed \" : \"solid \";\n  }\n\n  if (/[sd]/.test(rowLines)) {\n    table.setAttribute(\"rowlines\", rowLines.trim());\n  }\n\n  if (menclose !== \"\") {\n    table = new mathMLTree.MathNode(\"menclose\", [table]);\n    table.setAttribute(\"notation\", menclose.trim());\n  }\n\n  if (group.arraystretch && group.arraystretch < 1) {\n    // A small array. Wrap in scriptstyle so row gap is not too large.\n    table = new mathMLTree.MathNode(\"mstyle\", [table]);\n    table.setAttribute(\"scriptlevel\", \"1\");\n  }\n\n  return table;\n}; // Convenience function for align, align*, aligned, alignat, alignat*, alignedat.\n\n\nconst alignedHandler = function (context, args) {\n  if (context.envName.indexOf(\"ed\") === -1) {\n    validateAmsEnvironmentContext(context);\n  }\n\n  const cols = [];\n  const separationType = context.envName.indexOf(\"at\") > -1 ? \"alignat\" : \"align\";\n  const isSplit = context.envName === \"split\";\n  const res = parseArray(context.parser, {\n    cols,\n    addJot: true,\n    autoTag: isSplit ? undefined : getAutoTag(context.envName),\n    emptySingleRow: true,\n    colSeparationType: separationType,\n    maxNumCols: isSplit ? 2 : undefined,\n    leqno: context.parser.settings.leqno\n  }, \"display\"); // Determining number of columns.\n  // 1. If the first argument is given, we use it as a number of columns,\n  //    and makes sure that each row doesn't exceed that number.\n  // 2. Otherwise, just count number of columns = maximum number\n  //    of cells in each row (\"aligned\" mode -- isAligned will be true).\n  //\n  // At the same time, prepend empty group {} at beginning of every second\n  // cell in each row (starting with second cell) so that operators become\n  // binary.  This behavior is implemented in amsmath's \\start@aligned.\n\n  let numMaths;\n  let numCols = 0;\n  const emptyGroup = {\n    type: \"ordgroup\",\n    mode: context.mode,\n    body: []\n  };\n\n  if (args[0] && args[0].type === \"ordgroup\") {\n    let arg0 = \"\";\n\n    for (let i = 0; i < args[0].body.length; i++) {\n      const textord = assertNodeType(args[0].body[i], \"textord\");\n      arg0 += textord.text;\n    }\n\n    numMaths = Number(arg0);\n    numCols = numMaths * 2;\n  }\n\n  const isAligned = !numCols;\n  res.body.forEach(function (row) {\n    for (let i = 1; i < row.length; i += 2) {\n      // Modify ordgroup node within styling node\n      const styling = assertNodeType(row[i], \"styling\");\n      const ordgroup = assertNodeType(styling.body[0], \"ordgroup\");\n      ordgroup.body.unshift(emptyGroup);\n    }\n\n    if (!isAligned) {\n      // Case 1\n      const curMaths = row.length / 2;\n\n      if (numMaths < curMaths) {\n        throw new src_ParseError(\"Too many math in a row: \" + (\"expected \" + numMaths + \", but got \" + curMaths), row[0]);\n      }\n    } else if (numCols < row.length) {\n      // Case 2\n      numCols = row.length;\n    }\n  }); // Adjusting alignment.\n  // In aligned mode, we add one \\qquad between columns;\n  // otherwise we add nothing.\n\n  for (let i = 0; i < numCols; ++i) {\n    let align = \"r\";\n    let pregap = 0;\n\n    if (i % 2 === 1) {\n      align = \"l\";\n    } else if (i > 0 && isAligned) {\n      // \"aligned\" mode.\n      pregap = 1; // add one \\quad\n    }\n\n    cols[i] = {\n      type: \"align\",\n      align: align,\n      pregap: pregap,\n      postgap: 0\n    };\n  }\n\n  res.colSeparationType = isAligned ? \"align\" : \"alignat\";\n  return res;\n}; // Arrays are part of LaTeX, defined in lttab.dtx so its documentation\n// is part of the source2e.pdf file of LaTeX2e source documentation.\n// {darray} is an {array} environment where cells are set in \\displaystyle,\n// as defined in nccmath.sty.\n\n\ndefineEnvironment({\n  type: \"array\",\n  names: [\"array\", \"darray\"],\n  props: {\n    numArgs: 1\n  },\n\n  handler(context, args) {\n    // Since no types are specified above, the two possibilities are\n    // - The argument is wrapped in {} or [], in which case Parser's\n    //   parseGroup() returns an \"ordgroup\" wrapping some symbol node.\n    // - The argument is a bare symbol node.\n    const symNode = checkSymbolNodeType(args[0]);\n    const colalign = symNode ? [args[0]] : assertNodeType(args[0], \"ordgroup\").body;\n    const cols = colalign.map(function (nde) {\n      const node = assertSymbolNodeType(nde);\n      const ca = node.text;\n\n      if (\"lcr\".indexOf(ca) !== -1) {\n        return {\n          type: \"align\",\n          align: ca\n        };\n      } else if (ca === \"|\") {\n        return {\n          type: \"separator\",\n          separator: \"|\"\n        };\n      } else if (ca === \":\") {\n        return {\n          type: \"separator\",\n          separator: \":\"\n        };\n      }\n\n      throw new src_ParseError(\"Unknown column alignment: \" + ca, nde);\n    });\n    const res = {\n      cols,\n      hskipBeforeAndAfter: true,\n      // \\@preamble in lttab.dtx\n      maxNumCols: cols.length\n    };\n    return parseArray(context.parser, res, dCellStyle(context.envName));\n  },\n\n  htmlBuilder: array_htmlBuilder,\n  mathmlBuilder: array_mathmlBuilder\n}); // The matrix environments of amsmath builds on the array environment\n// of LaTeX, which is discussed above.\n// The mathtools package adds starred versions of the same environments.\n// These have an optional argument to choose left|center|right justification.\n\ndefineEnvironment({\n  type: \"array\",\n  names: [\"matrix\", \"pmatrix\", \"bmatrix\", \"Bmatrix\", \"vmatrix\", \"Vmatrix\", \"matrix*\", \"pmatrix*\", \"bmatrix*\", \"Bmatrix*\", \"vmatrix*\", \"Vmatrix*\"],\n  props: {\n    numArgs: 0\n  },\n\n  handler(context) {\n    const delimiters = {\n      \"matrix\": null,\n      \"pmatrix\": [\"(\", \")\"],\n      \"bmatrix\": [\"[\", \"]\"],\n      \"Bmatrix\": [\"\\\\{\", \"\\\\}\"],\n      \"vmatrix\": [\"|\", \"|\"],\n      \"Vmatrix\": [\"\\\\Vert\", \"\\\\Vert\"]\n    }[context.envName.replace(\"*\", \"\")]; // \\hskip -\\arraycolsep in amsmath\n\n    let colAlign = \"c\";\n    const payload = {\n      hskipBeforeAndAfter: false,\n      cols: [{\n        type: \"align\",\n        align: colAlign\n      }]\n    };\n\n    if (context.envName.charAt(context.envName.length - 1) === \"*\") {\n      // It's one of the mathtools starred functions.\n      // Parse the optional alignment argument.\n      const parser = context.parser;\n      parser.consumeSpaces();\n\n      if (parser.fetch().text === \"[\") {\n        parser.consume();\n        parser.consumeSpaces();\n        colAlign = parser.fetch().text;\n\n        if (\"lcr\".indexOf(colAlign) === -1) {\n          throw new src_ParseError(\"Expected l or c or r\", parser.nextToken);\n        }\n\n        parser.consume();\n        parser.consumeSpaces();\n        parser.expect(\"]\");\n        parser.consume();\n        payload.cols = [{\n          type: \"align\",\n          align: colAlign\n        }];\n      }\n    }\n\n    const res = parseArray(context.parser, payload, dCellStyle(context.envName)); // Populate cols with the correct number of column alignment specs.\n\n    const numCols = Math.max(0, ...res.body.map(row => row.length));\n    res.cols = new Array(numCols).fill({\n      type: \"align\",\n      align: colAlign\n    });\n    return delimiters ? {\n      type: \"leftright\",\n      mode: context.mode,\n      body: [res],\n      left: delimiters[0],\n      right: delimiters[1],\n      rightColor: undefined // \\right uninfluenced by \\color in array\n\n    } : res;\n  },\n\n  htmlBuilder: array_htmlBuilder,\n  mathmlBuilder: array_mathmlBuilder\n});\ndefineEnvironment({\n  type: \"array\",\n  names: [\"smallmatrix\"],\n  props: {\n    numArgs: 0\n  },\n\n  handler(context) {\n    const payload = {\n      arraystretch: 0.5\n    };\n    const res = parseArray(context.parser, payload, \"script\");\n    res.colSeparationType = \"small\";\n    return res;\n  },\n\n  htmlBuilder: array_htmlBuilder,\n  mathmlBuilder: array_mathmlBuilder\n});\ndefineEnvironment({\n  type: \"array\",\n  names: [\"subarray\"],\n  props: {\n    numArgs: 1\n  },\n\n  handler(context, args) {\n    // Parsing of {subarray} is similar to {array}\n    const symNode = checkSymbolNodeType(args[0]);\n    const colalign = symNode ? [args[0]] : assertNodeType(args[0], \"ordgroup\").body;\n    const cols = colalign.map(function (nde) {\n      const node = assertSymbolNodeType(nde);\n      const ca = node.text; // {subarray} only recognizes \"l\" & \"c\"\n\n      if (\"lc\".indexOf(ca) !== -1) {\n        return {\n          type: \"align\",\n          align: ca\n        };\n      }\n\n      throw new src_ParseError(\"Unknown column alignment: \" + ca, nde);\n    });\n\n    if (cols.length > 1) {\n      throw new src_ParseError(\"{subarray} can contain only one column\");\n    }\n\n    let res = {\n      cols,\n      hskipBeforeAndAfter: false,\n      arraystretch: 0.5\n    };\n    res = parseArray(context.parser, res, \"script\");\n\n    if (res.body.length > 0 && res.body[0].length > 1) {\n      throw new src_ParseError(\"{subarray} can contain only one column\");\n    }\n\n    return res;\n  },\n\n  htmlBuilder: array_htmlBuilder,\n  mathmlBuilder: array_mathmlBuilder\n}); // A cases environment (in amsmath.sty) is almost equivalent to\n// \\def\\arraystretch{1.2}%\n// \\left\\{\\begin{array}{@{}l@{\\quad}l@{}}  \\end{array}\\right.\n// {dcases} is a {cases} environment where cells are set in \\displaystyle,\n// as defined in mathtools.sty.\n// {rcases} is another mathtools environment. It's brace is on the right side.\n\ndefineEnvironment({\n  type: \"array\",\n  names: [\"cases\", \"dcases\", \"rcases\", \"drcases\"],\n  props: {\n    numArgs: 0\n  },\n\n  handler(context) {\n    const payload = {\n      arraystretch: 1.2,\n      cols: [{\n        type: \"align\",\n        align: \"l\",\n        pregap: 0,\n        // TODO(kevinb) get the current style.\n        // For now we use the metrics for TEXT style which is what we were\n        // doing before.  Before attempting to get the current style we\n        // should look at TeX's behavior especially for \\over and matrices.\n        postgap: 1.0\n        /* 1em quad */\n\n      }, {\n        type: \"align\",\n        align: \"l\",\n        pregap: 0,\n        postgap: 0\n      }]\n    };\n    const res = parseArray(context.parser, payload, dCellStyle(context.envName));\n    return {\n      type: \"leftright\",\n      mode: context.mode,\n      body: [res],\n      left: context.envName.indexOf(\"r\") > -1 ? \".\" : \"\\\\{\",\n      right: context.envName.indexOf(\"r\") > -1 ? \"\\\\}\" : \".\",\n      rightColor: undefined\n    };\n  },\n\n  htmlBuilder: array_htmlBuilder,\n  mathmlBuilder: array_mathmlBuilder\n}); // In the align environment, one uses ampersands, &, to specify number of\n// columns in each row, and to locate spacing between each column.\n// align gets automatic numbering. align* and aligned do not.\n// The alignedat environment can be used in math mode.\n// Note that we assume \\nomallineskiplimit to be zero,\n// so that \\strut@ is the same as \\strut.\n\ndefineEnvironment({\n  type: \"array\",\n  names: [\"align\", \"align*\", \"aligned\", \"split\"],\n  props: {\n    numArgs: 0\n  },\n  handler: alignedHandler,\n  htmlBuilder: array_htmlBuilder,\n  mathmlBuilder: array_mathmlBuilder\n}); // A gathered environment is like an array environment with one centered\n// column, but where rows are considered lines so get \\jot line spacing\n// and contents are set in \\displaystyle.\n\ndefineEnvironment({\n  type: \"array\",\n  names: [\"gathered\", \"gather\", \"gather*\"],\n  props: {\n    numArgs: 0\n  },\n\n  handler(context) {\n    if (utils.contains([\"gather\", \"gather*\"], context.envName)) {\n      validateAmsEnvironmentContext(context);\n    }\n\n    const res = {\n      cols: [{\n        type: \"align\",\n        align: \"c\"\n      }],\n      addJot: true,\n      colSeparationType: \"gather\",\n      autoTag: getAutoTag(context.envName),\n      emptySingleRow: true,\n      leqno: context.parser.settings.leqno\n    };\n    return parseArray(context.parser, res, \"display\");\n  },\n\n  htmlBuilder: array_htmlBuilder,\n  mathmlBuilder: array_mathmlBuilder\n}); // alignat environment is like an align environment, but one must explicitly\n// specify maximum number of columns in each row, and can adjust spacing between\n// each columns.\n\ndefineEnvironment({\n  type: \"array\",\n  names: [\"alignat\", \"alignat*\", \"alignedat\"],\n  props: {\n    numArgs: 1\n  },\n  handler: alignedHandler,\n  htmlBuilder: array_htmlBuilder,\n  mathmlBuilder: array_mathmlBuilder\n});\ndefineEnvironment({\n  type: \"array\",\n  names: [\"equation\", \"equation*\"],\n  props: {\n    numArgs: 0\n  },\n\n  handler(context) {\n    validateAmsEnvironmentContext(context);\n    const res = {\n      autoTag: getAutoTag(context.envName),\n      emptySingleRow: true,\n      singleRow: true,\n      maxNumCols: 1,\n      leqno: context.parser.settings.leqno\n    };\n    return parseArray(context.parser, res, \"display\");\n  },\n\n  htmlBuilder: array_htmlBuilder,\n  mathmlBuilder: array_mathmlBuilder\n});\ndefineEnvironment({\n  type: \"array\",\n  names: [\"CD\"],\n  props: {\n    numArgs: 0\n  },\n\n  handler(context) {\n    validateAmsEnvironmentContext(context);\n    return parseCD(context.parser);\n  },\n\n  htmlBuilder: array_htmlBuilder,\n  mathmlBuilder: array_mathmlBuilder\n});\ndefineMacro(\"\\\\nonumber\", \"\\\\gdef\\\\@eqnsw{0}\");\ndefineMacro(\"\\\\notag\", \"\\\\nonumber\"); // Catch \\hline outside array environment\n\ndefineFunction({\n  type: \"text\",\n  // Doesn't matter what this is.\n  names: [\"\\\\hline\", \"\\\\hdashline\"],\n  props: {\n    numArgs: 0,\n    allowedInText: true,\n    allowedInMath: true\n  },\n\n  handler(context, args) {\n    throw new src_ParseError(context.funcName + \" valid only within array environment\");\n  }\n\n});\n;// CONCATENATED MODULE: ./src/environments.js\n\nconst environments = _environments;\n/* harmony default export */ var src_environments = (environments); // All environment definitions should be imported below\n\n\n;// CONCATENATED MODULE: ./src/functions/environment.js\n\n\n\n // Environment delimiters. HTML/MathML rendering is defined in the corresponding\n// defineEnvironment definitions.\n\ndefineFunction({\n  type: \"environment\",\n  names: [\"\\\\begin\", \"\\\\end\"],\n  props: {\n    numArgs: 1,\n    argTypes: [\"text\"]\n  },\n\n  handler(_ref, args) {\n    let {\n      parser,\n      funcName\n    } = _ref;\n    const nameGroup = args[0];\n\n    if (nameGroup.type !== \"ordgroup\") {\n      throw new src_ParseError(\"Invalid environment name\", nameGroup);\n    }\n\n    let envName = \"\";\n\n    for (let i = 0; i < nameGroup.body.length; ++i) {\n      envName += assertNodeType(nameGroup.body[i], \"textord\").text;\n    }\n\n    if (funcName === \"\\\\begin\") {\n      // begin...end is similar to left...right\n      if (!src_environments.hasOwnProperty(envName)) {\n        throw new src_ParseError(\"No such environment: \" + envName, nameGroup);\n      } // Build the environment object. Arguments and other information will\n      // be made available to the begin and end methods using properties.\n\n\n      const env = src_environments[envName];\n      const {\n        args,\n        optArgs\n      } = parser.parseArguments(\"\\\\begin{\" + envName + \"}\", env);\n      const context = {\n        mode: parser.mode,\n        envName,\n        parser\n      };\n      const result = env.handler(context, args, optArgs);\n      parser.expect(\"\\\\end\", false);\n      const endNameToken = parser.nextToken;\n      const end = assertNodeType(parser.parseFunction(), \"environment\");\n\n      if (end.name !== envName) {\n        throw new src_ParseError(\"Mismatch: \\\\begin{\" + envName + \"} matched by \\\\end{\" + end.name + \"}\", endNameToken);\n      } // $FlowFixMe, \"environment\" handler returns an environment ParseNode\n\n\n      return result;\n    }\n\n    return {\n      type: \"environment\",\n      mode: parser.mode,\n      name: envName,\n      nameGroup\n    };\n  }\n\n});\n;// CONCATENATED MODULE: ./src/functions/font.js\n// TODO(kevinb): implement \\\\sl and \\\\sc\n\n\n\n\n\n\nconst font_htmlBuilder = (group, options) => {\n  const font = group.font;\n  const newOptions = options.withFont(font);\n  return buildGroup(group.body, newOptions);\n};\n\nconst font_mathmlBuilder = (group, options) => {\n  const font = group.font;\n  const newOptions = options.withFont(font);\n  return buildMathML_buildGroup(group.body, newOptions);\n};\n\nconst fontAliases = {\n  \"\\\\Bbb\": \"\\\\mathbb\",\n  \"\\\\bold\": \"\\\\mathbf\",\n  \"\\\\frak\": \"\\\\mathfrak\",\n  \"\\\\bm\": \"\\\\boldsymbol\"\n};\ndefineFunction({\n  type: \"font\",\n  names: [// styles, except \\boldsymbol defined below\n  \"\\\\mathrm\", \"\\\\mathit\", \"\\\\mathbf\", \"\\\\mathnormal\", // families\n  \"\\\\mathbb\", \"\\\\mathcal\", \"\\\\mathfrak\", \"\\\\mathscr\", \"\\\\mathsf\", \"\\\\mathtt\", // aliases, except \\bm defined below\n  \"\\\\Bbb\", \"\\\\bold\", \"\\\\frak\"],\n  props: {\n    numArgs: 1,\n    allowedInArgument: true\n  },\n  handler: (_ref, args) => {\n    let {\n      parser,\n      funcName\n    } = _ref;\n    const body = normalizeArgument(args[0]);\n    let func = funcName;\n\n    if (func in fontAliases) {\n      func = fontAliases[func];\n    }\n\n    return {\n      type: \"font\",\n      mode: parser.mode,\n      font: func.slice(1),\n      body\n    };\n  },\n  htmlBuilder: font_htmlBuilder,\n  mathmlBuilder: font_mathmlBuilder\n});\ndefineFunction({\n  type: \"mclass\",\n  names: [\"\\\\boldsymbol\", \"\\\\bm\"],\n  props: {\n    numArgs: 1\n  },\n  handler: (_ref2, args) => {\n    let {\n      parser\n    } = _ref2;\n    const body = args[0];\n    const isCharacterBox = utils.isCharacterBox(body); // amsbsy.sty's \\boldsymbol uses \\binrel spacing to inherit the\n    // argument's bin|rel|ord status\n\n    return {\n      type: \"mclass\",\n      mode: parser.mode,\n      mclass: binrelClass(body),\n      body: [{\n        type: \"font\",\n        mode: parser.mode,\n        font: \"boldsymbol\",\n        body\n      }],\n      isCharacterBox: isCharacterBox\n    };\n  }\n}); // Old font changing functions\n\ndefineFunction({\n  type: \"font\",\n  names: [\"\\\\rm\", \"\\\\sf\", \"\\\\tt\", \"\\\\bf\", \"\\\\it\", \"\\\\cal\"],\n  props: {\n    numArgs: 0,\n    allowedInText: true\n  },\n  handler: (_ref3, args) => {\n    let {\n      parser,\n      funcName,\n      breakOnTokenText\n    } = _ref3;\n    const {\n      mode\n    } = parser;\n    const body = parser.parseExpression(true, breakOnTokenText);\n    const style = \"math\" + funcName.slice(1);\n    return {\n      type: \"font\",\n      mode: mode,\n      font: style,\n      body: {\n        type: \"ordgroup\",\n        mode: parser.mode,\n        body\n      }\n    };\n  },\n  htmlBuilder: font_htmlBuilder,\n  mathmlBuilder: font_mathmlBuilder\n});\n;// CONCATENATED MODULE: ./src/functions/genfrac.js\n\n\n\n\n\n\n\n\n\n\n\nconst adjustStyle = (size, originalStyle) => {\n  // Figure out what style this fraction should be in based on the\n  // function used\n  let style = originalStyle;\n\n  if (size === \"display\") {\n    // Get display style as a default.\n    // If incoming style is sub/sup, use style.text() to get correct size.\n    style = style.id >= src_Style.SCRIPT.id ? style.text() : src_Style.DISPLAY;\n  } else if (size === \"text\" && style.size === src_Style.DISPLAY.size) {\n    // We're in a \\tfrac but incoming style is displaystyle, so:\n    style = src_Style.TEXT;\n  } else if (size === \"script\") {\n    style = src_Style.SCRIPT;\n  } else if (size === \"scriptscript\") {\n    style = src_Style.SCRIPTSCRIPT;\n  }\n\n  return style;\n};\n\nconst genfrac_htmlBuilder = (group, options) => {\n  // Fractions are handled in the TeXbook on pages 444-445, rules 15(a-e).\n  const style = adjustStyle(group.size, options.style);\n  const nstyle = style.fracNum();\n  const dstyle = style.fracDen();\n  let newOptions;\n  newOptions = options.havingStyle(nstyle);\n  const numerm = buildGroup(group.numer, newOptions, options);\n\n  if (group.continued) {\n    // \\cfrac inserts a \\strut into the numerator.\n    // Get \\strut dimensions from TeXbook page 353.\n    const hStrut = 8.5 / options.fontMetrics().ptPerEm;\n    const dStrut = 3.5 / options.fontMetrics().ptPerEm;\n    numerm.height = numerm.height < hStrut ? hStrut : numerm.height;\n    numerm.depth = numerm.depth < dStrut ? dStrut : numerm.depth;\n  }\n\n  newOptions = options.havingStyle(dstyle);\n  const denomm = buildGroup(group.denom, newOptions, options);\n  let rule;\n  let ruleWidth;\n  let ruleSpacing;\n\n  if (group.hasBarLine) {\n    if (group.barSize) {\n      ruleWidth = calculateSize(group.barSize, options);\n      rule = buildCommon.makeLineSpan(\"frac-line\", options, ruleWidth);\n    } else {\n      rule = buildCommon.makeLineSpan(\"frac-line\", options);\n    }\n\n    ruleWidth = rule.height;\n    ruleSpacing = rule.height;\n  } else {\n    rule = null;\n    ruleWidth = 0;\n    ruleSpacing = options.fontMetrics().defaultRuleThickness;\n  } // Rule 15b\n\n\n  let numShift;\n  let clearance;\n  let denomShift;\n\n  if (style.size === src_Style.DISPLAY.size || group.size === \"display\") {\n    numShift = options.fontMetrics().num1;\n\n    if (ruleWidth > 0) {\n      clearance = 3 * ruleSpacing;\n    } else {\n      clearance = 7 * ruleSpacing;\n    }\n\n    denomShift = options.fontMetrics().denom1;\n  } else {\n    if (ruleWidth > 0) {\n      numShift = options.fontMetrics().num2;\n      clearance = ruleSpacing;\n    } else {\n      numShift = options.fontMetrics().num3;\n      clearance = 3 * ruleSpacing;\n    }\n\n    denomShift = options.fontMetrics().denom2;\n  }\n\n  let frac;\n\n  if (!rule) {\n    // Rule 15c\n    const candidateClearance = numShift - numerm.depth - (denomm.height - denomShift);\n\n    if (candidateClearance < clearance) {\n      numShift += 0.5 * (clearance - candidateClearance);\n      denomShift += 0.5 * (clearance - candidateClearance);\n    }\n\n    frac = buildCommon.makeVList({\n      positionType: \"individualShift\",\n      children: [{\n        type: \"elem\",\n        elem: denomm,\n        shift: denomShift\n      }, {\n        type: \"elem\",\n        elem: numerm,\n        shift: -numShift\n      }]\n    }, options);\n  } else {\n    // Rule 15d\n    const axisHeight = options.fontMetrics().axisHeight;\n\n    if (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth) < clearance) {\n      numShift += clearance - (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth));\n    }\n\n    if (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift) < clearance) {\n      denomShift += clearance - (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift));\n    }\n\n    const midShift = -(axisHeight - 0.5 * ruleWidth);\n    frac = buildCommon.makeVList({\n      positionType: \"individualShift\",\n      children: [{\n        type: \"elem\",\n        elem: denomm,\n        shift: denomShift\n      }, {\n        type: \"elem\",\n        elem: rule,\n        shift: midShift\n      }, {\n        type: \"elem\",\n        elem: numerm,\n        shift: -numShift\n      }]\n    }, options);\n  } // Since we manually change the style sometimes (with \\dfrac or \\tfrac),\n  // account for the possible size change here.\n\n\n  newOptions = options.havingStyle(style);\n  frac.height *= newOptions.sizeMultiplier / options.sizeMultiplier;\n  frac.depth *= newOptions.sizeMultiplier / options.sizeMultiplier; // Rule 15e\n\n  let delimSize;\n\n  if (style.size === src_Style.DISPLAY.size) {\n    delimSize = options.fontMetrics().delim1;\n  } else if (style.size === src_Style.SCRIPTSCRIPT.size) {\n    delimSize = options.havingStyle(src_Style.SCRIPT).fontMetrics().delim2;\n  } else {\n    delimSize = options.fontMetrics().delim2;\n  }\n\n  let leftDelim;\n  let rightDelim;\n\n  if (group.leftDelim == null) {\n    leftDelim = makeNullDelimiter(options, [\"mopen\"]);\n  } else {\n    leftDelim = delimiter.customSizedDelim(group.leftDelim, delimSize, true, options.havingStyle(style), group.mode, [\"mopen\"]);\n  }\n\n  if (group.continued) {\n    rightDelim = buildCommon.makeSpan([]); // zero width for \\cfrac\n  } else if (group.rightDelim == null) {\n    rightDelim = makeNullDelimiter(options, [\"mclose\"]);\n  } else {\n    rightDelim = delimiter.customSizedDelim(group.rightDelim, delimSize, true, options.havingStyle(style), group.mode, [\"mclose\"]);\n  }\n\n  return buildCommon.makeSpan([\"mord\"].concat(newOptions.sizingClasses(options)), [leftDelim, buildCommon.makeSpan([\"mfrac\"], [frac]), rightDelim], options);\n};\n\nconst genfrac_mathmlBuilder = (group, options) => {\n  let node = new mathMLTree.MathNode(\"mfrac\", [buildMathML_buildGroup(group.numer, options), buildMathML_buildGroup(group.denom, options)]);\n\n  if (!group.hasBarLine) {\n    node.setAttribute(\"linethickness\", \"0px\");\n  } else if (group.barSize) {\n    const ruleWidth = calculateSize(group.barSize, options);\n    node.setAttribute(\"linethickness\", makeEm(ruleWidth));\n  }\n\n  const style = adjustStyle(group.size, options.style);\n\n  if (style.size !== options.style.size) {\n    node = new mathMLTree.MathNode(\"mstyle\", [node]);\n    const isDisplay = style.size === src_Style.DISPLAY.size ? \"true\" : \"false\";\n    node.setAttribute(\"displaystyle\", isDisplay);\n    node.setAttribute(\"scriptlevel\", \"0\");\n  }\n\n  if (group.leftDelim != null || group.rightDelim != null) {\n    const withDelims = [];\n\n    if (group.leftDelim != null) {\n      const leftOp = new mathMLTree.MathNode(\"mo\", [new mathMLTree.TextNode(group.leftDelim.replace(\"\\\\\", \"\"))]);\n      leftOp.setAttribute(\"fence\", \"true\");\n      withDelims.push(leftOp);\n    }\n\n    withDelims.push(node);\n\n    if (group.rightDelim != null) {\n      const rightOp = new mathMLTree.MathNode(\"mo\", [new mathMLTree.TextNode(group.rightDelim.replace(\"\\\\\", \"\"))]);\n      rightOp.setAttribute(\"fence\", \"true\");\n      withDelims.push(rightOp);\n    }\n\n    return makeRow(withDelims);\n  }\n\n  return node;\n};\n\ndefineFunction({\n  type: \"genfrac\",\n  names: [\"\\\\dfrac\", \"\\\\frac\", \"\\\\tfrac\", \"\\\\dbinom\", \"\\\\binom\", \"\\\\tbinom\", \"\\\\\\\\atopfrac\", // cant be entered directly\n  \"\\\\\\\\bracefrac\", \"\\\\\\\\brackfrac\" // ditto\n  ],\n  props: {\n    numArgs: 2,\n    allowedInArgument: true\n  },\n  handler: (_ref, args) => {\n    let {\n      parser,\n      funcName\n    } = _ref;\n    const numer = args[0];\n    const denom = args[1];\n    let hasBarLine;\n    let leftDelim = null;\n    let rightDelim = null;\n    let size = \"auto\";\n\n    switch (funcName) {\n      case \"\\\\dfrac\":\n      case \"\\\\frac\":\n      case \"\\\\tfrac\":\n        hasBarLine = true;\n        break;\n\n      case \"\\\\\\\\atopfrac\":\n        hasBarLine = false;\n        break;\n\n      case \"\\\\dbinom\":\n      case \"\\\\binom\":\n      case \"\\\\tbinom\":\n        hasBarLine = false;\n        leftDelim = \"(\";\n        rightDelim = \")\";\n        break;\n\n      case \"\\\\\\\\bracefrac\":\n        hasBarLine = false;\n        leftDelim = \"\\\\{\";\n        rightDelim = \"\\\\}\";\n        break;\n\n      case \"\\\\\\\\brackfrac\":\n        hasBarLine = false;\n        leftDelim = \"[\";\n        rightDelim = \"]\";\n        break;\n\n      default:\n        throw new Error(\"Unrecognized genfrac command\");\n    }\n\n    switch (funcName) {\n      case \"\\\\dfrac\":\n      case \"\\\\dbinom\":\n        size = \"display\";\n        break;\n\n      case \"\\\\tfrac\":\n      case \"\\\\tbinom\":\n        size = \"text\";\n        break;\n    }\n\n    return {\n      type: \"genfrac\",\n      mode: parser.mode,\n      continued: false,\n      numer,\n      denom,\n      hasBarLine,\n      leftDelim,\n      rightDelim,\n      size,\n      barSize: null\n    };\n  },\n  htmlBuilder: genfrac_htmlBuilder,\n  mathmlBuilder: genfrac_mathmlBuilder\n});\ndefineFunction({\n  type: \"genfrac\",\n  names: [\"\\\\cfrac\"],\n  props: {\n    numArgs: 2\n  },\n  handler: (_ref2, args) => {\n    let {\n      parser,\n      funcName\n    } = _ref2;\n    const numer = args[0];\n    const denom = args[1];\n    return {\n      type: \"genfrac\",\n      mode: parser.mode,\n      continued: true,\n      numer,\n      denom,\n      hasBarLine: true,\n      leftDelim: null,\n      rightDelim: null,\n      size: \"display\",\n      barSize: null\n    };\n  }\n}); // Infix generalized fractions -- these are not rendered directly, but replaced\n// immediately by one of the variants above.\n\ndefineFunction({\n  type: \"infix\",\n  names: [\"\\\\over\", \"\\\\choose\", \"\\\\atop\", \"\\\\brace\", \"\\\\brack\"],\n  props: {\n    numArgs: 0,\n    infix: true\n  },\n\n  handler(_ref3) {\n    let {\n      parser,\n      funcName,\n      token\n    } = _ref3;\n    let replaceWith;\n\n    switch (funcName) {\n      case \"\\\\over\":\n        replaceWith = \"\\\\frac\";\n        break;\n\n      case \"\\\\choose\":\n        replaceWith = \"\\\\binom\";\n        break;\n\n      case \"\\\\atop\":\n        replaceWith = \"\\\\\\\\atopfrac\";\n        break;\n\n      case \"\\\\brace\":\n        replaceWith = \"\\\\\\\\bracefrac\";\n        break;\n\n      case \"\\\\brack\":\n        replaceWith = \"\\\\\\\\brackfrac\";\n        break;\n\n      default:\n        throw new Error(\"Unrecognized infix genfrac command\");\n    }\n\n    return {\n      type: \"infix\",\n      mode: parser.mode,\n      replaceWith,\n      token\n    };\n  }\n\n});\nconst stylArray = [\"display\", \"text\", \"script\", \"scriptscript\"];\n\nconst delimFromValue = function (delimString) {\n  let delim = null;\n\n  if (delimString.length > 0) {\n    delim = delimString;\n    delim = delim === \".\" ? null : delim;\n  }\n\n  return delim;\n};\n\ndefineFunction({\n  type: \"genfrac\",\n  names: [\"\\\\genfrac\"],\n  props: {\n    numArgs: 6,\n    allowedInArgument: true,\n    argTypes: [\"math\", \"math\", \"size\", \"text\", \"math\", \"math\"]\n  },\n\n  handler(_ref4, args) {\n    let {\n      parser\n    } = _ref4;\n    const numer = args[4];\n    const denom = args[5]; // Look into the parse nodes to get the desired delimiters.\n\n    const leftNode = normalizeArgument(args[0]);\n    const leftDelim = leftNode.type === \"atom\" && leftNode.family === \"open\" ? delimFromValue(leftNode.text) : null;\n    const rightNode = normalizeArgument(args[1]);\n    const rightDelim = rightNode.type === \"atom\" && rightNode.family === \"close\" ? delimFromValue(rightNode.text) : null;\n    const barNode = assertNodeType(args[2], \"size\");\n    let hasBarLine;\n    let barSize = null;\n\n    if (barNode.isBlank) {\n      // \\genfrac acts differently than \\above.\n      // \\genfrac treats an empty size group as a signal to use a\n      // standard bar size. \\above would see size = 0 and omit the bar.\n      hasBarLine = true;\n    } else {\n      barSize = barNode.value;\n      hasBarLine = barSize.number > 0;\n    } // Find out if we want displaystyle, textstyle, etc.\n\n\n    let size = \"auto\";\n    let styl = args[3];\n\n    if (styl.type === \"ordgroup\") {\n      if (styl.body.length > 0) {\n        const textOrd = assertNodeType(styl.body[0], \"textord\");\n        size = stylArray[Number(textOrd.text)];\n      }\n    } else {\n      styl = assertNodeType(styl, \"textord\");\n      size = stylArray[Number(styl.text)];\n    }\n\n    return {\n      type: \"genfrac\",\n      mode: parser.mode,\n      numer,\n      denom,\n      continued: false,\n      hasBarLine,\n      barSize,\n      leftDelim,\n      rightDelim,\n      size\n    };\n  },\n\n  htmlBuilder: genfrac_htmlBuilder,\n  mathmlBuilder: genfrac_mathmlBuilder\n}); // \\above is an infix fraction that also defines a fraction bar size.\n\ndefineFunction({\n  type: \"infix\",\n  names: [\"\\\\above\"],\n  props: {\n    numArgs: 1,\n    argTypes: [\"size\"],\n    infix: true\n  },\n\n  handler(_ref5, args) {\n    let {\n      parser,\n      funcName,\n      token\n    } = _ref5;\n    return {\n      type: \"infix\",\n      mode: parser.mode,\n      replaceWith: \"\\\\\\\\abovefrac\",\n      size: assertNodeType(args[0], \"size\").value,\n      token\n    };\n  }\n\n});\ndefineFunction({\n  type: \"genfrac\",\n  names: [\"\\\\\\\\abovefrac\"],\n  props: {\n    numArgs: 3,\n    argTypes: [\"math\", \"size\", \"math\"]\n  },\n  handler: (_ref6, args) => {\n    let {\n      parser,\n      funcName\n    } = _ref6;\n    const numer = args[0];\n    const barSize = assert(assertNodeType(args[1], \"infix\").size);\n    const denom = args[2];\n    const hasBarLine = barSize.number > 0;\n    return {\n      type: \"genfrac\",\n      mode: parser.mode,\n      numer,\n      denom,\n      continued: false,\n      hasBarLine,\n      barSize,\n      leftDelim: null,\n      rightDelim: null,\n      size: \"auto\"\n    };\n  },\n  htmlBuilder: genfrac_htmlBuilder,\n  mathmlBuilder: genfrac_mathmlBuilder\n});\n;// CONCATENATED MODULE: ./src/functions/horizBrace.js\n\n\n\n\n\n\n\n\n// NOTE: Unlike most `htmlBuilder`s, this one handles not only \"horizBrace\", but\n// also \"supsub\" since an over/underbrace can affect super/subscripting.\nconst horizBrace_htmlBuilder = (grp, options) => {\n  const style = options.style; // Pull out the `ParseNode<\"horizBrace\">` if `grp` is a \"supsub\" node.\n\n  let supSubGroup;\n  let group;\n\n  if (grp.type === \"supsub\") {\n    // Ref: LaTeX source2e: }}}}\\limits}\n    // i.e. LaTeX treats the brace similar to an op and passes it\n    // with \\limits, so we need to assign supsub style.\n    supSubGroup = grp.sup ? buildGroup(grp.sup, options.havingStyle(style.sup()), options) : buildGroup(grp.sub, options.havingStyle(style.sub()), options);\n    group = assertNodeType(grp.base, \"horizBrace\");\n  } else {\n    group = assertNodeType(grp, \"horizBrace\");\n  } // Build the base group\n\n\n  const body = buildGroup(group.base, options.havingBaseStyle(src_Style.DISPLAY)); // Create the stretchy element\n\n  const braceBody = stretchy.svgSpan(group, options); // Generate the vlist, with the appropriate kerns        \n  // This first vlist contains the content and the brace:   equation\n\n  let vlist;\n\n  if (group.isOver) {\n    vlist = buildCommon.makeVList({\n      positionType: \"firstBaseline\",\n      children: [{\n        type: \"elem\",\n        elem: body\n      }, {\n        type: \"kern\",\n        size: 0.1\n      }, {\n        type: \"elem\",\n        elem: braceBody\n      }]\n    }, options); // $FlowFixMe: Replace this with passing \"svg-align\" into makeVList.\n\n    vlist.children[0].children[0].children[1].classes.push(\"svg-align\");\n  } else {\n    vlist = buildCommon.makeVList({\n      positionType: \"bottom\",\n      positionData: body.depth + 0.1 + braceBody.height,\n      children: [{\n        type: \"elem\",\n        elem: braceBody\n      }, {\n        type: \"kern\",\n        size: 0.1\n      }, {\n        type: \"elem\",\n        elem: body\n      }]\n    }, options); // $FlowFixMe: Replace this with passing \"svg-align\" into makeVList.\n\n    vlist.children[0].children[0].children[0].classes.push(\"svg-align\");\n  }\n\n  if (supSubGroup) {\n    // To write the supsub, wrap the first vlist in another vlist:\n    // They can't all go in the same vlist, because the note might be\n    // wider than the equation. We want the equation to control the\n    // brace width.\n    //      note          long note           long note\n    //      or         not    \n    //    equation           eqn                 eqn\n    const vSpan = buildCommon.makeSpan([\"mord\", group.isOver ? \"mover\" : \"munder\"], [vlist], options);\n\n    if (group.isOver) {\n      vlist = buildCommon.makeVList({\n        positionType: \"firstBaseline\",\n        children: [{\n          type: \"elem\",\n          elem: vSpan\n        }, {\n          type: \"kern\",\n          size: 0.2\n        }, {\n          type: \"elem\",\n          elem: supSubGroup\n        }]\n      }, options);\n    } else {\n      vlist = buildCommon.makeVList({\n        positionType: \"bottom\",\n        positionData: vSpan.depth + 0.2 + supSubGroup.height + supSubGroup.depth,\n        children: [{\n          type: \"elem\",\n          elem: supSubGroup\n        }, {\n          type: \"kern\",\n          size: 0.2\n        }, {\n          type: \"elem\",\n          elem: vSpan\n        }]\n      }, options);\n    }\n  }\n\n  return buildCommon.makeSpan([\"mord\", group.isOver ? \"mover\" : \"munder\"], [vlist], options);\n};\n\nconst horizBrace_mathmlBuilder = (group, options) => {\n  const accentNode = stretchy.mathMLnode(group.label);\n  return new mathMLTree.MathNode(group.isOver ? \"mover\" : \"munder\", [buildMathML_buildGroup(group.base, options), accentNode]);\n}; // Horizontal stretchy braces\n\n\ndefineFunction({\n  type: \"horizBrace\",\n  names: [\"\\\\overbrace\", \"\\\\underbrace\"],\n  props: {\n    numArgs: 1\n  },\n\n  handler(_ref, args) {\n    let {\n      parser,\n      funcName\n    } = _ref;\n    return {\n      type: \"horizBrace\",\n      mode: parser.mode,\n      label: funcName,\n      isOver: /^\\\\over/.test(funcName),\n      base: args[0]\n    };\n  },\n\n  htmlBuilder: horizBrace_htmlBuilder,\n  mathmlBuilder: horizBrace_mathmlBuilder\n});\n;// CONCATENATED MODULE: ./src/functions/href.js\n\n\n\n\n\n\ndefineFunction({\n  type: \"href\",\n  names: [\"\\\\href\"],\n  props: {\n    numArgs: 2,\n    argTypes: [\"url\", \"original\"],\n    allowedInText: true\n  },\n  handler: (_ref, args) => {\n    let {\n      parser\n    } = _ref;\n    const body = args[1];\n    const href = assertNodeType(args[0], \"url\").url;\n\n    if (!parser.settings.isTrusted({\n      command: \"\\\\href\",\n      url: href\n    })) {\n      return parser.formatUnsupportedCmd(\"\\\\href\");\n    }\n\n    return {\n      type: \"href\",\n      mode: parser.mode,\n      href,\n      body: ordargument(body)\n    };\n  },\n  htmlBuilder: (group, options) => {\n    const elements = buildExpression(group.body, options, false);\n    return buildCommon.makeAnchor(group.href, [], elements, options);\n  },\n  mathmlBuilder: (group, options) => {\n    let math = buildExpressionRow(group.body, options);\n\n    if (!(math instanceof MathNode)) {\n      math = new MathNode(\"mrow\", [math]);\n    }\n\n    math.setAttribute(\"href\", group.href);\n    return math;\n  }\n});\ndefineFunction({\n  type: \"href\",\n  names: [\"\\\\url\"],\n  props: {\n    numArgs: 1,\n    argTypes: [\"url\"],\n    allowedInText: true\n  },\n  handler: (_ref2, args) => {\n    let {\n      parser\n    } = _ref2;\n    const href = assertNodeType(args[0], \"url\").url;\n\n    if (!parser.settings.isTrusted({\n      command: \"\\\\url\",\n      url: href\n    })) {\n      return parser.formatUnsupportedCmd(\"\\\\url\");\n    }\n\n    const chars = [];\n\n    for (let i = 0; i < href.length; i++) {\n      let c = href[i];\n\n      if (c === \"~\") {\n        c = \"\\\\textasciitilde\";\n      }\n\n      chars.push({\n        type: \"textord\",\n        mode: \"text\",\n        text: c\n      });\n    }\n\n    const body = {\n      type: \"text\",\n      mode: parser.mode,\n      font: \"\\\\texttt\",\n      body: chars\n    };\n    return {\n      type: \"href\",\n      mode: parser.mode,\n      href,\n      body: ordargument(body)\n    };\n  }\n});\n;// CONCATENATED MODULE: ./src/functions/hbox.js\n\n\n\n\n // \\hbox is provided for compatibility with LaTeX \\vcenter.\n// In LaTeX, \\vcenter can act only on a box, as in\n// \\vcenter{\\hbox{$\\frac{a+b}{\\dfrac{c}{d}}$}}\n// This function by itself doesn't do anything but prevent a soft line break.\n\ndefineFunction({\n  type: \"hbox\",\n  names: [\"\\\\hbox\"],\n  props: {\n    numArgs: 1,\n    argTypes: [\"text\"],\n    allowedInText: true,\n    primitive: true\n  },\n\n  handler(_ref, args) {\n    let {\n      parser\n    } = _ref;\n    return {\n      type: \"hbox\",\n      mode: parser.mode,\n      body: ordargument(args[0])\n    };\n  },\n\n  htmlBuilder(group, options) {\n    const elements = buildExpression(group.body, options, false);\n    return buildCommon.makeFragment(elements);\n  },\n\n  mathmlBuilder(group, options) {\n    return new mathMLTree.MathNode(\"mrow\", buildMathML_buildExpression(group.body, options));\n  }\n\n});\n;// CONCATENATED MODULE: ./src/functions/html.js\n\n\n\n\n\n\ndefineFunction({\n  type: \"html\",\n  names: [\"\\\\htmlClass\", \"\\\\htmlId\", \"\\\\htmlStyle\", \"\\\\htmlData\"],\n  props: {\n    numArgs: 2,\n    argTypes: [\"raw\", \"original\"],\n    allowedInText: true\n  },\n  handler: (_ref, args) => {\n    let {\n      parser,\n      funcName,\n      token\n    } = _ref;\n    const value = assertNodeType(args[0], \"raw\").string;\n    const body = args[1];\n\n    if (parser.settings.strict) {\n      parser.settings.reportNonstrict(\"htmlExtension\", \"HTML extension is disabled on strict mode\");\n    }\n\n    let trustContext;\n    const attributes = {};\n\n    switch (funcName) {\n      case \"\\\\htmlClass\":\n        attributes.class = value;\n        trustContext = {\n          command: \"\\\\htmlClass\",\n          class: value\n        };\n        break;\n\n      case \"\\\\htmlId\":\n        attributes.id = value;\n        trustContext = {\n          command: \"\\\\htmlId\",\n          id: value\n        };\n        break;\n\n      case \"\\\\htmlStyle\":\n        attributes.style = value;\n        trustContext = {\n          command: \"\\\\htmlStyle\",\n          style: value\n        };\n        break;\n\n      case \"\\\\htmlData\":\n        {\n          const data = value.split(\",\");\n\n          for (let i = 0; i < data.length; i++) {\n            const keyVal = data[i].split(\"=\");\n\n            if (keyVal.length !== 2) {\n              throw new src_ParseError(\"Error parsing key-value for \\\\htmlData\");\n            }\n\n            attributes[\"data-\" + keyVal[0].trim()] = keyVal[1].trim();\n          }\n\n          trustContext = {\n            command: \"\\\\htmlData\",\n            attributes\n          };\n          break;\n        }\n\n      default:\n        throw new Error(\"Unrecognized html command\");\n    }\n\n    if (!parser.settings.isTrusted(trustContext)) {\n      return parser.formatUnsupportedCmd(funcName);\n    }\n\n    return {\n      type: \"html\",\n      mode: parser.mode,\n      attributes,\n      body: ordargument(body)\n    };\n  },\n  htmlBuilder: (group, options) => {\n    const elements = buildExpression(group.body, options, false);\n    const classes = [\"enclosing\"];\n\n    if (group.attributes.class) {\n      classes.push(...group.attributes.class.trim().split(/\\s+/));\n    }\n\n    const span = buildCommon.makeSpan(classes, elements, options);\n\n    for (const attr in group.attributes) {\n      if (attr !== \"class\" && group.attributes.hasOwnProperty(attr)) {\n        span.setAttribute(attr, group.attributes[attr]);\n      }\n    }\n\n    return span;\n  },\n  mathmlBuilder: (group, options) => {\n    return buildExpressionRow(group.body, options);\n  }\n});\n;// CONCATENATED MODULE: ./src/functions/htmlmathml.js\n\n\n\n\ndefineFunction({\n  type: \"htmlmathml\",\n  names: [\"\\\\html@mathml\"],\n  props: {\n    numArgs: 2,\n    allowedInText: true\n  },\n  handler: (_ref, args) => {\n    let {\n      parser\n    } = _ref;\n    return {\n      type: \"htmlmathml\",\n      mode: parser.mode,\n      html: ordargument(args[0]),\n      mathml: ordargument(args[1])\n    };\n  },\n  htmlBuilder: (group, options) => {\n    const elements = buildExpression(group.html, options, false);\n    return buildCommon.makeFragment(elements);\n  },\n  mathmlBuilder: (group, options) => {\n    return buildExpressionRow(group.mathml, options);\n  }\n});\n;// CONCATENATED MODULE: ./src/functions/includegraphics.js\n\n\n\n\n\n\n\nconst sizeData = function (str) {\n  if (/^[-+]? *(\\d+(\\.\\d*)?|\\.\\d+)$/.test(str)) {\n    // str is a number with no unit specified.\n    // default unit is bp, per graphix package.\n    return {\n      number: +str,\n      unit: \"bp\"\n    };\n  } else {\n    const match = /([-+]?) *(\\d+(?:\\.\\d*)?|\\.\\d+) *([a-z]{2})/.exec(str);\n\n    if (!match) {\n      throw new src_ParseError(\"Invalid size: '\" + str + \"' in \\\\includegraphics\");\n    }\n\n    const data = {\n      number: +(match[1] + match[2]),\n      // sign + magnitude, cast to number\n      unit: match[3]\n    };\n\n    if (!validUnit(data)) {\n      throw new src_ParseError(\"Invalid unit: '\" + data.unit + \"' in \\\\includegraphics.\");\n    }\n\n    return data;\n  }\n};\n\ndefineFunction({\n  type: \"includegraphics\",\n  names: [\"\\\\includegraphics\"],\n  props: {\n    numArgs: 1,\n    numOptionalArgs: 1,\n    argTypes: [\"raw\", \"url\"],\n    allowedInText: false\n  },\n  handler: (_ref, args, optArgs) => {\n    let {\n      parser\n    } = _ref;\n    let width = {\n      number: 0,\n      unit: \"em\"\n    };\n    let height = {\n      number: 0.9,\n      unit: \"em\"\n    }; // sorta character sized.\n\n    let totalheight = {\n      number: 0,\n      unit: \"em\"\n    };\n    let alt = \"\";\n\n    if (optArgs[0]) {\n      const attributeStr = assertNodeType(optArgs[0], \"raw\").string; // Parser.js does not parse key/value pairs. We get a string.\n\n      const attributes = attributeStr.split(\",\");\n\n      for (let i = 0; i < attributes.length; i++) {\n        const keyVal = attributes[i].split(\"=\");\n\n        if (keyVal.length === 2) {\n          const str = keyVal[1].trim();\n\n          switch (keyVal[0].trim()) {\n            case \"alt\":\n              alt = str;\n              break;\n\n            case \"width\":\n              width = sizeData(str);\n              break;\n\n            case \"height\":\n              height = sizeData(str);\n              break;\n\n            case \"totalheight\":\n              totalheight = sizeData(str);\n              break;\n\n            default:\n              throw new src_ParseError(\"Invalid key: '\" + keyVal[0] + \"' in \\\\includegraphics.\");\n          }\n        }\n      }\n    }\n\n    const src = assertNodeType(args[0], \"url\").url;\n\n    if (alt === \"\") {\n      // No alt given. Use the file name. Strip away the path.\n      alt = src;\n      alt = alt.replace(/^.*[\\\\/]/, '');\n      alt = alt.substring(0, alt.lastIndexOf('.'));\n    }\n\n    if (!parser.settings.isTrusted({\n      command: \"\\\\includegraphics\",\n      url: src\n    })) {\n      return parser.formatUnsupportedCmd(\"\\\\includegraphics\");\n    }\n\n    return {\n      type: \"includegraphics\",\n      mode: parser.mode,\n      alt: alt,\n      width: width,\n      height: height,\n      totalheight: totalheight,\n      src: src\n    };\n  },\n  htmlBuilder: (group, options) => {\n    const height = calculateSize(group.height, options);\n    let depth = 0;\n\n    if (group.totalheight.number > 0) {\n      depth = calculateSize(group.totalheight, options) - height;\n    }\n\n    let width = 0;\n\n    if (group.width.number > 0) {\n      width = calculateSize(group.width, options);\n    }\n\n    const style = {\n      height: makeEm(height + depth)\n    };\n\n    if (width > 0) {\n      style.width = makeEm(width);\n    }\n\n    if (depth > 0) {\n      style.verticalAlign = makeEm(-depth);\n    }\n\n    const node = new Img(group.src, group.alt, style);\n    node.height = height;\n    node.depth = depth;\n    return node;\n  },\n  mathmlBuilder: (group, options) => {\n    const node = new mathMLTree.MathNode(\"mglyph\", []);\n    node.setAttribute(\"alt\", group.alt);\n    const height = calculateSize(group.height, options);\n    let depth = 0;\n\n    if (group.totalheight.number > 0) {\n      depth = calculateSize(group.totalheight, options) - height;\n      node.setAttribute(\"valign\", makeEm(-depth));\n    }\n\n    node.setAttribute(\"height\", makeEm(height + depth));\n\n    if (group.width.number > 0) {\n      const width = calculateSize(group.width, options);\n      node.setAttribute(\"width\", makeEm(width));\n    }\n\n    node.setAttribute(\"src\", group.src);\n    return node;\n  }\n});\n;// CONCATENATED MODULE: ./src/functions/kern.js\n// Horizontal spacing commands\n\n\n\n\n // TODO: \\hskip and \\mskip should support plus and minus in lengths\n\ndefineFunction({\n  type: \"kern\",\n  names: [\"\\\\kern\", \"\\\\mkern\", \"\\\\hskip\", \"\\\\mskip\"],\n  props: {\n    numArgs: 1,\n    argTypes: [\"size\"],\n    primitive: true,\n    allowedInText: true\n  },\n\n  handler(_ref, args) {\n    let {\n      parser,\n      funcName\n    } = _ref;\n    const size = assertNodeType(args[0], \"size\");\n\n    if (parser.settings.strict) {\n      const mathFunction = funcName[1] === 'm'; // \\mkern, \\mskip\n\n      const muUnit = size.value.unit === 'mu';\n\n      if (mathFunction) {\n        if (!muUnit) {\n          parser.settings.reportNonstrict(\"mathVsTextUnits\", \"LaTeX's \" + funcName + \" supports only mu units, \" + (\"not \" + size.value.unit + \" units\"));\n        }\n\n        if (parser.mode !== \"math\") {\n          parser.settings.reportNonstrict(\"mathVsTextUnits\", \"LaTeX's \" + funcName + \" works only in math mode\");\n        }\n      } else {\n        // !mathFunction\n        if (muUnit) {\n          parser.settings.reportNonstrict(\"mathVsTextUnits\", \"LaTeX's \" + funcName + \" doesn't support mu units\");\n        }\n      }\n    }\n\n    return {\n      type: \"kern\",\n      mode: parser.mode,\n      dimension: size.value\n    };\n  },\n\n  htmlBuilder(group, options) {\n    return buildCommon.makeGlue(group.dimension, options);\n  },\n\n  mathmlBuilder(group, options) {\n    const dimension = calculateSize(group.dimension, options);\n    return new mathMLTree.SpaceNode(dimension);\n  }\n\n});\n;// CONCATENATED MODULE: ./src/functions/lap.js\n// Horizontal overlap functions\n\n\n\n\n\n\ndefineFunction({\n  type: \"lap\",\n  names: [\"\\\\mathllap\", \"\\\\mathrlap\", \"\\\\mathclap\"],\n  props: {\n    numArgs: 1,\n    allowedInText: true\n  },\n  handler: (_ref, args) => {\n    let {\n      parser,\n      funcName\n    } = _ref;\n    const body = args[0];\n    return {\n      type: \"lap\",\n      mode: parser.mode,\n      alignment: funcName.slice(5),\n      body\n    };\n  },\n  htmlBuilder: (group, options) => {\n    // mathllap, mathrlap, mathclap\n    let inner;\n\n    if (group.alignment === \"clap\") {\n      // ref: https://www.math.lsu.edu/~aperlis/publications/mathclap/\n      inner = buildCommon.makeSpan([], [buildGroup(group.body, options)]); // wrap, since CSS will center a .clap > .inner > span\n\n      inner = buildCommon.makeSpan([\"inner\"], [inner], options);\n    } else {\n      inner = buildCommon.makeSpan([\"inner\"], [buildGroup(group.body, options)]);\n    }\n\n    const fix = buildCommon.makeSpan([\"fix\"], []);\n    let node = buildCommon.makeSpan([group.alignment], [inner, fix], options); // At this point, we have correctly set horizontal alignment of the\n    // two items involved in the lap.\n    // Next, use a strut to set the height of the HTML bounding box.\n    // Otherwise, a tall argument may be misplaced.\n    // This code resolved issue #1153\n\n    const strut = buildCommon.makeSpan([\"strut\"]);\n    strut.style.height = makeEm(node.height + node.depth);\n\n    if (node.depth) {\n      strut.style.verticalAlign = makeEm(-node.depth);\n    }\n\n    node.children.unshift(strut); // Next, prevent vertical misplacement when next to something tall.\n    // This code resolves issue #1234\n\n    node = buildCommon.makeSpan([\"thinbox\"], [node], options);\n    return buildCommon.makeSpan([\"mord\", \"vbox\"], [node], options);\n  },\n  mathmlBuilder: (group, options) => {\n    // mathllap, mathrlap, mathclap\n    const node = new mathMLTree.MathNode(\"mpadded\", [buildMathML_buildGroup(group.body, options)]);\n\n    if (group.alignment !== \"rlap\") {\n      const offset = group.alignment === \"llap\" ? \"-1\" : \"-0.5\";\n      node.setAttribute(\"lspace\", offset + \"width\");\n    }\n\n    node.setAttribute(\"width\", \"0px\");\n    return node;\n  }\n});\n;// CONCATENATED MODULE: ./src/functions/math.js\n\n // Switching from text mode back to math mode\n\ndefineFunction({\n  type: \"styling\",\n  names: [\"\\\\(\", \"$\"],\n  props: {\n    numArgs: 0,\n    allowedInText: true,\n    allowedInMath: false\n  },\n\n  handler(_ref, args) {\n    let {\n      funcName,\n      parser\n    } = _ref;\n    const outerMode = parser.mode;\n    parser.switchMode(\"math\");\n    const close = funcName === \"\\\\(\" ? \"\\\\)\" : \"$\";\n    const body = parser.parseExpression(false, close);\n    parser.expect(close);\n    parser.switchMode(outerMode);\n    return {\n      type: \"styling\",\n      mode: parser.mode,\n      style: \"text\",\n      body\n    };\n  }\n\n}); // Check for extra closing math delimiters\n\ndefineFunction({\n  type: \"text\",\n  // Doesn't matter what this is.\n  names: [\"\\\\)\", \"\\\\]\"],\n  props: {\n    numArgs: 0,\n    allowedInText: true,\n    allowedInMath: false\n  },\n\n  handler(context, args) {\n    throw new src_ParseError(\"Mismatched \" + context.funcName);\n  }\n\n});\n;// CONCATENATED MODULE: ./src/functions/mathchoice.js\n\n\n\n\n\n\nconst chooseMathStyle = (group, options) => {\n  switch (options.style.size) {\n    case src_Style.DISPLAY.size:\n      return group.display;\n\n    case src_Style.TEXT.size:\n      return group.text;\n\n    case src_Style.SCRIPT.size:\n      return group.script;\n\n    case src_Style.SCRIPTSCRIPT.size:\n      return group.scriptscript;\n\n    default:\n      return group.text;\n  }\n};\n\ndefineFunction({\n  type: \"mathchoice\",\n  names: [\"\\\\mathchoice\"],\n  props: {\n    numArgs: 4,\n    primitive: true\n  },\n  handler: (_ref, args) => {\n    let {\n      parser\n    } = _ref;\n    return {\n      type: \"mathchoice\",\n      mode: parser.mode,\n      display: ordargument(args[0]),\n      text: ordargument(args[1]),\n      script: ordargument(args[2]),\n      scriptscript: ordargument(args[3])\n    };\n  },\n  htmlBuilder: (group, options) => {\n    const body = chooseMathStyle(group, options);\n    const elements = buildExpression(body, options, false);\n    return buildCommon.makeFragment(elements);\n  },\n  mathmlBuilder: (group, options) => {\n    const body = chooseMathStyle(group, options);\n    return buildExpressionRow(body, options);\n  }\n});\n;// CONCATENATED MODULE: ./src/functions/utils/assembleSupSub.js\n\n\n\n // For an operator with limits, assemble the base, sup, and sub into a span.\n\nconst assembleSupSub = (base, supGroup, subGroup, options, style, slant, baseShift) => {\n  base = buildCommon.makeSpan([], [base]);\n  const subIsSingleCharacter = subGroup && utils.isCharacterBox(subGroup);\n  let sub;\n  let sup; // We manually have to handle the superscripts and subscripts. This,\n  // aside from the kern calculations, is copied from supsub.\n\n  if (supGroup) {\n    const elem = buildGroup(supGroup, options.havingStyle(style.sup()), options);\n    sup = {\n      elem,\n      kern: Math.max(options.fontMetrics().bigOpSpacing1, options.fontMetrics().bigOpSpacing3 - elem.depth)\n    };\n  }\n\n  if (subGroup) {\n    const elem = buildGroup(subGroup, options.havingStyle(style.sub()), options);\n    sub = {\n      elem,\n      kern: Math.max(options.fontMetrics().bigOpSpacing2, options.fontMetrics().bigOpSpacing4 - elem.height)\n    };\n  } // Build the final group as a vlist of the possible subscript, base,\n  // and possible superscript.\n\n\n  let finalGroup;\n\n  if (sup && sub) {\n    const bottom = options.fontMetrics().bigOpSpacing5 + sub.elem.height + sub.elem.depth + sub.kern + base.depth + baseShift;\n    finalGroup = buildCommon.makeVList({\n      positionType: \"bottom\",\n      positionData: bottom,\n      children: [{\n        type: \"kern\",\n        size: options.fontMetrics().bigOpSpacing5\n      }, {\n        type: \"elem\",\n        elem: sub.elem,\n        marginLeft: makeEm(-slant)\n      }, {\n        type: \"kern\",\n        size: sub.kern\n      }, {\n        type: \"elem\",\n        elem: base\n      }, {\n        type: \"kern\",\n        size: sup.kern\n      }, {\n        type: \"elem\",\n        elem: sup.elem,\n        marginLeft: makeEm(slant)\n      }, {\n        type: \"kern\",\n        size: options.fontMetrics().bigOpSpacing5\n      }]\n    }, options);\n  } else if (sub) {\n    const top = base.height - baseShift; // Shift the limits by the slant of the symbol. Note\n    // that we are supposed to shift the limits by 1/2 of the slant,\n    // but since we are centering the limits adding a full slant of\n    // margin will shift by 1/2 that.\n\n    finalGroup = buildCommon.makeVList({\n      positionType: \"top\",\n      positionData: top,\n      children: [{\n        type: \"kern\",\n        size: options.fontMetrics().bigOpSpacing5\n      }, {\n        type: \"elem\",\n        elem: sub.elem,\n        marginLeft: makeEm(-slant)\n      }, {\n        type: \"kern\",\n        size: sub.kern\n      }, {\n        type: \"elem\",\n        elem: base\n      }]\n    }, options);\n  } else if (sup) {\n    const bottom = base.depth + baseShift;\n    finalGroup = buildCommon.makeVList({\n      positionType: \"bottom\",\n      positionData: bottom,\n      children: [{\n        type: \"elem\",\n        elem: base\n      }, {\n        type: \"kern\",\n        size: sup.kern\n      }, {\n        type: \"elem\",\n        elem: sup.elem,\n        marginLeft: makeEm(slant)\n      }, {\n        type: \"kern\",\n        size: options.fontMetrics().bigOpSpacing5\n      }]\n    }, options);\n  } else {\n    // This case probably shouldn't occur (this would mean the\n    // supsub was sending us a group with no superscript or\n    // subscript) but be safe.\n    return base;\n  }\n\n  const parts = [finalGroup];\n\n  if (sub && slant !== 0 && !subIsSingleCharacter) {\n    // A negative margin-left was applied to the lower limit.\n    // Avoid an overlap by placing a spacer on the left on the group.\n    const spacer = buildCommon.makeSpan([\"mspace\"], [], options);\n    spacer.style.marginRight = makeEm(slant);\n    parts.unshift(spacer);\n  }\n\n  return buildCommon.makeSpan([\"mop\", \"op-limits\"], parts, options);\n};\n;// CONCATENATED MODULE: ./src/functions/op.js\n// Limits, symbols\n\n\n\n\n\n\n\n\n\n\n\n// Most operators have a large successor symbol, but these don't.\nconst noSuccessor = [\"\\\\smallint\"]; // NOTE: Unlike most `htmlBuilder`s, this one handles not only \"op\", but also\n// \"supsub\" since some of them (like \\int) can affect super/subscripting.\n\nconst op_htmlBuilder = (grp, options) => {\n  // Operators are handled in the TeXbook pg. 443-444, rule 13(a).\n  let supGroup;\n  let subGroup;\n  let hasLimits = false;\n  let group;\n\n  if (grp.type === \"supsub\") {\n    // If we have limits, supsub will pass us its group to handle. Pull\n    // out the superscript and subscript and set the group to the op in\n    // its base.\n    supGroup = grp.sup;\n    subGroup = grp.sub;\n    group = assertNodeType(grp.base, \"op\");\n    hasLimits = true;\n  } else {\n    group = assertNodeType(grp, \"op\");\n  }\n\n  const style = options.style;\n  let large = false;\n\n  if (style.size === src_Style.DISPLAY.size && group.symbol && !utils.contains(noSuccessor, group.name)) {\n    // Most symbol operators get larger in displaystyle (rule 13)\n    large = true;\n  }\n\n  let base;\n\n  if (group.symbol) {\n    // If this is a symbol, create the symbol.\n    const fontName = large ? \"Size2-Regular\" : \"Size1-Regular\";\n    let stash = \"\";\n\n    if (group.name === \"\\\\oiint\" || group.name === \"\\\\oiiint\") {\n      // No font glyphs yet, so use a glyph w/o the oval.\n      // TODO: When font glyphs are available, delete this code.\n      stash = group.name.slice(1);\n      group.name = stash === \"oiint\" ? \"\\\\iint\" : \"\\\\iiint\";\n    }\n\n    base = buildCommon.makeSymbol(group.name, fontName, \"math\", options, [\"mop\", \"op-symbol\", large ? \"large-op\" : \"small-op\"]);\n\n    if (stash.length > 0) {\n      // We're in \\oiint or \\oiiint. Overlay the oval.\n      // TODO: When font glyphs are available, delete this code.\n      const italic = base.italic;\n      const oval = buildCommon.staticSvg(stash + \"Size\" + (large ? \"2\" : \"1\"), options);\n      base = buildCommon.makeVList({\n        positionType: \"individualShift\",\n        children: [{\n          type: \"elem\",\n          elem: base,\n          shift: 0\n        }, {\n          type: \"elem\",\n          elem: oval,\n          shift: large ? 0.08 : 0\n        }]\n      }, options);\n      group.name = \"\\\\\" + stash;\n      base.classes.unshift(\"mop\"); // $FlowFixMe\n\n      base.italic = italic;\n    }\n  } else if (group.body) {\n    // If this is a list, compose that list.\n    const inner = buildExpression(group.body, options, true);\n\n    if (inner.length === 1 && inner[0] instanceof SymbolNode) {\n      base = inner[0];\n      base.classes[0] = \"mop\"; // replace old mclass\n    } else {\n      base = buildCommon.makeSpan([\"mop\"], inner, options);\n    }\n  } else {\n    // Otherwise, this is a text operator. Build the text from the\n    // operator's name.\n    const output = [];\n\n    for (let i = 1; i < group.name.length; i++) {\n      output.push(buildCommon.mathsym(group.name[i], group.mode, options));\n    }\n\n    base = buildCommon.makeSpan([\"mop\"], output, options);\n  } // If content of op is a single symbol, shift it vertically.\n\n\n  let baseShift = 0;\n  let slant = 0;\n\n  if ((base instanceof SymbolNode || group.name === \"\\\\oiint\" || group.name === \"\\\\oiiint\") && !group.suppressBaseShift) {\n    // We suppress the shift of the base of \\overset and \\underset. Otherwise,\n    // shift the symbol so its center lies on the axis (rule 13). It\n    // appears that our fonts have the centers of the symbols already\n    // almost on the axis, so these numbers are very small. Note we\n    // don't actually apply this here, but instead it is used either in\n    // the vlist creation or separately when there are no limits.\n    baseShift = (base.height - base.depth) / 2 - options.fontMetrics().axisHeight; // The slant of the symbol is just its italic correction.\n    // $FlowFixMe\n\n    slant = base.italic;\n  }\n\n  if (hasLimits) {\n    return assembleSupSub(base, supGroup, subGroup, options, style, slant, baseShift);\n  } else {\n    if (baseShift) {\n      base.style.position = \"relative\";\n      base.style.top = makeEm(baseShift);\n    }\n\n    return base;\n  }\n};\n\nconst op_mathmlBuilder = (group, options) => {\n  let node;\n\n  if (group.symbol) {\n    // This is a symbol. Just add the symbol.\n    node = new MathNode(\"mo\", [makeText(group.name, group.mode)]);\n\n    if (utils.contains(noSuccessor, group.name)) {\n      node.setAttribute(\"largeop\", \"false\");\n    }\n  } else if (group.body) {\n    // This is an operator with children. Add them.\n    node = new MathNode(\"mo\", buildMathML_buildExpression(group.body, options));\n  } else {\n    // This is a text operator. Add all of the characters from the\n    // operator's name.\n    node = new MathNode(\"mi\", [new TextNode(group.name.slice(1))]); // Append an <mo>&ApplyFunction;</mo>.\n    // ref: https://www.w3.org/TR/REC-MathML/chap3_2.html#sec3.2.4\n\n    const operator = new MathNode(\"mo\", [makeText(\"\\u2061\", \"text\")]);\n\n    if (group.parentIsSupSub) {\n      node = new MathNode(\"mrow\", [node, operator]);\n    } else {\n      node = newDocumentFragment([node, operator]);\n    }\n  }\n\n  return node;\n};\n\nconst singleCharBigOps = {\n  \"\\u220F\": \"\\\\prod\",\n  \"\\u2210\": \"\\\\coprod\",\n  \"\\u2211\": \"\\\\sum\",\n  \"\\u22c0\": \"\\\\bigwedge\",\n  \"\\u22c1\": \"\\\\bigvee\",\n  \"\\u22c2\": \"\\\\bigcap\",\n  \"\\u22c3\": \"\\\\bigcup\",\n  \"\\u2a00\": \"\\\\bigodot\",\n  \"\\u2a01\": \"\\\\bigoplus\",\n  \"\\u2a02\": \"\\\\bigotimes\",\n  \"\\u2a04\": \"\\\\biguplus\",\n  \"\\u2a06\": \"\\\\bigsqcup\"\n};\ndefineFunction({\n  type: \"op\",\n  names: [\"\\\\coprod\", \"\\\\bigvee\", \"\\\\bigwedge\", \"\\\\biguplus\", \"\\\\bigcap\", \"\\\\bigcup\", \"\\\\intop\", \"\\\\prod\", \"\\\\sum\", \"\\\\bigotimes\", \"\\\\bigoplus\", \"\\\\bigodot\", \"\\\\bigsqcup\", \"\\\\smallint\", \"\\u220F\", \"\\u2210\", \"\\u2211\", \"\\u22c0\", \"\\u22c1\", \"\\u22c2\", \"\\u22c3\", \"\\u2a00\", \"\\u2a01\", \"\\u2a02\", \"\\u2a04\", \"\\u2a06\"],\n  props: {\n    numArgs: 0\n  },\n  handler: (_ref, args) => {\n    let {\n      parser,\n      funcName\n    } = _ref;\n    let fName = funcName;\n\n    if (fName.length === 1) {\n      fName = singleCharBigOps[fName];\n    }\n\n    return {\n      type: \"op\",\n      mode: parser.mode,\n      limits: true,\n      parentIsSupSub: false,\n      symbol: true,\n      name: fName\n    };\n  },\n  htmlBuilder: op_htmlBuilder,\n  mathmlBuilder: op_mathmlBuilder\n}); // Note: calling defineFunction with a type that's already been defined only\n// works because the same htmlBuilder and mathmlBuilder are being used.\n\ndefineFunction({\n  type: \"op\",\n  names: [\"\\\\mathop\"],\n  props: {\n    numArgs: 1,\n    primitive: true\n  },\n  handler: (_ref2, args) => {\n    let {\n      parser\n    } = _ref2;\n    const body = args[0];\n    return {\n      type: \"op\",\n      mode: parser.mode,\n      limits: false,\n      parentIsSupSub: false,\n      symbol: false,\n      body: ordargument(body)\n    };\n  },\n  htmlBuilder: op_htmlBuilder,\n  mathmlBuilder: op_mathmlBuilder\n}); // There are 2 flags for operators; whether they produce limits in\n// displaystyle, and whether they are symbols and should grow in\n// displaystyle. These four groups cover the four possible choices.\n\nconst singleCharIntegrals = {\n  \"\\u222b\": \"\\\\int\",\n  \"\\u222c\": \"\\\\iint\",\n  \"\\u222d\": \"\\\\iiint\",\n  \"\\u222e\": \"\\\\oint\",\n  \"\\u222f\": \"\\\\oiint\",\n  \"\\u2230\": \"\\\\oiiint\"\n}; // No limits, not symbols\n\ndefineFunction({\n  type: \"op\",\n  names: [\"\\\\arcsin\", \"\\\\arccos\", \"\\\\arctan\", \"\\\\arctg\", \"\\\\arcctg\", \"\\\\arg\", \"\\\\ch\", \"\\\\cos\", \"\\\\cosec\", \"\\\\cosh\", \"\\\\cot\", \"\\\\cotg\", \"\\\\coth\", \"\\\\csc\", \"\\\\ctg\", \"\\\\cth\", \"\\\\deg\", \"\\\\dim\", \"\\\\exp\", \"\\\\hom\", \"\\\\ker\", \"\\\\lg\", \"\\\\ln\", \"\\\\log\", \"\\\\sec\", \"\\\\sin\", \"\\\\sinh\", \"\\\\sh\", \"\\\\tan\", \"\\\\tanh\", \"\\\\tg\", \"\\\\th\"],\n  props: {\n    numArgs: 0\n  },\n\n  handler(_ref3) {\n    let {\n      parser,\n      funcName\n    } = _ref3;\n    return {\n      type: \"op\",\n      mode: parser.mode,\n      limits: false,\n      parentIsSupSub: false,\n      symbol: false,\n      name: funcName\n    };\n  },\n\n  htmlBuilder: op_htmlBuilder,\n  mathmlBuilder: op_mathmlBuilder\n}); // Limits, not symbols\n\ndefineFunction({\n  type: \"op\",\n  names: [\"\\\\det\", \"\\\\gcd\", \"\\\\inf\", \"\\\\lim\", \"\\\\max\", \"\\\\min\", \"\\\\Pr\", \"\\\\sup\"],\n  props: {\n    numArgs: 0\n  },\n\n  handler(_ref4) {\n    let {\n      parser,\n      funcName\n    } = _ref4;\n    return {\n      type: \"op\",\n      mode: parser.mode,\n      limits: true,\n      parentIsSupSub: false,\n      symbol: false,\n      name: funcName\n    };\n  },\n\n  htmlBuilder: op_htmlBuilder,\n  mathmlBuilder: op_mathmlBuilder\n}); // No limits, symbols\n\ndefineFunction({\n  type: \"op\",\n  names: [\"\\\\int\", \"\\\\iint\", \"\\\\iiint\", \"\\\\oint\", \"\\\\oiint\", \"\\\\oiiint\", \"\\u222b\", \"\\u222c\", \"\\u222d\", \"\\u222e\", \"\\u222f\", \"\\u2230\"],\n  props: {\n    numArgs: 0\n  },\n\n  handler(_ref5) {\n    let {\n      parser,\n      funcName\n    } = _ref5;\n    let fName = funcName;\n\n    if (fName.length === 1) {\n      fName = singleCharIntegrals[fName];\n    }\n\n    return {\n      type: \"op\",\n      mode: parser.mode,\n      limits: false,\n      parentIsSupSub: false,\n      symbol: true,\n      name: fName\n    };\n  },\n\n  htmlBuilder: op_htmlBuilder,\n  mathmlBuilder: op_mathmlBuilder\n});\n;// CONCATENATED MODULE: ./src/functions/operatorname.js\n\n\n\n\n\n\n\n\n\n// NOTE: Unlike most `htmlBuilder`s, this one handles not only\n// \"operatorname\", but also  \"supsub\" since \\operatorname* can\n// affect super/subscripting.\nconst operatorname_htmlBuilder = (grp, options) => {\n  // Operators are handled in the TeXbook pg. 443-444, rule 13(a).\n  let supGroup;\n  let subGroup;\n  let hasLimits = false;\n  let group;\n\n  if (grp.type === \"supsub\") {\n    // If we have limits, supsub will pass us its group to handle. Pull\n    // out the superscript and subscript and set the group to the op in\n    // its base.\n    supGroup = grp.sup;\n    subGroup = grp.sub;\n    group = assertNodeType(grp.base, \"operatorname\");\n    hasLimits = true;\n  } else {\n    group = assertNodeType(grp, \"operatorname\");\n  }\n\n  let base;\n\n  if (group.body.length > 0) {\n    const body = group.body.map(child => {\n      // $FlowFixMe: Check if the node has a string `text` property.\n      const childText = child.text;\n\n      if (typeof childText === \"string\") {\n        return {\n          type: \"textord\",\n          mode: child.mode,\n          text: childText\n        };\n      } else {\n        return child;\n      }\n    }); // Consolidate function names into symbol characters.\n\n    const expression = buildExpression(body, options.withFont(\"mathrm\"), true);\n\n    for (let i = 0; i < expression.length; i++) {\n      const child = expression[i];\n\n      if (child instanceof SymbolNode) {\n        // Per amsopn package,\n        // change minus to hyphen and \\ast to asterisk\n        child.text = child.text.replace(/\\u2212/, \"-\").replace(/\\u2217/, \"*\");\n      }\n    }\n\n    base = buildCommon.makeSpan([\"mop\"], expression, options);\n  } else {\n    base = buildCommon.makeSpan([\"mop\"], [], options);\n  }\n\n  if (hasLimits) {\n    return assembleSupSub(base, supGroup, subGroup, options, options.style, 0, 0);\n  } else {\n    return base;\n  }\n};\n\nconst operatorname_mathmlBuilder = (group, options) => {\n  // The steps taken here are similar to the html version.\n  let expression = buildMathML_buildExpression(group.body, options.withFont(\"mathrm\")); // Is expression a string or has it something like a fraction?\n\n  let isAllString = true; // default\n\n  for (let i = 0; i < expression.length; i++) {\n    const node = expression[i];\n\n    if (node instanceof mathMLTree.SpaceNode) {// Do nothing\n    } else if (node instanceof mathMLTree.MathNode) {\n      switch (node.type) {\n        case \"mi\":\n        case \"mn\":\n        case \"ms\":\n        case \"mspace\":\n        case \"mtext\":\n          break;\n        // Do nothing yet.\n\n        case \"mo\":\n          {\n            const child = node.children[0];\n\n            if (node.children.length === 1 && child instanceof mathMLTree.TextNode) {\n              child.text = child.text.replace(/\\u2212/, \"-\").replace(/\\u2217/, \"*\");\n            } else {\n              isAllString = false;\n            }\n\n            break;\n          }\n\n        default:\n          isAllString = false;\n      }\n    } else {\n      isAllString = false;\n    }\n  }\n\n  if (isAllString) {\n    // Write a single TextNode instead of multiple nested tags.\n    const word = expression.map(node => node.toText()).join(\"\");\n    expression = [new mathMLTree.TextNode(word)];\n  }\n\n  const identifier = new mathMLTree.MathNode(\"mi\", expression);\n  identifier.setAttribute(\"mathvariant\", \"normal\"); // \\u2061 is the same as &ApplyFunction;\n  // ref: https://www.w3schools.com/charsets/ref_html_entities_a.asp\n\n  const operator = new mathMLTree.MathNode(\"mo\", [makeText(\"\\u2061\", \"text\")]);\n\n  if (group.parentIsSupSub) {\n    return new mathMLTree.MathNode(\"mrow\", [identifier, operator]);\n  } else {\n    return mathMLTree.newDocumentFragment([identifier, operator]);\n  }\n}; // \\operatorname\n// amsopn.dtx: \\mathop{#1\\kern\\z@\\operator@font#3}\\newmcodes@\n\n\ndefineFunction({\n  type: \"operatorname\",\n  names: [\"\\\\operatorname@\", \"\\\\operatornamewithlimits\"],\n  props: {\n    numArgs: 1\n  },\n  handler: (_ref, args) => {\n    let {\n      parser,\n      funcName\n    } = _ref;\n    const body = args[0];\n    return {\n      type: \"operatorname\",\n      mode: parser.mode,\n      body: ordargument(body),\n      alwaysHandleSupSub: funcName === \"\\\\operatornamewithlimits\",\n      limits: false,\n      parentIsSupSub: false\n    };\n  },\n  htmlBuilder: operatorname_htmlBuilder,\n  mathmlBuilder: operatorname_mathmlBuilder\n});\ndefineMacro(\"\\\\operatorname\", \"\\\\@ifstar\\\\operatornamewithlimits\\\\operatorname@\");\n;// CONCATENATED MODULE: ./src/functions/ordgroup.js\n\n\n\n\ndefineFunctionBuilders({\n  type: \"ordgroup\",\n\n  htmlBuilder(group, options) {\n    if (group.semisimple) {\n      return buildCommon.makeFragment(buildExpression(group.body, options, false));\n    }\n\n    return buildCommon.makeSpan([\"mord\"], buildExpression(group.body, options, true), options);\n  },\n\n  mathmlBuilder(group, options) {\n    return buildExpressionRow(group.body, options, true);\n  }\n\n});\n;// CONCATENATED MODULE: ./src/functions/overline.js\n\n\n\n\n\ndefineFunction({\n  type: \"overline\",\n  names: [\"\\\\overline\"],\n  props: {\n    numArgs: 1\n  },\n\n  handler(_ref, args) {\n    let {\n      parser\n    } = _ref;\n    const body = args[0];\n    return {\n      type: \"overline\",\n      mode: parser.mode,\n      body\n    };\n  },\n\n  htmlBuilder(group, options) {\n    // Overlines are handled in the TeXbook pg 443, Rule 9.\n    // Build the inner group in the cramped style.\n    const innerGroup = buildGroup(group.body, options.havingCrampedStyle()); // Create the line above the body\n\n    const line = buildCommon.makeLineSpan(\"overline-line\", options); // Generate the vlist, with the appropriate kerns\n\n    const defaultRuleThickness = options.fontMetrics().defaultRuleThickness;\n    const vlist = buildCommon.makeVList({\n      positionType: \"firstBaseline\",\n      children: [{\n        type: \"elem\",\n        elem: innerGroup\n      }, {\n        type: \"kern\",\n        size: 3 * defaultRuleThickness\n      }, {\n        type: \"elem\",\n        elem: line\n      }, {\n        type: \"kern\",\n        size: defaultRuleThickness\n      }]\n    }, options);\n    return buildCommon.makeSpan([\"mord\", \"overline\"], [vlist], options);\n  },\n\n  mathmlBuilder(group, options) {\n    const operator = new mathMLTree.MathNode(\"mo\", [new mathMLTree.TextNode(\"\\u203e\")]);\n    operator.setAttribute(\"stretchy\", \"true\");\n    const node = new mathMLTree.MathNode(\"mover\", [buildMathML_buildGroup(group.body, options), operator]);\n    node.setAttribute(\"accent\", \"true\");\n    return node;\n  }\n\n});\n;// CONCATENATED MODULE: ./src/functions/phantom.js\n\n\n\n\n\ndefineFunction({\n  type: \"phantom\",\n  names: [\"\\\\phantom\"],\n  props: {\n    numArgs: 1,\n    allowedInText: true\n  },\n  handler: (_ref, args) => {\n    let {\n      parser\n    } = _ref;\n    const body = args[0];\n    return {\n      type: \"phantom\",\n      mode: parser.mode,\n      body: ordargument(body)\n    };\n  },\n  htmlBuilder: (group, options) => {\n    const elements = buildExpression(group.body, options.withPhantom(), false); // \\phantom isn't supposed to affect the elements it contains.\n    // See \"color\" for more details.\n\n    return buildCommon.makeFragment(elements);\n  },\n  mathmlBuilder: (group, options) => {\n    const inner = buildMathML_buildExpression(group.body, options);\n    return new mathMLTree.MathNode(\"mphantom\", inner);\n  }\n});\ndefineFunction({\n  type: \"hphantom\",\n  names: [\"\\\\hphantom\"],\n  props: {\n    numArgs: 1,\n    allowedInText: true\n  },\n  handler: (_ref2, args) => {\n    let {\n      parser\n    } = _ref2;\n    const body = args[0];\n    return {\n      type: \"hphantom\",\n      mode: parser.mode,\n      body\n    };\n  },\n  htmlBuilder: (group, options) => {\n    let node = buildCommon.makeSpan([], [buildGroup(group.body, options.withPhantom())]);\n    node.height = 0;\n    node.depth = 0;\n\n    if (node.children) {\n      for (let i = 0; i < node.children.length; i++) {\n        node.children[i].height = 0;\n        node.children[i].depth = 0;\n      }\n    } // See smash for comment re: use of makeVList\n\n\n    node = buildCommon.makeVList({\n      positionType: \"firstBaseline\",\n      children: [{\n        type: \"elem\",\n        elem: node\n      }]\n    }, options); // For spacing, TeX treats \\smash as a math group (same spacing as ord).\n\n    return buildCommon.makeSpan([\"mord\"], [node], options);\n  },\n  mathmlBuilder: (group, options) => {\n    const inner = buildMathML_buildExpression(ordargument(group.body), options);\n    const phantom = new mathMLTree.MathNode(\"mphantom\", inner);\n    const node = new mathMLTree.MathNode(\"mpadded\", [phantom]);\n    node.setAttribute(\"height\", \"0px\");\n    node.setAttribute(\"depth\", \"0px\");\n    return node;\n  }\n});\ndefineFunction({\n  type: \"vphantom\",\n  names: [\"\\\\vphantom\"],\n  props: {\n    numArgs: 1,\n    allowedInText: true\n  },\n  handler: (_ref3, args) => {\n    let {\n      parser\n    } = _ref3;\n    const body = args[0];\n    return {\n      type: \"vphantom\",\n      mode: parser.mode,\n      body\n    };\n  },\n  htmlBuilder: (group, options) => {\n    const inner = buildCommon.makeSpan([\"inner\"], [buildGroup(group.body, options.withPhantom())]);\n    const fix = buildCommon.makeSpan([\"fix\"], []);\n    return buildCommon.makeSpan([\"mord\", \"rlap\"], [inner, fix], options);\n  },\n  mathmlBuilder: (group, options) => {\n    const inner = buildMathML_buildExpression(ordargument(group.body), options);\n    const phantom = new mathMLTree.MathNode(\"mphantom\", inner);\n    const node = new mathMLTree.MathNode(\"mpadded\", [phantom]);\n    node.setAttribute(\"width\", \"0px\");\n    return node;\n  }\n});\n;// CONCATENATED MODULE: ./src/functions/raisebox.js\n\n\n\n\n\n\n // Box manipulation\n\ndefineFunction({\n  type: \"raisebox\",\n  names: [\"\\\\raisebox\"],\n  props: {\n    numArgs: 2,\n    argTypes: [\"size\", \"hbox\"],\n    allowedInText: true\n  },\n\n  handler(_ref, args) {\n    let {\n      parser\n    } = _ref;\n    const amount = assertNodeType(args[0], \"size\").value;\n    const body = args[1];\n    return {\n      type: \"raisebox\",\n      mode: parser.mode,\n      dy: amount,\n      body\n    };\n  },\n\n  htmlBuilder(group, options) {\n    const body = buildGroup(group.body, options);\n    const dy = calculateSize(group.dy, options);\n    return buildCommon.makeVList({\n      positionType: \"shift\",\n      positionData: -dy,\n      children: [{\n        type: \"elem\",\n        elem: body\n      }]\n    }, options);\n  },\n\n  mathmlBuilder(group, options) {\n    const node = new mathMLTree.MathNode(\"mpadded\", [buildMathML_buildGroup(group.body, options)]);\n    const dy = group.dy.number + group.dy.unit;\n    node.setAttribute(\"voffset\", dy);\n    return node;\n  }\n\n});\n;// CONCATENATED MODULE: ./src/functions/relax.js\n\ndefineFunction({\n  type: \"internal\",\n  names: [\"\\\\relax\"],\n  props: {\n    numArgs: 0,\n    allowedInText: true\n  },\n\n  handler(_ref) {\n    let {\n      parser\n    } = _ref;\n    return {\n      type: \"internal\",\n      mode: parser.mode\n    };\n  }\n\n});\n;// CONCATENATED MODULE: ./src/functions/rule.js\n\n\n\n\n\ndefineFunction({\n  type: \"rule\",\n  names: [\"\\\\rule\"],\n  props: {\n    numArgs: 2,\n    numOptionalArgs: 1,\n    argTypes: [\"size\", \"size\", \"size\"]\n  },\n\n  handler(_ref, args, optArgs) {\n    let {\n      parser\n    } = _ref;\n    const shift = optArgs[0];\n    const width = assertNodeType(args[0], \"size\");\n    const height = assertNodeType(args[1], \"size\");\n    return {\n      type: \"rule\",\n      mode: parser.mode,\n      shift: shift && assertNodeType(shift, \"size\").value,\n      width: width.value,\n      height: height.value\n    };\n  },\n\n  htmlBuilder(group, options) {\n    // Make an empty span for the rule\n    const rule = buildCommon.makeSpan([\"mord\", \"rule\"], [], options); // Calculate the shift, width, and height of the rule, and account for units\n\n    const width = calculateSize(group.width, options);\n    const height = calculateSize(group.height, options);\n    const shift = group.shift ? calculateSize(group.shift, options) : 0; // Style the rule to the right size\n\n    rule.style.borderRightWidth = makeEm(width);\n    rule.style.borderTopWidth = makeEm(height);\n    rule.style.bottom = makeEm(shift); // Record the height and width\n\n    rule.width = width;\n    rule.height = height + shift;\n    rule.depth = -shift; // Font size is the number large enough that the browser will\n    // reserve at least `absHeight` space above the baseline.\n    // The 1.125 factor was empirically determined\n\n    rule.maxFontSize = height * 1.125 * options.sizeMultiplier;\n    return rule;\n  },\n\n  mathmlBuilder(group, options) {\n    const width = calculateSize(group.width, options);\n    const height = calculateSize(group.height, options);\n    const shift = group.shift ? calculateSize(group.shift, options) : 0;\n    const color = options.color && options.getColor() || \"black\";\n    const rule = new mathMLTree.MathNode(\"mspace\");\n    rule.setAttribute(\"mathbackground\", color);\n    rule.setAttribute(\"width\", makeEm(width));\n    rule.setAttribute(\"height\", makeEm(height));\n    const wrapper = new mathMLTree.MathNode(\"mpadded\", [rule]);\n\n    if (shift >= 0) {\n      wrapper.setAttribute(\"height\", makeEm(shift));\n    } else {\n      wrapper.setAttribute(\"height\", makeEm(shift));\n      wrapper.setAttribute(\"depth\", makeEm(-shift));\n    }\n\n    wrapper.setAttribute(\"voffset\", makeEm(shift));\n    return wrapper;\n  }\n\n});\n;// CONCATENATED MODULE: ./src/functions/sizing.js\n\n\n\n\n\n\nfunction sizingGroup(value, options, baseOptions) {\n  const inner = buildExpression(value, options, false);\n  const multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier; // Add size-resetting classes to the inner list and set maxFontSize\n  // manually. Handle nested size changes.\n\n  for (let i = 0; i < inner.length; i++) {\n    const pos = inner[i].classes.indexOf(\"sizing\");\n\n    if (pos < 0) {\n      Array.prototype.push.apply(inner[i].classes, options.sizingClasses(baseOptions));\n    } else if (inner[i].classes[pos + 1] === \"reset-size\" + options.size) {\n      // This is a nested size change: e.g., inner[i] is the \"b\" in\n      // `\\Huge a \\small b`. Override the old size (the `reset-` class)\n      // but not the new size.\n      inner[i].classes[pos + 1] = \"reset-size\" + baseOptions.size;\n    }\n\n    inner[i].height *= multiplier;\n    inner[i].depth *= multiplier;\n  }\n\n  return buildCommon.makeFragment(inner);\n}\nconst sizeFuncs = [\"\\\\tiny\", \"\\\\sixptsize\", \"\\\\scriptsize\", \"\\\\footnotesize\", \"\\\\small\", \"\\\\normalsize\", \"\\\\large\", \"\\\\Large\", \"\\\\LARGE\", \"\\\\huge\", \"\\\\Huge\"];\nconst sizing_htmlBuilder = (group, options) => {\n  // Handle sizing operators like \\Huge. Real TeX doesn't actually allow\n  // these functions inside of math expressions, so we do some special\n  // handling.\n  const newOptions = options.havingSize(group.size);\n  return sizingGroup(group.body, newOptions, options);\n};\ndefineFunction({\n  type: \"sizing\",\n  names: sizeFuncs,\n  props: {\n    numArgs: 0,\n    allowedInText: true\n  },\n  handler: (_ref, args) => {\n    let {\n      breakOnTokenText,\n      funcName,\n      parser\n    } = _ref;\n    const body = parser.parseExpression(false, breakOnTokenText);\n    return {\n      type: \"sizing\",\n      mode: parser.mode,\n      // Figure out what size to use based on the list of functions above\n      size: sizeFuncs.indexOf(funcName) + 1,\n      body\n    };\n  },\n  htmlBuilder: sizing_htmlBuilder,\n  mathmlBuilder: (group, options) => {\n    const newOptions = options.havingSize(group.size);\n    const inner = buildMathML_buildExpression(group.body, newOptions);\n    const node = new mathMLTree.MathNode(\"mstyle\", inner); // TODO(emily): This doesn't produce the correct size for nested size\n    // changes, because we don't keep state of what style we're currently\n    // in, so we can't reset the size to normal before changing it.  Now\n    // that we're passing an options parameter we should be able to fix\n    // this.\n\n    node.setAttribute(\"mathsize\", makeEm(newOptions.sizeMultiplier));\n    return node;\n  }\n});\n;// CONCATENATED MODULE: ./src/functions/smash.js\n// smash, with optional [tb], as in AMS\n\n\n\n\n\n\ndefineFunction({\n  type: \"smash\",\n  names: [\"\\\\smash\"],\n  props: {\n    numArgs: 1,\n    numOptionalArgs: 1,\n    allowedInText: true\n  },\n  handler: (_ref, args, optArgs) => {\n    let {\n      parser\n    } = _ref;\n    let smashHeight = false;\n    let smashDepth = false;\n    const tbArg = optArgs[0] && assertNodeType(optArgs[0], \"ordgroup\");\n\n    if (tbArg) {\n      // Optional [tb] argument is engaged.\n      // ref: amsmath: \\renewcommand{\\smash}[1][tb]{%\n      //               def\\mb@t{\\ht}\\def\\mb@b{\\dp}\\def\\mb@tb{\\ht\\z@\\z@\\dp}%\n      let letter = \"\";\n\n      for (let i = 0; i < tbArg.body.length; ++i) {\n        const node = tbArg.body[i]; // $FlowFixMe: Not every node type has a `text` property.\n\n        letter = node.text;\n\n        if (letter === \"t\") {\n          smashHeight = true;\n        } else if (letter === \"b\") {\n          smashDepth = true;\n        } else {\n          smashHeight = false;\n          smashDepth = false;\n          break;\n        }\n      }\n    } else {\n      smashHeight = true;\n      smashDepth = true;\n    }\n\n    const body = args[0];\n    return {\n      type: \"smash\",\n      mode: parser.mode,\n      body,\n      smashHeight,\n      smashDepth\n    };\n  },\n  htmlBuilder: (group, options) => {\n    const node = buildCommon.makeSpan([], [buildGroup(group.body, options)]);\n\n    if (!group.smashHeight && !group.smashDepth) {\n      return node;\n    }\n\n    if (group.smashHeight) {\n      node.height = 0; // In order to influence makeVList, we have to reset the children.\n\n      if (node.children) {\n        for (let i = 0; i < node.children.length; i++) {\n          node.children[i].height = 0;\n        }\n      }\n    }\n\n    if (group.smashDepth) {\n      node.depth = 0;\n\n      if (node.children) {\n        for (let i = 0; i < node.children.length; i++) {\n          node.children[i].depth = 0;\n        }\n      }\n    } // At this point, we've reset the TeX-like height and depth values.\n    // But the span still has an HTML line height.\n    // makeVList applies \"display: table-cell\", which prevents the browser\n    // from acting on that line height. So we'll call makeVList now.\n\n\n    const smashedNode = buildCommon.makeVList({\n      positionType: \"firstBaseline\",\n      children: [{\n        type: \"elem\",\n        elem: node\n      }]\n    }, options); // For spacing, TeX treats \\hphantom as a math group (same spacing as ord).\n\n    return buildCommon.makeSpan([\"mord\"], [smashedNode], options);\n  },\n  mathmlBuilder: (group, options) => {\n    const node = new mathMLTree.MathNode(\"mpadded\", [buildMathML_buildGroup(group.body, options)]);\n\n    if (group.smashHeight) {\n      node.setAttribute(\"height\", \"0px\");\n    }\n\n    if (group.smashDepth) {\n      node.setAttribute(\"depth\", \"0px\");\n    }\n\n    return node;\n  }\n});\n;// CONCATENATED MODULE: ./src/functions/sqrt.js\n\n\n\n\n\n\n\n\ndefineFunction({\n  type: \"sqrt\",\n  names: [\"\\\\sqrt\"],\n  props: {\n    numArgs: 1,\n    numOptionalArgs: 1\n  },\n\n  handler(_ref, args, optArgs) {\n    let {\n      parser\n    } = _ref;\n    const index = optArgs[0];\n    const body = args[0];\n    return {\n      type: \"sqrt\",\n      mode: parser.mode,\n      body,\n      index\n    };\n  },\n\n  htmlBuilder(group, options) {\n    // Square roots are handled in the TeXbook pg. 443, Rule 11.\n    // First, we do the same steps as in overline to build the inner group\n    // and line\n    let inner = buildGroup(group.body, options.havingCrampedStyle());\n\n    if (inner.height === 0) {\n      // Render a small surd.\n      inner.height = options.fontMetrics().xHeight;\n    } // Some groups can return document fragments.  Handle those by wrapping\n    // them in a span.\n\n\n    inner = buildCommon.wrapFragment(inner, options); // Calculate the minimum size for the \\surd delimiter\n\n    const metrics = options.fontMetrics();\n    const theta = metrics.defaultRuleThickness;\n    let phi = theta;\n\n    if (options.style.id < src_Style.TEXT.id) {\n      phi = options.fontMetrics().xHeight;\n    } // Calculate the clearance between the body and line\n\n\n    let lineClearance = theta + phi / 4;\n    const minDelimiterHeight = inner.height + inner.depth + lineClearance + theta; // Create a sqrt SVG of the required minimum size\n\n    const {\n      span: img,\n      ruleWidth,\n      advanceWidth\n    } = delimiter.sqrtImage(minDelimiterHeight, options);\n    const delimDepth = img.height - ruleWidth; // Adjust the clearance based on the delimiter size\n\n    if (delimDepth > inner.height + inner.depth + lineClearance) {\n      lineClearance = (lineClearance + delimDepth - inner.height - inner.depth) / 2;\n    } // Shift the sqrt image\n\n\n    const imgShift = img.height - inner.height - lineClearance - ruleWidth;\n    inner.style.paddingLeft = makeEm(advanceWidth); // Overlay the image and the argument.\n\n    const body = buildCommon.makeVList({\n      positionType: \"firstBaseline\",\n      children: [{\n        type: \"elem\",\n        elem: inner,\n        wrapperClasses: [\"svg-align\"]\n      }, {\n        type: \"kern\",\n        size: -(inner.height + imgShift)\n      }, {\n        type: \"elem\",\n        elem: img\n      }, {\n        type: \"kern\",\n        size: ruleWidth\n      }]\n    }, options);\n\n    if (!group.index) {\n      return buildCommon.makeSpan([\"mord\", \"sqrt\"], [body], options);\n    } else {\n      // Handle the optional root index\n      // The index is always in scriptscript style\n      const newOptions = options.havingStyle(src_Style.SCRIPTSCRIPT);\n      const rootm = buildGroup(group.index, newOptions, options); // The amount the index is shifted by. This is taken from the TeX\n      // source, in the definition of `\\r@@t`.\n\n      const toShift = 0.6 * (body.height - body.depth); // Build a VList with the superscript shifted up correctly\n\n      const rootVList = buildCommon.makeVList({\n        positionType: \"shift\",\n        positionData: -toShift,\n        children: [{\n          type: \"elem\",\n          elem: rootm\n        }]\n      }, options); // Add a class surrounding it so we can add on the appropriate\n      // kerning\n\n      const rootVListWrap = buildCommon.makeSpan([\"root\"], [rootVList]);\n      return buildCommon.makeSpan([\"mord\", \"sqrt\"], [rootVListWrap, body], options);\n    }\n  },\n\n  mathmlBuilder(group, options) {\n    const {\n      body,\n      index\n    } = group;\n    return index ? new mathMLTree.MathNode(\"mroot\", [buildMathML_buildGroup(body, options), buildMathML_buildGroup(index, options)]) : new mathMLTree.MathNode(\"msqrt\", [buildMathML_buildGroup(body, options)]);\n  }\n\n});\n;// CONCATENATED MODULE: ./src/functions/styling.js\n\n\n\n\n\nconst styling_styleMap = {\n  \"display\": src_Style.DISPLAY,\n  \"text\": src_Style.TEXT,\n  \"script\": src_Style.SCRIPT,\n  \"scriptscript\": src_Style.SCRIPTSCRIPT\n};\ndefineFunction({\n  type: \"styling\",\n  names: [\"\\\\displaystyle\", \"\\\\textstyle\", \"\\\\scriptstyle\", \"\\\\scriptscriptstyle\"],\n  props: {\n    numArgs: 0,\n    allowedInText: true,\n    primitive: true\n  },\n\n  handler(_ref, args) {\n    let {\n      breakOnTokenText,\n      funcName,\n      parser\n    } = _ref;\n    // parse out the implicit body\n    const body = parser.parseExpression(true, breakOnTokenText); // TODO: Refactor to avoid duplicating styleMap in multiple places (e.g.\n    // here and in buildHTML and de-dupe the enumeration of all the styles).\n    // $FlowFixMe: The names above exactly match the styles.\n\n    const style = funcName.slice(1, funcName.length - 5);\n    return {\n      type: \"styling\",\n      mode: parser.mode,\n      // Figure out what style to use by pulling out the style from\n      // the function name\n      style,\n      body\n    };\n  },\n\n  htmlBuilder(group, options) {\n    // Style changes are handled in the TeXbook on pg. 442, Rule 3.\n    const newStyle = styling_styleMap[group.style];\n    const newOptions = options.havingStyle(newStyle).withFont('');\n    return sizingGroup(group.body, newOptions, options);\n  },\n\n  mathmlBuilder(group, options) {\n    // Figure out what style we're changing to.\n    const newStyle = styling_styleMap[group.style];\n    const newOptions = options.havingStyle(newStyle);\n    const inner = buildMathML_buildExpression(group.body, newOptions);\n    const node = new mathMLTree.MathNode(\"mstyle\", inner);\n    const styleAttributes = {\n      \"display\": [\"0\", \"true\"],\n      \"text\": [\"0\", \"false\"],\n      \"script\": [\"1\", \"false\"],\n      \"scriptscript\": [\"2\", \"false\"]\n    };\n    const attr = styleAttributes[group.style];\n    node.setAttribute(\"scriptlevel\", attr[0]);\n    node.setAttribute(\"displaystyle\", attr[1]);\n    return node;\n  }\n\n});\n;// CONCATENATED MODULE: ./src/functions/supsub.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Sometimes, groups perform special rules when they have superscripts or\n * subscripts attached to them. This function lets the `supsub` group know that\n * Sometimes, groups perform special rules when they have superscripts or\n * its inner element should handle the superscripts and subscripts instead of\n * handling them itself.\n */\nconst htmlBuilderDelegate = function (group, options) {\n  const base = group.base;\n\n  if (!base) {\n    return null;\n  } else if (base.type === \"op\") {\n    // Operators handle supsubs differently when they have limits\n    // (e.g. `\\displaystyle\\sum_2^3`)\n    const delegate = base.limits && (options.style.size === src_Style.DISPLAY.size || base.alwaysHandleSupSub);\n    return delegate ? op_htmlBuilder : null;\n  } else if (base.type === \"operatorname\") {\n    const delegate = base.alwaysHandleSupSub && (options.style.size === src_Style.DISPLAY.size || base.limits);\n    return delegate ? operatorname_htmlBuilder : null;\n  } else if (base.type === \"accent\") {\n    return utils.isCharacterBox(base.base) ? htmlBuilder : null;\n  } else if (base.type === \"horizBrace\") {\n    const isSup = !group.sub;\n    return isSup === base.isOver ? horizBrace_htmlBuilder : null;\n  } else {\n    return null;\n  }\n}; // Super scripts and subscripts, whose precise placement can depend on other\n// functions that precede them.\n\n\ndefineFunctionBuilders({\n  type: \"supsub\",\n\n  htmlBuilder(group, options) {\n    // Superscript and subscripts are handled in the TeXbook on page\n    // 445-446, rules 18(a-f).\n    // Here is where we defer to the inner group if it should handle\n    // superscripts and subscripts itself.\n    const builderDelegate = htmlBuilderDelegate(group, options);\n\n    if (builderDelegate) {\n      return builderDelegate(group, options);\n    }\n\n    const {\n      base: valueBase,\n      sup: valueSup,\n      sub: valueSub\n    } = group;\n    const base = buildGroup(valueBase, options);\n    let supm;\n    let subm;\n    const metrics = options.fontMetrics(); // Rule 18a\n\n    let supShift = 0;\n    let subShift = 0;\n    const isCharacterBox = valueBase && utils.isCharacterBox(valueBase);\n\n    if (valueSup) {\n      const newOptions = options.havingStyle(options.style.sup());\n      supm = buildGroup(valueSup, newOptions, options);\n\n      if (!isCharacterBox) {\n        supShift = base.height - newOptions.fontMetrics().supDrop * newOptions.sizeMultiplier / options.sizeMultiplier;\n      }\n    }\n\n    if (valueSub) {\n      const newOptions = options.havingStyle(options.style.sub());\n      subm = buildGroup(valueSub, newOptions, options);\n\n      if (!isCharacterBox) {\n        subShift = base.depth + newOptions.fontMetrics().subDrop * newOptions.sizeMultiplier / options.sizeMultiplier;\n      }\n    } // Rule 18c\n\n\n    let minSupShift;\n\n    if (options.style === src_Style.DISPLAY) {\n      minSupShift = metrics.sup1;\n    } else if (options.style.cramped) {\n      minSupShift = metrics.sup3;\n    } else {\n      minSupShift = metrics.sup2;\n    } // scriptspace is a font-size-independent size, so scale it\n    // appropriately for use as the marginRight.\n\n\n    const multiplier = options.sizeMultiplier;\n    const marginRight = makeEm(0.5 / metrics.ptPerEm / multiplier);\n    let marginLeft = null;\n\n    if (subm) {\n      // Subscripts shouldn't be shifted by the base's italic correction.\n      // Account for that by shifting the subscript back the appropriate\n      // amount. Note we only do this when the base is a single symbol.\n      const isOiint = group.base && group.base.type === \"op\" && group.base.name && (group.base.name === \"\\\\oiint\" || group.base.name === \"\\\\oiiint\");\n\n      if (base instanceof SymbolNode || isOiint) {\n        // $FlowFixMe\n        marginLeft = makeEm(-base.italic);\n      }\n    }\n\n    let supsub;\n\n    if (supm && subm) {\n      supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);\n      subShift = Math.max(subShift, metrics.sub2);\n      const ruleWidth = metrics.defaultRuleThickness; // Rule 18e\n\n      const maxWidth = 4 * ruleWidth;\n\n      if (supShift - supm.depth - (subm.height - subShift) < maxWidth) {\n        subShift = maxWidth - (supShift - supm.depth) + subm.height;\n        const psi = 0.8 * metrics.xHeight - (supShift - supm.depth);\n\n        if (psi > 0) {\n          supShift += psi;\n          subShift -= psi;\n        }\n      }\n\n      const vlistElem = [{\n        type: \"elem\",\n        elem: subm,\n        shift: subShift,\n        marginRight,\n        marginLeft\n      }, {\n        type: \"elem\",\n        elem: supm,\n        shift: -supShift,\n        marginRight\n      }];\n      supsub = buildCommon.makeVList({\n        positionType: \"individualShift\",\n        children: vlistElem\n      }, options);\n    } else if (subm) {\n      // Rule 18b\n      subShift = Math.max(subShift, metrics.sub1, subm.height - 0.8 * metrics.xHeight);\n      const vlistElem = [{\n        type: \"elem\",\n        elem: subm,\n        marginLeft,\n        marginRight\n      }];\n      supsub = buildCommon.makeVList({\n        positionType: \"shift\",\n        positionData: subShift,\n        children: vlistElem\n      }, options);\n    } else if (supm) {\n      // Rule 18c, d\n      supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);\n      supsub = buildCommon.makeVList({\n        positionType: \"shift\",\n        positionData: -supShift,\n        children: [{\n          type: \"elem\",\n          elem: supm,\n          marginRight\n        }]\n      }, options);\n    } else {\n      throw new Error(\"supsub must have either sup or sub.\");\n    } // Wrap the supsub vlist in a span.msupsub to reset text-align.\n\n\n    const mclass = getTypeOfDomTree(base, \"right\") || \"mord\";\n    return buildCommon.makeSpan([mclass], [base, buildCommon.makeSpan([\"msupsub\"], [supsub])], options);\n  },\n\n  mathmlBuilder(group, options) {\n    // Is the inner group a relevant horizonal brace?\n    let isBrace = false;\n    let isOver;\n    let isSup;\n\n    if (group.base && group.base.type === \"horizBrace\") {\n      isSup = !!group.sup;\n\n      if (isSup === group.base.isOver) {\n        isBrace = true;\n        isOver = group.base.isOver;\n      }\n    }\n\n    if (group.base && (group.base.type === \"op\" || group.base.type === \"operatorname\")) {\n      group.base.parentIsSupSub = true;\n    }\n\n    const children = [buildMathML_buildGroup(group.base, options)];\n\n    if (group.sub) {\n      children.push(buildMathML_buildGroup(group.sub, options));\n    }\n\n    if (group.sup) {\n      children.push(buildMathML_buildGroup(group.sup, options));\n    }\n\n    let nodeType;\n\n    if (isBrace) {\n      nodeType = isOver ? \"mover\" : \"munder\";\n    } else if (!group.sub) {\n      const base = group.base;\n\n      if (base && base.type === \"op\" && base.limits && (options.style === src_Style.DISPLAY || base.alwaysHandleSupSub)) {\n        nodeType = \"mover\";\n      } else if (base && base.type === \"operatorname\" && base.alwaysHandleSupSub && (base.limits || options.style === src_Style.DISPLAY)) {\n        nodeType = \"mover\";\n      } else {\n        nodeType = \"msup\";\n      }\n    } else if (!group.sup) {\n      const base = group.base;\n\n      if (base && base.type === \"op\" && base.limits && (options.style === src_Style.DISPLAY || base.alwaysHandleSupSub)) {\n        nodeType = \"munder\";\n      } else if (base && base.type === \"operatorname\" && base.alwaysHandleSupSub && (base.limits || options.style === src_Style.DISPLAY)) {\n        nodeType = \"munder\";\n      } else {\n        nodeType = \"msub\";\n      }\n    } else {\n      const base = group.base;\n\n      if (base && base.type === \"op\" && base.limits && options.style === src_Style.DISPLAY) {\n        nodeType = \"munderover\";\n      } else if (base && base.type === \"operatorname\" && base.alwaysHandleSupSub && (options.style === src_Style.DISPLAY || base.limits)) {\n        nodeType = \"munderover\";\n      } else {\n        nodeType = \"msubsup\";\n      }\n    }\n\n    return new mathMLTree.MathNode(nodeType, children);\n  }\n\n});\n;// CONCATENATED MODULE: ./src/functions/symbolsOp.js\n\n\n\n // Operator ParseNodes created in Parser.js from symbol Groups in src/symbols.js.\n\ndefineFunctionBuilders({\n  type: \"atom\",\n\n  htmlBuilder(group, options) {\n    return buildCommon.mathsym(group.text, group.mode, options, [\"m\" + group.family]);\n  },\n\n  mathmlBuilder(group, options) {\n    const node = new mathMLTree.MathNode(\"mo\", [makeText(group.text, group.mode)]);\n\n    if (group.family === \"bin\") {\n      const variant = getVariant(group, options);\n\n      if (variant === \"bold-italic\") {\n        node.setAttribute(\"mathvariant\", variant);\n      }\n    } else if (group.family === \"punct\") {\n      node.setAttribute(\"separator\", \"true\");\n    } else if (group.family === \"open\" || group.family === \"close\") {\n      // Delims built here should not stretch vertically.\n      // See delimsizing.js for stretchy delims.\n      node.setAttribute(\"stretchy\", \"false\");\n    }\n\n    return node;\n  }\n\n});\n;// CONCATENATED MODULE: ./src/functions/symbolsOrd.js\n\n\n\n\n// \"mathord\" and \"textord\" ParseNodes created in Parser.js from symbol Groups in\n// src/symbols.js.\nconst defaultVariant = {\n  \"mi\": \"italic\",\n  \"mn\": \"normal\",\n  \"mtext\": \"normal\"\n};\ndefineFunctionBuilders({\n  type: \"mathord\",\n\n  htmlBuilder(group, options) {\n    return buildCommon.makeOrd(group, options, \"mathord\");\n  },\n\n  mathmlBuilder(group, options) {\n    const node = new mathMLTree.MathNode(\"mi\", [makeText(group.text, group.mode, options)]);\n    const variant = getVariant(group, options) || \"italic\";\n\n    if (variant !== defaultVariant[node.type]) {\n      node.setAttribute(\"mathvariant\", variant);\n    }\n\n    return node;\n  }\n\n});\ndefineFunctionBuilders({\n  type: \"textord\",\n\n  htmlBuilder(group, options) {\n    return buildCommon.makeOrd(group, options, \"textord\");\n  },\n\n  mathmlBuilder(group, options) {\n    const text = makeText(group.text, group.mode, options);\n    const variant = getVariant(group, options) || \"normal\";\n    let node;\n\n    if (group.mode === 'text') {\n      node = new mathMLTree.MathNode(\"mtext\", [text]);\n    } else if (/[0-9]/.test(group.text)) {\n      node = new mathMLTree.MathNode(\"mn\", [text]);\n    } else if (group.text === \"\\\\prime\") {\n      node = new mathMLTree.MathNode(\"mo\", [text]);\n    } else {\n      node = new mathMLTree.MathNode(\"mi\", [text]);\n    }\n\n    if (variant !== defaultVariant[node.type]) {\n      node.setAttribute(\"mathvariant\", variant);\n    }\n\n    return node;\n  }\n\n});\n;// CONCATENATED MODULE: ./src/functions/symbolsSpacing.js\n\n\n\n // A map of CSS-based spacing functions to their CSS class.\n\nconst cssSpace = {\n  \"\\\\nobreak\": \"nobreak\",\n  \"\\\\allowbreak\": \"allowbreak\"\n}; // A lookup table to determine whether a spacing function/symbol should be\n// treated like a regular space character.  If a symbol or command is a key\n// in this table, then it should be a regular space character.  Furthermore,\n// the associated value may have a `className` specifying an extra CSS class\n// to add to the created `span`.\n\nconst regularSpace = {\n  \" \": {},\n  \"\\\\ \": {},\n  \"~\": {\n    className: \"nobreak\"\n  },\n  \"\\\\space\": {},\n  \"\\\\nobreakspace\": {\n    className: \"nobreak\"\n  }\n}; // ParseNode<\"spacing\"> created in Parser.js from the \"spacing\" symbol Groups in\n// src/symbols.js.\n\ndefineFunctionBuilders({\n  type: \"spacing\",\n\n  htmlBuilder(group, options) {\n    if (regularSpace.hasOwnProperty(group.text)) {\n      const className = regularSpace[group.text].className || \"\"; // Spaces are generated by adding an actual space. Each of these\n      // things has an entry in the symbols table, so these will be turned\n      // into appropriate outputs.\n\n      if (group.mode === \"text\") {\n        const ord = buildCommon.makeOrd(group, options, \"textord\");\n        ord.classes.push(className);\n        return ord;\n      } else {\n        return buildCommon.makeSpan([\"mspace\", className], [buildCommon.mathsym(group.text, group.mode, options)], options);\n      }\n    } else if (cssSpace.hasOwnProperty(group.text)) {\n      // Spaces based on just a CSS class.\n      return buildCommon.makeSpan([\"mspace\", cssSpace[group.text]], [], options);\n    } else {\n      throw new src_ParseError(\"Unknown type of space \\\"\" + group.text + \"\\\"\");\n    }\n  },\n\n  mathmlBuilder(group, options) {\n    let node;\n\n    if (regularSpace.hasOwnProperty(group.text)) {\n      node = new mathMLTree.MathNode(\"mtext\", [new mathMLTree.TextNode(\"\\u00a0\")]);\n    } else if (cssSpace.hasOwnProperty(group.text)) {\n      // CSS-based MathML spaces (\\nobreak, \\allowbreak) are ignored\n      return new mathMLTree.MathNode(\"mspace\");\n    } else {\n      throw new src_ParseError(\"Unknown type of space \\\"\" + group.text + \"\\\"\");\n    }\n\n    return node;\n  }\n\n});\n;// CONCATENATED MODULE: ./src/functions/tag.js\n\n\n\n\nconst pad = () => {\n  const padNode = new mathMLTree.MathNode(\"mtd\", []);\n  padNode.setAttribute(\"width\", \"50%\");\n  return padNode;\n};\n\ndefineFunctionBuilders({\n  type: \"tag\",\n\n  mathmlBuilder(group, options) {\n    const table = new mathMLTree.MathNode(\"mtable\", [new mathMLTree.MathNode(\"mtr\", [pad(), new mathMLTree.MathNode(\"mtd\", [buildExpressionRow(group.body, options)]), pad(), new mathMLTree.MathNode(\"mtd\", [buildExpressionRow(group.tag, options)])])]);\n    table.setAttribute(\"width\", \"100%\");\n    return table; // TODO: Left-aligned tags.\n    // Currently, the group and options passed here do not contain\n    // enough info to set tag alignment. `leqno` is in Settings but it is\n    // not passed to Options. On the HTML side, leqno is\n    // set by a CSS class applied in buildTree.js. That would have worked\n    // in MathML if browsers supported <mlabeledtr>. Since they don't, we\n    // need to rewrite the way this function is called.\n  }\n\n});\n;// CONCATENATED MODULE: ./src/functions/text.js\n\n\n\n // Non-mathy text, possibly in a font\n\nconst textFontFamilies = {\n  \"\\\\text\": undefined,\n  \"\\\\textrm\": \"textrm\",\n  \"\\\\textsf\": \"textsf\",\n  \"\\\\texttt\": \"texttt\",\n  \"\\\\textnormal\": \"textrm\"\n};\nconst textFontWeights = {\n  \"\\\\textbf\": \"textbf\",\n  \"\\\\textmd\": \"textmd\"\n};\nconst textFontShapes = {\n  \"\\\\textit\": \"textit\",\n  \"\\\\textup\": \"textup\"\n};\n\nconst optionsWithFont = (group, options) => {\n  const font = group.font; // Checks if the argument is a font family or a font style.\n\n  if (!font) {\n    return options;\n  } else if (textFontFamilies[font]) {\n    return options.withTextFontFamily(textFontFamilies[font]);\n  } else if (textFontWeights[font]) {\n    return options.withTextFontWeight(textFontWeights[font]);\n  } else if (font === \"\\\\emph\") {\n    return options.fontShape === \"textit\" ? options.withTextFontShape(\"textup\") : options.withTextFontShape(\"textit\");\n  }\n\n  return options.withTextFontShape(textFontShapes[font]);\n};\n\ndefineFunction({\n  type: \"text\",\n  names: [// Font families\n  \"\\\\text\", \"\\\\textrm\", \"\\\\textsf\", \"\\\\texttt\", \"\\\\textnormal\", // Font weights\n  \"\\\\textbf\", \"\\\\textmd\", // Font Shapes\n  \"\\\\textit\", \"\\\\textup\", \"\\\\emph\"],\n  props: {\n    numArgs: 1,\n    argTypes: [\"text\"],\n    allowedInArgument: true,\n    allowedInText: true\n  },\n\n  handler(_ref, args) {\n    let {\n      parser,\n      funcName\n    } = _ref;\n    const body = args[0];\n    return {\n      type: \"text\",\n      mode: parser.mode,\n      body: ordargument(body),\n      font: funcName\n    };\n  },\n\n  htmlBuilder(group, options) {\n    const newOptions = optionsWithFont(group, options);\n    const inner = buildExpression(group.body, newOptions, true);\n    return buildCommon.makeSpan([\"mord\", \"text\"], inner, newOptions);\n  },\n\n  mathmlBuilder(group, options) {\n    const newOptions = optionsWithFont(group, options);\n    return buildExpressionRow(group.body, newOptions);\n  }\n\n});\n;// CONCATENATED MODULE: ./src/functions/underline.js\n\n\n\n\n\ndefineFunction({\n  type: \"underline\",\n  names: [\"\\\\underline\"],\n  props: {\n    numArgs: 1,\n    allowedInText: true\n  },\n\n  handler(_ref, args) {\n    let {\n      parser\n    } = _ref;\n    return {\n      type: \"underline\",\n      mode: parser.mode,\n      body: args[0]\n    };\n  },\n\n  htmlBuilder(group, options) {\n    // Underlines are handled in the TeXbook pg 443, Rule 10.\n    // Build the inner group.\n    const innerGroup = buildGroup(group.body, options); // Create the line to go below the body\n\n    const line = buildCommon.makeLineSpan(\"underline-line\", options); // Generate the vlist, with the appropriate kerns\n\n    const defaultRuleThickness = options.fontMetrics().defaultRuleThickness;\n    const vlist = buildCommon.makeVList({\n      positionType: \"top\",\n      positionData: innerGroup.height,\n      children: [{\n        type: \"kern\",\n        size: defaultRuleThickness\n      }, {\n        type: \"elem\",\n        elem: line\n      }, {\n        type: \"kern\",\n        size: 3 * defaultRuleThickness\n      }, {\n        type: \"elem\",\n        elem: innerGroup\n      }]\n    }, options);\n    return buildCommon.makeSpan([\"mord\", \"underline\"], [vlist], options);\n  },\n\n  mathmlBuilder(group, options) {\n    const operator = new mathMLTree.MathNode(\"mo\", [new mathMLTree.TextNode(\"\\u203e\")]);\n    operator.setAttribute(\"stretchy\", \"true\");\n    const node = new mathMLTree.MathNode(\"munder\", [buildMathML_buildGroup(group.body, options), operator]);\n    node.setAttribute(\"accentunder\", \"true\");\n    return node;\n  }\n\n});\n;// CONCATENATED MODULE: ./src/functions/vcenter.js\n\n\n\n\n // \\vcenter:  Vertically center the argument group on the math axis.\n\ndefineFunction({\n  type: \"vcenter\",\n  names: [\"\\\\vcenter\"],\n  props: {\n    numArgs: 1,\n    argTypes: [\"original\"],\n    // In LaTeX, \\vcenter can act only on a box.\n    allowedInText: false\n  },\n\n  handler(_ref, args) {\n    let {\n      parser\n    } = _ref;\n    return {\n      type: \"vcenter\",\n      mode: parser.mode,\n      body: args[0]\n    };\n  },\n\n  htmlBuilder(group, options) {\n    const body = buildGroup(group.body, options);\n    const axisHeight = options.fontMetrics().axisHeight;\n    const dy = 0.5 * (body.height - axisHeight - (body.depth + axisHeight));\n    return buildCommon.makeVList({\n      positionType: \"shift\",\n      positionData: dy,\n      children: [{\n        type: \"elem\",\n        elem: body\n      }]\n    }, options);\n  },\n\n  mathmlBuilder(group, options) {\n    // There is no way to do this in MathML.\n    // Write a class as a breadcrumb in case some post-processor wants\n    // to perform a vcenter adjustment.\n    return new mathMLTree.MathNode(\"mpadded\", [buildMathML_buildGroup(group.body, options)], [\"vcenter\"]);\n  }\n\n});\n;// CONCATENATED MODULE: ./src/functions/verb.js\n\n\n\n\ndefineFunction({\n  type: \"verb\",\n  names: [\"\\\\verb\"],\n  props: {\n    numArgs: 0,\n    allowedInText: true\n  },\n\n  handler(context, args, optArgs) {\n    // \\verb and \\verb* are dealt with directly in Parser.js.\n    // If we end up here, it's because of a failure to match the two delimiters\n    // in the regex in Lexer.js.  LaTeX raises the following error when \\verb is\n    // terminated by end of line (or file).\n    throw new src_ParseError(\"\\\\verb ended by end of line instead of matching delimiter\");\n  },\n\n  htmlBuilder(group, options) {\n    const text = makeVerb(group);\n    const body = []; // \\verb enters text mode and therefore is sized like \\textstyle\n\n    const newOptions = options.havingStyle(options.style.text());\n\n    for (let i = 0; i < text.length; i++) {\n      let c = text[i];\n\n      if (c === '~') {\n        c = '\\\\textasciitilde';\n      }\n\n      body.push(buildCommon.makeSymbol(c, \"Typewriter-Regular\", group.mode, newOptions, [\"mord\", \"texttt\"]));\n    }\n\n    return buildCommon.makeSpan([\"mord\", \"text\"].concat(newOptions.sizingClasses(options)), buildCommon.tryCombineChars(body), newOptions);\n  },\n\n  mathmlBuilder(group, options) {\n    const text = new mathMLTree.TextNode(makeVerb(group));\n    const node = new mathMLTree.MathNode(\"mtext\", [text]);\n    node.setAttribute(\"mathvariant\", \"monospace\");\n    return node;\n  }\n\n});\n/**\n * Converts verb group into body string.\n *\n * \\verb* replaces each space with an open box \\u2423\n * \\verb replaces each space with a no-break space \\xA0\n */\n\nconst makeVerb = group => group.body.replace(/ /g, group.star ? '\\u2423' : '\\xA0');\n;// CONCATENATED MODULE: ./src/functions.js\n/** Include this to ensure that all functions are defined. */\n\nconst functions = _functions;\n/* harmony default export */ var src_functions = (functions); // TODO(kevinb): have functions return an object and call defineFunction with\n// that object in this file instead of relying on side-effects.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n;// CONCATENATED MODULE: ./src/Lexer.js\n/**\n * The Lexer class handles tokenizing the input in various ways. Since our\n * parser expects us to be able to backtrack, the lexer allows lexing from any\n * given starting point.\n *\n * Its main exposed function is the `lex` function, which takes a position to\n * lex from and a type of token to lex. It defers to the appropriate `_innerLex`\n * function.\n *\n * The various `_innerLex` functions perform the actual lexing of different\n * kinds.\n */\n\n\n\n\n/* The following tokenRegex\n * - matches typical whitespace (but not NBSP etc.) using its first group\n * - does not match any control character \\x00-\\x1f except whitespace\n * - does not match a bare backslash\n * - matches any ASCII character except those just mentioned\n * - does not match the BMP private use area \\uE000-\\uF8FF\n * - does not match bare surrogate code units\n * - matches any BMP character except for those just described\n * - matches any valid Unicode surrogate pair\n * - matches a backslash followed by one or more whitespace characters\n * - matches a backslash followed by one or more letters then whitespace\n * - matches a backslash followed by any BMP character\n * Capturing groups:\n *   [1] regular whitespace\n *   [2] backslash followed by whitespace\n *   [3] anything else, which may include:\n *     [4] left character of \\verb*\n *     [5] left character of \\verb\n *     [6] backslash followed by word, excluding any trailing whitespace\n * Just because the Lexer matches something doesn't mean it's valid input:\n * If there is no matching function or symbol definition, the Parser will\n * still reject the input.\n */\nconst spaceRegexString = \"[ \\r\\n\\t]\";\nconst controlWordRegexString = \"\\\\\\\\[a-zA-Z@]+\";\nconst controlSymbolRegexString = \"\\\\\\\\[^\\uD800-\\uDFFF]\";\nconst controlWordWhitespaceRegexString = \"(\" + controlWordRegexString + \")\" + spaceRegexString + \"*\";\nconst controlSpaceRegexString = \"\\\\\\\\(\\n|[ \\r\\t]+\\n?)[ \\r\\t]*\";\nconst combiningDiacriticalMarkString = \"[\\u0300-\\u036f]\";\nconst combiningDiacriticalMarksEndRegex = new RegExp(combiningDiacriticalMarkString + \"+$\");\nconst tokenRegexString = \"(\" + spaceRegexString + \"+)|\" + ( // whitespace\ncontrolSpaceRegexString + \"|\") + // \\whitespace\n\"([!-\\\\[\\\\]-\\u2027\\u202A-\\uD7FF\\uF900-\\uFFFF]\" + ( // single codepoint\ncombiningDiacriticalMarkString + \"*\") + // ...plus accents\n\"|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]\" + ( // surrogate pair\ncombiningDiacriticalMarkString + \"*\") + // ...plus accents\n\"|\\\\\\\\verb\\\\*([^]).*?\\\\4\" + // \\verb*\n\"|\\\\\\\\verb([^*a-zA-Z]).*?\\\\5\" + ( // \\verb unstarred\n\"|\" + controlWordWhitespaceRegexString) + ( // \\macroName + spaces\n\"|\" + controlSymbolRegexString + \")\"); // \\\\, \\', etc.\n\n/** Main Lexer class */\n\nclass Lexer {\n  // Category codes. The lexer only supports comment characters (14) for now.\n  // MacroExpander additionally distinguishes active (13).\n  constructor(input, settings) {\n    this.input = void 0;\n    this.settings = void 0;\n    this.tokenRegex = void 0;\n    this.catcodes = void 0;\n    // Separate accents from characters\n    this.input = input;\n    this.settings = settings;\n    this.tokenRegex = new RegExp(tokenRegexString, 'g');\n    this.catcodes = {\n      \"%\": 14,\n      // comment character\n      \"~\": 13 // active character\n\n    };\n  }\n\n  setCatcode(char, code) {\n    this.catcodes[char] = code;\n  }\n  /**\n   * This function lexes a single token.\n   */\n\n\n  lex() {\n    const input = this.input;\n    const pos = this.tokenRegex.lastIndex;\n\n    if (pos === input.length) {\n      return new Token(\"EOF\", new SourceLocation(this, pos, pos));\n    }\n\n    const match = this.tokenRegex.exec(input);\n\n    if (match === null || match.index !== pos) {\n      throw new src_ParseError(\"Unexpected character: '\" + input[pos] + \"'\", new Token(input[pos], new SourceLocation(this, pos, pos + 1)));\n    }\n\n    const text = match[6] || match[3] || (match[2] ? \"\\\\ \" : \" \");\n\n    if (this.catcodes[text] === 14) {\n      // comment character\n      const nlIndex = input.indexOf('\\n', this.tokenRegex.lastIndex);\n\n      if (nlIndex === -1) {\n        this.tokenRegex.lastIndex = input.length; // EOF\n\n        this.settings.reportNonstrict(\"commentAtEnd\", \"% comment has no terminating newline; LaTeX would \" + \"fail because of commenting the end of math mode (e.g. $)\");\n      } else {\n        this.tokenRegex.lastIndex = nlIndex + 1;\n      }\n\n      return this.lex();\n    }\n\n    return new Token(text, new SourceLocation(this, pos, this.tokenRegex.lastIndex));\n  }\n\n}\n;// CONCATENATED MODULE: ./src/Namespace.js\n/**\n * A `Namespace` refers to a space of nameable things like macros or lengths,\n * which can be `set` either globally or local to a nested group, using an\n * undo stack similar to how TeX implements this functionality.\n * Performance-wise, `get` and local `set` take constant time, while global\n * `set` takes time proportional to the depth of group nesting.\n */\n\nclass Namespace {\n  /**\n   * Both arguments are optional.  The first argument is an object of\n   * built-in mappings which never change.  The second argument is an object\n   * of initial (global-level) mappings, which will constantly change\n   * according to any global/top-level `set`s done.\n   */\n  constructor(builtins, globalMacros) {\n    if (builtins === void 0) {\n      builtins = {};\n    }\n\n    if (globalMacros === void 0) {\n      globalMacros = {};\n    }\n\n    this.current = void 0;\n    this.builtins = void 0;\n    this.undefStack = void 0;\n    this.current = globalMacros;\n    this.builtins = builtins;\n    this.undefStack = [];\n  }\n  /**\n   * Start a new nested group, affecting future local `set`s.\n   */\n\n\n  beginGroup() {\n    this.undefStack.push({});\n  }\n  /**\n   * End current nested group, restoring values before the group began.\n   */\n\n\n  endGroup() {\n    if (this.undefStack.length === 0) {\n      throw new src_ParseError(\"Unbalanced namespace destruction: attempt \" + \"to pop global namespace; please report this as a bug\");\n    }\n\n    const undefs = this.undefStack.pop();\n\n    for (const undef in undefs) {\n      if (undefs.hasOwnProperty(undef)) {\n        if (undefs[undef] == null) {\n          delete this.current[undef];\n        } else {\n          this.current[undef] = undefs[undef];\n        }\n      }\n    }\n  }\n  /**\n   * Ends all currently nested groups (if any), restoring values before the\n   * groups began.  Useful in case of an error in the middle of parsing.\n   */\n\n\n  endGroups() {\n    while (this.undefStack.length > 0) {\n      this.endGroup();\n    }\n  }\n  /**\n   * Detect whether `name` has a definition.  Equivalent to\n   * `get(name) != null`.\n   */\n\n\n  has(name) {\n    return this.current.hasOwnProperty(name) || this.builtins.hasOwnProperty(name);\n  }\n  /**\n   * Get the current value of a name, or `undefined` if there is no value.\n   *\n   * Note: Do not use `if (namespace.get(...))` to detect whether a macro\n   * is defined, as the definition may be the empty string which evaluates\n   * to `false` in JavaScript.  Use `if (namespace.get(...) != null)` or\n   * `if (namespace.has(...))`.\n   */\n\n\n  get(name) {\n    if (this.current.hasOwnProperty(name)) {\n      return this.current[name];\n    } else {\n      return this.builtins[name];\n    }\n  }\n  /**\n   * Set the current value of a name, and optionally set it globally too.\n   * Local set() sets the current value and (when appropriate) adds an undo\n   * operation to the undo stack.  Global set() may change the undo\n   * operation at every level, so takes time linear in their number.\n   * A value of undefined means to delete existing definitions.\n   */\n\n\n  set(name, value, global) {\n    if (global === void 0) {\n      global = false;\n    }\n\n    if (global) {\n      // Global set is equivalent to setting in all groups.  Simulate this\n      // by destroying any undos currently scheduled for this name,\n      // and adding an undo with the *new* value (in case it later gets\n      // locally reset within this environment).\n      for (let i = 0; i < this.undefStack.length; i++) {\n        delete this.undefStack[i][name];\n      }\n\n      if (this.undefStack.length > 0) {\n        this.undefStack[this.undefStack.length - 1][name] = value;\n      }\n    } else {\n      // Undo this set at end of this group (possibly to `undefined`),\n      // unless an undo is already in place, in which case that older\n      // value is the correct one.\n      const top = this.undefStack[this.undefStack.length - 1];\n\n      if (top && !top.hasOwnProperty(name)) {\n        top[name] = this.current[name];\n      }\n    }\n\n    if (value == null) {\n      delete this.current[name];\n    } else {\n      this.current[name] = value;\n    }\n  }\n\n}\n;// CONCATENATED MODULE: ./src/macros.js\n/**\n * Predefined macros for KaTeX.\n * This can be used to define some commands in terms of others.\n */\n// Export global macros object from defineMacro\n\nconst macros = _macros;\n/* harmony default export */ var src_macros = (macros);\n\n\n\n\n\n //////////////////////////////////////////////////////////////////////\n// macro tools\n\ndefineMacro(\"\\\\noexpand\", function (context) {\n  // The expansion is the token itself; but that token is interpreted\n  // as if its meaning were \\relax if it is a control sequence that\n  // would ordinarily be expanded by TeXs expansion rules.\n  const t = context.popToken();\n\n  if (context.isExpandable(t.text)) {\n    t.noexpand = true;\n    t.treatAsRelax = true;\n  }\n\n  return {\n    tokens: [t],\n    numArgs: 0\n  };\n});\ndefineMacro(\"\\\\expandafter\", function (context) {\n  // TeX first reads the token that comes immediately after \\expandafter,\n  // without expanding it; lets call this token t. Then TeX reads the\n  // token that comes after t (and possibly more tokens, if that token\n  // has an argument), replacing it by its expansion. Finally TeX puts\n  // t back in front of that expansion.\n  const t = context.popToken();\n  context.expandOnce(true); // expand only an expandable token\n\n  return {\n    tokens: [t],\n    numArgs: 0\n  };\n}); // LaTeX's \\@firstoftwo{#1}{#2} expands to #1, skipping #2\n// TeX source: \\long\\def\\@firstoftwo#1#2{#1}\n\ndefineMacro(\"\\\\@firstoftwo\", function (context) {\n  const args = context.consumeArgs(2);\n  return {\n    tokens: args[0],\n    numArgs: 0\n  };\n}); // LaTeX's \\@secondoftwo{#1}{#2} expands to #2, skipping #1\n// TeX source: \\long\\def\\@secondoftwo#1#2{#2}\n\ndefineMacro(\"\\\\@secondoftwo\", function (context) {\n  const args = context.consumeArgs(2);\n  return {\n    tokens: args[1],\n    numArgs: 0\n  };\n}); // LaTeX's \\@ifnextchar{#1}{#2}{#3} looks ahead to the next (unexpanded)\n// symbol that isn't a space, consuming any spaces but not consuming the\n// first nonspace character.  If that nonspace character matches #1, then\n// the macro expands to #2; otherwise, it expands to #3.\n\ndefineMacro(\"\\\\@ifnextchar\", function (context) {\n  const args = context.consumeArgs(3); // symbol, if, else\n\n  context.consumeSpaces();\n  const nextToken = context.future();\n\n  if (args[0].length === 1 && args[0][0].text === nextToken.text) {\n    return {\n      tokens: args[1],\n      numArgs: 0\n    };\n  } else {\n    return {\n      tokens: args[2],\n      numArgs: 0\n    };\n  }\n}); // LaTeX's \\@ifstar{#1}{#2} looks ahead to the next (unexpanded) symbol.\n// If it is `*`, then it consumes the symbol, and the macro expands to #1;\n// otherwise, the macro expands to #2 (without consuming the symbol).\n// TeX source: \\def\\@ifstar#1{\\@ifnextchar *{\\@firstoftwo{#1}}}\n\ndefineMacro(\"\\\\@ifstar\", \"\\\\@ifnextchar *{\\\\@firstoftwo{#1}}\"); // LaTeX's \\TextOrMath{#1}{#2} expands to #1 in text mode, #2 in math mode\n\ndefineMacro(\"\\\\TextOrMath\", function (context) {\n  const args = context.consumeArgs(2);\n\n  if (context.mode === 'text') {\n    return {\n      tokens: args[0],\n      numArgs: 0\n    };\n  } else {\n    return {\n      tokens: args[1],\n      numArgs: 0\n    };\n  }\n}); // Lookup table for parsing numbers in base 8 through 16\n\nconst digitToNumber = {\n  \"0\": 0,\n  \"1\": 1,\n  \"2\": 2,\n  \"3\": 3,\n  \"4\": 4,\n  \"5\": 5,\n  \"6\": 6,\n  \"7\": 7,\n  \"8\": 8,\n  \"9\": 9,\n  \"a\": 10,\n  \"A\": 10,\n  \"b\": 11,\n  \"B\": 11,\n  \"c\": 12,\n  \"C\": 12,\n  \"d\": 13,\n  \"D\": 13,\n  \"e\": 14,\n  \"E\": 14,\n  \"f\": 15,\n  \"F\": 15\n}; // TeX \\char makes a literal character (catcode 12) using the following forms:\n// (see The TeXBook, p. 43)\n//   \\char123  -- decimal\n//   \\char'123 -- octal\n//   \\char\"123 -- hex\n//   \\char`x   -- character that can be written (i.e. isn't active)\n//   \\char`\\x  -- character that cannot be written (e.g. %)\n// These all refer to characters from the font, so we turn them into special\n// calls to a function \\@char dealt with in the Parser.\n\ndefineMacro(\"\\\\char\", function (context) {\n  let token = context.popToken();\n  let base;\n  let number = '';\n\n  if (token.text === \"'\") {\n    base = 8;\n    token = context.popToken();\n  } else if (token.text === '\"') {\n    base = 16;\n    token = context.popToken();\n  } else if (token.text === \"`\") {\n    token = context.popToken();\n\n    if (token.text[0] === \"\\\\\") {\n      number = token.text.charCodeAt(1);\n    } else if (token.text === \"EOF\") {\n      throw new src_ParseError(\"\\\\char` missing argument\");\n    } else {\n      number = token.text.charCodeAt(0);\n    }\n  } else {\n    base = 10;\n  }\n\n  if (base) {\n    // Parse a number in the given base, starting with first `token`.\n    number = digitToNumber[token.text];\n\n    if (number == null || number >= base) {\n      throw new src_ParseError(\"Invalid base-\" + base + \" digit \" + token.text);\n    }\n\n    let digit;\n\n    while ((digit = digitToNumber[context.future().text]) != null && digit < base) {\n      number *= base;\n      number += digit;\n      context.popToken();\n    }\n  }\n\n  return \"\\\\@char{\" + number + \"}\";\n}); // \\newcommand{\\macro}[args]{definition}\n// \\renewcommand{\\macro}[args]{definition}\n// TODO: Optional arguments: \\newcommand{\\macro}[args][default]{definition}\n\nconst newcommand = (context, existsOK, nonexistsOK) => {\n  let arg = context.consumeArg().tokens;\n\n  if (arg.length !== 1) {\n    throw new src_ParseError(\"\\\\newcommand's first argument must be a macro name\");\n  }\n\n  const name = arg[0].text;\n  const exists = context.isDefined(name);\n\n  if (exists && !existsOK) {\n    throw new src_ParseError(\"\\\\newcommand{\" + name + \"} attempting to redefine \" + (name + \"; use \\\\renewcommand\"));\n  }\n\n  if (!exists && !nonexistsOK) {\n    throw new src_ParseError(\"\\\\renewcommand{\" + name + \"} when command \" + name + \" \" + \"does not yet exist; use \\\\newcommand\");\n  }\n\n  let numArgs = 0;\n  arg = context.consumeArg().tokens;\n\n  if (arg.length === 1 && arg[0].text === \"[\") {\n    let argText = '';\n    let token = context.expandNextToken();\n\n    while (token.text !== \"]\" && token.text !== \"EOF\") {\n      // TODO: Should properly expand arg, e.g., ignore {}s\n      argText += token.text;\n      token = context.expandNextToken();\n    }\n\n    if (!argText.match(/^\\s*[0-9]+\\s*$/)) {\n      throw new src_ParseError(\"Invalid number of arguments: \" + argText);\n    }\n\n    numArgs = parseInt(argText);\n    arg = context.consumeArg().tokens;\n  } // Final arg is the expansion of the macro\n\n\n  context.macros.set(name, {\n    tokens: arg,\n    numArgs\n  });\n  return '';\n};\n\ndefineMacro(\"\\\\newcommand\", context => newcommand(context, false, true));\ndefineMacro(\"\\\\renewcommand\", context => newcommand(context, true, false));\ndefineMacro(\"\\\\providecommand\", context => newcommand(context, true, true)); // terminal (console) tools\n\ndefineMacro(\"\\\\message\", context => {\n  const arg = context.consumeArgs(1)[0]; // eslint-disable-next-line no-console\n\n  console.log(arg.reverse().map(token => token.text).join(\"\"));\n  return '';\n});\ndefineMacro(\"\\\\errmessage\", context => {\n  const arg = context.consumeArgs(1)[0]; // eslint-disable-next-line no-console\n\n  console.error(arg.reverse().map(token => token.text).join(\"\"));\n  return '';\n});\ndefineMacro(\"\\\\show\", context => {\n  const tok = context.popToken();\n  const name = tok.text; // eslint-disable-next-line no-console\n\n  console.log(tok, context.macros.get(name), src_functions[name], src_symbols.math[name], src_symbols.text[name]);\n  return '';\n}); //////////////////////////////////////////////////////////////////////\n// Grouping\n// \\let\\bgroup={ \\let\\egroup=}\n\ndefineMacro(\"\\\\bgroup\", \"{\");\ndefineMacro(\"\\\\egroup\", \"}\"); // Symbols from latex.ltx:\n// \\def~{\\nobreakspace{}}\n// \\def\\lq{`}\n// \\def\\rq{'}\n// \\def \\aa {\\r a}\n// \\def \\AA {\\r A}\n\ndefineMacro(\"~\", \"\\\\nobreakspace\");\ndefineMacro(\"\\\\lq\", \"`\");\ndefineMacro(\"\\\\rq\", \"'\");\ndefineMacro(\"\\\\aa\", \"\\\\r a\");\ndefineMacro(\"\\\\AA\", \"\\\\r A\"); // Copyright (C) and registered (R) symbols. Use raw symbol in MathML.\n// \\DeclareTextCommandDefault{\\textcopyright}{\\textcircled{c}}\n// \\DeclareTextCommandDefault{\\textregistered}{\\textcircled{%\n//      \\check@mathfonts\\fontsize\\sf@size\\z@\\math@fontsfalse\\selectfont R}}\n// \\DeclareRobustCommand{\\copyright}{%\n//    \\ifmmode{\\nfss@text{\\textcopyright}}\\else\\textcopyright\\fi}\n\ndefineMacro(\"\\\\textcopyright\", \"\\\\html@mathml{\\\\textcircled{c}}{\\\\char`}\");\ndefineMacro(\"\\\\copyright\", \"\\\\TextOrMath{\\\\textcopyright}{\\\\text{\\\\textcopyright}}\");\ndefineMacro(\"\\\\textregistered\", \"\\\\html@mathml{\\\\textcircled{\\\\scriptsize R}}{\\\\char`}\"); // Characters omitted from Unicode range 1D4001D7FF\n\ndefineMacro(\"\\u212C\", \"\\\\mathscr{B}\"); // script\n\ndefineMacro(\"\\u2130\", \"\\\\mathscr{E}\");\ndefineMacro(\"\\u2131\", \"\\\\mathscr{F}\");\ndefineMacro(\"\\u210B\", \"\\\\mathscr{H}\");\ndefineMacro(\"\\u2110\", \"\\\\mathscr{I}\");\ndefineMacro(\"\\u2112\", \"\\\\mathscr{L}\");\ndefineMacro(\"\\u2133\", \"\\\\mathscr{M}\");\ndefineMacro(\"\\u211B\", \"\\\\mathscr{R}\");\ndefineMacro(\"\\u212D\", \"\\\\mathfrak{C}\"); // Fraktur\n\ndefineMacro(\"\\u210C\", \"\\\\mathfrak{H}\");\ndefineMacro(\"\\u2128\", \"\\\\mathfrak{Z}\"); // Define \\Bbbk with a macro that works in both HTML and MathML.\n\ndefineMacro(\"\\\\Bbbk\", \"\\\\Bbb{k}\"); // Unicode middle dot\n// The KaTeX fonts do not contain U+00B7. Instead, \\cdotp displays\n// the dot at U+22C5 and gives it punct spacing.\n\ndefineMacro(\"\\u00b7\", \"\\\\cdotp\"); // \\llap and \\rlap render their contents in text mode\n\ndefineMacro(\"\\\\llap\", \"\\\\mathllap{\\\\textrm{#1}}\");\ndefineMacro(\"\\\\rlap\", \"\\\\mathrlap{\\\\textrm{#1}}\");\ndefineMacro(\"\\\\clap\", \"\\\\mathclap{\\\\textrm{#1}}\"); // \\mathstrut from the TeXbook, p 360\n\ndefineMacro(\"\\\\mathstrut\", \"\\\\vphantom{(}\"); // \\underbar from TeXbook p 353\n\ndefineMacro(\"\\\\underbar\", \"\\\\underline{\\\\text{#1}}\"); // \\not is defined by base/fontmath.ltx via\n// \\DeclareMathSymbol{\\not}{\\mathrel}{symbols}{\"36}\n// It's thus treated like a \\mathrel, but defined by a symbol that has zero\n// width but extends to the right.  We use \\rlap to get that spacing.\n// For MathML we write U+0338 here. buildMathML.js will then do the overlay.\n\ndefineMacro(\"\\\\not\", '\\\\html@mathml{\\\\mathrel{\\\\mathrlap\\\\@not}}{\\\\char\"338}'); // Negated symbols from base/fontmath.ltx:\n// \\def\\neq{\\not=} \\let\\ne=\\neq\n// \\DeclareRobustCommand\n//   \\notin{\\mathrel{\\m@th\\mathpalette\\c@ncel\\in}}\n// \\def\\c@ncel#1#2{\\m@th\\ooalign{$\\hfil#1\\mkern1mu/\\hfil$\\crcr$#1#2$}}\n\ndefineMacro(\"\\\\neq\", \"\\\\html@mathml{\\\\mathrel{\\\\not=}}{\\\\mathrel{\\\\char`}}\");\ndefineMacro(\"\\\\ne\", \"\\\\neq\");\ndefineMacro(\"\\u2260\", \"\\\\neq\");\ndefineMacro(\"\\\\notin\", \"\\\\html@mathml{\\\\mathrel{{\\\\in}\\\\mathllap{/\\\\mskip1mu}}}\" + \"{\\\\mathrel{\\\\char`}}\");\ndefineMacro(\"\\u2209\", \"\\\\notin\"); // Unicode stacked relations\n\ndefineMacro(\"\\u2258\", \"\\\\html@mathml{\" + \"\\\\mathrel{=\\\\kern{-1em}\\\\raisebox{0.4em}{$\\\\scriptsize\\\\frown$}}\" + \"}{\\\\mathrel{\\\\char`\\u2258}}\");\ndefineMacro(\"\\u2259\", \"\\\\html@mathml{\\\\stackrel{\\\\tiny\\\\wedge}{=}}{\\\\mathrel{\\\\char`\\u2258}}\");\ndefineMacro(\"\\u225A\", \"\\\\html@mathml{\\\\stackrel{\\\\tiny\\\\vee}{=}}{\\\\mathrel{\\\\char`\\u225A}}\");\ndefineMacro(\"\\u225B\", \"\\\\html@mathml{\\\\stackrel{\\\\scriptsize\\\\star}{=}}\" + \"{\\\\mathrel{\\\\char`\\u225B}}\");\ndefineMacro(\"\\u225D\", \"\\\\html@mathml{\\\\stackrel{\\\\tiny\\\\mathrm{def}}{=}}\" + \"{\\\\mathrel{\\\\char`\\u225D}}\");\ndefineMacro(\"\\u225E\", \"\\\\html@mathml{\\\\stackrel{\\\\tiny\\\\mathrm{m}}{=}}\" + \"{\\\\mathrel{\\\\char`\\u225E}}\");\ndefineMacro(\"\\u225F\", \"\\\\html@mathml{\\\\stackrel{\\\\tiny?}{=}}{\\\\mathrel{\\\\char`\\u225F}}\"); // Misc Unicode\n\ndefineMacro(\"\\u27C2\", \"\\\\perp\");\ndefineMacro(\"\\u203C\", \"\\\\mathclose{!\\\\mkern-0.8mu!}\");\ndefineMacro(\"\\u220C\", \"\\\\notni\");\ndefineMacro(\"\\u231C\", \"\\\\ulcorner\");\ndefineMacro(\"\\u231D\", \"\\\\urcorner\");\ndefineMacro(\"\\u231E\", \"\\\\llcorner\");\ndefineMacro(\"\\u231F\", \"\\\\lrcorner\");\ndefineMacro(\"\\u00A9\", \"\\\\copyright\");\ndefineMacro(\"\\u00AE\", \"\\\\textregistered\");\ndefineMacro(\"\\uFE0F\", \"\\\\textregistered\"); // The KaTeX fonts have corners at codepoints that don't match Unicode.\n// For MathML purposes, use the Unicode code point.\n\ndefineMacro(\"\\\\ulcorner\", \"\\\\html@mathml{\\\\@ulcorner}{\\\\mathop{\\\\char\\\"231c}}\");\ndefineMacro(\"\\\\urcorner\", \"\\\\html@mathml{\\\\@urcorner}{\\\\mathop{\\\\char\\\"231d}}\");\ndefineMacro(\"\\\\llcorner\", \"\\\\html@mathml{\\\\@llcorner}{\\\\mathop{\\\\char\\\"231e}}\");\ndefineMacro(\"\\\\lrcorner\", \"\\\\html@mathml{\\\\@lrcorner}{\\\\mathop{\\\\char\\\"231f}}\"); //////////////////////////////////////////////////////////////////////\n// LaTeX_2\n// \\vdots{\\vbox{\\baselineskip4\\p@  \\lineskiplimit\\z@\n// \\kern6\\p@\\hbox{.}\\hbox{.}\\hbox{.}}}\n// We'll call \\varvdots, which gets a glyph from symbols.js.\n// The zero-width rule gets us an equivalent to the vertical 6pt kern.\n\ndefineMacro(\"\\\\vdots\", \"\\\\mathord{\\\\varvdots\\\\rule{0pt}{15pt}}\");\ndefineMacro(\"\\u22ee\", \"\\\\vdots\"); //////////////////////////////////////////////////////////////////////\n// amsmath.sty\n// http://mirrors.concertpass.com/tex-archive/macros/latex/required/amsmath/amsmath.pdf\n// Italic Greek capital letters.  AMS defines these with \\DeclareMathSymbol,\n// but they are equivalent to \\mathit{\\Letter}.\n\ndefineMacro(\"\\\\varGamma\", \"\\\\mathit{\\\\Gamma}\");\ndefineMacro(\"\\\\varDelta\", \"\\\\mathit{\\\\Delta}\");\ndefineMacro(\"\\\\varTheta\", \"\\\\mathit{\\\\Theta}\");\ndefineMacro(\"\\\\varLambda\", \"\\\\mathit{\\\\Lambda}\");\ndefineMacro(\"\\\\varXi\", \"\\\\mathit{\\\\Xi}\");\ndefineMacro(\"\\\\varPi\", \"\\\\mathit{\\\\Pi}\");\ndefineMacro(\"\\\\varSigma\", \"\\\\mathit{\\\\Sigma}\");\ndefineMacro(\"\\\\varUpsilon\", \"\\\\mathit{\\\\Upsilon}\");\ndefineMacro(\"\\\\varPhi\", \"\\\\mathit{\\\\Phi}\");\ndefineMacro(\"\\\\varPsi\", \"\\\\mathit{\\\\Psi}\");\ndefineMacro(\"\\\\varOmega\", \"\\\\mathit{\\\\Omega}\"); //\\newcommand{\\substack}[1]{\\subarray{c}#1\\endsubarray}\n\ndefineMacro(\"\\\\substack\", \"\\\\begin{subarray}{c}#1\\\\end{subarray}\"); // \\renewcommand{\\colon}{\\nobreak\\mskip2mu\\mathpunct{}\\nonscript\n// \\mkern-\\thinmuskip{:}\\mskip6muplus1mu\\relax}\n\ndefineMacro(\"\\\\colon\", \"\\\\nobreak\\\\mskip2mu\\\\mathpunct{}\" + \"\\\\mathchoice{\\\\mkern-3mu}{\\\\mkern-3mu}{}{}{:}\\\\mskip6mu\\\\relax\"); // \\newcommand{\\boxed}[1]{\\fbox{\\m@th$\\displaystyle#1$}}\n\ndefineMacro(\"\\\\boxed\", \"\\\\fbox{$\\\\displaystyle{#1}$}\"); // \\def\\iff{\\DOTSB\\;\\Longleftrightarrow\\;}\n// \\def\\implies{\\DOTSB\\;\\Longrightarrow\\;}\n// \\def\\impliedby{\\DOTSB\\;\\Longleftarrow\\;}\n\ndefineMacro(\"\\\\iff\", \"\\\\DOTSB\\\\;\\\\Longleftrightarrow\\\\;\");\ndefineMacro(\"\\\\implies\", \"\\\\DOTSB\\\\;\\\\Longrightarrow\\\\;\");\ndefineMacro(\"\\\\impliedby\", \"\\\\DOTSB\\\\;\\\\Longleftarrow\\\\;\"); // AMSMath's automatic \\dots, based on \\mdots@@ macro.\n\nconst dotsByToken = {\n  ',': '\\\\dotsc',\n  '\\\\not': '\\\\dotsb',\n  // \\keybin@ checks for the following:\n  '+': '\\\\dotsb',\n  '=': '\\\\dotsb',\n  '<': '\\\\dotsb',\n  '>': '\\\\dotsb',\n  '-': '\\\\dotsb',\n  '*': '\\\\dotsb',\n  ':': '\\\\dotsb',\n  // Symbols whose definition starts with \\DOTSB:\n  '\\\\DOTSB': '\\\\dotsb',\n  '\\\\coprod': '\\\\dotsb',\n  '\\\\bigvee': '\\\\dotsb',\n  '\\\\bigwedge': '\\\\dotsb',\n  '\\\\biguplus': '\\\\dotsb',\n  '\\\\bigcap': '\\\\dotsb',\n  '\\\\bigcup': '\\\\dotsb',\n  '\\\\prod': '\\\\dotsb',\n  '\\\\sum': '\\\\dotsb',\n  '\\\\bigotimes': '\\\\dotsb',\n  '\\\\bigoplus': '\\\\dotsb',\n  '\\\\bigodot': '\\\\dotsb',\n  '\\\\bigsqcup': '\\\\dotsb',\n  '\\\\And': '\\\\dotsb',\n  '\\\\longrightarrow': '\\\\dotsb',\n  '\\\\Longrightarrow': '\\\\dotsb',\n  '\\\\longleftarrow': '\\\\dotsb',\n  '\\\\Longleftarrow': '\\\\dotsb',\n  '\\\\longleftrightarrow': '\\\\dotsb',\n  '\\\\Longleftrightarrow': '\\\\dotsb',\n  '\\\\mapsto': '\\\\dotsb',\n  '\\\\longmapsto': '\\\\dotsb',\n  '\\\\hookrightarrow': '\\\\dotsb',\n  '\\\\doteq': '\\\\dotsb',\n  // Symbols whose definition starts with \\mathbin:\n  '\\\\mathbin': '\\\\dotsb',\n  // Symbols whose definition starts with \\mathrel:\n  '\\\\mathrel': '\\\\dotsb',\n  '\\\\relbar': '\\\\dotsb',\n  '\\\\Relbar': '\\\\dotsb',\n  '\\\\xrightarrow': '\\\\dotsb',\n  '\\\\xleftarrow': '\\\\dotsb',\n  // Symbols whose definition starts with \\DOTSI:\n  '\\\\DOTSI': '\\\\dotsi',\n  '\\\\int': '\\\\dotsi',\n  '\\\\oint': '\\\\dotsi',\n  '\\\\iint': '\\\\dotsi',\n  '\\\\iiint': '\\\\dotsi',\n  '\\\\iiiint': '\\\\dotsi',\n  '\\\\idotsint': '\\\\dotsi',\n  // Symbols whose definition starts with \\DOTSX:\n  '\\\\DOTSX': '\\\\dotsx'\n};\ndefineMacro(\"\\\\dots\", function (context) {\n  // TODO: If used in text mode, should expand to \\textellipsis.\n  // However, in KaTeX, \\textellipsis and \\ldots behave the same\n  // (in text mode), and it's unlikely we'd see any of the math commands\n  // that affect the behavior of \\dots when in text mode.  So fine for now\n  // (until we support \\ifmmode ... \\else ... \\fi).\n  let thedots = '\\\\dotso';\n  const next = context.expandAfterFuture().text;\n\n  if (next in dotsByToken) {\n    thedots = dotsByToken[next];\n  } else if (next.slice(0, 4) === '\\\\not') {\n    thedots = '\\\\dotsb';\n  } else if (next in src_symbols.math) {\n    if (utils.contains(['bin', 'rel'], src_symbols.math[next].group)) {\n      thedots = '\\\\dotsb';\n    }\n  }\n\n  return thedots;\n});\nconst spaceAfterDots = {\n  // \\rightdelim@ checks for the following:\n  ')': true,\n  ']': true,\n  '\\\\rbrack': true,\n  '\\\\}': true,\n  '\\\\rbrace': true,\n  '\\\\rangle': true,\n  '\\\\rceil': true,\n  '\\\\rfloor': true,\n  '\\\\rgroup': true,\n  '\\\\rmoustache': true,\n  '\\\\right': true,\n  '\\\\bigr': true,\n  '\\\\biggr': true,\n  '\\\\Bigr': true,\n  '\\\\Biggr': true,\n  // \\extra@ also tests for the following:\n  '$': true,\n  // \\extrap@ checks for the following:\n  ';': true,\n  '.': true,\n  ',': true\n};\ndefineMacro(\"\\\\dotso\", function (context) {\n  const next = context.future().text;\n\n  if (next in spaceAfterDots) {\n    return \"\\\\ldots\\\\,\";\n  } else {\n    return \"\\\\ldots\";\n  }\n});\ndefineMacro(\"\\\\dotsc\", function (context) {\n  const next = context.future().text; // \\dotsc uses \\extra@ but not \\extrap@, instead specially checking for\n  // ';' and '.', but doesn't check for ','.\n\n  if (next in spaceAfterDots && next !== ',') {\n    return \"\\\\ldots\\\\,\";\n  } else {\n    return \"\\\\ldots\";\n  }\n});\ndefineMacro(\"\\\\cdots\", function (context) {\n  const next = context.future().text;\n\n  if (next in spaceAfterDots) {\n    return \"\\\\@cdots\\\\,\";\n  } else {\n    return \"\\\\@cdots\";\n  }\n});\ndefineMacro(\"\\\\dotsb\", \"\\\\cdots\");\ndefineMacro(\"\\\\dotsm\", \"\\\\cdots\");\ndefineMacro(\"\\\\dotsi\", \"\\\\!\\\\cdots\"); // amsmath doesn't actually define \\dotsx, but \\dots followed by a macro\n// starting with \\DOTSX implies \\dotso, and then \\extra@ detects this case\n// and forces the added `\\,`.\n\ndefineMacro(\"\\\\dotsx\", \"\\\\ldots\\\\,\"); // \\let\\DOTSI\\relax\n// \\let\\DOTSB\\relax\n// \\let\\DOTSX\\relax\n\ndefineMacro(\"\\\\DOTSI\", \"\\\\relax\");\ndefineMacro(\"\\\\DOTSB\", \"\\\\relax\");\ndefineMacro(\"\\\\DOTSX\", \"\\\\relax\"); // Spacing, based on amsmath.sty's override of LaTeX defaults\n// \\DeclareRobustCommand{\\tmspace}[3]{%\n//   \\ifmmode\\mskip#1#2\\else\\kern#1#3\\fi\\relax}\n\ndefineMacro(\"\\\\tmspace\", \"\\\\TextOrMath{\\\\kern#1#3}{\\\\mskip#1#2}\\\\relax\"); // \\renewcommand{\\,}{\\tmspace+\\thinmuskip{.1667em}}\n// TODO: math mode should use \\thinmuskip\n\ndefineMacro(\"\\\\,\", \"\\\\tmspace+{3mu}{.1667em}\"); // \\let\\thinspace\\,\n\ndefineMacro(\"\\\\thinspace\", \"\\\\,\"); // \\def\\>{\\mskip\\medmuskip}\n// \\renewcommand{\\:}{\\tmspace+\\medmuskip{.2222em}}\n// TODO: \\> and math mode of \\: should use \\medmuskip = 4mu plus 2mu minus 4mu\n\ndefineMacro(\"\\\\>\", \"\\\\mskip{4mu}\");\ndefineMacro(\"\\\\:\", \"\\\\tmspace+{4mu}{.2222em}\"); // \\let\\medspace\\:\n\ndefineMacro(\"\\\\medspace\", \"\\\\:\"); // \\renewcommand{\\;}{\\tmspace+\\thickmuskip{.2777em}}\n// TODO: math mode should use \\thickmuskip = 5mu plus 5mu\n\ndefineMacro(\"\\\\;\", \"\\\\tmspace+{5mu}{.2777em}\"); // \\let\\thickspace\\;\n\ndefineMacro(\"\\\\thickspace\", \"\\\\;\"); // \\renewcommand{\\!}{\\tmspace-\\thinmuskip{.1667em}}\n// TODO: math mode should use \\thinmuskip\n\ndefineMacro(\"\\\\!\", \"\\\\tmspace-{3mu}{.1667em}\"); // \\let\\negthinspace\\!\n\ndefineMacro(\"\\\\negthinspace\", \"\\\\!\"); // \\newcommand{\\negmedspace}{\\tmspace-\\medmuskip{.2222em}}\n// TODO: math mode should use \\medmuskip\n\ndefineMacro(\"\\\\negmedspace\", \"\\\\tmspace-{4mu}{.2222em}\"); // \\newcommand{\\negthickspace}{\\tmspace-\\thickmuskip{.2777em}}\n// TODO: math mode should use \\thickmuskip\n\ndefineMacro(\"\\\\negthickspace\", \"\\\\tmspace-{5mu}{.277em}\"); // \\def\\enspace{\\kern.5em }\n\ndefineMacro(\"\\\\enspace\", \"\\\\kern.5em \"); // \\def\\enskip{\\hskip.5em\\relax}\n\ndefineMacro(\"\\\\enskip\", \"\\\\hskip.5em\\\\relax\"); // \\def\\quad{\\hskip1em\\relax}\n\ndefineMacro(\"\\\\quad\", \"\\\\hskip1em\\\\relax\"); // \\def\\qquad{\\hskip2em\\relax}\n\ndefineMacro(\"\\\\qquad\", \"\\\\hskip2em\\\\relax\"); // \\tag@in@display form of \\tag\n\ndefineMacro(\"\\\\tag\", \"\\\\@ifstar\\\\tag@literal\\\\tag@paren\");\ndefineMacro(\"\\\\tag@paren\", \"\\\\tag@literal{({#1})}\");\ndefineMacro(\"\\\\tag@literal\", context => {\n  if (context.macros.get(\"\\\\df@tag\")) {\n    throw new src_ParseError(\"Multiple \\\\tag\");\n  }\n\n  return \"\\\\gdef\\\\df@tag{\\\\text{#1}}\";\n}); // \\renewcommand{\\bmod}{\\nonscript\\mskip-\\medmuskip\\mkern5mu\\mathbin\n//   {\\operator@font mod}\\penalty900\n//   \\mkern5mu\\nonscript\\mskip-\\medmuskip}\n// \\newcommand{\\pod}[1]{\\allowbreak\n//   \\if@display\\mkern18mu\\else\\mkern8mu\\fi(#1)}\n// \\renewcommand{\\pmod}[1]{\\pod{{\\operator@font mod}\\mkern6mu#1}}\n// \\newcommand{\\mod}[1]{\\allowbreak\\if@display\\mkern18mu\n//   \\else\\mkern12mu\\fi{\\operator@font mod}\\,\\,#1}\n// TODO: math mode should use \\medmuskip = 4mu plus 2mu minus 4mu\n\ndefineMacro(\"\\\\bmod\", \"\\\\mathchoice{\\\\mskip1mu}{\\\\mskip1mu}{\\\\mskip5mu}{\\\\mskip5mu}\" + \"\\\\mathbin{\\\\rm mod}\" + \"\\\\mathchoice{\\\\mskip1mu}{\\\\mskip1mu}{\\\\mskip5mu}{\\\\mskip5mu}\");\ndefineMacro(\"\\\\pod\", \"\\\\allowbreak\" + \"\\\\mathchoice{\\\\mkern18mu}{\\\\mkern8mu}{\\\\mkern8mu}{\\\\mkern8mu}(#1)\");\ndefineMacro(\"\\\\pmod\", \"\\\\pod{{\\\\rm mod}\\\\mkern6mu#1}\");\ndefineMacro(\"\\\\mod\", \"\\\\allowbreak\" + \"\\\\mathchoice{\\\\mkern18mu}{\\\\mkern12mu}{\\\\mkern12mu}{\\\\mkern12mu}\" + \"{\\\\rm mod}\\\\,\\\\,#1\"); //////////////////////////////////////////////////////////////////////\n// LaTeX source2e\n// \\expandafter\\let\\expandafter\\@normalcr\n//     \\csname\\expandafter\\@gobble\\string\\\\ \\endcsname\n// \\DeclareRobustCommand\\newline{\\@normalcr\\relax}\n\ndefineMacro(\"\\\\newline\", \"\\\\\\\\\\\\relax\"); // \\def\\TeX{T\\kern-.1667em\\lower.5ex\\hbox{E}\\kern-.125emX\\@}\n// TODO: Doesn't normally work in math mode because \\@ fails.  KaTeX doesn't\n// support \\@ yet, so that's omitted, and we add \\text so that the result\n// doesn't look funny in math mode.\n\ndefineMacro(\"\\\\TeX\", \"\\\\textrm{\\\\html@mathml{\" + \"T\\\\kern-.1667em\\\\raisebox{-.5ex}{E}\\\\kern-.125emX\" + \"}{TeX}}\"); // \\DeclareRobustCommand{\\LaTeX}{L\\kern-.36em%\n//         {\\sbox\\z@ T%\n//          \\vbox to\\ht\\z@{\\hbox{\\check@mathfonts\n//                               \\fontsize\\sf@size\\z@\n//                               \\math@fontsfalse\\selectfont\n//                               A}%\n//                         \\vss}%\n//         }%\n//         \\kern-.15em%\n//         \\TeX}\n// This code aligns the top of the A with the T (from the perspective of TeX's\n// boxes, though visually the A appears to extend above slightly).\n// We compute the corresponding \\raisebox when A is rendered in \\normalsize\n// \\scriptstyle, which has a scale factor of 0.7 (see Options.js).\n\nconst latexRaiseA = makeEm(fontMetricsData[\"Main-Regular\"][\"T\".charCodeAt(0)][1] - 0.7 * fontMetricsData[\"Main-Regular\"][\"A\".charCodeAt(0)][1]);\ndefineMacro(\"\\\\LaTeX\", \"\\\\textrm{\\\\html@mathml{\" + (\"L\\\\kern-.36em\\\\raisebox{\" + latexRaiseA + \"}{\\\\scriptstyle A}\") + \"\\\\kern-.15em\\\\TeX}{LaTeX}}\"); // New KaTeX logo based on tweaking LaTeX logo\n\ndefineMacro(\"\\\\KaTeX\", \"\\\\textrm{\\\\html@mathml{\" + (\"K\\\\kern-.17em\\\\raisebox{\" + latexRaiseA + \"}{\\\\scriptstyle A}\") + \"\\\\kern-.15em\\\\TeX}{KaTeX}}\"); // \\DeclareRobustCommand\\hspace{\\@ifstar\\@hspacer\\@hspace}\n// \\def\\@hspace#1{\\hskip  #1\\relax}\n// \\def\\@hspacer#1{\\vrule \\@width\\z@\\nobreak\n//                 \\hskip #1\\hskip \\z@skip}\n\ndefineMacro(\"\\\\hspace\", \"\\\\@ifstar\\\\@hspacer\\\\@hspace\");\ndefineMacro(\"\\\\@hspace\", \"\\\\hskip #1\\\\relax\");\ndefineMacro(\"\\\\@hspacer\", \"\\\\rule{0pt}{0pt}\\\\hskip #1\\\\relax\"); //////////////////////////////////////////////////////////////////////\n// mathtools.sty\n//\\providecommand\\ordinarycolon{:}\n\ndefineMacro(\"\\\\ordinarycolon\", \":\"); //\\def\\vcentcolon{\\mathrel{\\mathop\\ordinarycolon}}\n//TODO(edemaine): Not yet centered. Fix via \\raisebox or #726\n\ndefineMacro(\"\\\\vcentcolon\", \"\\\\mathrel{\\\\mathop\\\\ordinarycolon}\"); // \\providecommand*\\dblcolon{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}\n\ndefineMacro(\"\\\\dblcolon\", \"\\\\html@mathml{\" + \"\\\\mathrel{\\\\vcentcolon\\\\mathrel{\\\\mkern-.9mu}\\\\vcentcolon}}\" + \"{\\\\mathop{\\\\char\\\"2237}}\"); // \\providecommand*\\coloneqq{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}\n\ndefineMacro(\"\\\\coloneqq\", \"\\\\html@mathml{\" + \"\\\\mathrel{\\\\vcentcolon\\\\mathrel{\\\\mkern-1.2mu}=}}\" + \"{\\\\mathop{\\\\char\\\"2254}}\"); // \n// \\providecommand*\\Coloneqq{\\dblcolon\\mathrel{\\mkern-1.2mu}=}\n\ndefineMacro(\"\\\\Coloneqq\", \"\\\\html@mathml{\" + \"\\\\mathrel{\\\\dblcolon\\\\mathrel{\\\\mkern-1.2mu}=}}\" + \"{\\\\mathop{\\\\char\\\"2237\\\\char\\\"3d}}\"); // \\providecommand*\\coloneq{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}\n\ndefineMacro(\"\\\\coloneq\", \"\\\\html@mathml{\" + \"\\\\mathrel{\\\\vcentcolon\\\\mathrel{\\\\mkern-1.2mu}\\\\mathrel{-}}}\" + \"{\\\\mathop{\\\\char\\\"3a\\\\char\\\"2212}}\"); // \\providecommand*\\Coloneq{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}\n\ndefineMacro(\"\\\\Coloneq\", \"\\\\html@mathml{\" + \"\\\\mathrel{\\\\dblcolon\\\\mathrel{\\\\mkern-1.2mu}\\\\mathrel{-}}}\" + \"{\\\\mathop{\\\\char\\\"2237\\\\char\\\"2212}}\"); // \\providecommand*\\eqqcolon{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}\n\ndefineMacro(\"\\\\eqqcolon\", \"\\\\html@mathml{\" + \"\\\\mathrel{=\\\\mathrel{\\\\mkern-1.2mu}\\\\vcentcolon}}\" + \"{\\\\mathop{\\\\char\\\"2255}}\"); // \n// \\providecommand*\\Eqqcolon{=\\mathrel{\\mkern-1.2mu}\\dblcolon}\n\ndefineMacro(\"\\\\Eqqcolon\", \"\\\\html@mathml{\" + \"\\\\mathrel{=\\\\mathrel{\\\\mkern-1.2mu}\\\\dblcolon}}\" + \"{\\\\mathop{\\\\char\\\"3d\\\\char\\\"2237}}\"); // \\providecommand*\\eqcolon{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}\n\ndefineMacro(\"\\\\eqcolon\", \"\\\\html@mathml{\" + \"\\\\mathrel{\\\\mathrel{-}\\\\mathrel{\\\\mkern-1.2mu}\\\\vcentcolon}}\" + \"{\\\\mathop{\\\\char\\\"2239}}\"); // \\providecommand*\\Eqcolon{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}\n\ndefineMacro(\"\\\\Eqcolon\", \"\\\\html@mathml{\" + \"\\\\mathrel{\\\\mathrel{-}\\\\mathrel{\\\\mkern-1.2mu}\\\\dblcolon}}\" + \"{\\\\mathop{\\\\char\\\"2212\\\\char\\\"2237}}\"); // \\providecommand*\\colonapprox{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}\n\ndefineMacro(\"\\\\colonapprox\", \"\\\\html@mathml{\" + \"\\\\mathrel{\\\\vcentcolon\\\\mathrel{\\\\mkern-1.2mu}\\\\approx}}\" + \"{\\\\mathop{\\\\char\\\"3a\\\\char\\\"2248}}\"); // \\providecommand*\\Colonapprox{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}\n\ndefineMacro(\"\\\\Colonapprox\", \"\\\\html@mathml{\" + \"\\\\mathrel{\\\\dblcolon\\\\mathrel{\\\\mkern-1.2mu}\\\\approx}}\" + \"{\\\\mathop{\\\\char\\\"2237\\\\char\\\"2248}}\"); // \\providecommand*\\colonsim{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}\n\ndefineMacro(\"\\\\colonsim\", \"\\\\html@mathml{\" + \"\\\\mathrel{\\\\vcentcolon\\\\mathrel{\\\\mkern-1.2mu}\\\\sim}}\" + \"{\\\\mathop{\\\\char\\\"3a\\\\char\\\"223c}}\"); // \\providecommand*\\Colonsim{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}\n\ndefineMacro(\"\\\\Colonsim\", \"\\\\html@mathml{\" + \"\\\\mathrel{\\\\dblcolon\\\\mathrel{\\\\mkern-1.2mu}\\\\sim}}\" + \"{\\\\mathop{\\\\char\\\"2237\\\\char\\\"223c}}\"); // Some Unicode characters are implemented with macros to mathtools functions.\n\ndefineMacro(\"\\u2237\", \"\\\\dblcolon\"); // ::\n\ndefineMacro(\"\\u2239\", \"\\\\eqcolon\"); // -:\n\ndefineMacro(\"\\u2254\", \"\\\\coloneqq\"); // :=\n\ndefineMacro(\"\\u2255\", \"\\\\eqqcolon\"); // =:\n\ndefineMacro(\"\\u2A74\", \"\\\\Coloneqq\"); // ::=\n//////////////////////////////////////////////////////////////////////\n// colonequals.sty\n// Alternate names for mathtools's macros:\n\ndefineMacro(\"\\\\ratio\", \"\\\\vcentcolon\");\ndefineMacro(\"\\\\coloncolon\", \"\\\\dblcolon\");\ndefineMacro(\"\\\\colonequals\", \"\\\\coloneqq\");\ndefineMacro(\"\\\\coloncolonequals\", \"\\\\Coloneqq\");\ndefineMacro(\"\\\\equalscolon\", \"\\\\eqqcolon\");\ndefineMacro(\"\\\\equalscoloncolon\", \"\\\\Eqqcolon\");\ndefineMacro(\"\\\\colonminus\", \"\\\\coloneq\");\ndefineMacro(\"\\\\coloncolonminus\", \"\\\\Coloneq\");\ndefineMacro(\"\\\\minuscolon\", \"\\\\eqcolon\");\ndefineMacro(\"\\\\minuscoloncolon\", \"\\\\Eqcolon\"); // \\colonapprox name is same in mathtools and colonequals.\n\ndefineMacro(\"\\\\coloncolonapprox\", \"\\\\Colonapprox\"); // \\colonsim name is same in mathtools and colonequals.\n\ndefineMacro(\"\\\\coloncolonsim\", \"\\\\Colonsim\"); // Additional macros, implemented by analogy with mathtools definitions:\n\ndefineMacro(\"\\\\simcolon\", \"\\\\mathrel{\\\\sim\\\\mathrel{\\\\mkern-1.2mu}\\\\vcentcolon}\");\ndefineMacro(\"\\\\simcoloncolon\", \"\\\\mathrel{\\\\sim\\\\mathrel{\\\\mkern-1.2mu}\\\\dblcolon}\");\ndefineMacro(\"\\\\approxcolon\", \"\\\\mathrel{\\\\approx\\\\mathrel{\\\\mkern-1.2mu}\\\\vcentcolon}\");\ndefineMacro(\"\\\\approxcoloncolon\", \"\\\\mathrel{\\\\approx\\\\mathrel{\\\\mkern-1.2mu}\\\\dblcolon}\"); // Present in newtxmath, pxfonts and txfonts\n\ndefineMacro(\"\\\\notni\", \"\\\\html@mathml{\\\\not\\\\ni}{\\\\mathrel{\\\\char`\\u220C}}\");\ndefineMacro(\"\\\\limsup\", \"\\\\DOTSB\\\\operatorname*{lim\\\\,sup}\");\ndefineMacro(\"\\\\liminf\", \"\\\\DOTSB\\\\operatorname*{lim\\\\,inf}\"); //////////////////////////////////////////////////////////////////////\n// From amsopn.sty\n\ndefineMacro(\"\\\\injlim\", \"\\\\DOTSB\\\\operatorname*{inj\\\\,lim}\");\ndefineMacro(\"\\\\projlim\", \"\\\\DOTSB\\\\operatorname*{proj\\\\,lim}\");\ndefineMacro(\"\\\\varlimsup\", \"\\\\DOTSB\\\\operatorname*{\\\\overline{lim}}\");\ndefineMacro(\"\\\\varliminf\", \"\\\\DOTSB\\\\operatorname*{\\\\underline{lim}}\");\ndefineMacro(\"\\\\varinjlim\", \"\\\\DOTSB\\\\operatorname*{\\\\underrightarrow{lim}}\");\ndefineMacro(\"\\\\varprojlim\", \"\\\\DOTSB\\\\operatorname*{\\\\underleftarrow{lim}}\"); //////////////////////////////////////////////////////////////////////\n// MathML alternates for KaTeX glyphs in the Unicode private area\n\ndefineMacro(\"\\\\gvertneqq\", \"\\\\html@mathml{\\\\@gvertneqq}{\\u2269}\");\ndefineMacro(\"\\\\lvertneqq\", \"\\\\html@mathml{\\\\@lvertneqq}{\\u2268}\");\ndefineMacro(\"\\\\ngeqq\", \"\\\\html@mathml{\\\\@ngeqq}{\\u2271}\");\ndefineMacro(\"\\\\ngeqslant\", \"\\\\html@mathml{\\\\@ngeqslant}{\\u2271}\");\ndefineMacro(\"\\\\nleqq\", \"\\\\html@mathml{\\\\@nleqq}{\\u2270}\");\ndefineMacro(\"\\\\nleqslant\", \"\\\\html@mathml{\\\\@nleqslant}{\\u2270}\");\ndefineMacro(\"\\\\nshortmid\", \"\\\\html@mathml{\\\\@nshortmid}{}\");\ndefineMacro(\"\\\\nshortparallel\", \"\\\\html@mathml{\\\\@nshortparallel}{}\");\ndefineMacro(\"\\\\nsubseteqq\", \"\\\\html@mathml{\\\\@nsubseteqq}{\\u2288}\");\ndefineMacro(\"\\\\nsupseteqq\", \"\\\\html@mathml{\\\\@nsupseteqq}{\\u2289}\");\ndefineMacro(\"\\\\varsubsetneq\", \"\\\\html@mathml{\\\\@varsubsetneq}{}\");\ndefineMacro(\"\\\\varsubsetneqq\", \"\\\\html@mathml{\\\\@varsubsetneqq}{}\");\ndefineMacro(\"\\\\varsupsetneq\", \"\\\\html@mathml{\\\\@varsupsetneq}{}\");\ndefineMacro(\"\\\\varsupsetneqq\", \"\\\\html@mathml{\\\\@varsupsetneqq}{}\");\ndefineMacro(\"\\\\imath\", \"\\\\html@mathml{\\\\@imath}{\\u0131}\");\ndefineMacro(\"\\\\jmath\", \"\\\\html@mathml{\\\\@jmath}{\\u0237}\"); //////////////////////////////////////////////////////////////////////\n// stmaryrd and semantic\n// The stmaryrd and semantic packages render the next four items by calling a\n// glyph. Those glyphs do not exist in the KaTeX fonts. Hence the macros.\n\ndefineMacro(\"\\\\llbracket\", \"\\\\html@mathml{\" + \"\\\\mathopen{[\\\\mkern-3.2mu[}}\" + \"{\\\\mathopen{\\\\char`\\u27e6}}\");\ndefineMacro(\"\\\\rrbracket\", \"\\\\html@mathml{\" + \"\\\\mathclose{]\\\\mkern-3.2mu]}}\" + \"{\\\\mathclose{\\\\char`\\u27e7}}\");\ndefineMacro(\"\\u27e6\", \"\\\\llbracket\"); // blackboard bold [\n\ndefineMacro(\"\\u27e7\", \"\\\\rrbracket\"); // blackboard bold ]\n\ndefineMacro(\"\\\\lBrace\", \"\\\\html@mathml{\" + \"\\\\mathopen{\\\\{\\\\mkern-3.2mu[}}\" + \"{\\\\mathopen{\\\\char`\\u2983}}\");\ndefineMacro(\"\\\\rBrace\", \"\\\\html@mathml{\" + \"\\\\mathclose{]\\\\mkern-3.2mu\\\\}}}\" + \"{\\\\mathclose{\\\\char`\\u2984}}\");\ndefineMacro(\"\\u2983\", \"\\\\lBrace\"); // blackboard bold {\n\ndefineMacro(\"\\u2984\", \"\\\\rBrace\"); // blackboard bold }\n// TODO: Create variable sized versions of the last two items. I believe that\n// will require new font glyphs.\n// The stmaryrd function `\\minuso` provides a \"Plimsoll\" symbol that\n// superimposes the characters \\circ and \\mathminus. Used in chemistry.\n\ndefineMacro(\"\\\\minuso\", \"\\\\mathbin{\\\\html@mathml{\" + \"{\\\\mathrlap{\\\\mathchoice{\\\\kern{0.145em}}{\\\\kern{0.145em}}\" + \"{\\\\kern{0.1015em}}{\\\\kern{0.0725em}}\\\\circ}{-}}}\" + \"{\\\\char`}}\");\ndefineMacro(\"\", \"\\\\minuso\"); //////////////////////////////////////////////////////////////////////\n// texvc.sty\n// The texvc package contains macros available in mediawiki pages.\n// We omit the functions deprecated at\n// https://en.wikipedia.org/wiki/Help:Displaying_a_formula#Deprecated_syntax\n// We also omit texvc's \\O, which conflicts with \\text{\\O}\n\ndefineMacro(\"\\\\darr\", \"\\\\downarrow\");\ndefineMacro(\"\\\\dArr\", \"\\\\Downarrow\");\ndefineMacro(\"\\\\Darr\", \"\\\\Downarrow\");\ndefineMacro(\"\\\\lang\", \"\\\\langle\");\ndefineMacro(\"\\\\rang\", \"\\\\rangle\");\ndefineMacro(\"\\\\uarr\", \"\\\\uparrow\");\ndefineMacro(\"\\\\uArr\", \"\\\\Uparrow\");\ndefineMacro(\"\\\\Uarr\", \"\\\\Uparrow\");\ndefineMacro(\"\\\\N\", \"\\\\mathbb{N}\");\ndefineMacro(\"\\\\R\", \"\\\\mathbb{R}\");\ndefineMacro(\"\\\\Z\", \"\\\\mathbb{Z}\");\ndefineMacro(\"\\\\alef\", \"\\\\aleph\");\ndefineMacro(\"\\\\alefsym\", \"\\\\aleph\");\ndefineMacro(\"\\\\Alpha\", \"\\\\mathrm{A}\");\ndefineMacro(\"\\\\Beta\", \"\\\\mathrm{B}\");\ndefineMacro(\"\\\\bull\", \"\\\\bullet\");\ndefineMacro(\"\\\\Chi\", \"\\\\mathrm{X}\");\ndefineMacro(\"\\\\clubs\", \"\\\\clubsuit\");\ndefineMacro(\"\\\\cnums\", \"\\\\mathbb{C}\");\ndefineMacro(\"\\\\Complex\", \"\\\\mathbb{C}\");\ndefineMacro(\"\\\\Dagger\", \"\\\\ddagger\");\ndefineMacro(\"\\\\diamonds\", \"\\\\diamondsuit\");\ndefineMacro(\"\\\\empty\", \"\\\\emptyset\");\ndefineMacro(\"\\\\Epsilon\", \"\\\\mathrm{E}\");\ndefineMacro(\"\\\\Eta\", \"\\\\mathrm{H}\");\ndefineMacro(\"\\\\exist\", \"\\\\exists\");\ndefineMacro(\"\\\\harr\", \"\\\\leftrightarrow\");\ndefineMacro(\"\\\\hArr\", \"\\\\Leftrightarrow\");\ndefineMacro(\"\\\\Harr\", \"\\\\Leftrightarrow\");\ndefineMacro(\"\\\\hearts\", \"\\\\heartsuit\");\ndefineMacro(\"\\\\image\", \"\\\\Im\");\ndefineMacro(\"\\\\infin\", \"\\\\infty\");\ndefineMacro(\"\\\\Iota\", \"\\\\mathrm{I}\");\ndefineMacro(\"\\\\isin\", \"\\\\in\");\ndefineMacro(\"\\\\Kappa\", \"\\\\mathrm{K}\");\ndefineMacro(\"\\\\larr\", \"\\\\leftarrow\");\ndefineMacro(\"\\\\lArr\", \"\\\\Leftarrow\");\ndefineMacro(\"\\\\Larr\", \"\\\\Leftarrow\");\ndefineMacro(\"\\\\lrarr\", \"\\\\leftrightarrow\");\ndefineMacro(\"\\\\lrArr\", \"\\\\Leftrightarrow\");\ndefineMacro(\"\\\\Lrarr\", \"\\\\Leftrightarrow\");\ndefineMacro(\"\\\\Mu\", \"\\\\mathrm{M}\");\ndefineMacro(\"\\\\natnums\", \"\\\\mathbb{N}\");\ndefineMacro(\"\\\\Nu\", \"\\\\mathrm{N}\");\ndefineMacro(\"\\\\Omicron\", \"\\\\mathrm{O}\");\ndefineMacro(\"\\\\plusmn\", \"\\\\pm\");\ndefineMacro(\"\\\\rarr\", \"\\\\rightarrow\");\ndefineMacro(\"\\\\rArr\", \"\\\\Rightarrow\");\ndefineMacro(\"\\\\Rarr\", \"\\\\Rightarrow\");\ndefineMacro(\"\\\\real\", \"\\\\Re\");\ndefineMacro(\"\\\\reals\", \"\\\\mathbb{R}\");\ndefineMacro(\"\\\\Reals\", \"\\\\mathbb{R}\");\ndefineMacro(\"\\\\Rho\", \"\\\\mathrm{P}\");\ndefineMacro(\"\\\\sdot\", \"\\\\cdot\");\ndefineMacro(\"\\\\sect\", \"\\\\S\");\ndefineMacro(\"\\\\spades\", \"\\\\spadesuit\");\ndefineMacro(\"\\\\sub\", \"\\\\subset\");\ndefineMacro(\"\\\\sube\", \"\\\\subseteq\");\ndefineMacro(\"\\\\supe\", \"\\\\supseteq\");\ndefineMacro(\"\\\\Tau\", \"\\\\mathrm{T}\");\ndefineMacro(\"\\\\thetasym\", \"\\\\vartheta\"); // TODO: defineMacro(\"\\\\varcoppa\", \"\\\\\\mbox{\\\\coppa}\");\n\ndefineMacro(\"\\\\weierp\", \"\\\\wp\");\ndefineMacro(\"\\\\Zeta\", \"\\\\mathrm{Z}\"); //////////////////////////////////////////////////////////////////////\n// statmath.sty\n// https://ctan.math.illinois.edu/macros/latex/contrib/statmath/statmath.pdf\n\ndefineMacro(\"\\\\argmin\", \"\\\\DOTSB\\\\operatorname*{arg\\\\,min}\");\ndefineMacro(\"\\\\argmax\", \"\\\\DOTSB\\\\operatorname*{arg\\\\,max}\");\ndefineMacro(\"\\\\plim\", \"\\\\DOTSB\\\\mathop{\\\\operatorname{plim}}\\\\limits\"); //////////////////////////////////////////////////////////////////////\n// braket.sty\n// http://ctan.math.washington.edu/tex-archive/macros/latex/contrib/braket/braket.pdf\n\ndefineMacro(\"\\\\bra\", \"\\\\mathinner{\\\\langle{#1}|}\");\ndefineMacro(\"\\\\ket\", \"\\\\mathinner{|{#1}\\\\rangle}\");\ndefineMacro(\"\\\\braket\", \"\\\\mathinner{\\\\langle{#1}\\\\rangle}\");\ndefineMacro(\"\\\\Bra\", \"\\\\left\\\\langle#1\\\\right|\");\ndefineMacro(\"\\\\Ket\", \"\\\\left|#1\\\\right\\\\rangle\");\n\nconst braketHelper = one => context => {\n  const left = context.consumeArg().tokens;\n  const middle = context.consumeArg().tokens;\n  const middleDouble = context.consumeArg().tokens;\n  const right = context.consumeArg().tokens;\n  const oldMiddle = context.macros.get(\"|\");\n  const oldMiddleDouble = context.macros.get(\"\\\\|\");\n  context.macros.beginGroup();\n\n  const midMacro = double => context => {\n    if (one) {\n      // Only modify the first instance of | or \\|\n      context.macros.set(\"|\", oldMiddle);\n\n      if (middleDouble.length) {\n        context.macros.set(\"\\\\|\", oldMiddleDouble);\n      }\n    }\n\n    let doubled = double;\n\n    if (!double && middleDouble.length) {\n      // Mimic \\@ifnextchar\n      const nextToken = context.future();\n\n      if (nextToken.text === \"|\") {\n        context.popToken();\n        doubled = true;\n      }\n    }\n\n    return {\n      tokens: doubled ? middleDouble : middle,\n      numArgs: 0\n    };\n  };\n\n  context.macros.set(\"|\", midMacro(false));\n\n  if (middleDouble.length) {\n    context.macros.set(\"\\\\|\", midMacro(true));\n  }\n\n  const arg = context.consumeArg().tokens;\n  const expanded = context.expandTokens([...right, ...arg, ...left // reversed\n  ]);\n  context.macros.endGroup();\n  return {\n    tokens: expanded.reverse(),\n    numArgs: 0\n  };\n};\n\ndefineMacro(\"\\\\bra@ket\", braketHelper(false));\ndefineMacro(\"\\\\bra@set\", braketHelper(true));\ndefineMacro(\"\\\\Braket\", \"\\\\bra@ket{\\\\left\\\\langle}\" + \"{\\\\,\\\\middle\\\\vert\\\\,}{\\\\,\\\\middle\\\\vert\\\\,}{\\\\right\\\\rangle}\");\ndefineMacro(\"\\\\Set\", \"\\\\bra@set{\\\\left\\\\{\\\\:}\" + \"{\\\\;\\\\middle\\\\vert\\\\;}{\\\\;\\\\middle\\\\Vert\\\\;}{\\\\:\\\\right\\\\}}\");\ndefineMacro(\"\\\\set\", \"\\\\bra@set{\\\\{\\\\,}{\\\\mid}{}{\\\\,\\\\}}\"); // has no support for special || or \\|\n//////////////////////////////////////////////////////////////////////\n// actuarialangle.dtx\n\ndefineMacro(\"\\\\angln\", \"{\\\\angl n}\"); // Custom Khan Academy colors, should be moved to an optional package\n\ndefineMacro(\"\\\\blue\", \"\\\\textcolor{##6495ed}{#1}\");\ndefineMacro(\"\\\\orange\", \"\\\\textcolor{##ffa500}{#1}\");\ndefineMacro(\"\\\\pink\", \"\\\\textcolor{##ff00af}{#1}\");\ndefineMacro(\"\\\\red\", \"\\\\textcolor{##df0030}{#1}\");\ndefineMacro(\"\\\\green\", \"\\\\textcolor{##28ae7b}{#1}\");\ndefineMacro(\"\\\\gray\", \"\\\\textcolor{gray}{#1}\");\ndefineMacro(\"\\\\purple\", \"\\\\textcolor{##9d38bd}{#1}\");\ndefineMacro(\"\\\\blueA\", \"\\\\textcolor{##ccfaff}{#1}\");\ndefineMacro(\"\\\\blueB\", \"\\\\textcolor{##80f6ff}{#1}\");\ndefineMacro(\"\\\\blueC\", \"\\\\textcolor{##63d9ea}{#1}\");\ndefineMacro(\"\\\\blueD\", \"\\\\textcolor{##11accd}{#1}\");\ndefineMacro(\"\\\\blueE\", \"\\\\textcolor{##0c7f99}{#1}\");\ndefineMacro(\"\\\\tealA\", \"\\\\textcolor{##94fff5}{#1}\");\ndefineMacro(\"\\\\tealB\", \"\\\\textcolor{##26edd5}{#1}\");\ndefineMacro(\"\\\\tealC\", \"\\\\textcolor{##01d1c1}{#1}\");\ndefineMacro(\"\\\\tealD\", \"\\\\textcolor{##01a995}{#1}\");\ndefineMacro(\"\\\\tealE\", \"\\\\textcolor{##208170}{#1}\");\ndefineMacro(\"\\\\greenA\", \"\\\\textcolor{##b6ffb0}{#1}\");\ndefineMacro(\"\\\\greenB\", \"\\\\textcolor{##8af281}{#1}\");\ndefineMacro(\"\\\\greenC\", \"\\\\textcolor{##74cf70}{#1}\");\ndefineMacro(\"\\\\greenD\", \"\\\\textcolor{##1fab54}{#1}\");\ndefineMacro(\"\\\\greenE\", \"\\\\textcolor{##0d923f}{#1}\");\ndefineMacro(\"\\\\goldA\", \"\\\\textcolor{##ffd0a9}{#1}\");\ndefineMacro(\"\\\\goldB\", \"\\\\textcolor{##ffbb71}{#1}\");\ndefineMacro(\"\\\\goldC\", \"\\\\textcolor{##ff9c39}{#1}\");\ndefineMacro(\"\\\\goldD\", \"\\\\textcolor{##e07d10}{#1}\");\ndefineMacro(\"\\\\goldE\", \"\\\\textcolor{##a75a05}{#1}\");\ndefineMacro(\"\\\\redA\", \"\\\\textcolor{##fca9a9}{#1}\");\ndefineMacro(\"\\\\redB\", \"\\\\textcolor{##ff8482}{#1}\");\ndefineMacro(\"\\\\redC\", \"\\\\textcolor{##f9685d}{#1}\");\ndefineMacro(\"\\\\redD\", \"\\\\textcolor{##e84d39}{#1}\");\ndefineMacro(\"\\\\redE\", \"\\\\textcolor{##bc2612}{#1}\");\ndefineMacro(\"\\\\maroonA\", \"\\\\textcolor{##ffbde0}{#1}\");\ndefineMacro(\"\\\\maroonB\", \"\\\\textcolor{##ff92c6}{#1}\");\ndefineMacro(\"\\\\maroonC\", \"\\\\textcolor{##ed5fa6}{#1}\");\ndefineMacro(\"\\\\maroonD\", \"\\\\textcolor{##ca337c}{#1}\");\ndefineMacro(\"\\\\maroonE\", \"\\\\textcolor{##9e034e}{#1}\");\ndefineMacro(\"\\\\purpleA\", \"\\\\textcolor{##ddd7ff}{#1}\");\ndefineMacro(\"\\\\purpleB\", \"\\\\textcolor{##c6b9fc}{#1}\");\ndefineMacro(\"\\\\purpleC\", \"\\\\textcolor{##aa87ff}{#1}\");\ndefineMacro(\"\\\\purpleD\", \"\\\\textcolor{##7854ab}{#1}\");\ndefineMacro(\"\\\\purpleE\", \"\\\\textcolor{##543b78}{#1}\");\ndefineMacro(\"\\\\mintA\", \"\\\\textcolor{##f5f9e8}{#1}\");\ndefineMacro(\"\\\\mintB\", \"\\\\textcolor{##edf2df}{#1}\");\ndefineMacro(\"\\\\mintC\", \"\\\\textcolor{##e0e5cc}{#1}\");\ndefineMacro(\"\\\\grayA\", \"\\\\textcolor{##f6f7f7}{#1}\");\ndefineMacro(\"\\\\grayB\", \"\\\\textcolor{##f0f1f2}{#1}\");\ndefineMacro(\"\\\\grayC\", \"\\\\textcolor{##e3e5e6}{#1}\");\ndefineMacro(\"\\\\grayD\", \"\\\\textcolor{##d6d8da}{#1}\");\ndefineMacro(\"\\\\grayE\", \"\\\\textcolor{##babec2}{#1}\");\ndefineMacro(\"\\\\grayF\", \"\\\\textcolor{##888d93}{#1}\");\ndefineMacro(\"\\\\grayG\", \"\\\\textcolor{##626569}{#1}\");\ndefineMacro(\"\\\\grayH\", \"\\\\textcolor{##3b3e40}{#1}\");\ndefineMacro(\"\\\\grayI\", \"\\\\textcolor{##21242c}{#1}\");\ndefineMacro(\"\\\\kaBlue\", \"\\\\textcolor{##314453}{#1}\");\ndefineMacro(\"\\\\kaGreen\", \"\\\\textcolor{##71B307}{#1}\");\n;// CONCATENATED MODULE: ./src/MacroExpander.js\n/**\n * This file contains the gullet where macros are expanded\n * until only non-macro tokens remain.\n */\n\n\n\n\n\n\n\n// List of commands that act like macros but aren't defined as a macro,\n// function, or symbol.  Used in `isDefined`.\nconst implicitCommands = {\n  \"^\": true,\n  // Parser.js\n  \"_\": true,\n  // Parser.js\n  \"\\\\limits\": true,\n  // Parser.js\n  \"\\\\nolimits\": true // Parser.js\n\n};\nclass MacroExpander {\n  constructor(input, settings, mode) {\n    this.settings = void 0;\n    this.expansionCount = void 0;\n    this.lexer = void 0;\n    this.macros = void 0;\n    this.stack = void 0;\n    this.mode = void 0;\n    this.settings = settings;\n    this.expansionCount = 0;\n    this.feed(input); // Make new global namespace\n\n    this.macros = new Namespace(src_macros, settings.macros);\n    this.mode = mode;\n    this.stack = []; // contains tokens in REVERSE order\n  }\n  /**\n   * Feed a new input string to the same MacroExpander\n   * (with existing macros etc.).\n   */\n\n\n  feed(input) {\n    this.lexer = new Lexer(input, this.settings);\n  }\n  /**\n   * Switches between \"text\" and \"math\" modes.\n   */\n\n\n  switchMode(newMode) {\n    this.mode = newMode;\n  }\n  /**\n   * Start a new group nesting within all namespaces.\n   */\n\n\n  beginGroup() {\n    this.macros.beginGroup();\n  }\n  /**\n   * End current group nesting within all namespaces.\n   */\n\n\n  endGroup() {\n    this.macros.endGroup();\n  }\n  /**\n   * Ends all currently nested groups (if any), restoring values before the\n   * groups began.  Useful in case of an error in the middle of parsing.\n   */\n\n\n  endGroups() {\n    this.macros.endGroups();\n  }\n  /**\n   * Returns the topmost token on the stack, without expanding it.\n   * Similar in behavior to TeX's `\\futurelet`.\n   */\n\n\n  future() {\n    if (this.stack.length === 0) {\n      this.pushToken(this.lexer.lex());\n    }\n\n    return this.stack[this.stack.length - 1];\n  }\n  /**\n   * Remove and return the next unexpanded token.\n   */\n\n\n  popToken() {\n    this.future(); // ensure non-empty stack\n\n    return this.stack.pop();\n  }\n  /**\n   * Add a given token to the token stack.  In particular, this get be used\n   * to put back a token returned from one of the other methods.\n   */\n\n\n  pushToken(token) {\n    this.stack.push(token);\n  }\n  /**\n   * Append an array of tokens to the token stack.\n   */\n\n\n  pushTokens(tokens) {\n    this.stack.push(...tokens);\n  }\n  /**\n   * Find an macro argument without expanding tokens and append the array of\n   * tokens to the token stack. Uses Token as a container for the result.\n   */\n\n\n  scanArgument(isOptional) {\n    let start;\n    let end;\n    let tokens;\n\n    if (isOptional) {\n      this.consumeSpaces(); // \\@ifnextchar gobbles any space following it\n\n      if (this.future().text !== \"[\") {\n        return null;\n      }\n\n      start = this.popToken(); // don't include [ in tokens\n\n      ({\n        tokens,\n        end\n      } = this.consumeArg([\"]\"]));\n    } else {\n      ({\n        tokens,\n        start,\n        end\n      } = this.consumeArg());\n    } // indicate the end of an argument\n\n\n    this.pushToken(new Token(\"EOF\", end.loc));\n    this.pushTokens(tokens);\n    return start.range(end, \"\");\n  }\n  /**\n   * Consume all following space tokens, without expansion.\n   */\n\n\n  consumeSpaces() {\n    for (;;) {\n      const token = this.future();\n\n      if (token.text === \" \") {\n        this.stack.pop();\n      } else {\n        break;\n      }\n    }\n  }\n  /**\n   * Consume an argument from the token stream, and return the resulting array\n   * of tokens and start/end token.\n   */\n\n\n  consumeArg(delims) {\n    // The argument for a delimited parameter is the shortest (possibly\n    // empty) sequence of tokens with properly nested {...} groups that is\n    // followed ... by this particular list of non-parameter tokens.\n    // The argument for an undelimited parameter is the next nonblank\n    // token, unless that token is {, when the argument will be the\n    // entire {...} group that follows.\n    const tokens = [];\n    const isDelimited = delims && delims.length > 0;\n\n    if (!isDelimited) {\n      // Ignore spaces between arguments.  As the TeXbook says:\n      // \"After you have said \\def\\row#1#2{...}, you are allowed to\n      //  put spaces between the arguments (e.g., \\row x n), because\n      //  TeX doesnt use single spaces as undelimited arguments.\"\n      this.consumeSpaces();\n    }\n\n    const start = this.future();\n    let tok;\n    let depth = 0;\n    let match = 0;\n\n    do {\n      tok = this.popToken();\n      tokens.push(tok);\n\n      if (tok.text === \"{\") {\n        ++depth;\n      } else if (tok.text === \"}\") {\n        --depth;\n\n        if (depth === -1) {\n          throw new src_ParseError(\"Extra }\", tok);\n        }\n      } else if (tok.text === \"EOF\") {\n        throw new src_ParseError(\"Unexpected end of input in a macro argument\" + \", expected '\" + (delims && isDelimited ? delims[match] : \"}\") + \"'\", tok);\n      }\n\n      if (delims && isDelimited) {\n        if ((depth === 0 || depth === 1 && delims[match] === \"{\") && tok.text === delims[match]) {\n          ++match;\n\n          if (match === delims.length) {\n            // don't include delims in tokens\n            tokens.splice(-match, match);\n            break;\n          }\n        } else {\n          match = 0;\n        }\n      }\n    } while (depth !== 0 || isDelimited); // If the argument found ... has the form {<nested tokens>},\n    // ... the outermost braces enclosing the argument are removed\n\n\n    if (start.text === \"{\" && tokens[tokens.length - 1].text === \"}\") {\n      tokens.pop();\n      tokens.shift();\n    }\n\n    tokens.reverse(); // to fit in with stack order\n\n    return {\n      tokens,\n      start,\n      end: tok\n    };\n  }\n  /**\n   * Consume the specified number of (delimited) arguments from the token\n   * stream and return the resulting array of arguments.\n   */\n\n\n  consumeArgs(numArgs, delimiters) {\n    if (delimiters) {\n      if (delimiters.length !== numArgs + 1) {\n        throw new src_ParseError(\"The length of delimiters doesn't match the number of args!\");\n      }\n\n      const delims = delimiters[0];\n\n      for (let i = 0; i < delims.length; i++) {\n        const tok = this.popToken();\n\n        if (delims[i] !== tok.text) {\n          throw new src_ParseError(\"Use of the macro doesn't match its definition\", tok);\n        }\n      }\n    }\n\n    const args = [];\n\n    for (let i = 0; i < numArgs; i++) {\n      args.push(this.consumeArg(delimiters && delimiters[i + 1]).tokens);\n    }\n\n    return args;\n  }\n  /**\n   * Increment `expansionCount` by the specified amount.\n   * Throw an error if it exceeds `maxExpand`.\n   */\n\n\n  countExpansion(amount) {\n    this.expansionCount += amount;\n\n    if (this.expansionCount > this.settings.maxExpand) {\n      throw new src_ParseError(\"Too many expansions: infinite loop or \" + \"need to increase maxExpand setting\");\n    }\n  }\n  /**\n   * Expand the next token only once if possible.\n   *\n   * If the token is expanded, the resulting tokens will be pushed onto\n   * the stack in reverse order, and the number of such tokens will be\n   * returned.  This number might be zero or positive.\n   *\n   * If not, the return value is `false`, and the next token remains at the\n   * top of the stack.\n   *\n   * In either case, the next token will be on the top of the stack,\n   * or the stack will be empty (in case of empty expansion\n   * and no other tokens).\n   *\n   * Used to implement `expandAfterFuture` and `expandNextToken`.\n   *\n   * If expandableOnly, only expandable tokens are expanded and\n   * an undefined control sequence results in an error.\n   */\n\n\n  expandOnce(expandableOnly) {\n    const topToken = this.popToken();\n    const name = topToken.text;\n    const expansion = !topToken.noexpand ? this._getExpansion(name) : null;\n\n    if (expansion == null || expandableOnly && expansion.unexpandable) {\n      if (expandableOnly && expansion == null && name[0] === \"\\\\\" && !this.isDefined(name)) {\n        throw new src_ParseError(\"Undefined control sequence: \" + name);\n      }\n\n      this.pushToken(topToken);\n      return false;\n    }\n\n    this.countExpansion(1);\n    let tokens = expansion.tokens;\n    const args = this.consumeArgs(expansion.numArgs, expansion.delimiters);\n\n    if (expansion.numArgs) {\n      // paste arguments in place of the placeholders\n      tokens = tokens.slice(); // make a shallow copy\n\n      for (let i = tokens.length - 1; i >= 0; --i) {\n        let tok = tokens[i];\n\n        if (tok.text === \"#\") {\n          if (i === 0) {\n            throw new src_ParseError(\"Incomplete placeholder at end of macro body\", tok);\n          }\n\n          tok = tokens[--i]; // next token on stack\n\n          if (tok.text === \"#\") {\n            // ##  #\n            tokens.splice(i + 1, 1); // drop first #\n          } else if (/^[1-9]$/.test(tok.text)) {\n            // replace the placeholder with the indicated argument\n            tokens.splice(i, 2, ...args[+tok.text - 1]);\n          } else {\n            throw new src_ParseError(\"Not a valid argument number\", tok);\n          }\n        }\n      }\n    } // Concatenate expansion onto top of stack.\n\n\n    this.pushTokens(tokens);\n    return tokens.length;\n  }\n  /**\n   * Expand the next token only once (if possible), and return the resulting\n   * top token on the stack (without removing anything from the stack).\n   * Similar in behavior to TeX's `\\expandafter\\futurelet`.\n   * Equivalent to expandOnce() followed by future().\n   */\n\n\n  expandAfterFuture() {\n    this.expandOnce();\n    return this.future();\n  }\n  /**\n   * Recursively expand first token, then return first non-expandable token.\n   */\n\n\n  expandNextToken() {\n    for (;;) {\n      if (this.expandOnce() === false) {\n        // fully expanded\n        const token = this.stack.pop(); // the token after \\noexpand is interpreted as if its meaning\n        // were \\relax\n\n        if (token.treatAsRelax) {\n          token.text = \"\\\\relax\";\n        }\n\n        return token;\n      }\n    } // Flow unable to figure out that this pathway is impossible.\n    // https://github.com/facebook/flow/issues/4808\n\n\n    throw new Error(); // eslint-disable-line no-unreachable\n  }\n  /**\n   * Fully expand the given macro name and return the resulting list of\n   * tokens, or return `undefined` if no such macro is defined.\n   */\n\n\n  expandMacro(name) {\n    return this.macros.has(name) ? this.expandTokens([new Token(name)]) : undefined;\n  }\n  /**\n   * Fully expand the given token stream and return the resulting list of\n   * tokens.  Note that the input tokens are in reverse order, but the\n   * output tokens are in forward order.\n   */\n\n\n  expandTokens(tokens) {\n    const output = [];\n    const oldStackLength = this.stack.length;\n    this.pushTokens(tokens);\n\n    while (this.stack.length > oldStackLength) {\n      // Expand only expandable tokens\n      if (this.expandOnce(true) === false) {\n        // fully expanded\n        const token = this.stack.pop();\n\n        if (token.treatAsRelax) {\n          // the expansion of \\noexpand is the token itself\n          token.noexpand = false;\n          token.treatAsRelax = false;\n        }\n\n        output.push(token);\n      }\n    } // Count all of these tokens as additional expansions, to prevent\n    // exponential blowup from linearly many \\edef's.\n\n\n    this.countExpansion(output.length);\n    return output;\n  }\n  /**\n   * Fully expand the given macro name and return the result as a string,\n   * or return `undefined` if no such macro is defined.\n   */\n\n\n  expandMacroAsText(name) {\n    const tokens = this.expandMacro(name);\n\n    if (tokens) {\n      return tokens.map(token => token.text).join(\"\");\n    } else {\n      return tokens;\n    }\n  }\n  /**\n   * Returns the expanded macro as a reversed array of tokens and a macro\n   * argument count.  Or returns `null` if no such macro.\n   */\n\n\n  _getExpansion(name) {\n    const definition = this.macros.get(name);\n\n    if (definition == null) {\n      // mainly checking for undefined here\n      return definition;\n    } // If a single character has an associated catcode other than 13\n    // (active character), then don't expand it.\n\n\n    if (name.length === 1) {\n      const catcode = this.lexer.catcodes[name];\n\n      if (catcode != null && catcode !== 13) {\n        return;\n      }\n    }\n\n    const expansion = typeof definition === \"function\" ? definition(this) : definition;\n\n    if (typeof expansion === \"string\") {\n      let numArgs = 0;\n\n      if (expansion.indexOf(\"#\") !== -1) {\n        const stripped = expansion.replace(/##/g, \"\");\n\n        while (stripped.indexOf(\"#\" + (numArgs + 1)) !== -1) {\n          ++numArgs;\n        }\n      }\n\n      const bodyLexer = new Lexer(expansion, this.settings);\n      const tokens = [];\n      let tok = bodyLexer.lex();\n\n      while (tok.text !== \"EOF\") {\n        tokens.push(tok);\n        tok = bodyLexer.lex();\n      }\n\n      tokens.reverse(); // to fit in with stack using push and pop\n\n      const expanded = {\n        tokens,\n        numArgs\n      };\n      return expanded;\n    }\n\n    return expansion;\n  }\n  /**\n   * Determine whether a command is currently \"defined\" (has some\n   * functionality), meaning that it's a macro (in the current group),\n   * a function, a symbol, or one of the special commands listed in\n   * `implicitCommands`.\n   */\n\n\n  isDefined(name) {\n    return this.macros.has(name) || src_functions.hasOwnProperty(name) || src_symbols.math.hasOwnProperty(name) || src_symbols.text.hasOwnProperty(name) || implicitCommands.hasOwnProperty(name);\n  }\n  /**\n   * Determine whether a command is expandable.\n   */\n\n\n  isExpandable(name) {\n    const macro = this.macros.get(name);\n    return macro != null ? typeof macro === \"string\" || typeof macro === \"function\" || !macro.unexpandable : src_functions.hasOwnProperty(name) && !src_functions[name].primitive;\n  }\n\n}\n;// CONCATENATED MODULE: ./src/unicodeSupOrSub.js\n// Helpers for Parser.js handling of Unicode (sub|super)script characters.\nconst unicodeSubRegEx = /^[]/;\nconst uSubsAndSups = Object.freeze({\n  '': '+',\n  '': '-',\n  '': '=',\n  '': '(',\n  '': ')',\n  '': '0',\n  '': '1',\n  '': '2',\n  '': '3',\n  '': '4',\n  '': '5',\n  '': '6',\n  '': '7',\n  '': '8',\n  '': '9',\n  '\\u2090': 'a',\n  '\\u2091': 'e',\n  '\\u2095': 'h',\n  '\\u1D62': 'i',\n  '\\u2C7C': 'j',\n  '\\u2096': 'k',\n  '\\u2097': 'l',\n  '\\u2098': 'm',\n  '\\u2099': 'n',\n  '\\u2092': 'o',\n  '\\u209A': 'p',\n  '\\u1D63': 'r',\n  '\\u209B': 's',\n  '\\u209C': 't',\n  '\\u1D64': 'u',\n  '\\u1D65': 'v',\n  '\\u2093': 'x',\n  '\\u1D66': '',\n  '\\u1D67': '',\n  '\\u1D68': '',\n  '\\u1D69': '\\u03d5',\n  '\\u1D6A': '',\n  '': '+',\n  '': '-',\n  '': '=',\n  '': '(',\n  '': ')',\n  '': '0',\n  '': '1',\n  '': '2',\n  '': '3',\n  '': '4',\n  '': '5',\n  '': '6',\n  '': '7',\n  '': '8',\n  '': '9',\n  '\\u1D2C': 'A',\n  '\\u1D2E': 'B',\n  '\\u1D30': 'D',\n  '\\u1D31': 'E',\n  '\\u1D33': 'G',\n  '\\u1D34': 'H',\n  '\\u1D35': 'I',\n  '\\u1D36': 'J',\n  '\\u1D37': 'K',\n  '\\u1D38': 'L',\n  '\\u1D39': 'M',\n  '\\u1D3A': 'N',\n  '\\u1D3C': 'O',\n  '\\u1D3E': 'P',\n  '\\u1D3F': 'R',\n  '\\u1D40': 'T',\n  '\\u1D41': 'U',\n  '\\u2C7D': 'V',\n  '\\u1D42': 'W',\n  '\\u1D43': 'a',\n  '\\u1D47': 'b',\n  '\\u1D9C': 'c',\n  '\\u1D48': 'd',\n  '\\u1D49': 'e',\n  '\\u1DA0': 'f',\n  '\\u1D4D': 'g',\n  '\\u02B0': 'h',\n  '\\u2071': 'i',\n  '\\u02B2': 'j',\n  '\\u1D4F': 'k',\n  '\\u02E1': 'l',\n  '\\u1D50': 'm',\n  '\\u207F': 'n',\n  '\\u1D52': 'o',\n  '\\u1D56': 'p',\n  '\\u02B3': 'r',\n  '\\u02E2': 's',\n  '\\u1D57': 't',\n  '\\u1D58': 'u',\n  '\\u1D5B': 'v',\n  '\\u02B7': 'w',\n  '\\u02E3': 'x',\n  '\\u02B8': 'y',\n  '\\u1DBB': 'z',\n  '\\u1D5D': '',\n  '\\u1D5E': '',\n  '\\u1D5F': '',\n  '\\u1D60': '\\u03d5',\n  '\\u1D61': '',\n  '\\u1DBF': ''\n});\n;// CONCATENATED MODULE: ./src/Parser.js\n/* eslint no-constant-condition:0 */\n\n\n\n\n\n\n\n\n\n\n // Pre-evaluate both modules as unicodeSymbols require String.normalize()\n\nconst unicodeAccents = {\n  \"\": {\n    \"text\": \"\\\\'\",\n    \"math\": \"\\\\acute\"\n  },\n  \"\": {\n    \"text\": \"\\\\`\",\n    \"math\": \"\\\\grave\"\n  },\n  \"\": {\n    \"text\": \"\\\\\\\"\",\n    \"math\": \"\\\\ddot\"\n  },\n  \"\": {\n    \"text\": \"\\\\~\",\n    \"math\": \"\\\\tilde\"\n  },\n  \"\": {\n    \"text\": \"\\\\=\",\n    \"math\": \"\\\\bar\"\n  },\n  \"\": {\n    \"text\": \"\\\\u\",\n    \"math\": \"\\\\breve\"\n  },\n  \"\": {\n    \"text\": \"\\\\v\",\n    \"math\": \"\\\\check\"\n  },\n  \"\": {\n    \"text\": \"\\\\^\",\n    \"math\": \"\\\\hat\"\n  },\n  \"\": {\n    \"text\": \"\\\\.\",\n    \"math\": \"\\\\dot\"\n  },\n  \"\": {\n    \"text\": \"\\\\r\",\n    \"math\": \"\\\\mathring\"\n  },\n  \"\": {\n    \"text\": \"\\\\H\"\n  },\n  \"\": {\n    \"text\": \"\\\\c\"\n  }\n};\nconst unicodeSymbols = {\n  \"\": \"a\",\n  \"\": \"a\",\n  \"\": \"a\",\n  \"\": \"a\",\n  \"\": \"a\",\n  \"\": \"a\",\n  \"\": \"a\",\n  \"\": \"a\",\n  \"\": \"a\",\n  \"\": \"a\",\n  \"\": \"a\",\n  \"\": \"a\",\n  \"\": \"a\",\n  \"\": \"a\",\n  \"\": \"a\",\n  \"\": \"a\",\n  \"\": \"a\",\n  \"\": \"a\",\n  \"\": \"a\",\n  \"\": \"b\",\n  \"\": \"c\",\n  \"\": \"c\",\n  \"\": \"c\",\n  \"\": \"c\",\n  \"\": \"c\",\n  \"\": \"c\",\n  \"\": \"d\",\n  \"\": \"d\",\n  \"\": \"d\",\n  \"\": \"e\",\n  \"\": \"e\",\n  \"\": \"e\",\n  \"\": \"e\",\n  \"\": \"e\",\n  \"\": \"e\",\n  \"\": \"e\",\n  \"\": \"e\",\n  \"\": \"e\",\n  \"\": \"e\",\n  \"\": \"e\",\n  \"\": \"e\",\n  \"\": \"e\",\n  \"\": \"e\",\n  \"\": \"e\",\n  \"\": \"e\",\n  \"\": \"f\",\n  \"\": \"g\",\n  \"\": \"g\",\n  \"\": \"g\",\n  \"\": \"g\",\n  \"\": \"g\",\n  \"\": \"g\",\n  \"\": \"g\",\n  \"\": \"h\",\n  \"\": \"h\",\n  \"\": \"h\",\n  \"\": \"h\",\n  \"\": \"h\",\n  \"\": \"i\",\n  \"\": \"i\",\n  \"\": \"i\",\n  \"\": \"i\",\n  \"\": \"i\",\n  \"\": \"i\",\n  \"\": \"i\",\n  \"\": \"i\",\n  \"\": \"i\",\n  \"\": \"j\",\n  \"\": \"j\",\n  \"\": \"k\",\n  \"\": \"k\",\n  \"\": \"k\",\n  \"\": \"l\",\n  \"\": \"l\",\n  \"\": \"l\",\n  \"\": \"m\",\n  \"\": \"m\",\n  \"\": \"n\",\n  \"\": \"n\",\n  \"\": \"n\",\n  \"\": \"n\",\n  \"\": \"n\",\n  \"\": \"n\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"p\",\n  \"\": \"p\",\n  \"\": \"r\",\n  \"\": \"r\",\n  \"\": \"r\",\n  \"\": \"r\",\n  \"\": \"s\",\n  \"\": \"s\",\n  \"\": \"s\",\n  \"\": \"s\",\n  \"\": \"s\",\n  \"\": \"s\",\n  \"\": \"s\",\n  \"\": \"t\",\n  \"\": \"t\",\n  \"\": \"t\",\n  \"\": \"t\",\n  \"\": \"u\",\n  \"\": \"u\",\n  \"\": \"u\",\n  \"\": \"u\",\n  \"\": \"u\",\n  \"\": \"u\",\n  \"\": \"u\",\n  \"\": \"u\",\n  \"\": \"u\",\n  \"\": \"u\",\n  \"\": \"u\",\n  \"\": \"u\",\n  \"\": \"u\",\n  \"\": \"u\",\n  \"\": \"u\",\n  \"\": \"u\",\n  \"\": \"v\",\n  \"\": \"w\",\n  \"\": \"w\",\n  \"\": \"w\",\n  \"\": \"w\",\n  \"\": \"w\",\n  \"\": \"w\",\n  \"\": \"x\",\n  \"\": \"x\",\n  \"\": \"y\",\n  \"\": \"y\",\n  \"\": \"y\",\n  \"\": \"y\",\n  \"\": \"y\",\n  \"\": \"y\",\n  \"\": \"y\",\n  \"\": \"y\",\n  \"\": \"z\",\n  \"\": \"z\",\n  \"\": \"z\",\n  \"\": \"z\",\n  \"\": \"A\",\n  \"\": \"A\",\n  \"\": \"A\",\n  \"\": \"A\",\n  \"\": \"A\",\n  \"\": \"A\",\n  \"\": \"A\",\n  \"\": \"A\",\n  \"\": \"A\",\n  \"\": \"A\",\n  \"\": \"A\",\n  \"\": \"A\",\n  \"\": \"A\",\n  \"\": \"A\",\n  \"\": \"A\",\n  \"\": \"A\",\n  \"\": \"A\",\n  \"\": \"A\",\n  \"\": \"A\",\n  \"\": \"B\",\n  \"\": \"C\",\n  \"\": \"C\",\n  \"\": \"C\",\n  \"\": \"C\",\n  \"\": \"C\",\n  \"\": \"C\",\n  \"\": \"D\",\n  \"\": \"D\",\n  \"\": \"D\",\n  \"\": \"E\",\n  \"\": \"E\",\n  \"\": \"E\",\n  \"\": \"E\",\n  \"\": \"E\",\n  \"\": \"E\",\n  \"\": \"E\",\n  \"\": \"E\",\n  \"\": \"E\",\n  \"\": \"E\",\n  \"\": \"E\",\n  \"\": \"E\",\n  \"\": \"E\",\n  \"\": \"E\",\n  \"\": \"E\",\n  \"\": \"E\",\n  \"\": \"F\",\n  \"\": \"G\",\n  \"\": \"G\",\n  \"\": \"G\",\n  \"\": \"G\",\n  \"\": \"G\",\n  \"\": \"G\",\n  \"\": \"G\",\n  \"\": \"H\",\n  \"\": \"H\",\n  \"\": \"H\",\n  \"\": \"H\",\n  \"\": \"H\",\n  \"\": \"I\",\n  \"\": \"I\",\n  \"\": \"I\",\n  \"\": \"I\",\n  \"\": \"I\",\n  \"\": \"I\",\n  \"\": \"I\",\n  \"\": \"I\",\n  \"\": \"I\",\n  \"\": \"I\",\n  \"\": \"J\",\n  \"\": \"K\",\n  \"\": \"K\",\n  \"\": \"K\",\n  \"\": \"L\",\n  \"\": \"L\",\n  \"\": \"L\",\n  \"\": \"M\",\n  \"\": \"M\",\n  \"\": \"N\",\n  \"\": \"N\",\n  \"\": \"N\",\n  \"\": \"N\",\n  \"\": \"N\",\n  \"\": \"N\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"P\",\n  \"\": \"P\",\n  \"\": \"R\",\n  \"\": \"R\",\n  \"\": \"R\",\n  \"\": \"R\",\n  \"\": \"S\",\n  \"\": \"S\",\n  \"\": \"S\",\n  \"\": \"S\",\n  \"\": \"S\",\n  \"\": \"S\",\n  \"\": \"S\",\n  \"\": \"T\",\n  \"\": \"T\",\n  \"\": \"T\",\n  \"\": \"U\",\n  \"\": \"U\",\n  \"\": \"U\",\n  \"\": \"U\",\n  \"\": \"U\",\n  \"\": \"U\",\n  \"\": \"U\",\n  \"\": \"U\",\n  \"\": \"U\",\n  \"\": \"U\",\n  \"\": \"U\",\n  \"\": \"U\",\n  \"\": \"U\",\n  \"\": \"U\",\n  \"\": \"U\",\n  \"\": \"U\",\n  \"\": \"V\",\n  \"\": \"W\",\n  \"\": \"W\",\n  \"\": \"W\",\n  \"\": \"W\",\n  \"\": \"W\",\n  \"\": \"X\",\n  \"\": \"X\",\n  \"\": \"Y\",\n  \"\": \"Y\",\n  \"\": \"Y\",\n  \"\": \"Y\",\n  \"\": \"Y\",\n  \"\": \"Y\",\n  \"\": \"Y\",\n  \"\": \"Z\",\n  \"\": \"Z\",\n  \"\": \"Z\",\n  \"\": \"Z\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\"\n};\n\n/**\n * This file contains the parser used to parse out a TeX expression from the\n * input. Since TeX isn't context-free, standard parsers don't work particularly\n * well.\n *\n * The strategy of this parser is as such:\n *\n * The main functions (the `.parse...` ones) take a position in the current\n * parse string to parse tokens from. The lexer (found in Lexer.js, stored at\n * this.gullet.lexer) also supports pulling out tokens at arbitrary places. When\n * individual tokens are needed at a position, the lexer is called to pull out a\n * token, which is then used.\n *\n * The parser has a property called \"mode\" indicating the mode that\n * the parser is currently in. Currently it has to be one of \"math\" or\n * \"text\", which denotes whether the current environment is a math-y\n * one or a text-y one (e.g. inside \\text). Currently, this serves to\n * limit the functions which can be used in text mode.\n *\n * The main functions then return an object which contains the useful data that\n * was parsed at its given point, and a new position at the end of the parsed\n * data. The main functions can call each other and continue the parsing by\n * using the returned position as a new starting point.\n *\n * There are also extra `.handle...` functions, which pull out some reused\n * functionality into self-contained functions.\n *\n * The functions return ParseNodes.\n */\nclass Parser {\n  constructor(input, settings) {\n    this.mode = void 0;\n    this.gullet = void 0;\n    this.settings = void 0;\n    this.leftrightDepth = void 0;\n    this.nextToken = void 0;\n    // Start in math mode\n    this.mode = \"math\"; // Create a new macro expander (gullet) and (indirectly via that) also a\n    // new lexer (mouth) for this parser (stomach, in the language of TeX)\n\n    this.gullet = new MacroExpander(input, settings, this.mode); // Store the settings for use in parsing\n\n    this.settings = settings; // Count leftright depth (for \\middle errors)\n\n    this.leftrightDepth = 0;\n  }\n  /**\n   * Checks a result to make sure it has the right type, and throws an\n   * appropriate error otherwise.\n   */\n\n\n  expect(text, consume) {\n    if (consume === void 0) {\n      consume = true;\n    }\n\n    if (this.fetch().text !== text) {\n      throw new src_ParseError(\"Expected '\" + text + \"', got '\" + this.fetch().text + \"'\", this.fetch());\n    }\n\n    if (consume) {\n      this.consume();\n    }\n  }\n  /**\n   * Discards the current lookahead token, considering it consumed.\n   */\n\n\n  consume() {\n    this.nextToken = null;\n  }\n  /**\n   * Return the current lookahead token, or if there isn't one (at the\n   * beginning, or if the previous lookahead token was consume()d),\n   * fetch the next token as the new lookahead token and return it.\n   */\n\n\n  fetch() {\n    if (this.nextToken == null) {\n      this.nextToken = this.gullet.expandNextToken();\n    }\n\n    return this.nextToken;\n  }\n  /**\n   * Switches between \"text\" and \"math\" modes.\n   */\n\n\n  switchMode(newMode) {\n    this.mode = newMode;\n    this.gullet.switchMode(newMode);\n  }\n  /**\n   * Main parsing function, which parses an entire input.\n   */\n\n\n  parse() {\n    if (!this.settings.globalGroup) {\n      // Create a group namespace for the math expression.\n      // (LaTeX creates a new group for every $...$, $$...$$, \\[...\\].)\n      this.gullet.beginGroup();\n    } // Use old \\color behavior (same as LaTeX's \\textcolor) if requested.\n    // We do this within the group for the math expression, so it doesn't\n    // pollute settings.macros.\n\n\n    if (this.settings.colorIsTextColor) {\n      this.gullet.macros.set(\"\\\\color\", \"\\\\textcolor\");\n    }\n\n    try {\n      // Try to parse the input\n      const parse = this.parseExpression(false); // If we succeeded, make sure there's an EOF at the end\n\n      this.expect(\"EOF\"); // End the group namespace for the expression\n\n      if (!this.settings.globalGroup) {\n        this.gullet.endGroup();\n      }\n\n      return parse; // Close any leftover groups in case of a parse error.\n    } finally {\n      this.gullet.endGroups();\n    }\n  }\n  /**\n   * Fully parse a separate sequence of tokens as a separate job.\n   * Tokens should be specified in reverse order, as in a MacroDefinition.\n   */\n\n\n  subparse(tokens) {\n    // Save the next token from the current job.\n    const oldToken = this.nextToken;\n    this.consume(); // Run the new job, terminating it with an excess '}'\n\n    this.gullet.pushToken(new Token(\"}\"));\n    this.gullet.pushTokens(tokens);\n    const parse = this.parseExpression(false);\n    this.expect(\"}\"); // Restore the next token from the current job.\n\n    this.nextToken = oldToken;\n    return parse;\n  }\n\n  /**\n   * Parses an \"expression\", which is a list of atoms.\n   *\n   * `breakOnInfix`: Should the parsing stop when we hit infix nodes? This\n   *                 happens when functions have higher precedence han infix\n   *                 nodes in implicit parses.\n   *\n   * `breakOnTokenText`: The text of the token that the expression should end\n   *                     with, or `null` if something else should end the\n   *                     expression.\n   */\n  parseExpression(breakOnInfix, breakOnTokenText) {\n    const body = []; // Keep adding atoms to the body until we can't parse any more atoms (either\n    // we reached the end, a }, or a \\right)\n\n    while (true) {\n      // Ignore spaces in math mode\n      if (this.mode === \"math\") {\n        this.consumeSpaces();\n      }\n\n      const lex = this.fetch();\n\n      if (Parser.endOfExpression.indexOf(lex.text) !== -1) {\n        break;\n      }\n\n      if (breakOnTokenText && lex.text === breakOnTokenText) {\n        break;\n      }\n\n      if (breakOnInfix && src_functions[lex.text] && src_functions[lex.text].infix) {\n        break;\n      }\n\n      const atom = this.parseAtom(breakOnTokenText);\n\n      if (!atom) {\n        break;\n      } else if (atom.type === \"internal\") {\n        continue;\n      }\n\n      body.push(atom);\n    }\n\n    if (this.mode === \"text\") {\n      this.formLigatures(body);\n    }\n\n    return this.handleInfixNodes(body);\n  }\n  /**\n   * Rewrites infix operators such as \\over with corresponding commands such\n   * as \\frac.\n   *\n   * There can only be one infix operator per group.  If there's more than one\n   * then the expression is ambiguous.  This can be resolved by adding {}.\n   */\n\n\n  handleInfixNodes(body) {\n    let overIndex = -1;\n    let funcName;\n\n    for (let i = 0; i < body.length; i++) {\n      if (body[i].type === \"infix\") {\n        if (overIndex !== -1) {\n          throw new src_ParseError(\"only one infix operator per group\", body[i].token);\n        }\n\n        overIndex = i;\n        funcName = body[i].replaceWith;\n      }\n    }\n\n    if (overIndex !== -1 && funcName) {\n      let numerNode;\n      let denomNode;\n      const numerBody = body.slice(0, overIndex);\n      const denomBody = body.slice(overIndex + 1);\n\n      if (numerBody.length === 1 && numerBody[0].type === \"ordgroup\") {\n        numerNode = numerBody[0];\n      } else {\n        numerNode = {\n          type: \"ordgroup\",\n          mode: this.mode,\n          body: numerBody\n        };\n      }\n\n      if (denomBody.length === 1 && denomBody[0].type === \"ordgroup\") {\n        denomNode = denomBody[0];\n      } else {\n        denomNode = {\n          type: \"ordgroup\",\n          mode: this.mode,\n          body: denomBody\n        };\n      }\n\n      let node;\n\n      if (funcName === \"\\\\\\\\abovefrac\") {\n        node = this.callFunction(funcName, [numerNode, body[overIndex], denomNode], []);\n      } else {\n        node = this.callFunction(funcName, [numerNode, denomNode], []);\n      }\n\n      return [node];\n    } else {\n      return body;\n    }\n  }\n  /**\n   * Handle a subscript or superscript with nice errors.\n   */\n\n\n  handleSupSubscript(name // For error reporting.\n  ) {\n    const symbolToken = this.fetch();\n    const symbol = symbolToken.text;\n    this.consume();\n    this.consumeSpaces(); // ignore spaces before sup/subscript argument\n\n    const group = this.parseGroup(name);\n\n    if (!group) {\n      throw new src_ParseError(\"Expected group after '\" + symbol + \"'\", symbolToken);\n    }\n\n    return group;\n  }\n  /**\n   * Converts the textual input of an unsupported command into a text node\n   * contained within a color node whose color is determined by errorColor\n   */\n\n\n  formatUnsupportedCmd(text) {\n    const textordArray = [];\n\n    for (let i = 0; i < text.length; i++) {\n      textordArray.push({\n        type: \"textord\",\n        mode: \"text\",\n        text: text[i]\n      });\n    }\n\n    const textNode = {\n      type: \"text\",\n      mode: this.mode,\n      body: textordArray\n    };\n    const colorNode = {\n      type: \"color\",\n      mode: this.mode,\n      color: this.settings.errorColor,\n      body: [textNode]\n    };\n    return colorNode;\n  }\n  /**\n   * Parses a group with optional super/subscripts.\n   */\n\n\n  parseAtom(breakOnTokenText) {\n    // The body of an atom is an implicit group, so that things like\n    // \\left(x\\right)^2 work correctly.\n    const base = this.parseGroup(\"atom\", breakOnTokenText); // In text mode, we don't have superscripts or subscripts\n\n    if (this.mode === \"text\") {\n      return base;\n    } // Note that base may be empty (i.e. null) at this point.\n\n\n    let superscript;\n    let subscript;\n\n    while (true) {\n      // Guaranteed in math mode, so eat any spaces first.\n      this.consumeSpaces(); // Lex the first token\n\n      const lex = this.fetch();\n\n      if (lex.text === \"\\\\limits\" || lex.text === \"\\\\nolimits\") {\n        // We got a limit control\n        if (base && base.type === \"op\") {\n          const limits = lex.text === \"\\\\limits\";\n          base.limits = limits;\n          base.alwaysHandleSupSub = true;\n        } else if (base && base.type === \"operatorname\") {\n          if (base.alwaysHandleSupSub) {\n            base.limits = lex.text === \"\\\\limits\";\n          }\n        } else {\n          throw new src_ParseError(\"Limit controls must follow a math operator\", lex);\n        }\n\n        this.consume();\n      } else if (lex.text === \"^\") {\n        // We got a superscript start\n        if (superscript) {\n          throw new src_ParseError(\"Double superscript\", lex);\n        }\n\n        superscript = this.handleSupSubscript(\"superscript\");\n      } else if (lex.text === \"_\") {\n        // We got a subscript start\n        if (subscript) {\n          throw new src_ParseError(\"Double subscript\", lex);\n        }\n\n        subscript = this.handleSupSubscript(\"subscript\");\n      } else if (lex.text === \"'\") {\n        // We got a prime\n        if (superscript) {\n          throw new src_ParseError(\"Double superscript\", lex);\n        }\n\n        const prime = {\n          type: \"textord\",\n          mode: this.mode,\n          text: \"\\\\prime\"\n        }; // Many primes can be grouped together, so we handle this here\n\n        const primes = [prime];\n        this.consume(); // Keep lexing tokens until we get something that's not a prime\n\n        while (this.fetch().text === \"'\") {\n          // For each one, add another prime to the list\n          primes.push(prime);\n          this.consume();\n        } // If there's a superscript following the primes, combine that\n        // superscript in with the primes.\n\n\n        if (this.fetch().text === \"^\") {\n          primes.push(this.handleSupSubscript(\"superscript\"));\n        } // Put everything into an ordgroup as the superscript\n\n\n        superscript = {\n          type: \"ordgroup\",\n          mode: this.mode,\n          body: primes\n        };\n      } else if (uSubsAndSups[lex.text]) {\n        // A Unicode subscript or superscript character.\n        // We treat these similarly to the unicode-math package.\n        // So we render a string of Unicode (sub|super)scripts the\n        // same as a (sub|super)script of regular characters.\n        const isSub = unicodeSubRegEx.test(lex.text);\n        const subsupTokens = [];\n        subsupTokens.push(new Token(uSubsAndSups[lex.text]));\n        this.consume(); // Continue fetching tokens to fill out the string.\n\n        while (true) {\n          const token = this.fetch().text;\n\n          if (!uSubsAndSups[token]) {\n            break;\n          }\n\n          if (unicodeSubRegEx.test(token) !== isSub) {\n            break;\n          }\n\n          subsupTokens.unshift(new Token(uSubsAndSups[token]));\n          this.consume();\n        } // Now create a (sub|super)script.\n\n\n        const body = this.subparse(subsupTokens);\n\n        if (isSub) {\n          subscript = {\n            type: \"ordgroup\",\n            mode: \"math\",\n            body\n          };\n        } else {\n          superscript = {\n            type: \"ordgroup\",\n            mode: \"math\",\n            body\n          };\n        }\n      } else {\n        // If it wasn't ^, _, or ', stop parsing super/subscripts\n        break;\n      }\n    } // Base must be set if superscript or subscript are set per logic above,\n    // but need to check here for type check to pass.\n\n\n    if (superscript || subscript) {\n      // If we got either a superscript or subscript, create a supsub\n      return {\n        type: \"supsub\",\n        mode: this.mode,\n        base: base,\n        sup: superscript,\n        sub: subscript\n      };\n    } else {\n      // Otherwise return the original body\n      return base;\n    }\n  }\n  /**\n   * Parses an entire function, including its base and all of its arguments.\n   */\n\n\n  parseFunction(breakOnTokenText, name // For determining its context\n  ) {\n    const token = this.fetch();\n    const func = token.text;\n    const funcData = src_functions[func];\n\n    if (!funcData) {\n      return null;\n    }\n\n    this.consume(); // consume command token\n\n    if (name && name !== \"atom\" && !funcData.allowedInArgument) {\n      throw new src_ParseError(\"Got function '\" + func + \"' with no arguments\" + (name ? \" as \" + name : \"\"), token);\n    } else if (this.mode === \"text\" && !funcData.allowedInText) {\n      throw new src_ParseError(\"Can't use function '\" + func + \"' in text mode\", token);\n    } else if (this.mode === \"math\" && funcData.allowedInMath === false) {\n      throw new src_ParseError(\"Can't use function '\" + func + \"' in math mode\", token);\n    }\n\n    const {\n      args,\n      optArgs\n    } = this.parseArguments(func, funcData);\n    return this.callFunction(func, args, optArgs, token, breakOnTokenText);\n  }\n  /**\n   * Call a function handler with a suitable context and arguments.\n   */\n\n\n  callFunction(name, args, optArgs, token, breakOnTokenText) {\n    const context = {\n      funcName: name,\n      parser: this,\n      token,\n      breakOnTokenText\n    };\n    const func = src_functions[name];\n\n    if (func && func.handler) {\n      return func.handler(context, args, optArgs);\n    } else {\n      throw new src_ParseError(\"No function handler for \" + name);\n    }\n  }\n  /**\n   * Parses the arguments of a function or environment\n   */\n\n\n  parseArguments(func, // Should look like \"\\name\" or \"\\begin{name}\".\n  funcData) {\n    const totalArgs = funcData.numArgs + funcData.numOptionalArgs;\n\n    if (totalArgs === 0) {\n      return {\n        args: [],\n        optArgs: []\n      };\n    }\n\n    const args = [];\n    const optArgs = [];\n\n    for (let i = 0; i < totalArgs; i++) {\n      let argType = funcData.argTypes && funcData.argTypes[i];\n      const isOptional = i < funcData.numOptionalArgs;\n\n      if (funcData.primitive && argType == null || // \\sqrt expands into primitive if optional argument doesn't exist\n      funcData.type === \"sqrt\" && i === 1 && optArgs[0] == null) {\n        argType = \"primitive\";\n      }\n\n      const arg = this.parseGroupOfType(\"argument to '\" + func + \"'\", argType, isOptional);\n\n      if (isOptional) {\n        optArgs.push(arg);\n      } else if (arg != null) {\n        args.push(arg);\n      } else {\n        // should be unreachable\n        throw new src_ParseError(\"Null argument, please report this as a bug\");\n      }\n    }\n\n    return {\n      args,\n      optArgs\n    };\n  }\n  /**\n   * Parses a group when the mode is changing.\n   */\n\n\n  parseGroupOfType(name, type, optional) {\n    switch (type) {\n      case \"color\":\n        return this.parseColorGroup(optional);\n\n      case \"size\":\n        return this.parseSizeGroup(optional);\n\n      case \"url\":\n        return this.parseUrlGroup(optional);\n\n      case \"math\":\n      case \"text\":\n        return this.parseArgumentGroup(optional, type);\n\n      case \"hbox\":\n        {\n          // hbox argument type wraps the argument in the equivalent of\n          // \\hbox, which is like \\text but switching to \\textstyle size.\n          const group = this.parseArgumentGroup(optional, \"text\");\n          return group != null ? {\n            type: \"styling\",\n            mode: group.mode,\n            body: [group],\n            style: \"text\" // simulate \\textstyle\n\n          } : null;\n        }\n\n      case \"raw\":\n        {\n          const token = this.parseStringGroup(\"raw\", optional);\n          return token != null ? {\n            type: \"raw\",\n            mode: \"text\",\n            string: token.text\n          } : null;\n        }\n\n      case \"primitive\":\n        {\n          if (optional) {\n            throw new src_ParseError(\"A primitive argument cannot be optional\");\n          }\n\n          const group = this.parseGroup(name);\n\n          if (group == null) {\n            throw new src_ParseError(\"Expected group as \" + name, this.fetch());\n          }\n\n          return group;\n        }\n\n      case \"original\":\n      case null:\n      case undefined:\n        return this.parseArgumentGroup(optional);\n\n      default:\n        throw new src_ParseError(\"Unknown group type as \" + name, this.fetch());\n    }\n  }\n  /**\n   * Discard any space tokens, fetching the next non-space token.\n   */\n\n\n  consumeSpaces() {\n    while (this.fetch().text === \" \") {\n      this.consume();\n    }\n  }\n  /**\n   * Parses a group, essentially returning the string formed by the\n   * brace-enclosed tokens plus some position information.\n   */\n\n\n  parseStringGroup(modeName, // Used to describe the mode in error messages.\n  optional) {\n    const argToken = this.gullet.scanArgument(optional);\n\n    if (argToken == null) {\n      return null;\n    }\n\n    let str = \"\";\n    let nextToken;\n\n    while ((nextToken = this.fetch()).text !== \"EOF\") {\n      str += nextToken.text;\n      this.consume();\n    }\n\n    this.consume(); // consume the end of the argument\n\n    argToken.text = str;\n    return argToken;\n  }\n  /**\n   * Parses a regex-delimited group: the largest sequence of tokens\n   * whose concatenated strings match `regex`. Returns the string\n   * formed by the tokens plus some position information.\n   */\n\n\n  parseRegexGroup(regex, modeName // Used to describe the mode in error messages.\n  ) {\n    const firstToken = this.fetch();\n    let lastToken = firstToken;\n    let str = \"\";\n    let nextToken;\n\n    while ((nextToken = this.fetch()).text !== \"EOF\" && regex.test(str + nextToken.text)) {\n      lastToken = nextToken;\n      str += lastToken.text;\n      this.consume();\n    }\n\n    if (str === \"\") {\n      throw new src_ParseError(\"Invalid \" + modeName + \": '\" + firstToken.text + \"'\", firstToken);\n    }\n\n    return firstToken.range(lastToken, str);\n  }\n  /**\n   * Parses a color description.\n   */\n\n\n  parseColorGroup(optional) {\n    const res = this.parseStringGroup(\"color\", optional);\n\n    if (res == null) {\n      return null;\n    }\n\n    const match = /^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i.exec(res.text);\n\n    if (!match) {\n      throw new src_ParseError(\"Invalid color: '\" + res.text + \"'\", res);\n    }\n\n    let color = match[0];\n\n    if (/^[0-9a-f]{6}$/i.test(color)) {\n      // We allow a 6-digit HTML color spec without a leading \"#\".\n      // This follows the xcolor package's HTML color model.\n      // Predefined color names are all missed by this RegEx pattern.\n      color = \"#\" + color;\n    }\n\n    return {\n      type: \"color-token\",\n      mode: this.mode,\n      color\n    };\n  }\n  /**\n   * Parses a size specification, consisting of magnitude and unit.\n   */\n\n\n  parseSizeGroup(optional) {\n    let res;\n    let isBlank = false; // don't expand before parseStringGroup\n\n    this.gullet.consumeSpaces();\n\n    if (!optional && this.gullet.future().text !== \"{\") {\n      res = this.parseRegexGroup(/^[-+]? *(?:$|\\d+|\\d+\\.\\d*|\\.\\d*) *[a-z]{0,2} *$/, \"size\");\n    } else {\n      res = this.parseStringGroup(\"size\", optional);\n    }\n\n    if (!res) {\n      return null;\n    }\n\n    if (!optional && res.text.length === 0) {\n      // Because we've tested for what is !optional, this block won't\n      // affect \\kern, \\hspace, etc. It will capture the mandatory arguments\n      // to \\genfrac and \\above.\n      res.text = \"0pt\"; // Enable \\above{}\n\n      isBlank = true; // This is here specifically for \\genfrac\n    }\n\n    const match = /([-+]?) *(\\d+(?:\\.\\d*)?|\\.\\d+) *([a-z]{2})/.exec(res.text);\n\n    if (!match) {\n      throw new src_ParseError(\"Invalid size: '\" + res.text + \"'\", res);\n    }\n\n    const data = {\n      number: +(match[1] + match[2]),\n      // sign + magnitude, cast to number\n      unit: match[3]\n    };\n\n    if (!validUnit(data)) {\n      throw new src_ParseError(\"Invalid unit: '\" + data.unit + \"'\", res);\n    }\n\n    return {\n      type: \"size\",\n      mode: this.mode,\n      value: data,\n      isBlank\n    };\n  }\n  /**\n   * Parses an URL, checking escaped letters and allowed protocols,\n   * and setting the catcode of % as an active character (as in \\hyperref).\n   */\n\n\n  parseUrlGroup(optional) {\n    this.gullet.lexer.setCatcode(\"%\", 13); // active character\n\n    this.gullet.lexer.setCatcode(\"~\", 12); // other character\n\n    const res = this.parseStringGroup(\"url\", optional);\n    this.gullet.lexer.setCatcode(\"%\", 14); // comment character\n\n    this.gullet.lexer.setCatcode(\"~\", 13); // active character\n\n    if (res == null) {\n      return null;\n    } // hyperref package allows backslashes alone in href, but doesn't\n    // generate valid links in such cases; we interpret this as\n    // \"undefined\" behaviour, and keep them as-is. Some browser will\n    // replace backslashes with forward slashes.\n\n\n    const url = res.text.replace(/\\\\([#$%&~_^{}])/g, '$1');\n    return {\n      type: \"url\",\n      mode: this.mode,\n      url\n    };\n  }\n  /**\n   * Parses an argument with the mode specified.\n   */\n\n\n  parseArgumentGroup(optional, mode) {\n    const argToken = this.gullet.scanArgument(optional);\n\n    if (argToken == null) {\n      return null;\n    }\n\n    const outerMode = this.mode;\n\n    if (mode) {\n      // Switch to specified mode\n      this.switchMode(mode);\n    }\n\n    this.gullet.beginGroup();\n    const expression = this.parseExpression(false, \"EOF\"); // TODO: find an alternative way to denote the end\n\n    this.expect(\"EOF\"); // expect the end of the argument\n\n    this.gullet.endGroup();\n    const result = {\n      type: \"ordgroup\",\n      mode: this.mode,\n      loc: argToken.loc,\n      body: expression\n    };\n\n    if (mode) {\n      // Switch mode back\n      this.switchMode(outerMode);\n    }\n\n    return result;\n  }\n  /**\n   * Parses an ordinary group, which is either a single nucleus (like \"x\")\n   * or an expression in braces (like \"{x+y}\") or an implicit group, a group\n   * that starts at the current position, and ends right before a higher explicit\n   * group ends, or at EOF.\n   */\n\n\n  parseGroup(name, // For error reporting.\n  breakOnTokenText) {\n    const firstToken = this.fetch();\n    const text = firstToken.text;\n    let result; // Try to parse an open brace or \\begingroup\n\n    if (text === \"{\" || text === \"\\\\begingroup\") {\n      this.consume();\n      const groupEnd = text === \"{\" ? \"}\" : \"\\\\endgroup\";\n      this.gullet.beginGroup(); // If we get a brace, parse an expression\n\n      const expression = this.parseExpression(false, groupEnd);\n      const lastToken = this.fetch();\n      this.expect(groupEnd); // Check that we got a matching closing brace\n\n      this.gullet.endGroup();\n      result = {\n        type: \"ordgroup\",\n        mode: this.mode,\n        loc: SourceLocation.range(firstToken, lastToken),\n        body: expression,\n        // A group formed by \\begingroup...\\endgroup is a semi-simple group\n        // which doesn't affect spacing in math mode, i.e., is transparent.\n        // https://tex.stackexchange.com/questions/1930/when-should-one-\n        // use-begingroup-instead-of-bgroup\n        semisimple: text === \"\\\\begingroup\" || undefined\n      };\n    } else {\n      // If there exists a function with this name, parse the function.\n      // Otherwise, just return a nucleus\n      result = this.parseFunction(breakOnTokenText, name) || this.parseSymbol();\n\n      if (result == null && text[0] === \"\\\\\" && !implicitCommands.hasOwnProperty(text)) {\n        if (this.settings.throwOnError) {\n          throw new src_ParseError(\"Undefined control sequence: \" + text, firstToken);\n        }\n\n        result = this.formatUnsupportedCmd(text);\n        this.consume();\n      }\n    }\n\n    return result;\n  }\n  /**\n   * Form ligature-like combinations of characters for text mode.\n   * This includes inputs like \"--\", \"---\", \"``\" and \"''\".\n   * The result will simply replace multiple textord nodes with a single\n   * character in each value by a single textord node having multiple\n   * characters in its value.  The representation is still ASCII source.\n   * The group will be modified in place.\n   */\n\n\n  formLigatures(group) {\n    let n = group.length - 1;\n\n    for (let i = 0; i < n; ++i) {\n      const a = group[i]; // $FlowFixMe: Not every node type has a `text` property.\n\n      const v = a.text;\n\n      if (v === \"-\" && group[i + 1].text === \"-\") {\n        if (i + 1 < n && group[i + 2].text === \"-\") {\n          group.splice(i, 3, {\n            type: \"textord\",\n            mode: \"text\",\n            loc: SourceLocation.range(a, group[i + 2]),\n            text: \"---\"\n          });\n          n -= 2;\n        } else {\n          group.splice(i, 2, {\n            type: \"textord\",\n            mode: \"text\",\n            loc: SourceLocation.range(a, group[i + 1]),\n            text: \"--\"\n          });\n          n -= 1;\n        }\n      }\n\n      if ((v === \"'\" || v === \"`\") && group[i + 1].text === v) {\n        group.splice(i, 2, {\n          type: \"textord\",\n          mode: \"text\",\n          loc: SourceLocation.range(a, group[i + 1]),\n          text: v + v\n        });\n        n -= 1;\n      }\n    }\n  }\n  /**\n   * Parse a single symbol out of the string. Here, we handle single character\n   * symbols and special functions like \\verb.\n   */\n\n\n  parseSymbol() {\n    const nucleus = this.fetch();\n    let text = nucleus.text;\n\n    if (/^\\\\verb[^a-zA-Z]/.test(text)) {\n      this.consume();\n      let arg = text.slice(5);\n      const star = arg.charAt(0) === \"*\";\n\n      if (star) {\n        arg = arg.slice(1);\n      } // Lexer's tokenRegex is constructed to always have matching\n      // first/last characters.\n\n\n      if (arg.length < 2 || arg.charAt(0) !== arg.slice(-1)) {\n        throw new src_ParseError(\"\\\\verb assertion failed --\\n                    please report what input caused this bug\");\n      }\n\n      arg = arg.slice(1, -1); // remove first and last char\n\n      return {\n        type: \"verb\",\n        mode: \"text\",\n        body: arg,\n        star\n      };\n    } // At this point, we should have a symbol, possibly with accents.\n    // First expand any accented base symbol according to unicodeSymbols.\n\n\n    if (unicodeSymbols.hasOwnProperty(text[0]) && !src_symbols[this.mode][text[0]]) {\n      // This behavior is not strict (XeTeX-compatible) in math mode.\n      if (this.settings.strict && this.mode === \"math\") {\n        this.settings.reportNonstrict(\"unicodeTextInMathMode\", \"Accented Unicode text character \\\"\" + text[0] + \"\\\" used in \" + \"math mode\", nucleus);\n      }\n\n      text = unicodeSymbols[text[0]] + text.slice(1);\n    } // Strip off any combining characters\n\n\n    const match = combiningDiacriticalMarksEndRegex.exec(text);\n\n    if (match) {\n      text = text.substring(0, match.index);\n\n      if (text === 'i') {\n        text = '\\u0131'; // dotless i, in math and text mode\n      } else if (text === 'j') {\n        text = '\\u0237'; // dotless j, in math and text mode\n      }\n    } // Recognize base symbol\n\n\n    let symbol;\n\n    if (src_symbols[this.mode][text]) {\n      if (this.settings.strict && this.mode === 'math' && extraLatin.indexOf(text) >= 0) {\n        this.settings.reportNonstrict(\"unicodeTextInMathMode\", \"Latin-1/Unicode text character \\\"\" + text[0] + \"\\\" used in \" + \"math mode\", nucleus);\n      }\n\n      const group = src_symbols[this.mode][text].group;\n      const loc = SourceLocation.range(nucleus);\n      let s;\n\n      if (ATOMS.hasOwnProperty(group)) {\n        // $FlowFixMe\n        const family = group;\n        s = {\n          type: \"atom\",\n          mode: this.mode,\n          family,\n          loc,\n          text\n        };\n      } else {\n        // $FlowFixMe\n        s = {\n          type: group,\n          mode: this.mode,\n          loc,\n          text\n        };\n      } // $FlowFixMe\n\n\n      symbol = s;\n    } else if (text.charCodeAt(0) >= 0x80) {\n      // no symbol for e.g. ^\n      if (this.settings.strict) {\n        if (!supportedCodepoint(text.charCodeAt(0))) {\n          this.settings.reportNonstrict(\"unknownSymbol\", \"Unrecognized Unicode character \\\"\" + text[0] + \"\\\"\" + (\" (\" + text.charCodeAt(0) + \")\"), nucleus);\n        } else if (this.mode === \"math\") {\n          this.settings.reportNonstrict(\"unicodeTextInMathMode\", \"Unicode text character \\\"\" + text[0] + \"\\\" used in math mode\", nucleus);\n        }\n      } // All nonmathematical Unicode characters are rendered as if they\n      // are in text mode (wrapped in \\text) because that's what it\n      // takes to render them in LaTeX.  Setting `mode: this.mode` is\n      // another natural choice (the user requested math mode), but\n      // this makes it more difficult for getCharacterMetrics() to\n      // distinguish Unicode characters without metrics and those for\n      // which we want to simulate the letter M.\n\n\n      symbol = {\n        type: \"textord\",\n        mode: \"text\",\n        loc: SourceLocation.range(nucleus),\n        text\n      };\n    } else {\n      return null; // EOF, ^, _, {, }, etc.\n    }\n\n    this.consume(); // Transform combining characters into accents\n\n    if (match) {\n      for (let i = 0; i < match[0].length; i++) {\n        const accent = match[0][i];\n\n        if (!unicodeAccents[accent]) {\n          throw new src_ParseError(\"Unknown accent ' \" + accent + \"'\", nucleus);\n        }\n\n        const command = unicodeAccents[accent][this.mode] || unicodeAccents[accent].text;\n\n        if (!command) {\n          throw new src_ParseError(\"Accent \" + accent + \" unsupported in \" + this.mode + \" mode\", nucleus);\n        }\n\n        symbol = {\n          type: \"accent\",\n          mode: this.mode,\n          loc: SourceLocation.range(nucleus),\n          label: command,\n          isStretchy: false,\n          isShifty: true,\n          // $FlowFixMe\n          base: symbol\n        };\n      }\n    } // $FlowFixMe\n\n\n    return symbol;\n  }\n\n}\nParser.endOfExpression = [\"}\", \"\\\\endgroup\", \"\\\\end\", \"\\\\right\", \"&\"];\n;// CONCATENATED MODULE: ./src/parseTree.js\n/**\n * Provides a single function for parsing an expression using a Parser\n * TODO(emily): Remove this\n */\n\n\n\n\n/**\n * Parses an expression using a Parser, then returns the parsed result.\n */\nconst parseTree = function (toParse, settings) {\n  if (!(typeof toParse === 'string' || toParse instanceof String)) {\n    throw new TypeError('KaTeX can only parse string typed expression');\n  }\n\n  const parser = new Parser(toParse, settings); // Blank out any \\df@tag to avoid spurious \"Duplicate \\tag\" errors\n\n  delete parser.gullet.macros.current[\"\\\\df@tag\"];\n  let tree = parser.parse(); // Prevent a color definition from persisting between calls to katex.render().\n\n  delete parser.gullet.macros.current[\"\\\\current@color\"];\n  delete parser.gullet.macros.current[\"\\\\color\"]; // If the input used \\tag, it will set the \\df@tag macro to the tag.\n  // In this case, we separately parse the tag and wrap the tree.\n\n  if (parser.gullet.macros.get(\"\\\\df@tag\")) {\n    if (!settings.displayMode) {\n      throw new src_ParseError(\"\\\\tag works only in display equations\");\n    }\n\n    tree = [{\n      type: \"tag\",\n      mode: \"text\",\n      body: tree,\n      tag: parser.subparse([new Token(\"\\\\df@tag\")])\n    }];\n  }\n\n  return tree;\n};\n\n/* harmony default export */ var src_parseTree = (parseTree);\n;// CONCATENATED MODULE: ./katex.js\n/* eslint no-console:0 */\n\n/**\n * This is the main entry point for KaTeX. Here, we expose functions for\n * rendering expressions either to DOM nodes or to markup strings.\n *\n * We also expose the ParseError class to check if errors thrown from KaTeX are\n * errors in the expression, or errors in javascript handling.\n */\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Parse and build an expression, and place that expression in the DOM node\n * given.\n */\nlet render = function (expression, baseNode, options) {\n  baseNode.textContent = \"\";\n  const node = renderToDomTree(expression, options).toNode();\n  baseNode.appendChild(node);\n}; // KaTeX's styles don't work properly in quirks mode. Print out an error, and\n// disable rendering.\n\n\nif (typeof document !== \"undefined\") {\n  if (document.compatMode !== \"CSS1Compat\") {\n    typeof console !== \"undefined\" && console.warn(\"Warning: KaTeX doesn't work in quirks mode. Make sure your \" + \"website has a suitable doctype.\");\n\n    render = function () {\n      throw new src_ParseError(\"KaTeX doesn't work in quirks mode.\");\n    };\n  }\n}\n/**\n * Parse and build an expression, and return the markup for that.\n */\n\n\nconst renderToString = function (expression, options) {\n  const markup = renderToDomTree(expression, options).toMarkup();\n  return markup;\n};\n/**\n * Parse an expression and return the parse tree.\n */\n\n\nconst generateParseTree = function (expression, options) {\n  const settings = new Settings(options);\n  return src_parseTree(expression, settings);\n};\n/**\n * If the given error is a KaTeX ParseError and options.throwOnError is false,\n * renders the invalid LaTeX as a span with hover title giving the KaTeX\n * error message.  Otherwise, simply throws the error.\n */\n\n\nconst renderError = function (error, expression, options) {\n  if (options.throwOnError || !(error instanceof src_ParseError)) {\n    throw error;\n  }\n\n  const node = buildCommon.makeSpan([\"katex-error\"], [new SymbolNode(expression)]);\n  node.setAttribute(\"title\", error.toString());\n  node.setAttribute(\"style\", \"color:\" + options.errorColor);\n  return node;\n};\n/**\n * Generates and returns the katex build tree. This is used for advanced\n * use cases (like rendering to custom output).\n */\n\n\nconst renderToDomTree = function (expression, options) {\n  const settings = new Settings(options);\n\n  try {\n    const tree = src_parseTree(expression, settings);\n    return buildTree(tree, expression, settings);\n  } catch (error) {\n    return renderError(error, expression, settings);\n  }\n};\n/**\n * Generates and returns the katex build tree, with just HTML (no MathML).\n * This is used for advanced use cases (like rendering to custom output).\n */\n\n\nconst renderToHTMLTree = function (expression, options) {\n  const settings = new Settings(options);\n\n  try {\n    const tree = src_parseTree(expression, settings);\n    return buildHTMLTree(tree, expression, settings);\n  } catch (error) {\n    return renderError(error, expression, settings);\n  }\n};\n\n/* harmony default export */ var katex = ({\n  /**\n   * Current KaTeX version\n   */\n  version: \"0.16.11\",\n\n  /**\n   * Renders the given LaTeX into an HTML+MathML combination, and adds\n   * it as a child to the specified DOM node.\n   */\n  render,\n\n  /**\n   * Renders the given LaTeX into an HTML+MathML combination string,\n   * for sending to the client.\n   */\n  renderToString,\n\n  /**\n   * KaTeX error, usually during parsing.\n   */\n  ParseError: src_ParseError,\n\n  /**\n   * The shema of Settings\n   */\n  SETTINGS_SCHEMA: SETTINGS_SCHEMA,\n\n  /**\n   * Parses the given LaTeX into KaTeX's internal parse tree structure,\n   * without rendering to HTML or MathML.\n   *\n   * NOTE: This method is not currently recommended for public use.\n   * The internal tree representation is unstable and is very likely\n   * to change. Use at your own risk.\n   */\n  __parse: generateParseTree,\n\n  /**\n   * Renders the given LaTeX into an HTML+MathML internal DOM tree\n   * representation, without flattening that representation to a string.\n   *\n   * NOTE: This method is not currently recommended for public use.\n   * The internal tree representation is unstable and is very likely\n   * to change. Use at your own risk.\n   */\n  __renderToDomTree: renderToDomTree,\n\n  /**\n   * Renders the given LaTeX into an HTML internal DOM tree representation,\n   * without MathML and without flattening that representation to a string.\n   *\n   * NOTE: This method is not currently recommended for public use.\n   * The internal tree representation is unstable and is very likely\n   * to change. Use at your own risk.\n   */\n  __renderToHTMLTree: renderToHTMLTree,\n\n  /**\n   * extends internal font metrics object with a new object\n   * each key in the new object represents a font name\n  */\n  __setFontMetrics: setFontMetrics,\n\n  /**\n   * adds a new symbol to builtin symbols table\n   */\n  __defineSymbol: defineSymbol,\n\n  /**\n   * adds a new function to builtin function list,\n   * which directly produce parse tree elements\n   * and have their own html/mathml builders\n   */\n  __defineFunction: defineFunction,\n\n  /**\n   * adds a new macro to builtin macro list\n   */\n  __defineMacro: defineMacro,\n\n  /**\n   * Expose the dom tree node types, which can be useful for type checking nodes.\n   *\n   * NOTE: This method is not currently recommended for public use.\n   * The internal tree representation is unstable and is very likely\n   * to change. Use at your own risk.\n   */\n  __domTree: {\n    Span: Span,\n    Anchor: Anchor,\n    SymbolNode: SymbolNode,\n    SvgNode: SvgNode,\n    PathNode: PathNode,\n    LineNode: LineNode\n  }\n});\n;// CONCATENATED MODULE: ./katex.webpack.js\n/**\n * This is the webpack entry point for KaTeX. As ECMAScript, flow[1] and jest[2]\n * doesn't support CSS modules natively, a separate entry point is used and\n * it is not flowtyped.\n *\n * [1] https://gist.github.com/lambdahands/d19e0da96285b749f0ef\n * [2] https://facebook.github.io/jest/docs/en/webpack.html\n */\n\n\n/* harmony default export */ var katex_webpack = (katex);\n__nested_webpack_exports__ = __nested_webpack_exports__[\"default\"];\n/******/ \treturn __nested_webpack_exports__;\n/******/ })()\n;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9rYXRleC9kaXN0L2thdGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsSUFBSSxJQUF5RDtBQUM3RDtBQUNBLE1BQU0sRUFLc0I7QUFDNUIsQ0FBQztBQUNELDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsY0FBYyw4QkFBbUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsOEJBQW1CO0FBQzlCO0FBQ0EsZ0JBQWdCLDhCQUFtQix3QkFBd0IsOEJBQW1CO0FBQzlFLG9EQUFvRCx3Q0FBd0M7QUFDNUY7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVcsOEJBQW1CLDJCQUEyQjtBQUN6RCxXQUFXO0FBQ1g7QUFDQTtBQUNBLElBQUksMEJBQW1COztBQUV2QjtBQUNBLDhCQUFtQixHQUFHLDBCQUFtQjtBQUN6QywwQkFBMEI7QUFDMUIsQ0FBQzs7QUFFRCxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQzs7QUFFckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTs7O0FBR1IsOEVBQThFOztBQUU5RTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7OztBQUdBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1osWUFBWTtBQUNaLGVBQWU7QUFDZixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7OztBQUdBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx3R0FBd0csTUFBTTtBQUM5RztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsT0FBTyxNQUFNO0FBQzFGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTtBQUNGOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZixtTkFBbU47O0FBRW5OO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUSxZQUFZLFFBQVEsT0FBTyxTQUFTO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjs7QUFFbEI7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjs7QUFFbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QixJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxnREFBZ0Q7O0FBRWhELDhDQUE4Qzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMERBQTBEOztBQUUxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DOztBQUVwQyxvQ0FBb0M7O0FBRXBDO0FBQ0EscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0Msc0RBQXNEO0FBQ3JHOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsYUFBYTtBQUNwRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFVBQVU7QUFDVixVQUFVO0FBQ1YsV0FBVztBQUNYO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7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QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQSxnREFBZ0Q7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdB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QUM7Ozs7Ozs7O0FBUUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHLENBQVM7QUFDM0csQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjs7QUFFL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLG1CQUFtQjtBQUN2Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQzs7Ozs7OztBQU9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLGtFQUFrRTs7QUFFbEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELENBQUM7Ozs7Ozs7OztBQVNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQSxNQUFNO0FBQ047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Q0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBOztBQUVBLHdEQUF3RDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQztBQUNEOzs7OztBQUtBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsQ0FBQzs7OztBQUlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQyxHQUFHO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FB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QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHVCQUF1QjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx1QkFBdUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLElBQUk7QUFDSjs7O0FBR0EsNEVBQTRFOztBQUU1RSw4R0FBOEc7O0FBRTlHLHNGQUFzRjtBQUN0RjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKLGtEQUFrRDtBQUNsRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDs7QUFFM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7O0FBR0Esa0JBQWtCOztBQUVsQixvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7O0FBRWpEO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUEseUdBQXlHOztBQUV6RztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QjtBQUM1QixNQUFNO0FBQ04sNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQSxzR0FBc0csbUJBQW1CLGdIQUFnSDs7QUFFek8sc1NBQXNTOztBQUV0UyxxR0FBcUc7QUFDckc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDLEdBQUc7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUMsR0FBRztBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IscUJBQXFCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0RBQXNEO0FBQ3REOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTs7O0FBR0o7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7OztBQUdKLHdFQUF3RTtBQUN4RTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsZ0ZBQWdGOztBQUVoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRyxZQUFZLE9BQU8sT0FBTztBQUN4QztBQUNBLG1GQUFtRjtBQUNuRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxDQUFDOzs7Ozs7Ozs7OztBQVdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGLG1CQUFtQjs7QUFFL0c7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7O0FBRW5EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7Ozs7Ozs7Ozs7OztBQVlEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLElBQUk7QUFDSjs7O0FBR0E7QUFDQTtBQUNBLG9FQUFvRTs7QUFFcEU7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDO0FBQzNDLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qix5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxHQUFHO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLENBQUMsR0FBRzs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7QUFDRCxDQUFDOzs7Ozs7Ozs7QUFTRDtB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QkFBMEIsaUJBQWlCO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxDQUFDOzs7Ozs7OztBQVFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osMERBQTBELEVBQUU7O0FBRTVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxRUFBcUU7O0FBRXJFOztBQUVBLHNCQUFzQix1QkFBdUI7QUFDN0M7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxDQUFDO0FBQ0Q7Ozs7O0FBS0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQSxnREFBZ0Q7O0FBRWhEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELENBQUM7QUFDRDs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJFQUEyRTs7QUFFM0U7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBLCtFQUErRTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0M7QUFDbEM7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMsR0FBRzs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELENBQUM7Ozs7Ozs7QUFPRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQzs7OztBQUlEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztB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O0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLDBCQUEwQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUssWUFBWTs7QUFFakI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxDQUFDOzs7Ozs7O0FBT0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELENBQUM7Ozs7OztBQU1EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNB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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEOztBQUV0RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsQ0FBQzs7OztBQUlEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7QUFDRCxDQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7QUFDRCxDQUFDOzs7O0FBSUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNULFdBQVc7QUFDWDtBQUNBO0FBQ0EsR0FBRztBQUNILGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsQ0FBQzs7Ozs7QUFLRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxDQUFDOzs7O0FBSUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxDQUFDOzs7Ozs7QUFNRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7O0FBRXhELHNFQUFzRTs7QUFFdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsQ0FBQzs7Ozs7QUFLRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxDQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjs7QUFFQSxvQkFBb0IsaUJBQWlCO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBLDhEQUE4RDtBQUM5RDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZ0RBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDOztBQUV2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0RBQWtEOztBQUVsRCw2RkFBNkY7QUFDN0YsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLHdHQUF3RztBQUN4Rzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDRCQUE0QjtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNB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LE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047OztBQUdBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxDQUFDO0FBQ0Q7Ozs7Ozs7Ozs7O0FBV0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCOztBQUVBLGlFQUFpRTs7QUFFakUsOEJB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QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7OztBQUdWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSw4REFBOEQsS0FBSztBQUNuRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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OztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLDBCQUFtQixHQUFHLDBCQUFtQjtBQUN6QyxpQkFBaUIsMEJBQW1CO0FBQ3BDLFVBQVU7QUFDVjtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2thdGV4L2Rpc3Qva2F0ZXguanM/ODM2NCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJrYXRleFwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJrYXRleFwiXSA9IGZhY3RvcnkoKTtcbn0pKCh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdGhpcyksIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbigpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHRcInVzZSBzdHJpY3RcIjtcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgc2NvcGVcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19yZXF1aXJlX18gPSB7fTtcbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMgKi9cbi8qKioqKiovIFx0IWZ1bmN0aW9uKCkge1xuLyoqKioqKi8gXHRcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBkZWZpbml0aW9uKSB7XG4vKioqKioqLyBcdFx0XHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG4vKioqKioqLyBcdFx0XHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuLyoqKioqKi8gXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG4vKioqKioqLyBcdFx0XHRcdH1cbi8qKioqKiovIFx0XHRcdH1cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHR9KCk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kICovXG4vKioqKioqLyBcdCFmdW5jdGlvbigpIHtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmosIHByb3ApIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApOyB9XG4vKioqKioqLyBcdH0oKTtcbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xudmFyIF9fd2VicGFja19leHBvcnRzX18gPSB7fTtcblxuLy8gRVhQT1JUU1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbiAgXCJkZWZhdWx0XCI6IGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogYmluZGluZyAqLyBrYXRleF93ZWJwYWNrOyB9XG59KTtcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL1BhcnNlRXJyb3IuanNcblxuXG4vKipcbiAqIFRoaXMgaXMgdGhlIFBhcnNlRXJyb3IgY2xhc3MsIHdoaWNoIGlzIHRoZSBtYWluIGVycm9yIHRocm93biBieSBLYVRlWFxuICogZnVuY3Rpb25zIHdoZW4gc29tZXRoaW5nIGhhcyBnb25lIHdyb25nLiBUaGlzIGlzIHVzZWQgdG8gZGlzdGluZ3Vpc2ggaW50ZXJuYWxcbiAqIGVycm9ycyBmcm9tIGVycm9ycyBpbiB0aGUgZXhwcmVzc2lvbiB0aGF0IHRoZSB1c2VyIHByb3ZpZGVkLlxuICpcbiAqIElmIHBvc3NpYmxlLCBhIGNhbGxlciBzaG91bGQgcHJvdmlkZSBhIFRva2VuIG9yIFBhcnNlTm9kZSB3aXRoIGluZm9ybWF0aW9uXG4gKiBhYm91dCB3aGVyZSBpbiB0aGUgc291cmNlIHN0cmluZyB0aGUgcHJvYmxlbSBvY2N1cnJlZC5cbiAqL1xuY2xhc3MgUGFyc2VFcnJvciB7XG4gIC8vIEVycm9yIHN0YXJ0IHBvc2l0aW9uIGJhc2VkIG9uIHBhc3NlZC1pbiBUb2tlbiBvciBQYXJzZU5vZGUuXG4gIC8vIExlbmd0aCBvZiBhZmZlY3RlZCB0ZXh0IGJhc2VkIG9uIHBhc3NlZC1pbiBUb2tlbiBvciBQYXJzZU5vZGUuXG4gIC8vIFRoZSB1bmRlcmx5aW5nIGVycm9yIG1lc3NhZ2Ugd2l0aG91dCBhbnkgY29udGV4dCBhZGRlZC5cbiAgY29uc3RydWN0b3IobWVzc2FnZSwgLy8gVGhlIGVycm9yIG1lc3NhZ2VcbiAgdG9rZW4gLy8gQW4gb2JqZWN0IHByb3ZpZGluZyBwb3NpdGlvbiBpbmZvcm1hdGlvblxuICApIHtcbiAgICB0aGlzLm5hbWUgPSB2b2lkIDA7XG4gICAgdGhpcy5wb3NpdGlvbiA9IHZvaWQgMDtcbiAgICB0aGlzLmxlbmd0aCA9IHZvaWQgMDtcbiAgICB0aGlzLnJhd01lc3NhZ2UgPSB2b2lkIDA7XG4gICAgbGV0IGVycm9yID0gXCJLYVRlWCBwYXJzZSBlcnJvcjogXCIgKyBtZXNzYWdlO1xuICAgIGxldCBzdGFydDtcbiAgICBsZXQgZW5kO1xuICAgIGNvbnN0IGxvYyA9IHRva2VuICYmIHRva2VuLmxvYztcblxuICAgIGlmIChsb2MgJiYgbG9jLnN0YXJ0IDw9IGxvYy5lbmQpIHtcbiAgICAgIC8vIElmIHdlIGhhdmUgdGhlIGlucHV0IGFuZCBhIHBvc2l0aW9uLCBtYWtlIHRoZSBlcnJvciBhIGJpdCBmYW5jaWVyXG4gICAgICAvLyBHZXQgdGhlIGlucHV0XG4gICAgICBjb25zdCBpbnB1dCA9IGxvYy5sZXhlci5pbnB1dDsgLy8gUHJlcGVuZCBzb21lIGluZm9ybWF0aW9uXG5cbiAgICAgIHN0YXJ0ID0gbG9jLnN0YXJ0O1xuICAgICAgZW5kID0gbG9jLmVuZDtcblxuICAgICAgaWYgKHN0YXJ0ID09PSBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgZXJyb3IgKz0gXCIgYXQgZW5kIG9mIGlucHV0OiBcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yICs9IFwiIGF0IHBvc2l0aW9uIFwiICsgKHN0YXJ0ICsgMSkgKyBcIjogXCI7XG4gICAgICB9IC8vIFVuZGVybGluZSB0b2tlbiBpbiBxdWVzdGlvbiB1c2luZyBjb21iaW5pbmcgdW5kZXJzY29yZXNcblxuXG4gICAgICBjb25zdCB1bmRlcmxpbmVkID0gaW5wdXQuc2xpY2Uoc3RhcnQsIGVuZCkucmVwbGFjZSgvW15dL2csIFwiJCZcXHUwMzMyXCIpOyAvLyBFeHRyYWN0IHNvbWUgY29udGV4dCBmcm9tIHRoZSBpbnB1dCBhbmQgYWRkIGl0IHRvIHRoZSBlcnJvclxuXG4gICAgICBsZXQgbGVmdDtcblxuICAgICAgaWYgKHN0YXJ0ID4gMTUpIHtcbiAgICAgICAgbGVmdCA9IFwi4oCmXCIgKyBpbnB1dC5zbGljZShzdGFydCAtIDE1LCBzdGFydCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZWZ0ID0gaW5wdXQuc2xpY2UoMCwgc3RhcnQpO1xuICAgICAgfVxuXG4gICAgICBsZXQgcmlnaHQ7XG5cbiAgICAgIGlmIChlbmQgKyAxNSA8IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICByaWdodCA9IGlucHV0LnNsaWNlKGVuZCwgZW5kICsgMTUpICsgXCLigKZcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJpZ2h0ID0gaW5wdXQuc2xpY2UoZW5kKTtcbiAgICAgIH1cblxuICAgICAgZXJyb3IgKz0gbGVmdCArIHVuZGVybGluZWQgKyByaWdodDtcbiAgICB9IC8vIFNvbWUgaGFja2VyeSB0byBtYWtlIFBhcnNlRXJyb3IgYSBwcm90b3R5cGUgb2YgRXJyb3JcbiAgICAvLyBTZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvODQ2MDc1M1xuICAgIC8vICRGbG93Rml4TWVcblxuXG4gICAgY29uc3Qgc2VsZiA9IG5ldyBFcnJvcihlcnJvcik7XG4gICAgc2VsZi5uYW1lID0gXCJQYXJzZUVycm9yXCI7IC8vICRGbG93Rml4TWVcblxuICAgIHNlbGYuX19wcm90b19fID0gUGFyc2VFcnJvci5wcm90b3R5cGU7XG4gICAgc2VsZi5wb3NpdGlvbiA9IHN0YXJ0O1xuXG4gICAgaWYgKHN0YXJ0ICE9IG51bGwgJiYgZW5kICE9IG51bGwpIHtcbiAgICAgIHNlbGYubGVuZ3RoID0gZW5kIC0gc3RhcnQ7XG4gICAgfVxuXG4gICAgc2VsZi5yYXdNZXNzYWdlID0gbWVzc2FnZTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuXG59IC8vICRGbG93Rml4TWUgTW9yZSBoYWNrZXJ5XG5cblxuUGFyc2VFcnJvci5wcm90b3R5cGUuX19wcm90b19fID0gRXJyb3IucHJvdG90eXBlO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgc3JjX1BhcnNlRXJyb3IgPSAoUGFyc2VFcnJvcik7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbHMuanNcbi8qKlxuICogVGhpcyBmaWxlIGNvbnRhaW5zIGEgbGlzdCBvZiB1dGlsaXR5IGZ1bmN0aW9ucyB3aGljaCBhcmUgdXNlZnVsIGluIG90aGVyXG4gKiBmaWxlcy5cbiAqL1xuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIGFuIGVsZW1lbnQgaXMgY29udGFpbmVkIGluIGEgbGlzdFxuICovXG5jb25zdCBjb250YWlucyA9IGZ1bmN0aW9uIChsaXN0LCBlbGVtKSB7XG4gIHJldHVybiBsaXN0LmluZGV4T2YoZWxlbSkgIT09IC0xO1xufTtcbi8qKlxuICogUHJvdmlkZSBhIGRlZmF1bHQgdmFsdWUgaWYgYSBzZXR0aW5nIGlzIHVuZGVmaW5lZFxuICogTk9URTogQ291bGRuJ3QgdXNlIGBUYCBhcyB0aGUgb3V0cHV0IHR5cGUgZHVlIHRvIGZhY2Vib29rL2Zsb3cjNTAyMi5cbiAqL1xuXG5cbmNvbnN0IGRlZmx0ID0gZnVuY3Rpb24gKHNldHRpbmcsIGRlZmF1bHRJZlVuZGVmaW5lZCkge1xuICByZXR1cm4gc2V0dGluZyA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdElmVW5kZWZpbmVkIDogc2V0dGluZztcbn07IC8vIGh5cGhlbmF0ZSBhbmQgZXNjYXBlIGFkYXB0ZWQgZnJvbSBGYWNlYm9vaydzIFJlYWN0IHVuZGVyIEFwYWNoZSAyIGxpY2Vuc2VcblxuXG5jb25zdCB1cHBlcmNhc2UgPSAvKFtBLVpdKS9nO1xuXG5jb25zdCBoeXBoZW5hdGUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSh1cHBlcmNhc2UsIFwiLSQxXCIpLnRvTG93ZXJDYXNlKCk7XG59O1xuXG5jb25zdCBFU0NBUEVfTE9PS1VQID0ge1xuICBcIiZcIjogXCImYW1wO1wiLFxuICBcIj5cIjogXCImZ3Q7XCIsXG4gIFwiPFwiOiBcIiZsdDtcIixcbiAgXCJcXFwiXCI6IFwiJnF1b3Q7XCIsXG4gIFwiJ1wiOiBcIiYjeDI3O1wiXG59O1xuY29uc3QgRVNDQVBFX1JFR0VYID0gL1smPjxcIiddL2c7XG4vKipcbiAqIEVzY2FwZXMgdGV4dCB0byBwcmV2ZW50IHNjcmlwdGluZyBhdHRhY2tzLlxuICovXG5cbmZ1bmN0aW9uIHV0aWxzX2VzY2FwZSh0ZXh0KSB7XG4gIHJldHVybiBTdHJpbmcodGV4dCkucmVwbGFjZShFU0NBUEVfUkVHRVgsIG1hdGNoID0+IEVTQ0FQRV9MT09LVVBbbWF0Y2hdKTtcbn1cbi8qKlxuICogU29tZXRpbWVzIHdlIHdhbnQgdG8gcHVsbCBvdXQgdGhlIGlubmVybW9zdCBlbGVtZW50IG9mIGEgZ3JvdXAuIEluIG1vc3RcbiAqIGNhc2VzLCB0aGlzIHdpbGwganVzdCBiZSB0aGUgZ3JvdXAgaXRzZWxmLCBidXQgd2hlbiBvcmRncm91cHMgYW5kIGNvbG9ycyBoYXZlXG4gKiBhIHNpbmdsZSBlbGVtZW50LCB3ZSB3YW50IHRvIHB1bGwgdGhhdCBvdXQuXG4gKi9cblxuXG5jb25zdCBnZXRCYXNlRWxlbSA9IGZ1bmN0aW9uIChncm91cCkge1xuICBpZiAoZ3JvdXAudHlwZSA9PT0gXCJvcmRncm91cFwiKSB7XG4gICAgaWYgKGdyb3VwLmJvZHkubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gZ2V0QmFzZUVsZW0oZ3JvdXAuYm9keVswXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBncm91cDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZ3JvdXAudHlwZSA9PT0gXCJjb2xvclwiKSB7XG4gICAgaWYgKGdyb3VwLmJvZHkubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gZ2V0QmFzZUVsZW0oZ3JvdXAuYm9keVswXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBncm91cDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZ3JvdXAudHlwZSA9PT0gXCJmb250XCIpIHtcbiAgICByZXR1cm4gZ2V0QmFzZUVsZW0oZ3JvdXAuYm9keSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdyb3VwO1xuICB9XG59O1xuLyoqXG4gKiBUZVhib29rIGFsZ29yaXRobXMgb2Z0ZW4gcmVmZXJlbmNlIFwiY2hhcmFjdGVyIGJveGVzXCIsIHdoaWNoIGFyZSBzaW1wbHkgZ3JvdXBzXG4gKiB3aXRoIGEgc2luZ2xlIGNoYXJhY3RlciBpbiB0aGVtLiBUbyBkZWNpZGUgaWYgc29tZXRoaW5nIGlzIGEgY2hhcmFjdGVyIGJveCxcbiAqIHdlIGZpbmQgaXRzIGlubmVybW9zdCBncm91cCwgYW5kIHNlZSBpZiBpdCBpcyBhIHNpbmdsZSBjaGFyYWN0ZXIuXG4gKi9cblxuXG5jb25zdCBpc0NoYXJhY3RlckJveCA9IGZ1bmN0aW9uIChncm91cCkge1xuICBjb25zdCBiYXNlRWxlbSA9IGdldEJhc2VFbGVtKGdyb3VwKTsgLy8gVGhlc2UgYXJlIGFsbCB0aGV5IHR5cGVzIG9mIGdyb3VwcyB3aGljaCBob2xkIHNpbmdsZSBjaGFyYWN0ZXJzXG5cbiAgcmV0dXJuIGJhc2VFbGVtLnR5cGUgPT09IFwibWF0aG9yZFwiIHx8IGJhc2VFbGVtLnR5cGUgPT09IFwidGV4dG9yZFwiIHx8IGJhc2VFbGVtLnR5cGUgPT09IFwiYXRvbVwiO1xufTtcblxuY29uc3QgYXNzZXJ0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIG5vbi1udWxsLCBidXQgZ290ICcgKyBTdHJpbmcodmFsdWUpKTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn07XG4vKipcbiAqIFJldHVybiB0aGUgcHJvdG9jb2wgb2YgYSBVUkwsIG9yIFwiX3JlbGF0aXZlXCIgaWYgdGhlIFVSTCBkb2VzIG5vdCBzcGVjaWZ5IGFcbiAqIHByb3RvY29sIChhbmQgdGh1cyBpcyByZWxhdGl2ZSksIG9yIGBudWxsYCBpZiBVUkwgaGFzIGludmFsaWQgcHJvdG9jb2xcbiAqIChzbyBzaG91bGQgYmUgb3V0cmlnaHQgcmVqZWN0ZWQpLlxuICovXG5cbmNvbnN0IHByb3RvY29sRnJvbVVybCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgLy8gQ2hlY2sgZm9yIHBvc3NpYmxlIGxlYWRpbmcgcHJvdG9jb2wuXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jdXJsLXBhcnNpbmcgc3RyaXBzIGxlYWRpbmcgd2hpdGVzcGFjZVxuICAvLyAoVSsyMCkgb3IgQzAgY29udHJvbCAoVSswMC1VKzFGKSBjaGFyYWN0ZXJzLlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxuICBjb25zdCBwcm90b2NvbCA9IC9eW1xceDAwLVxceDIwXSooW15cXFxcLyM/XSo/KSg6fCYjMCo1OHwmI3gwKjNhfCZjb2xvbikvaS5leGVjKHVybCk7XG5cbiAgaWYgKCFwcm90b2NvbCkge1xuICAgIHJldHVybiBcIl9yZWxhdGl2ZVwiO1xuICB9IC8vIFJlamVjdCB3ZWlyZCBjb2xvbnNcblxuXG4gIGlmIChwcm90b2NvbFsyXSAhPT0gXCI6XCIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBSZWplY3QgaW52YWxpZCBjaGFyYWN0ZXJzIGluIHNjaGVtZSBhY2NvcmRpbmcgdG9cbiAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmMzOTg2I3NlY3Rpb24tMy4xXG5cblxuICBpZiAoIS9eW2EtekEtWl1bYS16QS1aMC05K1xcLS5dKiQvLnRlc3QocHJvdG9jb2xbMV0pKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gTG93ZXJjYXNlIHRoZSBwcm90b2NvbFxuXG5cbiAgcmV0dXJuIHByb3RvY29sWzFdLnRvTG93ZXJDYXNlKCk7XG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdXRpbHMgPSAoe1xuICBjb250YWlucyxcbiAgZGVmbHQsXG4gIGVzY2FwZTogdXRpbHNfZXNjYXBlLFxuICBoeXBoZW5hdGUsXG4gIGdldEJhc2VFbGVtLFxuICBpc0NoYXJhY3RlckJveCxcbiAgcHJvdG9jb2xGcm9tVXJsXG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9TZXR0aW5ncy5qc1xuLyogZXNsaW50IG5vLWNvbnNvbGU6MCAqL1xuXG4vKipcbiAqIFRoaXMgaXMgYSBtb2R1bGUgZm9yIHN0b3Jpbmcgc2V0dGluZ3MgcGFzc2VkIGludG8gS2FUZVguIEl0IGNvcnJlY3RseSBoYW5kbGVzXG4gKiBkZWZhdWx0IHNldHRpbmdzLlxuICovXG5cblxuXG4vLyBUT0RPOiBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlIGRvY3VtZW50YXRpb25cbi8vIFRPRE86IGNoZWNrIGFsbCBwcm9wZXJ0aWVzIG9uIFNldHRpbmdzIGV4aXN0XG4vLyBUT0RPOiBjaGVjayB0aGUgdHlwZSBvZiBhIHByb3BlcnR5IG9uIFNldHRpbmdzIG1hdGNoZXNcbmNvbnN0IFNFVFRJTkdTX1NDSEVNQSA9IHtcbiAgZGlzcGxheU1vZGU6IHtcbiAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICBkZXNjcmlwdGlvbjogXCJSZW5kZXIgbWF0aCBpbiBkaXNwbGF5IG1vZGUsIHdoaWNoIHB1dHMgdGhlIG1hdGggaW4gXCIgKyBcImRpc3BsYXkgc3R5bGUgKHNvIFxcXFxpbnQgYW5kIFxcXFxzdW0gYXJlIGxhcmdlLCBmb3IgZXhhbXBsZSksIGFuZCBcIiArIFwiY2VudGVycyB0aGUgbWF0aCBvbiB0aGUgcGFnZSBvbiBpdHMgb3duIGxpbmUuXCIsXG4gICAgY2xpOiBcIi1kLCAtLWRpc3BsYXktbW9kZVwiXG4gIH0sXG4gIG91dHB1dDoge1xuICAgIHR5cGU6IHtcbiAgICAgIGVudW06IFtcImh0bWxBbmRNYXRobWxcIiwgXCJodG1sXCIsIFwibWF0aG1sXCJdXG4gICAgfSxcbiAgICBkZXNjcmlwdGlvbjogXCJEZXRlcm1pbmVzIHRoZSBtYXJrdXAgbGFuZ3VhZ2Ugb2YgdGhlIG91dHB1dC5cIixcbiAgICBjbGk6IFwiLUYsIC0tZm9ybWF0IDx0eXBlPlwiXG4gIH0sXG4gIGxlcW5vOiB7XG4gICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgZGVzY3JpcHRpb246IFwiUmVuZGVyIGRpc3BsYXkgbWF0aCBpbiBsZXFubyBzdHlsZSAobGVmdC1qdXN0aWZpZWQgdGFncykuXCJcbiAgfSxcbiAgZmxlcW46IHtcbiAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICBkZXNjcmlwdGlvbjogXCJSZW5kZXIgZGlzcGxheSBtYXRoIGZsdXNoIGxlZnQuXCJcbiAgfSxcbiAgdGhyb3dPbkVycm9yOiB7XG4gICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICBjbGk6IFwiLXQsIC0tbm8tdGhyb3ctb24tZXJyb3JcIixcbiAgICBjbGlEZXNjcmlwdGlvbjogXCJSZW5kZXIgZXJyb3JzIChpbiB0aGUgY29sb3IgZ2l2ZW4gYnkgLS1lcnJvci1jb2xvcikgaW5zXCIgKyBcInRlYWQgb2YgdGhyb3dpbmcgYSBQYXJzZUVycm9yIGV4Y2VwdGlvbiB3aGVuIGVuY291bnRlcmluZyBhbiBlcnJvci5cIlxuICB9LFxuICBlcnJvckNvbG9yOiB7XG4gICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICBkZWZhdWx0OiBcIiNjYzAwMDBcIixcbiAgICBjbGk6IFwiLWMsIC0tZXJyb3ItY29sb3IgPGNvbG9yPlwiLFxuICAgIGNsaURlc2NyaXB0aW9uOiBcIkEgY29sb3Igc3RyaW5nIGdpdmVuIGluIHRoZSBmb3JtYXQgJ3JnYicgb3IgJ3JyZ2diYicgXCIgKyBcIihubyAjKS4gVGhpcyBvcHRpb24gZGV0ZXJtaW5lcyB0aGUgY29sb3Igb2YgZXJyb3JzIHJlbmRlcmVkIGJ5IHRoZSBcIiArIFwiLXQgb3B0aW9uLlwiLFxuICAgIGNsaVByb2Nlc3NvcjogY29sb3IgPT4gXCIjXCIgKyBjb2xvclxuICB9LFxuICBtYWNyb3M6IHtcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIGNsaTogXCItbSwgLS1tYWNybyA8ZGVmPlwiLFxuICAgIGNsaURlc2NyaXB0aW9uOiBcIkRlZmluZSBjdXN0b20gbWFjcm8gb2YgdGhlIGZvcm0gJ1xcXFxmb286ZXhwYW5zaW9uJyAodXNlIFwiICsgXCJtdWx0aXBsZSAtbSBhcmd1bWVudHMgZm9yIG11bHRpcGxlIG1hY3JvcykuXCIsXG4gICAgY2xpRGVmYXVsdDogW10sXG4gICAgY2xpUHJvY2Vzc29yOiAoZGVmLCBkZWZzKSA9PiB7XG4gICAgICBkZWZzLnB1c2goZGVmKTtcbiAgICAgIHJldHVybiBkZWZzO1xuICAgIH1cbiAgfSxcbiAgbWluUnVsZVRoaWNrbmVzczoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVzY3JpcHRpb246IFwiU3BlY2lmaWVzIGEgbWluaW11bSB0aGlja25lc3MsIGluIGVtcywgZm9yIGZyYWN0aW9uIGxpbmVzLFwiICsgXCIgYFxcXFxzcXJ0YCB0b3AgbGluZXMsIGB7YXJyYXl9YCB2ZXJ0aWNhbCBsaW5lcywgYFxcXFxobGluZWAsIFwiICsgXCJgXFxcXGhkYXNobGluZWAsIGBcXFxcdW5kZXJsaW5lYCwgYFxcXFxvdmVybGluZWAsIGFuZCB0aGUgYm9yZGVycyBvZiBcIiArIFwiYFxcXFxmYm94YCwgYFxcXFxib3hlZGAsIGFuZCBgXFxcXGZjb2xvcmJveGAuXCIsXG4gICAgcHJvY2Vzc29yOiB0ID0+IE1hdGgubWF4KDAsIHQpLFxuICAgIGNsaTogXCItLW1pbi1ydWxlLXRoaWNrbmVzcyA8c2l6ZT5cIixcbiAgICBjbGlQcm9jZXNzb3I6IHBhcnNlRmxvYXRcbiAgfSxcbiAgY29sb3JJc1RleHRDb2xvcjoge1xuICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIk1ha2VzIFxcXFxjb2xvciBiZWhhdmUgbGlrZSBMYVRlWCdzIDItYXJndW1lbnQgXFxcXHRleHRjb2xvciwgXCIgKyBcImluc3RlYWQgb2YgTGFUZVgncyBvbmUtYXJndW1lbnQgXFxcXGNvbG9yIG1vZGUgY2hhbmdlLlwiLFxuICAgIGNsaTogXCItYiwgLS1jb2xvci1pcy10ZXh0LWNvbG9yXCJcbiAgfSxcbiAgc3RyaWN0OiB7XG4gICAgdHlwZTogW3tcbiAgICAgIGVudW06IFtcIndhcm5cIiwgXCJpZ25vcmVcIiwgXCJlcnJvclwiXVxuICAgIH0sIFwiYm9vbGVhblwiLCBcImZ1bmN0aW9uXCJdLFxuICAgIGRlc2NyaXB0aW9uOiBcIlR1cm4gb24gc3RyaWN0IC8gTGFUZVggZmFpdGhmdWxuZXNzIG1vZGUsIHdoaWNoIHRocm93cyBhbiBcIiArIFwiZXJyb3IgaWYgdGhlIGlucHV0IHVzZXMgZmVhdHVyZXMgdGhhdCBhcmUgbm90IHN1cHBvcnRlZCBieSBMYVRlWC5cIixcbiAgICBjbGk6IFwiLVMsIC0tc3RyaWN0XCIsXG4gICAgY2xpRGVmYXVsdDogZmFsc2VcbiAgfSxcbiAgdHJ1c3Q6IHtcbiAgICB0eXBlOiBbXCJib29sZWFuXCIsIFwiZnVuY3Rpb25cIl0sXG4gICAgZGVzY3JpcHRpb246IFwiVHJ1c3QgdGhlIGlucHV0LCBlbmFibGluZyBhbGwgSFRNTCBmZWF0dXJlcyBzdWNoIGFzIFxcXFx1cmwuXCIsXG4gICAgY2xpOiBcIi1ULCAtLXRydXN0XCJcbiAgfSxcbiAgbWF4U2l6ZToge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVmYXVsdDogSW5maW5pdHksXG4gICAgZGVzY3JpcHRpb246IFwiSWYgbm9uLXplcm8sIGFsbCB1c2VyLXNwZWNpZmllZCBzaXplcywgZS5nLiBpbiBcIiArIFwiXFxcXHJ1bGV7NTAwZW19ezUwMGVtfSwgd2lsbCBiZSBjYXBwZWQgdG8gbWF4U2l6ZSBlbXMuIE90aGVyd2lzZSwgXCIgKyBcImVsZW1lbnRzIGFuZCBzcGFjZXMgY2FuIGJlIGFyYml0cmFyaWx5IGxhcmdlXCIsXG4gICAgcHJvY2Vzc29yOiBzID0+IE1hdGgubWF4KDAsIHMpLFxuICAgIGNsaTogXCItcywgLS1tYXgtc2l6ZSA8bj5cIixcbiAgICBjbGlQcm9jZXNzb3I6IHBhcnNlSW50XG4gIH0sXG4gIG1heEV4cGFuZDoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVmYXVsdDogMTAwMCxcbiAgICBkZXNjcmlwdGlvbjogXCJMaW1pdCB0aGUgbnVtYmVyIG9mIG1hY3JvIGV4cGFuc2lvbnMgdG8gdGhlIHNwZWNpZmllZCBcIiArIFwibnVtYmVyLCB0byBwcmV2ZW50IGUuZy4gaW5maW5pdGUgbWFjcm8gbG9vcHMuIElmIHNldCB0byBJbmZpbml0eSwgXCIgKyBcInRoZSBtYWNybyBleHBhbmRlciB3aWxsIHRyeSB0byBmdWxseSBleHBhbmQgYXMgaW4gTGFUZVguXCIsXG4gICAgcHJvY2Vzc29yOiBuID0+IE1hdGgubWF4KDAsIG4pLFxuICAgIGNsaTogXCItZSwgLS1tYXgtZXhwYW5kIDxuPlwiLFxuICAgIGNsaVByb2Nlc3NvcjogbiA9PiBuID09PSBcIkluZmluaXR5XCIgPyBJbmZpbml0eSA6IHBhcnNlSW50KG4pXG4gIH0sXG4gIGdsb2JhbEdyb3VwOiB7XG4gICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgY2xpOiBmYWxzZVxuICB9XG59O1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0VmFsdWUoc2NoZW1hKSB7XG4gIGlmIChzY2hlbWEuZGVmYXVsdCkge1xuICAgIHJldHVybiBzY2hlbWEuZGVmYXVsdDtcbiAgfVxuXG4gIGNvbnN0IHR5cGUgPSBzY2hlbWEudHlwZTtcbiAgY29uc3QgZGVmYXVsdFR5cGUgPSBBcnJheS5pc0FycmF5KHR5cGUpID8gdHlwZVswXSA6IHR5cGU7XG5cbiAgaWYgKHR5cGVvZiBkZWZhdWx0VHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVmYXVsdFR5cGUuZW51bVswXTtcbiAgfVxuXG4gIHN3aXRjaCAoZGVmYXVsdFR5cGUpIHtcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gJyc7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIDA7XG5cbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgcmV0dXJuIHt9O1xuICB9XG59XG4vKipcbiAqIFRoZSBtYWluIFNldHRpbmdzIG9iamVjdFxuICpcbiAqIFRoZSBjdXJyZW50IG9wdGlvbnMgc3RvcmVkIGFyZTpcbiAqICAtIGRpc3BsYXlNb2RlOiBXaGV0aGVyIHRoZSBleHByZXNzaW9uIHNob3VsZCBiZSB0eXBlc2V0IGFzIGlubGluZSBtYXRoXG4gKiAgICAgICAgICAgICAgICAgKGZhbHNlLCB0aGUgZGVmYXVsdCksIG1lYW5pbmcgdGhhdCB0aGUgbWF0aCBzdGFydHMgaW5cbiAqICAgICAgICAgICAgICAgICBcXHRleHRzdHlsZSBhbmQgaXMgcGxhY2VkIGluIGFuIGlubGluZS1ibG9jayk7IG9yIGFzIGRpc3BsYXlcbiAqICAgICAgICAgICAgICAgICBtYXRoICh0cnVlKSwgbWVhbmluZyB0aGF0IHRoZSBtYXRoIHN0YXJ0cyBpbiBcXGRpc3BsYXlzdHlsZVxuICogICAgICAgICAgICAgICAgIGFuZCBpcyBwbGFjZWQgaW4gYSBibG9jayB3aXRoIHZlcnRpY2FsIG1hcmdpbi5cbiAqL1xuXG5cbmNsYXNzIFNldHRpbmdzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMuZGlzcGxheU1vZGUgPSB2b2lkIDA7XG4gICAgdGhpcy5vdXRwdXQgPSB2b2lkIDA7XG4gICAgdGhpcy5sZXFubyA9IHZvaWQgMDtcbiAgICB0aGlzLmZsZXFuID0gdm9pZCAwO1xuICAgIHRoaXMudGhyb3dPbkVycm9yID0gdm9pZCAwO1xuICAgIHRoaXMuZXJyb3JDb2xvciA9IHZvaWQgMDtcbiAgICB0aGlzLm1hY3JvcyA9IHZvaWQgMDtcbiAgICB0aGlzLm1pblJ1bGVUaGlja25lc3MgPSB2b2lkIDA7XG4gICAgdGhpcy5jb2xvcklzVGV4dENvbG9yID0gdm9pZCAwO1xuICAgIHRoaXMuc3RyaWN0ID0gdm9pZCAwO1xuICAgIHRoaXMudHJ1c3QgPSB2b2lkIDA7XG4gICAgdGhpcy5tYXhTaXplID0gdm9pZCAwO1xuICAgIHRoaXMubWF4RXhwYW5kID0gdm9pZCAwO1xuICAgIHRoaXMuZ2xvYmFsR3JvdXAgPSB2b2lkIDA7XG4gICAgLy8gYWxsb3cgbnVsbCBvcHRpb25zXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBmb3IgKGNvbnN0IHByb3AgaW4gU0VUVElOR1NfU0NIRU1BKSB7XG4gICAgICBpZiAoU0VUVElOR1NfU0NIRU1BLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgIC8vICRGbG93Rml4TWVcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gU0VUVElOR1NfU0NIRU1BW3Byb3BdOyAvLyBUT0RPOiB2YWxpZGF0ZSBvcHRpb25zXG4gICAgICAgIC8vICRGbG93Rml4TWVcblxuICAgICAgICB0aGlzW3Byb3BdID0gb3B0aW9uc1twcm9wXSAhPT0gdW5kZWZpbmVkID8gc2NoZW1hLnByb2Nlc3NvciA/IHNjaGVtYS5wcm9jZXNzb3Iob3B0aW9uc1twcm9wXSkgOiBvcHRpb25zW3Byb3BdIDogZ2V0RGVmYXVsdFZhbHVlKHNjaGVtYSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXBvcnQgbm9uc3RyaWN0IChub24tTGFUZVgtY29tcGF0aWJsZSkgaW5wdXQuXG4gICAqIENhbiBzYWZlbHkgbm90IGJlIGNhbGxlZCBpZiBgdGhpcy5zdHJpY3RgIGlzIGZhbHNlIGluIEphdmFTY3JpcHQuXG4gICAqL1xuXG5cbiAgcmVwb3J0Tm9uc3RyaWN0KGVycm9yQ29kZSwgZXJyb3JNc2csIHRva2VuKSB7XG4gICAgbGV0IHN0cmljdCA9IHRoaXMuc3RyaWN0O1xuXG4gICAgaWYgKHR5cGVvZiBzdHJpY3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgLy8gQWxsb3cgcmV0dXJuIHZhbHVlIG9mIHN0cmljdCBmdW5jdGlvbiB0byBiZSBib29sZWFuIG9yIHN0cmluZ1xuICAgICAgLy8gKG9yIG51bGwvdW5kZWZpbmVkLCBtZWFuaW5nIG5vIGZ1cnRoZXIgcHJvY2Vzc2luZykuXG4gICAgICBzdHJpY3QgPSBzdHJpY3QoZXJyb3JDb2RlLCBlcnJvck1zZywgdG9rZW4pO1xuICAgIH1cblxuICAgIGlmICghc3RyaWN0IHx8IHN0cmljdCA9PT0gXCJpZ25vcmVcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoc3RyaWN0ID09PSB0cnVlIHx8IHN0cmljdCA9PT0gXCJlcnJvclwiKSB7XG4gICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJMYVRlWC1pbmNvbXBhdGlibGUgaW5wdXQgYW5kIHN0cmljdCBtb2RlIGlzIHNldCB0byAnZXJyb3InOiBcIiArIChlcnJvck1zZyArIFwiIFtcIiArIGVycm9yQ29kZSArIFwiXVwiKSwgdG9rZW4pO1xuICAgIH0gZWxzZSBpZiAoc3RyaWN0ID09PSBcIndhcm5cIikge1xuICAgICAgdHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29uc29sZS53YXJuKFwiTGFUZVgtaW5jb21wYXRpYmxlIGlucHV0IGFuZCBzdHJpY3QgbW9kZSBpcyBzZXQgdG8gJ3dhcm4nOiBcIiArIChlcnJvck1zZyArIFwiIFtcIiArIGVycm9yQ29kZSArIFwiXVwiKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHdvbid0IGhhcHBlbiBpbiB0eXBlLXNhZmUgY29kZVxuICAgICAgdHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29uc29sZS53YXJuKFwiTGFUZVgtaW5jb21wYXRpYmxlIGlucHV0IGFuZCBzdHJpY3QgbW9kZSBpcyBzZXQgdG8gXCIgKyAoXCJ1bnJlY29nbml6ZWQgJ1wiICsgc3RyaWN0ICsgXCInOiBcIiArIGVycm9yTXNnICsgXCIgW1wiICsgZXJyb3JDb2RlICsgXCJdXCIpKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgdG8gYXBwbHkgc3RyaWN0IChMYVRlWC1hZGhlcmluZykgYmVoYXZpb3IgZm9yIHVudXN1YWxcbiAgICogaW5wdXQgKGxpa2UgYFxcXFxgKS4gIFVubGlrZSBgbm9uc3RyaWN0YCwgd2lsbCBub3QgdGhyb3cgYW4gZXJyb3I7XG4gICAqIGluc3RlYWQsIFwiZXJyb3JcIiB0cmFuc2xhdGVzIHRvIGEgcmV0dXJuIHZhbHVlIG9mIGB0cnVlYCwgd2hpbGUgXCJpZ25vcmVcIlxuICAgKiB0cmFuc2xhdGVzIHRvIGEgcmV0dXJuIHZhbHVlIG9mIGBmYWxzZWAuICBNYXkgc3RpbGwgcHJpbnQgYSB3YXJuaW5nOlxuICAgKiBcIndhcm5cIiBwcmludHMgYSB3YXJuaW5nIGFuZCByZXR1cm5zIGBmYWxzZWAuXG4gICAqIFRoaXMgaXMgZm9yIHRoZSBzZWNvbmQgY2F0ZWdvcnkgb2YgYGVycm9yQ29kZWBzIGxpc3RlZCBpbiB0aGUgUkVBRE1FLlxuICAgKi9cblxuXG4gIHVzZVN0cmljdEJlaGF2aW9yKGVycm9yQ29kZSwgZXJyb3JNc2csIHRva2VuKSB7XG4gICAgbGV0IHN0cmljdCA9IHRoaXMuc3RyaWN0O1xuXG4gICAgaWYgKHR5cGVvZiBzdHJpY3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgLy8gQWxsb3cgcmV0dXJuIHZhbHVlIG9mIHN0cmljdCBmdW5jdGlvbiB0byBiZSBib29sZWFuIG9yIHN0cmluZ1xuICAgICAgLy8gKG9yIG51bGwvdW5kZWZpbmVkLCBtZWFuaW5nIG5vIGZ1cnRoZXIgcHJvY2Vzc2luZykuXG4gICAgICAvLyBCdXQgY2F0Y2ggYW55IGV4Y2VwdGlvbnMgdGhyb3duIGJ5IGZ1bmN0aW9uLCB0cmVhdGluZyB0aGVtXG4gICAgICAvLyBsaWtlIFwiZXJyb3JcIi5cbiAgICAgIHRyeSB7XG4gICAgICAgIHN0cmljdCA9IHN0cmljdChlcnJvckNvZGUsIGVycm9yTXNnLCB0b2tlbik7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBzdHJpY3QgPSBcImVycm9yXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFzdHJpY3QgfHwgc3RyaWN0ID09PSBcImlnbm9yZVwiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChzdHJpY3QgPT09IHRydWUgfHwgc3RyaWN0ID09PSBcImVycm9yXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoc3RyaWN0ID09PSBcIndhcm5cIikge1xuICAgICAgdHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29uc29sZS53YXJuKFwiTGFUZVgtaW5jb21wYXRpYmxlIGlucHV0IGFuZCBzdHJpY3QgbW9kZSBpcyBzZXQgdG8gJ3dhcm4nOiBcIiArIChlcnJvck1zZyArIFwiIFtcIiArIGVycm9yQ29kZSArIFwiXVwiKSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHdvbid0IGhhcHBlbiBpbiB0eXBlLXNhZmUgY29kZVxuICAgICAgdHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29uc29sZS53YXJuKFwiTGFUZVgtaW5jb21wYXRpYmxlIGlucHV0IGFuZCBzdHJpY3QgbW9kZSBpcyBzZXQgdG8gXCIgKyAoXCJ1bnJlY29nbml6ZWQgJ1wiICsgc3RyaWN0ICsgXCInOiBcIiArIGVycm9yTXNnICsgXCIgW1wiICsgZXJyb3JDb2RlICsgXCJdXCIpKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgdG8gdGVzdCBwb3RlbnRpYWxseSBkYW5nZXJvdXMgaW5wdXQsIGFuZCByZXR1cm5cbiAgICogYHRydWVgICh0cnVzdGVkKSBvciBgZmFsc2VgICh1bnRydXN0ZWQpLiAgVGhlIHNvbGUgYXJndW1lbnQgYGNvbnRleHRgXG4gICAqIHNob3VsZCBiZSBhbiBvYmplY3Qgd2l0aCBgY29tbWFuZGAgZmllbGQgc3BlY2lmeWluZyB0aGUgcmVsZXZhbnQgTGFUZVhcbiAgICogY29tbWFuZCAoYXMgYSBzdHJpbmcgc3RhcnRpbmcgd2l0aCBgXFxgKSwgYW5kIGFueSBvdGhlciBhcmd1bWVudHMsIGV0Yy5cbiAgICogSWYgYGNvbnRleHRgIGhhcyBhIGB1cmxgIGZpZWxkLCBhIGBwcm90b2NvbGAgZmllbGQgd2lsbCBhdXRvbWF0aWNhbGx5XG4gICAqIGdldCBhZGRlZCBieSB0aGlzIGZ1bmN0aW9uIChjaGFuZ2luZyB0aGUgc3BlY2lmaWVkIG9iamVjdCkuXG4gICAqL1xuXG5cbiAgaXNUcnVzdGVkKGNvbnRleHQpIHtcbiAgICBpZiAoY29udGV4dC51cmwgJiYgIWNvbnRleHQucHJvdG9jb2wpIHtcbiAgICAgIGNvbnN0IHByb3RvY29sID0gdXRpbHMucHJvdG9jb2xGcm9tVXJsKGNvbnRleHQudXJsKTtcblxuICAgICAgaWYgKHByb3RvY29sID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0LnByb3RvY29sID0gcHJvdG9jb2w7XG4gICAgfVxuXG4gICAgY29uc3QgdHJ1c3QgPSB0eXBlb2YgdGhpcy50cnVzdCA9PT0gXCJmdW5jdGlvblwiID8gdGhpcy50cnVzdChjb250ZXh0KSA6IHRoaXMudHJ1c3Q7XG4gICAgcmV0dXJuIEJvb2xlYW4odHJ1c3QpO1xuICB9XG5cbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9TdHlsZS5qc1xuLyoqXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgaW5mb3JtYXRpb24gYW5kIGNsYXNzZXMgZm9yIHRoZSB2YXJpb3VzIGtpbmRzIG9mIHN0eWxlc1xuICogdXNlZCBpbiBUZVguIEl0IHByb3ZpZGVzIGEgZ2VuZXJpYyBgU3R5bGVgIGNsYXNzLCB3aGljaCBob2xkcyBpbmZvcm1hdGlvblxuICogYWJvdXQgYSBzcGVjaWZpYyBzdHlsZS4gSXQgdGhlbiBwcm92aWRlcyBpbnN0YW5jZXMgb2YgYWxsIHRoZSBkaWZmZXJlbnQga2luZHNcbiAqIG9mIHN0eWxlcyBwb3NzaWJsZSwgYW5kIHByb3ZpZGVzIGZ1bmN0aW9ucyB0byBtb3ZlIGJldHdlZW4gdGhlbSBhbmQgZ2V0XG4gKiBpbmZvcm1hdGlvbiBhYm91dCB0aGVtLlxuICovXG5cbi8qKlxuICogVGhlIG1haW4gc3R5bGUgY2xhc3MuIENvbnRhaW5zIGEgdW5pcXVlIGlkIGZvciB0aGUgc3R5bGUsIGEgc2l6ZSAod2hpY2ggaXNcbiAqIHRoZSBzYW1lIGZvciBjcmFtcGVkIGFuZCB1bmNyYW1wZWQgdmVyc2lvbiBvZiBhIHN0eWxlKSwgYW5kIGEgY3JhbXBlZCBmbGFnLlxuICovXG5jbGFzcyBTdHlsZSB7XG4gIGNvbnN0cnVjdG9yKGlkLCBzaXplLCBjcmFtcGVkKSB7XG4gICAgdGhpcy5pZCA9IHZvaWQgMDtcbiAgICB0aGlzLnNpemUgPSB2b2lkIDA7XG4gICAgdGhpcy5jcmFtcGVkID0gdm9pZCAwO1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgIHRoaXMuY3JhbXBlZCA9IGNyYW1wZWQ7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgc3R5bGUgb2YgYSBzdXBlcnNjcmlwdCBnaXZlbiBhIGJhc2UgaW4gdGhlIGN1cnJlbnQgc3R5bGUuXG4gICAqL1xuXG5cbiAgc3VwKCkge1xuICAgIHJldHVybiBzdHlsZXNbc3VwW3RoaXMuaWRdXTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBzdHlsZSBvZiBhIHN1YnNjcmlwdCBnaXZlbiBhIGJhc2UgaW4gdGhlIGN1cnJlbnQgc3R5bGUuXG4gICAqL1xuXG5cbiAgc3ViKCkge1xuICAgIHJldHVybiBzdHlsZXNbc3ViW3RoaXMuaWRdXTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBzdHlsZSBvZiBhIGZyYWN0aW9uIG51bWVyYXRvciBnaXZlbiB0aGUgZnJhY3Rpb24gaW4gdGhlIGN1cnJlbnRcbiAgICogc3R5bGUuXG4gICAqL1xuXG5cbiAgZnJhY051bSgpIHtcbiAgICByZXR1cm4gc3R5bGVzW2ZyYWNOdW1bdGhpcy5pZF1dO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHN0eWxlIG9mIGEgZnJhY3Rpb24gZGVub21pbmF0b3IgZ2l2ZW4gdGhlIGZyYWN0aW9uIGluIHRoZSBjdXJyZW50XG4gICAqIHN0eWxlLlxuICAgKi9cblxuXG4gIGZyYWNEZW4oKSB7XG4gICAgcmV0dXJuIHN0eWxlc1tmcmFjRGVuW3RoaXMuaWRdXTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBjcmFtcGVkIHZlcnNpb24gb2YgYSBzdHlsZSAoaW4gcGFydGljdWxhciwgY3JhbXBpbmcgYSBjcmFtcGVkIHN0eWxlXG4gICAqIGRvZXNuJ3QgY2hhbmdlIHRoZSBzdHlsZSkuXG4gICAqL1xuXG5cbiAgY3JhbXAoKSB7XG4gICAgcmV0dXJuIHN0eWxlc1tjcmFtcFt0aGlzLmlkXV07XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhIHRleHQgb3IgZGlzcGxheSB2ZXJzaW9uIG9mIHRoaXMgc3R5bGUuXG4gICAqL1xuXG5cbiAgdGV4dCgpIHtcbiAgICByZXR1cm4gc3R5bGVzW1N0eWxlX3RleHRbdGhpcy5pZF1dO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGlzIHN0eWxlIGlzIHRpZ2h0bHkgc3BhY2VkIChzY3JpcHRzdHlsZS9zY3JpcHRzY3JpcHRzdHlsZSlcbiAgICovXG5cblxuICBpc1RpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLnNpemUgPj0gMjtcbiAgfVxuXG59IC8vIEV4cG9ydCBhbiBpbnRlcmZhY2UgZm9yIHR5cGUgY2hlY2tpbmcsIGJ1dCBkb24ndCBleHBvc2UgdGhlIGltcGxlbWVudGF0aW9uLlxuLy8gVGhpcyB3YXksIG5vIG1vcmUgc3R5bGVzIGNhbiBiZSBnZW5lcmF0ZWQuXG5cblxuLy8gSURzIG9mIHRoZSBkaWZmZXJlbnQgc3R5bGVzXG5jb25zdCBEID0gMDtcbmNvbnN0IERjID0gMTtcbmNvbnN0IFQgPSAyO1xuY29uc3QgVGMgPSAzO1xuY29uc3QgUyA9IDQ7XG5jb25zdCBTYyA9IDU7XG5jb25zdCBTUyA9IDY7XG5jb25zdCBTU2MgPSA3OyAvLyBJbnN0YW5jZXMgb2YgdGhlIGRpZmZlcmVudCBzdHlsZXNcblxuY29uc3Qgc3R5bGVzID0gW25ldyBTdHlsZShELCAwLCBmYWxzZSksIG5ldyBTdHlsZShEYywgMCwgdHJ1ZSksIG5ldyBTdHlsZShULCAxLCBmYWxzZSksIG5ldyBTdHlsZShUYywgMSwgdHJ1ZSksIG5ldyBTdHlsZShTLCAyLCBmYWxzZSksIG5ldyBTdHlsZShTYywgMiwgdHJ1ZSksIG5ldyBTdHlsZShTUywgMywgZmFsc2UpLCBuZXcgU3R5bGUoU1NjLCAzLCB0cnVlKV07IC8vIExvb2t1cCB0YWJsZXMgZm9yIHN3aXRjaGluZyBmcm9tIG9uZSBzdHlsZSB0byBhbm90aGVyXG5cbmNvbnN0IHN1cCA9IFtTLCBTYywgUywgU2MsIFNTLCBTU2MsIFNTLCBTU2NdO1xuY29uc3Qgc3ViID0gW1NjLCBTYywgU2MsIFNjLCBTU2MsIFNTYywgU1NjLCBTU2NdO1xuY29uc3QgZnJhY051bSA9IFtULCBUYywgUywgU2MsIFNTLCBTU2MsIFNTLCBTU2NdO1xuY29uc3QgZnJhY0RlbiA9IFtUYywgVGMsIFNjLCBTYywgU1NjLCBTU2MsIFNTYywgU1NjXTtcbmNvbnN0IGNyYW1wID0gW0RjLCBEYywgVGMsIFRjLCBTYywgU2MsIFNTYywgU1NjXTtcbmNvbnN0IFN0eWxlX3RleHQgPSBbRCwgRGMsIFQsIFRjLCBULCBUYywgVCwgVGNdOyAvLyBXZSBvbmx5IGV4cG9ydCBzb21lIG9mIHRoZSBzdHlsZXMuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHNyY19TdHlsZSA9ICh7XG4gIERJU1BMQVk6IHN0eWxlc1tEXSxcbiAgVEVYVDogc3R5bGVzW1RdLFxuICBTQ1JJUFQ6IHN0eWxlc1tTXSxcbiAgU0NSSVBUU0NSSVBUOiBzdHlsZXNbU1NdXG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91bmljb2RlU2NyaXB0cy5qc1xuLypcbiAqIFRoaXMgZmlsZSBkZWZpbmVzIHRoZSBVbmljb2RlIHNjcmlwdHMgYW5kIHNjcmlwdCBmYW1pbGllcyB0aGF0IHdlXG4gKiBzdXBwb3J0LiBUbyBhZGQgbmV3IHNjcmlwdHMgb3IgZmFtaWxpZXMsIGp1c3QgYWRkIGEgbmV3IGVudHJ5IHRvIHRoZVxuICogc2NyaXB0RGF0YSBhcnJheSBiZWxvdy4gQWRkaW5nIHNjcmlwdHMgdG8gdGhlIHNjcmlwdERhdGEgYXJyYXkgYWxsb3dzXG4gKiBjaGFyYWN0ZXJzIGZyb20gdGhhdCBzY3JpcHQgdG8gYXBwZWFyIGluIFxcdGV4dHt9IGVudmlyb25tZW50cy5cbiAqL1xuXG4vKipcbiAqIEVhY2ggc2NyaXB0IG9yIHNjcmlwdCBmYW1pbHkgaGFzIGEgbmFtZSBhbmQgYW4gYXJyYXkgb2YgYmxvY2tzLlxuICogRWFjaCBibG9jayBpcyBhbiBhcnJheSBvZiB0d28gbnVtYmVycyB3aGljaCBzcGVjaWZ5IHRoZSBzdGFydCBhbmRcbiAqIGVuZCBwb2ludHMgKGluY2x1c2l2ZSkgb2YgYSBibG9jayBvZiBVbmljb2RlIGNvZGVwb2ludHMuXG4gKi9cblxuLyoqXG4gKiBVbmljb2RlIGJsb2NrIGRhdGEgZm9yIHRoZSBmYW1pbGllcyBvZiBzY3JpcHRzIHdlIHN1cHBvcnQgaW4gXFx0ZXh0e30uXG4gKiBTY3JpcHRzIG9ubHkgbmVlZCB0byBhcHBlYXIgaGVyZSBpZiB0aGV5IGRvIG5vdCBoYXZlIGZvbnQgbWV0cmljcy5cbiAqL1xuY29uc3Qgc2NyaXB0RGF0YSA9IFt7XG4gIC8vIExhdGluIGNoYXJhY3RlcnMgYmV5b25kIHRoZSBMYXRpbi0xIGNoYXJhY3RlcnMgd2UgaGF2ZSBtZXRyaWNzIGZvci5cbiAgLy8gTmVlZGVkIGZvciBDemVjaCwgSHVuZ2FyaWFuIGFuZCBUdXJraXNoIHRleHQsIGZvciBleGFtcGxlLlxuICBuYW1lOiAnbGF0aW4nLFxuICBibG9ja3M6IFtbMHgwMTAwLCAweDAyNGZdLCAvLyBMYXRpbiBFeHRlbmRlZC1BIGFuZCBMYXRpbiBFeHRlbmRlZC1CXG4gIFsweDAzMDAsIDB4MDM2Zl0gLy8gQ29tYmluaW5nIERpYWNyaXRpY2FsIG1hcmtzXG4gIF1cbn0sIHtcbiAgLy8gVGhlIEN5cmlsbGljIHNjcmlwdCB1c2VkIGJ5IFJ1c3NpYW4gYW5kIHJlbGF0ZWQgbGFuZ3VhZ2VzLlxuICAvLyBBIEN5cmlsbGljIHN1YnNldCB1c2VkIHRvIGJlIHN1cHBvcnRlZCBhcyBleHBsaWNpdGx5IGRlZmluZWRcbiAgLy8gc3ltYm9scyBpbiBzeW1ib2xzLmpzXG4gIG5hbWU6ICdjeXJpbGxpYycsXG4gIGJsb2NrczogW1sweDA0MDAsIDB4MDRmZl1dXG59LCB7XG4gIC8vIEFybWVuaWFuXG4gIG5hbWU6ICdhcm1lbmlhbicsXG4gIGJsb2NrczogW1sweDA1MzAsIDB4MDU4Rl1dXG59LCB7XG4gIC8vIFRoZSBCcmFobWljIHNjcmlwdHMgb2YgU291dGggYW5kIFNvdXRoZWFzdCBBc2lhXG4gIC8vIERldmFuYWdhcmkgKDA5MDDigJMwOTdGKVxuICAvLyBCZW5nYWxpICgwOTgw4oCTMDlGRilcbiAgLy8gR3VybXVraGkgKDBBMDDigJMwQTdGKVxuICAvLyBHdWphcmF0aSAoMEE4MOKAkzBBRkYpXG4gIC8vIE9yaXlhICgwQjAw4oCTMEI3RilcbiAgLy8gVGFtaWwgKDBCODDigJMwQkZGKVxuICAvLyBUZWx1Z3UgKDBDMDDigJMwQzdGKVxuICAvLyBLYW5uYWRhICgwQzgw4oCTMENGRilcbiAgLy8gTWFsYXlhbGFtICgwRDAw4oCTMEQ3RilcbiAgLy8gU2luaGFsYSAoMEQ4MOKAkzBERkYpXG4gIC8vIFRoYWkgKDBFMDDigJMwRTdGKVxuICAvLyBMYW8gKDBFODDigJMwRUZGKVxuICAvLyBUaWJldGFuICgwRjAw4oCTMEZGRilcbiAgLy8gTXlhbm1hciAoMTAwMOKAkzEwOUYpXG4gIG5hbWU6ICdicmFobWljJyxcbiAgYmxvY2tzOiBbWzB4MDkwMCwgMHgxMDlGXV1cbn0sIHtcbiAgbmFtZTogJ2dlb3JnaWFuJyxcbiAgYmxvY2tzOiBbWzB4MTBBMCwgMHgxMGZmXV1cbn0sIHtcbiAgLy8gQ2hpbmVzZSBhbmQgSmFwYW5lc2UuXG4gIC8vIFRoZSBcImtcIiBpbiBjamsgaXMgZm9yIEtvcmVhbiwgYnV0IHdlJ3ZlIHNlcGFyYXRlZCBLb3JlYW4gb3V0XG4gIG5hbWU6IFwiY2prXCIsXG4gIGJsb2NrczogW1sweDMwMDAsIDB4MzBGRl0sIC8vIENKSyBzeW1ib2xzIGFuZCBwdW5jdHVhdGlvbiwgSGlyYWdhbmEsIEthdGFrYW5hXG4gIFsweDRFMDAsIDB4OUZBRl0sIC8vIENKSyBpZGVvZ3JhbXNcbiAgWzB4RkYwMCwgMHhGRjYwXSAvLyBGdWxsd2lkdGggcHVuY3R1YXRpb25cbiAgLy8gVE9ETzogYWRkIGhhbGZ3aWR0aCBLYXRha2FuYSBhbmQgUm9tYW5qaSBnbHlwaHNcbiAgXVxufSwge1xuICAvLyBLb3JlYW5cbiAgbmFtZTogJ2hhbmd1bCcsXG4gIGJsb2NrczogW1sweEFDMDAsIDB4RDdBRl1dXG59XTtcbi8qKlxuICogR2l2ZW4gYSBjb2RlcG9pbnQsIHJldHVybiB0aGUgbmFtZSBvZiB0aGUgc2NyaXB0IG9yIHNjcmlwdCBmYW1pbHlcbiAqIGl0IGlzIGZyb20sIG9yIG51bGwgaWYgaXQgaXMgbm90IHBhcnQgb2YgYSBrbm93biBibG9ja1xuICovXG5cbmZ1bmN0aW9uIHNjcmlwdEZyb21Db2RlcG9pbnQoY29kZXBvaW50KSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2NyaXB0RGF0YS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNjcmlwdCA9IHNjcmlwdERhdGFbaV07XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNjcmlwdC5ibG9ja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGJsb2NrID0gc2NyaXB0LmJsb2Nrc1tpXTtcblxuICAgICAgaWYgKGNvZGVwb2ludCA+PSBibG9ja1swXSAmJiBjb2RlcG9pbnQgPD0gYmxvY2tbMV0pIHtcbiAgICAgICAgcmV0dXJuIHNjcmlwdC5uYW1lO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBBIGZsYXR0ZW5lZCB2ZXJzaW9uIG9mIGFsbCB0aGUgc3VwcG9ydGVkIGJsb2NrcyBpbiBhIHNpbmdsZSBhcnJheS5cbiAqIFRoaXMgaXMgYW4gb3B0aW1pemF0aW9uIHRvIG1ha2Ugc3VwcG9ydGVkQ29kZXBvaW50KCkgZmFzdC5cbiAqL1xuXG5jb25zdCBhbGxCbG9ja3MgPSBbXTtcbnNjcmlwdERhdGEuZm9yRWFjaChzID0+IHMuYmxvY2tzLmZvckVhY2goYiA9PiBhbGxCbG9ja3MucHVzaCguLi5iKSkpO1xuLyoqXG4gKiBHaXZlbiBhIGNvZGVwb2ludCwgcmV0dXJuIHRydWUgaWYgaXQgZmFsbHMgd2l0aGluIG9uZSBvZiB0aGVcbiAqIHNjcmlwdHMgb3Igc2NyaXB0IGZhbWlsaWVzIGRlZmluZWQgYWJvdmUgYW5kIGZhbHNlIG90aGVyd2lzZS5cbiAqXG4gKiBNaWNybyBiZW5jaG1hcmtzIHNob3dzIHRoYXQgdGhpcyBpcyBmYXN0ZXIgdGhhblxuICogL1tcXHUzMDAwLVxcdTMwRkZcXHU0RTAwLVxcdTlGQUZcXHVGRjAwLVxcdUZGNjBcXHVBQzAwLVxcdUQ3QUZcXHUwOTAwLVxcdTEwOUZdLy50ZXN0KClcbiAqIGluIEZpcmVmb3gsIENocm9tZSBhbmQgTm9kZS5cbiAqL1xuXG5mdW5jdGlvbiBzdXBwb3J0ZWRDb2RlcG9pbnQoY29kZXBvaW50KSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYWxsQmxvY2tzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgaWYgKGNvZGVwb2ludCA+PSBhbGxCbG9ja3NbaV0gJiYgY29kZXBvaW50IDw9IGFsbEJsb2Nrc1tpICsgMV0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9zdmdHZW9tZXRyeS5qc1xuLyoqXG4gKiBUaGlzIGZpbGUgcHJvdmlkZXMgc3VwcG9ydCB0byBkb21UcmVlLmpzIGFuZCBkZWxpbWl0ZXIuanMuXG4gKiBJdCdzIGEgc3RvcmVob3VzZSBvZiBwYXRoIGdlb21ldHJ5IGZvciBTVkcgaW1hZ2VzLlxuICovXG4vLyBJbiBhbGwgcGF0aHMgYmVsb3csIHRoZSB2aWV3Qm94LXRvLWVtIHNjYWxlIGlzIDEwMDA6MS5cbmNvbnN0IGhMaW5lUGFkID0gODA7IC8vIHBhZGRpbmcgYWJvdmUgYSBzcXJ0IHZpbmN1bHVtLiBQcmV2ZW50cyBpbWFnZSBjcm9wcGluZy5cbi8vIFRoZSB2aW5jdWx1bSBvZiBhIFxcc3FydCBjYW4gYmUgbWFkZSB0aGlja2VyIGJ5IGEgS2FUZVggcmVuZGVyaW5nIG9wdGlvbi5cbi8vIFRoaW5rIG9mIHZhcmlhYmxlIGV4dHJhVmluY3VsdW0gYXMgdHdvIGRldG91cnMgaW4gdGhlIFNWRyBwYXRoLlxuLy8gVGhlIGRldG91ciBiZWdpbnMgYXQgdGhlIGxvd2VyIGxlZnQgb2YgdGhlIGFyZWEgbGFiZWxlZCBleHRyYVZpbmN1bHVtIGJlbG93LlxuLy8gVGhlIGRldG91ciBwcm9jZWVkcyBvbmUgZXh0cmFWaW5jdWx1bSBkaXN0YW5jZSB1cCBhbmQgc2xpZ2h0bHkgdG8gdGhlIHJpZ2h0LFxuLy8gZGlzcGxhY2luZyB0aGUgcmFkaXVzZWQgY29ybmVyIGJldHdlZW4gc3VyZCBhbmQgdmluY3VsdW0uIFRoZSByYWRpdXMgaXNcbi8vIHRyYXZlcnNlZCBhcyB1c3VhbCwgdGhlbiB0aGUgZGV0b3VyIHJlc3VtZXMuIEl0IGdvZXMgcmlnaHQsIHRvIHRoZSBlbmQgb2Zcbi8vIHRoZSB2ZXJ5IGxvbmcgdmluY3VsdW0sIHRoZW4gZG93biBvbmUgZXh0cmFWaW5jdWx1bSBkaXN0YW5jZSxcbi8vIGFmdGVyIHdoaWNoIGl0IHJlc3VtZXMgcmVndWxhciBwYXRoIGdlb21ldHJ5IGZvciB0aGUgcmFkaWNhbC5cblxuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpbmN1bHVtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvXG4gICAgICAgICAv4paS4paS4paS4paS4paS4paS4paS4paS4paS4paS4paS4paS4paS4paS4paS4paS4paS4paS4paS4paS4paS4oaQZXh0cmFWaW5jdWx1bVxuICAgICAgICAvIOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKGkDAuMDRlbSAoNDAgdW5pdCkgc3RkIHZpbmN1bHVtIHRoaWNrbmVzc1xuICAgICAgIC8gL1xuICAgICAgLyAvXG4gICAgIC8gL1xcXG4gICAgLyAvIHN1cmRcbiovXG5cbmNvbnN0IHNxcnRNYWluID0gZnVuY3Rpb24gKGV4dHJhVmluY3VsdW0sIGhMaW5lUGFkKSB7XG4gIC8vIHNxcnRNYWluIHBhdGggZ2VvbWV0cnkgaXMgZnJvbSBnbHlwaCBVMjIxQSBpbiB0aGUgZm9udCBLYVRlWCBNYWluXG4gIHJldHVybiBcIk05NSxcIiArICg2MjIgKyBleHRyYVZpbmN1bHVtICsgaExpbmVQYWQpICsgXCJcXG5jLTIuNywwLC03LjE3LC0yLjcsLTEzLjUsLThjLTUuOCwtNS4zLC05LjUsLTEwLC05LjUsLTE0XFxuYzAsLTIsMC4zLC0zLjMsMSwtNGMxLjMsLTIuNywyMy44MywtMjAuNyw2Ny41LC01NFxcbmM0NC4yLC0zMy4zLDY1LjgsLTUwLjMsNjYuNSwtNTFjMS4zLC0xLjMsMywtMiw1LC0yYzQuNywwLDguNywzLjMsMTIsMTBcXG5zMTczLDM3OCwxNzMsMzc4YzAuNywwLDM1LjMsLTcxLDEwNCwtMjEzYzY4LjcsLTE0MiwxMzcuNSwtMjg1LDIwNi41LC00MjlcXG5jNjksLTE0NCwxMDQuNSwtMjE3LjcsMTA2LjUsLTIyMVxcbmxcIiArIGV4dHJhVmluY3VsdW0gLyAyLjA3NSArIFwiIC1cIiArIGV4dHJhVmluY3VsdW0gKyBcIlxcbmM1LjMsLTkuMywxMiwtMTQsMjAsLTE0XFxuSDQwMDAwMHZcIiArICg0MCArIGV4dHJhVmluY3VsdW0pICsgXCJIODQ1LjI3MjRcXG5zLTIyNS4yNzIsNDY3LC0yMjUuMjcyLDQ2N3MtMjM1LDQ4NiwtMjM1LDQ4NmMtMi43LDQuNywtOSw3LC0xOSw3XFxuYy02LDAsLTEwLC0xLC0xMiwtM3MtMTk0LC00MjIsLTE5NCwtNDIycy02NSw0NywtNjUsNDd6XFxuTVwiICsgKDgzNCArIGV4dHJhVmluY3VsdW0pICsgXCIgXCIgKyBoTGluZVBhZCArIFwiaDQwMDAwMHZcIiArICg0MCArIGV4dHJhVmluY3VsdW0pICsgXCJoLTQwMDAwMHpcIjtcbn07XG5cbmNvbnN0IHNxcnRTaXplMSA9IGZ1bmN0aW9uIChleHRyYVZpbmN1bHVtLCBoTGluZVBhZCkge1xuICAvLyBzaXplMSBpcyBmcm9tIGdseXBoIFUyMjFBIGluIHRoZSBmb250IEthVGVYX1NpemUxLVJlZ3VsYXJcbiAgcmV0dXJuIFwiTTI2MyxcIiArICg2MDEgKyBleHRyYVZpbmN1bHVtICsgaExpbmVQYWQpICsgXCJjMC43LDAsMTgsMzkuNyw1MiwxMTlcXG5jMzQsNzkuMyw2OC4xNjcsMTU4LjcsMTAyLjUsMjM4YzM0LjMsNzkuMyw1MS44LDExOS4zLDUyLjUsMTIwXFxuYzM0MCwtNzA0LjcsNTEwLjcsLTEwNjAuMyw1MTIsLTEwNjdcXG5sXCIgKyBleHRyYVZpbmN1bHVtIC8gMi4wODQgKyBcIiAtXCIgKyBleHRyYVZpbmN1bHVtICsgXCJcXG5jNC43LC03LjMsMTEsLTExLDE5LC0xMVxcbkg0MDAwMHZcIiArICg0MCArIGV4dHJhVmluY3VsdW0pICsgXCJIMTAxMi4zXFxucy0yNzEuMyw1NjcsLTI3MS4zLDU2N2MtMzguNyw4MC43LC04NCwxNzUsLTEzNiwyODNjLTUyLDEwOCwtODkuMTY3LDE4NS4zLC0xMTEuNSwyMzJcXG5jLTIyLjMsNDYuNywtMzMuOCw3MC4zLC0zNC41LDcxYy00LjcsNC43LC0xMi4zLDcsLTIzLDdzLTEyLC0xLC0xMiwtMVxcbnMtMTA5LC0yNTMsLTEwOSwtMjUzYy03Mi43LC0xNjgsLTEwOS4zLC0yNTIsLTExMCwtMjUyYy0xMC43LDgsLTIyLDE2LjcsLTM0LDI2XFxuYy0yMiwxNy4zLC0zMy4zLDI2LC0zNCwyNnMtMjYsLTI2LC0yNiwtMjZzNzYsLTU5LDc2LC01OXM3NiwtNjAsNzYsLTYwelxcbk1cIiArICgxMDAxICsgZXh0cmFWaW5jdWx1bSkgKyBcIiBcIiArIGhMaW5lUGFkICsgXCJoNDAwMDAwdlwiICsgKDQwICsgZXh0cmFWaW5jdWx1bSkgKyBcImgtNDAwMDAwelwiO1xufTtcblxuY29uc3Qgc3FydFNpemUyID0gZnVuY3Rpb24gKGV4dHJhVmluY3VsdW0sIGhMaW5lUGFkKSB7XG4gIC8vIHNpemUyIGlzIGZyb20gZ2x5cGggVTIyMUEgaW4gdGhlIGZvbnQgS2FUZVhfU2l6ZTItUmVndWxhclxuICByZXR1cm4gXCJNOTgzIFwiICsgKDEwICsgZXh0cmFWaW5jdWx1bSArIGhMaW5lUGFkKSArIFwiXFxubFwiICsgZXh0cmFWaW5jdWx1bSAvIDMuMTMgKyBcIiAtXCIgKyBleHRyYVZpbmN1bHVtICsgXCJcXG5jNCwtNi43LDEwLC0xMCwxOCwtMTAgSDQwMDAwMHZcIiArICg0MCArIGV4dHJhVmluY3VsdW0pICsgXCJcXG5IMTAxMy4xcy04My40LDI2OCwtMjY0LjEsODQwYy0xODAuNyw1NzIsLTI3Nyw4NzYuMywtMjg5LDkxM2MtNC43LDQuNywtMTIuNyw3LC0yNCw3XFxucy0xMiwwLC0xMiwwYy0xLjMsLTMuMywtMy43LC0xMS43LC03LC0yNWMtMzUuMywtMTI1LjMsLTEwNi43LC0zNzMuMywtMjE0LC03NDRcXG5jLTEwLDEyLC0yMSwyNSwtMzMsMzlzLTMyLDM5LC0zMiwzOWMtNiwtNS4zLC0xNSwtMTQsLTI3LC0yNnMyNSwtMzAsMjUsLTMwXFxuYzI2LjcsLTMyLjcsNTIsLTYzLDc2LC05MXM1MiwtNjAsNTIsLTYwczIwOCw3MjIsMjA4LDcyMlxcbmM1NiwtMTc1LjMsMTI2LjMsLTM5Ny4zLDIxMSwtNjY2Yzg0LjcsLTI2OC43LDE1My44LC00ODguMiwyMDcuNSwtNjU4LjVcXG5jNTMuNywtMTcwLjMsODQuNSwtMjY2LjgsOTIuNSwtMjg5LjV6XFxuTVwiICsgKDEwMDEgKyBleHRyYVZpbmN1bHVtKSArIFwiIFwiICsgaExpbmVQYWQgKyBcImg0MDAwMDB2XCIgKyAoNDAgKyBleHRyYVZpbmN1bHVtKSArIFwiaC00MDAwMDB6XCI7XG59O1xuXG5jb25zdCBzcXJ0U2l6ZTMgPSBmdW5jdGlvbiAoZXh0cmFWaW5jdWx1bSwgaExpbmVQYWQpIHtcbiAgLy8gc2l6ZTMgaXMgZnJvbSBnbHlwaCBVMjIxQSBpbiB0aGUgZm9udCBLYVRlWF9TaXplMy1SZWd1bGFyXG4gIHJldHVybiBcIk00MjQsXCIgKyAoMjM5OCArIGV4dHJhVmluY3VsdW0gKyBoTGluZVBhZCkgKyBcIlxcbmMtMS4zLC0wLjcsLTM4LjUsLTE3MiwtMTExLjUsLTUxNGMtNzMsLTM0MiwtMTA5LjgsLTUxMy4zLC0xMTAuNSwtNTE0XFxuYzAsLTIsLTEwLjcsMTQuMywtMzIsNDljLTQuNyw3LjMsLTkuOCwxNS43LC0xNS41LDI1Yy01LjcsOS4zLC05LjgsMTYsLTEyLjUsMjBcXG5zLTUsNywtNSw3Yy00LC0zLjMsLTguMywtNy43LC0xMywtMTNzLTEzLC0xMywtMTMsLTEzczc2LC0xMjIsNzYsLTEyMnM3NywtMTIxLDc3LC0xMjFcXG5zMjA5LDk2OCwyMDksOTY4YzAsLTIsODQuNywtMzYxLjcsMjU0LC0xMDc5YzE2OS4zLC03MTcuMywyNTQuNywtMTA3Ny43LDI1NiwtMTA4MVxcbmxcIiArIGV4dHJhVmluY3VsdW0gLyA0LjIyMyArIFwiIC1cIiArIGV4dHJhVmluY3VsdW0gKyBcImM0LC02LjcsMTAsLTEwLDE4LC0xMCBINDAwMDAwXFxudlwiICsgKDQwICsgZXh0cmFWaW5jdWx1bSkgKyBcIkgxMDE0LjZcXG5zLTg3LjMsMzc4LjcsLTI3Mi42LDExNjZjLTE4NS4zLDc4Ny4zLC0yNzkuMywxMTgyLjMsLTI4MiwxMTg1XFxuYy0yLDYsLTEwLDksLTI0LDlcXG5jLTgsMCwtMTIsLTAuNywtMTIsLTJ6IE1cIiArICgxMDAxICsgZXh0cmFWaW5jdWx1bSkgKyBcIiBcIiArIGhMaW5lUGFkICsgXCJcXG5oNDAwMDAwdlwiICsgKDQwICsgZXh0cmFWaW5jdWx1bSkgKyBcImgtNDAwMDAwelwiO1xufTtcblxuY29uc3Qgc3FydFNpemU0ID0gZnVuY3Rpb24gKGV4dHJhVmluY3VsdW0sIGhMaW5lUGFkKSB7XG4gIC8vIHNpemU0IGlzIGZyb20gZ2x5cGggVTIyMUEgaW4gdGhlIGZvbnQgS2FUZVhfU2l6ZTQtUmVndWxhclxuICByZXR1cm4gXCJNNDczLFwiICsgKDI3MTMgKyBleHRyYVZpbmN1bHVtICsgaExpbmVQYWQpICsgXCJcXG5jMzM5LjMsLTE3OTkuMyw1MDkuMywtMjcwMCw1MTAsLTI3MDIgbFwiICsgZXh0cmFWaW5jdWx1bSAvIDUuMjk4ICsgXCIgLVwiICsgZXh0cmFWaW5jdWx1bSArIFwiXFxuYzMuMywtNy4zLDkuMywtMTEsMTgsLTExIEg0MDAwMDB2XCIgKyAoNDAgKyBleHRyYVZpbmN1bHVtKSArIFwiSDEwMTcuN1xcbnMtOTAuNSw0NzgsLTI3Ni4yLDE0NjZjLTE4NS43LDk4OCwtMjc5LjUsMTQ4MywtMjgxLjUsMTQ4NWMtMiw2LC0xMCw5LC0yNCw5XFxuYy04LDAsLTEyLC0wLjcsLTEyLC0yYzAsLTEuMywtNS4zLC0zMiwtMTYsLTkyYy01MC43LC0yOTMuMywtMTE5LjcsLTY5My4zLC0yMDcsLTEyMDBcXG5jMCwtMS4zLC01LjMsOC43LC0xNiwzMGMtMTAuNywyMS4zLC0yMS4zLDQyLjcsLTMyLDY0cy0xNiwzMywtMTYsMzNzLTI2LC0yNiwtMjYsLTI2XFxuczc2LC0xNTMsNzYsLTE1M3M3NywtMTUxLDc3LC0xNTFjMC43LDAuNywzNS43LDIwMiwxMDUsNjA0YzY3LjMsNDAwLjcsMTAyLDYwMi43LDEwNCxcXG42MDZ6TVwiICsgKDEwMDEgKyBleHRyYVZpbmN1bHVtKSArIFwiIFwiICsgaExpbmVQYWQgKyBcImg0MDAwMDB2XCIgKyAoNDAgKyBleHRyYVZpbmN1bHVtKSArIFwiSDEwMTcuN3pcIjtcbn07XG5cbmNvbnN0IHBoYXNlUGF0aCA9IGZ1bmN0aW9uICh5KSB7XG4gIGNvbnN0IHggPSB5IC8gMjsgLy8geCBjb29yZGluYXRlIGF0IHRvcCBvZiBhbmdsZVxuXG4gIHJldHVybiBcIk00MDAwMDAgXCIgKyB5ICsgXCIgSDAgTFwiICsgeCArIFwiIDAgbDY1IDQ1IEwxNDUgXCIgKyAoeSAtIDgwKSArIFwiIEg0MDAwMDB6XCI7XG59O1xuXG5jb25zdCBzcXJ0VGFsbCA9IGZ1bmN0aW9uIChleHRyYVZpbmN1bHVtLCBoTGluZVBhZCwgdmlld0JveEhlaWdodCkge1xuICAvLyBzcXJ0VGFsbCBpcyBmcm9tIGdseXBoIFUyM0I3IGluIHRoZSBmb250IEthVGVYX1NpemU0LVJlZ3VsYXJcbiAgLy8gT25lIHBhdGggZWRnZSBoYXMgYSB2YXJpYWJsZSBsZW5ndGguIEl0IHJ1bnMgdmVydGljYWxseSBmcm9tIHRoZSB2aW5jdWx1bVxuICAvLyB0byBhIHBvaW50IG5lYXIgKDE0IHVuaXRzKSB0aGUgYm90dG9tIG9mIHRoZSBzdXJkLiBUaGUgdmluY3VsdW1cbiAgLy8gaXMgbm9ybWFsbHkgNDAgdW5pdHMgdGhpY2suIFNvIHRoZSBsZW5ndGggb2YgdGhlIGxpbmUgaW4gcXVlc3Rpb24gaXM6XG4gIGNvbnN0IHZlcnRTZWdtZW50ID0gdmlld0JveEhlaWdodCAtIDU0IC0gaExpbmVQYWQgLSBleHRyYVZpbmN1bHVtO1xuICByZXR1cm4gXCJNNzAyIFwiICsgKGV4dHJhVmluY3VsdW0gKyBoTGluZVBhZCkgKyBcIkg0MDAwMDBcIiArICg0MCArIGV4dHJhVmluY3VsdW0pICsgXCJcXG5INzQydlwiICsgdmVydFNlZ21lbnQgKyBcImwtNCA0LTQgNGMtLjY2Ny43IC0yIDEuNS00IDIuNXMtNC4xNjcgMS44MzMtNi41IDIuNS01LjUgMS05LjUgMVxcbmgtMTJsLTI4LTg0Yy0xNi42NjctNTItOTYuNjY3IC0yOTQuMzMzLTI0MC03MjdsLTIxMiAtNjQzIC04NSAxNzBcXG5jLTQtMy4zMzMtOC4zMzMtNy42NjctMTMgLTEzbC0xMy0xM2w3Ny0xNTUgNzctMTU2YzY2IDE5OS4zMzMgMTM5IDQxOS42NjdcXG4yMTkgNjYxIGwyMTggNjYxek03MDIgXCIgKyBoTGluZVBhZCArIFwiSDQwMDAwMHZcIiArICg0MCArIGV4dHJhVmluY3VsdW0pICsgXCJINzQyelwiO1xufTtcblxuY29uc3Qgc3FydFBhdGggPSBmdW5jdGlvbiAoc2l6ZSwgZXh0cmFWaW5jdWx1bSwgdmlld0JveEhlaWdodCkge1xuICBleHRyYVZpbmN1bHVtID0gMTAwMCAqIGV4dHJhVmluY3VsdW07IC8vIENvbnZlcnQgZnJvbSBkb2N1bWVudCBlbXMgdG8gdmlld0JveC5cblxuICBsZXQgcGF0aCA9IFwiXCI7XG5cbiAgc3dpdGNoIChzaXplKSB7XG4gICAgY2FzZSBcInNxcnRNYWluXCI6XG4gICAgICBwYXRoID0gc3FydE1haW4oZXh0cmFWaW5jdWx1bSwgaExpbmVQYWQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwic3FydFNpemUxXCI6XG4gICAgICBwYXRoID0gc3FydFNpemUxKGV4dHJhVmluY3VsdW0sIGhMaW5lUGFkKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcInNxcnRTaXplMlwiOlxuICAgICAgcGF0aCA9IHNxcnRTaXplMihleHRyYVZpbmN1bHVtLCBoTGluZVBhZCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJzcXJ0U2l6ZTNcIjpcbiAgICAgIHBhdGggPSBzcXJ0U2l6ZTMoZXh0cmFWaW5jdWx1bSwgaExpbmVQYWQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwic3FydFNpemU0XCI6XG4gICAgICBwYXRoID0gc3FydFNpemU0KGV4dHJhVmluY3VsdW0sIGhMaW5lUGFkKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcInNxcnRUYWxsXCI6XG4gICAgICBwYXRoID0gc3FydFRhbGwoZXh0cmFWaW5jdWx1bSwgaExpbmVQYWQsIHZpZXdCb3hIZWlnaHQpO1xuICB9XG5cbiAgcmV0dXJuIHBhdGg7XG59O1xuY29uc3QgaW5uZXJQYXRoID0gZnVuY3Rpb24gKG5hbWUsIGhlaWdodCkge1xuICAvLyBUaGUgaW5uZXIgcGFydCBvZiBzdHJldGNoeSB0YWxsIGRlbGltaXRlcnNcbiAgc3dpdGNoIChuYW1lKSB7XG4gICAgY2FzZSBcIlxcdTIzOWNcIjpcbiAgICAgIHJldHVybiBcIk0yOTEgMCBINDE3IFZcIiArIGhlaWdodCArIFwiIEgyOTF6IE0yOTEgMCBINDE3IFZcIiArIGhlaWdodCArIFwiIEgyOTF6XCI7XG5cbiAgICBjYXNlIFwiXFx1MjIyM1wiOlxuICAgICAgcmV0dXJuIFwiTTE0NSAwIEgxODggVlwiICsgaGVpZ2h0ICsgXCIgSDE0NXogTTE0NSAwIEgxODggVlwiICsgaGVpZ2h0ICsgXCIgSDE0NXpcIjtcblxuICAgIGNhc2UgXCJcXHUyMjI1XCI6XG4gICAgICByZXR1cm4gXCJNMTQ1IDAgSDE4OCBWXCIgKyBoZWlnaHQgKyBcIiBIMTQ1eiBNMTQ1IDAgSDE4OCBWXCIgKyBoZWlnaHQgKyBcIiBIMTQ1elwiICsgKFwiTTM2NyAwIEg0MTAgVlwiICsgaGVpZ2h0ICsgXCIgSDM2N3ogTTM2NyAwIEg0MTAgVlwiICsgaGVpZ2h0ICsgXCIgSDM2N3pcIik7XG5cbiAgICBjYXNlIFwiXFx1MjM5ZlwiOlxuICAgICAgcmV0dXJuIFwiTTQ1NyAwIEg1ODMgVlwiICsgaGVpZ2h0ICsgXCIgSDQ1N3ogTTQ1NyAwIEg1ODMgVlwiICsgaGVpZ2h0ICsgXCIgSDQ1N3pcIjtcblxuICAgIGNhc2UgXCJcXHUyM2EyXCI6XG4gICAgICByZXR1cm4gXCJNMzE5IDAgSDQwMyBWXCIgKyBoZWlnaHQgKyBcIiBIMzE5eiBNMzE5IDAgSDQwMyBWXCIgKyBoZWlnaHQgKyBcIiBIMzE5elwiO1xuXG4gICAgY2FzZSBcIlxcdTIzYTVcIjpcbiAgICAgIHJldHVybiBcIk0yNjMgMCBIMzQ3IFZcIiArIGhlaWdodCArIFwiIEgyNjN6IE0yNjMgMCBIMzQ3IFZcIiArIGhlaWdodCArIFwiIEgyNjN6XCI7XG5cbiAgICBjYXNlIFwiXFx1MjNhYVwiOlxuICAgICAgcmV0dXJuIFwiTTM4NCAwIEg1MDQgVlwiICsgaGVpZ2h0ICsgXCIgSDM4NHogTTM4NCAwIEg1MDQgVlwiICsgaGVpZ2h0ICsgXCIgSDM4NHpcIjtcblxuICAgIGNhc2UgXCJcXHUyM2QwXCI6XG4gICAgICByZXR1cm4gXCJNMzEyIDAgSDM1NSBWXCIgKyBoZWlnaHQgKyBcIiBIMzEyeiBNMzEyIDAgSDM1NSBWXCIgKyBoZWlnaHQgKyBcIiBIMzEyelwiO1xuXG4gICAgY2FzZSBcIlxcdTIwMTZcIjpcbiAgICAgIHJldHVybiBcIk0yNTcgMCBIMzAwIFZcIiArIGhlaWdodCArIFwiIEgyNTd6IE0yNTcgMCBIMzAwIFZcIiArIGhlaWdodCArIFwiIEgyNTd6XCIgKyAoXCJNNDc4IDAgSDUyMSBWXCIgKyBoZWlnaHQgKyBcIiBINDc4eiBNNDc4IDAgSDUyMSBWXCIgKyBoZWlnaHQgKyBcIiBINDc4elwiKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gXCJcIjtcbiAgfVxufTtcbmNvbnN0IHBhdGggPSB7XG4gIC8vIFRoZSBkb3VibGVsZWZ0YXJyb3cgZ2VvbWV0cnkgaXMgZnJvbSBnbHlwaCBVKzIxRDAgaW4gdGhlIGZvbnQgS2FUZVggTWFpblxuICBkb3VibGVsZWZ0YXJyb3c6IFwiTTI2MiAxNTdcXG5sMTAtMTBjMzQtMzYgNjIuNy03NyA4Ni0xMjMgMy4zLTggNS0xMy4zIDUtMTYgMC01LjMtNi43LTgtMjAtOC03LjNcXG4gMC0xMi4yLjUtMTQuNSAxLjUtMi4zIDEtNC44IDQuNS03LjUgMTAuNS00OS4zIDk3LjMtMTIxLjcgMTY5LjMtMjE3IDIxNi0yOFxcbiAxNC01Ny4zIDI1LTg4IDMzLTYuNyAyLTExIDMuOC0xMyA1LjUtMiAxLjctMyA0LjItMyA3LjVzMSA1LjggMyA3LjVcXG5jMiAxLjcgNi4zIDMuNSAxMyA1LjUgNjggMTcuMyAxMjguMiA0Ny44IDE4MC41IDkxLjUgNTIuMyA0My43IDkzLjggOTYuMiAxMjQuNVxcbiAxNTcuNSA5LjMgOCAxNS4zIDEyLjMgMTggMTNoNmMxMi0uNyAxOC00IDE4LTEwIDAtMi0xLjctNy01LTE1LTIzLjMtNDYtNTItODdcXG4tODYtMTIzbC0xMC0xMGgzOTk3Mzh2LTQwSDIxOGMzMjggMCAwIDAgMCAwbC0xMC04Yy0yNi43LTIwLTY1LjctNDMtMTE3LTY5IDIuN1xcbi0yIDYtMy43IDEwLTUgMzYuNy0xNiA3Mi4zLTM3LjMgMTA3LTY0bDEwLThoMzk5Nzgydi00MHpcXG5tOCAwdjQwaDM5OTczMHYtNDB6bTAgMTk0djQwaDM5OTczMHYtNDB6XCIsXG4gIC8vIGRvdWJsZXJpZ2h0YXJyb3cgaXMgZnJvbSBnbHlwaCBVKzIxRDIgaW4gZm9udCBLYVRlWCBNYWluXG4gIGRvdWJsZXJpZ2h0YXJyb3c6IFwiTTM5OTczOCAzOTJsXFxuLTEwIDEwYy0zNCAzNi02Mi43IDc3LTg2IDEyMy0zLjMgOC01IDEzLjMtNSAxNiAwIDUuMyA2LjcgOCAyMCA4IDcuMyAwIDEyLjItLjVcXG4gMTQuNS0xLjUgMi4zLTEgNC44LTQuNSA3LjUtMTAuNSA0OS4zLTk3LjMgMTIxLjctMTY5LjMgMjE3LTIxNiAyOC0xNCA1Ny4zLTI1IDg4XFxuLTMzIDYuNy0yIDExLTMuOCAxMy01LjUgMi0xLjcgMy00LjIgMy03LjVzLTEtNS44LTMtNy41Yy0yLTEuNy02LjMtMy41LTEzLTUuNS02OFxcbi0xNy4zLTEyOC4yLTQ3LjgtMTgwLjUtOTEuNS01Mi4zLTQzLjctOTMuOC05Ni4yLTEyNC41LTE1Ny41LTkuMy04LTE1LjMtMTIuMy0xOFxcbi0xM2gtNmMtMTIgLjctMTggNC0xOCAxMCAwIDIgMS43IDcgNSAxNSAyMy4zIDQ2IDUyIDg3IDg2IDEyM2wxMCAxMEgwdjQwaDM5OTc4MlxcbmMtMzI4IDAgMCAwIDAgMGwxMCA4YzI2LjcgMjAgNjUuNyA0MyAxMTcgNjktMi43IDItNiAzLjctMTAgNS0zNi43IDE2LTcyLjMgMzcuM1xcbi0xMDcgNjRsLTEwIDhIMHY0MHpNMCAxNTd2NDBoMzk5NzMwdi00MHptMCAxOTR2NDBoMzk5NzMwdi00MHpcIixcbiAgLy8gbGVmdGFycm93IGlzIGZyb20gZ2x5cGggVSsyMTkwIGluIGZvbnQgS2FUZVggTWFpblxuICBsZWZ0YXJyb3c6IFwiTTQwMDAwMCAyNDFIMTEwbDMtM2M2OC43LTUyLjcgMTEzLjctMTIwXFxuIDEzNS0yMDIgNC0xNC43IDYtMjMgNi0yNSAwLTcuMy03LTExLTIxLTExLTggMC0xMy4yLjgtMTUuNSAyLjUtMi4zIDEuNy00LjIgNS44XFxuLTUuNSAxMi41LTEuMyA0LjctMi43IDEwLjMtNCAxNy0xMiA0OC43LTM0LjggOTItNjguNSAxMzBTNjUuMyAyMjguMyAxOCAyNDdcXG5jLTEwIDQtMTYgNy43LTE4IDExIDAgOC43IDYgMTQuMyAxOCAxNyA0Ny4zIDE4LjcgODcuOCA0NyAxMjEuNSA4NVMxOTYgNDQxLjMgMjA4XFxuIDQ5MGMuNyAyIDEuMyA1IDIgOXMxLjIgNi43IDEuNSA4Yy4zIDEuMyAxIDMuMyAyIDZzMi4yIDQuNSAzLjUgNS41YzEuMyAxIDMuM1xcbiAxLjggNiAyLjVzNiAxIDEwIDFjMTQgMCAyMS0zLjcgMjEtMTEgMC0yLTItMTAuMy02LTI1LTIwLTc5LjMtNjUtMTQ2LjctMTM1LTIwMlxcbiBsLTMtM2gzOTk4OTB6TTEwMCAyNDF2NDBoMzk5OTAwdi00MHpcIixcbiAgLy8gb3ZlcmJyYWNlIGlzIGZyb20gZ2x5cGhzIFUrMjNBOS8yM0E4LzIzQTcgaW4gZm9udCBLYVRlWF9TaXplNC1SZWd1bGFyXG4gIGxlZnRicmFjZTogXCJNNiA1NDhsLTYtNnYtMzVsNi0xMWM1Ni0xMDQgMTM1LjMtMTgxLjMgMjM4LTIzMiA1Ny4zLTI4LjcgMTE3XFxuLTQ1IDE3OS01MGgzOTk1Nzd2MTIwSDQwM2MtNDMuMyA3LTgxIDE1LTExMyAyNi0xMDAuNyAzMy0xNzkuNyA5MS0yMzcgMTc0LTIuN1xcbiA1LTYgOS0xMCAxMy0uNyAxLTcuMyAxLTIwIDFINnpcIixcbiAgbGVmdGJyYWNldW5kZXI6IFwiTTAgNmw2LTZoMTdjMTIuNjg4IDAgMTkuMzEzLjMgMjAgMSA0IDQgNy4zMTMgOC4zIDEwIDEzXFxuIDM1LjMxMyA1MS4zIDgwLjgxMyA5My44IDEzNi41IDEyNy41IDU1LjY4OCAzMy43IDExNy4xODggNTUuOCAxODQuNSA2Ni41LjY4OFxcbiAwIDIgLjMgNCAxIDE4LjY4OCAyLjcgNzYgNC4zIDE3MiA1aDM5OTQ1MHYxMjBINDI5bC02LTFjLTEyNC42ODgtOC0yMzUtNjEuN1xcbi0zMzEtMTYxQzYwLjY4NyAxMzguNyAzMi4zMTIgOTkuMyA3IDU0TDAgNDFWNnpcIixcbiAgLy8gb3Zlcmdyb3VwIGlzIGZyb20gdGhlIE1uU3ltYm9sIHBhY2thZ2UgKHB1YmxpYyBkb21haW4pXG4gIGxlZnRncm91cDogXCJNNDAwMDAwIDgwXFxuSDQzNUM2NCA4MCAxNjguMyAyMjkuNCAyMSAyNjBjLTUuOSAxLjItMTggMC0xOCAwLTIgMC0zLTEtMy0zdi0zOEM3NiA2MSAyNTcgMFxcbiA0MzUgMGgzOTk1NjV6XCIsXG4gIGxlZnRncm91cHVuZGVyOiBcIk00MDAwMDAgMjYyXFxuSDQzNUM2NCAyNjIgMTY4LjMgMTEyLjYgMjEgODJjLTUuOS0xLjItMTggMC0xOCAwLTIgMC0zIDEtMyAzdjM4Yzc2IDE1OCAyNTcgMjE5XFxuIDQzNSAyMTloMzk5NTY1elwiLFxuICAvLyBIYXJwb29ucyBhcmUgZnJvbSBnbHlwaCBVKzIxQkQgaW4gZm9udCBLYVRlWCBNYWluXG4gIGxlZnRoYXJwb29uOiBcIk0wIDI2N2MuNyA1LjMgMyAxMCA3IDE0aDM5OTk5M3YtNDBIOTNjMy4zXFxuLTMuMyAxMC4yLTkuNSAyMC41LTE4LjVzMTcuOC0xNS44IDIyLjUtMjAuNWM1MC43LTUyIDg4LTExMC4zIDExMi0xNzUgNC0xMS4zIDVcXG4tMTguMyAzLTIxLTEuMy00LTcuMy02LTE4LTYtOCAwLTEzIC43LTE1IDJzLTQuNyA2LjctOCAxNmMtNDIgOTguNy0xMDcuMyAxNzQuN1xcbi0xOTYgMjI4LTYuNyA0LjctMTAuNyA4LTEyIDEwLTEuMyAyLTIgNS43LTIgMTF6bTEwMC0yNnY0MGgzOTk5MDB2LTQwelwiLFxuICBsZWZ0aGFycG9vbnBsdXM6IFwiTTAgMjY3Yy43IDUuMyAzIDEwIDcgMTRoMzk5OTkzdi00MEg5M2MzLjMtMy4zIDEwLjItOS41XFxuIDIwLjUtMTguNXMxNy44LTE1LjggMjIuNS0yMC41YzUwLjctNTIgODgtMTEwLjMgMTEyLTE3NSA0LTExLjMgNS0xOC4zIDMtMjEtMS4zXFxuLTQtNy4zLTYtMTgtNi04IDAtMTMgLjctMTUgMnMtNC43IDYuNy04IDE2Yy00MiA5OC43LTEwNy4zIDE3NC43LTE5NiAyMjgtNi43IDQuN1xcbi0xMC43IDgtMTIgMTAtMS4zIDItMiA1LjctMiAxMXptMTAwLTI2djQwaDM5OTkwMHYtNDB6TTAgNDM1djQwaDQwMDAwMHYtNDB6XFxubTAgMHY0MGg0MDAwMDB2LTQwelwiLFxuICBsZWZ0aGFycG9vbmRvd246IFwiTTcgMjQxYy00IDQtNi4zMzMgOC42NjctNyAxNCAwIDUuMzMzLjY2NyA5IDIgMTFzNS4zMzNcXG4gNS4zMzMgMTIgMTBjOTAuNjY3IDU0IDE1NiAxMzAgMTk2IDIyOCAzLjMzMyAxMC42NjcgNi4zMzMgMTYuMzMzIDkgMTcgMiAuNjY3IDVcXG4gMSA5IDFoNWMxMC42NjcgMCAxNi42NjctMiAxOC02IDItMi42NjcgMS05LjY2Ny0zLTIxLTMyLTg3LjMzMy04Mi42NjctMTU3LjY2N1xcbi0xNTItMjExbC0zLTNoMzk5OTA3di00MHpNOTMgMjgxIEg0MDAwMDAgdi00MEw3IDI0MXpcIixcbiAgbGVmdGhhcnBvb25kb3ducGx1czogXCJNNyA0MzVjLTQgNC02LjMgOC43LTcgMTQgMCA1LjMuNyA5IDIgMTFzNS4zIDUuMyAxMlxcbiAxMGM5MC43IDU0IDE1NiAxMzAgMTk2IDIyOCAzLjMgMTAuNyA2LjMgMTYuMyA5IDE3IDIgLjcgNSAxIDkgMWg1YzEwLjcgMCAxNi43XFxuLTIgMTgtNiAyLTIuNyAxLTkuNy0zLTIxLTMyLTg3LjMtODIuNy0xNTcuNy0xNTItMjExbC0zLTNoMzk5OTA3di00MEg3em05MyAwXFxudjQwaDM5OTkwMHYtNDB6TTAgMjQxdjQwaDM5OTkwMHYtNDB6bTAgMHY0MGgzOTk5MDB2LTQwelwiLFxuICAvLyBob29rIGlzIGZyb20gZ2x5cGggVSsyMUE5IGluIGZvbnQgS2FUZVggTWFpblxuICBsZWZ0aG9vazogXCJNNDAwMDAwIDI4MSBIMTAzcy0zMy0xMS4yLTYxLTMzLjVTMCAxOTcuMyAwIDE2NHMxNC4yLTYxLjIgNDIuNVxcbi04My41QzcwLjggNTguMiAxMDQgNDcgMTQyIDQ3IGMxNi43IDAgMjUgNi43IDI1IDIwIDAgMTItOC43IDE4LjctMjYgMjAtNDAgMy4zXFxuLTY4LjcgMTUuNy04NiAzNy0xMCAxMi0xNSAyNS4zLTE1IDQwIDAgMjIuNyA5LjggNDAuNyAyOS41IDU0IDE5LjcgMTMuMyA0My41IDIxXFxuIDcxLjUgMjNoMzk5ODU5ek0xMDMgMjgxdi00MGgzOTk4OTd2NDB6XCIsXG4gIGxlZnRsaW5lc2VnbWVudDogXCJNNDAgMjgxIFY0MjggSDAgVjk0IEg0MCBWMjQxIEg0MDAwMDAgdjQwelxcbk00MCAyODEgVjQyOCBIMCBWOTQgSDQwIFYyNDEgSDQwMDAwMCB2NDB6XCIsXG4gIGxlZnRtYXBzdG86IFwiTTQwIDI4MSBWNDQ4SDBWNzRINDBWMjQxSDQwMDAwMHY0MHpcXG5NNDAgMjgxIFY0NDhIMFY3NEg0MFYyNDFINDAwMDAwdjQwelwiLFxuICAvLyB0b2Zyb20gaXMgZnJvbSBnbHlwaCBVKzIxQzQgaW4gZm9udCBLYVRlWCBBTVMgUmVndWxhclxuICBsZWZ0VG9Gcm9tOiBcIk0wIDE0N2g0MDAwMDB2NDBIMHptMCAyMTRjNjggNDAgMTE1LjcgOTUuNyAxNDMgMTY3aDIyYzE1LjMgMCAyM1xcbi0uMyAyMy0xIDAtMS4zLTUuMy0xMy43LTE2LTM3LTE4LTM1LjMtNDEuMy02OS03MC0xMDFsLTctOGgzOTk5MDV2LTQwSDk1bDctOFxcbmMyOC43LTMyIDUyLTY1LjcgNzAtMTAxIDEwLjctMjMuMyAxNi0zNS43IDE2LTM3IDAtLjctNy43LTEtMjMtMWgtMjJDMTE1LjcgMjY1LjNcXG4gNjggMzIxIDAgMzYxem0wLTE3NHYtNDBoMzk5OTAwdjQwem0xMDAgMTU0djQwaDM5OTkwMHYtNDB6XCIsXG4gIGxvbmdlcXVhbDogXCJNMCA1MCBoNDAwMDAwIHY0MEgweiBtMCAxOTRoNDAwMDB2NDBIMHpcXG5NMCA1MCBoNDAwMDAwIHY0MEgweiBtMCAxOTRoNDAwMDB2NDBIMHpcIixcbiAgbWlkYnJhY2U6IFwiTTIwMDQyOCAzMzRcXG5jLTEwMC43LTguMy0xOTUuMy00NC0yODAtMTA4LTU1LjMtNDItMTAxLjctOTMtMTM5LTE1M2wtOS0xNGMtMi43IDQtNS43IDguNy05IDE0XFxuLTUzLjMgODYuNy0xMjMuNyAxNTMtMjExIDE5OS02Ni43IDM2LTEzNy4zIDU2LjMtMjEyIDYySDBWMjE0aDE5OTU2OGMxNzguMy0xMS43XFxuIDMxMS43LTc4LjMgNDAzLTIwMSA2LTggOS43LTEyIDExLTEyIC43LS43IDYuNy0xIDE4LTFzMTcuMy4zIDE4IDFjMS4zIDAgNSA0IDExXFxuIDEyIDQ0LjcgNTkuMyAxMDEuMyAxMDYuMyAxNzAgMTQxczE0NS4zIDU0LjMgMjI5IDYwaDE5OTU3MnYxMjB6XCIsXG4gIG1pZGJyYWNldW5kZXI6IFwiTTE5OTU3MiAyMTRcXG5jMTAwLjcgOC4zIDE5NS4zIDQ0IDI4MCAxMDggNTUuMyA0MiAxMDEuNyA5MyAxMzkgMTUzbDkgMTRjMi43LTQgNS43LTguNyA5LTE0XFxuIDUzLjMtODYuNyAxMjMuNy0xNTMgMjExLTE5OSA2Ni43LTM2IDEzNy4zLTU2LjMgMjEyLTYyaDE5OTU2OHYxMjBIMjAwNDMyYy0xNzguM1xcbiAxMS43LTMxMS43IDc4LjMtNDAzIDIwMS02IDgtOS43IDEyLTExIDEyLS43LjctNi43IDEtMTggMXMtMTcuMy0uMy0xOC0xYy0xLjMgMFxcbi01LTQtMTEtMTItNDQuNy01OS4zLTEwMS4zLTEwNi4zLTE3MC0xNDFzLTE0NS4zLTU0LjMtMjI5LTYwSDBWMjE0elwiLFxuICBvaWludFNpemUxOiBcIk01MTIuNiA3MS42YzI3Mi42IDAgMzIwLjMgMTA2LjggMzIwLjMgMTc4LjIgMCA3MC44LTQ3LjcgMTc3LjZcXG4tMzIwLjMgMTc3LjZTMTkzLjEgMzIwLjYgMTkzLjEgMjQ5LjhjMC03MS40IDQ2LjktMTc4LjIgMzE5LjUtMTc4LjJ6XFxubTM2OC4xIDE3OC4yYzAtODYuNC02MC45LTIxNS40LTM2OC4xLTIxNS40LTMwNi40IDAtMzY3LjMgMTI5LTM2Ny4zIDIxNS40IDAgODUuOFxcbjYwLjkgMjE0LjggMzY3LjMgMjE0LjggMzA3LjIgMCAzNjguMS0xMjkgMzY4LjEtMjE0Ljh6XCIsXG4gIG9paW50U2l6ZTI6IFwiTTc1Ny44IDEwMC4xYzM4NC43IDAgNDUxLjEgMTM3LjYgNDUxLjEgMjMwIDAgOTEuMy02Ni40IDIyOC44XFxuLTQ1MS4xIDIyOC44LTM4Ni4zIDAtNDUyLjctMTM3LjUtNDUyLjctMjI4LjggMC05Mi40IDY2LjQtMjMwIDQ1Mi43LTIzMHpcXG5tNTAyLjQgMjMwYzAtMTExLjItODIuNC0yNzcuMi01MDIuNC0yNzcuMnMtNTA0IDE2Ni01MDQgMjc3LjJcXG5jMCAxMTAgODQgMjc2IDUwNCAyNzZzNTAyLjQtMTY2IDUwMi40LTI3NnpcIixcbiAgb2lpaW50U2l6ZTE6IFwiTTY4MS40IDcxLjZjNDA4LjkgMCA0ODAuNSAxMDYuOCA0ODAuNSAxNzguMiAwIDcwLjgtNzEuNiAxNzcuNlxcbi00ODAuNSAxNzcuNlMyMDIuMSAzMjAuNiAyMDIuMSAyNDkuOGMwLTcxLjQgNzAuNS0xNzguMiA0NzkuMy0xNzguMnpcXG5tNTI1LjggMTc4LjJjMC04Ni40LTg2LjgtMjE1LjQtNTI1LjctMjE1LjQtNDM3LjkgMC01MjQuNyAxMjktNTI0LjcgMjE1LjQgMFxcbjg1LjggODYuOCAyMTQuOCA1MjQuNyAyMTQuOCA0MzguOSAwIDUyNS43LTEyOSA1MjUuNy0yMTQuOHpcIixcbiAgb2lpaW50U2l6ZTI6IFwiTTEwMjEuMiA1M2M2MDMuNiAwIDcwNy44IDE2NS44IDcwNy44IDI3Ny4yIDAgMTEwLTEwNC4yIDI3NS44XFxuLTcwNy44IDI3NS44LTYwNiAwLTcxMC4yLTE2NS44LTcxMC4yLTI3NS44QzMxMSAyMTguOCA0MTUuMiA1MyAxMDIxLjIgNTN6XFxubTc3MC40IDI3Ny4xYzAtMTMxLjItMTI2LjQtMzI3LjYtNzcwLjUtMzI3LjZTMjQ4LjQgMTk4LjkgMjQ4LjQgMzMwLjFcXG5jMCAxMzAgMTI4LjggMzI2LjQgNzcyLjcgMzI2LjRzNzcwLjUtMTk2LjQgNzcwLjUtMzI2LjR6XCIsXG4gIHJpZ2h0YXJyb3c6IFwiTTAgMjQxdjQwaDM5OTg5MWMtNDcuMyAzNS4zLTg0IDc4LTExMCAxMjhcXG4tMTYuNyAzMi0yNy43IDYzLjctMzMgOTUgMCAxLjMtLjIgMi43LS41IDQtLjMgMS4zLS41IDIuMy0uNSAzIDAgNy4zIDYuNyAxMSAyMFxcbiAxMSA4IDAgMTMuMi0uOCAxNS41LTIuNSAyLjMtMS43IDQuMi01LjUgNS41LTExLjUgMi0xMy4zIDUuNy0yNyAxMS00MSAxNC43LTQ0LjdcXG4gMzktODQuNSA3My0xMTkuNXM3My43LTYwLjIgMTE5LTc1LjVjNi0yIDktNS43IDktMTFzLTMtOS05LTExYy00NS4zLTE1LjMtODVcXG4tNDAuNS0xMTktNzUuNXMtNTguMy03NC44LTczLTExOS41Yy00LjctMTQtOC4zLTI3LjMtMTEtNDAtMS4zLTYuNy0zLjItMTAuOC01LjVcXG4tMTIuNS0yLjMtMS43LTcuNS0yLjUtMTUuNS0yLjUtMTQgMC0yMSAzLjctMjEgMTEgMCAyIDIgMTAuMyA2IDI1IDIwLjcgODMuMyA2N1xcbiAxNTEuNyAxMzkgMjA1em0wIDB2NDBoMzk5OTAwdi00MHpcIixcbiAgcmlnaHRicmFjZTogXCJNNDAwMDAwIDU0MmxcXG4tNiA2aC0xN2MtMTIuNyAwLTE5LjMtLjMtMjAtMS00LTQtNy4zLTguMy0xMC0xMy0zNS4zLTUxLjMtODAuOC05My44LTEzNi41LTEyNy41XFxucy0xMTcuMi01NS44LTE4NC41LTY2LjVjLS43IDAtMi0uMy00LTEtMTguNy0yLjctNzYtNC4zLTE3Mi01SDBWMjE0aDM5OTU3MWw2IDFcXG5jMTI0LjcgOCAyMzUgNjEuNyAzMzEgMTYxIDMxLjMgMzMuMyA1OS43IDcyLjcgODUgMTE4bDcgMTN2MzV6XCIsXG4gIHJpZ2h0YnJhY2V1bmRlcjogXCJNMzk5OTk0IDBsNiA2djM1bC02IDExYy01NiAxMDQtMTM1LjMgMTgxLjMtMjM4IDIzMi01Ny4zXFxuIDI4LjctMTE3IDQ1LTE3OSA1MEgtMzAwVjIxNGgzOTk4OTdjNDMuMy03IDgxLTE1IDExMy0yNiAxMDAuNy0zMyAxNzkuNy05MSAyMzdcXG4tMTc0IDIuNy01IDYtOSAxMC0xMyAuNy0xIDcuMy0xIDIwLTFoMTd6XCIsXG4gIHJpZ2h0Z3JvdXA6IFwiTTAgODBoMzk5NTY1YzM3MSAwIDI2Ni43IDE0OS40IDQxNCAxODAgNS45IDEuMiAxOCAwIDE4IDAgMiAwXFxuIDMtMSAzLTN2LTM4Yy03Ni0xNTgtMjU3LTIxOS00MzUtMjE5SDB6XCIsXG4gIHJpZ2h0Z3JvdXB1bmRlcjogXCJNMCAyNjJoMzk5NTY1YzM3MSAwIDI2Ni43LTE0OS40IDQxNC0xODAgNS45LTEuMiAxOCAwIDE4XFxuIDAgMiAwIDMgMSAzIDN2MzhjLTc2IDE1OC0yNTcgMjE5LTQzNSAyMTlIMHpcIixcbiAgcmlnaHRoYXJwb29uOiBcIk0wIDI0MXY0MGgzOTk5OTNjNC43LTQuNyA3LTkuMyA3LTE0IDAtOS4zXFxuLTMuNy0xNS4zLTExLTE4LTkyLjctNTYuNy0xNTktMTMzLjctMTk5LTIzMS0zLjMtOS4zLTYtMTQuNy04LTE2LTItMS4zLTctMi0xNS0yXFxuLTEwLjcgMC0xNi43IDItMTggNi0yIDIuNy0xIDkuNyAzIDIxIDE1LjMgNDIgMzYuNyA4MS44IDY0IDExOS41IDI3LjMgMzcuNyA1OFxcbiA2OS4yIDkyIDk0LjV6bTAgMHY0MGgzOTk5MDB2LTQwelwiLFxuICByaWdodGhhcnBvb25wbHVzOiBcIk0wIDI0MXY0MGgzOTk5OTNjNC43LTQuNyA3LTkuMyA3LTE0IDAtOS4zLTMuNy0xNS4zLTExXFxuLTE4LTkyLjctNTYuNy0xNTktMTMzLjctMTk5LTIzMS0zLjMtOS4zLTYtMTQuNy04LTE2LTItMS4zLTctMi0xNS0yLTEwLjcgMC0xNi43XFxuIDItMTggNi0yIDIuNy0xIDkuNyAzIDIxIDE1LjMgNDIgMzYuNyA4MS44IDY0IDExOS41IDI3LjMgMzcuNyA1OCA2OS4yIDkyIDk0LjV6XFxubTAgMHY0MGgzOTk5MDB2LTQweiBtMTAwIDE5NHY0MGgzOTk5MDB2LTQwem0wIDB2NDBoMzk5OTAwdi00MHpcIixcbiAgcmlnaHRoYXJwb29uZG93bjogXCJNMzk5NzQ3IDUxMWMwIDcuMyA2LjcgMTEgMjAgMTEgOCAwIDEzLS44IDE1LTIuNXM0LjctNi44XFxuIDgtMTUuNWM0MC05NCA5OS4zLTE2Ni4zIDE3OC0yMTcgMTMuMy04IDIwLjMtMTIuMyAyMS0xMyA1LjMtMy4zIDguNS01LjggOS41XFxuLTcuNSAxLTEuNyAxLjUtNS4yIDEuNS0xMC41cy0yLjMtMTAuMy03LTE1SDB2NDBoMzk5OTA4Yy0zNCAyNS4zLTY0LjcgNTctOTIgOTVcXG4tMjcuMyAzOC00OC43IDc3LjctNjQgMTE5LTMuMyA4LjctNSAxNC01IDE2ek0wIDI0MXY0MGgzOTk5MDB2LTQwelwiLFxuICByaWdodGhhcnBvb25kb3ducGx1czogXCJNMzk5NzQ3IDcwNWMwIDcuMyA2LjcgMTEgMjAgMTEgOCAwIDEzLS44XFxuIDE1LTIuNXM0LjctNi44IDgtMTUuNWM0MC05NCA5OS4zLTE2Ni4zIDE3OC0yMTcgMTMuMy04IDIwLjMtMTIuMyAyMS0xMyA1LjMtMy4zXFxuIDguNS01LjggOS41LTcuNSAxLTEuNyAxLjUtNS4yIDEuNS0xMC41cy0yLjMtMTAuMy03LTE1SDB2NDBoMzk5OTA4Yy0zNCAyNS4zXFxuLTY0LjcgNTctOTIgOTUtMjcuMyAzOC00OC43IDc3LjctNjQgMTE5LTMuMyA4LjctNSAxNC01IDE2ek0wIDQzNXY0MGgzOTk5MDB2LTQwelxcbm0wLTE5NHY0MGg0MDAwMDB2LTQwem0wIDB2NDBoNDAwMDAwdi00MHpcIixcbiAgcmlnaHRob29rOiBcIk0zOTk4NTkgMjQxYy03NjQgMCAwIDAgMCAwIDQwLTMuMyA2OC43LTE1LjcgODYtMzcgMTAtMTIgMTUtMjUuM1xcbiAxNS00MCAwLTIyLjctOS44LTQwLjctMjkuNS01NC0xOS43LTEzLjMtNDMuNS0yMS03MS41LTIzLTE3LjMtMS4zLTI2LTgtMjYtMjAgMFxcbi0xMy4zIDguNy0yMCAyNi0yMCAzOCAwIDcxIDExLjIgOTkgMzMuNSAwIDAgNyA1LjYgMjEgMTYuNyAxNCAxMS4yIDIxIDMzLjUgMjFcXG4gNjYuOHMtMTQgNjEuMi00MiA4My41Yy0yOCAyMi4zLTYxIDMzLjUtOTkgMzMuNUwwIDI0MXogTTAgMjgxdi00MGgzOTk4NTl2NDB6XCIsXG4gIHJpZ2h0bGluZXNlZ21lbnQ6IFwiTTM5OTk2MCAyNDEgVjk0IGg0MCBWNDI4IGgtNDAgVjI4MSBIMCB2LTQwelxcbk0zOTk5NjAgMjQxIFY5NCBoNDAgVjQyOCBoLTQwIFYyODEgSDAgdi00MHpcIixcbiAgcmlnaHRUb0Zyb206IFwiTTQwMDAwMCAxNjdjLTcwLjctNDItMTE4LTk3LjctMTQyLTE2N2gtMjNjLTE1LjMgMC0yMyAuMy0yM1xcbiAxIDAgMS4zIDUuMyAxMy43IDE2IDM3IDE4IDM1LjMgNDEuMyA2OSA3MCAxMDFsNyA4SDB2NDBoMzk5OTA1bC03IDhjLTI4LjcgMzJcXG4tNTIgNjUuNy03MCAxMDEtMTAuNyAyMy4zLTE2IDM1LjctMTYgMzcgMCAuNyA3LjcgMSAyMyAxaDIzYzI0LTY5LjMgNzEuMy0xMjUgMTQyXFxuLTE2N3ogTTEwMCAxNDd2NDBoMzk5OTAwdi00MHpNMCAzNDF2NDBoMzk5OTAwdi00MHpcIixcbiAgLy8gdHdvaGVhZGxlZnRhcnJvdyBpcyBmcm9tIGdseXBoIFUrMjE5RSBpbiBmb250IEthVGVYIEFNUyBSZWd1bGFyXG4gIHR3b2hlYWRsZWZ0YXJyb3c6IFwiTTAgMTY3YzY4IDQwXFxuIDExNS43IDk1LjcgMTQzIDE2N2gyMmMxNS4zIDAgMjMtLjMgMjMtMSAwLTEuMy01LjMtMTMuNy0xNi0zNy0xOC0zNS4zLTQxLjMtNjlcXG4tNzAtMTAxbC03LThoMTI1bDkgN2M1MC43IDM5LjMgODUgODYgMTAzIDE0MGg0NmMwLTQuNy02LjMtMTguNy0xOS00Mi0xOC0zNS4zXFxuLTQwLTY3LjMtNjYtOTZsLTktOWgzOTk3MTZ2LTQwSDI4NGw5LTljMjYtMjguNyA0OC02MC43IDY2LTk2IDEyLjctMjMuMzMzIDE5XFxuLTM3LjMzMyAxOS00MmgtNDZjLTE4IDU0LTUyLjMgMTAwLjctMTAzIDE0MGwtOSA3SDk1bDctOGMyOC43LTMyIDUyLTY1LjcgNzAtMTAxXFxuIDEwLjctMjMuMzMzIDE2LTM1LjcgMTYtMzcgMC0uNy03LjctMS0yMy0xaC0yMkMxMTUuNyA3MS4zIDY4IDEyNyAwIDE2N3pcIixcbiAgdHdvaGVhZHJpZ2h0YXJyb3c6IFwiTTQwMDAwMCAxNjdcXG5jLTY4LTQwLTExNS43LTk1LjctMTQzLTE2N2gtMjJjLTE1LjMgMC0yMyAuMy0yMyAxIDAgMS4zIDUuMyAxMy43IDE2IDM3IDE4IDM1LjNcXG4gNDEuMyA2OSA3MCAxMDFsNyA4aC0xMjVsLTktN2MtNTAuNy0zOS4zLTg1LTg2LTEwMy0xNDBoLTQ2YzAgNC43IDYuMyAxOC43IDE5IDQyXFxuIDE4IDM1LjMgNDAgNjcuMyA2NiA5Nmw5IDlIMHY0MGgzOTk3MTZsLTkgOWMtMjYgMjguNy00OCA2MC43LTY2IDk2LTEyLjcgMjMuMzMzXFxuLTE5IDM3LjMzMy0xOSA0Mmg0NmMxOC01NCA1Mi4zLTEwMC43IDEwMy0xNDBsOS03aDEyNWwtNyA4Yy0yOC43IDMyLTUyIDY1LjctNzBcXG4gMTAxLTEwLjcgMjMuMzMzLTE2IDM1LjctMTYgMzcgMCAuNyA3LjcgMSAyMyAxaDIyYzI3LjMtNzEuMyA3NS0xMjcgMTQzLTE2N3pcIixcbiAgLy8gdGlsZGUxIGlzIGEgbW9kaWZpZWQgdmVyc2lvbiBvZiBhIGdseXBoIGZyb20gdGhlIE1uU3ltYm9sIHBhY2thZ2VcbiAgdGlsZGUxOiBcIk0yMDAgNTUuNTM4Yy03NyAwLTE2OCA3My45NTMtMTc3IDczLjk1My0zIDAtN1xcbi0yLjE3NS05LTUuNDM3TDIgOTdjLTEtMi0yLTQtMi02IDAtNCAyLTcgNS05bDIwLTEyQzExNiAxMiAxNzEgMCAyMDcgMGM4NiAwXFxuIDExNCA2OCAxOTEgNjggNzggMCAxNjgtNjggMTc3LTY4IDQgMCA3IDIgOSA1bDEyIDE5YzEgMi4xNzUgMiA0LjM1IDIgNi41MjUgMFxcbiA0LjM1LTIgNy42MTMtNSA5Ljc4OGwtMTkgMTMuMDVjLTkyIDYzLjA3Ny0xMTYuOTM3IDc1LjMwOC0xODMgNzYuMTI4XFxuLTY4LjI2Ny44NDctMTEzLTczLjk1Mi0xOTEtNzMuOTUyelwiLFxuICAvLyBkaXR0byB0aWxkZTIsIHRpbGRlMywgJiB0aWxkZTRcbiAgdGlsZGUyOiBcIk0zNDQgNTUuMjY2Yy0xNDIgMC0zMDAuNjM4IDgxLjMxNi0zMTEuNSA4Ni40MThcXG4tOC4wMSAzLjc2Mi0yMi41IDEwLjkxLTIzLjUgNS41NjJMMSAxMjBjLTEtMi0xLTMtMS00IDAtNSAzLTkgOC0xMGwxOC40LTlDMTYwLjlcXG4gMzEuOSAyODMgMCAzNTggMGMxNDggMCAxODggMTIyIDMzMSAxMjJzMzE0LTk3IDMyNi05N2M0IDAgOCAyIDEwIDdsNyAyMS4xMTRcXG5jMSAyLjE0IDEgMy4yMSAxIDQuMjggMCA1LjM0Ny0zIDkuNjI2LTcgMTAuNjk2bC0yMi4zIDEyLjYyMkM4NTIuNiAxNTguMzcyIDc1MVxcbiAxODEuNDc2IDY3NiAxODEuNDc2Yy0xNDkgMC0xODktMTI2LjIxLTMzMi0xMjYuMjF6XCIsXG4gIHRpbGRlMzogXCJNNzg2IDU5QzQ1NyA1OSAzMiAxNzUuMjQyIDEzIDE3NS4yNDJjLTYgMC0xMC0zLjQ1N1xcbi0xMS0xMC4zN0wuMTUgMTM4Yy0xLTcgMy0xMiAxMC0xM2wxOS4yLTYuNEMzNzguNCA0MC43IDYzNC4zIDAgODA0LjMgMGMzMzcgMFxcbiA0MTEuOCAxNTcgNzQ2LjggMTU3IDMyOCAwIDc1NC0xMTIgNzczLTExMiA1IDAgMTAgMyAxMSA5bDEgMTQuMDc1YzEgOC4wNjYtLjY5N1xcbiAxNi41OTUtNi42OTcgMTcuNDkybC0yMS4wNTIgNy4zMWMtMzY3LjkgOTguMTQ2LTYwOS4xNSAxMjIuNjk2LTc3OC4xNSAxMjIuNjk2XFxuIC0zMzggMC00MDktMTU2LjU3My03NDQtMTU2LjU3M3pcIixcbiAgdGlsZGU0OiBcIk03ODYgNThDNDU3IDU4IDMyIDE3Ny40ODcgMTMgMTc3LjQ4N2MtNiAwLTEwLTMuMzQ1XFxuLTExLTEwLjAzNUwuMTUgMTQzYy0xLTcgMy0xMiAxMC0xM2wyMi02LjdDMzgxLjIgMzUgNjM3LjE1IDAgODA3LjE1IDBjMzM3IDAgNDA5XFxuIDE3NyA3NDQgMTc3IDMyOCAwIDc1NC0xMjcgNzczLTEyNyA1IDAgMTAgMyAxMSA5bDEgMTQuNzk0YzEgNy44MDUtMyAxMy4zOC05XFxuIDE0LjQ5NWwtMjAuNyA1LjU3NGMtMzY2Ljg1IDk5Ljc5LTYwNy4zIDEzOS4zNzItNzc2LjMgMTM5LjM3Mi0zMzggMC00MDlcXG4gLTE3NS4yMzYtNzQ0LTE3NS4yMzZ6XCIsXG4gIC8vIHZlYyBpcyBmcm9tIGdseXBoIFUrMjBENyBpbiBmb250IEthVGVYIE1haW5cbiAgdmVjOiBcIk0zNzcgMjBjMC01LjMzMyAxLjgzMy0xMCA1LjUtMTRTMzkxIDAgMzk3IDBjNC42NjcgMCA4LjY2NyAxLjY2NyAxMiA1XFxuMy4zMzMgMi42NjcgNi42NjcgOSAxMCAxOSA2LjY2NyAyNC42NjcgMjAuMzMzIDQzLjY2NyA0MSA1NyA3LjMzMyA0LjY2NyAxMVxcbjEwLjY2NyAxMSAxOCAwIDYtMSAxMC0zIDEycy02LjY2NyA1LTE0IDljLTI4LjY2NyAxNC42NjctNTMuNjY3IDM1LjY2Ny03NSA2M1xcbi0xLjMzMyAxLjMzMy0zLjE2NyAzLjUtNS41IDYuNXMtNCA0LjgzMy01IDUuNWMtMSAuNjY3LTIuNSAxLjMzMy00LjUgMnMtNC4zMzMgMVxcbi03IDFjLTQuNjY3IDAtOS4xNjctMS44MzMtMTMuNS01LjVTMzM3IDE4NCAzMzcgMTc4YzAtMTIuNjY3IDE1LjY2Ny0zMi4zMzMgNDctNTlcXG5IMjEzbC0xNzEtMWMtOC42NjctNi0xMy0xMi4zMzMtMTMtMTkgMC00LjY2NyA0LjMzMy0xMS4zMzMgMTMtMjBoMzU5XFxuYy0xNi0yNS4zMzMtMjQtNDUtMjQtNTl6XCIsXG4gIC8vIHdpZGVoYXQxIGlzIGEgbW9kaWZpZWQgdmVyc2lvbiBvZiBhIGdseXBoIGZyb20gdGhlIE1uU3ltYm9sIHBhY2thZ2VcbiAgd2lkZWhhdDE6IFwiTTUyOSAwaDVsNTE5IDExNWM1IDEgOSA1IDkgMTAgMCAxLTEgMi0xIDNsLTQgMjJcXG5jLTEgNS01IDktMTEgOWgtMkw1MzIgNjcgMTkgMTU5aC0yYy01IDAtOS00LTExLTlsLTUtMjJjLTEtNiAyLTEyIDgtMTN6XCIsXG4gIC8vIGRpdHRvIHdpZGVoYXQyLCB3aWRlaGF0MywgJiB3aWRlaGF0NFxuICB3aWRlaGF0MjogXCJNMTE4MSAwaDJsMTE3MSAxNzZjNiAwIDEwIDUgMTAgMTFsLTIgMjNjLTEgNi01IDEwXFxuLTExIDEwaC0xTDExODIgNjcgMTUgMjIwaC0xYy02IDAtMTAtNC0xMS0xMGwtMi0yM2MtMS02IDQtMTEgMTAtMTF6XCIsXG4gIHdpZGVoYXQzOiBcIk0xMTgxIDBoMmwxMTcxIDIzNmM2IDAgMTAgNSAxMCAxMWwtMiAyM2MtMSA2LTUgMTBcXG4tMTEgMTBoLTFMMTE4MiA2NyAxNSAyODBoLTFjLTYgMC0xMC00LTExLTEwbC0yLTIzYy0xLTYgNC0xMSAxMC0xMXpcIixcbiAgd2lkZWhhdDQ6IFwiTTExODEgMGgybDExNzEgMjk2YzYgMCAxMCA1IDEwIDExbC0yIDIzYy0xIDYtNSAxMFxcbi0xMSAxMGgtMUwxMTgyIDY3IDE1IDM0MGgtMWMtNiAwLTEwLTQtMTEtMTBsLTItMjNjLTEtNiA0LTExIDEwLTExelwiLFxuICAvLyB3aWRlY2hlY2sgcGF0aHMgYXJlIGFsbCBpbnZlcnRlZCB2ZXJzaW9ucyBvZiB3aWRlaGF0XG4gIHdpZGVjaGVjazE6IFwiTTUyOSwxNTloNWw1MTksLTExNWM1LC0xLDksLTUsOSwtMTBjMCwtMSwtMSwtMiwtMSwtM2wtNCwtMjJjLTEsXFxuLTUsLTUsLTksLTExLC05aC0ybC01MTIsOTJsLTUxMywtOTJoLTJjLTUsMCwtOSw0LC0xMSw5bC01LDIyYy0xLDYsMiwxMiw4LDEzelwiLFxuICB3aWRlY2hlY2syOiBcIk0xMTgxLDIyMGgybDExNzEsLTE3NmM2LDAsMTAsLTUsMTAsLTExbC0yLC0yM2MtMSwtNiwtNSwtMTAsXFxuLTExLC0xMGgtMWwtMTE2OCwxNTNsLTExNjcsLTE1M2gtMWMtNiwwLC0xMCw0LC0xMSwxMGwtMiwyM2MtMSw2LDQsMTEsMTAsMTF6XCIsXG4gIHdpZGVjaGVjazM6IFwiTTExODEsMjgwaDJsMTE3MSwtMjM2YzYsMCwxMCwtNSwxMCwtMTFsLTIsLTIzYy0xLC02LC01LC0xMCxcXG4tMTEsLTEwaC0xbC0xMTY4LDIxM2wtMTE2NywtMjEzaC0xYy02LDAsLTEwLDQsLTExLDEwbC0yLDIzYy0xLDYsNCwxMSwxMCwxMXpcIixcbiAgd2lkZWNoZWNrNDogXCJNMTE4MSwzNDBoMmwxMTcxLC0yOTZjNiwwLDEwLC01LDEwLC0xMWwtMiwtMjNjLTEsLTYsLTUsLTEwLFxcbi0xMSwtMTBoLTFsLTExNjgsMjczbC0xMTY3LC0yNzNoLTFjLTYsMCwtMTAsNCwtMTEsMTBsLTIsMjNjLTEsNiw0LDExLDEwLDExelwiLFxuICAvLyBUaGUgbmV4dCB0ZW4gcGF0aHMgc3VwcG9ydCByZWFjdGlvbiBhcnJvd3MgZnJvbSB0aGUgbWhjaGVtIHBhY2thZ2UuXG4gIC8vIEFycm93cyBmb3IgXFxjZXs8LS0+fSBhcmUgb2Zmc2V0IGZyb20geEF4aXMgYnkgMC4yMmV4LCBwZXIgbWhjaGVtIGluIExhVGVYXG4gIC8vIGJhcmFib3ZlbGVmdGFycm93IGlzIG1vc3RseSBmcm9tIGdseXBoIFUrMjE5MCBpbiBmb250IEthVGVYIE1haW5cbiAgYmFyYWJvdmVsZWZ0YXJyb3c6IFwiTTQwMDAwMCA2MjBoLTM5OTg5MGwzIC0zYzY4LjcgLTUyLjcgMTEzLjcgLTEyMCAxMzUgLTIwMlxcbmM0IC0xNC43IDYgLTIzIDYgLTI1YzAgLTcuMyAtNyAtMTEgLTIxIC0xMWMtOCAwIC0xMy4yIDAuOCAtMTUuNSAyLjVcXG5jLTIuMyAxLjcgLTQuMiA1LjggLTUuNSAxMi41Yy0xLjMgNC43IC0yLjcgMTAuMyAtNCAxN2MtMTIgNDguNyAtMzQuOCA5MiAtNjguNSAxMzBcXG5zLTc0LjIgNjYuMyAtMTIxLjUgODVjLTEwIDQgLTE2IDcuNyAtMTggMTFjMCA4LjcgNiAxNC4zIDE4IDE3YzQ3LjMgMTguNyA4Ny44IDQ3XFxuMTIxLjUgODVzNTYuNSA4MS4zIDY4LjUgMTMwYzAuNyAyIDEuMyA1IDIgOXMxLjIgNi43IDEuNSA4YzAuMyAxLjMgMSAzLjMgMiA2XFxuczIuMiA0LjUgMy41IDUuNWMxLjMgMSAzLjMgMS44IDYgMi41czYgMSAxMCAxYzE0IDAgMjEgLTMuNyAyMSAtMTFcXG5jMCAtMiAtMiAtMTAuMyAtNiAtMjVjLTIwIC03OS4zIC02NSAtMTQ2LjcgLTEzNSAtMjAybC0zIC0zaDM5OTg5MHpcXG5NMTAwIDYyMHY0MGgzOTk5MDB2LTQweiBNMCAyNDF2NDBoMzk5OTAwdi00MHpNMCAyNDF2NDBoMzk5OTAwdi00MHpcIixcbiAgLy8gcmlnaHRhcnJvd2Fib3ZlYmFyIGlzIG1vc3RseSBmcm9tIGdseXBoIFUrMjE5MiwgS2FUZVggTWFpblxuICByaWdodGFycm93YWJvdmViYXI6IFwiTTAgMjQxdjQwaDM5OTg5MWMtNDcuMyAzNS4zLTg0IDc4LTExMCAxMjgtMTYuNyAzMlxcbi0yNy43IDYzLjctMzMgOTUgMCAxLjMtLjIgMi43LS41IDQtLjMgMS4zLS41IDIuMy0uNSAzIDAgNy4zIDYuNyAxMSAyMCAxMSA4IDBcXG4xMy4yLS44IDE1LjUtMi41IDIuMy0xLjcgNC4yLTUuNSA1LjUtMTEuNSAyLTEzLjMgNS43LTI3IDExLTQxIDE0LjctNDQuNyAzOVxcbi04NC41IDczLTExOS41czczLjctNjAuMiAxMTktNzUuNWM2LTIgOS01LjcgOS0xMXMtMy05LTktMTFjLTQ1LjMtMTUuMy04NS00MC41XFxuLTExOS03NS41cy01OC4zLTc0LjgtNzMtMTE5LjVjLTQuNy0xNC04LjMtMjcuMy0xMS00MC0xLjMtNi43LTMuMi0xMC44LTUuNVxcbi0xMi41LTIuMy0xLjctNy41LTIuNS0xNS41LTIuNS0xNCAwLTIxIDMuNy0yMSAxMSAwIDIgMiAxMC4zIDYgMjUgMjAuNyA4My4zIDY3XFxuMTUxLjcgMTM5IDIwNXptOTYgMzc5aDM5OTg5NHY0MEgwem0wIDBoMzk5OTA0djQwSDB6XCIsXG4gIC8vIFRoZSBzaG9ydCBsZWZ0IGhhcnBvb24gaGFzIDAuNWVtIChpLmUuIDUwMCB1bml0cykga2VybiBvbiB0aGUgbGVmdCBlbmQuXG4gIC8vIFJlZiBmcm9tIG1oY2hlbS5zdHk6IFxccmxhcHtcXHJhaXNlYm94ey0uMjJleH17JFxca2VybjAuNWVtXG4gIGJhcmFib3Zlc2hvcnRsZWZ0aGFycG9vbjogXCJNNTA3LDQzNWMtNCw0LC02LjMsOC43LC03LDE0YzAsNS4zLDAuNyw5LDIsMTFcXG5jMS4zLDIsNS4zLDUuMywxMiwxMGM5MC43LDU0LDE1NiwxMzAsMTk2LDIyOGMzLjMsMTAuNyw2LjMsMTYuMyw5LDE3XFxuYzIsMC43LDUsMSw5LDFjMCwwLDUsMCw1LDBjMTAuNywwLDE2LjcsLTIsMTgsLTZjMiwtMi43LDEsLTkuNywtMywtMjFcXG5jLTMyLC04Ny4zLC04Mi43LC0xNTcuNywtMTUyLC0yMTFjMCwwLC0zLC0zLC0zLC0zbDM5OTM1MSwwbDAsLTQwXFxuYy0zOTg1NzAsMCwtMzk5NDM3LDAsLTM5OTQzNywweiBNNTkzIDQzNSB2NDAgSDM5OTUwMCB2LTQwelxcbk0wIDI4MSB2LTQwIEgzOTk5MDggdjQweiBNMCAyODEgdi00MCBIMzk5OTA4IHY0MHpcIixcbiAgcmlnaHRoYXJwb29uYWJvdmVzaG9ydGJhcjogXCJNMCwyNDEgbDAsNDBjMzk5MTI2LDAsMzk5OTkzLDAsMzk5OTkzLDBcXG5jNC43LC00LjcsNywtOS4zLDcsLTE0YzAsLTkuMywtMy43LC0xNS4zLC0xMSwtMThjLTkyLjcsLTU2LjcsLTE1OSwtMTMzLjcsLTE5OSxcXG4tMjMxYy0zLjMsLTkuMywtNiwtMTQuNywtOCwtMTZjLTIsLTEuMywtNywtMiwtMTUsLTJjLTEwLjcsMCwtMTYuNywyLC0xOCw2XFxuYy0yLDIuNywtMSw5LjcsMywyMWMxNS4zLDQyLDM2LjcsODEuOCw2NCwxMTkuNWMyNy4zLDM3LjcsNTgsNjkuMiw5Miw5NC41elxcbk0wIDI0MSB2NDAgSDM5OTkwOCB2LTQweiBNMCA0NzUgdi00MCBIMzk5NTAwIHY0MHogTTAgNDc1IHYtNDAgSDM5OTUwMCB2NDB6XCIsXG4gIHNob3J0YmFyYWJvdmVsZWZ0aGFycG9vbjogXCJNNyw0MzVjLTQsNCwtNi4zLDguNywtNywxNGMwLDUuMywwLjcsOSwyLDExXFxuYzEuMywyLDUuMyw1LjMsMTIsMTBjOTAuNyw1NCwxNTYsMTMwLDE5NiwyMjhjMy4zLDEwLjcsNi4zLDE2LjMsOSwxN2MyLDAuNyw1LDEsOSxcXG4xYzAsMCw1LDAsNSwwYzEwLjcsMCwxNi43LC0yLDE4LC02YzIsLTIuNywxLC05LjcsLTMsLTIxYy0zMiwtODcuMywtODIuNywtMTU3LjcsXFxuLTE1MiwtMjExYzAsMCwtMywtMywtMywtM2wzOTk5MDcsMGwwLC00MGMtMzk5MTI2LDAsLTM5OTk5MywwLC0zOTk5OTMsMHpcXG5NOTMgNDM1IHY0MCBINDAwMDAwIHYtNDB6IE01MDAgMjQxIHY0MCBINDAwMDAwIHYtNDB6IE01MDAgMjQxIHY0MCBINDAwMDAwIHYtNDB6XCIsXG4gIHNob3J0cmlnaHRoYXJwb29uYWJvdmViYXI6IFwiTTUzLDI0MWwwLDQwYzM5ODU3MCwwLDM5OTQzNywwLDM5OTQzNywwXFxuYzQuNywtNC43LDcsLTkuMyw3LC0xNGMwLC05LjMsLTMuNywtMTUuMywtMTEsLTE4Yy05Mi43LC01Ni43LC0xNTksLTEzMy43LC0xOTksXFxuLTIzMWMtMy4zLC05LjMsLTYsLTE0LjcsLTgsLTE2Yy0yLC0xLjMsLTcsLTIsLTE1LC0yYy0xMC43LDAsLTE2LjcsMiwtMTgsNlxcbmMtMiwyLjcsLTEsOS43LDMsMjFjMTUuMyw0MiwzNi43LDgxLjgsNjQsMTE5LjVjMjcuMywzNy43LDU4LDY5LjIsOTIsOTQuNXpcXG5NNTAwIDI0MSB2NDAgSDM5OTQwOCB2LTQweiBNNTAwIDQzNSB2NDAgSDQwMDAwMCB2LTQwelwiXG59O1xuY29uc3QgdGFsbERlbGltID0gZnVuY3Rpb24gKGxhYmVsLCBtaWRIZWlnaHQpIHtcbiAgc3dpdGNoIChsYWJlbCkge1xuICAgIGNhc2UgXCJsYnJhY2tcIjpcbiAgICAgIHJldHVybiBcIk00MDMgMTc1OSBWODQgSDY2NiBWMCBIMzE5IFYxNzU5IHZcIiArIG1pZEhlaWdodCArIFwiIHYxNzU5IGgzNDcgdi04NFxcbkg0MDN6IE00MDMgMTc1OSBWMCBIMzE5IFYxNzU5IHZcIiArIG1pZEhlaWdodCArIFwiIHYxNzU5IGg4NHpcIjtcblxuICAgIGNhc2UgXCJyYnJhY2tcIjpcbiAgICAgIHJldHVybiBcIk0zNDcgMTc1OSBWMCBIMCBWODQgSDI2MyBWMTc1OSB2XCIgKyBtaWRIZWlnaHQgKyBcIiB2MTc1OSBIMCB2ODQgSDM0N3pcXG5NMzQ3IDE3NTkgVjAgSDI2MyBWMTc1OSB2XCIgKyBtaWRIZWlnaHQgKyBcIiB2MTc1OSBoODR6XCI7XG5cbiAgICBjYXNlIFwidmVydFwiOlxuICAgICAgcmV0dXJuIFwiTTE0NSAxNSB2NTg1IHZcIiArIG1pZEhlaWdodCArIFwiIHY1ODUgYzIuNjY3LDEwLDkuNjY3LDE1LDIxLDE1XFxuYzEwLDAsMTYuNjY3LC01LDIwLC0xNSB2LTU4NSB2XCIgKyAtbWlkSGVpZ2h0ICsgXCIgdi01ODUgYy0yLjY2NywtMTAsLTkuNjY3LC0xNSwtMjEsLTE1XFxuYy0xMCwwLC0xNi42NjcsNSwtMjAsMTV6IE0xODggMTUgSDE0NSB2NTg1IHZcIiArIG1pZEhlaWdodCArIFwiIHY1ODUgaDQzelwiO1xuXG4gICAgY2FzZSBcImRvdWJsZXZlcnRcIjpcbiAgICAgIHJldHVybiBcIk0xNDUgMTUgdjU4NSB2XCIgKyBtaWRIZWlnaHQgKyBcIiB2NTg1IGMyLjY2NywxMCw5LjY2NywxNSwyMSwxNVxcbmMxMCwwLDE2LjY2NywtNSwyMCwtMTUgdi01ODUgdlwiICsgLW1pZEhlaWdodCArIFwiIHYtNTg1IGMtMi42NjcsLTEwLC05LjY2NywtMTUsLTIxLC0xNVxcbmMtMTAsMCwtMTYuNjY3LDUsLTIwLDE1eiBNMTg4IDE1IEgxNDUgdjU4NSB2XCIgKyBtaWRIZWlnaHQgKyBcIiB2NTg1IGg0M3pcXG5NMzY3IDE1IHY1ODUgdlwiICsgbWlkSGVpZ2h0ICsgXCIgdjU4NSBjMi42NjcsMTAsOS42NjcsMTUsMjEsMTVcXG5jMTAsMCwxNi42NjcsLTUsMjAsLTE1IHYtNTg1IHZcIiArIC1taWRIZWlnaHQgKyBcIiB2LTU4NSBjLTIuNjY3LC0xMCwtOS42NjcsLTE1LC0yMSwtMTVcXG5jLTEwLDAsLTE2LjY2Nyw1LC0yMCwxNXogTTQxMCAxNSBIMzY3IHY1ODUgdlwiICsgbWlkSGVpZ2h0ICsgXCIgdjU4NSBoNDN6XCI7XG5cbiAgICBjYXNlIFwibGZsb29yXCI6XG4gICAgICByZXR1cm4gXCJNMzE5IDYwMiBWMCBINDAzIFY2MDIgdlwiICsgbWlkSGVpZ2h0ICsgXCIgdjE3MTUgaDI2MyB2ODQgSDMxOXpcXG5NTTMxOSA2MDIgVjAgSDQwMyBWNjAyIHZcIiArIG1pZEhlaWdodCArIFwiIHYxNzE1IEgzMTl6XCI7XG5cbiAgICBjYXNlIFwicmZsb29yXCI6XG4gICAgICByZXR1cm4gXCJNMzE5IDYwMiBWMCBINDAzIFY2MDIgdlwiICsgbWlkSGVpZ2h0ICsgXCIgdjE3OTkgSDAgdi04NCBIMzE5elxcbk1NMzE5IDYwMiBWMCBINDAzIFY2MDIgdlwiICsgbWlkSGVpZ2h0ICsgXCIgdjE3MTUgSDMxOXpcIjtcblxuICAgIGNhc2UgXCJsY2VpbFwiOlxuICAgICAgcmV0dXJuIFwiTTQwMyAxNzU5IFY4NCBINjY2IFYwIEgzMTkgVjE3NTkgdlwiICsgbWlkSGVpZ2h0ICsgXCIgdjYwMiBoODR6XFxuTTQwMyAxNzU5IFYwIEgzMTkgVjE3NTkgdlwiICsgbWlkSGVpZ2h0ICsgXCIgdjYwMiBoODR6XCI7XG5cbiAgICBjYXNlIFwicmNlaWxcIjpcbiAgICAgIHJldHVybiBcIk0zNDcgMTc1OSBWMCBIMCBWODQgSDI2MyBWMTc1OSB2XCIgKyBtaWRIZWlnaHQgKyBcIiB2NjAyIGg4NHpcXG5NMzQ3IDE3NTkgVjAgaC04NCBWMTc1OSB2XCIgKyBtaWRIZWlnaHQgKyBcIiB2NjAyIGg4NHpcIjtcblxuICAgIGNhc2UgXCJscGFyZW5cIjpcbiAgICAgIHJldHVybiBcIk04NjMsOWMwLC0yLC0yLC01LC02LC05YzAsMCwtMTcsMCwtMTcsMGMtMTIuNywwLC0xOS4zLDAuMywtMjAsMVxcbmMtNS4zLDUuMywtMTAuMywxMSwtMTUsMTdjLTI0Mi43LDI5NC43LC0zOTUuMyw2ODIsLTQ1OCwxMTYyYy0yMS4zLDE2My4zLC0zMy4zLDM0OSxcXG4tMzYsNTU3IGwwLFwiICsgKG1pZEhlaWdodCArIDg0KSArIFwiYzAuMiw2LDAsMjYsMCw2MGMyLDE1OS4zLDEwLDMxMC43LDI0LDQ1NGM1My4zLDUyOCwyMTAsXFxuOTQ5LjcsNDcwLDEyNjVjNC43LDYsOS43LDExLjcsMTUsMTdjMC43LDAuNyw3LDEsMTksMWMwLDAsMTgsMCwxOCwwYzQsLTQsNiwtNyw2LC05XFxuYzAsLTIuNywtMy4zLC04LjcsLTEwLC0xOGMtMTM1LjMsLTE5Mi43LC0yMzUuNSwtNDE0LjMsLTMwMC41LC02NjVjLTY1LC0yNTAuNywtMTAyLjUsXFxuLTU0NC43LC0xMTIuNSwtODgyYy0yLC0xMDQsLTMsLTE2NywtMywtMTg5XFxubDAsLVwiICsgKG1pZEhlaWdodCArIDkyKSArIFwiYzAsLTE2Mi43LDUuNywtMzE0LDE3LC00NTRjMjAuNywtMjcyLDYzLjcsLTUxMywxMjksLTcyM2M2NS4zLFxcbi0yMTAsMTU1LjMsLTM5Ni4zLDI3MCwtNTU5YzYuNywtOS4zLDEwLC0xNS4zLDEwLC0xOHpcIjtcblxuICAgIGNhc2UgXCJycGFyZW5cIjpcbiAgICAgIHJldHVybiBcIk03NiwwYy0xNi43LDAsLTI1LDMsLTI1LDljMCwyLDIsNi4zLDYsMTNjMjEuMywyOC43LDQyLjMsNjAuMyxcXG42Myw5NWM5Ni43LDE1Ni43LDE3Mi44LDMzMi41LDIyOC41LDUyNy41YzU1LjcsMTk1LDkyLjgsNDE2LjUsMTExLjUsNjY0LjVcXG5jMTEuMywxMzkuMywxNywyOTAuNywxNyw0NTRjMCwyOCwxLjcsNDMsMy4zLDQ1bDAsXCIgKyAobWlkSGVpZ2h0ICsgOSkgKyBcIlxcbmMtMyw0LC0zLjMsMTYuNywtMy4zLDM4YzAsMTYyLC01LjcsMzEzLjcsLTE3LDQ1NWMtMTguNywyNDgsLTU1LjgsNDY5LjMsLTExMS41LDY2NFxcbmMtNTUuNywxOTQuNywtMTMxLjgsMzcwLjMsLTIyOC41LDUyN2MtMjAuNywzNC43LC00MS43LDY2LjMsLTYzLDk1Yy0yLDMuMywtNCw3LC02LDExXFxuYzAsNy4zLDUuNywxMSwxNywxMWMwLDAsMTEsMCwxMSwwYzkuMywwLDE0LjMsLTAuMywxNSwtMWM1LjMsLTUuMywxMC4zLC0xMSwxNSwtMTdcXG5jMjQyLjcsLTI5NC43LDM5NS4zLC02ODEuNyw0NTgsLTExNjFjMjEuMywtMTY0LjcsMzMuMywtMzUwLjcsMzYsLTU1OFxcbmwwLC1cIiArIChtaWRIZWlnaHQgKyAxNDQpICsgXCJjLTIsLTE1OS4zLC0xMCwtMzEwLjcsLTI0LC00NTRjLTUzLjMsLTUyOCwtMjEwLC05NDkuNyxcXG4tNDcwLC0xMjY1Yy00LjcsLTYsLTkuNywtMTEuNywtMTUsLTE3Yy0wLjcsLTAuNywtNi43LC0xLC0xOCwtMXpcIjtcblxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBXZSBzaG91bGQgbm90IGV2ZXIgZ2V0IGhlcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHN0cmV0Y2h5IGRlbGltaXRlci5cIik7XG4gIH1cbn07XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdHJlZS5qc1xuXG5cbi8qKlxuICogVGhpcyBub2RlIHJlcHJlc2VudHMgYSBkb2N1bWVudCBmcmFnbWVudCwgd2hpY2ggY29udGFpbnMgZWxlbWVudHMsIGJ1dCB3aGVuXG4gKiBwbGFjZWQgaW50byB0aGUgRE9NIGRvZXNuJ3QgaGF2ZSBhbnkgcmVwcmVzZW50YXRpb24gaXRzZWxmLiBJdCBvbmx5IGNvbnRhaW5zXG4gKiBjaGlsZHJlbiBhbmQgZG9lc24ndCBoYXZlIGFueSBET00gbm9kZSBwcm9wZXJ0aWVzLlxuICovXG5jbGFzcyBEb2N1bWVudEZyYWdtZW50IHtcbiAgLy8gSHRtbERvbU5vZGVcbiAgLy8gTmV2ZXIgdXNlZDsgbmVlZGVkIGZvciBzYXRpc2Z5aW5nIGludGVyZmFjZS5cbiAgY29uc3RydWN0b3IoY2hpbGRyZW4pIHtcbiAgICB0aGlzLmNoaWxkcmVuID0gdm9pZCAwO1xuICAgIHRoaXMuY2xhc3NlcyA9IHZvaWQgMDtcbiAgICB0aGlzLmhlaWdodCA9IHZvaWQgMDtcbiAgICB0aGlzLmRlcHRoID0gdm9pZCAwO1xuICAgIHRoaXMubWF4Rm9udFNpemUgPSB2b2lkIDA7XG4gICAgdGhpcy5zdHlsZSA9IHZvaWQgMDtcbiAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgdGhpcy5jbGFzc2VzID0gW107XG4gICAgdGhpcy5oZWlnaHQgPSAwO1xuICAgIHRoaXMuZGVwdGggPSAwO1xuICAgIHRoaXMubWF4Rm9udFNpemUgPSAwO1xuICAgIHRoaXMuc3R5bGUgPSB7fTtcbiAgfVxuXG4gIGhhc0NsYXNzKGNsYXNzTmFtZSkge1xuICAgIHJldHVybiB1dGlscy5jb250YWlucyh0aGlzLmNsYXNzZXMsIGNsYXNzTmFtZSk7XG4gIH1cbiAgLyoqIENvbnZlcnQgdGhlIGZyYWdtZW50IGludG8gYSBub2RlLiAqL1xuXG5cbiAgdG9Ob2RlKCkge1xuICAgIGNvbnN0IGZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZyYWcuYXBwZW5kQ2hpbGQodGhpcy5jaGlsZHJlbltpXS50b05vZGUoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZyYWc7XG4gIH1cbiAgLyoqIENvbnZlcnQgdGhlIGZyYWdtZW50IGludG8gSFRNTCBtYXJrdXAuICovXG5cblxuICB0b01hcmt1cCgpIHtcbiAgICBsZXQgbWFya3VwID0gXCJcIjsgLy8gU2ltcGx5IGNvbmNhdGVuYXRlIHRoZSBtYXJrdXAgZm9yIHRoZSBjaGlsZHJlbiB0b2dldGhlci5cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgbWFya3VwICs9IHRoaXMuY2hpbGRyZW5baV0udG9NYXJrdXAoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFya3VwO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgbWF0aCBub2RlIGludG8gYSBzdHJpbmcsIHNpbWlsYXIgdG8gaW5uZXJUZXh0LiBBcHBsaWVzIHRvXG4gICAqIE1hdGhEb21Ob2RlJ3Mgb25seS5cbiAgICovXG5cblxuICB0b1RleHQoKSB7XG4gICAgLy8gVG8gYXZvaWQgdGhpcywgd2Ugd291bGQgc3ViY2xhc3MgZG9jdW1lbnRGcmFnbWVudCBzZXBhcmF0ZWx5IGZvclxuICAgIC8vIE1hdGhNTCwgYnV0IHBvbHlmaWxscyBmb3Igc3ViY2xhc3NpbmcgaXMgZXhwZW5zaXZlIHBlciBQUiAxNDY5LlxuICAgIC8vICRGbG93Rml4TWU6IE9ubHkgd29ya3MgZm9yIENoaWxkVHlwZSA9IE1hdGhEb21Ob2RlLlxuICAgIGNvbnN0IHRvVGV4dCA9IGNoaWxkID0+IGNoaWxkLnRvVGV4dCgpO1xuXG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4ubWFwKHRvVGV4dCkuam9pbihcIlwiKTtcbiAgfVxuXG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZm9udE1ldHJpY3NEYXRhLmpzXG4vLyBUaGlzIGZpbGUgaXMgR0VORVJBVEVEIGJ5IGJ1aWxkTWV0cmljcy5zaC4gRE8gTk9UIE1PRElGWS5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGZvbnRNZXRyaWNzRGF0YSA9ICh7XG4gIFwiQU1TLVJlZ3VsYXJcIjoge1xuICAgIFwiMzJcIjogWzAsIDAsIDAsIDAsIDAuMjVdLFxuICAgIFwiNjVcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiNjZcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiNjdcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiNjhcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiNjlcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiNzBcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNjExMTFdLFxuICAgIFwiNzFcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiNzJcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiNzNcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuMzg4ODldLFxuICAgIFwiNzRcIjogWzAuMTY2NjcsIDAuNjg4ODksIDAsIDAsIDAuNV0sXG4gICAgXCI3NVwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI3NlwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI3N1wiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC45NDQ0NV0sXG4gICAgXCI3OFwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI3OVwiOiBbMC4xNjY2NywgMC42ODg4OSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4MFwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC42MTExMV0sXG4gICAgXCI4MVwiOiBbMC4xNjY2NywgMC42ODg4OSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4MlwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI4M1wiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC41NTU1Nl0sXG4gICAgXCI4NFwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI4NVwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI4NlwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI4N1wiOiBbMCwgMC42ODg4OSwgMCwgMCwgMS4wXSxcbiAgICBcIjg4XCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjg5XCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjkwXCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjEwN1wiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC41NTU1Nl0sXG4gICAgXCIxNjBcIjogWzAsIDAsIDAsIDAsIDAuMjVdLFxuICAgIFwiMTY1XCI6IFswLCAwLjY3NSwgMC4wMjUsIDAsIDAuNzVdLFxuICAgIFwiMTc0XCI6IFswLjE1NTU5LCAwLjY5MjI0LCAwLCAwLCAwLjk0NjY2XSxcbiAgICBcIjI0MFwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC41NTU1Nl0sXG4gICAgXCIyOTVcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNTQwMjhdLFxuICAgIFwiNzEwXCI6IFswLCAwLjgyNSwgMCwgMCwgMi4zMzMzNF0sXG4gICAgXCI3MzJcIjogWzAsIDAuOSwgMCwgMCwgMi4zMzMzNF0sXG4gICAgXCI3NzBcIjogWzAsIDAuODI1LCAwLCAwLCAyLjMzMzM0XSxcbiAgICBcIjc3MVwiOiBbMCwgMC45LCAwLCAwLCAyLjMzMzM0XSxcbiAgICBcIjk4OVwiOiBbMC4wODE2NywgMC41ODE2NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIxMDA4XCI6IFswLCAwLjQzMDU2LCAwLjA0MDI4LCAwLCAwLjY2NjY3XSxcbiAgICBcIjgyNDVcIjogWzAsIDAuNTQ5ODYsIDAsIDAsIDAuMjc1XSxcbiAgICBcIjg0NjNcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNTQwMjhdLFxuICAgIFwiODQ4N1wiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI4NDk4XCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjU1NTU2XSxcbiAgICBcIjg1MDJcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiODUwM1wiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC40NDQ0NV0sXG4gICAgXCI4NTA0XCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjg1MTNcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNjM4ODldLFxuICAgIFwiODU5MlwiOiBbLTAuMDM1OTgsIDAuNDY0MDIsIDAsIDAsIDAuNV0sXG4gICAgXCI4NTk0XCI6IFstMC4wMzU5OCwgMC40NjQwMiwgMCwgMCwgMC41XSxcbiAgICBcIjg2MDJcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwLCAxLjBdLFxuICAgIFwiODYwM1wiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjA2XCI6IFswLjAxMzU0LCAwLjUyMjM5LCAwLCAwLCAxLjBdLFxuICAgIFwiODYwOFwiOiBbMC4wMTM1NCwgMC41MjIzOSwgMCwgMCwgMS4wXSxcbiAgICBcIjg2MTBcIjogWzAuMDEzNTQsIDAuNTIyMzksIDAsIDAsIDEuMTExMTFdLFxuICAgIFwiODYxMVwiOiBbMC4wMTM1NCwgMC41MjIzOSwgMCwgMCwgMS4xMTExMV0sXG4gICAgXCI4NjE5XCI6IFswLCAwLjU0OTg2LCAwLCAwLCAxLjBdLFxuICAgIFwiODYyMFwiOiBbMCwgMC41NDk4NiwgMCwgMCwgMS4wXSxcbiAgICBcIjg2MjFcIjogWy0wLjEzMzEzLCAwLjM3Nzg4LCAwLCAwLCAxLjM4ODg5XSxcbiAgICBcIjg2MjJcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwLCAxLjBdLFxuICAgIFwiODYyNFwiOiBbMCwgMC42OTIyNCwgMCwgMCwgMC41XSxcbiAgICBcIjg2MjVcIjogWzAsIDAuNjkyMjQsIDAsIDAsIDAuNV0sXG4gICAgXCI4NjMwXCI6IFswLCAwLjQzMDU2LCAwLCAwLCAxLjBdLFxuICAgIFwiODYzMVwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMS4wXSxcbiAgICBcIjg2MzRcIjogWzAuMDgxOTgsIDAuNTgxOTgsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODYzNVwiOiBbMC4wODE5OCwgMC41ODE5OCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4NjM4XCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwLCAwLjQxNjY3XSxcbiAgICBcIjg2MzlcIjogWzAuMTk0NDQsIDAuNjkyMjQsIDAsIDAsIDAuNDE2NjddLFxuICAgIFwiODY0MlwiOiBbMC4xOTQ0NCwgMC42OTIyNCwgMCwgMCwgMC40MTY2N10sXG4gICAgXCI4NjQzXCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwLCAwLjQxNjY3XSxcbiAgICBcIjg2NDRcIjogWzAuMTgwOCwgMC42NzUsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjQ2XCI6IFswLjE4MDgsIDAuNjc1LCAwLCAwLCAxLjBdLFxuICAgIFwiODY0N1wiOiBbMC4xODA4LCAwLjY3NSwgMCwgMCwgMS4wXSxcbiAgICBcIjg2NDhcIjogWzAuMTk0NDQsIDAuNjkyMjQsIDAsIDAsIDAuODMzMzRdLFxuICAgIFwiODY0OVwiOiBbMC4xODA4LCAwLjY3NSwgMCwgMCwgMS4wXSxcbiAgICBcIjg2NTBcIjogWzAuMTk0NDQsIDAuNjkyMjQsIDAsIDAsIDAuODMzMzRdLFxuICAgIFwiODY1MVwiOiBbMC4wMTM1NCwgMC41MjIzOSwgMCwgMCwgMS4wXSxcbiAgICBcIjg2NTJcIjogWzAuMDEzNTQsIDAuNTIyMzksIDAsIDAsIDEuMF0sXG4gICAgXCI4NjUzXCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMCwgMS4wXSxcbiAgICBcIjg2NTRcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwLCAxLjBdLFxuICAgIFwiODY1NVwiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjY2XCI6IFswLjEzNjY3LCAwLjYzNjY3LCAwLCAwLCAxLjBdLFxuICAgIFwiODY2N1wiOiBbMC4xMzY2NywgMC42MzY2NywgMCwgMCwgMS4wXSxcbiAgICBcIjg2NjlcIjogWy0wLjEzMzEzLCAwLjM3Nzg4LCAwLCAwLCAxLjBdLFxuICAgIFwiODY3MlwiOiBbLTAuMDY0LCAwLjQzNywgMCwgMCwgMS4zMzRdLFxuICAgIFwiODY3NFwiOiBbLTAuMDY0LCAwLjQzNywgMCwgMCwgMS4zMzRdLFxuICAgIFwiODcwNVwiOiBbMCwgMC44MjUsIDAsIDAsIDAuNV0sXG4gICAgXCI4NzA4XCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjU1NTU2XSxcbiAgICBcIjg3MDlcIjogWzAuMDgxNjcsIDAuNTgxNjcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODcxN1wiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC40MjkxN10sXG4gICAgXCI4NzIyXCI6IFstMC4wMzU5OCwgMC40NjQwMiwgMCwgMCwgMC41XSxcbiAgICBcIjg3MjRcIjogWzAuMDgxOTgsIDAuNjkyMjQsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODcyNlwiOiBbMC4wODE2NywgMC41ODE2NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4NzMzXCI6IFswLCAwLjY5MjI0LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg3MzZcIjogWzAsIDAuNjkyMjQsIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiODczN1wiOiBbMCwgMC42OTIyNCwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI4NzM4XCI6IFswLjAzNTE3LCAwLjUyMjM5LCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjg3MzlcIjogWzAuMDgxNjcsIDAuNTgxNjcsIDAsIDAsIDAuMjIyMjJdLFxuICAgIFwiODc0MFwiOiBbMC4yNTE0MiwgMC43NDExMSwgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCI4NzQxXCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwLCAwLjM4ODg5XSxcbiAgICBcIjg3NDJcIjogWzAuMjUxNDIsIDAuNzQxMTEsIDAsIDAsIDAuNV0sXG4gICAgXCI4NzU2XCI6IFswLCAwLjY5MjI0LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjg3NTdcIjogWzAsIDAuNjkyMjQsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiODc2NFwiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODc2NVwiOiBbLTAuMTMzMTMsIDAuMzc3ODgsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODc2OVwiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODc3MFwiOiBbLTAuMDM2MjUsIDAuNDYzNzUsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODc3NFwiOiBbMC4zMDI3NCwgMC43OTM4MywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4Nzc2XCI6IFstMC4wMTY4OCwgMC40ODMxMiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4Nzc4XCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg3ODJcIjogWzAuMDYwNjIsIDAuNTQ5ODYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODc4M1wiOiBbMC4wNjA2MiwgMC41NDk4NiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4Nzg1XCI6IFswLjA4MTk4LCAwLjU4MTk4LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg3ODZcIjogWzAuMDgxOTgsIDAuNTgxOTgsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODc4N1wiOiBbMC4wODE5OCwgMC41ODE5OCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4NzkwXCI6IFswLCAwLjY5MjI0LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg3OTFcIjogWzAuMjI5NTgsIDAuNzI5NTgsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODc5NlwiOiBbMC4wODE5OCwgMC45MTY2NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODA2XCI6IFswLjI1NTgzLCAwLjc1NTgzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4MDdcIjogWzAuMjU1ODMsIDAuNzU1ODMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODgwOFwiOiBbMC4yNTE0MiwgMC43NTcyNiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODA5XCI6IFswLjI1MTQyLCAwLjc1NzI2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4MTJcIjogWzAuMjU1ODMsIDAuNzU1ODMsIDAsIDAsIDAuNV0sXG4gICAgXCI4ODE0XCI6IFswLjIwNTc2LCAwLjcwNTc2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4MTVcIjogWzAuMjA1NzYsIDAuNzA1NzYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODgxNlwiOiBbMC4zMDI3NCwgMC43OTM4MywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODE3XCI6IFswLjMwMjc0LCAwLjc5MzgzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4MThcIjogWzAuMjI5NTgsIDAuNzI5NTgsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODgxOVwiOiBbMC4yMjk1OCwgMC43Mjk1OCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODIyXCI6IFswLjE4MDgsIDAuNjc1LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4MjNcIjogWzAuMTgwOCwgMC42NzUsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODgyOFwiOiBbMC4xMzY2NywgMC42MzY2NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODI5XCI6IFswLjEzNjY3LCAwLjYzNjY3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4MzBcIjogWzAuMjI5NTgsIDAuNzI5NTgsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODgzMVwiOiBbMC4yMjk1OCwgMC43Mjk1OCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODMyXCI6IFswLjIwNTc2LCAwLjcwNTc2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4MzNcIjogWzAuMjA1NzYsIDAuNzA1NzYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg0MFwiOiBbMC4zMDI3NCwgMC43OTM4MywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODQxXCI6IFswLjMwMjc0LCAwLjc5MzgzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4NDJcIjogWzAuMTM1OTcsIDAuNjM1OTcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg0M1wiOiBbMC4xMzU5NywgMC42MzU5NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODQ3XCI6IFswLjAzNTE3LCAwLjU0OTg2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4NDhcIjogWzAuMDM1MTcsIDAuNTQ5ODYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg1OFwiOiBbMC4wODE5OCwgMC41ODE5OCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODU5XCI6IFswLjA4MTk4LCAwLjU4MTk4LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4NjFcIjogWzAuMDgxOTgsIDAuNTgxOTgsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg2MlwiOiBbMCwgMC42NzUsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg2M1wiOiBbMCwgMC42NzUsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg2NFwiOiBbMCwgMC42NzUsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg2NVwiOiBbMCwgMC42NzUsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg3MlwiOiBbMCwgMC42OTIyNCwgMCwgMCwgMC42MTExMV0sXG4gICAgXCI4ODczXCI6IFswLCAwLjY5MjI0LCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjg4NzRcIjogWzAsIDAuNjkyMjQsIDAsIDAsIDAuODg4ODldLFxuICAgIFwiODg3NlwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC42MTExMV0sXG4gICAgXCI4ODc3XCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjYxMTExXSxcbiAgICBcIjg4NzhcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiODg3OVwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI4ODgyXCI6IFswLjAzNTE3LCAwLjU0OTg2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4ODNcIjogWzAuMDM1MTcsIDAuNTQ5ODYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg4NFwiOiBbMC4xMzY2NywgMC42MzY2NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODg1XCI6IFswLjEzNjY3LCAwLjYzNjY3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4ODhcIjogWzAsIDAuNTQ5ODYsIDAsIDAsIDEuMTExMTFdLFxuICAgIFwiODg5MFwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMCwgMC41NTU1Nl0sXG4gICAgXCI4ODkxXCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwLCAwLjYxMTExXSxcbiAgICBcIjg4OTJcIjogWzAuMTk0NDQsIDAuNjkyMjQsIDAsIDAsIDAuNjExMTFdLFxuICAgIFwiODkwMVwiOiBbMCwgMC41NDk4NiwgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCI4OTAzXCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg5MDVcIjogWzAuMDgxNjcsIDAuNTgxNjcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODkwNlwiOiBbMC4wODE2NywgMC41ODE2NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4OTA3XCI6IFswLCAwLjY5MjI0LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg5MDhcIjogWzAsIDAuNjkyMjQsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODkwOVwiOiBbLTAuMDM1OTgsIDAuNDY0MDIsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODkxMFwiOiBbMCwgMC41NDk4NiwgMCwgMCwgMC43NjA0Ml0sXG4gICAgXCI4OTExXCI6IFswLCAwLjU0OTg2LCAwLCAwLCAwLjc2MDQyXSxcbiAgICBcIjg5MTJcIjogWzAuMDM1MTcsIDAuNTQ5ODYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODkxM1wiOiBbMC4wMzUxNywgMC41NDk4NiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4OTE0XCI6IFswLCAwLjU0OTg2LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjg5MTVcIjogWzAsIDAuNTQ5ODYsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiODkxNlwiOiBbMCwgMC42OTIyNCwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI4OTE4XCI6IFswLjAzOTEsIDAuNTM5MSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4OTE5XCI6IFswLjAzOTEsIDAuNTM5MSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4OTIwXCI6IFswLjAzNTE3LCAwLjU0OTg2LCAwLCAwLCAxLjMzMzM0XSxcbiAgICBcIjg5MjFcIjogWzAuMDM1MTcsIDAuNTQ5ODYsIDAsIDAsIDEuMzMzMzRdLFxuICAgIFwiODkyMlwiOiBbMC4zODU2OSwgMC44ODU2OSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4OTIzXCI6IFswLjM4NTY5LCAwLjg4NTY5LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg5MjZcIjogWzAuMTM2NjcsIDAuNjM2NjcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODkyN1wiOiBbMC4xMzY2NywgMC42MzY2NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4OTI4XCI6IFswLjMwMjc0LCAwLjc5MzgzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg5MjlcIjogWzAuMzAyNzQsIDAuNzkzODMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODkzNFwiOiBbMC4yMzIyMiwgMC43NDExMSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4OTM1XCI6IFswLjIzMjIyLCAwLjc0MTExLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg5MzZcIjogWzAuMjMyMjIsIDAuNzQxMTEsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODkzN1wiOiBbMC4yMzIyMiwgMC43NDExMSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4OTM4XCI6IFswLjIwNTc2LCAwLjcwNTc2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg5MzlcIjogWzAuMjA1NzYsIDAuNzA1NzYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODk0MFwiOiBbMC4zMDI3NCwgMC43OTM4MywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4OTQxXCI6IFswLjMwMjc0LCAwLjc5MzgzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg5OTRcIjogWzAuMTk0NDQsIDAuNjkyMjQsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODk5NVwiOiBbMC4xOTQ0NCwgMC42OTIyNCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI5NDE2XCI6IFswLjE1NTU5LCAwLjY5MjI0LCAwLCAwLCAwLjkwMjIyXSxcbiAgICBcIjk0ODRcIjogWzAsIDAuNjkyMjQsIDAsIDAsIDAuNV0sXG4gICAgXCI5NDg4XCI6IFswLCAwLjY5MjI0LCAwLCAwLCAwLjVdLFxuICAgIFwiOTQ5MlwiOiBbMCwgMC4zNzc4OCwgMCwgMCwgMC41XSxcbiAgICBcIjk0OTZcIjogWzAsIDAuMzc3ODgsIDAsIDAsIDAuNV0sXG4gICAgXCI5NTg1XCI6IFswLjE5NDQ0LCAwLjY4ODg5LCAwLCAwLCAwLjg4ODg5XSxcbiAgICBcIjk1ODZcIjogWzAuMTk0NDQsIDAuNzQxMTEsIDAsIDAsIDAuODg4ODldLFxuICAgIFwiOTYzMlwiOiBbMCwgMC42NzUsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiOTYzM1wiOiBbMCwgMC42NzUsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiOTY1MFwiOiBbMCwgMC41NDk4NiwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI5NjUxXCI6IFswLCAwLjU0OTg2LCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjk2NTRcIjogWzAuMDM1MTcsIDAuNTQ5ODYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiOTY2MFwiOiBbMCwgMC41NDk4NiwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI5NjYxXCI6IFswLCAwLjU0OTg2LCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjk2NjRcIjogWzAuMDM1MTcsIDAuNTQ5ODYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiOTY3NFwiOiBbMC4xMTExMSwgMC42OTIyNCwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI5NzMzXCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwLCAwLjk0NDQ1XSxcbiAgICBcIjEwMDAzXCI6IFswLCAwLjY5MjI0LCAwLCAwLCAwLjgzMzM0XSxcbiAgICBcIjEwMDE2XCI6IFswLCAwLjY5MjI0LCAwLCAwLCAwLjgzMzM0XSxcbiAgICBcIjEwNzMxXCI6IFswLjExMTExLCAwLjY5MjI0LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjEwODQ2XCI6IFswLjE5NDQ0LCAwLjc1NTgzLCAwLCAwLCAwLjYxMTExXSxcbiAgICBcIjEwODc3XCI6IFswLjEzNjY3LCAwLjYzNjY3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjEwODc4XCI6IFswLjEzNjY3LCAwLjYzNjY3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjEwODg1XCI6IFswLjI1NTgzLCAwLjc1NTgzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjEwODg2XCI6IFswLjI1NTgzLCAwLjc1NTgzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjEwODg3XCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjEwODg4XCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjEwODg5XCI6IFswLjI2MTY3LCAwLjc1NzI2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjEwODkwXCI6IFswLjI2MTY3LCAwLjc1NzI2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjEwODkxXCI6IFswLjQ4MjU2LCAwLjk4MjU2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjEwODkyXCI6IFswLjQ4MjU2LCAwLjk4MjU2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjEwOTAxXCI6IFswLjEzNjY3LCAwLjYzNjY3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjEwOTAyXCI6IFswLjEzNjY3LCAwLjYzNjY3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjEwOTMzXCI6IFswLjI1MTQyLCAwLjc1NzI2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjEwOTM0XCI6IFswLjI1MTQyLCAwLjc1NzI2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjEwOTM1XCI6IFswLjI2MTY3LCAwLjc1NzI2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjEwOTM2XCI6IFswLjI2MTY3LCAwLjc1NzI2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjEwOTM3XCI6IFswLjI2MTY3LCAwLjc1NzI2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjEwOTM4XCI6IFswLjI2MTY3LCAwLjc1NzI2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjEwOTQ5XCI6IFswLjI1NTgzLCAwLjc1NTgzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjEwOTUwXCI6IFswLjI1NTgzLCAwLjc1NTgzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjEwOTU1XCI6IFswLjI4NDgxLCAwLjc5MzgzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjEwOTU2XCI6IFswLjI4NDgxLCAwLjc5MzgzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjU3MzUwXCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwLCAwLjIyMjIyXSxcbiAgICBcIjU3MzUxXCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwLCAwLjM4ODg5XSxcbiAgICBcIjU3MzUyXCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjU3MzUzXCI6IFswLCAwLjQzMDU2LCAwLjA0MDI4LCAwLCAwLjY2NjY3XSxcbiAgICBcIjU3MzU2XCI6IFswLjI1MTQyLCAwLjc1NzI2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjU3MzU3XCI6IFswLjI1MTQyLCAwLjc1NzI2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjU3MzU4XCI6IFswLjQxOTUxLCAwLjkxOTUxLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjU3MzU5XCI6IFswLjMwMjc0LCAwLjc5MzgzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjU3MzYwXCI6IFswLjMwMjc0LCAwLjc5MzgzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjU3MzYxXCI6IFswLjQxOTUxLCAwLjkxOTUxLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjU3MzY2XCI6IFswLjI1MTQyLCAwLjc1NzI2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjU3MzY3XCI6IFswLjI1MTQyLCAwLjc1NzI2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjU3MzY4XCI6IFswLjI1MTQyLCAwLjc1NzI2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjU3MzY5XCI6IFswLjI1MTQyLCAwLjc1NzI2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjU3MzcwXCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjU3MzcxXCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwLCAwLjc3Nzc4XVxuICB9LFxuICBcIkNhbGlncmFwaGljLVJlZ3VsYXJcIjoge1xuICAgIFwiMzJcIjogWzAsIDAsIDAsIDAsIDAuMjVdLFxuICAgIFwiNjVcIjogWzAsIDAuNjgzMzMsIDAsIDAuMTk0NDUsIDAuNzk4NDddLFxuICAgIFwiNjZcIjogWzAsIDAuNjgzMzMsIDAuMDMwNDEsIDAuMTM4ODksIDAuNjU2ODFdLFxuICAgIFwiNjdcIjogWzAsIDAuNjgzMzMsIDAuMDU4MzQsIDAuMTM4ODksIDAuNTI2NTNdLFxuICAgIFwiNjhcIjogWzAsIDAuNjgzMzMsIDAuMDI3NzgsIDAuMDgzMzQsIDAuNzcxMzldLFxuICAgIFwiNjlcIjogWzAsIDAuNjgzMzMsIDAuMDg5NDQsIDAuMTExMTEsIDAuNTI3NzhdLFxuICAgIFwiNzBcIjogWzAsIDAuNjgzMzMsIDAuMDk5MzEsIDAuMTExMTEsIDAuNzE4NzVdLFxuICAgIFwiNzFcIjogWzAuMDk3MjIsIDAuNjgzMzMsIDAuMDU5MywgMC4xMTExMSwgMC41OTQ4N10sXG4gICAgXCI3MlwiOiBbMCwgMC42ODMzMywgMC4wMDk2NSwgMC4xMTExMSwgMC44NDQ1Ml0sXG4gICAgXCI3M1wiOiBbMCwgMC42ODMzMywgMC4wNzM4MiwgMCwgMC41NDQ1Ml0sXG4gICAgXCI3NFwiOiBbMC4wOTcyMiwgMC42ODMzMywgMC4xODQ3MiwgMC4xNjY2NywgMC42Nzc3OF0sXG4gICAgXCI3NVwiOiBbMCwgMC42ODMzMywgMC4wMTQ0NSwgMC4wNTU1NiwgMC43NjE5NV0sXG4gICAgXCI3NlwiOiBbMCwgMC42ODMzMywgMCwgMC4xMzg4OSwgMC42ODk3Ml0sXG4gICAgXCI3N1wiOiBbMCwgMC42ODMzMywgMCwgMC4xMzg4OSwgMS4yMDA5XSxcbiAgICBcIjc4XCI6IFswLCAwLjY4MzMzLCAwLjE0NzM2LCAwLjA4MzM0LCAwLjgyMDQ5XSxcbiAgICBcIjc5XCI6IFswLCAwLjY4MzMzLCAwLjAyNzc4LCAwLjExMTExLCAwLjc5NjExXSxcbiAgICBcIjgwXCI6IFswLCAwLjY4MzMzLCAwLjA4MjIyLCAwLjA4MzM0LCAwLjY5NTU2XSxcbiAgICBcIjgxXCI6IFswLjA5NzIyLCAwLjY4MzMzLCAwLCAwLjExMTExLCAwLjgxNjY3XSxcbiAgICBcIjgyXCI6IFswLCAwLjY4MzMzLCAwLCAwLjA4MzM0LCAwLjg0NzVdLFxuICAgIFwiODNcIjogWzAsIDAuNjgzMzMsIDAuMDc1LCAwLjEzODg5LCAwLjYwNTU2XSxcbiAgICBcIjg0XCI6IFswLCAwLjY4MzMzLCAwLjI1NDE3LCAwLCAwLjU0NDY0XSxcbiAgICBcIjg1XCI6IFswLCAwLjY4MzMzLCAwLjA5OTMxLCAwLjA4MzM0LCAwLjYyNTgzXSxcbiAgICBcIjg2XCI6IFswLCAwLjY4MzMzLCAwLjA4MjIyLCAwLCAwLjYxMjc4XSxcbiAgICBcIjg3XCI6IFswLCAwLjY4MzMzLCAwLjA4MjIyLCAwLjA4MzM0LCAwLjk4Nzc4XSxcbiAgICBcIjg4XCI6IFswLCAwLjY4MzMzLCAwLjE0NjQzLCAwLjEzODg5LCAwLjcxMzNdLFxuICAgIFwiODlcIjogWzAuMDk3MjIsIDAuNjgzMzMsIDAuMDgyMjIsIDAuMDgzMzQsIDAuNjY4MzRdLFxuICAgIFwiOTBcIjogWzAsIDAuNjgzMzMsIDAuMDc5NDQsIDAuMTM4ODksIDAuNzI0NzNdLFxuICAgIFwiMTYwXCI6IFswLCAwLCAwLCAwLCAwLjI1XVxuICB9LFxuICBcIkZyYWt0dXItUmVndWxhclwiOiB7XG4gICAgXCIzMlwiOiBbMCwgMCwgMCwgMCwgMC4yNV0sXG4gICAgXCIzM1wiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC4yOTU3NF0sXG4gICAgXCIzNFwiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC4yMTQ3MV0sXG4gICAgXCIzOFwiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC43Mzc4Nl0sXG4gICAgXCIzOVwiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC4yMTIwMV0sXG4gICAgXCI0MFwiOiBbMC4yNDk4MiwgMC43NDk0NywgMCwgMCwgMC4zODg2NV0sXG4gICAgXCI0MVwiOiBbMC4yNDk4MiwgMC43NDk0NywgMCwgMCwgMC4zODg2NV0sXG4gICAgXCI0MlwiOiBbMCwgMC42MjExOSwgMCwgMCwgMC4yNzc2NF0sXG4gICAgXCI0M1wiOiBbMC4wODMxOSwgMC41ODI4MywgMCwgMCwgMC43NTYyM10sXG4gICAgXCI0NFwiOiBbMCwgMC4xMDgwMywgMCwgMCwgMC4yNzc2NF0sXG4gICAgXCI0NVwiOiBbMC4wODMxOSwgMC41ODI4MywgMCwgMCwgMC43NTYyM10sXG4gICAgXCI0NlwiOiBbMCwgMC4xMDgwMywgMCwgMCwgMC4yNzc2NF0sXG4gICAgXCI0N1wiOiBbMC4yNDk4MiwgMC43NDk0NywgMCwgMCwgMC41MDE4MV0sXG4gICAgXCI0OFwiOiBbMCwgMC40NzUzNCwgMCwgMCwgMC41MDE4MV0sXG4gICAgXCI0OVwiOiBbMCwgMC40NzUzNCwgMCwgMCwgMC41MDE4MV0sXG4gICAgXCI1MFwiOiBbMCwgMC40NzUzNCwgMCwgMCwgMC41MDE4MV0sXG4gICAgXCI1MVwiOiBbMC4xODkwNiwgMC40NzUzNCwgMCwgMCwgMC41MDE4MV0sXG4gICAgXCI1MlwiOiBbMC4xODkwNiwgMC40NzUzNCwgMCwgMCwgMC41MDE4MV0sXG4gICAgXCI1M1wiOiBbMC4xODkwNiwgMC40NzUzNCwgMCwgMCwgMC41MDE4MV0sXG4gICAgXCI1NFwiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC41MDE4MV0sXG4gICAgXCI1NVwiOiBbMC4xODkwNiwgMC40NzUzNCwgMCwgMCwgMC41MDE4MV0sXG4gICAgXCI1NlwiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC41MDE4MV0sXG4gICAgXCI1N1wiOiBbMC4xODkwNiwgMC40NzUzNCwgMCwgMCwgMC41MDE4MV0sXG4gICAgXCI1OFwiOiBbMCwgMC40NzUzNCwgMCwgMCwgMC4yMTYwNl0sXG4gICAgXCI1OVwiOiBbMC4xMjYwNCwgMC40NzUzNCwgMCwgMCwgMC4yMTYwNl0sXG4gICAgXCI2MVwiOiBbLTAuMTMwOTksIDAuMzY4NjYsIDAsIDAsIDAuNzU2MjNdLFxuICAgIFwiNjNcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuMzYyNDVdLFxuICAgIFwiNjVcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuNzE3Nl0sXG4gICAgXCI2NlwiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC44ODM5N10sXG4gICAgXCI2N1wiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC42MTI1NF0sXG4gICAgXCI2OFwiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC44MzE1OF0sXG4gICAgXCI2OVwiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC42NjI3OF0sXG4gICAgXCI3MFwiOiBbMC4xMjYwNCwgMC42OTE0MSwgMCwgMCwgMC42MTExOV0sXG4gICAgXCI3MVwiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC43ODUzOV0sXG4gICAgXCI3MlwiOiBbMC4wNjMwMiwgMC42OTE0MSwgMCwgMCwgMC43MjAzXSxcbiAgICBcIjczXCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjU1NDQ4XSxcbiAgICBcIjc0XCI6IFswLjEyNjA0LCAwLjY5MTQxLCAwLCAwLCAwLjU1MjMxXSxcbiAgICBcIjc1XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjY2ODQ1XSxcbiAgICBcIjc2XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjY2NjAyXSxcbiAgICBcIjc3XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAxLjA0OTUzXSxcbiAgICBcIjc4XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjgzMjEyXSxcbiAgICBcIjc5XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjgyNjk5XSxcbiAgICBcIjgwXCI6IFswLjE4OTA2LCAwLjY5MTQxLCAwLCAwLCAwLjgyNzUzXSxcbiAgICBcIjgxXCI6IFswLjAzNzgxLCAwLjY5MTQxLCAwLCAwLCAwLjgyNjk5XSxcbiAgICBcIjgyXCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjgyODA3XSxcbiAgICBcIjgzXCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjgyODYxXSxcbiAgICBcIjg0XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjY2ODk5XSxcbiAgICBcIjg1XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjY0NTc2XSxcbiAgICBcIjg2XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjgzMTMxXSxcbiAgICBcIjg3XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAxLjA0NjAyXSxcbiAgICBcIjg4XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjcxOTIyXSxcbiAgICBcIjg5XCI6IFswLjE4OTA2LCAwLjY5MTQxLCAwLCAwLCAwLjgzMjkzXSxcbiAgICBcIjkwXCI6IFswLjEyNjA0LCAwLjY5MTQxLCAwLCAwLCAwLjYwMjAxXSxcbiAgICBcIjkxXCI6IFswLjI0OTgyLCAwLjc0OTQ3LCAwLCAwLCAwLjI3NzY0XSxcbiAgICBcIjkzXCI6IFswLjI0OTgyLCAwLjc0OTQ3LCAwLCAwLCAwLjI3NzY0XSxcbiAgICBcIjk0XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjQ5OTY1XSxcbiAgICBcIjk3XCI6IFswLCAwLjQ3NTM0LCAwLCAwLCAwLjUwMDQ2XSxcbiAgICBcIjk4XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjUxMzE1XSxcbiAgICBcIjk5XCI6IFswLCAwLjQ3NTM0LCAwLCAwLCAwLjM4OTQ2XSxcbiAgICBcIjEwMFwiOiBbMCwgMC42MjExOSwgMCwgMCwgMC40OTg1N10sXG4gICAgXCIxMDFcIjogWzAsIDAuNDc1MzQsIDAsIDAsIDAuNDAwNTNdLFxuICAgIFwiMTAyXCI6IFswLjE4OTA2LCAwLjY5MTQxLCAwLCAwLCAwLjMyNjI2XSxcbiAgICBcIjEwM1wiOiBbMC4xODkwNiwgMC40NzUzNCwgMCwgMCwgMC41MDM3XSxcbiAgICBcIjEwNFwiOiBbMC4xODkwNiwgMC42OTE0MSwgMCwgMCwgMC41MjEyNl0sXG4gICAgXCIxMDVcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuMjc4OTldLFxuICAgIFwiMTA2XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjI4MDg4XSxcbiAgICBcIjEwN1wiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC4zODk0Nl0sXG4gICAgXCIxMDhcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuMjc5NTNdLFxuICAgIFwiMTA5XCI6IFswLCAwLjQ3NTM0LCAwLCAwLCAwLjc2Njc2XSxcbiAgICBcIjExMFwiOiBbMCwgMC40NzUzNCwgMCwgMCwgMC41MjY2Nl0sXG4gICAgXCIxMTFcIjogWzAsIDAuNDc1MzQsIDAsIDAsIDAuNDg4ODVdLFxuICAgIFwiMTEyXCI6IFswLjE4OTA2LCAwLjUyMzk2LCAwLCAwLCAwLjUwMDQ2XSxcbiAgICBcIjExM1wiOiBbMC4xODkwNiwgMC40NzUzNCwgMCwgMCwgMC40ODkxMl0sXG4gICAgXCIxMTRcIjogWzAsIDAuNDc1MzQsIDAsIDAsIDAuMzg5MTldLFxuICAgIFwiMTE1XCI6IFswLCAwLjQ3NTM0LCAwLCAwLCAwLjQ0MjY2XSxcbiAgICBcIjExNlwiOiBbMCwgMC42MjExOSwgMCwgMCwgMC4zMzMwMV0sXG4gICAgXCIxMTdcIjogWzAsIDAuNDc1MzQsIDAsIDAsIDAuNTE3Ml0sXG4gICAgXCIxMThcIjogWzAsIDAuNTIzOTYsIDAsIDAsIDAuNTExOF0sXG4gICAgXCIxMTlcIjogWzAsIDAuNTIzOTYsIDAsIDAsIDAuNzczNTFdLFxuICAgIFwiMTIwXCI6IFswLjE4OTA2LCAwLjQ3NTM0LCAwLCAwLCAwLjM4ODY1XSxcbiAgICBcIjEyMVwiOiBbMC4xODkwNiwgMC40NzUzNCwgMCwgMCwgMC40OTg4NF0sXG4gICAgXCIxMjJcIjogWzAuMTg5MDYsIDAuNDc1MzQsIDAsIDAsIDAuMzkwNTRdLFxuICAgIFwiMTYwXCI6IFswLCAwLCAwLCAwLCAwLjI1XSxcbiAgICBcIjgyMTZcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuMjE0NzFdLFxuICAgIFwiODIxN1wiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC4yMTQ3MV0sXG4gICAgXCI1ODExMlwiOiBbMCwgMC42MjExOSwgMCwgMCwgMC40OTc0OV0sXG4gICAgXCI1ODExM1wiOiBbMCwgMC42MjExOSwgMCwgMCwgMC40OTgzXSxcbiAgICBcIjU4MTE0XCI6IFswLjE4OTA2LCAwLjY5MTQxLCAwLCAwLCAwLjMzMzI4XSxcbiAgICBcIjU4MTE1XCI6IFswLjE4OTA2LCAwLjY5MTQxLCAwLCAwLCAwLjMyOTIzXSxcbiAgICBcIjU4MTE2XCI6IFswLjE4OTA2LCAwLjQ3NTM0LCAwLCAwLCAwLjUwMzQzXSxcbiAgICBcIjU4MTE3XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjMzMzAxXSxcbiAgICBcIjU4MTE4XCI6IFswLCAwLjYyMTE5LCAwLCAwLCAwLjMzNDA5XSxcbiAgICBcIjU4MTE5XCI6IFswLCAwLjQ3NTM0LCAwLCAwLCAwLjUwMDczXVxuICB9LFxuICBcIk1haW4tQm9sZFwiOiB7XG4gICAgXCIzMlwiOiBbMCwgMCwgMCwgMCwgMC4yNV0sXG4gICAgXCIzM1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4zNV0sXG4gICAgXCIzNFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42MDI3OF0sXG4gICAgXCIzNVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC45NTgzM10sXG4gICAgXCIzNlwiOiBbMC4wNTU1NiwgMC43NSwgMCwgMCwgMC41NzVdLFxuICAgIFwiMzdcIjogWzAuMDU1NTYsIDAuNzUsIDAsIDAsIDAuOTU4MzNdLFxuICAgIFwiMzhcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiMzlcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMzE5NDRdLFxuICAgIFwiNDBcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNDQ3MjJdLFxuICAgIFwiNDFcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNDQ3MjJdLFxuICAgIFwiNDJcIjogWzAsIDAuNzUsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjQzXCI6IFswLjEzMzMzLCAwLjYzMzMzLCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjQ0XCI6IFswLjE5NDQ0LCAwLjE1NTU2LCAwLCAwLCAwLjMxOTQ0XSxcbiAgICBcIjQ1XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjM4MzMzXSxcbiAgICBcIjQ2XCI6IFswLCAwLjE1NTU2LCAwLCAwLCAwLjMxOTQ0XSxcbiAgICBcIjQ3XCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI0OFwiOiBbMCwgMC42NDQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiNDlcIjogWzAsIDAuNjQ0NDQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjUwXCI6IFswLCAwLjY0NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI1MVwiOiBbMCwgMC42NDQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiNTJcIjogWzAsIDAuNjQ0NDQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjUzXCI6IFswLCAwLjY0NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI1NFwiOiBbMCwgMC42NDQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiNTVcIjogWzAsIDAuNjQ0NDQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjU2XCI6IFswLCAwLjY0NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI1N1wiOiBbMCwgMC42NDQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiNThcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuMzE5NDRdLFxuICAgIFwiNTlcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDAsIDAuMzE5NDRdLFxuICAgIFwiNjBcIjogWzAuMDg1NTYsIDAuNTg1NTYsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiNjFcIjogWy0wLjEwODg5LCAwLjM5MTExLCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjYyXCI6IFswLjA4NTU2LCAwLjU4NTU2LCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjYzXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU0MzA1XSxcbiAgICBcIjY0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjY1XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjg2OTQ0XSxcbiAgICBcIjY2XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjgxODA1XSxcbiAgICBcIjY3XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjgzMDU1XSxcbiAgICBcIjY4XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjg4MTk0XSxcbiAgICBcIjY5XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjc1NTU1XSxcbiAgICBcIjcwXCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjcyMzYxXSxcbiAgICBcIjcxXCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjkwNDE2XSxcbiAgICBcIjcyXCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjldLFxuICAgIFwiNzNcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuNDM2MTFdLFxuICAgIFwiNzRcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuNTk0NDRdLFxuICAgIFwiNzVcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuOTAxMzhdLFxuICAgIFwiNzZcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuNjkxNjZdLFxuICAgIFwiNzdcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDEuMDkxNjZdLFxuICAgIFwiNzhcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuOV0sXG4gICAgXCI3OVwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC44NjM4OF0sXG4gICAgXCI4MFwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC43ODYxMV0sXG4gICAgXCI4MVwiOiBbMC4xOTQ0NCwgMC42ODYxMSwgMCwgMCwgMC44NjM4OF0sXG4gICAgXCI4MlwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC44NjI1XSxcbiAgICBcIjgzXCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjYzODg5XSxcbiAgICBcIjg0XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjhdLFxuICAgIFwiODVcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuODg0NzJdLFxuICAgIFwiODZcIjogWzAsIDAuNjg2MTEsIDAuMDE1OTcsIDAsIDAuODY5NDRdLFxuICAgIFwiODdcIjogWzAsIDAuNjg2MTEsIDAuMDE1OTcsIDAsIDEuMTg4ODhdLFxuICAgIFwiODhcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuODY5NDRdLFxuICAgIFwiODlcIjogWzAsIDAuNjg2MTEsIDAuMDI4NzUsIDAsIDAuODY5NDRdLFxuICAgIFwiOTBcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuNzAyNzddLFxuICAgIFwiOTFcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuMzE5NDRdLFxuICAgIFwiOTJcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjkzXCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjMxOTQ0XSxcbiAgICBcIjk0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI5NVwiOiBbMC4zMSwgMC4xMzQ0NCwgMC4wMzE5NCwgMCwgMC41NzVdLFxuICAgIFwiOTdcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNTU5MDJdLFxuICAgIFwiOThcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjM4ODldLFxuICAgIFwiOTlcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNTExMTFdLFxuICAgIFwiMTAwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjYzODg5XSxcbiAgICBcIjEwMVwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC41MjcwOF0sXG4gICAgXCIxMDJcIjogWzAsIDAuNjk0NDQsIDAuMTA5MDMsIDAsIDAuMzUxMzldLFxuICAgIFwiMTAzXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjAxNTk3LCAwLCAwLjU3NV0sXG4gICAgXCIxMDRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjM4ODldLFxuICAgIFwiMTA1XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjMxOTQ0XSxcbiAgICBcIjEwNlwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC4zNTEzOV0sXG4gICAgXCIxMDdcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjA2OTRdLFxuICAgIFwiMTA4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjMxOTQ0XSxcbiAgICBcIjEwOVwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC45NTgzM10sXG4gICAgXCIxMTBcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNjM4ODldLFxuICAgIFwiMTExXCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCIxMTJcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDAsIDAuNjM4ODldLFxuICAgIFwiMTEzXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwLCAwLjYwNjk0XSxcbiAgICBcIjExNFwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC40NzM2MV0sXG4gICAgXCIxMTVcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNDUzNjFdLFxuICAgIFwiMTE2XCI6IFswLCAwLjYzNDkyLCAwLCAwLCAwLjQ0NzIyXSxcbiAgICBcIjExN1wiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC42Mzg4OV0sXG4gICAgXCIxMThcIjogWzAsIDAuNDQ0NDQsIDAuMDE1OTcsIDAsIDAuNjA2OTRdLFxuICAgIFwiMTE5XCI6IFswLCAwLjQ0NDQ0LCAwLjAxNTk3LCAwLCAwLjgzMDU1XSxcbiAgICBcIjEyMFwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC42MDY5NF0sXG4gICAgXCIxMjFcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMDE1OTcsIDAsIDAuNjA2OTRdLFxuICAgIFwiMTIyXCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjUxMTExXSxcbiAgICBcIjEyM1wiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC41NzVdLFxuICAgIFwiMTI0XCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjMxOTQ0XSxcbiAgICBcIjEyNVwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC41NzVdLFxuICAgIFwiMTI2XCI6IFswLjM1LCAwLjM0NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCIxNjBcIjogWzAsIDAsIDAsIDAsIDAuMjVdLFxuICAgIFwiMTYzXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjg2ODUzXSxcbiAgICBcIjE2OFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiMTcyXCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjc2NjY2XSxcbiAgICBcIjE3NlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC44Njk0NF0sXG4gICAgXCIxNzdcIjogWzAuMTMzMzMsIDAuNjMzMzMsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiMTg0XCI6IFswLjE3MDE0LCAwLCAwLCAwLCAwLjUxMTExXSxcbiAgICBcIjE5OFwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMS4wNDE2Nl0sXG4gICAgXCIyMTVcIjogWzAuMTMzMzMsIDAuNjMzMzMsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiMjE2XCI6IFswLjA0ODYxLCAwLjczNDcyLCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjIyM1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41OTcyMl0sXG4gICAgXCIyMzBcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuODMwNTVdLFxuICAgIFwiMjQ3XCI6IFswLjEzMzMzLCAwLjYzMzMzLCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjI0OFwiOiBbMC4wOTcyMiwgMC41NDE2NywgMCwgMCwgMC41NzVdLFxuICAgIFwiMzA1XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjMxOTQ0XSxcbiAgICBcIjMzOFwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMS4xNjk0NF0sXG4gICAgXCIzMzlcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiNTY3XCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwLCAwLjM1MTM5XSxcbiAgICBcIjcxMFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiNzExXCI6IFswLCAwLjYzMTk0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI3MTNcIjogWzAsIDAuNTk2MTEsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjcxNFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiNzE1XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI3MjhcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjcyOVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4zMTk0NF0sXG4gICAgXCI3MzBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuODY5NDRdLFxuICAgIFwiNzMyXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI3MzNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjkxNVwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC42OTE2Nl0sXG4gICAgXCI5MTZcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuOTU4MzNdLFxuICAgIFwiOTIwXCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjkyM1wiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC44MDU1NV0sXG4gICAgXCI5MjZcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuNzY2NjZdLFxuICAgIFwiOTI4XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjldLFxuICAgIFwiOTMxXCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjgzMDU1XSxcbiAgICBcIjkzM1wiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI5MzRcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuODMwNTVdLFxuICAgIFwiOTM2XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjkzN1wiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC44MzA1NV0sXG4gICAgXCI4MjExXCI6IFswLCAwLjQ0NDQ0LCAwLjAzMTk0LCAwLCAwLjU3NV0sXG4gICAgXCI4MjEyXCI6IFswLCAwLjQ0NDQ0LCAwLjAzMTk0LCAwLCAxLjE0OTk5XSxcbiAgICBcIjgyMTZcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMzE5NDRdLFxuICAgIFwiODIxN1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4zMTk0NF0sXG4gICAgXCI4MjIwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjYwMjc4XSxcbiAgICBcIjgyMjFcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjAyNzhdLFxuICAgIFwiODIyNFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC41MTExMV0sXG4gICAgXCI4MjI1XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjUxMTExXSxcbiAgICBcIjgyNDJcIjogWzAsIDAuNTU1NTYsIDAsIDAsIDAuMzQ0NDRdLFxuICAgIFwiODQwN1wiOiBbMCwgMC43MjQ0NCwgMC4xNTQ4NiwgMCwgMC41NzVdLFxuICAgIFwiODQ2M1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42Njc1OV0sXG4gICAgXCI4NDY1XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjgzMDU1XSxcbiAgICBcIjg0NjdcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNDczNjFdLFxuICAgIFwiODQ3MlwiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMCwgMC43NDAyN10sXG4gICAgXCI4NDc2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjgzMDU1XSxcbiAgICBcIjg1MDFcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzAyNzddLFxuICAgIFwiODU5MlwiOiBbLTAuMTA4ODksIDAuMzkxMTEsIDAsIDAsIDEuMTQ5OTldLFxuICAgIFwiODU5M1wiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiODU5NFwiOiBbLTAuMTA4ODksIDAuMzkxMTEsIDAsIDAsIDEuMTQ5OTldLFxuICAgIFwiODU5NVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiODU5NlwiOiBbLTAuMTA4ODksIDAuMzkxMTEsIDAsIDAsIDEuMTQ5OTldLFxuICAgIFwiODU5N1wiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC41NzVdLFxuICAgIFwiODU5OFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMS4xNDk5OV0sXG4gICAgXCI4NTk5XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAxLjE0OTk5XSxcbiAgICBcIjg2MDBcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDEuMTQ5OTldLFxuICAgIFwiODYwMVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMS4xNDk5OV0sXG4gICAgXCI4NjM2XCI6IFstMC4xMDg4OSwgMC4zOTExMSwgMCwgMCwgMS4xNDk5OV0sXG4gICAgXCI4NjM3XCI6IFstMC4xMDg4OSwgMC4zOTExMSwgMCwgMCwgMS4xNDk5OV0sXG4gICAgXCI4NjQwXCI6IFstMC4xMDg4OSwgMC4zOTExMSwgMCwgMCwgMS4xNDk5OV0sXG4gICAgXCI4NjQxXCI6IFstMC4xMDg4OSwgMC4zOTExMSwgMCwgMCwgMS4xNDk5OV0sXG4gICAgXCI4NjU2XCI6IFstMC4xMDg4OSwgMC4zOTExMSwgMCwgMCwgMS4xNDk5OV0sXG4gICAgXCI4NjU3XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjcwMjc3XSxcbiAgICBcIjg2NThcIjogWy0wLjEwODg5LCAwLjM5MTExLCAwLCAwLCAxLjE0OTk5XSxcbiAgICBcIjg2NTlcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuNzAyNzddLFxuICAgIFwiODY2MFwiOiBbLTAuMTA4ODksIDAuMzkxMTEsIDAsIDAsIDEuMTQ5OTldLFxuICAgIFwiODY2MVwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC43MDI3N10sXG4gICAgXCI4NzA0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjYzODg5XSxcbiAgICBcIjg3MDZcIjogWzAsIDAuNjk0NDQsIDAuMDYzODksIDAsIDAuNjI4NDddLFxuICAgIFwiODcwN1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42Mzg4OV0sXG4gICAgXCI4NzA5XCI6IFswLjA1NTU2LCAwLjc1LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI4NzExXCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjk1ODMzXSxcbiAgICBcIjg3MTJcIjogWzAuMDg1NTYsIDAuNTg1NTYsIDAsIDAsIDAuNzY2NjZdLFxuICAgIFwiODcxNVwiOiBbMC4wODU1NiwgMC41ODU1NiwgMCwgMCwgMC43NjY2Nl0sXG4gICAgXCI4NzIyXCI6IFswLjEzMzMzLCAwLjYzMzMzLCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjg3MjNcIjogWzAuMTMzMzMsIDAuNjMzMzMsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiODcyNVwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC41NzVdLFxuICAgIFwiODcyNlwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC41NzVdLFxuICAgIFwiODcyN1wiOiBbLTAuMDI3NzgsIDAuNDcyMjIsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjg3MjhcIjogWy0wLjAyNjM5LCAwLjQ3MzYxLCAwLCAwLCAwLjU3NV0sXG4gICAgXCI4NzI5XCI6IFstMC4wMjYzOSwgMC40NzM2MSwgMCwgMCwgMC41NzVdLFxuICAgIFwiODczMFwiOiBbMC4xOCwgMC44MiwgMCwgMCwgMC45NTgzM10sXG4gICAgXCI4NzMzXCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjg3MzRcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDEuMTQ5OTldLFxuICAgIFwiODczNlwiOiBbMCwgMC42OTIyNCwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI4NzM5XCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjMxOTQ0XSxcbiAgICBcIjg3NDFcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjg3NDNcIjogWzAsIDAuNTU1NTYsIDAsIDAsIDAuNzY2NjZdLFxuICAgIFwiODc0NFwiOiBbMCwgMC41NTU1NiwgMCwgMCwgMC43NjY2Nl0sXG4gICAgXCI4NzQ1XCI6IFswLCAwLjU1NTU2LCAwLCAwLCAwLjc2NjY2XSxcbiAgICBcIjg3NDZcIjogWzAsIDAuNTU1NTYsIDAsIDAsIDAuNzY2NjZdLFxuICAgIFwiODc0N1wiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4xMjc3OCwgMCwgMC41Njg3NV0sXG4gICAgXCI4NzY0XCI6IFstMC4xMDg4OSwgMC4zOTExMSwgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI4NzY4XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjMxOTQ0XSxcbiAgICBcIjg3NzFcIjogWzAuMDAyMjIsIDAuNTAyMjIsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiODc3M1wiOiBbMC4wMjcsIDAuNjM4LCAwLCAwLCAwLjg5NF0sXG4gICAgXCI4Nzc2XCI6IFswLjAyNDQ0LCAwLjUyNDQ0LCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjg3ODFcIjogWzAuMDAyMjIsIDAuNTAyMjIsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiODgwMVwiOiBbMC4wMDIyMiwgMC41MDIyMiwgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI4ODA0XCI6IFswLjE5NjY3LCAwLjY5NjY3LCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjg4MDVcIjogWzAuMTk2NjcsIDAuNjk2NjcsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiODgxMFwiOiBbMC4wODU1NiwgMC41ODU1NiwgMCwgMCwgMS4xNDk5OV0sXG4gICAgXCI4ODExXCI6IFswLjA4NTU2LCAwLjU4NTU2LCAwLCAwLCAxLjE0OTk5XSxcbiAgICBcIjg4MjZcIjogWzAuMDg1NTYsIDAuNTg1NTYsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiODgyN1wiOiBbMC4wODU1NiwgMC41ODU1NiwgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI4ODM0XCI6IFswLjA4NTU2LCAwLjU4NTU2LCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjg4MzVcIjogWzAuMDg1NTYsIDAuNTg1NTYsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiODgzOFwiOiBbMC4xOTY2NywgMC42OTY2NywgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI4ODM5XCI6IFswLjE5NjY3LCAwLjY5NjY3LCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjg4NDZcIjogWzAsIDAuNTU1NTYsIDAsIDAsIDAuNzY2NjZdLFxuICAgIFwiODg0OVwiOiBbMC4xOTY2NywgMC42OTY2NywgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI4ODUwXCI6IFswLjE5NjY3LCAwLjY5NjY3LCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjg4NTFcIjogWzAsIDAuNTU1NTYsIDAsIDAsIDAuNzY2NjZdLFxuICAgIFwiODg1MlwiOiBbMCwgMC41NTU1NiwgMCwgMCwgMC43NjY2Nl0sXG4gICAgXCI4ODUzXCI6IFswLjEzMzMzLCAwLjYzMzMzLCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjg4NTRcIjogWzAuMTMzMzMsIDAuNjMzMzMsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiODg1NVwiOiBbMC4xMzMzMywgMC42MzMzMywgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI4ODU2XCI6IFswLjEzMzMzLCAwLjYzMzMzLCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjg4NTdcIjogWzAuMTMzMzMsIDAuNjMzMzMsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiODg2NlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43MDI3N10sXG4gICAgXCI4ODY3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjcwMjc3XSxcbiAgICBcIjg4NjhcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiODg2OVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI4OTAwXCI6IFstMC4wMjYzOSwgMC40NzM2MSwgMCwgMCwgMC41NzVdLFxuICAgIFwiODkwMVwiOiBbLTAuMDI2MzksIDAuNDczNjEsIDAsIDAsIDAuMzE5NDRdLFxuICAgIFwiODkwMlwiOiBbLTAuMDI3NzgsIDAuNDcyMjIsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjg5NjhcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNTExMTFdLFxuICAgIFwiODk2OVwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC41MTExMV0sXG4gICAgXCI4OTcwXCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjUxMTExXSxcbiAgICBcIjg5NzFcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNTExMTFdLFxuICAgIFwiODk5NFwiOiBbLTAuMTM4ODksIDAuMzYxMTEsIDAsIDAsIDEuMTQ5OTldLFxuICAgIFwiODk5NVwiOiBbLTAuMTM4ODksIDAuMzYxMTEsIDAsIDAsIDEuMTQ5OTldLFxuICAgIFwiOTY1MVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMS4wMjIyMl0sXG4gICAgXCI5NjU3XCI6IFstMC4wMjc3OCwgMC40NzIyMiwgMCwgMCwgMC41NzVdLFxuICAgIFwiOTY2MVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMS4wMjIyMl0sXG4gICAgXCI5NjY3XCI6IFstMC4wMjc3OCwgMC40NzIyMiwgMCwgMCwgMC41NzVdLFxuICAgIFwiOTcxMVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMS4xNDk5OV0sXG4gICAgXCI5ODI0XCI6IFswLjEyOTYzLCAwLjY5NDQ0LCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjk4MjVcIjogWzAuMTI5NjMsIDAuNjk0NDQsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiOTgyNlwiOiBbMC4xMjk2MywgMC42OTQ0NCwgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI5ODI3XCI6IFswLjEyOTYzLCAwLjY5NDQ0LCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjk4MzdcIjogWzAsIDAuNzUsIDAsIDAsIDAuNDQ3MjJdLFxuICAgIFwiOTgzOFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC40NDcyMl0sXG4gICAgXCI5ODM5XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjQ0NzIyXSxcbiAgICBcIjEwMjE2XCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjQ0NzIyXSxcbiAgICBcIjEwMjE3XCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjQ0NzIyXSxcbiAgICBcIjEwODE1XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjldLFxuICAgIFwiMTA5MjdcIjogWzAuMTk2NjcsIDAuNjk2NjcsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiMTA5MjhcIjogWzAuMTk2NjcsIDAuNjk2NjcsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiNTczNzZcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDBdXG4gIH0sXG4gIFwiTWFpbi1Cb2xkSXRhbGljXCI6IHtcbiAgICBcIjMyXCI6IFswLCAwLCAwLCAwLCAwLjI1XSxcbiAgICBcIjMzXCI6IFswLCAwLjY5NDQ0LCAwLjExNDE3LCAwLCAwLjM4NjExXSxcbiAgICBcIjM0XCI6IFswLCAwLjY5NDQ0LCAwLjA3OTM5LCAwLCAwLjYyMDU1XSxcbiAgICBcIjM1XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjA2ODMzLCAwLCAwLjk0NDQ0XSxcbiAgICBcIjM3XCI6IFswLjA1NTU2LCAwLjc1LCAwLjEyODYxLCAwLCAwLjk0NDQ0XSxcbiAgICBcIjM4XCI6IFswLCAwLjY5NDQ0LCAwLjA4NTI4LCAwLCAwLjg4NTU1XSxcbiAgICBcIjM5XCI6IFswLCAwLjY5NDQ0LCAwLjEyOTQ1LCAwLCAwLjM1NTU1XSxcbiAgICBcIjQwXCI6IFswLjI1LCAwLjc1LCAwLjE1ODA2LCAwLCAwLjQ3MzMzXSxcbiAgICBcIjQxXCI6IFswLjI1LCAwLjc1LCAwLjAzMzA2LCAwLCAwLjQ3MzMzXSxcbiAgICBcIjQyXCI6IFswLCAwLjc1LCAwLjE0MzMzLCAwLCAwLjU5MTExXSxcbiAgICBcIjQzXCI6IFswLjEwMzMzLCAwLjYwMzMzLCAwLjAzMzA2LCAwLCAwLjg4NTU1XSxcbiAgICBcIjQ0XCI6IFswLjE5NDQ0LCAwLjE0NzIyLCAwLCAwLCAwLjM1NTU1XSxcbiAgICBcIjQ1XCI6IFswLCAwLjQ0NDQ0LCAwLjAyNjExLCAwLCAwLjQxNDQ0XSxcbiAgICBcIjQ2XCI6IFswLCAwLjE0NzIyLCAwLCAwLCAwLjM1NTU1XSxcbiAgICBcIjQ3XCI6IFswLjI1LCAwLjc1LCAwLjE1ODA2LCAwLCAwLjU5MTExXSxcbiAgICBcIjQ4XCI6IFswLCAwLjY0NDQ0LCAwLjEzMTY3LCAwLCAwLjU5MTExXSxcbiAgICBcIjQ5XCI6IFswLCAwLjY0NDQ0LCAwLjEzMTY3LCAwLCAwLjU5MTExXSxcbiAgICBcIjUwXCI6IFswLCAwLjY0NDQ0LCAwLjEzMTY3LCAwLCAwLjU5MTExXSxcbiAgICBcIjUxXCI6IFswLCAwLjY0NDQ0LCAwLjEzMTY3LCAwLCAwLjU5MTExXSxcbiAgICBcIjUyXCI6IFswLjE5NDQ0LCAwLjY0NDQ0LCAwLjEzMTY3LCAwLCAwLjU5MTExXSxcbiAgICBcIjUzXCI6IFswLCAwLjY0NDQ0LCAwLjEzMTY3LCAwLCAwLjU5MTExXSxcbiAgICBcIjU0XCI6IFswLCAwLjY0NDQ0LCAwLjEzMTY3LCAwLCAwLjU5MTExXSxcbiAgICBcIjU1XCI6IFswLjE5NDQ0LCAwLjY0NDQ0LCAwLjEzMTY3LCAwLCAwLjU5MTExXSxcbiAgICBcIjU2XCI6IFswLCAwLjY0NDQ0LCAwLjEzMTY3LCAwLCAwLjU5MTExXSxcbiAgICBcIjU3XCI6IFswLCAwLjY0NDQ0LCAwLjEzMTY3LCAwLCAwLjU5MTExXSxcbiAgICBcIjU4XCI6IFswLCAwLjQ0NDQ0LCAwLjA2Njk1LCAwLCAwLjM1NTU1XSxcbiAgICBcIjU5XCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjA2Njk1LCAwLCAwLjM1NTU1XSxcbiAgICBcIjYxXCI6IFstMC4xMDg4OSwgMC4zOTExMSwgMC4wNjgzMywgMCwgMC44ODU1NV0sXG4gICAgXCI2M1wiOiBbMCwgMC42OTQ0NCwgMC4xMTQ3MiwgMCwgMC41OTExMV0sXG4gICAgXCI2NFwiOiBbMCwgMC42OTQ0NCwgMC4wOTIwOCwgMCwgMC44ODU1NV0sXG4gICAgXCI2NVwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC44NjU1NV0sXG4gICAgXCI2NlwiOiBbMCwgMC42ODYxMSwgMC4wOTkyLCAwLCAwLjgxNjY2XSxcbiAgICBcIjY3XCI6IFswLCAwLjY4NjExLCAwLjE0MjA4LCAwLCAwLjgyNjY2XSxcbiAgICBcIjY4XCI6IFswLCAwLjY4NjExLCAwLjA5MDYyLCAwLCAwLjg3NTU1XSxcbiAgICBcIjY5XCI6IFswLCAwLjY4NjExLCAwLjExNDMxLCAwLCAwLjc1NjY2XSxcbiAgICBcIjcwXCI6IFswLCAwLjY4NjExLCAwLjEyOTAzLCAwLCAwLjcyNzIyXSxcbiAgICBcIjcxXCI6IFswLCAwLjY4NjExLCAwLjA3MzQ3LCAwLCAwLjg5NTI3XSxcbiAgICBcIjcyXCI6IFswLCAwLjY4NjExLCAwLjE3MjA4LCAwLCAwLjg5NjFdLFxuICAgIFwiNzNcIjogWzAsIDAuNjg2MTEsIDAuMTU2ODEsIDAsIDAuNDcxNjZdLFxuICAgIFwiNzRcIjogWzAsIDAuNjg2MTEsIDAuMTQ1LCAwLCAwLjYxMDU1XSxcbiAgICBcIjc1XCI6IFswLCAwLjY4NjExLCAwLjE0MjA4LCAwLCAwLjg5NDk5XSxcbiAgICBcIjc2XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjY5Nzc3XSxcbiAgICBcIjc3XCI6IFswLCAwLjY4NjExLCAwLjE3MjA4LCAwLCAxLjA3Mjc3XSxcbiAgICBcIjc4XCI6IFswLCAwLjY4NjExLCAwLjE3MjA4LCAwLCAwLjg5NjFdLFxuICAgIFwiNzlcIjogWzAsIDAuNjg2MTEsIDAuMDkwNjIsIDAsIDAuODU0OTldLFxuICAgIFwiODBcIjogWzAsIDAuNjg2MTEsIDAuMDk5MiwgMCwgMC43ODcyMV0sXG4gICAgXCI4MVwiOiBbMC4xOTQ0NCwgMC42ODYxMSwgMC4wOTA2MiwgMCwgMC44NTQ5OV0sXG4gICAgXCI4MlwiOiBbMCwgMC42ODYxMSwgMC4wMjU1OSwgMCwgMC44NTk0NF0sXG4gICAgXCI4M1wiOiBbMCwgMC42ODYxMSwgMC4xMTI2NCwgMCwgMC42NDk5OV0sXG4gICAgXCI4NFwiOiBbMCwgMC42ODYxMSwgMC4xMjkwMywgMCwgMC43OTYxXSxcbiAgICBcIjg1XCI6IFswLCAwLjY4NjExLCAwLjE3MjA4LCAwLCAwLjg4MDgzXSxcbiAgICBcIjg2XCI6IFswLCAwLjY4NjExLCAwLjE4NjI1LCAwLCAwLjg2NTU1XSxcbiAgICBcIjg3XCI6IFswLCAwLjY4NjExLCAwLjE4NjI1LCAwLCAxLjE1OTk5XSxcbiAgICBcIjg4XCI6IFswLCAwLjY4NjExLCAwLjE1NjgxLCAwLCAwLjg2NTU1XSxcbiAgICBcIjg5XCI6IFswLCAwLjY4NjExLCAwLjE5ODAzLCAwLCAwLjg2NTU1XSxcbiAgICBcIjkwXCI6IFswLCAwLjY4NjExLCAwLjE0MjA4LCAwLCAwLjcwODg4XSxcbiAgICBcIjkxXCI6IFswLjI1LCAwLjc1LCAwLjE4NzUsIDAsIDAuMzU2MTFdLFxuICAgIFwiOTNcIjogWzAuMjUsIDAuNzUsIDAuMDk5NzIsIDAsIDAuMzU2MTFdLFxuICAgIFwiOTRcIjogWzAsIDAuNjk0NDQsIDAuMDY3MDksIDAsIDAuNTkxMTFdLFxuICAgIFwiOTVcIjogWzAuMzEsIDAuMTM0NDQsIDAuMDk4MTEsIDAsIDAuNTkxMTFdLFxuICAgIFwiOTdcIjogWzAsIDAuNDQ0NDQsIDAuMDk0MjYsIDAsIDAuNTkxMTFdLFxuICAgIFwiOThcIjogWzAsIDAuNjk0NDQsIDAuMDc4NjEsIDAsIDAuNTMyMjJdLFxuICAgIFwiOTlcIjogWzAsIDAuNDQ0NDQsIDAuMDUyMjIsIDAsIDAuNTMyMjJdLFxuICAgIFwiMTAwXCI6IFswLCAwLjY5NDQ0LCAwLjEwODYxLCAwLCAwLjU5MTExXSxcbiAgICBcIjEwMVwiOiBbMCwgMC40NDQ0NCwgMC4wODUsIDAsIDAuNTMyMjJdLFxuICAgIFwiMTAyXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjIxNzc4LCAwLCAwLjRdLFxuICAgIFwiMTAzXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjEwNSwgMCwgMC41MzIyMl0sXG4gICAgXCIxMDRcIjogWzAsIDAuNjk0NDQsIDAuMDk0MjYsIDAsIDAuNTkxMTFdLFxuICAgIFwiMTA1XCI6IFswLCAwLjY5MzI2LCAwLjExMzg3LCAwLCAwLjM1NTU1XSxcbiAgICBcIjEwNlwiOiBbMC4xOTQ0NCwgMC42OTMyNiwgMC4xNjcyLCAwLCAwLjM1NTU1XSxcbiAgICBcIjEwN1wiOiBbMCwgMC42OTQ0NCwgMC4xMTExMSwgMCwgMC41MzIyMl0sXG4gICAgXCIxMDhcIjogWzAsIDAuNjk0NDQsIDAuMTA4NjEsIDAsIDAuMjk2NjZdLFxuICAgIFwiMTA5XCI6IFswLCAwLjQ0NDQ0LCAwLjA5NDI2LCAwLCAwLjk0NDQ0XSxcbiAgICBcIjExMFwiOiBbMCwgMC40NDQ0NCwgMC4wOTQyNiwgMCwgMC42NDk5OV0sXG4gICAgXCIxMTFcIjogWzAsIDAuNDQ0NDQsIDAuMDc4NjEsIDAsIDAuNTkxMTFdLFxuICAgIFwiMTEyXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjA3ODYxLCAwLCAwLjU5MTExXSxcbiAgICBcIjExM1wiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMC4xMDUsIDAsIDAuNTMyMjJdLFxuICAgIFwiMTE0XCI6IFswLCAwLjQ0NDQ0LCAwLjExMTExLCAwLCAwLjUwMTY3XSxcbiAgICBcIjExNVwiOiBbMCwgMC40NDQ0NCwgMC4wODE2NywgMCwgMC40ODY5NF0sXG4gICAgXCIxMTZcIjogWzAsIDAuNjM0OTIsIDAuMDk2MzksIDAsIDAuMzg1XSxcbiAgICBcIjExN1wiOiBbMCwgMC40NDQ0NCwgMC4wOTQyNiwgMCwgMC42MjA1NV0sXG4gICAgXCIxMThcIjogWzAsIDAuNDQ0NDQsIDAuMTExMTEsIDAsIDAuNTMyMjJdLFxuICAgIFwiMTE5XCI6IFswLCAwLjQ0NDQ0LCAwLjExMTExLCAwLCAwLjc2Nzc3XSxcbiAgICBcIjEyMFwiOiBbMCwgMC40NDQ0NCwgMC4xMjU4MywgMCwgMC41NjA1NV0sXG4gICAgXCIxMjFcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMTA1LCAwLCAwLjU2MTY2XSxcbiAgICBcIjEyMlwiOiBbMCwgMC40NDQ0NCwgMC4xMzg4OSwgMCwgMC40OTA1NV0sXG4gICAgXCIxMjZcIjogWzAuMzUsIDAuMzQ0NDQsIDAuMTE0NzIsIDAsIDAuNTkxMTFdLFxuICAgIFwiMTYwXCI6IFswLCAwLCAwLCAwLCAwLjI1XSxcbiAgICBcIjE2OFwiOiBbMCwgMC42OTQ0NCwgMC4xMTQ3MywgMCwgMC41OTExMV0sXG4gICAgXCIxNzZcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuOTQ4ODhdLFxuICAgIFwiMTg0XCI6IFswLjE3MDE0LCAwLCAwLCAwLCAwLjUzMjIyXSxcbiAgICBcIjE5OFwiOiBbMCwgMC42ODYxMSwgMC4xMTQzMSwgMCwgMS4wMjI3N10sXG4gICAgXCIyMTZcIjogWzAuMDQ4NjEsIDAuNzM0NzIsIDAuMDkwNjIsIDAsIDAuODg1NTVdLFxuICAgIFwiMjIzXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjA5NzM2LCAwLCAwLjY2NV0sXG4gICAgXCIyMzBcIjogWzAsIDAuNDQ0NDQsIDAuMDg1LCAwLCAwLjgyNjY2XSxcbiAgICBcIjI0OFwiOiBbMC4wOTcyMiwgMC41NDE2NywgMC4wOTQ1OCwgMCwgMC41OTExMV0sXG4gICAgXCIzMDVcIjogWzAsIDAuNDQ0NDQsIDAuMDk0MjYsIDAsIDAuMzU1NTVdLFxuICAgIFwiMzM4XCI6IFswLCAwLjY4NjExLCAwLjExNDMxLCAwLCAxLjE0MDU0XSxcbiAgICBcIjMzOVwiOiBbMCwgMC40NDQ0NCwgMC4wODUsIDAsIDAuODI2NjZdLFxuICAgIFwiNTY3XCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjA0NjExLCAwLCAwLjM4NV0sXG4gICAgXCI3MTBcIjogWzAsIDAuNjk0NDQsIDAuMDY3MDksIDAsIDAuNTkxMTFdLFxuICAgIFwiNzExXCI6IFswLCAwLjYzMTk0LCAwLjA4MjcxLCAwLCAwLjU5MTExXSxcbiAgICBcIjcxM1wiOiBbMCwgMC41OTQ0NCwgMC4xMDQ0NCwgMCwgMC41OTExMV0sXG4gICAgXCI3MTRcIjogWzAsIDAuNjk0NDQsIDAuMDg1MjgsIDAsIDAuNTkxMTFdLFxuICAgIFwiNzE1XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU5MTExXSxcbiAgICBcIjcyOFwiOiBbMCwgMC42OTQ0NCwgMC4xMDMzMywgMCwgMC41OTExMV0sXG4gICAgXCI3MjlcIjogWzAsIDAuNjk0NDQsIDAuMTI5NDUsIDAsIDAuMzU1NTVdLFxuICAgIFwiNzMwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjk0ODg4XSxcbiAgICBcIjczMlwiOiBbMCwgMC42OTQ0NCwgMC4xMTQ3MiwgMCwgMC41OTExMV0sXG4gICAgXCI3MzNcIjogWzAsIDAuNjk0NDQsIDAuMTE0NzIsIDAsIDAuNTkxMTFdLFxuICAgIFwiOTE1XCI6IFswLCAwLjY4NjExLCAwLjEyOTAzLCAwLCAwLjY5Nzc3XSxcbiAgICBcIjkxNlwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC45NDQ0NF0sXG4gICAgXCI5MjBcIjogWzAsIDAuNjg2MTEsIDAuMDkwNjIsIDAsIDAuODg1NTVdLFxuICAgIFwiOTIzXCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjgwNjY2XSxcbiAgICBcIjkyNlwiOiBbMCwgMC42ODYxMSwgMC4xNTA5MiwgMCwgMC43Njc3N10sXG4gICAgXCI5MjhcIjogWzAsIDAuNjg2MTEsIDAuMTcyMDgsIDAsIDAuODk2MV0sXG4gICAgXCI5MzFcIjogWzAsIDAuNjg2MTEsIDAuMTE0MzEsIDAsIDAuODI2NjZdLFxuICAgIFwiOTMzXCI6IFswLCAwLjY4NjExLCAwLjEwNzc4LCAwLCAwLjg4NTU1XSxcbiAgICBcIjkzNFwiOiBbMCwgMC42ODYxMSwgMC4wNTYzMiwgMCwgMC44MjY2Nl0sXG4gICAgXCI5MzZcIjogWzAsIDAuNjg2MTEsIDAuMTA3NzgsIDAsIDAuODg1NTVdLFxuICAgIFwiOTM3XCI6IFswLCAwLjY4NjExLCAwLjA5OTIsIDAsIDAuODI2NjZdLFxuICAgIFwiODIxMVwiOiBbMCwgMC40NDQ0NCwgMC4wOTgxMSwgMCwgMC41OTExMV0sXG4gICAgXCI4MjEyXCI6IFswLCAwLjQ0NDQ0LCAwLjA5ODExLCAwLCAxLjE4MjIxXSxcbiAgICBcIjgyMTZcIjogWzAsIDAuNjk0NDQsIDAuMTI5NDUsIDAsIDAuMzU1NTVdLFxuICAgIFwiODIxN1wiOiBbMCwgMC42OTQ0NCwgMC4xMjk0NSwgMCwgMC4zNTU1NV0sXG4gICAgXCI4MjIwXCI6IFswLCAwLjY5NDQ0LCAwLjE2NzcyLCAwLCAwLjYyMDU1XSxcbiAgICBcIjgyMjFcIjogWzAsIDAuNjk0NDQsIDAuMDc5MzksIDAsIDAuNjIwNTVdXG4gIH0sXG4gIFwiTWFpbi1JdGFsaWNcIjoge1xuICAgIFwiMzJcIjogWzAsIDAsIDAsIDAsIDAuMjVdLFxuICAgIFwiMzNcIjogWzAsIDAuNjk0NDQsIDAuMTI0MTcsIDAsIDAuMzA2NjddLFxuICAgIFwiMzRcIjogWzAsIDAuNjk0NDQsIDAuMDY5NjEsIDAsIDAuNTE0NDRdLFxuICAgIFwiMzVcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMDY2MTYsIDAsIDAuODE3NzddLFxuICAgIFwiMzdcIjogWzAuMDU1NTYsIDAuNzUsIDAuMTM2MzksIDAsIDAuODE3NzddLFxuICAgIFwiMzhcIjogWzAsIDAuNjk0NDQsIDAuMDk2OTQsIDAsIDAuNzY2NjZdLFxuICAgIFwiMzlcIjogWzAsIDAuNjk0NDQsIDAuMTI0MTcsIDAsIDAuMzA2NjddLFxuICAgIFwiNDBcIjogWzAuMjUsIDAuNzUsIDAuMTYxOTQsIDAsIDAuNDA4ODldLFxuICAgIFwiNDFcIjogWzAuMjUsIDAuNzUsIDAuMDM2OTQsIDAsIDAuNDA4ODldLFxuICAgIFwiNDJcIjogWzAsIDAuNzUsIDAuMTQ5MTcsIDAsIDAuNTExMTFdLFxuICAgIFwiNDNcIjogWzAuMDU2NjcsIDAuNTYxNjcsIDAuMDM2OTQsIDAsIDAuNzY2NjZdLFxuICAgIFwiNDRcIjogWzAuMTk0NDQsIDAuMTA1NTYsIDAsIDAsIDAuMzA2NjddLFxuICAgIFwiNDVcIjogWzAsIDAuNDMwNTYsIDAuMDI4MjYsIDAsIDAuMzU3NzhdLFxuICAgIFwiNDZcIjogWzAsIDAuMTA1NTYsIDAsIDAsIDAuMzA2NjddLFxuICAgIFwiNDdcIjogWzAuMjUsIDAuNzUsIDAuMTYxOTQsIDAsIDAuNTExMTFdLFxuICAgIFwiNDhcIjogWzAsIDAuNjQ0NDQsIDAuMTM1NTYsIDAsIDAuNTExMTFdLFxuICAgIFwiNDlcIjogWzAsIDAuNjQ0NDQsIDAuMTM1NTYsIDAsIDAuNTExMTFdLFxuICAgIFwiNTBcIjogWzAsIDAuNjQ0NDQsIDAuMTM1NTYsIDAsIDAuNTExMTFdLFxuICAgIFwiNTFcIjogWzAsIDAuNjQ0NDQsIDAuMTM1NTYsIDAsIDAuNTExMTFdLFxuICAgIFwiNTJcIjogWzAuMTk0NDQsIDAuNjQ0NDQsIDAuMTM1NTYsIDAsIDAuNTExMTFdLFxuICAgIFwiNTNcIjogWzAsIDAuNjQ0NDQsIDAuMTM1NTYsIDAsIDAuNTExMTFdLFxuICAgIFwiNTRcIjogWzAsIDAuNjQ0NDQsIDAuMTM1NTYsIDAsIDAuNTExMTFdLFxuICAgIFwiNTVcIjogWzAuMTk0NDQsIDAuNjQ0NDQsIDAuMTM1NTYsIDAsIDAuNTExMTFdLFxuICAgIFwiNTZcIjogWzAsIDAuNjQ0NDQsIDAuMTM1NTYsIDAsIDAuNTExMTFdLFxuICAgIFwiNTdcIjogWzAsIDAuNjQ0NDQsIDAuMTM1NTYsIDAsIDAuNTExMTFdLFxuICAgIFwiNThcIjogWzAsIDAuNDMwNTYsIDAuMDU4MiwgMCwgMC4zMDY2N10sXG4gICAgXCI1OVwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wNTgyLCAwLCAwLjMwNjY3XSxcbiAgICBcIjYxXCI6IFstMC4xMzMxMywgMC4zNjY4NywgMC4wNjYxNiwgMCwgMC43NjY2Nl0sXG4gICAgXCI2M1wiOiBbMCwgMC42OTQ0NCwgMC4xMjI1LCAwLCAwLjUxMTExXSxcbiAgICBcIjY0XCI6IFswLCAwLjY5NDQ0LCAwLjA5NTk3LCAwLCAwLjc2NjY2XSxcbiAgICBcIjY1XCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjc0MzMzXSxcbiAgICBcIjY2XCI6IFswLCAwLjY4MzMzLCAwLjEwMjU3LCAwLCAwLjcwMzg5XSxcbiAgICBcIjY3XCI6IFswLCAwLjY4MzMzLCAwLjE0NTI4LCAwLCAwLjcxNTU1XSxcbiAgICBcIjY4XCI6IFswLCAwLjY4MzMzLCAwLjA5NDAzLCAwLCAwLjc1NV0sXG4gICAgXCI2OVwiOiBbMCwgMC42ODMzMywgMC4xMjAyOCwgMCwgMC42NzgzM10sXG4gICAgXCI3MFwiOiBbMCwgMC42ODMzMywgMC4xMzMwNSwgMCwgMC42NTI3N10sXG4gICAgXCI3MVwiOiBbMCwgMC42ODMzMywgMC4wODcyMiwgMCwgMC43NzM2MV0sXG4gICAgXCI3MlwiOiBbMCwgMC42ODMzMywgMC4xNjM4OSwgMCwgMC43NDMzM10sXG4gICAgXCI3M1wiOiBbMCwgMC42ODMzMywgMC4xNTgwNiwgMCwgMC4zODU1NV0sXG4gICAgXCI3NFwiOiBbMCwgMC42ODMzMywgMC4xNDAyOCwgMCwgMC41MjVdLFxuICAgIFwiNzVcIjogWzAsIDAuNjgzMzMsIDAuMTQ1MjgsIDAsIDAuNzY4ODhdLFxuICAgIFwiNzZcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNjI3MjJdLFxuICAgIFwiNzdcIjogWzAsIDAuNjgzMzMsIDAuMTYzODksIDAsIDAuODk2NjZdLFxuICAgIFwiNzhcIjogWzAsIDAuNjgzMzMsIDAuMTYzODksIDAsIDAuNzQzMzNdLFxuICAgIFwiNzlcIjogWzAsIDAuNjgzMzMsIDAuMDk0MDMsIDAsIDAuNzY2NjZdLFxuICAgIFwiODBcIjogWzAsIDAuNjgzMzMsIDAuMTAyNTcsIDAsIDAuNjc4MzNdLFxuICAgIFwiODFcIjogWzAuMTk0NDQsIDAuNjgzMzMsIDAuMDk0MDMsIDAsIDAuNzY2NjZdLFxuICAgIFwiODJcIjogWzAsIDAuNjgzMzMsIDAuMDM4NjgsIDAsIDAuNzI5NDRdLFxuICAgIFwiODNcIjogWzAsIDAuNjgzMzMsIDAuMTE5NzIsIDAsIDAuNTYyMjJdLFxuICAgIFwiODRcIjogWzAsIDAuNjgzMzMsIDAuMTMzMDUsIDAsIDAuNzE1NTVdLFxuICAgIFwiODVcIjogWzAsIDAuNjgzMzMsIDAuMTYzODksIDAsIDAuNzQzMzNdLFxuICAgIFwiODZcIjogWzAsIDAuNjgzMzMsIDAuMTgzNjEsIDAsIDAuNzQzMzNdLFxuICAgIFwiODdcIjogWzAsIDAuNjgzMzMsIDAuMTgzNjEsIDAsIDAuOTk4ODhdLFxuICAgIFwiODhcIjogWzAsIDAuNjgzMzMsIDAuMTU4MDYsIDAsIDAuNzQzMzNdLFxuICAgIFwiODlcIjogWzAsIDAuNjgzMzMsIDAuMTkzODMsIDAsIDAuNzQzMzNdLFxuICAgIFwiOTBcIjogWzAsIDAuNjgzMzMsIDAuMTQ1MjgsIDAsIDAuNjEzMzNdLFxuICAgIFwiOTFcIjogWzAuMjUsIDAuNzUsIDAuMTg3NSwgMCwgMC4zMDY2N10sXG4gICAgXCI5M1wiOiBbMC4yNSwgMC43NSwgMC4xMDUyOCwgMCwgMC4zMDY2N10sXG4gICAgXCI5NFwiOiBbMCwgMC42OTQ0NCwgMC4wNjY0NiwgMCwgMC41MTExMV0sXG4gICAgXCI5NVwiOiBbMC4zMSwgMC4xMjA1NiwgMC4wOTIwOCwgMCwgMC41MTExMV0sXG4gICAgXCI5N1wiOiBbMCwgMC40MzA1NiwgMC4wNzY3MSwgMCwgMC41MTExMV0sXG4gICAgXCI5OFwiOiBbMCwgMC42OTQ0NCwgMC4wNjMxMiwgMCwgMC40Nl0sXG4gICAgXCI5OVwiOiBbMCwgMC40MzA1NiwgMC4wNTY1MywgMCwgMC40Nl0sXG4gICAgXCIxMDBcIjogWzAsIDAuNjk0NDQsIDAuMTAzMzMsIDAsIDAuNTExMTFdLFxuICAgIFwiMTAxXCI6IFswLCAwLjQzMDU2LCAwLjA3NTE0LCAwLCAwLjQ2XSxcbiAgICBcIjEwMlwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4yMTE5NCwgMCwgMC4zMDY2N10sXG4gICAgXCIxMDNcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAuMDg4NDcsIDAsIDAuNDZdLFxuICAgIFwiMTA0XCI6IFswLCAwLjY5NDQ0LCAwLjA3NjcxLCAwLCAwLjUxMTExXSxcbiAgICBcIjEwNVwiOiBbMCwgMC42NTUzNiwgMC4xMDE5LCAwLCAwLjMwNjY3XSxcbiAgICBcIjEwNlwiOiBbMC4xOTQ0NCwgMC42NTUzNiwgMC4xNDQ2NywgMCwgMC4zMDY2N10sXG4gICAgXCIxMDdcIjogWzAsIDAuNjk0NDQsIDAuMTA3NjQsIDAsIDAuNDZdLFxuICAgIFwiMTA4XCI6IFswLCAwLjY5NDQ0LCAwLjEwMzMzLCAwLCAwLjI1NTU1XSxcbiAgICBcIjEwOVwiOiBbMCwgMC40MzA1NiwgMC4wNzY3MSwgMCwgMC44MTc3N10sXG4gICAgXCIxMTBcIjogWzAsIDAuNDMwNTYsIDAuMDc2NzEsIDAsIDAuNTYyMjJdLFxuICAgIFwiMTExXCI6IFswLCAwLjQzMDU2LCAwLjA2MzEyLCAwLCAwLjUxMTExXSxcbiAgICBcIjExMlwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wNjMxMiwgMCwgMC41MTExMV0sXG4gICAgXCIxMTNcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAuMDg4NDcsIDAsIDAuNDZdLFxuICAgIFwiMTE0XCI6IFswLCAwLjQzMDU2LCAwLjEwNzY0LCAwLCAwLjQyMTY2XSxcbiAgICBcIjExNVwiOiBbMCwgMC40MzA1NiwgMC4wODIwOCwgMCwgMC40MDg4OV0sXG4gICAgXCIxMTZcIjogWzAsIDAuNjE1MDgsIDAuMDk0ODYsIDAsIDAuMzMyMjJdLFxuICAgIFwiMTE3XCI6IFswLCAwLjQzMDU2LCAwLjA3NjcxLCAwLCAwLjUzNjY2XSxcbiAgICBcIjExOFwiOiBbMCwgMC40MzA1NiwgMC4xMDc2NCwgMCwgMC40Nl0sXG4gICAgXCIxMTlcIjogWzAsIDAuNDMwNTYsIDAuMTA3NjQsIDAsIDAuNjY0NDRdLFxuICAgIFwiMTIwXCI6IFswLCAwLjQzMDU2LCAwLjEyMDQyLCAwLCAwLjQ2Mzg5XSxcbiAgICBcIjEyMVwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wODg0NywgMCwgMC40ODU1NV0sXG4gICAgXCIxMjJcIjogWzAsIDAuNDMwNTYsIDAuMTIyOTIsIDAsIDAuNDA4ODldLFxuICAgIFwiMTI2XCI6IFswLjM1LCAwLjMxNzg2LCAwLjExNTg1LCAwLCAwLjUxMTExXSxcbiAgICBcIjE2MFwiOiBbMCwgMCwgMCwgMCwgMC4yNV0sXG4gICAgXCIxNjhcIjogWzAsIDAuNjY3ODYsIDAuMTA0NzQsIDAsIDAuNTExMTFdLFxuICAgIFwiMTc2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjgzMTI5XSxcbiAgICBcIjE4NFwiOiBbMC4xNzAxNCwgMCwgMCwgMCwgMC40Nl0sXG4gICAgXCIxOThcIjogWzAsIDAuNjgzMzMsIDAuMTIwMjgsIDAsIDAuODgyNzddLFxuICAgIFwiMjE2XCI6IFswLjA0ODYxLCAwLjczMTk0LCAwLjA5NDAzLCAwLCAwLjc2NjY2XSxcbiAgICBcIjIyM1wiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4xMDUxNCwgMCwgMC41MzY2Nl0sXG4gICAgXCIyMzBcIjogWzAsIDAuNDMwNTYsIDAuMDc1MTQsIDAsIDAuNzE1NTVdLFxuICAgIFwiMjQ4XCI6IFswLjA5NzIyLCAwLjUyNzc4LCAwLjA5MTk0LCAwLCAwLjUxMTExXSxcbiAgICBcIjMzOFwiOiBbMCwgMC42ODMzMywgMC4xMjAyOCwgMCwgMC45ODQ5OV0sXG4gICAgXCIzMzlcIjogWzAsIDAuNDMwNTYsIDAuMDc1MTQsIDAsIDAuNzE1NTVdLFxuICAgIFwiNzEwXCI6IFswLCAwLjY5NDQ0LCAwLjA2NjQ2LCAwLCAwLjUxMTExXSxcbiAgICBcIjcxMVwiOiBbMCwgMC42Mjg0NywgMC4wODI5NSwgMCwgMC41MTExMV0sXG4gICAgXCI3MTNcIjogWzAsIDAuNTYxNjcsIDAuMTAzMzMsIDAsIDAuNTExMTFdLFxuICAgIFwiNzE0XCI6IFswLCAwLjY5NDQ0LCAwLjA5Njk0LCAwLCAwLjUxMTExXSxcbiAgICBcIjcxNVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41MTExMV0sXG4gICAgXCI3MjhcIjogWzAsIDAuNjk0NDQsIDAuMTA4MDYsIDAsIDAuNTExMTFdLFxuICAgIFwiNzI5XCI6IFswLCAwLjY2Nzg2LCAwLjExNzUyLCAwLCAwLjMwNjY3XSxcbiAgICBcIjczMFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC44MzEyOV0sXG4gICAgXCI3MzJcIjogWzAsIDAuNjY3ODYsIDAuMTE1ODUsIDAsIDAuNTExMTFdLFxuICAgIFwiNzMzXCI6IFswLCAwLjY5NDQ0LCAwLjEyMjUsIDAsIDAuNTExMTFdLFxuICAgIFwiOTE1XCI6IFswLCAwLjY4MzMzLCAwLjEzMzA1LCAwLCAwLjYyNzIyXSxcbiAgICBcIjkxNlwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC44MTc3N10sXG4gICAgXCI5MjBcIjogWzAsIDAuNjgzMzMsIDAuMDk0MDMsIDAsIDAuNzY2NjZdLFxuICAgIFwiOTIzXCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjY5MjIyXSxcbiAgICBcIjkyNlwiOiBbMCwgMC42ODMzMywgMC4xNTI5NCwgMCwgMC42NjQ0NF0sXG4gICAgXCI5MjhcIjogWzAsIDAuNjgzMzMsIDAuMTYzODksIDAsIDAuNzQzMzNdLFxuICAgIFwiOTMxXCI6IFswLCAwLjY4MzMzLCAwLjEyMDI4LCAwLCAwLjcxNTU1XSxcbiAgICBcIjkzM1wiOiBbMCwgMC42ODMzMywgMC4xMTExMSwgMCwgMC43NjY2Nl0sXG4gICAgXCI5MzRcIjogWzAsIDAuNjgzMzMsIDAuMDU5ODYsIDAsIDAuNzE1NTVdLFxuICAgIFwiOTM2XCI6IFswLCAwLjY4MzMzLCAwLjExMTExLCAwLCAwLjc2NjY2XSxcbiAgICBcIjkzN1wiOiBbMCwgMC42ODMzMywgMC4xMDI1NywgMCwgMC43MTU1NV0sXG4gICAgXCI4MjExXCI6IFswLCAwLjQzMDU2LCAwLjA5MjA4LCAwLCAwLjUxMTExXSxcbiAgICBcIjgyMTJcIjogWzAsIDAuNDMwNTYsIDAuMDkyMDgsIDAsIDEuMDIyMjJdLFxuICAgIFwiODIxNlwiOiBbMCwgMC42OTQ0NCwgMC4xMjQxNywgMCwgMC4zMDY2N10sXG4gICAgXCI4MjE3XCI6IFswLCAwLjY5NDQ0LCAwLjEyNDE3LCAwLCAwLjMwNjY3XSxcbiAgICBcIjgyMjBcIjogWzAsIDAuNjk0NDQsIDAuMTY4NSwgMCwgMC41MTQ0NF0sXG4gICAgXCI4MjIxXCI6IFswLCAwLjY5NDQ0LCAwLjA2OTYxLCAwLCAwLjUxNDQ0XSxcbiAgICBcIjg0NjNcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNTQwMjhdXG4gIH0sXG4gIFwiTWFpbi1SZWd1bGFyXCI6IHtcbiAgICBcIjMyXCI6IFswLCAwLCAwLCAwLCAwLjI1XSxcbiAgICBcIjMzXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjM0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiMzVcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuODMzMzRdLFxuICAgIFwiMzZcIjogWzAuMDU1NTYsIDAuNzUsIDAsIDAsIDAuNV0sXG4gICAgXCIzN1wiOiBbMC4wNTU1NiwgMC43NSwgMCwgMCwgMC44MzMzNF0sXG4gICAgXCIzOFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIzOVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCI0MFwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC4zODg4OV0sXG4gICAgXCI0MVwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC4zODg4OV0sXG4gICAgXCI0MlwiOiBbMCwgMC43NSwgMCwgMCwgMC41XSxcbiAgICBcIjQzXCI6IFswLjA4MzMzLCAwLjU4MzMzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjQ0XCI6IFswLjE5NDQ0LCAwLjEwNTU2LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjQ1XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjMzMzMzXSxcbiAgICBcIjQ2XCI6IFswLCAwLjEwNTU2LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjQ3XCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjVdLFxuICAgIFwiNDhcIjogWzAsIDAuNjQ0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI0OVwiOiBbMCwgMC42NDQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjUwXCI6IFswLCAwLjY0NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiNTFcIjogWzAsIDAuNjQ0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI1MlwiOiBbMCwgMC42NDQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjUzXCI6IFswLCAwLjY0NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiNTRcIjogWzAsIDAuNjQ0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI1NVwiOiBbMCwgMC42NDQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjU2XCI6IFswLCAwLjY0NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiNTdcIjogWzAsIDAuNjQ0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI1OFwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCI1OVwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCI2MFwiOiBbMC4wMzkxLCAwLjUzOTEsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiNjFcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjYyXCI6IFswLjAzOTEsIDAuNTM5MSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI2M1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC40NzIyMl0sXG4gICAgXCI2NFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI2NVwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43NV0sXG4gICAgXCI2NlwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43MDgzNF0sXG4gICAgXCI2N1wiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI2OFwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43NjM4OV0sXG4gICAgXCI2OVwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC42ODA1Nl0sXG4gICAgXCI3MFwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC42NTI3OF0sXG4gICAgXCI3MVwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43ODQ3Ml0sXG4gICAgXCI3MlwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43NV0sXG4gICAgXCI3M1wiOiBbMCwgMC42ODMzMywgMCwgMCwgMC4zNjExMV0sXG4gICAgXCI3NFwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC41MTM4OV0sXG4gICAgXCI3NVwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI3NlwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC42MjVdLFxuICAgIFwiNzdcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuOTE2NjddLFxuICAgIFwiNzhcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNzVdLFxuICAgIFwiNzlcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODBcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNjgwNTZdLFxuICAgIFwiODFcIjogWzAuMTk0NDQsIDAuNjgzMzMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODJcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNzM2MTFdLFxuICAgIFwiODNcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNTU1NTZdLFxuICAgIFwiODRcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiODVcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNzVdLFxuICAgIFwiODZcIjogWzAsIDAuNjgzMzMsIDAuMDEzODksIDAsIDAuNzVdLFxuICAgIFwiODdcIjogWzAsIDAuNjgzMzMsIDAuMDEzODksIDAsIDEuMDI3NzhdLFxuICAgIFwiODhcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNzVdLFxuICAgIFwiODlcIjogWzAsIDAuNjgzMzMsIDAuMDI1LCAwLCAwLjc1XSxcbiAgICBcIjkwXCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjYxMTExXSxcbiAgICBcIjkxXCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjkyXCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjVdLFxuICAgIFwiOTNcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuMjc3NzhdLFxuICAgIFwiOTRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI5NVwiOiBbMC4zMSwgMC4xMjA1NiwgMC4wMjc3OCwgMCwgMC41XSxcbiAgICBcIjk3XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjVdLFxuICAgIFwiOThcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTU1NTZdLFxuICAgIFwiOTlcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNDQ0NDVdLFxuICAgIFwiMTAwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU1NTU2XSxcbiAgICBcIjEwMVwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC40NDQ0NV0sXG4gICAgXCIxMDJcIjogWzAsIDAuNjk0NDQsIDAuMDc3NzgsIDAsIDAuMzA1NTZdLFxuICAgIFwiMTAzXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLjAxMzg5LCAwLCAwLjVdLFxuICAgIFwiMTA0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU1NTU2XSxcbiAgICBcIjEwNVwiOiBbMCwgMC42Njc4NiwgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCIxMDZcIjogWzAuMTk0NDQsIDAuNjY3ODYsIDAsIDAsIDAuMzA1NTZdLFxuICAgIFwiMTA3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjUyNzc4XSxcbiAgICBcIjEwOFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCIxMDlcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuODMzMzRdLFxuICAgIFwiMTEwXCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjU1NTU2XSxcbiAgICBcIjExMVwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41XSxcbiAgICBcIjExMlwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMCwgMC41NTU1Nl0sXG4gICAgXCIxMTNcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAsIDAuNTI3NzhdLFxuICAgIFwiMTE0XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjM5MTY3XSxcbiAgICBcIjExNVwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC4zOTQ0NV0sXG4gICAgXCIxMTZcIjogWzAsIDAuNjE1MDgsIDAsIDAsIDAuMzg4ODldLFxuICAgIFwiMTE3XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjU1NTU2XSxcbiAgICBcIjExOFwiOiBbMCwgMC40MzA1NiwgMC4wMTM4OSwgMCwgMC41Mjc3OF0sXG4gICAgXCIxMTlcIjogWzAsIDAuNDMwNTYsIDAuMDEzODksIDAsIDAuNzIyMjJdLFxuICAgIFwiMTIwXCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjUyNzc4XSxcbiAgICBcIjEyMVwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wMTM4OSwgMCwgMC41Mjc3OF0sXG4gICAgXCIxMjJcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNDQ0NDVdLFxuICAgIFwiMTIzXCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjVdLFxuICAgIFwiMTI0XCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjEyNVwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC41XSxcbiAgICBcIjEyNlwiOiBbMC4zNSwgMC4zMTc4NiwgMCwgMCwgMC41XSxcbiAgICBcIjE2MFwiOiBbMCwgMCwgMCwgMCwgMC4yNV0sXG4gICAgXCIxNjNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzY5MDldLFxuICAgIFwiMTY3XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjQ0NDQ1XSxcbiAgICBcIjE2OFwiOiBbMCwgMC42Njc4NiwgMCwgMCwgMC41XSxcbiAgICBcIjE3MlwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC42NjY2N10sXG4gICAgXCIxNzZcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzVdLFxuICAgIFwiMTc3XCI6IFswLjA4MzMzLCAwLjU4MzMzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjE4MlwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC42MTExMV0sXG4gICAgXCIxODRcIjogWzAuMTcwMTQsIDAsIDAsIDAsIDAuNDQ0NDVdLFxuICAgIFwiMTk4XCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjkwMjc4XSxcbiAgICBcIjIxNVwiOiBbMC4wODMzMywgMC41ODMzMywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIyMTZcIjogWzAuMDQ4NjEsIDAuNzMxOTQsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiMjIzXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiMjMwXCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjI0N1wiOiBbMC4wODMzMywgMC41ODMzMywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIyNDhcIjogWzAuMDk3MjIsIDAuNTI3NzgsIDAsIDAsIDAuNV0sXG4gICAgXCIzMDVcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuMjc3NzhdLFxuICAgIFwiMzM4XCI6IFswLCAwLjY4MzMzLCAwLCAwLCAxLjAxMzg5XSxcbiAgICBcIjMzOVwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI1NjdcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAsIDAuMzA1NTZdLFxuICAgIFwiNzEwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiNzExXCI6IFswLCAwLjYyODQ3LCAwLCAwLCAwLjVdLFxuICAgIFwiNzEzXCI6IFswLCAwLjU2Nzc4LCAwLCAwLCAwLjVdLFxuICAgIFwiNzE0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiNzE1XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiNzI4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiNzI5XCI6IFswLCAwLjY2Nzg2LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjczMFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43NV0sXG4gICAgXCI3MzJcIjogWzAsIDAuNjY3ODYsIDAsIDAsIDAuNV0sXG4gICAgXCI3MzNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI5MTVcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNjI1XSxcbiAgICBcIjkxNlwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC44MzMzNF0sXG4gICAgXCI5MjBcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiOTIzXCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjY5NDQ1XSxcbiAgICBcIjkyNlwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC42NjY2N10sXG4gICAgXCI5MjhcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNzVdLFxuICAgIFwiOTMxXCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjkzM1wiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI5MzRcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiOTM2XCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjkzN1wiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI4MjExXCI6IFswLCAwLjQzMDU2LCAwLjAyNzc4LCAwLCAwLjVdLFxuICAgIFwiODIxMlwiOiBbMCwgMC40MzA1NiwgMC4wMjc3OCwgMCwgMS4wXSxcbiAgICBcIjgyMTZcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMjc3NzhdLFxuICAgIFwiODIxN1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCI4MjIwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiODIyMVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjgyMjRcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuNDQ0NDVdLFxuICAgIFwiODIyNVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC40NDQ0NV0sXG4gICAgXCI4MjMwXCI6IFswLCAwLjEyMywgMCwgMCwgMS4xNzJdLFxuICAgIFwiODI0MlwiOiBbMCwgMC41NTU1NiwgMCwgMCwgMC4yNzVdLFxuICAgIFwiODQwN1wiOiBbMCwgMC43MTQ0NCwgMC4xNTM4MiwgMCwgMC41XSxcbiAgICBcIjg0NjNcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNTQwMjhdLFxuICAgIFwiODQ2NVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI4NDY3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLjExMTExLCAwLjQxNjY3XSxcbiAgICBcIjg0NzJcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMTExMTEsIDAuNjM2NDZdLFxuICAgIFwiODQ3NlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI4NTAxXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjYxMTExXSxcbiAgICBcIjg1OTJcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwLCAxLjBdLFxuICAgIFwiODU5M1wiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjg1OTRcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwLCAxLjBdLFxuICAgIFwiODU5NVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjg1OTZcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwLCAxLjBdLFxuICAgIFwiODU5N1wiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC41XSxcbiAgICBcIjg1OThcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDEuMF0sXG4gICAgXCI4NTk5XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAxLjBdLFxuICAgIFwiODYwMFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMS4wXSxcbiAgICBcIjg2MDFcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjE0XCI6IFswLjAxMSwgMC41MTEsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjE3XCI6IFswLjAxMSwgMC41MTEsIDAsIDAsIDEuMTI2XSxcbiAgICBcIjg2MThcIjogWzAuMDExLCAwLjUxMSwgMCwgMCwgMS4xMjZdLFxuICAgIFwiODYzNlwiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjM3XCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMCwgMS4wXSxcbiAgICBcIjg2NDBcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwLCAxLjBdLFxuICAgIFwiODY0MVwiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjUyXCI6IFswLjAxMSwgMC42NzEsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjU2XCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMCwgMS4wXSxcbiAgICBcIjg2NTdcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuNjExMTFdLFxuICAgIFwiODY1OFwiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjU5XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjYxMTExXSxcbiAgICBcIjg2NjBcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwLCAxLjBdLFxuICAgIFwiODY2MVwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC42MTExMV0sXG4gICAgXCI4NzA0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU1NTU2XSxcbiAgICBcIjg3MDZcIjogWzAsIDAuNjk0NDQsIDAuMDU1NTYsIDAuMDgzMzQsIDAuNTMwOV0sXG4gICAgXCI4NzA3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU1NTU2XSxcbiAgICBcIjg3MDlcIjogWzAuMDU1NTYsIDAuNzUsIDAsIDAsIDAuNV0sXG4gICAgXCI4NzExXCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjgzMzM0XSxcbiAgICBcIjg3MTJcIjogWzAuMDM5MSwgMC41MzkxLCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjg3MTVcIjogWzAuMDM5MSwgMC41MzkxLCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjg3MjJcIjogWzAuMDgzMzMsIDAuNTgzMzMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODcyM1wiOiBbMC4wODMzMywgMC41ODMzMywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4NzI1XCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjVdLFxuICAgIFwiODcyNlwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC41XSxcbiAgICBcIjg3MjdcIjogWy0wLjAzNDcyLCAwLjQ2NTI4LCAwLCAwLCAwLjVdLFxuICAgIFwiODcyOFwiOiBbLTAuMDU1NTUsIDAuNDQ0NDUsIDAsIDAsIDAuNV0sXG4gICAgXCI4NzI5XCI6IFstMC4wNTU1NSwgMC40NDQ0NSwgMCwgMCwgMC41XSxcbiAgICBcIjg3MzBcIjogWzAuMiwgMC44LCAwLCAwLCAwLjgzMzM0XSxcbiAgICBcIjg3MzNcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODczNFwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMS4wXSxcbiAgICBcIjg3MzZcIjogWzAsIDAuNjkyMjQsIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiODczOVwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCI4NzQxXCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjVdLFxuICAgIFwiODc0M1wiOiBbMCwgMC41NTU1NiwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI4NzQ0XCI6IFswLCAwLjU1NTU2LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjg3NDVcIjogWzAsIDAuNTU1NTYsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiODc0NlwiOiBbMCwgMC41NTU1NiwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI4NzQ3XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjExMTExLCAwLCAwLjQxNjY3XSxcbiAgICBcIjg3NjRcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg3NjhcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuMjc3NzhdLFxuICAgIFwiODc3MVwiOiBbLTAuMDM2MjUsIDAuNDYzNzUsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODc3M1wiOiBbLTAuMDIyLCAwLjU4OSwgMCwgMCwgMC43NzhdLFxuICAgIFwiODc3NlwiOiBbLTAuMDE2ODgsIDAuNDgzMTIsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODc4MVwiOiBbLTAuMDM2MjUsIDAuNDYzNzUsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODc4NFwiOiBbLTAuMTMzLCAwLjY3MywgMCwgMCwgMC43NzhdLFxuICAgIFwiODgwMVwiOiBbLTAuMDM2MjUsIDAuNDYzNzUsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODgwNFwiOiBbMC4xMzU5NywgMC42MzU5NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODA1XCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4MTBcIjogWzAuMDM5MSwgMC41MzkxLCAwLCAwLCAxLjBdLFxuICAgIFwiODgxMVwiOiBbMC4wMzkxLCAwLjUzOTEsIDAsIDAsIDEuMF0sXG4gICAgXCI4ODI2XCI6IFswLjAzOTEsIDAuNTM5MSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODI3XCI6IFswLjAzOTEsIDAuNTM5MSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODM0XCI6IFswLjAzOTEsIDAuNTM5MSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODM1XCI6IFswLjAzOTEsIDAuNTM5MSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODM4XCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4MzlcIjogWzAuMTM1OTcsIDAuNjM1OTcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg0NlwiOiBbMCwgMC41NTU1NiwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI4ODQ5XCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4NTBcIjogWzAuMTM1OTcsIDAuNjM1OTcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg1MVwiOiBbMCwgMC41NTU1NiwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI4ODUyXCI6IFswLCAwLjU1NTU2LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjg4NTNcIjogWzAuMDgzMzMsIDAuNTgzMzMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg1NFwiOiBbMC4wODMzMywgMC41ODMzMywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODU1XCI6IFswLjA4MzMzLCAwLjU4MzMzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4NTZcIjogWzAuMDgzMzMsIDAuNTgzMzMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg1N1wiOiBbMC4wODMzMywgMC41ODMzMywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODY2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjYxMTExXSxcbiAgICBcIjg4NjdcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjExMTFdLFxuICAgIFwiODg2OFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODY5XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4NzJcIjogWzAuMjQ5LCAwLjc1LCAwLCAwLCAwLjg2N10sXG4gICAgXCI4OTAwXCI6IFstMC4wNTU1NSwgMC40NDQ0NSwgMCwgMCwgMC41XSxcbiAgICBcIjg5MDFcIjogWy0wLjA1NTU1LCAwLjQ0NDQ1LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjg5MDJcIjogWy0wLjAzNDcyLCAwLjQ2NTI4LCAwLCAwLCAwLjVdLFxuICAgIFwiODkwNFwiOiBbMC4wMDUsIDAuNTA1LCAwLCAwLCAwLjldLFxuICAgIFwiODk0MlwiOiBbMC4wMywgMC45MDMsIDAsIDAsIDAuMjc4XSxcbiAgICBcIjg5NDNcIjogWy0wLjE5LCAwLjMxMywgMCwgMCwgMS4xNzJdLFxuICAgIFwiODk0NVwiOiBbLTAuMSwgMC44MjMsIDAsIDAsIDEuMjgyXSxcbiAgICBcIjg5NjhcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNDQ0NDVdLFxuICAgIFwiODk2OVwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC40NDQ0NV0sXG4gICAgXCI4OTcwXCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjQ0NDQ1XSxcbiAgICBcIjg5NzFcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNDQ0NDVdLFxuICAgIFwiODk5NFwiOiBbLTAuMTQyMzYsIDAuMzU3NjQsIDAsIDAsIDEuMF0sXG4gICAgXCI4OTk1XCI6IFstMC4xNDIzNiwgMC4zNTc2NCwgMCwgMCwgMS4wXSxcbiAgICBcIjkxMzZcIjogWzAuMjQ0LCAwLjc0NCwgMCwgMCwgMC40MTJdLFxuICAgIFwiOTEzN1wiOiBbMC4yNDQsIDAuNzQ1LCAwLCAwLCAwLjQxMl0sXG4gICAgXCI5NjUxXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjg4ODg5XSxcbiAgICBcIjk2NTdcIjogWy0wLjAzNDcyLCAwLjQ2NTI4LCAwLCAwLCAwLjVdLFxuICAgIFwiOTY2MVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC44ODg4OV0sXG4gICAgXCI5NjY3XCI6IFstMC4wMzQ3MiwgMC40NjUyOCwgMCwgMCwgMC41XSxcbiAgICBcIjk3MTFcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDEuMF0sXG4gICAgXCI5ODI0XCI6IFswLjEyOTYzLCAwLjY5NDQ0LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjk4MjVcIjogWzAuMTI5NjMsIDAuNjk0NDQsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiOTgyNlwiOiBbMC4xMjk2MywgMC42OTQ0NCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI5ODI3XCI6IFswLjEyOTYzLCAwLjY5NDQ0LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjk4MzdcIjogWzAsIDAuNzUsIDAsIDAsIDAuMzg4ODldLFxuICAgIFwiOTgzOFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC4zODg4OV0sXG4gICAgXCI5ODM5XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjM4ODg5XSxcbiAgICBcIjEwMjE2XCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjM4ODg5XSxcbiAgICBcIjEwMjE3XCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjM4ODg5XSxcbiAgICBcIjEwMjIyXCI6IFswLjI0NCwgMC43NDQsIDAsIDAsIDAuNDEyXSxcbiAgICBcIjEwMjIzXCI6IFswLjI0NCwgMC43NDUsIDAsIDAsIDAuNDEyXSxcbiAgICBcIjEwMjI5XCI6IFswLjAxMSwgMC41MTEsIDAsIDAsIDEuNjA5XSxcbiAgICBcIjEwMjMwXCI6IFswLjAxMSwgMC41MTEsIDAsIDAsIDEuNjM4XSxcbiAgICBcIjEwMjMxXCI6IFswLjAxMSwgMC41MTEsIDAsIDAsIDEuODU5XSxcbiAgICBcIjEwMjMyXCI6IFswLjAyNCwgMC41MjUsIDAsIDAsIDEuNjA5XSxcbiAgICBcIjEwMjMzXCI6IFswLjAyNCwgMC41MjUsIDAsIDAsIDEuNjM4XSxcbiAgICBcIjEwMjM0XCI6IFswLjAyNCwgMC41MjUsIDAsIDAsIDEuODU4XSxcbiAgICBcIjEwMjM2XCI6IFswLjAxMSwgMC41MTEsIDAsIDAsIDEuNjM4XSxcbiAgICBcIjEwODE1XCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjc1XSxcbiAgICBcIjEwOTI3XCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjEwOTI4XCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjU3Mzc2XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwXVxuICB9LFxuICBcIk1hdGgtQm9sZEl0YWxpY1wiOiB7XG4gICAgXCIzMlwiOiBbMCwgMCwgMCwgMCwgMC4yNV0sXG4gICAgXCI0OFwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiNDlcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjUwXCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI1MVwiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiNTJcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjUzXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI1NFwiOiBbMCwgMC42NDQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiNTVcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjU2XCI6IFswLCAwLjY0NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI1N1wiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiNjVcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuODY5NDRdLFxuICAgIFwiNjZcIjogWzAsIDAuNjg2MTEsIDAuMDQ4MzUsIDAsIDAuODY2NF0sXG4gICAgXCI2N1wiOiBbMCwgMC42ODYxMSwgMC4wNjk3OSwgMCwgMC44MTY5NF0sXG4gICAgXCI2OFwiOiBbMCwgMC42ODYxMSwgMC4wMzE5NCwgMCwgMC45MzgxMl0sXG4gICAgXCI2OVwiOiBbMCwgMC42ODYxMSwgMC4wNTQ1MSwgMCwgMC44MTAwN10sXG4gICAgXCI3MFwiOiBbMCwgMC42ODYxMSwgMC4xNTk3MiwgMCwgMC42ODg4OV0sXG4gICAgXCI3MVwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC44ODY3M10sXG4gICAgXCI3MlwiOiBbMCwgMC42ODYxMSwgMC4wODIyOSwgMCwgMC45ODIyOV0sXG4gICAgXCI3M1wiOiBbMCwgMC42ODYxMSwgMC4wNzc3OCwgMCwgMC41MTExMV0sXG4gICAgXCI3NFwiOiBbMCwgMC42ODYxMSwgMC4xMDA2OSwgMCwgMC42MzEyNV0sXG4gICAgXCI3NVwiOiBbMCwgMC42ODYxMSwgMC4wNjk3OSwgMCwgMC45NzExOF0sXG4gICAgXCI3NlwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC43NTU1NV0sXG4gICAgXCI3N1wiOiBbMCwgMC42ODYxMSwgMC4xMTQyNCwgMCwgMS4xNDIwMV0sXG4gICAgXCI3OFwiOiBbMCwgMC42ODYxMSwgMC4xMTQyNCwgMCwgMC45NTAzNF0sXG4gICAgXCI3OVwiOiBbMCwgMC42ODYxMSwgMC4wMzE5NCwgMCwgMC44MzY2Nl0sXG4gICAgXCI4MFwiOiBbMCwgMC42ODYxMSwgMC4xNTk3MiwgMCwgMC43MjMwOV0sXG4gICAgXCI4MVwiOiBbMC4xOTQ0NCwgMC42ODYxMSwgMCwgMCwgMC44Njg2MV0sXG4gICAgXCI4MlwiOiBbMCwgMC42ODYxMSwgMC4wMDQyMSwgMCwgMC44NzIzNV0sXG4gICAgXCI4M1wiOiBbMCwgMC42ODYxMSwgMC4wNTM4MiwgMCwgMC42OTI3MV0sXG4gICAgXCI4NFwiOiBbMCwgMC42ODYxMSwgMC4xNTk3MiwgMCwgMC42MzY2M10sXG4gICAgXCI4NVwiOiBbMCwgMC42ODYxMSwgMC4xMTQyNCwgMCwgMC44MDAyN10sXG4gICAgXCI4NlwiOiBbMCwgMC42ODYxMSwgMC4yNTU1NSwgMCwgMC42Nzc3OF0sXG4gICAgXCI4N1wiOiBbMCwgMC42ODYxMSwgMC4xNTk3MiwgMCwgMS4wOTMwNV0sXG4gICAgXCI4OFwiOiBbMCwgMC42ODYxMSwgMC4wNzc3OCwgMCwgMC45NDcyMl0sXG4gICAgXCI4OVwiOiBbMCwgMC42ODYxMSwgMC4yNTU1NSwgMCwgMC42NzQ1OF0sXG4gICAgXCI5MFwiOiBbMCwgMC42ODYxMSwgMC4wNjk3OSwgMCwgMC43NzI1N10sXG4gICAgXCI5N1wiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC42MzI4N10sXG4gICAgXCI5OFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41MjA4M10sXG4gICAgXCI5OVwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC41MTM0Ml0sXG4gICAgXCIxMDBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjA5NzJdLFxuICAgIFwiMTAxXCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjU1MzYxXSxcbiAgICBcIjEwMlwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4xMTA0MiwgMCwgMC41NjgwNl0sXG4gICAgXCIxMDNcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMDM3MDQsIDAsIDAuNTQ0OV0sXG4gICAgXCIxMDRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjY3NTldLFxuICAgIFwiMTA1XCI6IFswLCAwLjY5MzI2LCAwLCAwLCAwLjQwNDhdLFxuICAgIFwiMTA2XCI6IFswLjE5NDQ0LCAwLjY5MzI2LCAwLjA2MjIsIDAsIDAuNDcwODNdLFxuICAgIFwiMTA3XCI6IFswLCAwLjY5NDQ0LCAwLjAxODUyLCAwLCAwLjYwMzddLFxuICAgIFwiMTA4XCI6IFswLCAwLjY5NDQ0LCAwLjAwODgsIDAsIDAuMzQ4MTVdLFxuICAgIFwiMTA5XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAxLjAzMjRdLFxuICAgIFwiMTEwXCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjcxMjk2XSxcbiAgICBcIjExMVwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC41ODQ3Ml0sXG4gICAgXCIxMTJcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDAsIDAuNjAwOTJdLFxuICAgIFwiMTEzXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjAzNzA0LCAwLCAwLjU0MjEzXSxcbiAgICBcIjExNFwiOiBbMCwgMC40NDQ0NCwgMC4wMzE5NCwgMCwgMC41Mjg3XSxcbiAgICBcIjExNVwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC41MzEyNV0sXG4gICAgXCIxMTZcIjogWzAsIDAuNjM0OTIsIDAsIDAsIDAuNDE1MjhdLFxuICAgIFwiMTE3XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjY4MTAyXSxcbiAgICBcIjExOFwiOiBbMCwgMC40NDQ0NCwgMC4wMzcwNCwgMCwgMC41NjY2Nl0sXG4gICAgXCIxMTlcIjogWzAsIDAuNDQ0NDQsIDAuMDI3NzgsIDAsIDAuODMxNDhdLFxuICAgIFwiMTIwXCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjY1OTAzXSxcbiAgICBcIjEyMVwiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMC4wMzcwNCwgMCwgMC41OTAyOF0sXG4gICAgXCIxMjJcIjogWzAsIDAuNDQ0NDQsIDAuMDQyMTMsIDAsIDAuNTU1MDldLFxuICAgIFwiMTYwXCI6IFswLCAwLCAwLCAwLCAwLjI1XSxcbiAgICBcIjkxNVwiOiBbMCwgMC42ODYxMSwgMC4xNTk3MiwgMCwgMC42NTY5NF0sXG4gICAgXCI5MTZcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuOTU4MzNdLFxuICAgIFwiOTIwXCI6IFswLCAwLjY4NjExLCAwLjAzMTk0LCAwLCAwLjg2NzIyXSxcbiAgICBcIjkyM1wiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC44MDU1NV0sXG4gICAgXCI5MjZcIjogWzAsIDAuNjg2MTEsIDAuMDc0NTgsIDAsIDAuODQxMjVdLFxuICAgIFwiOTI4XCI6IFswLCAwLjY4NjExLCAwLjA4MjI5LCAwLCAwLjk4MjI5XSxcbiAgICBcIjkzMVwiOiBbMCwgMC42ODYxMSwgMC4wNTQ1MSwgMCwgMC44ODUwN10sXG4gICAgXCI5MzNcIjogWzAsIDAuNjg2MTEsIDAuMTU5NzIsIDAsIDAuNjcwODNdLFxuICAgIFwiOTM0XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjc2NjY2XSxcbiAgICBcIjkzNlwiOiBbMCwgMC42ODYxMSwgMC4xMTY1MywgMCwgMC43MTQwMl0sXG4gICAgXCI5MzdcIjogWzAsIDAuNjg2MTEsIDAuMDQ4MzUsIDAsIDAuODc4OV0sXG4gICAgXCI5NDVcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNzYwNjRdLFxuICAgIFwiOTQ2XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjAzNDAzLCAwLCAwLjY1OTcyXSxcbiAgICBcIjk0N1wiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMC4wNjM4OSwgMCwgMC41OTAwM10sXG4gICAgXCI5NDhcIjogWzAsIDAuNjk0NDQsIDAuMDM4MTksIDAsIDAuNTIyMjJdLFxuICAgIFwiOTQ5XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjUyODgyXSxcbiAgICBcIjk1MFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4wNjIxNSwgMCwgMC41MDgzM10sXG4gICAgXCI5NTFcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMDM3MDQsIDAsIDAuNl0sXG4gICAgXCI5NTJcIjogWzAsIDAuNjk0NDQsIDAuMDMxOTQsIDAsIDAuNTYxOF0sXG4gICAgXCI5NTNcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNDEyMDRdLFxuICAgIFwiOTU0XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjY2NzU5XSxcbiAgICBcIjk1NVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42NzA4M10sXG4gICAgXCI5NTZcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDAsIDAuNzA3ODddLFxuICAgIFwiOTU3XCI6IFswLCAwLjQ0NDQ0LCAwLjA2ODk4LCAwLCAwLjU3Njg1XSxcbiAgICBcIjk1OFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4wMzAyMSwgMCwgMC41MDgzM10sXG4gICAgXCI5NTlcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNTg0NzJdLFxuICAgIFwiOTYwXCI6IFswLCAwLjQ0NDQ0LCAwLjAzNzA0LCAwLCAwLjY4MjQxXSxcbiAgICBcIjk2MVwiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMCwgMC42MTE4XSxcbiAgICBcIjk2MlwiOiBbMC4wOTcyMiwgMC40NDQ0NCwgMC4wNzkxNywgMCwgMC40MjM2MV0sXG4gICAgXCI5NjNcIjogWzAsIDAuNDQ0NDQsIDAuMDM3MDQsIDAsIDAuNjg1ODhdLFxuICAgIFwiOTY0XCI6IFswLCAwLjQ0NDQ0LCAwLjEzNDcyLCAwLCAwLjUyMDgzXSxcbiAgICBcIjk2NVwiOiBbMCwgMC40NDQ0NCwgMC4wMzcwNCwgMCwgMC42MzA1NV0sXG4gICAgXCI5NjZcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDAsIDAuNzQ3MjJdLFxuICAgIFwiOTY3XCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwLCAwLjcxODA1XSxcbiAgICBcIjk2OFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4wMzcwNCwgMCwgMC43NTgzM10sXG4gICAgXCI5NjlcIjogWzAsIDAuNDQ0NDQsIDAuMDM3MDQsIDAsIDAuNzE3ODJdLFxuICAgIFwiOTc3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjY5MTU1XSxcbiAgICBcIjk4MVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC43MTI1XSxcbiAgICBcIjk4MlwiOiBbMCwgMC40NDQ0NCwgMC4wMzE5NCwgMCwgMC45NzVdLFxuICAgIFwiMTAwOVwiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMCwgMC42MTE4XSxcbiAgICBcIjEwMTNcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNDgzMzNdLFxuICAgIFwiNTc2NDlcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuMzkzNTJdLFxuICAgIFwiNTc5MTFcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDAsIDAuNDM4ODldXG4gIH0sXG4gIFwiTWF0aC1JdGFsaWNcIjoge1xuICAgIFwiMzJcIjogWzAsIDAsIDAsIDAsIDAuMjVdLFxuICAgIFwiNDhcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNV0sXG4gICAgXCI0OVwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41XSxcbiAgICBcIjUwXCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjVdLFxuICAgIFwiNTFcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAsIDAuNV0sXG4gICAgXCI1MlwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMCwgMC41XSxcbiAgICBcIjUzXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwLCAwLjVdLFxuICAgIFwiNTRcIjogWzAsIDAuNjQ0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI1NVwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMCwgMC41XSxcbiAgICBcIjU2XCI6IFswLCAwLjY0NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiNTdcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAsIDAuNV0sXG4gICAgXCI2NVwiOiBbMCwgMC42ODMzMywgMCwgMC4xMzg4OSwgMC43NV0sXG4gICAgXCI2NlwiOiBbMCwgMC42ODMzMywgMC4wNTAxNywgMC4wODMzNCwgMC43NTg1MV0sXG4gICAgXCI2N1wiOiBbMCwgMC42ODMzMywgMC4wNzE1MywgMC4wODMzNCwgMC43MTQ3Ml0sXG4gICAgXCI2OFwiOiBbMCwgMC42ODMzMywgMC4wMjc3OCwgMC4wNTU1NiwgMC44Mjc5Ml0sXG4gICAgXCI2OVwiOiBbMCwgMC42ODMzMywgMC4wNTc2NCwgMC4wODMzNCwgMC43MzgyXSxcbiAgICBcIjcwXCI6IFswLCAwLjY4MzMzLCAwLjEzODg5LCAwLjA4MzM0LCAwLjY0MzA2XSxcbiAgICBcIjcxXCI6IFswLCAwLjY4MzMzLCAwLCAwLjA4MzM0LCAwLjc4NjI1XSxcbiAgICBcIjcyXCI6IFswLCAwLjY4MzMzLCAwLjA4MTI1LCAwLjA1NTU2LCAwLjgzMTI1XSxcbiAgICBcIjczXCI6IFswLCAwLjY4MzMzLCAwLjA3ODQ3LCAwLjExMTExLCAwLjQzOTU4XSxcbiAgICBcIjc0XCI6IFswLCAwLjY4MzMzLCAwLjA5NjE4LCAwLjE2NjY3LCAwLjU1NDUxXSxcbiAgICBcIjc1XCI6IFswLCAwLjY4MzMzLCAwLjA3MTUzLCAwLjA1NTU2LCAwLjg0OTMxXSxcbiAgICBcIjc2XCI6IFswLCAwLjY4MzMzLCAwLCAwLjAyNzc4LCAwLjY4MDU2XSxcbiAgICBcIjc3XCI6IFswLCAwLjY4MzMzLCAwLjEwOTAzLCAwLjA4MzM0LCAwLjk3MDE0XSxcbiAgICBcIjc4XCI6IFswLCAwLjY4MzMzLCAwLjEwOTAzLCAwLjA4MzM0LCAwLjgwMzQ3XSxcbiAgICBcIjc5XCI6IFswLCAwLjY4MzMzLCAwLjAyNzc4LCAwLjA4MzM0LCAwLjc2Mjc4XSxcbiAgICBcIjgwXCI6IFswLCAwLjY4MzMzLCAwLjEzODg5LCAwLjA4MzM0LCAwLjY0MjAxXSxcbiAgICBcIjgxXCI6IFswLjE5NDQ0LCAwLjY4MzMzLCAwLCAwLjA4MzM0LCAwLjc5MDU2XSxcbiAgICBcIjgyXCI6IFswLCAwLjY4MzMzLCAwLjAwNzczLCAwLjA4MzM0LCAwLjc1OTI5XSxcbiAgICBcIjgzXCI6IFswLCAwLjY4MzMzLCAwLjA1NzY0LCAwLjA4MzM0LCAwLjYxMzJdLFxuICAgIFwiODRcIjogWzAsIDAuNjgzMzMsIDAuMTM4ODksIDAuMDgzMzQsIDAuNTg0MzhdLFxuICAgIFwiODVcIjogWzAsIDAuNjgzMzMsIDAuMTA5MDMsIDAuMDI3NzgsIDAuNjgyNzhdLFxuICAgIFwiODZcIjogWzAsIDAuNjgzMzMsIDAuMjIyMjIsIDAsIDAuNTgzMzNdLFxuICAgIFwiODdcIjogWzAsIDAuNjgzMzMsIDAuMTM4ODksIDAsIDAuOTQ0NDVdLFxuICAgIFwiODhcIjogWzAsIDAuNjgzMzMsIDAuMDc4NDcsIDAuMDgzMzQsIDAuODI4NDddLFxuICAgIFwiODlcIjogWzAsIDAuNjgzMzMsIDAuMjIyMjIsIDAsIDAuNTgwNTZdLFxuICAgIFwiOTBcIjogWzAsIDAuNjgzMzMsIDAuMDcxNTMsIDAuMDgzMzQsIDAuNjgyNjRdLFxuICAgIFwiOTdcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNTI4NTldLFxuICAgIFwiOThcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNDI5MTddLFxuICAgIFwiOTlcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDU1NTYsIDAuNDMyNzZdLFxuICAgIFwiMTAwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLjE2NjY3LCAwLjUyMDQ5XSxcbiAgICBcIjEwMVwiOiBbMCwgMC40MzA1NiwgMCwgMC4wNTU1NiwgMC40NjU2M10sXG4gICAgXCIxMDJcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMTA3NjQsIDAuMTY2NjcsIDAuNDg5NTldLFxuICAgIFwiMTAzXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLjAzNTg4LCAwLjAyNzc4LCAwLjQ3Njk3XSxcbiAgICBcIjEwNFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NzYxNl0sXG4gICAgXCIxMDVcIjogWzAsIDAuNjU5NTIsIDAsIDAsIDAuMzQ0NTFdLFxuICAgIFwiMTA2XCI6IFswLjE5NDQ0LCAwLjY1OTUyLCAwLjA1NzI0LCAwLCAwLjQxMTgxXSxcbiAgICBcIjEwN1wiOiBbMCwgMC42OTQ0NCwgMC4wMzE0OCwgMCwgMC41MjA2XSxcbiAgICBcIjEwOFwiOiBbMCwgMC42OTQ0NCwgMC4wMTk2OCwgMC4wODMzNCwgMC4yOTgzOF0sXG4gICAgXCIxMDlcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuODc4MDFdLFxuICAgIFwiMTEwXCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjYwMDIzXSxcbiAgICBcIjExMVwiOiBbMCwgMC40MzA1NiwgMCwgMC4wNTU1NiwgMC40ODQ3Ml0sXG4gICAgXCIxMTJcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMDgzMzQsIDAuNTAzMTNdLFxuICAgIFwiMTEzXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLjAzNTg4LCAwLjA4MzM0LCAwLjQ0NjQxXSxcbiAgICBcIjExNFwiOiBbMCwgMC40MzA1NiwgMC4wMjc3OCwgMC4wNTU1NiwgMC40NTExNl0sXG4gICAgXCIxMTVcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDU1NTYsIDAuNDY4NzVdLFxuICAgIFwiMTE2XCI6IFswLCAwLjYxNTA4LCAwLCAwLjA4MzM0LCAwLjM2MTExXSxcbiAgICBcIjExN1wiOiBbMCwgMC40MzA1NiwgMCwgMC4wMjc3OCwgMC41NzI0Nl0sXG4gICAgXCIxMThcIjogWzAsIDAuNDMwNTYsIDAuMDM1ODgsIDAuMDI3NzgsIDAuNDg0NzJdLFxuICAgIFwiMTE5XCI6IFswLCAwLjQzMDU2LCAwLjAyNjkxLCAwLjA4MzM0LCAwLjcxNTkyXSxcbiAgICBcIjEyMFwiOiBbMCwgMC40MzA1NiwgMCwgMC4wMjc3OCwgMC41NzE1M10sXG4gICAgXCIxMjFcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAuMDM1ODgsIDAuMDU1NTYsIDAuNDkwMjhdLFxuICAgIFwiMTIyXCI6IFswLCAwLjQzMDU2LCAwLjA0Mzk4LCAwLjA1NTU2LCAwLjQ2NTA1XSxcbiAgICBcIjE2MFwiOiBbMCwgMCwgMCwgMCwgMC4yNV0sXG4gICAgXCI5MTVcIjogWzAsIDAuNjgzMzMsIDAuMTM4ODksIDAuMDgzMzQsIDAuNjE1MjhdLFxuICAgIFwiOTE2XCI6IFswLCAwLjY4MzMzLCAwLCAwLjE2NjY3LCAwLjgzMzM0XSxcbiAgICBcIjkyMFwiOiBbMCwgMC42ODMzMywgMC4wMjc3OCwgMC4wODMzNCwgMC43NjI3OF0sXG4gICAgXCI5MjNcIjogWzAsIDAuNjgzMzMsIDAsIDAuMTY2NjcsIDAuNjk0NDVdLFxuICAgIFwiOTI2XCI6IFswLCAwLjY4MzMzLCAwLjA3NTY5LCAwLjA4MzM0LCAwLjc0MjM2XSxcbiAgICBcIjkyOFwiOiBbMCwgMC42ODMzMywgMC4wODEyNSwgMC4wNTU1NiwgMC44MzEyNV0sXG4gICAgXCI5MzFcIjogWzAsIDAuNjgzMzMsIDAuMDU3NjQsIDAuMDgzMzQsIDAuNzc5ODZdLFxuICAgIFwiOTMzXCI6IFswLCAwLjY4MzMzLCAwLjEzODg5LCAwLjA1NTU2LCAwLjU4MzMzXSxcbiAgICBcIjkzNFwiOiBbMCwgMC42ODMzMywgMCwgMC4wODMzNCwgMC42NjY2N10sXG4gICAgXCI5MzZcIjogWzAsIDAuNjgzMzMsIDAuMTEsIDAuMDU1NTYsIDAuNjEyMjJdLFxuICAgIFwiOTM3XCI6IFswLCAwLjY4MzMzLCAwLjA1MDE3LCAwLjA4MzM0LCAwLjc3MjRdLFxuICAgIFwiOTQ1XCI6IFswLCAwLjQzMDU2LCAwLjAwMzcsIDAuMDI3NzgsIDAuNjM5N10sXG4gICAgXCI5NDZcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMDUyNzgsIDAuMDgzMzQsIDAuNTY1NjNdLFxuICAgIFwiOTQ3XCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLjA1NTU2LCAwLCAwLjUxNzczXSxcbiAgICBcIjk0OFwiOiBbMCwgMC42OTQ0NCwgMC4wMzc4NSwgMC4wNTU1NiwgMC40NDQ0NF0sXG4gICAgXCI5NDlcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDgzMzQsIDAuNDY2MzJdLFxuICAgIFwiOTUwXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjA3Mzc4LCAwLjA4MzM0LCAwLjQzNzVdLFxuICAgIFwiOTUxXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLjAzNTg4LCAwLjA1NTU2LCAwLjQ5NjUzXSxcbiAgICBcIjk1MlwiOiBbMCwgMC42OTQ0NCwgMC4wMjc3OCwgMC4wODMzNCwgMC40Njk0NF0sXG4gICAgXCI5NTNcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDU1NTYsIDAuMzUzOTRdLFxuICAgIFwiOTU0XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjU3NjE2XSxcbiAgICBcIjk1NVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41ODMzNF0sXG4gICAgXCI5NTZcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMDI3NzgsIDAuNjAyNTVdLFxuICAgIFwiOTU3XCI6IFswLCAwLjQzMDU2LCAwLjA2MzY2LCAwLjAyNzc4LCAwLjQ5Mzk4XSxcbiAgICBcIjk1OFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4wNDYwMSwgMC4xMTExMSwgMC40Mzc1XSxcbiAgICBcIjk1OVwiOiBbMCwgMC40MzA1NiwgMCwgMC4wNTU1NiwgMC40ODQ3Ml0sXG4gICAgXCI5NjBcIjogWzAsIDAuNDMwNTYsIDAuMDM1ODgsIDAsIDAuNTcwMDNdLFxuICAgIFwiOTYxXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwLjA4MzM0LCAwLjUxNzAyXSxcbiAgICBcIjk2MlwiOiBbMC4wOTcyMiwgMC40MzA1NiwgMC4wNzk4NiwgMC4wODMzNCwgMC4zNjI4NV0sXG4gICAgXCI5NjNcIjogWzAsIDAuNDMwNTYsIDAuMDM1ODgsIDAsIDAuNTcxNDFdLFxuICAgIFwiOTY0XCI6IFswLCAwLjQzMDU2LCAwLjExMzIsIDAuMDI3NzgsIDAuNDM3MTVdLFxuICAgIFwiOTY1XCI6IFswLCAwLjQzMDU2LCAwLjAzNTg4LCAwLjAyNzc4LCAwLjU0MDI4XSxcbiAgICBcIjk2NlwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMC4wODMzNCwgMC42NTQxN10sXG4gICAgXCI5NjdcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMDU1NTYsIDAuNjI1NjldLFxuICAgIFwiOTY4XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjAzNTg4LCAwLjExMTExLCAwLjY1MTM5XSxcbiAgICBcIjk2OVwiOiBbMCwgMC40MzA1NiwgMC4wMzU4OCwgMCwgMC42MjI0NV0sXG4gICAgXCI5NzdcIjogWzAsIDAuNjk0NDQsIDAsIDAuMDgzMzQsIDAuNTkxNDRdLFxuICAgIFwiOTgxXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLjA4MzM0LCAwLjU5NTgzXSxcbiAgICBcIjk4MlwiOiBbMCwgMC40MzA1NiwgMC4wMjc3OCwgMCwgMC44MjgxM10sXG4gICAgXCIxMDA5XCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwLjA4MzM0LCAwLjUxNzAyXSxcbiAgICBcIjEwMTNcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDU1NTYsIDAuNDA1OV0sXG4gICAgXCI1NzY0OVwiOiBbMCwgMC40MzA1NiwgMCwgMC4wMjc3OCwgMC4zMjI0Nl0sXG4gICAgXCI1NzkxMVwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMC4wODMzNCwgMC4zODQwM11cbiAgfSxcbiAgXCJTYW5zU2VyaWYtQm9sZFwiOiB7XG4gICAgXCIzMlwiOiBbMCwgMCwgMCwgMCwgMC4yNV0sXG4gICAgXCIzM1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4zNjY2N10sXG4gICAgXCIzNFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NTgzNF0sXG4gICAgXCIzNVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC45MTY2N10sXG4gICAgXCIzNlwiOiBbMC4wNTU1NiwgMC43NSwgMCwgMCwgMC41NV0sXG4gICAgXCIzN1wiOiBbMC4wNTU1NiwgMC43NSwgMCwgMCwgMS4wMjkxMl0sXG4gICAgXCIzOFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC44MzA1Nl0sXG4gICAgXCIzOVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4zMDU1Nl0sXG4gICAgXCI0MFwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC40Mjc3OF0sXG4gICAgXCI0MVwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC40Mjc3OF0sXG4gICAgXCI0MlwiOiBbMCwgMC43NSwgMCwgMCwgMC41NV0sXG4gICAgXCI0M1wiOiBbMC4xMTY2NywgMC42MTY2NywgMCwgMCwgMC44NTU1Nl0sXG4gICAgXCI0NFwiOiBbMC4xMDU1NiwgMC4xMzA1NiwgMCwgMCwgMC4zMDU1Nl0sXG4gICAgXCI0NVwiOiBbMCwgMC40NTgzMywgMCwgMCwgMC4zNjY2N10sXG4gICAgXCI0NlwiOiBbMCwgMC4xMzA1NiwgMCwgMCwgMC4zMDU1Nl0sXG4gICAgXCI0N1wiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC41NV0sXG4gICAgXCI0OFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sXG4gICAgXCI0OVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sXG4gICAgXCI1MFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sXG4gICAgXCI1MVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sXG4gICAgXCI1MlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sXG4gICAgXCI1M1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sXG4gICAgXCI1NFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sXG4gICAgXCI1NVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sXG4gICAgXCI1NlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sXG4gICAgXCI1N1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sXG4gICAgXCI1OFwiOiBbMCwgMC40NTgzMywgMCwgMCwgMC4zMDU1Nl0sXG4gICAgXCI1OVwiOiBbMC4xMDU1NiwgMC40NTgzMywgMCwgMCwgMC4zMDU1Nl0sXG4gICAgXCI2MVwiOiBbLTAuMDkzNzUsIDAuNDA2MjUsIDAsIDAsIDAuODU1NTZdLFxuICAgIFwiNjNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTE5NDVdLFxuICAgIFwiNjRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzMzMzRdLFxuICAgIFwiNjVcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzMzMzRdLFxuICAgIFwiNjZcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzMzMzRdLFxuICAgIFwiNjdcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzAyNzhdLFxuICAgIFwiNjhcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzk0NDVdLFxuICAgIFwiNjlcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjQxNjddLFxuICAgIFwiNzBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjExMTFdLFxuICAgIFwiNzFcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzMzMzRdLFxuICAgIFwiNzJcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzk0NDVdLFxuICAgIFwiNzNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMzMwNTZdLFxuICAgIFwiNzRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTE5NDVdLFxuICAgIFwiNzVcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzYzODldLFxuICAgIFwiNzZcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTgwNTZdLFxuICAgIFwiNzdcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuOTc3NzhdLFxuICAgIFwiNzhcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzk0NDVdLFxuICAgIFwiNzlcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzk0NDVdLFxuICAgIFwiODBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzAyNzhdLFxuICAgIFwiODFcIjogWzAuMTA1NTYsIDAuNjk0NDQsIDAsIDAsIDAuNzk0NDVdLFxuICAgIFwiODJcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzAyNzhdLFxuICAgIFwiODNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjExMTFdLFxuICAgIFwiODRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzMzMzRdLFxuICAgIFwiODVcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzYzODldLFxuICAgIFwiODZcIjogWzAsIDAuNjk0NDQsIDAuMDE1MjgsIDAsIDAuNzMzMzRdLFxuICAgIFwiODdcIjogWzAsIDAuNjk0NDQsIDAuMDE1MjgsIDAsIDEuMDM4ODldLFxuICAgIFwiODhcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzMzMzRdLFxuICAgIFwiODlcIjogWzAsIDAuNjk0NDQsIDAuMDI3NSwgMCwgMC43MzMzNF0sXG4gICAgXCI5MFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42NzIyM10sXG4gICAgXCI5MVwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC4zNDMwNl0sXG4gICAgXCI5M1wiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC4zNDMwNl0sXG4gICAgXCI5NFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sXG4gICAgXCI5NVwiOiBbMC4zNSwgMC4xMDgzMywgMC4wMzA1NiwgMCwgMC41NV0sXG4gICAgXCI5N1wiOiBbMCwgMC40NTgzMywgMCwgMCwgMC41MjVdLFxuICAgIFwiOThcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTYxMTFdLFxuICAgIFwiOTlcIjogWzAsIDAuNDU4MzMsIDAsIDAsIDAuNDg4ODldLFxuICAgIFwiMTAwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU2MTExXSxcbiAgICBcIjEwMVwiOiBbMCwgMC40NTgzMywgMCwgMCwgMC41MTExMV0sXG4gICAgXCIxMDJcIjogWzAsIDAuNjk0NDQsIDAuMDc2MzksIDAsIDAuMzM2MTFdLFxuICAgIFwiMTAzXCI6IFswLjE5NDQ0LCAwLjQ1ODMzLCAwLjAxNTI4LCAwLCAwLjU1XSxcbiAgICBcIjEwNFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NjExMV0sXG4gICAgXCIxMDVcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMjU1NTZdLFxuICAgIFwiMTA2XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjI4NjExXSxcbiAgICBcIjEwN1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41MzA1Nl0sXG4gICAgXCIxMDhcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMjU1NTZdLFxuICAgIFwiMTA5XCI6IFswLCAwLjQ1ODMzLCAwLCAwLCAwLjg2NjY3XSxcbiAgICBcIjExMFwiOiBbMCwgMC40NTgzMywgMCwgMCwgMC41NjExMV0sXG4gICAgXCIxMTFcIjogWzAsIDAuNDU4MzMsIDAsIDAsIDAuNTVdLFxuICAgIFwiMTEyXCI6IFswLjE5NDQ0LCAwLjQ1ODMzLCAwLCAwLCAwLjU2MTExXSxcbiAgICBcIjExM1wiOiBbMC4xOTQ0NCwgMC40NTgzMywgMCwgMCwgMC41NjExMV0sXG4gICAgXCIxMTRcIjogWzAsIDAuNDU4MzMsIDAuMDE1MjgsIDAsIDAuMzcyMjJdLFxuICAgIFwiMTE1XCI6IFswLCAwLjQ1ODMzLCAwLCAwLCAwLjQyMTY3XSxcbiAgICBcIjExNlwiOiBbMCwgMC41ODkyOSwgMCwgMCwgMC40MDQxN10sXG4gICAgXCIxMTdcIjogWzAsIDAuNDU4MzMsIDAsIDAsIDAuNTYxMTFdLFxuICAgIFwiMTE4XCI6IFswLCAwLjQ1ODMzLCAwLjAxNTI4LCAwLCAwLjVdLFxuICAgIFwiMTE5XCI6IFswLCAwLjQ1ODMzLCAwLjAxNTI4LCAwLCAwLjc0NDQ1XSxcbiAgICBcIjEyMFwiOiBbMCwgMC40NTgzMywgMCwgMCwgMC41XSxcbiAgICBcIjEyMVwiOiBbMC4xOTQ0NCwgMC40NTgzMywgMC4wMTUyOCwgMCwgMC41XSxcbiAgICBcIjEyMlwiOiBbMCwgMC40NTgzMywgMCwgMCwgMC40NzYzOV0sXG4gICAgXCIxMjZcIjogWzAuMzUsIDAuMzQ0NDQsIDAsIDAsIDAuNTVdLFxuICAgIFwiMTYwXCI6IFswLCAwLCAwLCAwLCAwLjI1XSxcbiAgICBcIjE2OFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sXG4gICAgXCIxNzZcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzMzMzRdLFxuICAgIFwiMTgwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU1XSxcbiAgICBcIjE4NFwiOiBbMC4xNzAxNCwgMCwgMCwgMCwgMC40ODg4OV0sXG4gICAgXCIzMDVcIjogWzAsIDAuNDU4MzMsIDAsIDAsIDAuMjU1NTZdLFxuICAgIFwiNTY3XCI6IFswLjE5NDQ0LCAwLjQ1ODMzLCAwLCAwLCAwLjI4NjExXSxcbiAgICBcIjcxMFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sXG4gICAgXCI3MTFcIjogWzAsIDAuNjM1NDIsIDAsIDAsIDAuNTVdLFxuICAgIFwiNzEzXCI6IFswLCAwLjYzNzc4LCAwLCAwLCAwLjU1XSxcbiAgICBcIjcyOFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sXG4gICAgXCI3MjlcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMzA1NTZdLFxuICAgIFwiNzMwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjczMzM0XSxcbiAgICBcIjczMlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sXG4gICAgXCI3MzNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTVdLFxuICAgIFwiOTE1XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU4MDU2XSxcbiAgICBcIjkxNlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC45MTY2N10sXG4gICAgXCI5MjBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuODU1NTZdLFxuICAgIFwiOTIzXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjY3MjIzXSxcbiAgICBcIjkyNlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43MzMzNF0sXG4gICAgXCI5MjhcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzk0NDVdLFxuICAgIFwiOTMxXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjc5NDQ1XSxcbiAgICBcIjkzM1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC44NTU1Nl0sXG4gICAgXCI5MzRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzk0NDVdLFxuICAgIFwiOTM2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjg1NTU2XSxcbiAgICBcIjkzN1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43OTQ0NV0sXG4gICAgXCI4MjExXCI6IFswLCAwLjQ1ODMzLCAwLjAzMDU2LCAwLCAwLjU1XSxcbiAgICBcIjgyMTJcIjogWzAsIDAuNDU4MzMsIDAuMDMwNTYsIDAsIDEuMTAwMDFdLFxuICAgIFwiODIxNlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4zMDU1Nl0sXG4gICAgXCI4MjE3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjMwNTU2XSxcbiAgICBcIjgyMjBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTU4MzRdLFxuICAgIFwiODIyMVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NTgzNF1cbiAgfSxcbiAgXCJTYW5zU2VyaWYtSXRhbGljXCI6IHtcbiAgICBcIjMyXCI6IFswLCAwLCAwLCAwLCAwLjI1XSxcbiAgICBcIjMzXCI6IFswLCAwLjY5NDQ0LCAwLjA1NzMzLCAwLCAwLjMxOTQ1XSxcbiAgICBcIjM0XCI6IFswLCAwLjY5NDQ0LCAwLjAwMzE2LCAwLCAwLjVdLFxuICAgIFwiMzVcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMDUwODcsIDAsIDAuODMzMzRdLFxuICAgIFwiMzZcIjogWzAuMDU1NTYsIDAuNzUsIDAuMTExNTYsIDAsIDAuNV0sXG4gICAgXCIzN1wiOiBbMC4wNTU1NiwgMC43NSwgMC4wMzEyNiwgMCwgMC44MzMzNF0sXG4gICAgXCIzOFwiOiBbMCwgMC42OTQ0NCwgMC4wMzA1OCwgMCwgMC43NTgzNF0sXG4gICAgXCIzOVwiOiBbMCwgMC42OTQ0NCwgMC4wNzgxNiwgMCwgMC4yNzc3OF0sXG4gICAgXCI0MFwiOiBbMC4yNSwgMC43NSwgMC4xMzE2NCwgMCwgMC4zODg4OV0sXG4gICAgXCI0MVwiOiBbMC4yNSwgMC43NSwgMC4wMjUzNiwgMCwgMC4zODg4OV0sXG4gICAgXCI0MlwiOiBbMCwgMC43NSwgMC4xMTc3NSwgMCwgMC41XSxcbiAgICBcIjQzXCI6IFswLjA4MzMzLCAwLjU4MzMzLCAwLjAyNTM2LCAwLCAwLjc3Nzc4XSxcbiAgICBcIjQ0XCI6IFswLjEyNSwgMC4wODMzMywgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCI0NVwiOiBbMCwgMC40NDQ0NCwgMC4wMTk0NiwgMCwgMC4zMzMzM10sXG4gICAgXCI0NlwiOiBbMCwgMC4wODMzMywgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCI0N1wiOiBbMC4yNSwgMC43NSwgMC4xMzE2NCwgMCwgMC41XSxcbiAgICBcIjQ4XCI6IFswLCAwLjY1NTU2LCAwLjExMTU2LCAwLCAwLjVdLFxuICAgIFwiNDlcIjogWzAsIDAuNjU1NTYsIDAuMTExNTYsIDAsIDAuNV0sXG4gICAgXCI1MFwiOiBbMCwgMC42NTU1NiwgMC4xMTE1NiwgMCwgMC41XSxcbiAgICBcIjUxXCI6IFswLCAwLjY1NTU2LCAwLjExMTU2LCAwLCAwLjVdLFxuICAgIFwiNTJcIjogWzAsIDAuNjU1NTYsIDAuMTExNTYsIDAsIDAuNV0sXG4gICAgXCI1M1wiOiBbMCwgMC42NTU1NiwgMC4xMTE1NiwgMCwgMC41XSxcbiAgICBcIjU0XCI6IFswLCAwLjY1NTU2LCAwLjExMTU2LCAwLCAwLjVdLFxuICAgIFwiNTVcIjogWzAsIDAuNjU1NTYsIDAuMTExNTYsIDAsIDAuNV0sXG4gICAgXCI1NlwiOiBbMCwgMC42NTU1NiwgMC4xMTE1NiwgMCwgMC41XSxcbiAgICBcIjU3XCI6IFswLCAwLjY1NTU2LCAwLjExMTU2LCAwLCAwLjVdLFxuICAgIFwiNThcIjogWzAsIDAuNDQ0NDQsIDAuMDI1MDIsIDAsIDAuMjc3NzhdLFxuICAgIFwiNTlcIjogWzAuMTI1LCAwLjQ0NDQ0LCAwLjAyNTAyLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjYxXCI6IFstMC4xMywgMC4zNywgMC4wNTA4NywgMCwgMC43Nzc3OF0sXG4gICAgXCI2M1wiOiBbMCwgMC42OTQ0NCwgMC4xMTgwOSwgMCwgMC40NzIyMl0sXG4gICAgXCI2NFwiOiBbMCwgMC42OTQ0NCwgMC4wNzU1NSwgMCwgMC42NjY2N10sXG4gICAgXCI2NVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI2NlwiOiBbMCwgMC42OTQ0NCwgMC4wODI5MywgMCwgMC42NjY2N10sXG4gICAgXCI2N1wiOiBbMCwgMC42OTQ0NCwgMC4xMTk4MywgMCwgMC42Mzg4OV0sXG4gICAgXCI2OFwiOiBbMCwgMC42OTQ0NCwgMC4wNzU1NSwgMCwgMC43MjIyM10sXG4gICAgXCI2OVwiOiBbMCwgMC42OTQ0NCwgMC4xMTk4MywgMCwgMC41OTcyMl0sXG4gICAgXCI3MFwiOiBbMCwgMC42OTQ0NCwgMC4xMzM3MiwgMCwgMC41Njk0NV0sXG4gICAgXCI3MVwiOiBbMCwgMC42OTQ0NCwgMC4xMTk4MywgMCwgMC42NjY2N10sXG4gICAgXCI3MlwiOiBbMCwgMC42OTQ0NCwgMC4wODA5NCwgMCwgMC43MDgzNF0sXG4gICAgXCI3M1wiOiBbMCwgMC42OTQ0NCwgMC4xMzM3MiwgMCwgMC4yNzc3OF0sXG4gICAgXCI3NFwiOiBbMCwgMC42OTQ0NCwgMC4wODA5NCwgMCwgMC40NzIyMl0sXG4gICAgXCI3NVwiOiBbMCwgMC42OTQ0NCwgMC4xMTk4MywgMCwgMC42OTQ0NV0sXG4gICAgXCI3NlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NDE2N10sXG4gICAgXCI3N1wiOiBbMCwgMC42OTQ0NCwgMC4wODA5NCwgMCwgMC44NzVdLFxuICAgIFwiNzhcIjogWzAsIDAuNjk0NDQsIDAuMDgwOTQsIDAsIDAuNzA4MzRdLFxuICAgIFwiNzlcIjogWzAsIDAuNjk0NDQsIDAuMDc1NTUsIDAsIDAuNzM2MTFdLFxuICAgIFwiODBcIjogWzAsIDAuNjk0NDQsIDAuMDgyOTMsIDAsIDAuNjM4ODldLFxuICAgIFwiODFcIjogWzAuMTI1LCAwLjY5NDQ0LCAwLjA3NTU1LCAwLCAwLjczNjExXSxcbiAgICBcIjgyXCI6IFswLCAwLjY5NDQ0LCAwLjA4MjkzLCAwLCAwLjY0NTg0XSxcbiAgICBcIjgzXCI6IFswLCAwLjY5NDQ0LCAwLjA5MjA1LCAwLCAwLjU1NTU2XSxcbiAgICBcIjg0XCI6IFswLCAwLjY5NDQ0LCAwLjEzMzcyLCAwLCAwLjY4MDU2XSxcbiAgICBcIjg1XCI6IFswLCAwLjY5NDQ0LCAwLjA4MDk0LCAwLCAwLjY4NzVdLFxuICAgIFwiODZcIjogWzAsIDAuNjk0NDQsIDAuMTYxNSwgMCwgMC42NjY2N10sXG4gICAgXCI4N1wiOiBbMCwgMC42OTQ0NCwgMC4xNjE1LCAwLCAwLjk0NDQ1XSxcbiAgICBcIjg4XCI6IFswLCAwLjY5NDQ0LCAwLjEzMzcyLCAwLCAwLjY2NjY3XSxcbiAgICBcIjg5XCI6IFswLCAwLjY5NDQ0LCAwLjE3MjYxLCAwLCAwLjY2NjY3XSxcbiAgICBcIjkwXCI6IFswLCAwLjY5NDQ0LCAwLjExOTgzLCAwLCAwLjYxMTExXSxcbiAgICBcIjkxXCI6IFswLjI1LCAwLjc1LCAwLjE1OTQyLCAwLCAwLjI4ODg5XSxcbiAgICBcIjkzXCI6IFswLjI1LCAwLjc1LCAwLjA4NzE5LCAwLCAwLjI4ODg5XSxcbiAgICBcIjk0XCI6IFswLCAwLjY5NDQ0LCAwLjA3OTksIDAsIDAuNV0sXG4gICAgXCI5NVwiOiBbMC4zNSwgMC4wOTQ0NCwgMC4wODYxNiwgMCwgMC41XSxcbiAgICBcIjk3XCI6IFswLCAwLjQ0NDQ0LCAwLjAwOTgxLCAwLCAwLjQ4MDU2XSxcbiAgICBcIjk4XCI6IFswLCAwLjY5NDQ0LCAwLjAzMDU3LCAwLCAwLjUxNjY3XSxcbiAgICBcIjk5XCI6IFswLCAwLjQ0NDQ0LCAwLjA4MzM2LCAwLCAwLjQ0NDQ1XSxcbiAgICBcIjEwMFwiOiBbMCwgMC42OTQ0NCwgMC4wOTQ4MywgMCwgMC41MTY2N10sXG4gICAgXCIxMDFcIjogWzAsIDAuNDQ0NDQsIDAuMDY3NzgsIDAsIDAuNDQ0NDVdLFxuICAgIFwiMTAyXCI6IFswLCAwLjY5NDQ0LCAwLjIxNzA1LCAwLCAwLjMwNTU2XSxcbiAgICBcIjEwM1wiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMC4xMDgzNiwgMCwgMC41XSxcbiAgICBcIjEwNFwiOiBbMCwgMC42OTQ0NCwgMC4wMTc3OCwgMCwgMC41MTY2N10sXG4gICAgXCIxMDVcIjogWzAsIDAuNjc5MzcsIDAuMDk3MTgsIDAsIDAuMjM4ODldLFxuICAgIFwiMTA2XCI6IFswLjE5NDQ0LCAwLjY3OTM3LCAwLjA5MTYyLCAwLCAwLjI2NjY3XSxcbiAgICBcIjEwN1wiOiBbMCwgMC42OTQ0NCwgMC4wODMzNiwgMCwgMC40ODg4OV0sXG4gICAgXCIxMDhcIjogWzAsIDAuNjk0NDQsIDAuMDk0ODMsIDAsIDAuMjM4ODldLFxuICAgIFwiMTA5XCI6IFswLCAwLjQ0NDQ0LCAwLjAxNzc4LCAwLCAwLjc5NDQ1XSxcbiAgICBcIjExMFwiOiBbMCwgMC40NDQ0NCwgMC4wMTc3OCwgMCwgMC41MTY2N10sXG4gICAgXCIxMTFcIjogWzAsIDAuNDQ0NDQsIDAuMDY2MTMsIDAsIDAuNV0sXG4gICAgXCIxMTJcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMDM4OSwgMCwgMC41MTY2N10sXG4gICAgXCIxMTNcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMDQxNjksIDAsIDAuNTE2NjddLFxuICAgIFwiMTE0XCI6IFswLCAwLjQ0NDQ0LCAwLjEwODM2LCAwLCAwLjM0MTY3XSxcbiAgICBcIjExNVwiOiBbMCwgMC40NDQ0NCwgMC4wNzc4LCAwLCAwLjM4MzMzXSxcbiAgICBcIjExNlwiOiBbMCwgMC41NzE0MywgMC4wNzIyNSwgMCwgMC4zNjExMV0sXG4gICAgXCIxMTdcIjogWzAsIDAuNDQ0NDQsIDAuMDQxNjksIDAsIDAuNTE2NjddLFxuICAgIFwiMTE4XCI6IFswLCAwLjQ0NDQ0LCAwLjEwODM2LCAwLCAwLjQ2MTExXSxcbiAgICBcIjExOVwiOiBbMCwgMC40NDQ0NCwgMC4xMDgzNiwgMCwgMC42ODMzNF0sXG4gICAgXCIxMjBcIjogWzAsIDAuNDQ0NDQsIDAuMDkxNjksIDAsIDAuNDYxMTFdLFxuICAgIFwiMTIxXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjEwODM2LCAwLCAwLjQ2MTExXSxcbiAgICBcIjEyMlwiOiBbMCwgMC40NDQ0NCwgMC4wODc1MiwgMCwgMC40MzQ3Ml0sXG4gICAgXCIxMjZcIjogWzAuMzUsIDAuMzI2NTksIDAuMDg4MjYsIDAsIDAuNV0sXG4gICAgXCIxNjBcIjogWzAsIDAsIDAsIDAsIDAuMjVdLFxuICAgIFwiMTY4XCI6IFswLCAwLjY3OTM3LCAwLjA2Mzg1LCAwLCAwLjVdLFxuICAgIFwiMTc2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjczNzUyXSxcbiAgICBcIjE4NFwiOiBbMC4xNzAxNCwgMCwgMCwgMCwgMC40NDQ0NV0sXG4gICAgXCIzMDVcIjogWzAsIDAuNDQ0NDQsIDAuMDQxNjksIDAsIDAuMjM4ODldLFxuICAgIFwiNTY3XCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjA0MTY5LCAwLCAwLjI2NjY3XSxcbiAgICBcIjcxMFwiOiBbMCwgMC42OTQ0NCwgMC4wNzk5LCAwLCAwLjVdLFxuICAgIFwiNzExXCI6IFswLCAwLjYzMTk0LCAwLjA4NDMyLCAwLCAwLjVdLFxuICAgIFwiNzEzXCI6IFswLCAwLjYwODg5LCAwLjA4Nzc2LCAwLCAwLjVdLFxuICAgIFwiNzE0XCI6IFswLCAwLjY5NDQ0LCAwLjA5MjA1LCAwLCAwLjVdLFxuICAgIFwiNzE1XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiNzI4XCI6IFswLCAwLjY5NDQ0LCAwLjA5NDgzLCAwLCAwLjVdLFxuICAgIFwiNzI5XCI6IFswLCAwLjY3OTM3LCAwLjA3Nzc0LCAwLCAwLjI3Nzc4XSxcbiAgICBcIjczMFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43Mzc1Ml0sXG4gICAgXCI3MzJcIjogWzAsIDAuNjc2NTksIDAuMDg4MjYsIDAsIDAuNV0sXG4gICAgXCI3MzNcIjogWzAsIDAuNjk0NDQsIDAuMDkyMDUsIDAsIDAuNV0sXG4gICAgXCI5MTVcIjogWzAsIDAuNjk0NDQsIDAuMTMzNzIsIDAsIDAuNTQxNjddLFxuICAgIFwiOTE2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjgzMzM0XSxcbiAgICBcIjkyMFwiOiBbMCwgMC42OTQ0NCwgMC4wNzU1NSwgMCwgMC43Nzc3OF0sXG4gICAgXCI5MjNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjExMTFdLFxuICAgIFwiOTI2XCI6IFswLCAwLjY5NDQ0LCAwLjEyODE2LCAwLCAwLjY2NjY3XSxcbiAgICBcIjkyOFwiOiBbMCwgMC42OTQ0NCwgMC4wODA5NCwgMCwgMC43MDgzNF0sXG4gICAgXCI5MzFcIjogWzAsIDAuNjk0NDQsIDAuMTE5ODMsIDAsIDAuNzIyMjJdLFxuICAgIFwiOTMzXCI6IFswLCAwLjY5NDQ0LCAwLjA5MDMxLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjkzNFwiOiBbMCwgMC42OTQ0NCwgMC4wNDYwMywgMCwgMC43MjIyMl0sXG4gICAgXCI5MzZcIjogWzAsIDAuNjk0NDQsIDAuMDkwMzEsIDAsIDAuNzc3NzhdLFxuICAgIFwiOTM3XCI6IFswLCAwLjY5NDQ0LCAwLjA4MjkzLCAwLCAwLjcyMjIyXSxcbiAgICBcIjgyMTFcIjogWzAsIDAuNDQ0NDQsIDAuMDg2MTYsIDAsIDAuNV0sXG4gICAgXCI4MjEyXCI6IFswLCAwLjQ0NDQ0LCAwLjA4NjE2LCAwLCAxLjBdLFxuICAgIFwiODIxNlwiOiBbMCwgMC42OTQ0NCwgMC4wNzgxNiwgMCwgMC4yNzc3OF0sXG4gICAgXCI4MjE3XCI6IFswLCAwLjY5NDQ0LCAwLjA3ODE2LCAwLCAwLjI3Nzc4XSxcbiAgICBcIjgyMjBcIjogWzAsIDAuNjk0NDQsIDAuMTQyMDUsIDAsIDAuNV0sXG4gICAgXCI4MjIxXCI6IFswLCAwLjY5NDQ0LCAwLjAwMzE2LCAwLCAwLjVdXG4gIH0sXG4gIFwiU2Fuc1NlcmlmLVJlZ3VsYXJcIjoge1xuICAgIFwiMzJcIjogWzAsIDAsIDAsIDAsIDAuMjVdLFxuICAgIFwiMzNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMzE5NDVdLFxuICAgIFwiMzRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCIzNVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC44MzMzNF0sXG4gICAgXCIzNlwiOiBbMC4wNTU1NiwgMC43NSwgMCwgMCwgMC41XSxcbiAgICBcIjM3XCI6IFswLjA1NTU2LCAwLjc1LCAwLCAwLCAwLjgzMzM0XSxcbiAgICBcIjM4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjc1ODM0XSxcbiAgICBcIjM5XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjQwXCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjM4ODg5XSxcbiAgICBcIjQxXCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjM4ODg5XSxcbiAgICBcIjQyXCI6IFswLCAwLjc1LCAwLCAwLCAwLjVdLFxuICAgIFwiNDNcIjogWzAuMDgzMzMsIDAuNTgzMzMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiNDRcIjogWzAuMTI1LCAwLjA4MzMzLCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjQ1XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjMzMzMzXSxcbiAgICBcIjQ2XCI6IFswLCAwLjA4MzMzLCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjQ3XCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjVdLFxuICAgIFwiNDhcIjogWzAsIDAuNjU1NTYsIDAsIDAsIDAuNV0sXG4gICAgXCI0OVwiOiBbMCwgMC42NTU1NiwgMCwgMCwgMC41XSxcbiAgICBcIjUwXCI6IFswLCAwLjY1NTU2LCAwLCAwLCAwLjVdLFxuICAgIFwiNTFcIjogWzAsIDAuNjU1NTYsIDAsIDAsIDAuNV0sXG4gICAgXCI1MlwiOiBbMCwgMC42NTU1NiwgMCwgMCwgMC41XSxcbiAgICBcIjUzXCI6IFswLCAwLjY1NTU2LCAwLCAwLCAwLjVdLFxuICAgIFwiNTRcIjogWzAsIDAuNjU1NTYsIDAsIDAsIDAuNV0sXG4gICAgXCI1NVwiOiBbMCwgMC42NTU1NiwgMCwgMCwgMC41XSxcbiAgICBcIjU2XCI6IFswLCAwLjY1NTU2LCAwLCAwLCAwLjVdLFxuICAgIFwiNTdcIjogWzAsIDAuNjU1NTYsIDAsIDAsIDAuNV0sXG4gICAgXCI1OFwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCI1OVwiOiBbMC4xMjUsIDAuNDQ0NDQsIDAsIDAsIDAuMjc3NzhdLFxuICAgIFwiNjFcIjogWy0wLjEzLCAwLjM3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjYzXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjQ3MjIyXSxcbiAgICBcIjY0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjY1XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjY2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjY3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjYzODg5XSxcbiAgICBcIjY4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjcyMjIzXSxcbiAgICBcIjY5XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU5NzIyXSxcbiAgICBcIjcwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU2OTQ1XSxcbiAgICBcIjcxXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjcyXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjcwODM0XSxcbiAgICBcIjczXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjc0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjQ3MjIyXSxcbiAgICBcIjc1XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjY5NDQ1XSxcbiAgICBcIjc2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU0MTY3XSxcbiAgICBcIjc3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjg3NV0sXG4gICAgXCI3OFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43MDgzNF0sXG4gICAgXCI3OVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43MzYxMV0sXG4gICAgXCI4MFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42Mzg4OV0sXG4gICAgXCI4MVwiOiBbMC4xMjUsIDAuNjk0NDQsIDAsIDAsIDAuNzM2MTFdLFxuICAgIFwiODJcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjQ1ODRdLFxuICAgIFwiODNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTU1NTZdLFxuICAgIFwiODRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjgwNTZdLFxuICAgIFwiODVcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjg3NV0sXG4gICAgXCI4NlwiOiBbMCwgMC42OTQ0NCwgMC4wMTM4OSwgMCwgMC42NjY2N10sXG4gICAgXCI4N1wiOiBbMCwgMC42OTQ0NCwgMC4wMTM4OSwgMCwgMC45NDQ0NV0sXG4gICAgXCI4OFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI4OVwiOiBbMCwgMC42OTQ0NCwgMC4wMjUsIDAsIDAuNjY2NjddLFxuICAgIFwiOTBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjExMTFdLFxuICAgIFwiOTFcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuMjg4ODldLFxuICAgIFwiOTNcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuMjg4ODldLFxuICAgIFwiOTRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI5NVwiOiBbMC4zNSwgMC4wOTQ0NCwgMC4wMjc3OCwgMCwgMC41XSxcbiAgICBcIjk3XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjQ4MDU2XSxcbiAgICBcIjk4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjUxNjY3XSxcbiAgICBcIjk5XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjQ0NDQ1XSxcbiAgICBcIjEwMFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41MTY2N10sXG4gICAgXCIxMDFcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNDQ0NDVdLFxuICAgIFwiMTAyXCI6IFswLCAwLjY5NDQ0LCAwLjA2OTQ0LCAwLCAwLjMwNTU2XSxcbiAgICBcIjEwM1wiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMC4wMTM4OSwgMCwgMC41XSxcbiAgICBcIjEwNFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41MTY2N10sXG4gICAgXCIxMDVcIjogWzAsIDAuNjc5MzcsIDAsIDAsIDAuMjM4ODldLFxuICAgIFwiMTA2XCI6IFswLjE5NDQ0LCAwLjY3OTM3LCAwLCAwLCAwLjI2NjY3XSxcbiAgICBcIjEwN1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC40ODg4OV0sXG4gICAgXCIxMDhcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMjM4ODldLFxuICAgIFwiMTA5XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjc5NDQ1XSxcbiAgICBcIjExMFwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC41MTY2N10sXG4gICAgXCIxMTFcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCIxMTJcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDAsIDAuNTE2NjddLFxuICAgIFwiMTEzXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwLCAwLjUxNjY3XSxcbiAgICBcIjExNFwiOiBbMCwgMC40NDQ0NCwgMC4wMTM4OSwgMCwgMC4zNDE2N10sXG4gICAgXCIxMTVcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuMzgzMzNdLFxuICAgIFwiMTE2XCI6IFswLCAwLjU3MTQzLCAwLCAwLCAwLjM2MTExXSxcbiAgICBcIjExN1wiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC41MTY2N10sXG4gICAgXCIxMThcIjogWzAsIDAuNDQ0NDQsIDAuMDEzODksIDAsIDAuNDYxMTFdLFxuICAgIFwiMTE5XCI6IFswLCAwLjQ0NDQ0LCAwLjAxMzg5LCAwLCAwLjY4MzM0XSxcbiAgICBcIjEyMFwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC40NjExMV0sXG4gICAgXCIxMjFcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMDEzODksIDAsIDAuNDYxMTFdLFxuICAgIFwiMTIyXCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjQzNDcyXSxcbiAgICBcIjEyNlwiOiBbMC4zNSwgMC4zMjY1OSwgMCwgMCwgMC41XSxcbiAgICBcIjE2MFwiOiBbMCwgMCwgMCwgMCwgMC4yNV0sXG4gICAgXCIxNjhcIjogWzAsIDAuNjc5MzcsIDAsIDAsIDAuNV0sXG4gICAgXCIxNzZcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiMTg0XCI6IFswLjE3MDE0LCAwLCAwLCAwLCAwLjQ0NDQ1XSxcbiAgICBcIjMwNVwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC4yMzg4OV0sXG4gICAgXCI1NjdcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDAsIDAuMjY2NjddLFxuICAgIFwiNzEwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiNzExXCI6IFswLCAwLjYzMTk0LCAwLCAwLCAwLjVdLFxuICAgIFwiNzEzXCI6IFswLCAwLjYwODg5LCAwLCAwLCAwLjVdLFxuICAgIFwiNzE0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiNzE1XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiNzI4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiNzI5XCI6IFswLCAwLjY3OTM3LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjczMFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI3MzJcIjogWzAsIDAuNjc2NTksIDAsIDAsIDAuNV0sXG4gICAgXCI3MzNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI5MTVcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTQxNjddLFxuICAgIFwiOTE2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjgzMzM0XSxcbiAgICBcIjkyMFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI5MjNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjExMTFdLFxuICAgIFwiOTI2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjkyOFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43MDgzNF0sXG4gICAgXCI5MzFcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiOTMzXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjkzNFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI5MzZcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiOTM3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjgyMTFcIjogWzAsIDAuNDQ0NDQsIDAuMDI3NzgsIDAsIDAuNV0sXG4gICAgXCI4MjEyXCI6IFswLCAwLjQ0NDQ0LCAwLjAyNzc4LCAwLCAxLjBdLFxuICAgIFwiODIxNlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCI4MjE3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjgyMjBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI4MjIxXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjVdXG4gIH0sXG4gIFwiU2NyaXB0LVJlZ3VsYXJcIjoge1xuICAgIFwiMzJcIjogWzAsIDAsIDAsIDAsIDAuMjVdLFxuICAgIFwiNjVcIjogWzAsIDAuNywgMC4yMjkyNSwgMCwgMC44MDI1M10sXG4gICAgXCI2NlwiOiBbMCwgMC43LCAwLjA0MDg3LCAwLCAwLjkwNzU3XSxcbiAgICBcIjY3XCI6IFswLCAwLjcsIDAuMTY4OSwgMCwgMC42NjYxOV0sXG4gICAgXCI2OFwiOiBbMCwgMC43LCAwLjA5MzcxLCAwLCAwLjc3NDQzXSxcbiAgICBcIjY5XCI6IFswLCAwLjcsIDAuMTg1ODMsIDAsIDAuNTYxNjJdLFxuICAgIFwiNzBcIjogWzAsIDAuNywgMC4xMzYzNCwgMCwgMC44OTU0NF0sXG4gICAgXCI3MVwiOiBbMCwgMC43LCAwLjE3MzIyLCAwLCAwLjYwOTYxXSxcbiAgICBcIjcyXCI6IFswLCAwLjcsIDAuMjk2OTQsIDAsIDAuOTY5MTldLFxuICAgIFwiNzNcIjogWzAsIDAuNywgMC4xOTE4OSwgMCwgMC44MDkwN10sXG4gICAgXCI3NFwiOiBbMC4yNzc3OCwgMC43LCAwLjE5MTg5LCAwLCAxLjA1MTU5XSxcbiAgICBcIjc1XCI6IFswLCAwLjcsIDAuMzEyNTksIDAsIDAuOTEzNjRdLFxuICAgIFwiNzZcIjogWzAsIDAuNywgMC4xOTE4OSwgMCwgMC44NzM3M10sXG4gICAgXCI3N1wiOiBbMCwgMC43LCAwLjE1OTgxLCAwLCAxLjA4MDMxXSxcbiAgICBcIjc4XCI6IFswLCAwLjcsIDAuMzUyNSwgMCwgMC45MDE1XSxcbiAgICBcIjc5XCI6IFswLCAwLjcsIDAuMDgwNzgsIDAsIDAuNzM3ODddLFxuICAgIFwiODBcIjogWzAsIDAuNywgMC4wODA3OCwgMCwgMS4wMTI2Ml0sXG4gICAgXCI4MVwiOiBbMCwgMC43LCAwLjAzMzA1LCAwLCAwLjg4MjgyXSxcbiAgICBcIjgyXCI6IFswLCAwLjcsIDAuMDYyNTksIDAsIDAuODVdLFxuICAgIFwiODNcIjogWzAsIDAuNywgMC4xOTE4OSwgMCwgMC44Njc2N10sXG4gICAgXCI4NFwiOiBbMCwgMC43LCAwLjI5MDg3LCAwLCAwLjc0Njk3XSxcbiAgICBcIjg1XCI6IFswLCAwLjcsIDAuMjU4MTUsIDAsIDAuNzk5OTZdLFxuICAgIFwiODZcIjogWzAsIDAuNywgMC4yNzUyMywgMCwgMC42MjIwNF0sXG4gICAgXCI4N1wiOiBbMCwgMC43LCAwLjI3NTIzLCAwLCAwLjgwNTMyXSxcbiAgICBcIjg4XCI6IFswLCAwLjcsIDAuMjYwMDYsIDAsIDAuOTQ0NDVdLFxuICAgIFwiODlcIjogWzAsIDAuNywgMC4yOTM5LCAwLCAwLjcwOTYxXSxcbiAgICBcIjkwXCI6IFswLCAwLjcsIDAuMjQwMzcsIDAsIDAuODIxMl0sXG4gICAgXCIxNjBcIjogWzAsIDAsIDAsIDAsIDAuMjVdXG4gIH0sXG4gIFwiU2l6ZTEtUmVndWxhclwiOiB7XG4gICAgXCIzMlwiOiBbMCwgMCwgMCwgMCwgMC4yNV0sXG4gICAgXCI0MFwiOiBbMC4zNTAwMSwgMC44NSwgMCwgMCwgMC40NTgzNF0sXG4gICAgXCI0MVwiOiBbMC4zNTAwMSwgMC44NSwgMCwgMCwgMC40NTgzNF0sXG4gICAgXCI0N1wiOiBbMC4zNTAwMSwgMC44NSwgMCwgMCwgMC41Nzc3OF0sXG4gICAgXCI5MVwiOiBbMC4zNTAwMSwgMC44NSwgMCwgMCwgMC40MTY2N10sXG4gICAgXCI5MlwiOiBbMC4zNTAwMSwgMC44NSwgMCwgMCwgMC41Nzc3OF0sXG4gICAgXCI5M1wiOiBbMC4zNTAwMSwgMC44NSwgMCwgMCwgMC40MTY2N10sXG4gICAgXCIxMjNcIjogWzAuMzUwMDEsIDAuODUsIDAsIDAsIDAuNTgzMzRdLFxuICAgIFwiMTI1XCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwLCAwLjU4MzM0XSxcbiAgICBcIjE2MFwiOiBbMCwgMCwgMCwgMCwgMC4yNV0sXG4gICAgXCI3MTBcIjogWzAsIDAuNzIyMjIsIDAsIDAsIDAuNTU1NTZdLFxuICAgIFwiNzMyXCI6IFswLCAwLjcyMjIyLCAwLCAwLCAwLjU1NTU2XSxcbiAgICBcIjc3MFwiOiBbMCwgMC43MjIyMiwgMCwgMCwgMC41NTU1Nl0sXG4gICAgXCI3NzFcIjogWzAsIDAuNzIyMjIsIDAsIDAsIDAuNTU1NTZdLFxuICAgIFwiODIxNFwiOiBbLTAuMDAwOTksIDAuNjAxLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg1OTNcIjogWzFlLTA1LCAwLjYsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiODU5NVwiOiBbMWUtMDUsIDAuNiwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI4NjU3XCI6IFsxZS0wNSwgMC42LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg2NTlcIjogWzFlLTA1LCAwLjYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODcxOVwiOiBbMC4yNTAwMSwgMC43NSwgMCwgMCwgMC45NDQ0NV0sXG4gICAgXCI4NzIwXCI6IFswLjI1MDAxLCAwLjc1LCAwLCAwLCAwLjk0NDQ1XSxcbiAgICBcIjg3MjFcIjogWzAuMjUwMDEsIDAuNzUsIDAsIDAsIDEuMDU1NTZdLFxuICAgIFwiODczMFwiOiBbMC4zNTAwMSwgMC44NSwgMCwgMCwgMS4wXSxcbiAgICBcIjg3MzlcIjogWy0wLjAwNTk5LCAwLjYwNiwgMCwgMCwgMC4zMzMzM10sXG4gICAgXCI4NzQxXCI6IFstMC4wMDU5OSwgMC42MDYsIDAsIDAsIDAuNTU1NTZdLFxuICAgIFwiODc0N1wiOiBbMC4zMDYxMiwgMC44MDUsIDAuMTk0NDUsIDAsIDAuNDcyMjJdLFxuICAgIFwiODc0OFwiOiBbMC4zMDYsIDAuODA1LCAwLjE5NDQ1LCAwLCAwLjQ3MjIyXSxcbiAgICBcIjg3NDlcIjogWzAuMzA2LCAwLjgwNSwgMC4xOTQ0NSwgMCwgMC40NzIyMl0sXG4gICAgXCI4NzUwXCI6IFswLjMwNjEyLCAwLjgwNSwgMC4xOTQ0NSwgMCwgMC40NzIyMl0sXG4gICAgXCI4ODk2XCI6IFswLjI1MDAxLCAwLjc1LCAwLCAwLCAwLjgzMzM0XSxcbiAgICBcIjg4OTdcIjogWzAuMjUwMDEsIDAuNzUsIDAsIDAsIDAuODMzMzRdLFxuICAgIFwiODg5OFwiOiBbMC4yNTAwMSwgMC43NSwgMCwgMCwgMC44MzMzNF0sXG4gICAgXCI4ODk5XCI6IFswLjI1MDAxLCAwLjc1LCAwLCAwLCAwLjgzMzM0XSxcbiAgICBcIjg5NjhcIjogWzAuMzUwMDEsIDAuODUsIDAsIDAsIDAuNDcyMjJdLFxuICAgIFwiODk2OVwiOiBbMC4zNTAwMSwgMC44NSwgMCwgMCwgMC40NzIyMl0sXG4gICAgXCI4OTcwXCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwLCAwLjQ3MjIyXSxcbiAgICBcIjg5NzFcIjogWzAuMzUwMDEsIDAuODUsIDAsIDAsIDAuNDcyMjJdLFxuICAgIFwiOTE2OFwiOiBbLTAuMDAwOTksIDAuNjAxLCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjEwMjE2XCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwLCAwLjQ3MjIyXSxcbiAgICBcIjEwMjE3XCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwLCAwLjQ3MjIyXSxcbiAgICBcIjEwNzUyXCI6IFswLjI1MDAxLCAwLjc1LCAwLCAwLCAxLjExMTExXSxcbiAgICBcIjEwNzUzXCI6IFswLjI1MDAxLCAwLjc1LCAwLCAwLCAxLjExMTExXSxcbiAgICBcIjEwNzU0XCI6IFswLjI1MDAxLCAwLjc1LCAwLCAwLCAxLjExMTExXSxcbiAgICBcIjEwNzU2XCI6IFswLjI1MDAxLCAwLjc1LCAwLCAwLCAwLjgzMzM0XSxcbiAgICBcIjEwNzU4XCI6IFswLjI1MDAxLCAwLjc1LCAwLCAwLCAwLjgzMzM0XVxuICB9LFxuICBcIlNpemUyLVJlZ3VsYXJcIjoge1xuICAgIFwiMzJcIjogWzAsIDAsIDAsIDAsIDAuMjVdLFxuICAgIFwiNDBcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDAsIDAuNTk3MjJdLFxuICAgIFwiNDFcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDAsIDAuNTk3MjJdLFxuICAgIFwiNDdcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDAsIDAuODExMTFdLFxuICAgIFwiOTFcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDAsIDAuNDcyMjJdLFxuICAgIFwiOTJcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDAsIDAuODExMTFdLFxuICAgIFwiOTNcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDAsIDAuNDcyMjJdLFxuICAgIFwiMTIzXCI6IFswLjY1MDAyLCAxLjE1LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjEyNVwiOiBbMC42NTAwMiwgMS4xNSwgMCwgMCwgMC42NjY2N10sXG4gICAgXCIxNjBcIjogWzAsIDAsIDAsIDAsIDAuMjVdLFxuICAgIFwiNzEwXCI6IFswLCAwLjc1LCAwLCAwLCAxLjBdLFxuICAgIFwiNzMyXCI6IFswLCAwLjc1LCAwLCAwLCAxLjBdLFxuICAgIFwiNzcwXCI6IFswLCAwLjc1LCAwLCAwLCAxLjBdLFxuICAgIFwiNzcxXCI6IFswLCAwLjc1LCAwLCAwLCAxLjBdLFxuICAgIFwiODcxOVwiOiBbMC41NTAwMSwgMS4wNSwgMCwgMCwgMS4yNzc3OF0sXG4gICAgXCI4NzIwXCI6IFswLjU1MDAxLCAxLjA1LCAwLCAwLCAxLjI3Nzc4XSxcbiAgICBcIjg3MjFcIjogWzAuNTUwMDEsIDEuMDUsIDAsIDAsIDEuNDQ0NDVdLFxuICAgIFwiODczMFwiOiBbMC42NTAwMiwgMS4xNSwgMCwgMCwgMS4wXSxcbiAgICBcIjg3NDdcIjogWzAuODYyMjUsIDEuMzYsIDAuNDQ0NDUsIDAsIDAuNTU1NTZdLFxuICAgIFwiODc0OFwiOiBbMC44NjIsIDEuMzYsIDAuNDQ0NDUsIDAsIDAuNTU1NTZdLFxuICAgIFwiODc0OVwiOiBbMC44NjIsIDEuMzYsIDAuNDQ0NDUsIDAsIDAuNTU1NTZdLFxuICAgIFwiODc1MFwiOiBbMC44NjIyNSwgMS4zNiwgMC40NDQ0NSwgMCwgMC41NTU1Nl0sXG4gICAgXCI4ODk2XCI6IFswLjU1MDAxLCAxLjA1LCAwLCAwLCAxLjExMTExXSxcbiAgICBcIjg4OTdcIjogWzAuNTUwMDEsIDEuMDUsIDAsIDAsIDEuMTExMTFdLFxuICAgIFwiODg5OFwiOiBbMC41NTAwMSwgMS4wNSwgMCwgMCwgMS4xMTExMV0sXG4gICAgXCI4ODk5XCI6IFswLjU1MDAxLCAxLjA1LCAwLCAwLCAxLjExMTExXSxcbiAgICBcIjg5NjhcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDAsIDAuNTI3NzhdLFxuICAgIFwiODk2OVwiOiBbMC42NTAwMiwgMS4xNSwgMCwgMCwgMC41Mjc3OF0sXG4gICAgXCI4OTcwXCI6IFswLjY1MDAyLCAxLjE1LCAwLCAwLCAwLjUyNzc4XSxcbiAgICBcIjg5NzFcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDAsIDAuNTI3NzhdLFxuICAgIFwiMTAyMTZcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDAsIDAuNjExMTFdLFxuICAgIFwiMTAyMTdcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDAsIDAuNjExMTFdLFxuICAgIFwiMTA3NTJcIjogWzAuNTUwMDEsIDEuMDUsIDAsIDAsIDEuNTExMTJdLFxuICAgIFwiMTA3NTNcIjogWzAuNTUwMDEsIDEuMDUsIDAsIDAsIDEuNTExMTJdLFxuICAgIFwiMTA3NTRcIjogWzAuNTUwMDEsIDEuMDUsIDAsIDAsIDEuNTExMTJdLFxuICAgIFwiMTA3NTZcIjogWzAuNTUwMDEsIDEuMDUsIDAsIDAsIDEuMTExMTFdLFxuICAgIFwiMTA3NThcIjogWzAuNTUwMDEsIDEuMDUsIDAsIDAsIDEuMTExMTFdXG4gIH0sXG4gIFwiU2l6ZTMtUmVndWxhclwiOiB7XG4gICAgXCIzMlwiOiBbMCwgMCwgMCwgMCwgMC4yNV0sXG4gICAgXCI0MFwiOiBbMC45NTAwMywgMS40NSwgMCwgMCwgMC43MzYxMV0sXG4gICAgXCI0MVwiOiBbMC45NTAwMywgMS40NSwgMCwgMCwgMC43MzYxMV0sXG4gICAgXCI0N1wiOiBbMC45NTAwMywgMS40NSwgMCwgMCwgMS4wNDQ0NV0sXG4gICAgXCI5MVwiOiBbMC45NTAwMywgMS40NSwgMCwgMCwgMC41Mjc3OF0sXG4gICAgXCI5MlwiOiBbMC45NTAwMywgMS40NSwgMCwgMCwgMS4wNDQ0NV0sXG4gICAgXCI5M1wiOiBbMC45NTAwMywgMS40NSwgMCwgMCwgMC41Mjc3OF0sXG4gICAgXCIxMjNcIjogWzAuOTUwMDMsIDEuNDUsIDAsIDAsIDAuNzVdLFxuICAgIFwiMTI1XCI6IFswLjk1MDAzLCAxLjQ1LCAwLCAwLCAwLjc1XSxcbiAgICBcIjE2MFwiOiBbMCwgMCwgMCwgMCwgMC4yNV0sXG4gICAgXCI3MTBcIjogWzAsIDAuNzUsIDAsIDAsIDEuNDQ0NDVdLFxuICAgIFwiNzMyXCI6IFswLCAwLjc1LCAwLCAwLCAxLjQ0NDQ1XSxcbiAgICBcIjc3MFwiOiBbMCwgMC43NSwgMCwgMCwgMS40NDQ0NV0sXG4gICAgXCI3NzFcIjogWzAsIDAuNzUsIDAsIDAsIDEuNDQ0NDVdLFxuICAgIFwiODczMFwiOiBbMC45NTAwMywgMS40NSwgMCwgMCwgMS4wXSxcbiAgICBcIjg5NjhcIjogWzAuOTUwMDMsIDEuNDUsIDAsIDAsIDAuNTgzMzRdLFxuICAgIFwiODk2OVwiOiBbMC45NTAwMywgMS40NSwgMCwgMCwgMC41ODMzNF0sXG4gICAgXCI4OTcwXCI6IFswLjk1MDAzLCAxLjQ1LCAwLCAwLCAwLjU4MzM0XSxcbiAgICBcIjg5NzFcIjogWzAuOTUwMDMsIDEuNDUsIDAsIDAsIDAuNTgzMzRdLFxuICAgIFwiMTAyMTZcIjogWzAuOTUwMDMsIDEuNDUsIDAsIDAsIDAuNzVdLFxuICAgIFwiMTAyMTdcIjogWzAuOTUwMDMsIDEuNDUsIDAsIDAsIDAuNzVdXG4gIH0sXG4gIFwiU2l6ZTQtUmVndWxhclwiOiB7XG4gICAgXCIzMlwiOiBbMCwgMCwgMCwgMCwgMC4yNV0sXG4gICAgXCI0MFwiOiBbMS4yNTAwMywgMS43NSwgMCwgMCwgMC43OTE2N10sXG4gICAgXCI0MVwiOiBbMS4yNTAwMywgMS43NSwgMCwgMCwgMC43OTE2N10sXG4gICAgXCI0N1wiOiBbMS4yNTAwMywgMS43NSwgMCwgMCwgMS4yNzc3OF0sXG4gICAgXCI5MVwiOiBbMS4yNTAwMywgMS43NSwgMCwgMCwgMC41ODMzNF0sXG4gICAgXCI5MlwiOiBbMS4yNTAwMywgMS43NSwgMCwgMCwgMS4yNzc3OF0sXG4gICAgXCI5M1wiOiBbMS4yNTAwMywgMS43NSwgMCwgMCwgMC41ODMzNF0sXG4gICAgXCIxMjNcIjogWzEuMjUwMDMsIDEuNzUsIDAsIDAsIDAuODA1NTZdLFxuICAgIFwiMTI1XCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwLCAwLjgwNTU2XSxcbiAgICBcIjE2MFwiOiBbMCwgMCwgMCwgMCwgMC4yNV0sXG4gICAgXCI3MTBcIjogWzAsIDAuODI1LCAwLCAwLCAxLjg4ODldLFxuICAgIFwiNzMyXCI6IFswLCAwLjgyNSwgMCwgMCwgMS44ODg5XSxcbiAgICBcIjc3MFwiOiBbMCwgMC44MjUsIDAsIDAsIDEuODg4OV0sXG4gICAgXCI3NzFcIjogWzAsIDAuODI1LCAwLCAwLCAxLjg4ODldLFxuICAgIFwiODczMFwiOiBbMS4yNTAwMywgMS43NSwgMCwgMCwgMS4wXSxcbiAgICBcIjg5NjhcIjogWzEuMjUwMDMsIDEuNzUsIDAsIDAsIDAuNjM4ODldLFxuICAgIFwiODk2OVwiOiBbMS4yNTAwMywgMS43NSwgMCwgMCwgMC42Mzg4OV0sXG4gICAgXCI4OTcwXCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwLCAwLjYzODg5XSxcbiAgICBcIjg5NzFcIjogWzEuMjUwMDMsIDEuNzUsIDAsIDAsIDAuNjM4ODldLFxuICAgIFwiOTExNVwiOiBbMC42NDUwMiwgMS4xNTUsIDAsIDAsIDAuODc1XSxcbiAgICBcIjkxMTZcIjogWzFlLTA1LCAwLjYsIDAsIDAsIDAuODc1XSxcbiAgICBcIjkxMTdcIjogWzAuNjQ1MDIsIDEuMTU1LCAwLCAwLCAwLjg3NV0sXG4gICAgXCI5MTE4XCI6IFswLjY0NTAyLCAxLjE1NSwgMCwgMCwgMC44NzVdLFxuICAgIFwiOTExOVwiOiBbMWUtMDUsIDAuNiwgMCwgMCwgMC44NzVdLFxuICAgIFwiOTEyMFwiOiBbMC42NDUwMiwgMS4xNTUsIDAsIDAsIDAuODc1XSxcbiAgICBcIjkxMjFcIjogWzAuNjQ1MDIsIDEuMTU1LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjkxMjJcIjogWy0wLjAwMDk5LCAwLjYwMSwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI5MTIzXCI6IFswLjY0NTAyLCAxLjE1NSwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI5MTI0XCI6IFswLjY0NTAyLCAxLjE1NSwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI5MTI1XCI6IFstMC4wMDA5OSwgMC42MDEsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiOTEyNlwiOiBbMC42NDUwMiwgMS4xNTUsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiOTEyN1wiOiBbMWUtMDUsIDAuOSwgMCwgMCwgMC44ODg4OV0sXG4gICAgXCI5MTI4XCI6IFswLjY1MDAyLCAxLjE1LCAwLCAwLCAwLjg4ODg5XSxcbiAgICBcIjkxMjlcIjogWzAuOTAwMDEsIDAsIDAsIDAsIDAuODg4ODldLFxuICAgIFwiOTEzMFwiOiBbMCwgMC4zLCAwLCAwLCAwLjg4ODg5XSxcbiAgICBcIjkxMzFcIjogWzFlLTA1LCAwLjksIDAsIDAsIDAuODg4ODldLFxuICAgIFwiOTEzMlwiOiBbMC42NTAwMiwgMS4xNSwgMCwgMCwgMC44ODg4OV0sXG4gICAgXCI5MTMzXCI6IFswLjkwMDAxLCAwLCAwLCAwLCAwLjg4ODg5XSxcbiAgICBcIjkxNDNcIjogWzAuODg1MDIsIDAuOTE1LCAwLCAwLCAxLjA1NTU2XSxcbiAgICBcIjEwMjE2XCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwLCAwLjgwNTU2XSxcbiAgICBcIjEwMjE3XCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwLCAwLjgwNTU2XSxcbiAgICBcIjU3MzQ0XCI6IFstMC4wMDQ5OSwgMC42MDUsIDAsIDAsIDEuMDU1NTZdLFxuICAgIFwiNTczNDVcIjogWy0wLjAwNDk5LCAwLjYwNSwgMCwgMCwgMS4wNTU1Nl0sXG4gICAgXCI1NzY4MFwiOiBbMCwgMC4xMiwgMCwgMCwgMC40NV0sXG4gICAgXCI1NzY4MVwiOiBbMCwgMC4xMiwgMCwgMCwgMC40NV0sXG4gICAgXCI1NzY4MlwiOiBbMCwgMC4xMiwgMCwgMCwgMC40NV0sXG4gICAgXCI1NzY4M1wiOiBbMCwgMC4xMiwgMCwgMCwgMC40NV1cbiAgfSxcbiAgXCJUeXBld3JpdGVyLVJlZ3VsYXJcIjoge1xuICAgIFwiMzJcIjogWzAsIDAsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjMzXCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCIzNFwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiMzVcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjM2XCI6IFswLjA4MzMzLCAwLjY5NDQ0LCAwLCAwLCAwLjUyNV0sXG4gICAgXCIzN1wiOiBbMC4wODMzMywgMC42OTQ0NCwgMCwgMCwgMC41MjVdLFxuICAgIFwiMzhcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjM5XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI0MFwiOiBbMC4wODMzMywgMC42OTQ0NCwgMCwgMCwgMC41MjVdLFxuICAgIFwiNDFcIjogWzAuMDgzMzMsIDAuNjk0NDQsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjQyXCI6IFswLCAwLjUyMDgzLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI0M1wiOiBbLTAuMDgwNTYsIDAuNTMwNTUsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjQ0XCI6IFswLjEzODg5LCAwLjEyNSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNDVcIjogWy0wLjA4MDU2LCAwLjUzMDU1LCAwLCAwLCAwLjUyNV0sXG4gICAgXCI0NlwiOiBbMCwgMC4xMjUsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjQ3XCI6IFswLjA4MzMzLCAwLjY5NDQ0LCAwLCAwLCAwLjUyNV0sXG4gICAgXCI0OFwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNDlcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjUwXCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI1MVwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNTJcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjUzXCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI1NFwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNTVcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjU2XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI1N1wiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNThcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjU5XCI6IFswLjEzODg5LCAwLjQzMDU2LCAwLCAwLCAwLjUyNV0sXG4gICAgXCI2MFwiOiBbLTAuMDU1NTYsIDAuNTU1NTYsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjYxXCI6IFstMC4xOTU0OSwgMC40MTU2MiwgMCwgMCwgMC41MjVdLFxuICAgIFwiNjJcIjogWy0wLjA1NTU2LCAwLjU1NTU2LCAwLCAwLCAwLjUyNV0sXG4gICAgXCI2M1wiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNjRcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjY1XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI2NlwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNjdcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjY4XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI2OVwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNzBcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjcxXCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI3MlwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNzNcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjc0XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI3NVwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNzZcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjc3XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI3OFwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNzlcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjgwXCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI4MVwiOiBbMC4xMzg4OSwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiODJcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjgzXCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI4NFwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiODVcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjg2XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI4N1wiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiODhcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjg5XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI5MFwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiOTFcIjogWzAuMDgzMzMsIDAuNjk0NDQsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjkyXCI6IFswLjA4MzMzLCAwLjY5NDQ0LCAwLCAwLCAwLjUyNV0sXG4gICAgXCI5M1wiOiBbMC4wODMzMywgMC42OTQ0NCwgMCwgMCwgMC41MjVdLFxuICAgIFwiOTRcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjk1XCI6IFswLjA5NTE0LCAwLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI5NlwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiOTdcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjk4XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI5OVwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTAwXCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMDFcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjEwMlwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTAzXCI6IFswLjIyMjIyLCAwLjQzMDU2LCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMDRcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjEwNVwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTA2XCI6IFswLjIyMjIyLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMDdcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjEwOFwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTA5XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMTBcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjExMVwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTEyXCI6IFswLjIyMjIyLCAwLjQzMDU2LCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMTNcIjogWzAuMjIyMjIsIDAuNDMwNTYsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjExNFwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTE1XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMTZcIjogWzAsIDAuNTUzNTgsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjExN1wiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTE4XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMTlcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjEyMFwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTIxXCI6IFswLjIyMjIyLCAwLjQzMDU2LCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMjJcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjEyM1wiOiBbMC4wODMzMywgMC42OTQ0NCwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTI0XCI6IFswLjA4MzMzLCAwLjY5NDQ0LCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMjVcIjogWzAuMDgzMzMsIDAuNjk0NDQsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjEyNlwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTI3XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxNjBcIjogWzAsIDAsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjE3NlwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTg0XCI6IFswLjE5NDQ1LCAwLCAwLCAwLCAwLjUyNV0sXG4gICAgXCIzMDVcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjU2N1wiOiBbMC4yMjIyMiwgMC40MzA1NiwgMCwgMCwgMC41MjVdLFxuICAgIFwiNzExXCI6IFswLCAwLjU2NTk3LCAwLCAwLCAwLjUyNV0sXG4gICAgXCI3MTNcIjogWzAsIDAuNTY1NTUsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjcxNFwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNzE1XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI3MjhcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjczMFwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNzcwXCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI3NzFcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjc3NlwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiOTE1XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI5MTZcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjkyMFwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiOTIzXCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI5MjZcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjkyOFwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiOTMxXCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI5MzNcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjkzNFwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiOTM2XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI5MzdcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjgyMTZcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjgyMTdcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjgyNDJcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjkyNTFcIjogWzAuMTExMTEsIDAuMjE5NDQsIDAsIDAsIDAuNTI1XVxuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mb250TWV0cmljcy5qc1xuXG5cbi8qKlxuICogVGhpcyBmaWxlIGNvbnRhaW5zIG1ldHJpY3MgcmVnYXJkaW5nIGZvbnRzIGFuZCBpbmRpdmlkdWFsIHN5bWJvbHMuIFRoZSBzaWdtYVxuICogYW5kIHhpIHZhcmlhYmxlcywgYXMgd2VsbCBhcyB0aGUgbWV0cmljTWFwIG1hcCBjb250YWluIGRhdGEgZXh0cmFjdGVkIGZyb21cbiAqIFRlWCwgVGVYIGZvbnQgbWV0cmljcywgYW5kIHRoZSBUVEYgZmlsZXMuIFRoZXNlIGRhdGEgYXJlIHRoZW4gZXhwb3NlZCB2aWEgdGhlXG4gKiBgbWV0cmljc2AgdmFyaWFibGUgYW5kIHRoZSBnZXRDaGFyYWN0ZXJNZXRyaWNzIGZ1bmN0aW9uLlxuICovXG4vLyBJbiBUZVgsIHRoZXJlIGFyZSBhY3R1YWxseSB0aHJlZSBzZXRzIG9mIGRpbWVuc2lvbnMsIG9uZSBmb3IgZWFjaCBvZlxuLy8gdGV4dHN0eWxlIChzaXplIGluZGV4IDUgYW5kIGhpZ2hlcjogPj05cHQpLCBzY3JpcHRzdHlsZSAoc2l6ZSBpbmRleCAzIGFuZCA0OlxuLy8gNy04cHQpLCBhbmQgc2NyaXB0c2NyaXB0c3R5bGUgKHNpemUgaW5kZXggMSBhbmQgMjogNS02cHQpLiAgVGhlc2UgYXJlXG4vLyBwcm92aWRlZCBpbiB0aGUgYXJyYXlzIGJlbG93LCBpbiB0aGF0IG9yZGVyLlxuLy9cbi8vIFRoZSBmb250IG1ldHJpY3MgYXJlIHN0b3JlZCBpbiBmb250cyBjbXN5MTAsIGNtc3k3LCBhbmQgY21zeTUgcmVzcGVjdGl2ZWx5LlxuLy8gVGhpcyB3YXMgZGV0ZXJtaW5lZCBieSBydW5uaW5nIHRoZSBmb2xsb3dpbmcgc2NyaXB0OlxuLy9cbi8vICAgICBsYXRleCAtaW50ZXJhY3Rpb249bm9uc3RvcG1vZGUgXFxcbi8vICAgICAnXFxkb2N1bWVudGNsYXNze2FydGljbGV9XFx1c2VwYWNrYWdle2Ftc21hdGh9XFxiZWdpbntkb2N1bWVudH0nIFxcXG4vLyAgICAgJyRhJCBcXGV4cGFuZGFmdGVyXFxzaG93XFx0aGVcXHRleHRmb250MicgXFxcbi8vICAgICAnXFxleHBhbmRhZnRlclxcc2hvd1xcdGhlXFxzY3JpcHRmb250MicgXFxcbi8vICAgICAnXFxleHBhbmRhZnRlclxcc2hvd1xcdGhlXFxzY3JpcHRzY3JpcHRmb250MicgXFxcbi8vICAgICAnXFxzdG9wJ1xuLy9cbi8vIFRoZSBtZXRyaWNzIHRoZW1zZWx2ZXMgd2VyZSByZXRyaWV2ZWQgdXNpbmcgdGhlIGZvbGxvd2luZyBjb21tYW5kczpcbi8vXG4vLyAgICAgdGZ0b3BsIGNtc3kxMFxuLy8gICAgIHRmdG9wbCBjbXN5N1xuLy8gICAgIHRmdG9wbCBjbXN5NVxuLy9cbi8vIFRoZSBvdXRwdXQgb2YgZWFjaCBvZiB0aGVzZSBjb21tYW5kcyBpcyBxdWl0ZSBsZW5ndGh5LiAgVGhlIG9ubHkgcGFydCB3ZVxuLy8gY2FyZSBhYm91dCBpcyB0aGUgRk9OVERJTUVOIHNlY3Rpb24uIEVhY2ggdmFsdWUgaXMgbWVhc3VyZWQgaW4gRU1zLlxuY29uc3Qgc2lnbWFzQW5kWGlzID0ge1xuICBzbGFudDogWzAuMjUwLCAwLjI1MCwgMC4yNTBdLFxuICAvLyBzaWdtYTFcbiAgc3BhY2U6IFswLjAwMCwgMC4wMDAsIDAuMDAwXSxcbiAgLy8gc2lnbWEyXG4gIHN0cmV0Y2g6IFswLjAwMCwgMC4wMDAsIDAuMDAwXSxcbiAgLy8gc2lnbWEzXG4gIHNocmluazogWzAuMDAwLCAwLjAwMCwgMC4wMDBdLFxuICAvLyBzaWdtYTRcbiAgeEhlaWdodDogWzAuNDMxLCAwLjQzMSwgMC40MzFdLFxuICAvLyBzaWdtYTVcbiAgcXVhZDogWzEuMDAwLCAxLjE3MSwgMS40NzJdLFxuICAvLyBzaWdtYTZcbiAgZXh0cmFTcGFjZTogWzAuMDAwLCAwLjAwMCwgMC4wMDBdLFxuICAvLyBzaWdtYTdcbiAgbnVtMTogWzAuNjc3LCAwLjczMiwgMC45MjVdLFxuICAvLyBzaWdtYThcbiAgbnVtMjogWzAuMzk0LCAwLjM4NCwgMC4zODddLFxuICAvLyBzaWdtYTlcbiAgbnVtMzogWzAuNDQ0LCAwLjQ3MSwgMC41MDRdLFxuICAvLyBzaWdtYTEwXG4gIGRlbm9tMTogWzAuNjg2LCAwLjc1MiwgMS4wMjVdLFxuICAvLyBzaWdtYTExXG4gIGRlbm9tMjogWzAuMzQ1LCAwLjM0NCwgMC41MzJdLFxuICAvLyBzaWdtYTEyXG4gIHN1cDE6IFswLjQxMywgMC41MDMsIDAuNTA0XSxcbiAgLy8gc2lnbWExM1xuICBzdXAyOiBbMC4zNjMsIDAuNDMxLCAwLjQwNF0sXG4gIC8vIHNpZ21hMTRcbiAgc3VwMzogWzAuMjg5LCAwLjI4NiwgMC4yOTRdLFxuICAvLyBzaWdtYTE1XG4gIHN1YjE6IFswLjE1MCwgMC4xNDMsIDAuMjAwXSxcbiAgLy8gc2lnbWExNlxuICBzdWIyOiBbMC4yNDcsIDAuMjg2LCAwLjQwMF0sXG4gIC8vIHNpZ21hMTdcbiAgc3VwRHJvcDogWzAuMzg2LCAwLjM1MywgMC40OTRdLFxuICAvLyBzaWdtYTE4XG4gIHN1YkRyb3A6IFswLjA1MCwgMC4wNzEsIDAuMTAwXSxcbiAgLy8gc2lnbWExOVxuICBkZWxpbTE6IFsyLjM5MCwgMS43MDAsIDEuOTgwXSxcbiAgLy8gc2lnbWEyMFxuICBkZWxpbTI6IFsxLjAxMCwgMS4xNTcsIDEuNDIwXSxcbiAgLy8gc2lnbWEyMVxuICBheGlzSGVpZ2h0OiBbMC4yNTAsIDAuMjUwLCAwLjI1MF0sXG4gIC8vIHNpZ21hMjJcbiAgLy8gVGhlc2UgZm9udCBtZXRyaWNzIGFyZSBleHRyYWN0ZWQgZnJvbSBUZVggYnkgdXNpbmcgdGZ0b3BsIG9uIGNtZXgxMC50Zm07XG4gIC8vIHRoZXkgY29ycmVzcG9uZCB0byB0aGUgZm9udCBwYXJhbWV0ZXJzIG9mIHRoZSBleHRlbnNpb24gZm9udHMgKGZhbWlseSAzKS5cbiAgLy8gU2VlIHRoZSBUZVhib29rLCBwYWdlIDQ0MS4gSW4gQU1TVGVYLCB0aGUgZXh0ZW5zaW9uIGZvbnRzIHNjYWxlOyB0b1xuICAvLyBtYXRjaCBjbWV4Nywgd2UnZCB1c2UgY21leDcudGZtIHZhbHVlcyBmb3Igc2NyaXB0IGFuZCBzY3JpcHRzY3JpcHRcbiAgLy8gdmFsdWVzLlxuICBkZWZhdWx0UnVsZVRoaWNrbmVzczogWzAuMDQsIDAuMDQ5LCAwLjA0OV0sXG4gIC8vIHhpODsgY21leDc6IDAuMDQ5XG4gIGJpZ09wU3BhY2luZzE6IFswLjExMSwgMC4xMTEsIDAuMTExXSxcbiAgLy8geGk5XG4gIGJpZ09wU3BhY2luZzI6IFswLjE2NiwgMC4xNjYsIDAuMTY2XSxcbiAgLy8geGkxMFxuICBiaWdPcFNwYWNpbmczOiBbMC4yLCAwLjIsIDAuMl0sXG4gIC8vIHhpMTFcbiAgYmlnT3BTcGFjaW5nNDogWzAuNiwgMC42MTEsIDAuNjExXSxcbiAgLy8geGkxMjsgY21leDc6IDAuNjExXG4gIGJpZ09wU3BhY2luZzU6IFswLjEsIDAuMTQzLCAwLjE0M10sXG4gIC8vIHhpMTM7IGNtZXg3OiAwLjE0M1xuICAvLyBUaGUgXFxzcXJ0IHJ1bGUgd2lkdGggaXMgdGFrZW4gZnJvbSB0aGUgaGVpZ2h0IG9mIHRoZSBzdXJkIGNoYXJhY3Rlci5cbiAgLy8gU2luY2Ugd2UgdXNlIHRoZSBzYW1lIGZvbnQgYXQgYWxsIHNpemVzLCB0aGlzIHRoaWNrbmVzcyBkb2Vzbid0IHNjYWxlLlxuICBzcXJ0UnVsZVRoaWNrbmVzczogWzAuMDQsIDAuMDQsIDAuMDRdLFxuICAvLyBUaGlzIHZhbHVlIGRldGVybWluZXMgaG93IGxhcmdlIGEgcHQgaXMsIGZvciBtZXRyaWNzIHdoaWNoIGFyZSBkZWZpbmVkXG4gIC8vIGluIHRlcm1zIG9mIHB0cy5cbiAgLy8gVGhpcyB2YWx1ZSBpcyBhbHNvIHVzZWQgaW4ga2F0ZXguc2NzczsgaWYgeW91IGNoYW5nZSBpdCBtYWtlIHN1cmUgdGhlXG4gIC8vIHZhbHVlcyBtYXRjaC5cbiAgcHRQZXJFbTogWzEwLjAsIDEwLjAsIDEwLjBdLFxuICAvLyBUaGUgc3BhY2UgYmV0d2VlbiBhZGphY2VudCBgfGAgY29sdW1ucyBpbiBhbiBhcnJheSBkZWZpbml0aW9uLiBGcm9tXG4gIC8vIGBcXHNob3d0aGVcXGRvdWJsZXJ1bGVzZXBgIGluIExhVGVYLiBFcXVhbHMgMi4wIC8gcHRQZXJFbS5cbiAgZG91YmxlUnVsZVNlcDogWzAuMiwgMC4yLCAwLjJdLFxuICAvLyBUaGUgd2lkdGggb2Ygc2VwYXJhdG9yIGxpbmVzIGluIHthcnJheX0gZW52aXJvbm1lbnRzLiBGcm9tXG4gIC8vIGBcXHNob3d0aGVcXGFycmF5cnVsZXdpZHRoYCBpbiBMYVRlWC4gRXF1YWxzIDAuNCAvIHB0UGVyRW0uXG4gIGFycmF5UnVsZVdpZHRoOiBbMC4wNCwgMC4wNCwgMC4wNF0sXG4gIC8vIFR3byB2YWx1ZXMgZnJvbSBMYVRlWCBzb3VyY2UyZTpcbiAgZmJveHNlcDogWzAuMywgMC4zLCAwLjNdLFxuICAvLyAgICAgICAgMyBwdCAvIHB0UGVyRW1cbiAgZmJveHJ1bGU6IFswLjA0LCAwLjA0LCAwLjA0XSAvLyAwLjQgcHQgLyBwdFBlckVtXG5cbn07IC8vIFRoaXMgbWFwIGNvbnRhaW5zIGEgbWFwcGluZyBmcm9tIGZvbnQgbmFtZSBhbmQgY2hhcmFjdGVyIGNvZGUgdG8gY2hhcmFjdGVyXG4vLyBtZXRyaWNzLCBpbmNsdWRpbmcgaGVpZ2h0LCBkZXB0aCwgaXRhbGljIGNvcnJlY3Rpb24sIGFuZCBza2V3IChrZXJuIGZyb20gdGhlXG4vLyBjaGFyYWN0ZXIgdG8gdGhlIGNvcnJlc3BvbmRpbmcgXFxza2V3Y2hhcilcbi8vIFRoaXMgbWFwIGlzIGdlbmVyYXRlZCB2aWEgYG1ha2UgbWV0cmljc2AuIEl0IHNob3VsZCBub3QgYmUgY2hhbmdlZCBtYW51YWxseS5cblxuIC8vIFRoZXNlIGFyZSB2ZXJ5IHJvdWdoIGFwcHJveGltYXRpb25zLiAgV2UgZGVmYXVsdCB0byBUaW1lcyBOZXcgUm9tYW4gd2hpY2hcbi8vIHNob3VsZCBoYXZlIExhdGluLTEgYW5kIEN5cmlsbGljIGNoYXJhY3RlcnMsIGJ1dCBtYXkgbm90IGRlcGVuZGluZyBvbiB0aGVcbi8vIG9wZXJhdGluZyBzeXN0ZW0uICBUaGUgbWV0cmljcyBkbyBub3QgYWNjb3VudCBmb3IgZXh0cmEgaGVpZ2h0IGZyb20gdGhlXG4vLyBhY2NlbnRzLiAgSW4gdGhlIGNhc2Ugb2YgQ3lyaWxsaWMgY2hhcmFjdGVycyB3aGljaCBoYXZlIGJvdGggYXNjZW5kZXJzIGFuZFxuLy8gZGVzY2VuZGVycyB3ZSBwcmVmZXIgYXBwcm94aW1hdGlvbnMgd2l0aCBhc2NlbmRlcnMsIHByaW1hcmlseSB0byBwcmV2ZW50XG4vLyB0aGUgZnJhY3Rpb24gYmFyIG9yIHJvb3QgbGluZSBmcm9tIGludGVyc2VjdGluZyB0aGUgZ2x5cGguXG4vLyBUT0RPKGtldmluYikgYWxsb3cgdW5pb24gb2YgbXVsdGlwbGUgZ2x5cGggbWV0cmljcyBmb3IgYmV0dGVyIGFjY3VyYWN5LlxuXG5jb25zdCBleHRyYUNoYXJhY3Rlck1hcCA9IHtcbiAgLy8gTGF0aW4tMVxuICAnw4UnOiAnQScsXG4gICfDkCc6ICdEJyxcbiAgJ8OeJzogJ28nLFxuICAnw6UnOiAnYScsXG4gICfDsCc6ICdkJyxcbiAgJ8O+JzogJ28nLFxuICAvLyBDeXJpbGxpY1xuICAn0JAnOiAnQScsXG4gICfQkSc6ICdCJyxcbiAgJ9CSJzogJ0InLFxuICAn0JMnOiAnRicsXG4gICfQlCc6ICdBJyxcbiAgJ9CVJzogJ0UnLFxuICAn0JYnOiAnSycsXG4gICfQlyc6ICczJyxcbiAgJ9CYJzogJ04nLFxuICAn0JknOiAnTicsXG4gICfQmic6ICdLJyxcbiAgJ9CbJzogJ04nLFxuICAn0JwnOiAnTScsXG4gICfQnSc6ICdIJyxcbiAgJ9CeJzogJ08nLFxuICAn0J8nOiAnTicsXG4gICfQoCc6ICdQJyxcbiAgJ9ChJzogJ0MnLFxuICAn0KInOiAnVCcsXG4gICfQoyc6ICd5JyxcbiAgJ9CkJzogJ08nLFxuICAn0KUnOiAnWCcsXG4gICfQpic6ICdVJyxcbiAgJ9CnJzogJ2gnLFxuICAn0KgnOiAnVycsXG4gICfQqSc6ICdXJyxcbiAgJ9CqJzogJ0InLFxuICAn0KsnOiAnWCcsXG4gICfQrCc6ICdCJyxcbiAgJ9CtJzogJzMnLFxuICAn0K4nOiAnWCcsXG4gICfQryc6ICdSJyxcbiAgJ9CwJzogJ2EnLFxuICAn0LEnOiAnYicsXG4gICfQsic6ICdhJyxcbiAgJ9CzJzogJ3InLFxuICAn0LQnOiAneScsXG4gICfQtSc6ICdlJyxcbiAgJ9C2JzogJ20nLFxuICAn0LcnOiAnZScsXG4gICfQuCc6ICduJyxcbiAgJ9C5JzogJ24nLFxuICAn0LonOiAnbicsXG4gICfQuyc6ICduJyxcbiAgJ9C8JzogJ20nLFxuICAn0L0nOiAnbicsXG4gICfQvic6ICdvJyxcbiAgJ9C/JzogJ24nLFxuICAn0YAnOiAncCcsXG4gICfRgSc6ICdjJyxcbiAgJ9GCJzogJ28nLFxuICAn0YMnOiAneScsXG4gICfRhCc6ICdiJyxcbiAgJ9GFJzogJ3gnLFxuICAn0YYnOiAnbicsXG4gICfRhyc6ICduJyxcbiAgJ9GIJzogJ3cnLFxuICAn0YknOiAndycsXG4gICfRiic6ICdhJyxcbiAgJ9GLJzogJ20nLFxuICAn0YwnOiAnYScsXG4gICfRjSc6ICdlJyxcbiAgJ9GOJzogJ20nLFxuICAn0Y8nOiAncidcbn07XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBhZGRzIG5ldyBmb250IG1ldHJpY3MgdG8gZGVmYXVsdCBtZXRyaWNNYXBcbiAqIEl0IGNhbiBhbHNvIG92ZXJyaWRlIGV4aXN0aW5nIG1ldHJpY3NcbiAqL1xuZnVuY3Rpb24gc2V0Rm9udE1ldHJpY3MoZm9udE5hbWUsIG1ldHJpY3MpIHtcbiAgZm9udE1ldHJpY3NEYXRhW2ZvbnROYW1lXSA9IG1ldHJpY3M7XG59XG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgYSBjb252ZW5pZW5jZSBmdW5jdGlvbiBmb3IgbG9va2luZyB1cCBpbmZvcm1hdGlvbiBpbiB0aGVcbiAqIG1ldHJpY01hcCB0YWJsZS4gSXQgdGFrZXMgYSBjaGFyYWN0ZXIgYXMgYSBzdHJpbmcsIGFuZCBhIGZvbnQuXG4gKlxuICogTm90ZTogdGhlIGB3aWR0aGAgcHJvcGVydHkgbWF5IGJlIHVuZGVmaW5lZCBpZiBmb250TWV0cmljc0RhdGEuanMgd2Fzbid0XG4gKiBidWlsdCB1c2luZyBgTWFrZSBleHRlbmRlZF9tZXRyaWNzYC5cbiAqL1xuXG5mdW5jdGlvbiBnZXRDaGFyYWN0ZXJNZXRyaWNzKGNoYXJhY3RlciwgZm9udCwgbW9kZSkge1xuICBpZiAoIWZvbnRNZXRyaWNzRGF0YVtmb250XSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkZvbnQgbWV0cmljcyBub3QgZm91bmQgZm9yIGZvbnQ6IFwiICsgZm9udCArIFwiLlwiKTtcbiAgfVxuXG4gIGxldCBjaCA9IGNoYXJhY3Rlci5jaGFyQ29kZUF0KDApO1xuICBsZXQgbWV0cmljcyA9IGZvbnRNZXRyaWNzRGF0YVtmb250XVtjaF07XG5cbiAgaWYgKCFtZXRyaWNzICYmIGNoYXJhY3RlclswXSBpbiBleHRyYUNoYXJhY3Rlck1hcCkge1xuICAgIGNoID0gZXh0cmFDaGFyYWN0ZXJNYXBbY2hhcmFjdGVyWzBdXS5jaGFyQ29kZUF0KDApO1xuICAgIG1ldHJpY3MgPSBmb250TWV0cmljc0RhdGFbZm9udF1bY2hdO1xuICB9XG5cbiAgaWYgKCFtZXRyaWNzICYmIG1vZGUgPT09ICd0ZXh0Jykge1xuICAgIC8vIFdlIGRvbid0IHR5cGljYWxseSBoYXZlIGZvbnQgbWV0cmljcyBmb3IgQXNpYW4gc2NyaXB0cy5cbiAgICAvLyBCdXQgc2luY2Ugd2Ugc3VwcG9ydCB0aGVtIGluIHRleHQgbW9kZSwgd2UgbmVlZCB0byByZXR1cm5cbiAgICAvLyBzb21lIHNvcnQgb2YgbWV0cmljcy5cbiAgICAvLyBTbyBpZiB0aGUgY2hhcmFjdGVyIGlzIGluIGEgc2NyaXB0IHdlIHN1cHBvcnQgYnV0IHdlXG4gICAgLy8gZG9uJ3QgaGF2ZSBtZXRyaWNzIGZvciBpdCwganVzdCB1c2UgdGhlIG1ldHJpY3MgZm9yXG4gICAgLy8gdGhlIExhdGluIGNhcGl0YWwgbGV0dGVyIE0uIFRoaXMgaXMgY2xvc2UgZW5vdWdoIGJlY2F1c2VcbiAgICAvLyB3ZSAoY3VycmVudGx5KSBvbmx5IGNhcmUgYWJvdXQgdGhlIGhlaWdodCBvZiB0aGUgZ2x5cGhcbiAgICAvLyBub3QgaXRzIHdpZHRoLlxuICAgIGlmIChzdXBwb3J0ZWRDb2RlcG9pbnQoY2gpKSB7XG4gICAgICBtZXRyaWNzID0gZm9udE1ldHJpY3NEYXRhW2ZvbnRdWzc3XTsgLy8gNzcgaXMgdGhlIGNoYXJjb2RlIGZvciAnTSdcbiAgICB9XG4gIH1cblxuICBpZiAobWV0cmljcykge1xuICAgIHJldHVybiB7XG4gICAgICBkZXB0aDogbWV0cmljc1swXSxcbiAgICAgIGhlaWdodDogbWV0cmljc1sxXSxcbiAgICAgIGl0YWxpYzogbWV0cmljc1syXSxcbiAgICAgIHNrZXc6IG1ldHJpY3NbM10sXG4gICAgICB3aWR0aDogbWV0cmljc1s0XVxuICAgIH07XG4gIH1cbn1cbmNvbnN0IGZvbnRNZXRyaWNzQnlTaXplSW5kZXggPSB7fTtcbi8qKlxuICogR2V0IHRoZSBmb250IG1ldHJpY3MgZm9yIGEgZ2l2ZW4gc2l6ZS5cbiAqL1xuXG5mdW5jdGlvbiBnZXRHbG9iYWxNZXRyaWNzKHNpemUpIHtcbiAgbGV0IHNpemVJbmRleDtcblxuICBpZiAoc2l6ZSA+PSA1KSB7XG4gICAgc2l6ZUluZGV4ID0gMDtcbiAgfSBlbHNlIGlmIChzaXplID49IDMpIHtcbiAgICBzaXplSW5kZXggPSAxO1xuICB9IGVsc2Uge1xuICAgIHNpemVJbmRleCA9IDI7XG4gIH1cblxuICBpZiAoIWZvbnRNZXRyaWNzQnlTaXplSW5kZXhbc2l6ZUluZGV4XSkge1xuICAgIGNvbnN0IG1ldHJpY3MgPSBmb250TWV0cmljc0J5U2l6ZUluZGV4W3NpemVJbmRleF0gPSB7XG4gICAgICBjc3NFbVBlck11OiBzaWdtYXNBbmRYaXMucXVhZFtzaXplSW5kZXhdIC8gMThcbiAgICB9O1xuXG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2lnbWFzQW5kWGlzKSB7XG4gICAgICBpZiAoc2lnbWFzQW5kWGlzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgbWV0cmljc1trZXldID0gc2lnbWFzQW5kWGlzW2tleV1bc2l6ZUluZGV4XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZm9udE1ldHJpY3NCeVNpemVJbmRleFtzaXplSW5kZXhdO1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL09wdGlvbnMuanNcbi8qKlxuICogVGhpcyBmaWxlIGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvcHRpb25zIHRoYXQgdGhlIFBhcnNlciBjYXJyaWVzXG4gKiBhcm91bmQgd2l0aCBpdCB3aGlsZSBwYXJzaW5nLiBEYXRhIGlzIGhlbGQgaW4gYW4gYE9wdGlvbnNgIG9iamVjdCwgYW5kIHdoZW5cbiAqIHJlY3Vyc2luZywgYSBuZXcgYE9wdGlvbnNgIG9iamVjdCBjYW4gYmUgY3JlYXRlZCB3aXRoIHRoZSBgLndpdGgqYCBhbmRcbiAqIGAucmVzZXRgIGZ1bmN0aW9ucy5cbiAqL1xuXG5jb25zdCBzaXplU3R5bGVNYXAgPSBbLy8gRWFjaCBlbGVtZW50IGNvbnRhaW5zIFt0ZXh0c2l6ZSwgc2NyaXB0c2l6ZSwgc2NyaXB0c2NyaXB0c2l6ZV0uXG4vLyBUaGUgc2l6ZSBtYXBwaW5ncyBhcmUgdGFrZW4gZnJvbSBUZVggd2l0aCBcXG5vcm1hbHNpemU9MTBwdC5cblsxLCAxLCAxXSwgLy8gc2l6ZTE6IFs1LCA1LCA1XSAgICAgICAgICAgICAgXFx0aW55XG5bMiwgMSwgMV0sIC8vIHNpemUyOiBbNiwgNSwgNV1cblszLCAxLCAxXSwgLy8gc2l6ZTM6IFs3LCA1LCA1XSAgICAgICAgICAgICAgXFxzY3JpcHRzaXplXG5bNCwgMiwgMV0sIC8vIHNpemU0OiBbOCwgNiwgNV0gICAgICAgICAgICAgIFxcZm9vdG5vdGVzaXplXG5bNSwgMiwgMV0sIC8vIHNpemU1OiBbOSwgNiwgNV0gICAgICAgICAgICAgIFxcc21hbGxcbls2LCAzLCAxXSwgLy8gc2l6ZTY6IFsxMCwgNywgNV0gICAgICAgICAgICAgXFxub3JtYWxzaXplXG5bNywgNCwgMl0sIC8vIHNpemU3OiBbMTIsIDgsIDZdICAgICAgICAgICAgIFxcbGFyZ2Vcbls4LCA2LCAzXSwgLy8gc2l6ZTg6IFsxNC40LCAxMCwgN10gICAgICAgICAgXFxMYXJnZVxuWzksIDcsIDZdLCAvLyBzaXplOTogWzE3LjI4LCAxMiwgMTBdICAgICAgICBcXExBUkdFXG5bMTAsIDgsIDddLCAvLyBzaXplMTA6IFsyMC43NCwgMTQuNCwgMTJdICAgICBcXGh1Z2VcblsxMSwgMTAsIDldIC8vIHNpemUxMTogWzI0Ljg4LCAyMC43NCwgMTcuMjhdIFxcSFVHRVxuXTtcbmNvbnN0IHNpemVNdWx0aXBsaWVycyA9IFsvLyBmb250TWV0cmljcy5qczpnZXRHbG9iYWxNZXRyaWNzIGFsc28gdXNlcyBzaXplIGluZGV4ZXMsIHNvIGlmXG4vLyB5b3UgY2hhbmdlIHNpemUgaW5kZXhlcywgY2hhbmdlIHRoYXQgZnVuY3Rpb24uXG4wLjUsIDAuNiwgMC43LCAwLjgsIDAuOSwgMS4wLCAxLjIsIDEuNDQsIDEuNzI4LCAyLjA3NCwgMi40ODhdO1xuXG5jb25zdCBzaXplQXRTdHlsZSA9IGZ1bmN0aW9uIChzaXplLCBzdHlsZSkge1xuICByZXR1cm4gc3R5bGUuc2l6ZSA8IDIgPyBzaXplIDogc2l6ZVN0eWxlTWFwW3NpemUgLSAxXVtzdHlsZS5zaXplIC0gMV07XG59OyAvLyBJbiB0aGVzZSB0eXBlcywgXCJcIiAoZW1wdHkgc3RyaW5nKSBtZWFucyBcIm5vIGNoYW5nZVwiLlxuXG5cbi8qKlxuICogVGhpcyBpcyB0aGUgbWFpbiBvcHRpb25zIGNsYXNzLiBJdCBjb250YWlucyB0aGUgY3VycmVudCBzdHlsZSwgc2l6ZSwgY29sb3IsXG4gKiBhbmQgZm9udC5cbiAqXG4gKiBPcHRpb25zIG9iamVjdHMgc2hvdWxkIG5vdCBiZSBtb2RpZmllZC4gVG8gY3JlYXRlIGEgbmV3IE9wdGlvbnMgd2l0aFxuICogZGlmZmVyZW50IHByb3BlcnRpZXMsIGNhbGwgYSBgLmhhdmluZypgIG1ldGhvZC5cbiAqL1xuY2xhc3MgT3B0aW9ucyB7XG4gIC8vIEEgZm9udCBmYW1pbHkgYXBwbGllcyB0byBhIGdyb3VwIG9mIGZvbnRzIChpLmUuIFNhbnNTZXJpZiksIHdoaWxlIGEgZm9udFxuICAvLyByZXByZXNlbnRzIGEgc3BlY2lmaWMgZm9udCAoaS5lLiBTYW5zU2VyaWYgQm9sZCkuXG4gIC8vIFNlZTogaHR0cHM6Ly90ZXguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzIyMzUwL2RpZmZlcmVuY2UtYmV0d2Vlbi10ZXh0cm0tYW5kLW1hdGhybVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBzaXplIGluZGV4LlxuICAgKi9cbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHRoaXMuc3R5bGUgPSB2b2lkIDA7XG4gICAgdGhpcy5jb2xvciA9IHZvaWQgMDtcbiAgICB0aGlzLnNpemUgPSB2b2lkIDA7XG4gICAgdGhpcy50ZXh0U2l6ZSA9IHZvaWQgMDtcbiAgICB0aGlzLnBoYW50b20gPSB2b2lkIDA7XG4gICAgdGhpcy5mb250ID0gdm9pZCAwO1xuICAgIHRoaXMuZm9udEZhbWlseSA9IHZvaWQgMDtcbiAgICB0aGlzLmZvbnRXZWlnaHQgPSB2b2lkIDA7XG4gICAgdGhpcy5mb250U2hhcGUgPSB2b2lkIDA7XG4gICAgdGhpcy5zaXplTXVsdGlwbGllciA9IHZvaWQgMDtcbiAgICB0aGlzLm1heFNpemUgPSB2b2lkIDA7XG4gICAgdGhpcy5taW5SdWxlVGhpY2tuZXNzID0gdm9pZCAwO1xuICAgIHRoaXMuX2ZvbnRNZXRyaWNzID0gdm9pZCAwO1xuICAgIHRoaXMuc3R5bGUgPSBkYXRhLnN0eWxlO1xuICAgIHRoaXMuY29sb3IgPSBkYXRhLmNvbG9yO1xuICAgIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZSB8fCBPcHRpb25zLkJBU0VTSVpFO1xuICAgIHRoaXMudGV4dFNpemUgPSBkYXRhLnRleHRTaXplIHx8IHRoaXMuc2l6ZTtcbiAgICB0aGlzLnBoYW50b20gPSAhIWRhdGEucGhhbnRvbTtcbiAgICB0aGlzLmZvbnQgPSBkYXRhLmZvbnQgfHwgXCJcIjtcbiAgICB0aGlzLmZvbnRGYW1pbHkgPSBkYXRhLmZvbnRGYW1pbHkgfHwgXCJcIjtcbiAgICB0aGlzLmZvbnRXZWlnaHQgPSBkYXRhLmZvbnRXZWlnaHQgfHwgJyc7XG4gICAgdGhpcy5mb250U2hhcGUgPSBkYXRhLmZvbnRTaGFwZSB8fCAnJztcbiAgICB0aGlzLnNpemVNdWx0aXBsaWVyID0gc2l6ZU11bHRpcGxpZXJzW3RoaXMuc2l6ZSAtIDFdO1xuICAgIHRoaXMubWF4U2l6ZSA9IGRhdGEubWF4U2l6ZTtcbiAgICB0aGlzLm1pblJ1bGVUaGlja25lc3MgPSBkYXRhLm1pblJ1bGVUaGlja25lc3M7XG4gICAgdGhpcy5fZm9udE1ldHJpY3MgPSB1bmRlZmluZWQ7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgb3B0aW9ucyBvYmplY3Qgd2l0aCB0aGUgc2FtZSBwcm9wZXJ0aWVzIGFzIFwidGhpc1wiLiAgUHJvcGVydGllc1xuICAgKiBmcm9tIFwiZXh0ZW5zaW9uXCIgd2lsbCBiZSBjb3BpZWQgdG8gdGhlIG5ldyBvcHRpb25zIG9iamVjdC5cbiAgICovXG5cblxuICBleHRlbmQoZXh0ZW5zaW9uKSB7XG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgIHN0eWxlOiB0aGlzLnN0eWxlLFxuICAgICAgc2l6ZTogdGhpcy5zaXplLFxuICAgICAgdGV4dFNpemU6IHRoaXMudGV4dFNpemUsXG4gICAgICBjb2xvcjogdGhpcy5jb2xvcixcbiAgICAgIHBoYW50b206IHRoaXMucGhhbnRvbSxcbiAgICAgIGZvbnQ6IHRoaXMuZm9udCxcbiAgICAgIGZvbnRGYW1pbHk6IHRoaXMuZm9udEZhbWlseSxcbiAgICAgIGZvbnRXZWlnaHQ6IHRoaXMuZm9udFdlaWdodCxcbiAgICAgIGZvbnRTaGFwZTogdGhpcy5mb250U2hhcGUsXG4gICAgICBtYXhTaXplOiB0aGlzLm1heFNpemUsXG4gICAgICBtaW5SdWxlVGhpY2tuZXNzOiB0aGlzLm1pblJ1bGVUaGlja25lc3NcbiAgICB9O1xuXG4gICAgZm9yIChjb25zdCBrZXkgaW4gZXh0ZW5zaW9uKSB7XG4gICAgICBpZiAoZXh0ZW5zaW9uLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgZGF0YVtrZXldID0gZXh0ZW5zaW9uW2tleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBPcHRpb25zKGRhdGEpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gb3B0aW9ucyBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gc3R5bGUuIElmIGB0aGlzLnN0eWxlID09PSBzdHlsZWAsXG4gICAqIHJldHVybnMgYHRoaXNgLlxuICAgKi9cblxuXG4gIGhhdmluZ1N0eWxlKHN0eWxlKSB7XG4gICAgaWYgKHRoaXMuc3R5bGUgPT09IHN0eWxlKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZXh0ZW5kKHtcbiAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICBzaXplOiBzaXplQXRTdHlsZSh0aGlzLnRleHRTaXplLCBzdHlsZSlcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGFuIG9wdGlvbnMgb2JqZWN0IHdpdGggYSBjcmFtcGVkIHZlcnNpb24gb2YgdGhlIGN1cnJlbnQgc3R5bGUuIElmXG4gICAqIHRoZSBjdXJyZW50IHN0eWxlIGlzIGNyYW1wZWQsIHJldHVybnMgYHRoaXNgLlxuICAgKi9cblxuXG4gIGhhdmluZ0NyYW1wZWRTdHlsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXZpbmdTdHlsZSh0aGlzLnN0eWxlLmNyYW1wKCkpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gb3B0aW9ucyBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gc2l6ZSBhbmQgaW4gYXQgbGVhc3QgYFxcdGV4dHN0eWxlYC5cbiAgICogUmV0dXJucyBgdGhpc2AgaWYgYXBwcm9wcmlhdGUuXG4gICAqL1xuXG5cbiAgaGF2aW5nU2l6ZShzaXplKSB7XG4gICAgaWYgKHRoaXMuc2l6ZSA9PT0gc2l6ZSAmJiB0aGlzLnRleHRTaXplID09PSBzaXplKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZXh0ZW5kKHtcbiAgICAgICAgc3R5bGU6IHRoaXMuc3R5bGUudGV4dCgpLFxuICAgICAgICBzaXplOiBzaXplLFxuICAgICAgICB0ZXh0U2l6ZTogc2l6ZSxcbiAgICAgICAgc2l6ZU11bHRpcGxpZXI6IHNpemVNdWx0aXBsaWVyc1tzaXplIC0gMV1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogTGlrZSBgdGhpcy5oYXZpbmdTaXplKEJBU0VTSVpFKS5oYXZpbmdTdHlsZShzdHlsZSlgLiBJZiBgc3R5bGVgIGlzIG9taXR0ZWQsXG4gICAqIGNoYW5nZXMgdG8gYXQgbGVhc3QgYFxcdGV4dHN0eWxlYC5cbiAgICovXG5cblxuICBoYXZpbmdCYXNlU3R5bGUoc3R5bGUpIHtcbiAgICBzdHlsZSA9IHN0eWxlIHx8IHRoaXMuc3R5bGUudGV4dCgpO1xuICAgIGNvbnN0IHdhbnRTaXplID0gc2l6ZUF0U3R5bGUoT3B0aW9ucy5CQVNFU0laRSwgc3R5bGUpO1xuXG4gICAgaWYgKHRoaXMuc2l6ZSA9PT0gd2FudFNpemUgJiYgdGhpcy50ZXh0U2l6ZSA9PT0gT3B0aW9ucy5CQVNFU0laRSAmJiB0aGlzLnN0eWxlID09PSBzdHlsZSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmV4dGVuZCh7XG4gICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgc2l6ZTogd2FudFNpemVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBlZmZlY3Qgb2Ygc2l6aW5nIGNoYW5nZXMgc3VjaCBhcyBcXEh1Z2UuXG4gICAqIEtlZXAgdGhlIGVmZmVjdCBvZiB0aGUgY3VycmVudCBzdHlsZSwgc3VjaCBhcyBcXHNjcmlwdHN0eWxlLlxuICAgKi9cblxuXG4gIGhhdmluZ0Jhc2VTaXppbmcoKSB7XG4gICAgbGV0IHNpemU7XG5cbiAgICBzd2l0Y2ggKHRoaXMuc3R5bGUuaWQpIHtcbiAgICAgIGNhc2UgNDpcbiAgICAgIGNhc2UgNTpcbiAgICAgICAgc2l6ZSA9IDM7IC8vIG5vcm1hbHNpemUgaW4gc2NyaXB0c3R5bGVcblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSA2OlxuICAgICAgY2FzZSA3OlxuICAgICAgICBzaXplID0gMTsgLy8gbm9ybWFsc2l6ZSBpbiBzY3JpcHRzY3JpcHRzdHlsZVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBzaXplID0gNjtcbiAgICAgIC8vIG5vcm1hbHNpemUgaW4gdGV4dHN0eWxlIG9yIGRpc3BsYXlzdHlsZVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmV4dGVuZCh7XG4gICAgICBzdHlsZTogdGhpcy5zdHlsZS50ZXh0KCksXG4gICAgICBzaXplOiBzaXplXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBvcHRpb25zIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBjb2xvci5cbiAgICovXG5cblxuICB3aXRoQ29sb3IoY29sb3IpIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbmQoe1xuICAgICAgY29sb3I6IGNvbG9yXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBvcHRpb25zIG9iamVjdCB3aXRoIFwicGhhbnRvbVwiIHNldCB0byB0cnVlLlxuICAgKi9cblxuXG4gIHdpdGhQaGFudG9tKCkge1xuICAgIHJldHVybiB0aGlzLmV4dGVuZCh7XG4gICAgICBwaGFudG9tOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgb3B0aW9ucyBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gbWF0aCBmb250IG9yIG9sZCB0ZXh0IGZvbnQuXG4gICAqIEB0eXBlIHtbdHlwZV19XG4gICAqL1xuXG5cbiAgd2l0aEZvbnQoZm9udCkge1xuICAgIHJldHVybiB0aGlzLmV4dGVuZCh7XG4gICAgICBmb250XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBvcHRpb25zIG9iamVjdHMgd2l0aCB0aGUgZ2l2ZW4gZm9udEZhbWlseS5cbiAgICovXG5cblxuICB3aXRoVGV4dEZvbnRGYW1pbHkoZm9udEZhbWlseSkge1xuICAgIHJldHVybiB0aGlzLmV4dGVuZCh7XG4gICAgICBmb250RmFtaWx5LFxuICAgICAgZm9udDogXCJcIlxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IG9wdGlvbnMgb2JqZWN0IHdpdGggdGhlIGdpdmVuIGZvbnQgd2VpZ2h0XG4gICAqL1xuXG5cbiAgd2l0aFRleHRGb250V2VpZ2h0KGZvbnRXZWlnaHQpIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbmQoe1xuICAgICAgZm9udFdlaWdodCxcbiAgICAgIGZvbnQ6IFwiXCJcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBvcHRpb25zIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBmb250IHdlaWdodFxuICAgKi9cblxuXG4gIHdpdGhUZXh0Rm9udFNoYXBlKGZvbnRTaGFwZSkge1xuICAgIHJldHVybiB0aGlzLmV4dGVuZCh7XG4gICAgICBmb250U2hhcGUsXG4gICAgICBmb250OiBcIlwiXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgQ1NTIHNpemluZyBjbGFzc2VzIHJlcXVpcmVkIHRvIHN3aXRjaCBmcm9tIGVuY2xvc2luZyBvcHRpb25zXG4gICAqIGBvbGRPcHRpb25zYCB0byBgdGhpc2AuIFJldHVybnMgYW4gYXJyYXkgb2YgY2xhc3Nlcy5cbiAgICovXG5cblxuICBzaXppbmdDbGFzc2VzKG9sZE9wdGlvbnMpIHtcbiAgICBpZiAob2xkT3B0aW9ucy5zaXplICE9PSB0aGlzLnNpemUpIHtcbiAgICAgIHJldHVybiBbXCJzaXppbmdcIiwgXCJyZXNldC1zaXplXCIgKyBvbGRPcHRpb25zLnNpemUsIFwic2l6ZVwiICsgdGhpcy5zaXplXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJuIHRoZSBDU1Mgc2l6aW5nIGNsYXNzZXMgcmVxdWlyZWQgdG8gc3dpdGNoIHRvIHRoZSBiYXNlIHNpemUuIExpa2VcbiAgICogYHRoaXMuaGF2aW5nU2l6ZShCQVNFU0laRSkuc2l6aW5nQ2xhc3Nlcyh0aGlzKWAuXG4gICAqL1xuXG5cbiAgYmFzZVNpemluZ0NsYXNzZXMoKSB7XG4gICAgaWYgKHRoaXMuc2l6ZSAhPT0gT3B0aW9ucy5CQVNFU0laRSkge1xuICAgICAgcmV0dXJuIFtcInNpemluZ1wiLCBcInJlc2V0LXNpemVcIiArIHRoaXMuc2l6ZSwgXCJzaXplXCIgKyBPcHRpb25zLkJBU0VTSVpFXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJuIHRoZSBmb250IG1ldHJpY3MgZm9yIHRoaXMgc2l6ZS5cbiAgICovXG5cblxuICBmb250TWV0cmljcygpIHtcbiAgICBpZiAoIXRoaXMuX2ZvbnRNZXRyaWNzKSB7XG4gICAgICB0aGlzLl9mb250TWV0cmljcyA9IGdldEdsb2JhbE1ldHJpY3ModGhpcy5zaXplKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fZm9udE1ldHJpY3M7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIENTUyBjb2xvciBvZiB0aGUgY3VycmVudCBvcHRpb25zIG9iamVjdFxuICAgKi9cblxuXG4gIGdldENvbG9yKCkge1xuICAgIGlmICh0aGlzLnBoYW50b20pIHtcbiAgICAgIHJldHVybiBcInRyYW5zcGFyZW50XCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbG9yO1xuICAgIH1cbiAgfVxuXG59XG5cbk9wdGlvbnMuQkFTRVNJWkUgPSA2O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgc3JjX09wdGlvbnMgPSAoT3B0aW9ucyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdW5pdHMuanNcbi8qKlxuICogVGhpcyBmaWxlIGRvZXMgY29udmVyc2lvbiBiZXR3ZWVuIHVuaXRzLiAgSW4gcGFydGljdWxhciwgaXQgcHJvdmlkZXNcbiAqIGNhbGN1bGF0ZVNpemUgdG8gY29udmVydCBvdGhlciB1bml0cyBpbnRvIGVtcy5cbiAqL1xuXG4gLy8gVGhpcyB0YWJsZSBnaXZlcyB0aGUgbnVtYmVyIG9mIFRlWCBwdHMgaW4gb25lIG9mIGVhY2ggKmFic29sdXRlKiBUZVggdW5pdC5cbi8vIFRodXMsIG11bHRpcGx5aW5nIGEgbGVuZ3RoIGJ5IHRoaXMgbnVtYmVyIGNvbnZlcnRzIHRoZSBsZW5ndGggZnJvbSB1bml0c1xuLy8gaW50byBwdHMuICBEaXZpZGluZyB0aGUgcmVzdWx0IGJ5IHB0UGVyRW0gZ2l2ZXMgdGhlIG51bWJlciBvZiBlbXNcbi8vICphc3N1bWluZyogYSBmb250IHNpemUgb2YgcHRQZXJFbSAobm9ybWFsIHNpemUsIG5vcm1hbCBzdHlsZSkuXG5cbmNvbnN0IHB0UGVyVW5pdCA9IHtcbiAgLy8gaHR0cHM6Ly9lbi53aWtpYm9va3Mub3JnL3dpa2kvTGFUZVgvTGVuZ3RocyBhbmRcbiAgLy8gaHR0cHM6Ly90ZXguc3RhY2tleGNoYW5nZS5jb20vYS84MjYzXG4gIFwicHRcIjogMSxcbiAgLy8gVGVYIHBvaW50XG4gIFwibW1cIjogNzIyNyAvIDI1NDAsXG4gIC8vIG1pbGxpbWV0ZXJcbiAgXCJjbVwiOiA3MjI3IC8gMjU0LFxuICAvLyBjZW50aW1ldGVyXG4gIFwiaW5cIjogNzIuMjcsXG4gIC8vIGluY2hcbiAgXCJicFwiOiA4MDMgLyA4MDAsXG4gIC8vIGJpZyAoUG9zdFNjcmlwdCkgcG9pbnRzXG4gIFwicGNcIjogMTIsXG4gIC8vIHBpY2FcbiAgXCJkZFwiOiAxMjM4IC8gMTE1NyxcbiAgLy8gZGlkb3RcbiAgXCJjY1wiOiAxNDg1NiAvIDExNTcsXG4gIC8vIGNpY2VybyAoMTIgZGlkb3QpXG4gIFwibmRcIjogNjg1IC8gNjQyLFxuICAvLyBuZXcgZGlkb3RcbiAgXCJuY1wiOiAxMzcwIC8gMTA3LFxuICAvLyBuZXcgY2ljZXJvICgxMiBuZXcgZGlkb3QpXG4gIFwic3BcIjogMSAvIDY1NTM2LFxuICAvLyBzY2FsZWQgcG9pbnQgKFRlWCdzIGludGVybmFsIHNtYWxsZXN0IHVuaXQpXG4gIC8vIGh0dHBzOi8vdGV4LnN0YWNrZXhjaGFuZ2UuY29tL2EvNDEzNzFcbiAgXCJweFwiOiA4MDMgLyA4MDAgLy8gXFxwZGZweGRpbWVuIGRlZmF1bHRzIHRvIDEgYnAgaW4gcGRmVGVYIGFuZCBMdWFUZVhcblxufTsgLy8gRGljdGlvbmFyeSBvZiByZWxhdGl2ZSB1bml0cywgZm9yIGZhc3QgdmFsaWRpdHkgdGVzdGluZy5cblxuY29uc3QgcmVsYXRpdmVVbml0ID0ge1xuICBcImV4XCI6IHRydWUsXG4gIFwiZW1cIjogdHJ1ZSxcbiAgXCJtdVwiOiB0cnVlXG59O1xuXG4vKipcbiAqIERldGVybWluZSB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgdW5pdCAoZWl0aGVyIGEgc3RyaW5nIGRlZmluaW5nIHRoZSB1bml0XG4gKiBvciBhIFwic2l6ZVwiIHBhcnNlIG5vZGUgY29udGFpbmluZyBhIHVuaXQgZmllbGQpIGlzIHZhbGlkLlxuICovXG5jb25zdCB2YWxpZFVuaXQgPSBmdW5jdGlvbiAodW5pdCkge1xuICBpZiAodHlwZW9mIHVuaXQgIT09IFwic3RyaW5nXCIpIHtcbiAgICB1bml0ID0gdW5pdC51bml0O1xuICB9XG5cbiAgcmV0dXJuIHVuaXQgaW4gcHRQZXJVbml0IHx8IHVuaXQgaW4gcmVsYXRpdmVVbml0IHx8IHVuaXQgPT09IFwiZXhcIjtcbn07XG4vKlxuICogQ29udmVydCBhIFwic2l6ZVwiIHBhcnNlIG5vZGUgKHdpdGggbnVtZXJpYyBcIm51bWJlclwiIGFuZCBzdHJpbmcgXCJ1bml0XCIgZmllbGRzLFxuICogYXMgcGFyc2VkIGJ5IGZ1bmN0aW9ucy5qcyBhcmdUeXBlIFwic2l6ZVwiKSBpbnRvIGEgQ1NTIGVtIHZhbHVlIGZvciB0aGVcbiAqIGN1cnJlbnQgc3R5bGUvc2NhbGUuICBgb3B0aW9uc2AgZ2l2ZXMgdGhlIGN1cnJlbnQgb3B0aW9ucy5cbiAqL1xuXG5jb25zdCBjYWxjdWxhdGVTaXplID0gZnVuY3Rpb24gKHNpemVWYWx1ZSwgb3B0aW9ucykge1xuICBsZXQgc2NhbGU7XG5cbiAgaWYgKHNpemVWYWx1ZS51bml0IGluIHB0UGVyVW5pdCkge1xuICAgIC8vIEFic29sdXRlIHVuaXRzXG4gICAgc2NhbGUgPSBwdFBlclVuaXRbc2l6ZVZhbHVlLnVuaXRdIC8vIENvbnZlcnQgdW5pdCB0byBwdFxuICAgIC8gb3B0aW9ucy5mb250TWV0cmljcygpLnB0UGVyRW0gLy8gQ29udmVydCBwdCB0byBDU1MgZW1cbiAgICAvIG9wdGlvbnMuc2l6ZU11bHRpcGxpZXI7IC8vIFVuc2NhbGUgdG8gbWFrZSBhYnNvbHV0ZSB1bml0c1xuICB9IGVsc2UgaWYgKHNpemVWYWx1ZS51bml0ID09PSBcIm11XCIpIHtcbiAgICAvLyBgbXVgIHVuaXRzIHNjYWxlIHdpdGggc2NyaXB0c3R5bGUvc2NyaXB0c2NyaXB0c3R5bGUuXG4gICAgc2NhbGUgPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkuY3NzRW1QZXJNdTtcbiAgfSBlbHNlIHtcbiAgICAvLyBPdGhlciByZWxhdGl2ZSB1bml0cyBhbHdheXMgcmVmZXIgdG8gdGhlICp0ZXh0c3R5bGUqIGZvbnRcbiAgICAvLyBpbiB0aGUgY3VycmVudCBzaXplLlxuICAgIGxldCB1bml0T3B0aW9ucztcblxuICAgIGlmIChvcHRpb25zLnN0eWxlLmlzVGlnaHQoKSkge1xuICAgICAgLy8gaXNUaWdodCgpIG1lYW5zIGN1cnJlbnQgc3R5bGUgaXMgc2NyaXB0L3NjcmlwdHNjcmlwdC5cbiAgICAgIHVuaXRPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdTdHlsZShvcHRpb25zLnN0eWxlLnRleHQoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVuaXRPcHRpb25zID0gb3B0aW9ucztcbiAgICB9IC8vIFRPRE86IEluIFRlWCB0aGVzZSB1bml0cyBhcmUgcmVsYXRpdmUgdG8gdGhlIHF1YWQgb2YgdGhlIGN1cnJlbnRcbiAgICAvLyAqdGV4dCogZm9udCwgZS5nLiBjbXIxMC4gS2FUZVggaW5zdGVhZCB1c2VzIHZhbHVlcyBmcm9tIHRoZVxuICAgIC8vIGNvbXBhcmFibHktc2l6ZWQgKkNvbXB1dGVyIE1vZGVybiBzeW1ib2wqIGZvbnQuIEF0IDEwcHQsIHRoZXNlXG4gICAgLy8gbWF0Y2guIEF0IDdwdCBhbmQgNXB0LCB0aGV5IGRpZmZlcjogY21yNz0xLjEzODg5NCwgY21zeTc9MS4xNzA2NDE7XG4gICAgLy8gY21yNT0xLjM2MTEzMywgY21zeTU9MS40NzIyNDEuIENvbnNpZGVyICRcXHNjcmlwdHNpemUgYVxca2VybjFlbWIkLlxuICAgIC8vIFRlWCBcXHNob3dsaXN0cyBzaG93cyBhIGtlcm4gb2YgMS4xMzg4OSAqIGZvbnRzaXplO1xuICAgIC8vIEthVGVYIHNob3dzIGEga2VybiBvZiAxLjE3MSAqIGZvbnRzaXplLlxuXG5cbiAgICBpZiAoc2l6ZVZhbHVlLnVuaXQgPT09IFwiZXhcIikge1xuICAgICAgc2NhbGUgPSB1bml0T3B0aW9ucy5mb250TWV0cmljcygpLnhIZWlnaHQ7XG4gICAgfSBlbHNlIGlmIChzaXplVmFsdWUudW5pdCA9PT0gXCJlbVwiKSB7XG4gICAgICBzY2FsZSA9IHVuaXRPcHRpb25zLmZvbnRNZXRyaWNzKCkucXVhZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiSW52YWxpZCB1bml0OiAnXCIgKyBzaXplVmFsdWUudW5pdCArIFwiJ1wiKTtcbiAgICB9XG5cbiAgICBpZiAodW5pdE9wdGlvbnMgIT09IG9wdGlvbnMpIHtcbiAgICAgIHNjYWxlICo9IHVuaXRPcHRpb25zLnNpemVNdWx0aXBsaWVyIC8gb3B0aW9ucy5zaXplTXVsdGlwbGllcjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gTWF0aC5taW4oc2l6ZVZhbHVlLm51bWJlciAqIHNjYWxlLCBvcHRpb25zLm1heFNpemUpO1xufTtcbi8qKlxuICogUm91bmQgYG5gIHRvIDQgZGVjaW1hbCBwbGFjZXMsIG9yIHRvIHRoZSBuZWFyZXN0IDEvMTAsMDAwdGggZW0uIFNlZVxuICogaHR0cHM6Ly9naXRodWIuY29tL0thVGVYL0thVGVYL3B1bGwvMjQ2MC5cbiAqL1xuXG5jb25zdCBtYWtlRW0gPSBmdW5jdGlvbiAobikge1xuICByZXR1cm4gK24udG9GaXhlZCg0KSArIFwiZW1cIjtcbn07XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZG9tVHJlZS5qc1xuLyoqXG4gKiBUaGVzZSBvYmplY3RzIHN0b3JlIHRoZSBkYXRhIGFib3V0IHRoZSBET00gbm9kZXMgd2UgY3JlYXRlLCBhcyB3ZWxsIGFzIHNvbWVcbiAqIGV4dHJhIGRhdGEuIFRoZXkgY2FuIHRoZW4gYmUgdHJhbnNmb3JtZWQgaW50byByZWFsIERPTSBub2RlcyB3aXRoIHRoZVxuICogYHRvTm9kZWAgZnVuY3Rpb24gb3IgSFRNTCBtYXJrdXAgdXNpbmcgYHRvTWFya3VwYC4gVGhleSBhcmUgdXNlZnVsIGZvciBib3RoXG4gKiBzdG9yaW5nIGV4dHJhIHByb3BlcnRpZXMgb24gdGhlIG5vZGVzLCBhcyB3ZWxsIGFzIHByb3ZpZGluZyBhIHdheSB0byBlYXNpbHlcbiAqIHdvcmsgd2l0aCB0aGUgRE9NLlxuICpcbiAqIFNpbWlsYXIgZnVuY3Rpb25zIGZvciB3b3JraW5nIHdpdGggTWF0aE1MIG5vZGVzIGV4aXN0IGluIG1hdGhNTFRyZWUuanMuXG4gKlxuICogVE9ETzogcmVmYWN0b3IgYHNwYW5gIGFuZCBgYW5jaG9yYCBpbnRvIGNvbW1vbiBzdXBlcmNsYXNzIHdoZW5cbiAqIHRhcmdldCBlbnZpcm9ubWVudHMgc3VwcG9ydCBjbGFzcyBpbmhlcml0YW5jZVxuICovXG5cblxuXG5cblxuXG4vKipcbiAqIENyZWF0ZSBhbiBIVE1MIGNsYXNzTmFtZSBiYXNlZCBvbiBhIGxpc3Qgb2YgY2xhc3Nlcy4gSW4gYWRkaXRpb24gdG8gam9pbmluZ1xuICogd2l0aCBzcGFjZXMsIHdlIGFsc28gcmVtb3ZlIGVtcHR5IGNsYXNzZXMuXG4gKi9cbmNvbnN0IGNyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKGNsYXNzZXMpIHtcbiAgcmV0dXJuIGNsYXNzZXMuZmlsdGVyKGNscyA9PiBjbHMpLmpvaW4oXCIgXCIpO1xufTtcblxuY29uc3QgaW5pdE5vZGUgPSBmdW5jdGlvbiAoY2xhc3Nlcywgb3B0aW9ucywgc3R5bGUpIHtcbiAgdGhpcy5jbGFzc2VzID0gY2xhc3NlcyB8fCBbXTtcbiAgdGhpcy5hdHRyaWJ1dGVzID0ge307XG4gIHRoaXMuaGVpZ2h0ID0gMDtcbiAgdGhpcy5kZXB0aCA9IDA7XG4gIHRoaXMubWF4Rm9udFNpemUgPSAwO1xuICB0aGlzLnN0eWxlID0gc3R5bGUgfHwge307XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5zdHlsZS5pc1RpZ2h0KCkpIHtcbiAgICAgIHRoaXMuY2xhc3Nlcy5wdXNoKFwibXRpZ2h0XCIpO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbG9yID0gb3B0aW9ucy5nZXRDb2xvcigpO1xuXG4gICAgaWYgKGNvbG9yKSB7XG4gICAgICB0aGlzLnN0eWxlLmNvbG9yID0gY29sb3I7XG4gICAgfVxuICB9XG59O1xuLyoqXG4gKiBDb252ZXJ0IGludG8gYW4gSFRNTCBub2RlXG4gKi9cblxuXG5jb25zdCB0b05vZGUgPSBmdW5jdGlvbiAodGFnTmFtZSkge1xuICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTsgLy8gQXBwbHkgdGhlIGNsYXNzXG5cbiAgbm9kZS5jbGFzc05hbWUgPSBjcmVhdGVDbGFzcyh0aGlzLmNsYXNzZXMpOyAvLyBBcHBseSBpbmxpbmUgc3R5bGVzXG5cbiAgZm9yIChjb25zdCBzdHlsZSBpbiB0aGlzLnN0eWxlKSB7XG4gICAgaWYgKHRoaXMuc3R5bGUuaGFzT3duUHJvcGVydHkoc3R5bGUpKSB7XG4gICAgICAvLyAkRmxvd0ZpeE1lIEZsb3cgZG9lc24ndCBzZWVtIHRvIHVuZGVyc3RhbmQgc3Bhbi5zdHlsZSdzIHR5cGUuXG4gICAgICBub2RlLnN0eWxlW3N0eWxlXSA9IHRoaXMuc3R5bGVbc3R5bGVdO1xuICAgIH1cbiAgfSAvLyBBcHBseSBhdHRyaWJ1dGVzXG5cblxuICBmb3IgKGNvbnN0IGF0dHIgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgaWYgKHRoaXMuYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShhdHRyKSkge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0ciwgdGhpcy5hdHRyaWJ1dGVzW2F0dHJdKTtcbiAgICB9XG4gIH0gLy8gQXBwZW5kIHRoZSBjaGlsZHJlbiwgYWxzbyBhcyBIVE1MIG5vZGVzXG5cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBub2RlLmFwcGVuZENoaWxkKHRoaXMuY2hpbGRyZW5baV0udG9Ob2RlKCkpO1xuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59O1xuLyoqXG4gKiBDb252ZXJ0IGludG8gYW4gSFRNTCBtYXJrdXAgc3RyaW5nXG4gKi9cblxuXG5jb25zdCB0b01hcmt1cCA9IGZ1bmN0aW9uICh0YWdOYW1lKSB7XG4gIGxldCBtYXJrdXAgPSBcIjxcIiArIHRhZ05hbWU7IC8vIEFkZCB0aGUgY2xhc3NcblxuICBpZiAodGhpcy5jbGFzc2VzLmxlbmd0aCkge1xuICAgIG1hcmt1cCArPSBcIiBjbGFzcz1cXFwiXCIgKyB1dGlscy5lc2NhcGUoY3JlYXRlQ2xhc3ModGhpcy5jbGFzc2VzKSkgKyBcIlxcXCJcIjtcbiAgfVxuXG4gIGxldCBzdHlsZXMgPSBcIlwiOyAvLyBBZGQgdGhlIHN0eWxlcywgYWZ0ZXIgaHlwaGVuYXRpb25cblxuICBmb3IgKGNvbnN0IHN0eWxlIGluIHRoaXMuc3R5bGUpIHtcbiAgICBpZiAodGhpcy5zdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZSkpIHtcbiAgICAgIHN0eWxlcyArPSB1dGlscy5oeXBoZW5hdGUoc3R5bGUpICsgXCI6XCIgKyB0aGlzLnN0eWxlW3N0eWxlXSArIFwiO1wiO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdHlsZXMpIHtcbiAgICBtYXJrdXAgKz0gXCIgc3R5bGU9XFxcIlwiICsgdXRpbHMuZXNjYXBlKHN0eWxlcykgKyBcIlxcXCJcIjtcbiAgfSAvLyBBZGQgdGhlIGF0dHJpYnV0ZXNcblxuXG4gIGZvciAoY29uc3QgYXR0ciBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICBpZiAodGhpcy5hdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KGF0dHIpKSB7XG4gICAgICBtYXJrdXAgKz0gXCIgXCIgKyBhdHRyICsgXCI9XFxcIlwiICsgdXRpbHMuZXNjYXBlKHRoaXMuYXR0cmlidXRlc1thdHRyXSkgKyBcIlxcXCJcIjtcbiAgICB9XG4gIH1cblxuICBtYXJrdXAgKz0gXCI+XCI7IC8vIEFkZCB0aGUgbWFya3VwIG9mIHRoZSBjaGlsZHJlbiwgYWxzbyBhcyBtYXJrdXBcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBtYXJrdXAgKz0gdGhpcy5jaGlsZHJlbltpXS50b01hcmt1cCgpO1xuICB9XG5cbiAgbWFya3VwICs9IFwiPC9cIiArIHRhZ05hbWUgKyBcIj5cIjtcbiAgcmV0dXJuIG1hcmt1cDtcbn07IC8vIE1ha2luZyB0aGUgdHlwZSBiZWxvdyBleGFjdCB3aXRoIGFsbCBvcHRpb25hbCBmaWVsZHMgZG9lc24ndCB3b3JrIGR1ZSB0b1xuLy8gLSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvNDU4MlxuLy8gLSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvNTY4OFxuLy8gSG93ZXZlciwgc2luY2UgKmFsbCogZmllbGRzIGFyZSBvcHRpb25hbCwgJFNoYXBlPD4gd29ya3MgYXMgc3VnZ2VzdGVkIGluIDU2ODhcbi8vIGFib3ZlLlxuLy8gVGhpcyB0eXBlIGRvZXMgbm90IGluY2x1ZGUgYWxsIENTUyBwcm9wZXJ0aWVzLiBBZGRpdGlvbmFsIHByb3BlcnRpZXMgc2hvdWxkXG4vLyBiZSBhZGRlZCBhcyBuZWVkZWQuXG5cblxuLyoqXG4gKiBUaGlzIG5vZGUgcmVwcmVzZW50cyBhIHNwYW4gbm9kZSwgd2l0aCBhIGNsYXNzTmFtZSwgYSBsaXN0IG9mIGNoaWxkcmVuLCBhbmRcbiAqIGFuIGlubGluZSBzdHlsZS4gSXQgYWxzbyBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCBpdHMgaGVpZ2h0LCBkZXB0aCwgYW5kXG4gKiBtYXhGb250U2l6ZS5cbiAqXG4gKiBSZXByZXNlbnRzIHR3byB0eXBlcyB3aXRoIGRpZmZlcmVudCB1c2VzOiBTdmdTcGFuIHRvIHdyYXAgYW4gU1ZHIGFuZCBEb21TcGFuXG4gKiBvdGhlcndpc2UuIFRoaXMgdHlwZXNhZmV0eSBpcyBpbXBvcnRhbnQgd2hlbiBIVE1MIGJ1aWxkZXJzIGFjY2VzcyBhIHNwYW4nc1xuICogY2hpbGRyZW4uXG4gKi9cbmNsYXNzIFNwYW4ge1xuICBjb25zdHJ1Y3RvcihjbGFzc2VzLCBjaGlsZHJlbiwgb3B0aW9ucywgc3R5bGUpIHtcbiAgICB0aGlzLmNoaWxkcmVuID0gdm9pZCAwO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IHZvaWQgMDtcbiAgICB0aGlzLmNsYXNzZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5oZWlnaHQgPSB2b2lkIDA7XG4gICAgdGhpcy5kZXB0aCA9IHZvaWQgMDtcbiAgICB0aGlzLndpZHRoID0gdm9pZCAwO1xuICAgIHRoaXMubWF4Rm9udFNpemUgPSB2b2lkIDA7XG4gICAgdGhpcy5zdHlsZSA9IHZvaWQgMDtcbiAgICBpbml0Tm9kZS5jYWxsKHRoaXMsIGNsYXNzZXMsIG9wdGlvbnMsIHN0eWxlKTtcbiAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW4gfHwgW107XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgYW4gYXJiaXRyYXJ5IGF0dHJpYnV0ZSBvbiB0aGUgc3Bhbi4gV2FybmluZzogdXNlIHRoaXMgd2lzZWx5LiBOb3RcbiAgICogYWxsIGJyb3dzZXJzIHN1cHBvcnQgYXR0cmlidXRlcyB0aGUgc2FtZSwgYW5kIGhhdmluZyB0b28gbWFueSBjdXN0b21cbiAgICogYXR0cmlidXRlcyBpcyBwcm9iYWJseSBiYWQuXG4gICAqL1xuXG5cbiAgc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICB0aGlzLmF0dHJpYnV0ZXNbYXR0cmlidXRlXSA9IHZhbHVlO1xuICB9XG5cbiAgaGFzQ2xhc3MoY2xhc3NOYW1lKSB7XG4gICAgcmV0dXJuIHV0aWxzLmNvbnRhaW5zKHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lKTtcbiAgfVxuXG4gIHRvTm9kZSgpIHtcbiAgICByZXR1cm4gdG9Ob2RlLmNhbGwodGhpcywgXCJzcGFuXCIpO1xuICB9XG5cbiAgdG9NYXJrdXAoKSB7XG4gICAgcmV0dXJuIHRvTWFya3VwLmNhbGwodGhpcywgXCJzcGFuXCIpO1xuICB9XG5cbn1cbi8qKlxuICogVGhpcyBub2RlIHJlcHJlc2VudHMgYW4gYW5jaG9yICg8YT4pIGVsZW1lbnQgd2l0aCBhIGh5cGVybGluay4gIFNlZSBgc3BhbmBcbiAqIGZvciBmdXJ0aGVyIGRldGFpbHMuXG4gKi9cblxuY2xhc3MgQW5jaG9yIHtcbiAgY29uc3RydWN0b3IoaHJlZiwgY2xhc3NlcywgY2hpbGRyZW4sIG9wdGlvbnMpIHtcbiAgICB0aGlzLmNoaWxkcmVuID0gdm9pZCAwO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IHZvaWQgMDtcbiAgICB0aGlzLmNsYXNzZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5oZWlnaHQgPSB2b2lkIDA7XG4gICAgdGhpcy5kZXB0aCA9IHZvaWQgMDtcbiAgICB0aGlzLm1heEZvbnRTaXplID0gdm9pZCAwO1xuICAgIHRoaXMuc3R5bGUgPSB2b2lkIDA7XG4gICAgaW5pdE5vZGUuY2FsbCh0aGlzLCBjbGFzc2VzLCBvcHRpb25zKTtcbiAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW4gfHwgW107XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcbiAgfVxuXG4gIHNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgdGhpcy5hdHRyaWJ1dGVzW2F0dHJpYnV0ZV0gPSB2YWx1ZTtcbiAgfVxuXG4gIGhhc0NsYXNzKGNsYXNzTmFtZSkge1xuICAgIHJldHVybiB1dGlscy5jb250YWlucyh0aGlzLmNsYXNzZXMsIGNsYXNzTmFtZSk7XG4gIH1cblxuICB0b05vZGUoKSB7XG4gICAgcmV0dXJuIHRvTm9kZS5jYWxsKHRoaXMsIFwiYVwiKTtcbiAgfVxuXG4gIHRvTWFya3VwKCkge1xuICAgIHJldHVybiB0b01hcmt1cC5jYWxsKHRoaXMsIFwiYVwiKTtcbiAgfVxuXG59XG4vKipcbiAqIFRoaXMgbm9kZSByZXByZXNlbnRzIGFuIGltYWdlIGVtYmVkICg8aW1nPikgZWxlbWVudC5cbiAqL1xuXG5jbGFzcyBJbWcge1xuICBjb25zdHJ1Y3RvcihzcmMsIGFsdCwgc3R5bGUpIHtcbiAgICB0aGlzLnNyYyA9IHZvaWQgMDtcbiAgICB0aGlzLmFsdCA9IHZvaWQgMDtcbiAgICB0aGlzLmNsYXNzZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5oZWlnaHQgPSB2b2lkIDA7XG4gICAgdGhpcy5kZXB0aCA9IHZvaWQgMDtcbiAgICB0aGlzLm1heEZvbnRTaXplID0gdm9pZCAwO1xuICAgIHRoaXMuc3R5bGUgPSB2b2lkIDA7XG4gICAgdGhpcy5hbHQgPSBhbHQ7XG4gICAgdGhpcy5zcmMgPSBzcmM7XG4gICAgdGhpcy5jbGFzc2VzID0gW1wibW9yZFwiXTtcbiAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gIH1cblxuICBoYXNDbGFzcyhjbGFzc05hbWUpIHtcbiAgICByZXR1cm4gdXRpbHMuY29udGFpbnModGhpcy5jbGFzc2VzLCBjbGFzc05hbWUpO1xuICB9XG5cbiAgdG9Ob2RlKCkge1xuICAgIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgIG5vZGUuc3JjID0gdGhpcy5zcmM7XG4gICAgbm9kZS5hbHQgPSB0aGlzLmFsdDtcbiAgICBub2RlLmNsYXNzTmFtZSA9IFwibW9yZFwiOyAvLyBBcHBseSBpbmxpbmUgc3R5bGVzXG5cbiAgICBmb3IgKGNvbnN0IHN0eWxlIGluIHRoaXMuc3R5bGUpIHtcbiAgICAgIGlmICh0aGlzLnN0eWxlLmhhc093blByb3BlcnR5KHN0eWxlKSkge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICAgIG5vZGUuc3R5bGVbc3R5bGVdID0gdGhpcy5zdHlsZVtzdHlsZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICB0b01hcmt1cCgpIHtcbiAgICBsZXQgbWFya3VwID0gXCI8aW1nIHNyYz1cXFwiXCIgKyB1dGlscy5lc2NhcGUodGhpcy5zcmMpICsgXCJcXFwiXCIgKyAoXCIgYWx0PVxcXCJcIiArIHV0aWxzLmVzY2FwZSh0aGlzLmFsdCkgKyBcIlxcXCJcIik7IC8vIEFkZCB0aGUgc3R5bGVzLCBhZnRlciBoeXBoZW5hdGlvblxuXG4gICAgbGV0IHN0eWxlcyA9IFwiXCI7XG5cbiAgICBmb3IgKGNvbnN0IHN0eWxlIGluIHRoaXMuc3R5bGUpIHtcbiAgICAgIGlmICh0aGlzLnN0eWxlLmhhc093blByb3BlcnR5KHN0eWxlKSkge1xuICAgICAgICBzdHlsZXMgKz0gdXRpbHMuaHlwaGVuYXRlKHN0eWxlKSArIFwiOlwiICsgdGhpcy5zdHlsZVtzdHlsZV0gKyBcIjtcIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3R5bGVzKSB7XG4gICAgICBtYXJrdXAgKz0gXCIgc3R5bGU9XFxcIlwiICsgdXRpbHMuZXNjYXBlKHN0eWxlcykgKyBcIlxcXCJcIjtcbiAgICB9XG5cbiAgICBtYXJrdXAgKz0gXCInLz5cIjtcbiAgICByZXR1cm4gbWFya3VwO1xuICB9XG5cbn1cbmNvbnN0IGlDb21iaW5hdGlvbnMgPSB7XG4gICfDric6ICdcXHUwMTMxXFx1MDMwMicsXG4gICfDryc6ICdcXHUwMTMxXFx1MDMwOCcsXG4gICfDrSc6ICdcXHUwMTMxXFx1MDMwMScsXG4gIC8vICfEqyc6ICdcXHUwMTMxXFx1MDMwNCcsIC8vIGVuYWJsZSB3aGVuIHdlIGFkZCBFeHRlbmRlZCBMYXRpblxuICAnw6wnOiAnXFx1MDEzMVxcdTAzMDAnXG59O1xuLyoqXG4gKiBBIHN5bWJvbCBub2RlIGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IGEgc2luZ2xlIHN5bWJvbC4gSXQgZWl0aGVyIHJlbmRlcnNcbiAqIHRvIGEgc2luZ2xlIHRleHQgbm9kZSwgb3IgYSBzcGFuIHdpdGggYSBzaW5nbGUgdGV4dCBub2RlIGluIGl0LCBkZXBlbmRpbmcgb25cbiAqIHdoZXRoZXIgaXQgaGFzIENTUyBjbGFzc2VzLCBzdHlsZXMsIG9yIG5lZWRzIGl0YWxpYyBjb3JyZWN0aW9uLlxuICovXG5cbmNsYXNzIFN5bWJvbE5vZGUge1xuICBjb25zdHJ1Y3Rvcih0ZXh0LCBoZWlnaHQsIGRlcHRoLCBpdGFsaWMsIHNrZXcsIHdpZHRoLCBjbGFzc2VzLCBzdHlsZSkge1xuICAgIHRoaXMudGV4dCA9IHZvaWQgMDtcbiAgICB0aGlzLmhlaWdodCA9IHZvaWQgMDtcbiAgICB0aGlzLmRlcHRoID0gdm9pZCAwO1xuICAgIHRoaXMuaXRhbGljID0gdm9pZCAwO1xuICAgIHRoaXMuc2tldyA9IHZvaWQgMDtcbiAgICB0aGlzLndpZHRoID0gdm9pZCAwO1xuICAgIHRoaXMubWF4Rm9udFNpemUgPSB2b2lkIDA7XG4gICAgdGhpcy5jbGFzc2VzID0gdm9pZCAwO1xuICAgIHRoaXMuc3R5bGUgPSB2b2lkIDA7XG4gICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodCB8fCAwO1xuICAgIHRoaXMuZGVwdGggPSBkZXB0aCB8fCAwO1xuICAgIHRoaXMuaXRhbGljID0gaXRhbGljIHx8IDA7XG4gICAgdGhpcy5za2V3ID0gc2tldyB8fCAwO1xuICAgIHRoaXMud2lkdGggPSB3aWR0aCB8fCAwO1xuICAgIHRoaXMuY2xhc3NlcyA9IGNsYXNzZXMgfHwgW107XG4gICAgdGhpcy5zdHlsZSA9IHN0eWxlIHx8IHt9O1xuICAgIHRoaXMubWF4Rm9udFNpemUgPSAwOyAvLyBNYXJrIHRleHQgZnJvbSBub24tTGF0aW4gc2NyaXB0cyB3aXRoIHNwZWNpZmljIGNsYXNzZXMgc28gdGhhdCB3ZVxuICAgIC8vIGNhbiBzcGVjaWZ5IHdoaWNoIGZvbnRzIHRvIHVzZS4gIFRoaXMgYWxsb3dzIHVzIHRvIHJlbmRlciB0aGVzZVxuICAgIC8vIGNoYXJhY3RlcnMgd2l0aCBhIHNlcmlmIGZvbnQgaW4gc2l0dWF0aW9ucyB3aGVyZSB0aGUgYnJvd3NlciB3b3VsZFxuICAgIC8vIGVpdGhlciBkZWZhdWx0IHRvIGEgc2FucyBzZXJpZiBvciByZW5kZXIgYSBwbGFjZWhvbGRlciBjaGFyYWN0ZXIuXG4gICAgLy8gV2UgdXNlIENTUyBjbGFzcyBuYW1lcyBsaWtlIGNqa19mYWxsYmFjaywgaGFuZ3VsX2ZhbGxiYWNrIGFuZFxuICAgIC8vIGJyYWhtaWNfZmFsbGJhY2suIFNlZSAuL3VuaWNvZGVTY3JpcHRzLmpzIGZvciB0aGUgc2V0IG9mIHBvc3NpYmxlXG4gICAgLy8gc2NyaXB0IG5hbWVzXG5cbiAgICBjb25zdCBzY3JpcHQgPSBzY3JpcHRGcm9tQ29kZXBvaW50KHRoaXMudGV4dC5jaGFyQ29kZUF0KDApKTtcblxuICAgIGlmIChzY3JpcHQpIHtcbiAgICAgIHRoaXMuY2xhc3Nlcy5wdXNoKHNjcmlwdCArIFwiX2ZhbGxiYWNrXCIpO1xuICAgIH1cblxuICAgIGlmICgvW8Ouw6/DrcOsXS8udGVzdCh0aGlzLnRleHQpKSB7XG4gICAgICAvLyBhZGQgxKsgd2hlbiB3ZSBhZGQgRXh0ZW5kZWQgTGF0aW5cbiAgICAgIHRoaXMudGV4dCA9IGlDb21iaW5hdGlvbnNbdGhpcy50ZXh0XTtcbiAgICB9XG4gIH1cblxuICBoYXNDbGFzcyhjbGFzc05hbWUpIHtcbiAgICByZXR1cm4gdXRpbHMuY29udGFpbnModGhpcy5jbGFzc2VzLCBjbGFzc05hbWUpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgdGV4dCBub2RlIG9yIHNwYW4gZnJvbSBhIHN5bWJvbCBub2RlLiBOb3RlIHRoYXQgYSBzcGFuIGlzIG9ubHlcbiAgICogY3JlYXRlZCBpZiBpdCBpcyBuZWVkZWQuXG4gICAqL1xuXG5cbiAgdG9Ob2RlKCkge1xuICAgIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLnRleHQpO1xuICAgIGxldCBzcGFuID0gbnVsbDtcblxuICAgIGlmICh0aGlzLml0YWxpYyA+IDApIHtcbiAgICAgIHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgIHNwYW4uc3R5bGUubWFyZ2luUmlnaHQgPSBtYWtlRW0odGhpcy5pdGFsaWMpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmNsYXNzZXMubGVuZ3RoID4gMCkge1xuICAgICAgc3BhbiA9IHNwYW4gfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICBzcGFuLmNsYXNzTmFtZSA9IGNyZWF0ZUNsYXNzKHRoaXMuY2xhc3Nlcyk7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBzdHlsZSBpbiB0aGlzLnN0eWxlKSB7XG4gICAgICBpZiAodGhpcy5zdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZSkpIHtcbiAgICAgICAgc3BhbiA9IHNwYW4gfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7IC8vICRGbG93Rml4TWUgRmxvdyBkb2Vzbid0IHNlZW0gdG8gdW5kZXJzdGFuZCBzcGFuLnN0eWxlJ3MgdHlwZS5cblxuICAgICAgICBzcGFuLnN0eWxlW3N0eWxlXSA9IHRoaXMuc3R5bGVbc3R5bGVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzcGFuKSB7XG4gICAgICBzcGFuLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgcmV0dXJuIHNwYW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBtYXJrdXAgZm9yIGEgc3ltYm9sIG5vZGUuXG4gICAqL1xuXG5cbiAgdG9NYXJrdXAoKSB7XG4gICAgLy8gVE9ETyhhbHBlcnQpOiBNb3JlIGR1cGxpY2F0aW9uIHRoYW4gSSdkIGxpa2UgZnJvbVxuICAgIC8vIHNwYW4ucHJvdG90eXBlLnRvTWFya3VwIGFuZCBzeW1ib2xOb2RlLnByb3RvdHlwZS50b05vZGUuLi5cbiAgICBsZXQgbmVlZHNTcGFuID0gZmFsc2U7XG4gICAgbGV0IG1hcmt1cCA9IFwiPHNwYW5cIjtcblxuICAgIGlmICh0aGlzLmNsYXNzZXMubGVuZ3RoKSB7XG4gICAgICBuZWVkc1NwYW4gPSB0cnVlO1xuICAgICAgbWFya3VwICs9IFwiIGNsYXNzPVxcXCJcIjtcbiAgICAgIG1hcmt1cCArPSB1dGlscy5lc2NhcGUoY3JlYXRlQ2xhc3ModGhpcy5jbGFzc2VzKSk7XG4gICAgICBtYXJrdXAgKz0gXCJcXFwiXCI7XG4gICAgfVxuXG4gICAgbGV0IHN0eWxlcyA9IFwiXCI7XG5cbiAgICBpZiAodGhpcy5pdGFsaWMgPiAwKSB7XG4gICAgICBzdHlsZXMgKz0gXCJtYXJnaW4tcmlnaHQ6XCIgKyB0aGlzLml0YWxpYyArIFwiZW07XCI7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBzdHlsZSBpbiB0aGlzLnN0eWxlKSB7XG4gICAgICBpZiAodGhpcy5zdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZSkpIHtcbiAgICAgICAgc3R5bGVzICs9IHV0aWxzLmh5cGhlbmF0ZShzdHlsZSkgKyBcIjpcIiArIHRoaXMuc3R5bGVbc3R5bGVdICsgXCI7XCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN0eWxlcykge1xuICAgICAgbmVlZHNTcGFuID0gdHJ1ZTtcbiAgICAgIG1hcmt1cCArPSBcIiBzdHlsZT1cXFwiXCIgKyB1dGlscy5lc2NhcGUoc3R5bGVzKSArIFwiXFxcIlwiO1xuICAgIH1cblxuICAgIGNvbnN0IGVzY2FwZWQgPSB1dGlscy5lc2NhcGUodGhpcy50ZXh0KTtcblxuICAgIGlmIChuZWVkc1NwYW4pIHtcbiAgICAgIG1hcmt1cCArPSBcIj5cIjtcbiAgICAgIG1hcmt1cCArPSBlc2NhcGVkO1xuICAgICAgbWFya3VwICs9IFwiPC9zcGFuPlwiO1xuICAgICAgcmV0dXJuIG1hcmt1cDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGVzY2FwZWQ7XG4gICAgfVxuICB9XG5cbn1cbi8qKlxuICogU1ZHIG5vZGVzIGFyZSB1c2VkIHRvIHJlbmRlciBzdHJldGNoeSB3aWRlIGVsZW1lbnRzLlxuICovXG5cbmNsYXNzIFN2Z05vZGUge1xuICBjb25zdHJ1Y3RvcihjaGlsZHJlbiwgYXR0cmlidXRlcykge1xuICAgIHRoaXMuY2hpbGRyZW4gPSB2b2lkIDA7XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gdm9pZCAwO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbiB8fCBbXTtcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzIHx8IHt9O1xuICB9XG5cbiAgdG9Ob2RlKCkge1xuICAgIGNvbnN0IHN2Z05TID0gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiO1xuICAgIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc3ZnTlMsIFwic3ZnXCIpOyAvLyBBcHBseSBhdHRyaWJ1dGVzXG5cbiAgICBmb3IgKGNvbnN0IGF0dHIgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYXR0cmlidXRlcywgYXR0cikpIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0ciwgdGhpcy5hdHRyaWJ1dGVzW2F0dHJdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vZGUuYXBwZW5kQ2hpbGQodGhpcy5jaGlsZHJlbltpXS50b05vZGUoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICB0b01hcmt1cCgpIHtcbiAgICBsZXQgbWFya3VwID0gXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCJcIjsgLy8gQXBwbHkgYXR0cmlidXRlc1xuXG4gICAgZm9yIChjb25zdCBhdHRyIGluIHRoaXMuYXR0cmlidXRlcykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmF0dHJpYnV0ZXMsIGF0dHIpKSB7XG4gICAgICAgIG1hcmt1cCArPSBcIiBcIiArIGF0dHIgKyBcIj1cXFwiXCIgKyB1dGlscy5lc2NhcGUodGhpcy5hdHRyaWJ1dGVzW2F0dHJdKSArIFwiXFxcIlwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1hcmt1cCArPSBcIj5cIjtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgbWFya3VwICs9IHRoaXMuY2hpbGRyZW5baV0udG9NYXJrdXAoKTtcbiAgICB9XG5cbiAgICBtYXJrdXAgKz0gXCI8L3N2Zz5cIjtcbiAgICByZXR1cm4gbWFya3VwO1xuICB9XG5cbn1cbmNsYXNzIFBhdGhOb2RlIHtcbiAgY29uc3RydWN0b3IocGF0aE5hbWUsIGFsdGVybmF0ZSkge1xuICAgIHRoaXMucGF0aE5hbWUgPSB2b2lkIDA7XG4gICAgdGhpcy5hbHRlcm5hdGUgPSB2b2lkIDA7XG4gICAgdGhpcy5wYXRoTmFtZSA9IHBhdGhOYW1lO1xuICAgIHRoaXMuYWx0ZXJuYXRlID0gYWx0ZXJuYXRlOyAvLyBVc2VkIG9ubHkgZm9yIFxcc3FydCwgXFxwaGFzZSwgJiB0YWxsIGRlbGltc1xuICB9XG5cbiAgdG9Ob2RlKCkge1xuICAgIGNvbnN0IHN2Z05TID0gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiO1xuICAgIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc3ZnTlMsIFwicGF0aFwiKTtcblxuICAgIGlmICh0aGlzLmFsdGVybmF0ZSkge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJkXCIsIHRoaXMuYWx0ZXJuYXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJkXCIsIHBhdGhbdGhpcy5wYXRoTmFtZV0pO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgdG9NYXJrdXAoKSB7XG4gICAgaWYgKHRoaXMuYWx0ZXJuYXRlKSB7XG4gICAgICByZXR1cm4gXCI8cGF0aCBkPVxcXCJcIiArIHV0aWxzLmVzY2FwZSh0aGlzLmFsdGVybmF0ZSkgKyBcIlxcXCIvPlwiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCI8cGF0aCBkPVxcXCJcIiArIHV0aWxzLmVzY2FwZShwYXRoW3RoaXMucGF0aE5hbWVdKSArIFwiXFxcIi8+XCI7XG4gICAgfVxuICB9XG5cbn1cbmNsYXNzIExpbmVOb2RlIHtcbiAgY29uc3RydWN0b3IoYXR0cmlidXRlcykge1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IHZvaWQgMDtcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzIHx8IHt9O1xuICB9XG5cbiAgdG9Ob2RlKCkge1xuICAgIGNvbnN0IHN2Z05TID0gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiO1xuICAgIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc3ZnTlMsIFwibGluZVwiKTsgLy8gQXBwbHkgYXR0cmlidXRlc1xuXG4gICAgZm9yIChjb25zdCBhdHRyIGluIHRoaXMuYXR0cmlidXRlcykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmF0dHJpYnV0ZXMsIGF0dHIpKSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHIsIHRoaXMuYXR0cmlidXRlc1thdHRyXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICB0b01hcmt1cCgpIHtcbiAgICBsZXQgbWFya3VwID0gXCI8bGluZVwiO1xuXG4gICAgZm9yIChjb25zdCBhdHRyIGluIHRoaXMuYXR0cmlidXRlcykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmF0dHJpYnV0ZXMsIGF0dHIpKSB7XG4gICAgICAgIG1hcmt1cCArPSBcIiBcIiArIGF0dHIgKyBcIj1cXFwiXCIgKyB1dGlscy5lc2NhcGUodGhpcy5hdHRyaWJ1dGVzW2F0dHJdKSArIFwiXFxcIlwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1hcmt1cCArPSBcIi8+XCI7XG4gICAgcmV0dXJuIG1hcmt1cDtcbiAgfVxuXG59XG5mdW5jdGlvbiBhc3NlcnRTeW1ib2xEb21Ob2RlKGdyb3VwKSB7XG4gIGlmIChncm91cCBpbnN0YW5jZW9mIFN5bWJvbE5vZGUpIHtcbiAgICByZXR1cm4gZ3JvdXA7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgc3ltYm9sTm9kZSBidXQgZ290IFwiICsgU3RyaW5nKGdyb3VwKSArIFwiLlwiKTtcbiAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0U3Bhbihncm91cCkge1xuICBpZiAoZ3JvdXAgaW5zdGFuY2VvZiBTcGFuKSB7XG4gICAgcmV0dXJuIGdyb3VwO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIHNwYW48SHRtbERvbU5vZGU+IGJ1dCBnb3QgXCIgKyBTdHJpbmcoZ3JvdXApICsgXCIuXCIpO1xuICB9XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvc3ltYm9scy5qc1xuLyoqXG4gKiBUaGlzIGZpbGUgaG9sZHMgYSBsaXN0IG9mIGFsbCBuby1hcmd1bWVudCBmdW5jdGlvbnMgYW5kIHNpbmdsZS1jaGFyYWN0ZXJcbiAqIHN5bWJvbHMgKGxpa2UgJ2EnIG9yICc7JykuXG4gKlxuICogRm9yIGVhY2ggb2YgdGhlIHN5bWJvbHMsIHRoZXJlIGFyZSB0aHJlZSBwcm9wZXJ0aWVzIHRoZXkgY2FuIGhhdmU6XG4gKiAtIGZvbnQgKHJlcXVpcmVkKTogdGhlIGZvbnQgdG8gYmUgdXNlZCBmb3IgdGhpcyBzeW1ib2wuIEVpdGhlciBcIm1haW5cIiAodGhlXG4gICAgIG5vcm1hbCBmb250KSwgb3IgXCJhbXNcIiAodGhlIGFtcyBmb250cykuXG4gKiAtIGdyb3VwIChyZXF1aXJlZCk6IHRoZSBQYXJzZU5vZGUgZ3JvdXAgdHlwZSB0aGUgc3ltYm9sIHNob3VsZCBoYXZlIChpLmUuXG4gICAgIFwidGV4dG9yZFwiLCBcIm1hdGhvcmRcIiwgZXRjKS5cbiAgICAgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9LYVRlWC9LYVRlWC93aWtpL0V4YW1pbmluZy1UZVgjZ3JvdXAtdHlwZXNcbiAqIC0gcmVwbGFjZTogdGhlIGNoYXJhY3RlciB0aGF0IHRoaXMgc3ltYm9sIG9yIGZ1bmN0aW9uIHNob3VsZCBiZVxuICogICByZXBsYWNlZCB3aXRoIChpLmUuIFwiXFxwaGlcIiBoYXMgYSByZXBsYWNlIHZhbHVlIG9mIFwiXFx1MDNkNVwiLCB0aGUgcGhpXG4gKiAgIGNoYXJhY3RlciBpbiB0aGUgbWFpbiBmb250KS5cbiAqXG4gKiBUaGUgb3V0ZXJtb3N0IG1hcCBpbiB0aGUgdGFibGUgaW5kaWNhdGVzIHdoYXQgbW9kZSB0aGUgc3ltYm9scyBzaG91bGQgYmVcbiAqIGFjY2VwdGVkIGluIChlLmcuIFwibWF0aFwiIG9yIFwidGV4dFwiKS5cbiAqL1xuLy8gU29tZSBvZiB0aGVzZSBoYXZlIGEgXCItdG9rZW5cIiBzdWZmaXggc2luY2UgdGhlc2UgYXJlIGFsc28gdXNlZCBhcyBgUGFyc2VOb2RlYFxuLy8gdHlwZXMgZm9yIHJhdyB0ZXh0IHRva2VucywgYW5kIHdlIHdhbnQgdG8gYXZvaWQgY29uZmxpY3RzIHdpdGggaGlnaGVyLWxldmVsXG4vLyBgUGFyc2VOb2RlYCB0eXBlcy4gVGhlc2UgYFBhcnNlTm9kZWBzIGFyZSBjb25zdHJ1Y3RlZCB3aXRoaW4gYFBhcnNlcmAgYnlcbi8vIGxvb2tpbmcgdXAgdGhlIGBzeW1ib2xzYCBtYXAuXG5jb25zdCBBVE9NUyA9IHtcbiAgXCJiaW5cIjogMSxcbiAgXCJjbG9zZVwiOiAxLFxuICBcImlubmVyXCI6IDEsXG4gIFwib3BlblwiOiAxLFxuICBcInB1bmN0XCI6IDEsXG4gIFwicmVsXCI6IDFcbn07XG5jb25zdCBOT05fQVRPTVMgPSB7XG4gIFwiYWNjZW50LXRva2VuXCI6IDEsXG4gIFwibWF0aG9yZFwiOiAxLFxuICBcIm9wLXRva2VuXCI6IDEsXG4gIFwic3BhY2luZ1wiOiAxLFxuICBcInRleHRvcmRcIjogMVxufTtcbmNvbnN0IHN5bWJvbHMgPSB7XG4gIFwibWF0aFwiOiB7fSxcbiAgXCJ0ZXh0XCI6IHt9XG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgc3JjX3N5bWJvbHMgPSAoc3ltYm9scyk7XG4vKiogYGFjY2VwdFVuaWNvZGVDaGFyID0gdHJ1ZWAgaXMgb25seSBhcHBsaWNhYmxlIGlmIGByZXBsYWNlYCBpcyBzZXQuICovXG5cbmZ1bmN0aW9uIGRlZmluZVN5bWJvbChtb2RlLCBmb250LCBncm91cCwgcmVwbGFjZSwgbmFtZSwgYWNjZXB0VW5pY29kZUNoYXIpIHtcbiAgc3ltYm9sc1ttb2RlXVtuYW1lXSA9IHtcbiAgICBmb250LFxuICAgIGdyb3VwLFxuICAgIHJlcGxhY2VcbiAgfTtcblxuICBpZiAoYWNjZXB0VW5pY29kZUNoYXIgJiYgcmVwbGFjZSkge1xuICAgIHN5bWJvbHNbbW9kZV1bcmVwbGFjZV0gPSBzeW1ib2xzW21vZGVdW25hbWVdO1xuICB9XG59IC8vIFNvbWUgYWJicmV2aWF0aW9ucyBmb3IgY29tbW9ubHkgdXNlZCBzdHJpbmdzLlxuLy8gVGhpcyBoZWxwcyBtaW5pZnkgdGhlIGNvZGUsIGFuZCBhbHNvIHNwb3R0aW5nIHR5cG9zIHVzaW5nIGpzaGludC5cbi8vIG1vZGVzOlxuXG5jb25zdCBtYXRoID0gXCJtYXRoXCI7XG5jb25zdCBzeW1ib2xzX3RleHQgPSBcInRleHRcIjsgLy8gZm9udHM6XG5cbmNvbnN0IG1haW4gPSBcIm1haW5cIjtcbmNvbnN0IGFtcyA9IFwiYW1zXCI7IC8vIGdyb3VwczpcblxuY29uc3QgYWNjZW50ID0gXCJhY2NlbnQtdG9rZW5cIjtcbmNvbnN0IGJpbiA9IFwiYmluXCI7XG5jb25zdCBzeW1ib2xzX2Nsb3NlID0gXCJjbG9zZVwiO1xuY29uc3QgaW5uZXIgPSBcImlubmVyXCI7XG5jb25zdCBtYXRob3JkID0gXCJtYXRob3JkXCI7XG5jb25zdCBvcCA9IFwib3AtdG9rZW5cIjtcbmNvbnN0IHN5bWJvbHNfb3BlbiA9IFwib3BlblwiO1xuY29uc3QgcHVuY3QgPSBcInB1bmN0XCI7XG5jb25zdCByZWwgPSBcInJlbFwiO1xuY29uc3Qgc3BhY2luZyA9IFwic3BhY2luZ1wiO1xuY29uc3QgdGV4dG9yZCA9IFwidGV4dG9yZFwiOyAvLyBOb3cgY29tZXMgdGhlIHN5bWJvbCB0YWJsZVxuLy8gUmVsYXRpb24gU3ltYm9sc1xuXG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyNjFcIiwgXCJcXFxcZXF1aXZcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyN2FcIiwgXCJcXFxccHJlY1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI3YlwiLCBcIlxcXFxzdWNjXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjNjXCIsIFwiXFxcXHNpbVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjJhNVwiLCBcIlxcXFxwZXJwXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyYWFmXCIsIFwiXFxcXHByZWNlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MmFiMFwiLCBcIlxcXFxzdWNjZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyNDNcIiwgXCJcXFxcc2ltZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyMjNcIiwgXCJcXFxcbWlkXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjZhXCIsIFwiXFxcXGxsXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjZiXCIsIFwiXFxcXGdnXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjRkXCIsIFwiXFxcXGFzeW1wXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjI1XCIsIFwiXFxcXHBhcmFsbGVsXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMmM4XCIsIFwiXFxcXGJvd3RpZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjMyM1wiLCBcIlxcXFxzbWlsZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI5MVwiLCBcIlxcXFxzcXN1YnNldGVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjkyXCIsIFwiXFxcXHNxc3Vwc2V0ZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyNTBcIiwgXCJcXFxcZG90ZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIzMjJcIiwgXCJcXFxcZnJvd25cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyMGJcIiwgXCJcXFxcbmlcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyMWRcIiwgXCJcXFxccHJvcHRvXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMmEyXCIsIFwiXFxcXHZkYXNoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMmEzXCIsIFwiXFxcXGRhc2h2XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjBiXCIsIFwiXFxcXG93bnNcIik7IC8vIFB1bmN0dWF0aW9uXG5cbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBwdW5jdCwgXCJcXHUwMDJlXCIsIFwiXFxcXGxkb3RwXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHB1bmN0LCBcIlxcdTIyYzVcIiwgXCJcXFxcY2RvdHBcIik7IC8vIE1pc2MgU3ltYm9sc1xuXG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwMDIzXCIsIFwiXFxcXCNcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAwMjNcIiwgXCJcXFxcI1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAwMjZcIiwgXCJcXFxcJlwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MDAyNlwiLCBcIlxcXFwmXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjEzNVwiLCBcIlxcXFxhbGVwaFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIyMDBcIiwgXCJcXFxcZm9yYWxsXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjEwZlwiLCBcIlxcXFxoYmFyXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjIwM1wiLCBcIlxcXFxleGlzdHNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMjA3XCIsIFwiXFxcXG5hYmxhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjY2ZFwiLCBcIlxcXFxmbGF0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjExM1wiLCBcIlxcXFxlbGxcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyNjZlXCIsIFwiXFxcXG5hdHVyYWxcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyNjYzXCIsIFwiXFxcXGNsdWJzdWl0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjExOFwiLCBcIlxcXFx3cFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTI2NmZcIiwgXCJcXFxcc2hhcnBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyNjYyXCIsIFwiXFxcXGRpYW1vbmRzdWl0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjExY1wiLCBcIlxcXFxSZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTI2NjFcIiwgXCJcXFxcaGVhcnRzdWl0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjExMVwiLCBcIlxcXFxJbVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTI2NjBcIiwgXCJcXFxcc3BhZGVzdWl0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDBhN1wiLCBcIlxcXFxTXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwMGE3XCIsIFwiXFxcXFNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwMGI2XCIsIFwiXFxcXFBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAwYjZcIiwgXCJcXFxcUFwiKTsgLy8gTWF0aCBhbmQgVGV4dFxuXG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDIwXCIsIFwiXFxcXGRhZ1wiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MjAyMFwiLCBcIlxcXFxkYWdcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIwMjBcIiwgXCJcXFxcdGV4dGRhZ2dlclwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIwMjFcIiwgXCJcXFxcZGRhZ1wiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MjAyMVwiLCBcIlxcXFxkZGFnXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDIxXCIsIFwiXFxcXHRleHRkYWdnZXJkYmxcIik7IC8vIExhcmdlIERlbGltaXRlcnNcblxuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHN5bWJvbHNfY2xvc2UsIFwiXFx1MjNiMVwiLCBcIlxcXFxybW91c3RhY2hlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHN5bWJvbHNfb3BlbiwgXCJcXHUyM2IwXCIsIFwiXFxcXGxtb3VzdGFjaGVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgc3ltYm9sc19jbG9zZSwgXCJcXHUyN2VmXCIsIFwiXFxcXHJncm91cFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBzeW1ib2xzX29wZW4sIFwiXFx1MjdlZVwiLCBcIlxcXFxsZ3JvdXBcIiwgdHJ1ZSk7IC8vIEJpbmFyeSBPcGVyYXRvcnNcblxuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjEzXCIsIFwiXFxcXG1wXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjk2XCIsIFwiXFxcXG9taW51c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjI4ZVwiLCBcIlxcXFx1cGx1c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjI5M1wiLCBcIlxcXFxzcWNhcFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjIxN1wiLCBcIlxcXFxhc3RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyOTRcIiwgXCJcXFxcc3FjdXBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTI1ZWZcIiwgXCJcXFxcYmlnY2lyY1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjIxOVwiLCBcIlxcXFxidWxsZXRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIwMjFcIiwgXCJcXFxcZGRhZ2dlclwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjI0MFwiLCBcIlxcXFx3clwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MmEzZlwiLCBcIlxcXFxhbWFsZ1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MDAyNlwiLCBcIlxcXFxBbmRcIik7IC8vIGZyb20gYW1zbWF0aFxuLy8gQXJyb3cgU3ltYm9sc1xuXG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTI3ZjVcIiwgXCJcXFxcbG9uZ2xlZnRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjFkMFwiLCBcIlxcXFxMZWZ0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTI3ZjhcIiwgXCJcXFxcTG9uZ2xlZnRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjdmNlwiLCBcIlxcXFxsb25ncmlnaHRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjFkMlwiLCBcIlxcXFxSaWdodGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyN2Y5XCIsIFwiXFxcXExvbmdyaWdodGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMTk0XCIsIFwiXFxcXGxlZnRyaWdodGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyN2Y3XCIsIFwiXFxcXGxvbmdsZWZ0cmlnaHRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjFkNFwiLCBcIlxcXFxMZWZ0cmlnaHRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjdmYVwiLCBcIlxcXFxMb25nbGVmdHJpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxYTZcIiwgXCJcXFxcbWFwc3RvXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyN2ZjXCIsIFwiXFxcXGxvbmdtYXBzdG9cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxOTdcIiwgXCJcXFxcbmVhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjFhOVwiLCBcIlxcXFxob29rbGVmdGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMWFhXCIsIFwiXFxcXGhvb2tyaWdodGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMTk4XCIsIFwiXFxcXHNlYXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxYmNcIiwgXCJcXFxcbGVmdGhhcnBvb251cFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjFjMFwiLCBcIlxcXFxyaWdodGhhcnBvb251cFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjE5OVwiLCBcIlxcXFxzd2Fycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMWJkXCIsIFwiXFxcXGxlZnRoYXJwb29uZG93blwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjFjMVwiLCBcIlxcXFxyaWdodGhhcnBvb25kb3duXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMTk2XCIsIFwiXFxcXG53YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxY2NcIiwgXCJcXFxccmlnaHRsZWZ0aGFycG9vbnNcIiwgdHJ1ZSk7IC8vIEFNUyBOZWdhdGVkIEJpbmFyeSBSZWxhdGlvbnNcblxuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNmVcIiwgXCJcXFxcbmxlc3NcIiwgdHJ1ZSk7IC8vIFN5bWJvbCBuYW1lcyBwcmVjZWRlZCBieSBcIkBcIiBlYWNoIGhhdmUgYSBjb3JyZXNwb25kaW5nIG1hY3JvLlxuXG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1ZTAxMFwiLCBcIlxcXFxAbmxlcXNsYW50XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdWUwMTFcIiwgXCJcXFxcQG5sZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhODdcIiwgXCJcXFxcbG5lcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjY4XCIsIFwiXFxcXGxuZXFxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdWUwMGNcIiwgXCJcXFxcQGx2ZXJ0bmVxcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmU2XCIsIFwiXFxcXGxuc2ltXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhODlcIiwgXCJcXFxcbG5hcHByb3hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI4MFwiLCBcIlxcXFxucHJlY1wiLCB0cnVlKTsgLy8gdW5pY29kZS1tYXRoIG1hcHMgXFx1MjJlMCB0byBcXG5wcmVjY3VybHllcS4gV2UnbGwgdXNlIHRoZSBBTVMgc3lub255bS5cblxuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZTBcIiwgXCJcXFxcbnByZWNlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmU4XCIsIFwiXFxcXHByZWNuc2ltXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhYjlcIiwgXCJcXFxccHJlY25hcHByb3hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI0MVwiLCBcIlxcXFxuc2ltXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdWUwMDZcIiwgXCJcXFxcQG5zaG9ydG1pZFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjI0XCIsIFwiXFxcXG5taWRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJhY1wiLCBcIlxcXFxudmRhc2hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJhZFwiLCBcIlxcXFxudkRhc2hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJlYVwiLCBcIlxcXFxudHJpYW5nbGVsZWZ0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZWNcIiwgXCJcXFxcbnRyaWFuZ2xlbGVmdGVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyOGFcIiwgXCJcXFxcc3Vic2V0bmVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdWUwMWFcIiwgXCJcXFxcQHZhcnN1YnNldG5lcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYWNiXCIsIFwiXFxcXHN1YnNldG5lcXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1ZTAxN1wiLCBcIlxcXFxAdmFyc3Vic2V0bmVxcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjZmXCIsIFwiXFxcXG5ndHJcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1ZTAwZlwiLCBcIlxcXFxAbmdlcXNsYW50XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdWUwMGVcIiwgXCJcXFxcQG5nZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhODhcIiwgXCJcXFxcZ25lcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjY5XCIsIFwiXFxcXGduZXFxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdWUwMGRcIiwgXCJcXFxcQGd2ZXJ0bmVxcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmU3XCIsIFwiXFxcXGduc2ltXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhOGFcIiwgXCJcXFxcZ25hcHByb3hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI4MVwiLCBcIlxcXFxuc3VjY1wiLCB0cnVlKTsgLy8gdW5pY29kZS1tYXRoIG1hcHMgXFx1MjJlMSB0byBcXG5zdWNjY3VybHllcS4gV2UnbGwgdXNlIHRoZSBBTVMgc3lub255bS5cblxuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZTFcIiwgXCJcXFxcbnN1Y2NlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmU5XCIsIFwiXFxcXHN1Y2Nuc2ltXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhYmFcIiwgXCJcXFxcc3VjY25hcHByb3hcIiwgdHJ1ZSk7IC8vIHVuaWNvZGUtbWF0aCBtYXBzIFxcdTIyNDYgdG8gXFxzaW1uZXFxLiBXZSdsbCB1c2UgdGhlIEFNUyBzeW5vbnltLlxuXG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI0NlwiLCBcIlxcXFxuY29uZ1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHVlMDA3XCIsIFwiXFxcXEBuc2hvcnRwYXJhbGxlbFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjI2XCIsIFwiXFxcXG5wYXJhbGxlbFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmFmXCIsIFwiXFxcXG5WRGFzaFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmViXCIsIFwiXFxcXG50cmlhbmdsZXJpZ2h0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZWRcIiwgXCJcXFxcbnRyaWFuZ2xlcmlnaHRlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHVlMDE4XCIsIFwiXFxcXEBuc3Vwc2V0ZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyOGJcIiwgXCJcXFxcc3Vwc2V0bmVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdWUwMWJcIiwgXCJcXFxcQHZhcnN1cHNldG5lcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYWNjXCIsIFwiXFxcXHN1cHNldG5lcXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1ZTAxOVwiLCBcIlxcXFxAdmFyc3Vwc2V0bmVxcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmFlXCIsIFwiXFxcXG5WZGFzaFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYWI1XCIsIFwiXFxcXHByZWNuZXFxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhYjZcIiwgXCJcXFxcc3VjY25lcXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1ZTAxNlwiLCBcIlxcXFxAbnN1YnNldGVxcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmI0XCIsIFwiXFxcXHVubGhkXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyYjVcIiwgXCJcXFxcdW5yaGRcIik7IC8vIEFNUyBOZWdhdGVkIEFycm93c1xuXG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjE5YVwiLCBcIlxcXFxubGVmdGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxOWJcIiwgXCJcXFxcbnJpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFjZFwiLCBcIlxcXFxuTGVmdGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxY2ZcIiwgXCJcXFxcblJpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFhZVwiLCBcIlxcXFxubGVmdHJpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFjZVwiLCBcIlxcXFxuTGVmdHJpZ2h0YXJyb3dcIiwgdHJ1ZSk7IC8vIEFNUyBNaXNjXG5cbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyNWIzXCIsIFwiXFxcXHZhcnRyaWFuZ2xlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMTBmXCIsIFwiXFxcXGhzbGFzaFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjViZFwiLCBcIlxcXFx0cmlhbmdsZWRvd25cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTI1Y2FcIiwgXCJcXFxcbG96ZW5nZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjRjOFwiLCBcIlxcXFxjaXJjbGVkU1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MDBhZVwiLCBcIlxcXFxjaXJjbGVkUlwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIGFtcywgdGV4dG9yZCwgXCJcXHUwMGFlXCIsIFwiXFxcXGNpcmNsZWRSXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMjIxXCIsIFwiXFxcXG1lYXN1cmVkYW5nbGVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTIyMDRcIiwgXCJcXFxcbmV4aXN0c1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjEyN1wiLCBcIlxcXFxtaG9cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTIxMzJcIiwgXCJcXFxcRmludlwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjE0MVwiLCBcIlxcXFxHYW1lXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMDM1XCIsIFwiXFxcXGJhY2twcmltZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjViMlwiLCBcIlxcXFxibGFja3RyaWFuZ2xlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyNWJjXCIsIFwiXFxcXGJsYWNrdHJpYW5nbGVkb3duXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyNWEwXCIsIFwiXFxcXGJsYWNrc3F1YXJlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyOWViXCIsIFwiXFxcXGJsYWNrbG96ZW5nZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjYwNVwiLCBcIlxcXFxiaWdzdGFyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMjIyXCIsIFwiXFxcXHNwaGVyaWNhbGFuZ2xlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMjAxXCIsIFwiXFxcXGNvbXBsZW1lbnRcIiwgdHJ1ZSk7IC8vIHVuaWNvZGUtbWF0aCBtYXBzIFUrRjAgdG8gXFxtYXRoZXRoLiBXZSBtYXAgdG8gQU1TIGZ1bmN0aW9uIFxcZXRoXG5cbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MDBmMFwiLCBcIlxcXFxldGhcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAwZjBcIiwgXCJcXHUwMGYwXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyNTcxXCIsIFwiXFxcXGRpYWd1cFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjU3MlwiLCBcIlxcXFxkaWFnZG93blwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjVhMVwiLCBcIlxcXFxzcXVhcmVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTI1YTFcIiwgXCJcXFxcQm94XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyNWNhXCIsIFwiXFxcXERpYW1vbmRcIik7IC8vIHVuaWNvZGUtbWF0aCBtYXBzIFUrQTUgdG8gXFxtYXRoeWVuLiBXZSBtYXAgdG8gQU1TIGZ1bmN0aW9uIFxceWVuXG5cbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MDBhNVwiLCBcIlxcXFx5ZW5cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBhbXMsIHRleHRvcmQsIFwiXFx1MDBhNVwiLCBcIlxcXFx5ZW5cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTI3MTNcIiwgXCJcXFxcY2hlY2ttYXJrXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTI3MTNcIiwgXCJcXFxcY2hlY2ttYXJrXCIpOyAvLyBBTVMgSGVicmV3XG5cbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjEzNlwiLCBcIlxcXFxiZXRoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMTM4XCIsIFwiXFxcXGRhbGV0aFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjEzN1wiLCBcIlxcXFxnaW1lbFwiLCB0cnVlKTsgLy8gQU1TIEdyZWVrXG5cbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MDNkZFwiLCBcIlxcXFxkaWdhbW1hXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUwM2YwXCIsIFwiXFxcXHZhcmthcHBhXCIpOyAvLyBBTVMgRGVsaW1pdGVyc1xuXG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBzeW1ib2xzX29wZW4sIFwiXFx1MjUwY1wiLCBcIlxcXFxAdWxjb3JuZXJcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBzeW1ib2xzX2Nsb3NlLCBcIlxcdTI1MTBcIiwgXCJcXFxcQHVyY29ybmVyXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgc3ltYm9sc19vcGVuLCBcIlxcdTI1MTRcIiwgXCJcXFxcQGxsY29ybmVyXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgc3ltYm9sc19jbG9zZSwgXCJcXHUyNTE4XCIsIFwiXFxcXEBscmNvcm5lclwiLCB0cnVlKTsgLy8gQU1TIEJpbmFyeSBSZWxhdGlvbnNcblxuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNjZcIiwgXCJcXFxcbGVxcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYTdkXCIsIFwiXFxcXGxlcXNsYW50XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhOTVcIiwgXCJcXFxcZXFzbGFudGxlc3NcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI3MlwiLCBcIlxcXFxsZXNzc2ltXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhODVcIiwgXCJcXFxcbGVzc2FwcHJveFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjRhXCIsIFwiXFxcXGFwcHJveGVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyZDZcIiwgXCJcXFxcbGVzc2RvdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmQ4XCIsIFwiXFxcXGxsbFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjc2XCIsIFwiXFxcXGxlc3NndHJcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJkYVwiLCBcIlxcXFxsZXNzZXFndHJcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MmE4YlwiLCBcIlxcXFxsZXNzZXFxZ3RyXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNTFcIiwgXCJcXFxcZG90ZXFkb3RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI1M1wiLCBcIlxcXFxyaXNpbmdkb3RzZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI1MlwiLCBcIlxcXFxmYWxsaW5nZG90c2VxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyM2RcIiwgXCJcXFxcYmFja3NpbVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmNkXCIsIFwiXFxcXGJhY2tzaW1lcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYWM1XCIsIFwiXFxcXHN1YnNldGVxcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmQwXCIsIFwiXFxcXFN1YnNldFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjhmXCIsIFwiXFxcXHNxc3Vic2V0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyN2NcIiwgXCJcXFxccHJlY2N1cmx5ZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJkZVwiLCBcIlxcXFxjdXJseWVxcHJlY1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjdlXCIsIFwiXFxcXHByZWNzaW1cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MmFiN1wiLCBcIlxcXFxwcmVjYXBwcm94XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyYjJcIiwgXCJcXFxcdmFydHJpYW5nbGVsZWZ0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyYjRcIiwgXCJcXFxcdHJpYW5nbGVsZWZ0ZXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJhOFwiLCBcIlxcXFx2RGFzaFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmFhXCIsIFwiXFxcXFZ2ZGFzaFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMzIzXCIsIFwiXFxcXHNtYWxsc21pbGVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjMyMlwiLCBcIlxcXFxzbWFsbGZyb3duXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNGZcIiwgXCJcXFxcYnVtcGVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNGVcIiwgXCJcXFxcQnVtcGVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNjdcIiwgXCJcXFxcZ2VxcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYTdlXCIsIFwiXFxcXGdlcXNsYW50XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhOTZcIiwgXCJcXFxcZXFzbGFudGd0clwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjczXCIsIFwiXFxcXGd0cnNpbVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYTg2XCIsIFwiXFxcXGd0cmFwcHJveFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmQ3XCIsIFwiXFxcXGd0cmRvdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmQ5XCIsIFwiXFxcXGdnZ1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjc3XCIsIFwiXFxcXGd0cmxlc3NcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJkYlwiLCBcIlxcXFxndHJlcWxlc3NcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MmE4Y1wiLCBcIlxcXFxndHJlcXFsZXNzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNTZcIiwgXCJcXFxcZXFjaXJjXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNTdcIiwgXCJcXFxcY2lyY2VxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNWNcIiwgXCJcXFxcdHJpYW5nbGVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyM2NcIiwgXCJcXFxcdGhpY2tzaW1cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI0OFwiLCBcIlxcXFx0aGlja2FwcHJveFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYWM2XCIsIFwiXFxcXHN1cHNldGVxcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmQxXCIsIFwiXFxcXFN1cHNldFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjkwXCIsIFwiXFxcXHNxc3Vwc2V0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyN2RcIiwgXCJcXFxcc3VjY2N1cmx5ZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJkZlwiLCBcIlxcXFxjdXJseWVxc3VjY1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjdmXCIsIFwiXFxcXHN1Y2NzaW1cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MmFiOFwiLCBcIlxcXFxzdWNjYXBwcm94XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyYjNcIiwgXCJcXFxcdmFydHJpYW5nbGVyaWdodFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmI1XCIsIFwiXFxcXHRyaWFuZ2xlcmlnaHRlcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmE5XCIsIFwiXFxcXFZkYXNoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyMjNcIiwgXCJcXFxcc2hvcnRtaWRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjIyNVwiLCBcIlxcXFxzaG9ydHBhcmFsbGVsXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNmNcIiwgXCJcXFxcYmV0d2VlblwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmQ0XCIsIFwiXFxcXHBpdGNoZm9ya1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjFkXCIsIFwiXFxcXHZhcnByb3B0b1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyNWMwXCIsIFwiXFxcXGJsYWNrdHJpYW5nbGVsZWZ0XCIpOyAvLyB1bmljb2RlLW1hdGggc2F5cyB0aGF0IFxcdGhlcmVmb3JlIGlzIGEgbWF0aG9yZCBhdG9tLlxuLy8gV2Uga2VwdCB0aGUgYW1zc3ltYiBhdG9tIHR5cGUsIHdoaWNoIGlzIHJlbC5cblxuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyMzRcIiwgXCJcXFxcdGhlcmVmb3JlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyMGRcIiwgXCJcXFxcYmFja2Vwc2lsb25cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjViNlwiLCBcIlxcXFxibGFja3RyaWFuZ2xlcmlnaHRcIik7IC8vIHVuaWNvZGUtbWF0aCBzYXlzIHRoYXQgXFxiZWNhdXNlIGlzIGEgbWF0aG9yZCBhdG9tLlxuLy8gV2Uga2VwdCB0aGUgYW1zc3ltYiBhdG9tIHR5cGUsIHdoaWNoIGlzIHJlbC5cblxuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyMzVcIiwgXCJcXFxcYmVjYXVzZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmQ4XCIsIFwiXFxcXGxsbGVzc1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmQ5XCIsIFwiXFxcXGdnZ3RyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyYjJcIiwgXCJcXFxcbGhkXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyYjNcIiwgXCJcXFxccmhkXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNDJcIiwgXCJcXFxcZXFzaW1cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyYzhcIiwgXCJcXFxcSm9pblwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjUxXCIsIFwiXFxcXERvdGVxXCIsIHRydWUpOyAvLyBBTVMgQmluYXJ5IE9wZXJhdG9yc1xuXG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjIxNFwiLCBcIlxcXFxkb3RwbHVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyMTZcIiwgXCJcXFxcc21hbGxzZXRtaW51c1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmQyXCIsIFwiXFxcXENhcFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmQzXCIsIFwiXFxcXEN1cFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyYTVlXCIsIFwiXFxcXGRvdWJsZWJhcndlZGdlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyOWZcIiwgXCJcXFxcYm94bWludXNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjI5ZVwiLCBcIlxcXFxib3hwbHVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyYzdcIiwgXCJcXFxcZGl2aWRlb250aW1lc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmM5XCIsIFwiXFxcXGx0aW1lc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmNhXCIsIFwiXFxcXHJ0aW1lc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmNiXCIsIFwiXFxcXGxlZnR0aHJlZXRpbWVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyY2NcIiwgXCJcXFxccmlnaHR0aHJlZXRpbWVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyY2ZcIiwgXCJcXFxcY3VybHl3ZWRnZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmNlXCIsIFwiXFxcXGN1cmx5dmVlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyOWRcIiwgXCJcXFxcY2lyY2xlZGRhc2hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjI5YlwiLCBcIlxcXFxjaXJjbGVkYXN0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyYzVcIiwgXCJcXFxcY2VudGVyZG90XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyYmFcIiwgXCJcXFxcaW50ZXJjYWxcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJkMlwiLCBcIlxcXFxkb3VibGVjYXBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJkM1wiLCBcIlxcXFxkb3VibGVjdXBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJhMFwiLCBcIlxcXFxib3h0aW1lc1wiLCB0cnVlKTsgLy8gQU1TIEFycm93c1xuLy8gTm90ZTogdW5pY29kZS1tYXRoIG1hcHMgXFx1MjFlMiB0byB0aGVpciBvd24gZnVuY3Rpb24gXFxyaWdodGRhc2hhcnJvdy5cbi8vIFdlJ2xsIG1hcCBpdCB0byBBTVMgZnVuY3Rpb24gXFxkYXNocmlnaHRhcnJvdy4gSXQgcHJvZHVjZXMgdGhlIHNhbWUgYXRvbS5cblxuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxZTJcIiwgXCJcXFxcZGFzaHJpZ2h0YXJyb3dcIiwgdHJ1ZSk7IC8vIHVuaWNvZGUtbWF0aCBtYXBzIFxcdTIxZTAgdG8gXFxsZWZ0ZGFzaGFycm93LiBXZSdsbCB1c2UgdGhlIEFNUyBzeW5vbnltLlxuXG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFlMFwiLCBcIlxcXFxkYXNobGVmdGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYzdcIiwgXCJcXFxcbGVmdGxlZnRhcnJvd3NcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFjNlwiLCBcIlxcXFxsZWZ0cmlnaHRhcnJvd3NcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFkYVwiLCBcIlxcXFxMbGVmdGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxOWVcIiwgXCJcXFxcdHdvaGVhZGxlZnRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWEyXCIsIFwiXFxcXGxlZnRhcnJvd3RhaWxcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFhYlwiLCBcIlxcXFxsb29wYXJyb3dsZWZ0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxY2JcIiwgXCJcXFxcbGVmdHJpZ2h0aGFycG9vbnNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFiNlwiLCBcIlxcXFxjdXJ2ZWFycm93bGVmdFwiLCB0cnVlKTsgLy8gdW5pY29kZS1tYXRoIG1hcHMgXFx1MjFiYSB0byBcXGFjd29wZW5jaXJjbGVhcnJvdy4gV2UnbGwgdXNlIHRoZSBBTVMgc3lub255bS5cblxuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYmFcIiwgXCJcXFxcY2lyY2xlYXJyb3dsZWZ0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYjBcIiwgXCJcXFxcTHNoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYzhcIiwgXCJcXFxcdXB1cGFycm93c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWJmXCIsIFwiXFxcXHVwaGFycG9vbmxlZnRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFjM1wiLCBcIlxcXFxkb3duaGFycG9vbmxlZnRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyYjZcIiwgXCJcXFxcb3JpZ29mXCIsIHRydWUpOyAvLyBub3QgaW4gZm9udFxuXG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyYjdcIiwgXCJcXFxcaW1hZ2VvZlwiLCB0cnVlKTsgLy8gbm90IGluIGZvbnRcblxuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyYjhcIiwgXCJcXFxcbXVsdGltYXBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFhZFwiLCBcIlxcXFxsZWZ0cmlnaHRzcXVpZ2Fycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYzlcIiwgXCJcXFxccmlnaHRyaWdodGFycm93c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWM0XCIsIFwiXFxcXHJpZ2h0bGVmdGFycm93c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWEwXCIsIFwiXFxcXHR3b2hlYWRyaWdodGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYTNcIiwgXCJcXFxccmlnaHRhcnJvd3RhaWxcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFhY1wiLCBcIlxcXFxsb29wYXJyb3dyaWdodFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWI3XCIsIFwiXFxcXGN1cnZlYXJyb3dyaWdodFwiLCB0cnVlKTsgLy8gdW5pY29kZS1tYXRoIG1hcHMgXFx1MjFiYiB0byBcXGN3b3BlbmNpcmNsZWFycm93LiBXZSdsbCB1c2UgdGhlIEFNUyBzeW5vbnltLlxuXG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFiYlwiLCBcIlxcXFxjaXJjbGVhcnJvd3JpZ2h0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYjFcIiwgXCJcXFxcUnNoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxY2FcIiwgXCJcXFxcZG93bmRvd25hcnJvd3NcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFiZVwiLCBcIlxcXFx1cGhhcnBvb25yaWdodFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWMyXCIsIFwiXFxcXGRvd25oYXJwb29ucmlnaHRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFkZFwiLCBcIlxcXFxyaWdodHNxdWlnYXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFkZFwiLCBcIlxcXFxsZWFkc3RvXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxZGJcIiwgXCJcXFxcUnJpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFiZVwiLCBcIlxcXFxyZXN0cmljdGlvblwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIwMThcIiwgXCJgXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiJFwiLCBcIlxcXFwkXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgdGV4dG9yZCwgXCIkXCIsIFwiXFxcXCRcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIiRcIiwgXCJcXFxcdGV4dGRvbGxhclwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIiVcIiwgXCJcXFxcJVwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHRleHRvcmQsIFwiJVwiLCBcIlxcXFwlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiX1wiLCBcIlxcXFxfXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJfXCIsIFwiXFxcXF9cIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIl9cIiwgXCJcXFxcdGV4dHVuZGVyc2NvcmVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMjIwXCIsIFwiXFxcXGFuZ2xlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjIxZVwiLCBcIlxcXFxpbmZ0eVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIwMzJcIiwgXCJcXFxccHJpbWVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyNWIzXCIsIFwiXFxcXHRyaWFuZ2xlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDM5M1wiLCBcIlxcXFxHYW1tYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAzOTRcIiwgXCJcXFxcRGVsdGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwMzk4XCIsIFwiXFxcXFRoZXRhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDM5YlwiLCBcIlxcXFxMYW1iZGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwMzllXCIsIFwiXFxcXFhpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDNhMFwiLCBcIlxcXFxQaVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAzYTNcIiwgXCJcXFxcU2lnbWFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwM2E1XCIsIFwiXFxcXFVwc2lsb25cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwM2E2XCIsIFwiXFxcXFBoaVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAzYThcIiwgXCJcXFxcUHNpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDNhOVwiLCBcIlxcXFxPbWVnYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIkFcIiwgXCJcXHUwMzkxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiQlwiLCBcIlxcdTAzOTJcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJFXCIsIFwiXFx1MDM5NVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlpcIiwgXCJcXHUwMzk2XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiSFwiLCBcIlxcdTAzOTdcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJJXCIsIFwiXFx1MDM5OVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIktcIiwgXCJcXHUwMzlBXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiTVwiLCBcIlxcdTAzOUNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJOXCIsIFwiXFx1MDM5RFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIk9cIiwgXCJcXHUwMzlGXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiUFwiLCBcIlxcdTAzQTFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJUXCIsIFwiXFx1MDNBNFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlhcIiwgXCJcXHUwM0E3XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDBhY1wiLCBcIlxcXFxuZWdcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwMGFjXCIsIFwiXFxcXGxub3RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMmE0XCIsIFwiXFxcXHRvcFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIyYTVcIiwgXCJcXFxcYm90XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjIwNVwiLCBcIlxcXFxlbXB0eXNldFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjIwNVwiLCBcIlxcXFx2YXJub3RoaW5nXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNiMVwiLCBcIlxcXFxhbHBoYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzYjJcIiwgXCJcXFxcYmV0YVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzYjNcIiwgXCJcXFxcZ2FtbWFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2I0XCIsIFwiXFxcXGRlbHRhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNmNVwiLCBcIlxcXFxlcHNpbG9uXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNiNlwiLCBcIlxcXFx6ZXRhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNiN1wiLCBcIlxcXFxldGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2I4XCIsIFwiXFxcXHRoZXRhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNiOVwiLCBcIlxcXFxpb3RhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNiYVwiLCBcIlxcXFxrYXBwYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzYmJcIiwgXCJcXFxcbGFtYmRhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNiY1wiLCBcIlxcXFxtdVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzYmRcIiwgXCJcXFxcbnVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2JlXCIsIFwiXFxcXHhpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNiZlwiLCBcIlxcXFxvbWljcm9uXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNjMFwiLCBcIlxcXFxwaVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzYzFcIiwgXCJcXFxccmhvXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNjM1wiLCBcIlxcXFxzaWdtYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzYzRcIiwgXCJcXFxcdGF1XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNjNVwiLCBcIlxcXFx1cHNpbG9uXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNkNVwiLCBcIlxcXFxwaGlcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2M3XCIsIFwiXFxcXGNoaVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzYzhcIiwgXCJcXFxccHNpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNjOVwiLCBcIlxcXFxvbWVnYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzYjVcIiwgXCJcXFxcdmFyZXBzaWxvblwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzZDFcIiwgXCJcXFxcdmFydGhldGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2Q2XCIsIFwiXFxcXHZhcnBpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNmMVwiLCBcIlxcXFx2YXJyaG9cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2MyXCIsIFwiXFxcXHZhcnNpZ21hXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNjNlwiLCBcIlxcXFx2YXJwaGlcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyMTdcIiwgXCIqXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCIrXCIsIFwiK1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjIxMlwiLCBcIi1cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyYzVcIiwgXCJcXFxcY2RvdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjIxOFwiLCBcIlxcXFxjaXJjXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUwMGY3XCIsIFwiXFxcXGRpdlwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MDBiMVwiLCBcIlxcXFxwbVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MDBkN1wiLCBcIlxcXFx0aW1lc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjIyOVwiLCBcIlxcXFxjYXBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyMmFcIiwgXCJcXFxcY3VwXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjE2XCIsIFwiXFxcXHNldG1pbnVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjI3XCIsIFwiXFxcXGxhbmRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyMjhcIiwgXCJcXFxcbG9yXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjI3XCIsIFwiXFxcXHdlZGdlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjI4XCIsIFwiXFxcXHZlZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIyMWFcIiwgXCJcXFxcc3VyZFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBzeW1ib2xzX29wZW4sIFwiXFx1MjdlOFwiLCBcIlxcXFxsYW5nbGVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgc3ltYm9sc19vcGVuLCBcIlxcdTIyMjNcIiwgXCJcXFxcbHZlcnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgc3ltYm9sc19vcGVuLCBcIlxcdTIyMjVcIiwgXCJcXFxcbFZlcnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgc3ltYm9sc19jbG9zZSwgXCI/XCIsIFwiP1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBzeW1ib2xzX2Nsb3NlLCBcIiFcIiwgXCIhXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHN5bWJvbHNfY2xvc2UsIFwiXFx1MjdlOVwiLCBcIlxcXFxyYW5nbGVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgc3ltYm9sc19jbG9zZSwgXCJcXHUyMjIzXCIsIFwiXFxcXHJ2ZXJ0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHN5bWJvbHNfY2xvc2UsIFwiXFx1MjIyNVwiLCBcIlxcXFxyVmVydFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiPVwiLCBcIj1cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIjpcIiwgXCI6XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjQ4XCIsIFwiXFxcXGFwcHJveFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI0NVwiLCBcIlxcXFxjb25nXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjY1XCIsIFwiXFxcXGdlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjY1XCIsIFwiXFxcXGdlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjE5MFwiLCBcIlxcXFxnZXRzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCI+XCIsIFwiXFxcXGd0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjA4XCIsIFwiXFxcXGluXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHVlMDIwXCIsIFwiXFxcXEBub3RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyODJcIiwgXCJcXFxcc3Vic2V0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjgzXCIsIFwiXFxcXHN1cHNldFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI4NlwiLCBcIlxcXFxzdWJzZXRlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI4N1wiLCBcIlxcXFxzdXBzZXRlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjg4XCIsIFwiXFxcXG5zdWJzZXRlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjg5XCIsIFwiXFxcXG5zdXBzZXRlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjJhOFwiLCBcIlxcXFxtb2RlbHNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxOTBcIiwgXCJcXFxcbGVmdGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjY0XCIsIFwiXFxcXGxlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjY0XCIsIFwiXFxcXGxlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiPFwiLCBcIlxcXFxsdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjE5MlwiLCBcIlxcXFxyaWdodGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMTkyXCIsIFwiXFxcXHRvXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNzFcIiwgXCJcXFxcbmdlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjcwXCIsIFwiXFxcXG5sZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgc3BhY2luZywgXCJcXHUwMGEwXCIsIFwiXFxcXCBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgc3BhY2luZywgXCJcXHUwMGEwXCIsIFwiXFxcXHNwYWNlXCIpOyAvLyBSZWY6IExhVGVYIFNvdXJjZSAyZTogXFxEZWNsYXJlUm9idXN0Q29tbWFuZHtcXG5vYnJlYWtzcGFjZX17JVxuXG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgc3BhY2luZywgXCJcXHUwMGEwXCIsIFwiXFxcXG5vYnJlYWtzcGFjZVwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHNwYWNpbmcsIFwiXFx1MDBhMFwiLCBcIlxcXFwgXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3BhY2luZywgXCJcXHUwMGEwXCIsIFwiIFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHNwYWNpbmcsIFwiXFx1MDBhMFwiLCBcIlxcXFxzcGFjZVwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHNwYWNpbmcsIFwiXFx1MDBhMFwiLCBcIlxcXFxub2JyZWFrc3BhY2VcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgc3BhY2luZywgbnVsbCwgXCJcXFxcbm9icmVha1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBzcGFjaW5nLCBudWxsLCBcIlxcXFxhbGxvd2JyZWFrXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHB1bmN0LCBcIixcIiwgXCIsXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHB1bmN0LCBcIjtcIiwgXCI7XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyYmNcIiwgXCJcXFxcYmFyd2VkZ2VcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJiYlwiLCBcIlxcXFx2ZWViYXJcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyOTlcIiwgXCJcXFxcb2RvdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjI5NVwiLCBcIlxcXFxvcGx1c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjI5N1wiLCBcIlxcXFxvdGltZXNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMjAyXCIsIFwiXFxcXHBhcnRpYWxcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyOThcIiwgXCJcXFxcb3NsYXNoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyOWFcIiwgXCJcXFxcY2lyY2xlZGNpcmNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJhMVwiLCBcIlxcXFxib3hkb3RcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTI1YjNcIiwgXCJcXFxcYmlndHJpYW5nbGV1cFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjViZFwiLCBcIlxcXFxiaWd0cmlhbmdsZWRvd25cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIwMjBcIiwgXCJcXFxcZGFnZ2VyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMmM0XCIsIFwiXFxcXGRpYW1vbmRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyYzZcIiwgXCJcXFxcc3RhclwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjVjM1wiLCBcIlxcXFx0cmlhbmdsZWxlZnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTI1YjlcIiwgXCJcXFxcdHJpYW5nbGVyaWdodFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBzeW1ib2xzX29wZW4sIFwie1wiLCBcIlxcXFx7XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJ7XCIsIFwiXFxcXHtcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIntcIiwgXCJcXFxcdGV4dGJyYWNlbGVmdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBzeW1ib2xzX2Nsb3NlLCBcIn1cIiwgXCJcXFxcfVwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHRleHRvcmQsIFwifVwiLCBcIlxcXFx9XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJ9XCIsIFwiXFxcXHRleHRicmFjZXJpZ2h0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHN5bWJvbHNfb3BlbiwgXCJ7XCIsIFwiXFxcXGxicmFjZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBzeW1ib2xzX2Nsb3NlLCBcIn1cIiwgXCJcXFxccmJyYWNlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHN5bWJvbHNfb3BlbiwgXCJbXCIsIFwiXFxcXGxicmFja1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHRleHRvcmQsIFwiW1wiLCBcIlxcXFxsYnJhY2tcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgc3ltYm9sc19jbG9zZSwgXCJdXCIsIFwiXFxcXHJicmFja1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHRleHRvcmQsIFwiXVwiLCBcIlxcXFxyYnJhY2tcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgc3ltYm9sc19vcGVuLCBcIihcIiwgXCJcXFxcbHBhcmVuXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHN5bWJvbHNfY2xvc2UsIFwiKVwiLCBcIlxcXFxycGFyZW5cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIjxcIiwgXCJcXFxcdGV4dGxlc3NcIiwgdHJ1ZSk7IC8vIGluIFQxIGZvbnRlbmNcblxuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgdGV4dG9yZCwgXCI+XCIsIFwiXFxcXHRleHRncmVhdGVyXCIsIHRydWUpOyAvLyBpbiBUMSBmb250ZW5jXG5cbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBzeW1ib2xzX29wZW4sIFwiXFx1MjMwYVwiLCBcIlxcXFxsZmxvb3JcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgc3ltYm9sc19jbG9zZSwgXCJcXHUyMzBiXCIsIFwiXFxcXHJmbG9vclwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBzeW1ib2xzX29wZW4sIFwiXFx1MjMwOFwiLCBcIlxcXFxsY2VpbFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBzeW1ib2xzX2Nsb3NlLCBcIlxcdTIzMDlcIiwgXCJcXFxccmNlaWxcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXFxcXCIsIFwiXFxcXGJhY2tzbGFzaFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIyMjNcIiwgXCJ8XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjIyM1wiLCBcIlxcXFx2ZXJ0XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJ8XCIsIFwiXFxcXHRleHRiYXJcIiwgdHJ1ZSk7IC8vIGluIFQxIGZvbnRlbmNcblxuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjIyNVwiLCBcIlxcXFx8XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjIyNVwiLCBcIlxcXFxWZXJ0XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMjI1XCIsIFwiXFxcXHRleHRiYXJkYmxcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIn5cIiwgXCJcXFxcdGV4dGFzY2lpdGlsZGVcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcXFxcIiwgXCJcXFxcdGV4dGJhY2tzbGFzaFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHRleHRvcmQsIFwiXlwiLCBcIlxcXFx0ZXh0YXNjaWljaXJjdW1cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxOTFcIiwgXCJcXFxcdXBhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjFkMVwiLCBcIlxcXFxVcGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMTkzXCIsIFwiXFxcXGRvd25hcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjFkM1wiLCBcIlxcXFxEb3duYXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxOTVcIiwgXCJcXFxcdXBkb3duYXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxZDVcIiwgXCJcXFxcVXBkb3duYXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3AsIFwiXFx1MjIxMFwiLCBcIlxcXFxjb3Byb2RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3AsIFwiXFx1MjJjMVwiLCBcIlxcXFxiaWd2ZWVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3AsIFwiXFx1MjJjMFwiLCBcIlxcXFxiaWd3ZWRnZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBvcCwgXCJcXHUyYTA0XCIsIFwiXFxcXGJpZ3VwbHVzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wLCBcIlxcdTIyYzJcIiwgXCJcXFxcYmlnY2FwXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wLCBcIlxcdTIyYzNcIiwgXCJcXFxcYmlnY3VwXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wLCBcIlxcdTIyMmJcIiwgXCJcXFxcaW50XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wLCBcIlxcdTIyMmJcIiwgXCJcXFxcaW50b3BcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3AsIFwiXFx1MjIyY1wiLCBcIlxcXFxpaW50XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wLCBcIlxcdTIyMmRcIiwgXCJcXFxcaWlpbnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3AsIFwiXFx1MjIwZlwiLCBcIlxcXFxwcm9kXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wLCBcIlxcdTIyMTFcIiwgXCJcXFxcc3VtXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wLCBcIlxcdTJhMDJcIiwgXCJcXFxcYmlnb3RpbWVzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wLCBcIlxcdTJhMDFcIiwgXCJcXFxcYmlnb3BsdXNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3AsIFwiXFx1MmEwMFwiLCBcIlxcXFxiaWdvZG90XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wLCBcIlxcdTIyMmVcIiwgXCJcXFxcb2ludFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBvcCwgXCJcXHUyMjJmXCIsIFwiXFxcXG9paW50XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wLCBcIlxcdTIyMzBcIiwgXCJcXFxcb2lpaW50XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wLCBcIlxcdTJhMDZcIiwgXCJcXFxcYmlnc3FjdXBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3AsIFwiXFx1MjIyYlwiLCBcIlxcXFxzbWFsbGludFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIGlubmVyLCBcIlxcdTIwMjZcIiwgXCJcXFxcdGV4dGVsbGlwc2lzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGlubmVyLCBcIlxcdTIwMjZcIiwgXCJcXFxcbWF0aGVsbGlwc2lzXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgaW5uZXIsIFwiXFx1MjAyNlwiLCBcIlxcXFxsZG90c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBpbm5lciwgXCJcXHUyMDI2XCIsIFwiXFxcXGxkb3RzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGlubmVyLCBcIlxcdTIyZWZcIiwgXCJcXFxcQGNkb3RzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGlubmVyLCBcIlxcdTIyZjFcIiwgXCJcXFxcZGRvdHNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMmVlXCIsIFwiXFxcXHZhcnZkb3RzXCIpOyAvLyBcXHZkb3RzIGlzIGEgbWFjcm9cblxuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGFjY2VudCwgXCJcXHUwMmNhXCIsIFwiXFxcXGFjdXRlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGFjY2VudCwgXCJcXHUwMmNiXCIsIFwiXFxcXGdyYXZlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGFjY2VudCwgXCJcXHUwMGE4XCIsIFwiXFxcXGRkb3RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYWNjZW50LCBcIlxcdTAwN2VcIiwgXCJcXFxcdGlsZGVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYWNjZW50LCBcIlxcdTAyYzlcIiwgXCJcXFxcYmFyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGFjY2VudCwgXCJcXHUwMmQ4XCIsIFwiXFxcXGJyZXZlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGFjY2VudCwgXCJcXHUwMmM3XCIsIFwiXFxcXGNoZWNrXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGFjY2VudCwgXCJcXHUwMDVlXCIsIFwiXFxcXGhhdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBhY2NlbnQsIFwiXFx1MjBkN1wiLCBcIlxcXFx2ZWNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYWNjZW50LCBcIlxcdTAyZDlcIiwgXCJcXFxcZG90XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGFjY2VudCwgXCJcXHUwMmRhXCIsIFwiXFxcXG1hdGhyaW5nXCIpOyAvLyBcXGltYXRoIGFuZCBcXGptYXRoIHNob3VsZCBiZSBpbnZhcmlhbnQgdG8gXFxtYXRocm0sIFxcbWF0aGJmLCBldGMuLCBzbyB1c2UgUFVBXG5cbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdWUxMzFcIiwgXCJcXFxcQGltYXRoXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1ZTIzN1wiLCBcIlxcXFxAam1hdGhcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwMTMxXCIsIFwiXFx1MDEzMVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAyMzdcIiwgXCJcXHUwMjM3XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwMTMxXCIsIFwiXFxcXGlcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAyMzdcIiwgXCJcXFxcalwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MDBkZlwiLCBcIlxcXFxzc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MDBlNlwiLCBcIlxcXFxhZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MDE1M1wiLCBcIlxcXFxvZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MDBmOFwiLCBcIlxcXFxvXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwMGM2XCIsIFwiXFxcXEFFXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwMTUyXCIsIFwiXFxcXE9FXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwMGQ4XCIsIFwiXFxcXE9cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBhY2NlbnQsIFwiXFx1MDJjYVwiLCBcIlxcXFwnXCIpOyAvLyBhY3V0ZVxuXG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBhY2NlbnQsIFwiXFx1MDJjYlwiLCBcIlxcXFxgXCIpOyAvLyBncmF2ZVxuXG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBhY2NlbnQsIFwiXFx1MDJjNlwiLCBcIlxcXFxeXCIpOyAvLyBjaXJjdW1mbGV4XG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIGFjY2VudCwgXCJcXHUwMmRjXCIsIFwiXFxcXH5cIik7IC8vIHRpbGRlXG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIGFjY2VudCwgXCJcXHUwMmM5XCIsIFwiXFxcXD1cIik7IC8vIG1hY3JvblxuXG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBhY2NlbnQsIFwiXFx1MDJkOFwiLCBcIlxcXFx1XCIpOyAvLyBicmV2ZVxuXG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBhY2NlbnQsIFwiXFx1MDJkOVwiLCBcIlxcXFwuXCIpOyAvLyBkb3QgYWJvdmVcblxuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgYWNjZW50LCBcIlxcdTAwYjhcIiwgXCJcXFxcY1wiKTsgLy8gY2VkaWxsYVxuXG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBhY2NlbnQsIFwiXFx1MDJkYVwiLCBcIlxcXFxyXCIpOyAvLyByaW5nIGFib3ZlXG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIGFjY2VudCwgXCJcXHUwMmM3XCIsIFwiXFxcXHZcIik7IC8vIGNhcm9uXG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIGFjY2VudCwgXCJcXHUwMGE4XCIsICdcXFxcXCInKTsgLy8gZGlhcmVzaXNcblxuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgYWNjZW50LCBcIlxcdTAyZGRcIiwgXCJcXFxcSFwiKTsgLy8gZG91YmxlIGFjdXRlXG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIGFjY2VudCwgXCJcXHUyNWVmXCIsIFwiXFxcXHRleHRjaXJjbGVkXCIpOyAvLyBcXGJpZ2NpcmMgZ2x5cGhcbi8vIFRoZXNlIGxpZ2F0dXJlcyBhcmUgZGV0ZWN0ZWQgYW5kIGNyZWF0ZWQgaW4gUGFyc2VyLmpzJ3MgYGZvcm1MaWdhdHVyZXNgLlxuXG5jb25zdCBsaWdhdHVyZXMgPSB7XG4gIFwiLS1cIjogdHJ1ZSxcbiAgXCItLS1cIjogdHJ1ZSxcbiAgXCJgYFwiOiB0cnVlLFxuICBcIicnXCI6IHRydWVcbn07XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIwMTNcIiwgXCItLVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MjAxM1wiLCBcIlxcXFx0ZXh0ZW5kYXNoXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDE0XCIsIFwiLS0tXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDE0XCIsIFwiXFxcXHRleHRlbWRhc2hcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIwMThcIiwgXCJgXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDE4XCIsIFwiXFxcXHRleHRxdW90ZWxlZnRcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIwMTlcIiwgXCInXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDE5XCIsIFwiXFxcXHRleHRxdW90ZXJpZ2h0XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDFjXCIsIFwiYGBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIwMWNcIiwgXCJcXFxcdGV4dHF1b3RlZGJsbGVmdFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MjAxZFwiLCBcIicnXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDFkXCIsIFwiXFxcXHRleHRxdW90ZWRibHJpZ2h0XCIpOyAvLyAgXFxkZWdyZWUgZnJvbSBnZW5zeW1iIHBhY2thZ2VcblxuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDBiMFwiLCBcIlxcXFxkZWdyZWVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAwYjBcIiwgXCJcXFxcZGVncmVlXCIpOyAvLyBcXHRleHRkZWdyZWUgZnJvbSBpbnB1dGVuYyBwYWNrYWdlXG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MDBiMFwiLCBcIlxcXFx0ZXh0ZGVncmVlXCIsIHRydWUpOyAvLyBUT0RPOiBJbiBMYVRlWCwgXFxwb3VuZHMgY2FuIGdlbmVyYXRlIGEgZGlmZmVyZW50IGNoYXJhY3RlciBpbiB0ZXh0IGFuZCBtYXRoXG4vLyBtb2RlLCBidXQgYW1vbmcgb3VyIGZvbnRzLCBvbmx5IE1haW4tUmVndWxhciBkZWZpbmVzIHRoaXMgY2hhcmFjdGVyIFwiMTYzXCIuXG5cbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAwYTNcIiwgXCJcXFxccG91bmRzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDBhM1wiLCBcIlxcXFxtYXRoc3RlcmxpbmdcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAwYTNcIiwgXCJcXFxccG91bmRzXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwMGEzXCIsIFwiXFxcXHRleHRzdGVybGluZ1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjcyMFwiLCBcIlxcXFxtYWx0ZXNlXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTI3MjBcIiwgXCJcXFxcbWFsdGVzZVwiKTsgLy8gVGhlcmUgYXJlIGxvdHMgb2Ygc3ltYm9scyB3aGljaCBhcmUgdGhlIHNhbWUsIHNvIHdlIGFkZCB0aGVtIGluIGFmdGVyd2FyZHMuXG4vLyBBbGwgb2YgdGhlc2UgYXJlIHRleHRvcmRzIGluIG1hdGggbW9kZVxuXG5jb25zdCBtYXRoVGV4dFN5bWJvbHMgPSBcIjAxMjM0NTY3ODkvQC5cXFwiXCI7XG5cbmZvciAobGV0IGkgPSAwOyBpIDwgbWF0aFRleHRTeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG4gIGNvbnN0IGNoID0gbWF0aFRleHRTeW1ib2xzLmNoYXJBdChpKTtcbiAgZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIGNoLCBjaCk7XG59IC8vIEFsbCBvZiB0aGVzZSBhcmUgdGV4dG9yZHMgaW4gdGV4dCBtb2RlXG5cblxuY29uc3QgdGV4dFN5bWJvbHMgPSBcIjAxMjM0NTY3ODkhQCooKS09K1xcXCI7Oj8vLixcIjtcblxuZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0U3ltYm9scy5sZW5ndGg7IGkrKykge1xuICBjb25zdCBjaCA9IHRleHRTeW1ib2xzLmNoYXJBdChpKTtcbiAgZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgdGV4dG9yZCwgY2gsIGNoKTtcbn0gLy8gQWxsIG9mIHRoZXNlIGFyZSB0ZXh0b3JkcyBpbiB0ZXh0IG1vZGUsIGFuZCBtYXRob3JkcyBpbiBtYXRoIG1vZGVcblxuXG5jb25zdCBsZXR0ZXJzID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XCI7XG5cbmZvciAobGV0IGkgPSAwOyBpIDwgbGV0dGVycy5sZW5ndGg7IGkrKykge1xuICBjb25zdCBjaCA9IGxldHRlcnMuY2hhckF0KGkpO1xuICBkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgY2gsIGNoKTtcbiAgZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgdGV4dG9yZCwgY2gsIGNoKTtcbn0gLy8gQmxhY2tib2FyZCBib2xkIGFuZCBzY3JpcHQgbGV0dGVycyBpbiBVbmljb2RlIHJhbmdlXG5cblxuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJDXCIsIFwiXFx1MjEwMlwiKTsgLy8gYmxhY2tib2FyZCBib2xkXG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIGFtcywgdGV4dG9yZCwgXCJDXCIsIFwiXFx1MjEwMlwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiSFwiLCBcIlxcdTIxMERcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBhbXMsIHRleHRvcmQsIFwiSFwiLCBcIlxcdTIxMERcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIk5cIiwgXCJcXHUyMTE1XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgYW1zLCB0ZXh0b3JkLCBcIk5cIiwgXCJcXHUyMTE1XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJQXCIsIFwiXFx1MjExOVwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIGFtcywgdGV4dG9yZCwgXCJQXCIsIFwiXFx1MjExOVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiUVwiLCBcIlxcdTIxMUFcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBhbXMsIHRleHRvcmQsIFwiUVwiLCBcIlxcdTIxMUFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlJcIiwgXCJcXHUyMTFEXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgYW1zLCB0ZXh0b3JkLCBcIlJcIiwgXCJcXHUyMTFEXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJaXCIsIFwiXFx1MjEyNFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIGFtcywgdGV4dG9yZCwgXCJaXCIsIFwiXFx1MjEyNFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcImhcIiwgXCJcXHUyMTBFXCIpOyAvLyBpdGFsaWMgaCwgUGxhbmNrIGNvbnN0YW50XG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIG1hdGhvcmQsIFwiaFwiLCBcIlxcdTIxMEVcIik7IC8vIFRoZSBuZXh0IGxvb3AgbG9hZHMgd2lkZSAoc3Vycm9nYXRlIHBhaXIpIGNoYXJhY3RlcnMuXG4vLyBXZSBzdXBwb3J0IHNvbWUgbGV0dGVycyBpbiB0aGUgVW5pY29kZSByYW5nZSBVKzFENDAwIHRvIFUrMUQ3RkYsXG4vLyBNYXRoZW1hdGljYWwgQWxwaGFudW1lcmljIFN5bWJvbHMuXG4vLyBTb21lIGVkaXRvcnMgZG8gbm90IGRlYWwgd2VsbCB3aXRoIHdpZGUgY2hhcmFjdGVycy4gU28gZG9uJ3Qgd3JpdGUgdGhlXG4vLyBzdHJpbmcgaW50byB0aGlzIGZpbGUuIEluc3RlYWQsIGNyZWF0ZSB0aGUgc3RyaW5nIGZyb20gdGhlIHN1cnJvZ2F0ZSBwYWlyLlxuXG5sZXQgd2lkZUNoYXIgPSBcIlwiO1xuXG5mb3IgKGxldCBpID0gMDsgaSA8IGxldHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgY29uc3QgY2ggPSBsZXR0ZXJzLmNoYXJBdChpKTsgLy8gVGhlIGhleCBudW1iZXJzIGluIHRoZSBuZXh0IGxpbmUgYXJlIGEgc3Vycm9nYXRlIHBhaXIuXG4gIC8vIDB4RDgzNSBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgZm9yIGFsbCBsZXR0ZXJzIGluIHRoZSByYW5nZSB3ZSBzdXBwb3J0LlxuICAvLyAweERDMDAgaXMgdGhlIGxvdyBzdXJyb2dhdGUgZm9yIGJvbGQgQS5cblxuICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODM1LCAweERDMDAgKyBpKTsgLy8gQS1aIGEteiBib2xkXG5cbiAgZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIGNoLCB3aWRlQ2hhcik7XG4gIGRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHRleHRvcmQsIGNoLCB3aWRlQ2hhcik7XG4gIHdpZGVDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEQ4MzUsIDB4REMzNCArIGkpOyAvLyBBLVogYS16IGl0YWxpY1xuXG4gIGRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBjaCwgd2lkZUNoYXIpO1xuICBkZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCB0ZXh0b3JkLCBjaCwgd2lkZUNoYXIpO1xuICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODM1LCAweERDNjggKyBpKTsgLy8gQS1aIGEteiBib2xkIGl0YWxpY1xuXG4gIGRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBjaCwgd2lkZUNoYXIpO1xuICBkZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCB0ZXh0b3JkLCBjaCwgd2lkZUNoYXIpO1xuICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODM1LCAweEREMDQgKyBpKTsgLy8gQS1aIGEteiBGcmFrdHVyXG5cbiAgZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIGNoLCB3aWRlQ2hhcik7XG4gIGRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHRleHRvcmQsIGNoLCB3aWRlQ2hhcik7XG4gIHdpZGVDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEQ4MzUsIDB4REQ2QyArIGkpOyAvLyBBLVogYS16IGJvbGQgRnJha3R1clxuXG4gIGRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBjaCwgd2lkZUNoYXIpO1xuICBkZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCB0ZXh0b3JkLCBjaCwgd2lkZUNoYXIpO1xuICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODM1LCAweEREQTAgKyBpKTsgLy8gQS1aIGEteiBzYW5zLXNlcmlmXG5cbiAgZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIGNoLCB3aWRlQ2hhcik7XG4gIGRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHRleHRvcmQsIGNoLCB3aWRlQ2hhcik7XG4gIHdpZGVDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEQ4MzUsIDB4RERENCArIGkpOyAvLyBBLVogYS16IHNhbnMgYm9sZFxuXG4gIGRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBjaCwgd2lkZUNoYXIpO1xuICBkZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCB0ZXh0b3JkLCBjaCwgd2lkZUNoYXIpO1xuICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODM1LCAweERFMDggKyBpKTsgLy8gQS1aIGEteiBzYW5zIGl0YWxpY1xuXG4gIGRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBjaCwgd2lkZUNoYXIpO1xuICBkZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCB0ZXh0b3JkLCBjaCwgd2lkZUNoYXIpO1xuICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODM1LCAweERFNzAgKyBpKTsgLy8gQS1aIGEteiBtb25vc3BhY2VcblxuICBkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgY2gsIHdpZGVDaGFyKTtcbiAgZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgdGV4dG9yZCwgY2gsIHdpZGVDaGFyKTtcblxuICBpZiAoaSA8IDI2KSB7XG4gICAgLy8gS2FUZVggZm9udHMgaGF2ZSBvbmx5IGNhcGl0YWwgbGV0dGVycyBmb3IgYmxhY2tib2FyZCBib2xkIGFuZCBzY3JpcHQuXG4gICAgLy8gU2VlIGV4Y2VwdGlvbiBmb3IgayBiZWxvdy5cbiAgICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODM1LCAweEREMzggKyBpKTsgLy8gQS1aIGRvdWJsZSBzdHJ1Y2tcblxuICAgIGRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBjaCwgd2lkZUNoYXIpO1xuICAgIGRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHRleHRvcmQsIGNoLCB3aWRlQ2hhcik7XG4gICAgd2lkZUNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RDgzNSwgMHhEQzlDICsgaSk7IC8vIEEtWiBzY3JpcHRcblxuICAgIGRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBjaCwgd2lkZUNoYXIpO1xuICAgIGRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHRleHRvcmQsIGNoLCB3aWRlQ2hhcik7XG4gIH0gLy8gVE9ETzogQWRkIGJvbGQgc2NyaXB0IHdoZW4gaXQgaXMgc3VwcG9ydGVkIGJ5IGEgS2FUZVggZm9udC5cblxufSAvLyBcImtcIiBpcyB0aGUgb25seSBkb3VibGUgc3RydWNrIGxvd2VyIGNhc2UgbGV0dGVyIGluIHRoZSBLYVRlWCBmb250cy5cblxuXG53aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODM1LCAweERENUMpOyAvLyBrIGRvdWJsZSBzdHJ1Y2tcblxuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwia1wiLCB3aWRlQ2hhcik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCB0ZXh0b3JkLCBcImtcIiwgd2lkZUNoYXIpOyAvLyBOZXh0LCBzb21lIHdpZGUgY2hhcmFjdGVyIG51bWVyYWxzXG5cbmZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICBjb25zdCBjaCA9IGkudG9TdHJpbmcoKTtcbiAgd2lkZUNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RDgzNSwgMHhERkNFICsgaSk7IC8vIDAtOSBib2xkXG5cbiAgZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIGNoLCB3aWRlQ2hhcik7XG4gIGRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHRleHRvcmQsIGNoLCB3aWRlQ2hhcik7XG4gIHdpZGVDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEQ4MzUsIDB4REZFMiArIGkpOyAvLyAwLTkgc2FucyBzZXJpZlxuXG4gIGRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBjaCwgd2lkZUNoYXIpO1xuICBkZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCB0ZXh0b3JkLCBjaCwgd2lkZUNoYXIpO1xuICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODM1LCAweERGRUMgKyBpKTsgLy8gMC05IGJvbGQgc2Fuc1xuXG4gIGRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBjaCwgd2lkZUNoYXIpO1xuICBkZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCB0ZXh0b3JkLCBjaCwgd2lkZUNoYXIpO1xuICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODM1LCAweERGRjYgKyBpKTsgLy8gMC05IG1vbm9zcGFjZVxuXG4gIGRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBjaCwgd2lkZUNoYXIpO1xuICBkZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCB0ZXh0b3JkLCBjaCwgd2lkZUNoYXIpO1xufSAvLyBXZSBhZGQgdGhlc2UgTGF0aW4tMSBsZXR0ZXJzIGFzIHN5bWJvbHMgZm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5LFxuLy8gYnV0IHRoZXkgYXJlIG5vdCBhY3R1YWxseSBpbiB0aGUgZm9udCwgbm9yIGFyZSB0aGV5IHN1cHBvcnRlZCBieSB0aGVcbi8vIFVuaWNvZGUgYWNjZW50IG1lY2hhbmlzbSwgc28gdGhleSBmYWxsIGJhY2sgdG8gVGltZXMgZm9udCBhbmQgbG9vayB1Z2x5LlxuLy8gVE9ETyhlZGVtYWluZSk6IEZpeCB0aGlzLlxuXG5cbmNvbnN0IGV4dHJhTGF0aW4gPSBcIlxcdTAwZDBcXHUwMGRlXFx1MDBmZVwiO1xuXG5mb3IgKGxldCBpID0gMDsgaSA8IGV4dHJhTGF0aW4ubGVuZ3RoOyBpKyspIHtcbiAgY29uc3QgY2ggPSBleHRyYUxhdGluLmNoYXJBdChpKTtcbiAgZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIGNoLCBjaCk7XG4gIGRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHRleHRvcmQsIGNoLCBjaCk7XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvd2lkZS1jaGFyYWN0ZXIuanNcbi8qKlxuICogVGhpcyBmaWxlIHByb3ZpZGVzIHN1cHBvcnQgZm9yIFVuaWNvZGUgcmFuZ2UgVSsxRDQwMCB0byBVKzFEN0ZGLFxuICogTWF0aGVtYXRpY2FsIEFscGhhbnVtZXJpYyBTeW1ib2xzLlxuICpcbiAqIEZ1bmN0aW9uIHdpZGVDaGFyYWN0ZXJGb250IHRha2VzIGEgd2lkZSBjaGFyYWN0ZXIgYXMgaW5wdXQgYW5kIHJldHVybnNcbiAqIHRoZSBmb250IGluZm9ybWF0aW9uIG5lY2Vzc2FyeSB0byByZW5kZXIgaXQgcHJvcGVybHkuXG4gKi9cblxuLyoqXG4gKiBEYXRhIGJlbG93IGlzIGZyb20gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvY2hhcnRzL1BERi9VMUQ0MDAucGRmXG4gKiBUaGF0IGRvY3VtZW50IHNvcnRzIGNoYXJhY3RlcnMgaW50byBncm91cHMgYnkgZm9udCB0eXBlLCBzYXkgYm9sZCBvciBpdGFsaWMuXG4gKlxuICogSW4gdGhlIGFycmF5cyBiZWxvdywgZWFjaCBzdWJhcnJheSBjb25zaXN0cyB0aHJlZSBlbGVtZW50czpcbiAqICAgICAgKiBUaGUgQ1NTIGNsYXNzIG9mIHRoYXQgZ3JvdXAgd2hlbiBpbiBtYXRoIG1vZGUuXG4gKiAgICAgICogVGhlIENTUyBjbGFzcyBvZiB0aGF0IGdyb3VwIHdoZW4gaW4gdGV4dCBtb2RlLlxuICogICAgICAqIFRoZSBmb250IG5hbWUsIHNvIHRoYXQgS2FUZVggY2FuIGdldCBmb250IG1ldHJpY3MuXG4gKi9cblxuY29uc3Qgd2lkZUxhdGluTGV0dGVyRGF0YSA9IFtbXCJtYXRoYmZcIiwgXCJ0ZXh0YmZcIiwgXCJNYWluLUJvbGRcIl0sIC8vIEEtWiBib2xkIHVwcmlnaHRcbltcIm1hdGhiZlwiLCBcInRleHRiZlwiLCBcIk1haW4tQm9sZFwiXSwgLy8gYS16IGJvbGQgdXByaWdodFxuW1wibWF0aG5vcm1hbFwiLCBcInRleHRpdFwiLCBcIk1hdGgtSXRhbGljXCJdLCAvLyBBLVogaXRhbGljXG5bXCJtYXRobm9ybWFsXCIsIFwidGV4dGl0XCIsIFwiTWF0aC1JdGFsaWNcIl0sIC8vIGEteiBpdGFsaWNcbltcImJvbGRzeW1ib2xcIiwgXCJib2xkc3ltYm9sXCIsIFwiTWFpbi1Cb2xkSXRhbGljXCJdLCAvLyBBLVogYm9sZCBpdGFsaWNcbltcImJvbGRzeW1ib2xcIiwgXCJib2xkc3ltYm9sXCIsIFwiTWFpbi1Cb2xkSXRhbGljXCJdLCAvLyBhLXogYm9sZCBpdGFsaWNcbi8vIE1hcCBmYW5jeSBBLVogbGV0dGVycyB0byBzY3JpcHQsIG5vdCBjYWxsaWdyYXBoaWMuXG4vLyBUaGlzIGFsaWducyB3aXRoIHVuaWNvZGUtbWF0aCBhbmQgbWF0aCBmb250cyAoZXhjZXB0IENhbWJyaWEgTWF0aCkuXG5bXCJtYXRoc2NyXCIsIFwidGV4dHNjclwiLCBcIlNjcmlwdC1SZWd1bGFyXCJdLCAvLyBBLVogc2NyaXB0XG5bXCJcIiwgXCJcIiwgXCJcIl0sIC8vIGEteiBzY3JpcHQuICBObyBmb250XG5bXCJcIiwgXCJcIiwgXCJcIl0sIC8vIEEtWiBib2xkIHNjcmlwdC4gTm8gZm9udFxuW1wiXCIsIFwiXCIsIFwiXCJdLCAvLyBhLXogYm9sZCBzY3JpcHQuIE5vIGZvbnRcbltcIm1hdGhmcmFrXCIsIFwidGV4dGZyYWtcIiwgXCJGcmFrdHVyLVJlZ3VsYXJcIl0sIC8vIEEtWiBGcmFrdHVyXG5bXCJtYXRoZnJha1wiLCBcInRleHRmcmFrXCIsIFwiRnJha3R1ci1SZWd1bGFyXCJdLCAvLyBhLXogRnJha3R1clxuW1wibWF0aGJiXCIsIFwidGV4dGJiXCIsIFwiQU1TLVJlZ3VsYXJcIl0sIC8vIEEtWiBkb3VibGUtc3RydWNrXG5bXCJtYXRoYmJcIiwgXCJ0ZXh0YmJcIiwgXCJBTVMtUmVndWxhclwiXSwgLy8gayBkb3VibGUtc3RydWNrXG4vLyBOb3RlIHRoYXQgd2UgYXJlIHVzaW5nIGEgYm9sZCBmb250LCBidXQgZm9udCBtZXRyaWNzIGZvciByZWd1bGFyIEZyYWt0dXIuXG5bXCJtYXRoYm9sZGZyYWtcIiwgXCJ0ZXh0Ym9sZGZyYWtcIiwgXCJGcmFrdHVyLVJlZ3VsYXJcIl0sIC8vIEEtWiBib2xkIEZyYWt0dXJcbltcIm1hdGhib2xkZnJha1wiLCBcInRleHRib2xkZnJha1wiLCBcIkZyYWt0dXItUmVndWxhclwiXSwgLy8gYS16IGJvbGQgRnJha3R1clxuW1wibWF0aHNmXCIsIFwidGV4dHNmXCIsIFwiU2Fuc1NlcmlmLVJlZ3VsYXJcIl0sIC8vIEEtWiBzYW5zLXNlcmlmXG5bXCJtYXRoc2ZcIiwgXCJ0ZXh0c2ZcIiwgXCJTYW5zU2VyaWYtUmVndWxhclwiXSwgLy8gYS16IHNhbnMtc2VyaWZcbltcIm1hdGhib2xkc2ZcIiwgXCJ0ZXh0Ym9sZHNmXCIsIFwiU2Fuc1NlcmlmLUJvbGRcIl0sIC8vIEEtWiBib2xkIHNhbnMtc2VyaWZcbltcIm1hdGhib2xkc2ZcIiwgXCJ0ZXh0Ym9sZHNmXCIsIFwiU2Fuc1NlcmlmLUJvbGRcIl0sIC8vIGEteiBib2xkIHNhbnMtc2VyaWZcbltcIm1hdGhpdHNmXCIsIFwidGV4dGl0c2ZcIiwgXCJTYW5zU2VyaWYtSXRhbGljXCJdLCAvLyBBLVogaXRhbGljIHNhbnMtc2VyaWZcbltcIm1hdGhpdHNmXCIsIFwidGV4dGl0c2ZcIiwgXCJTYW5zU2VyaWYtSXRhbGljXCJdLCAvLyBhLXogaXRhbGljIHNhbnMtc2VyaWZcbltcIlwiLCBcIlwiLCBcIlwiXSwgLy8gQS1aIGJvbGQgaXRhbGljIHNhbnMuIE5vIGZvbnRcbltcIlwiLCBcIlwiLCBcIlwiXSwgLy8gYS16IGJvbGQgaXRhbGljIHNhbnMuIE5vIGZvbnRcbltcIm1hdGh0dFwiLCBcInRleHR0dFwiLCBcIlR5cGV3cml0ZXItUmVndWxhclwiXSwgLy8gQS1aIG1vbm9zcGFjZVxuW1wibWF0aHR0XCIsIFwidGV4dHR0XCIsIFwiVHlwZXdyaXRlci1SZWd1bGFyXCJdIC8vIGEteiBtb25vc3BhY2Vcbl07XG5jb25zdCB3aWRlTnVtZXJhbERhdGEgPSBbW1wibWF0aGJmXCIsIFwidGV4dGJmXCIsIFwiTWFpbi1Cb2xkXCJdLCAvLyAwLTkgYm9sZFxuW1wiXCIsIFwiXCIsIFwiXCJdLCAvLyAwLTkgZG91YmxlLXN0cnVjay4gTm8gS2FUZVggZm9udC5cbltcIm1hdGhzZlwiLCBcInRleHRzZlwiLCBcIlNhbnNTZXJpZi1SZWd1bGFyXCJdLCAvLyAwLTkgc2Fucy1zZXJpZlxuW1wibWF0aGJvbGRzZlwiLCBcInRleHRib2xkc2ZcIiwgXCJTYW5zU2VyaWYtQm9sZFwiXSwgLy8gMC05IGJvbGQgc2Fucy1zZXJpZlxuW1wibWF0aHR0XCIsIFwidGV4dHR0XCIsIFwiVHlwZXdyaXRlci1SZWd1bGFyXCJdIC8vIDAtOSBtb25vc3BhY2Vcbl07XG5jb25zdCB3aWRlQ2hhcmFjdGVyRm9udCA9IGZ1bmN0aW9uICh3aWRlQ2hhciwgbW9kZSkge1xuICAvLyBJRSBkb2Vzbid0IHN1cHBvcnQgY29kZVBvaW50QXQoKS4gU28gd29yayB3aXRoIHRoZSBzdXJyb2dhdGUgcGFpci5cbiAgY29uc3QgSCA9IHdpZGVDaGFyLmNoYXJDb2RlQXQoMCk7IC8vIGhpZ2ggc3Vycm9nYXRlXG5cbiAgY29uc3QgTCA9IHdpZGVDaGFyLmNoYXJDb2RlQXQoMSk7IC8vIGxvdyBzdXJyb2dhdGVcblxuICBjb25zdCBjb2RlUG9pbnQgPSAoSCAtIDB4RDgwMCkgKiAweDQwMCArIChMIC0gMHhEQzAwKSArIDB4MTAwMDA7XG4gIGNvbnN0IGogPSBtb2RlID09PSBcIm1hdGhcIiA/IDAgOiAxOyAvLyBjb2x1bW4gaW5kZXggZm9yIENTUyBjbGFzcy5cblxuICBpZiAoMHgxRDQwMCA8PSBjb2RlUG9pbnQgJiYgY29kZVBvaW50IDwgMHgxRDZBNCkge1xuICAgIC8vIHdpZGVMYXRpbkxldHRlckRhdGEgY29udGFpbnMgZXhhY3RseSAyNiBjaGFycyBvbiBlYWNoIHJvdy5cbiAgICAvLyBTbyB3ZSBjYW4gY2FsY3VsYXRlIHRoZSByZWxldmFudCByb3cuIE5vIHRyYXZlcnNlIG5lY2Vzc2FyeS5cbiAgICBjb25zdCBpID0gTWF0aC5mbG9vcigoY29kZVBvaW50IC0gMHgxRDQwMCkgLyAyNik7XG4gICAgcmV0dXJuIFt3aWRlTGF0aW5MZXR0ZXJEYXRhW2ldWzJdLCB3aWRlTGF0aW5MZXR0ZXJEYXRhW2ldW2pdXTtcbiAgfSBlbHNlIGlmICgweDFEN0NFIDw9IGNvZGVQb2ludCAmJiBjb2RlUG9pbnQgPD0gMHgxRDdGRikge1xuICAgIC8vIE51bWVyYWxzLCB0ZW4gcGVyIHJvdy5cbiAgICBjb25zdCBpID0gTWF0aC5mbG9vcigoY29kZVBvaW50IC0gMHgxRDdDRSkgLyAxMCk7XG4gICAgcmV0dXJuIFt3aWRlTnVtZXJhbERhdGFbaV1bMl0sIHdpZGVOdW1lcmFsRGF0YVtpXVtqXV07XG4gIH0gZWxzZSBpZiAoY29kZVBvaW50ID09PSAweDFENkE1IHx8IGNvZGVQb2ludCA9PT0gMHgxRDZBNikge1xuICAgIC8vIGRvdGxlc3MgaSBvciBqXG4gICAgcmV0dXJuIFt3aWRlTGF0aW5MZXR0ZXJEYXRhWzBdWzJdLCB3aWRlTGF0aW5MZXR0ZXJEYXRhWzBdW2pdXTtcbiAgfSBlbHNlIGlmICgweDFENkE2IDwgY29kZVBvaW50ICYmIGNvZGVQb2ludCA8IDB4MUQ3Q0UpIHtcbiAgICAvLyBHcmVlayBsZXR0ZXJzLiBOb3Qgc3VwcG9ydGVkLCB5ZXQuXG4gICAgcmV0dXJuIFtcIlwiLCBcIlwiXTtcbiAgfSBlbHNlIHtcbiAgICAvLyBXZSBkb24ndCBzdXBwb3J0IGFueSB3aWRlIGNoYXJhY3RlcnMgb3V0c2lkZSAxRDQwMOKAkzFEN0ZGLlxuICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIlVuc3VwcG9ydGVkIGNoYXJhY3RlcjogXCIgKyB3aWRlQ2hhcik7XG4gIH1cbn07XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvYnVpbGRDb21tb24uanNcbi8qIGVzbGludCBuby1jb25zb2xlOjAgKi9cblxuLyoqXG4gKiBUaGlzIG1vZHVsZSBjb250YWlucyBnZW5lcmFsIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSB1c2VkIGZvciBidWlsZGluZ1xuICogZGlmZmVyZW50IGtpbmRzIG9mIGRvbVRyZWUgbm9kZXMgaW4gYSBjb25zaXN0ZW50IG1hbm5lci5cbiAqL1xuXG5cblxuXG5cblxuXG4vKipcbiAqIExvb2tzIHVwIHRoZSBnaXZlbiBzeW1ib2wgaW4gZm9udE1ldHJpY3MsIGFmdGVyIGFwcGx5aW5nIGFueSBzeW1ib2xcbiAqIHJlcGxhY2VtZW50cyBkZWZpbmVkIGluIHN5bWJvbC5qc1xuICovXG5jb25zdCBsb29rdXBTeW1ib2wgPSBmdW5jdGlvbiAodmFsdWUsIC8vIFRPRE8oIzk2Myk6IFVzZSBhIHVuaW9uIHR5cGUgZm9yIHRoaXMuXG5mb250TmFtZSwgbW9kZSkge1xuICAvLyBSZXBsYWNlIHRoZSB2YWx1ZSB3aXRoIGl0cyByZXBsYWNlZCB2YWx1ZSBmcm9tIHN5bWJvbC5qc1xuICBpZiAoc3JjX3N5bWJvbHNbbW9kZV1bdmFsdWVdICYmIHNyY19zeW1ib2xzW21vZGVdW3ZhbHVlXS5yZXBsYWNlKSB7XG4gICAgdmFsdWUgPSBzcmNfc3ltYm9sc1ttb2RlXVt2YWx1ZV0ucmVwbGFjZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIG1ldHJpY3M6IGdldENoYXJhY3Rlck1ldHJpY3ModmFsdWUsIGZvbnROYW1lLCBtb2RlKVxuICB9O1xufTtcbi8qKlxuICogTWFrZXMgYSBzeW1ib2xOb2RlIGFmdGVyIHRyYW5zbGF0aW9uIHZpYSB0aGUgbGlzdCBvZiBzeW1ib2xzIGluIHN5bWJvbHMuanMuXG4gKiBDb3JyZWN0bHkgcHVsbHMgb3V0IG1ldHJpY3MgZm9yIHRoZSBjaGFyYWN0ZXIsIGFuZCBvcHRpb25hbGx5IHRha2VzIGEgbGlzdCBvZlxuICogY2xhc3NlcyB0byBiZSBhdHRhY2hlZCB0byB0aGUgbm9kZS5cbiAqXG4gKiBUT0RPOiBtYWtlIGFyZ3VtZW50IG9yZGVyIGNsb3NlciB0byBtYWtlU3BhblxuICogVE9ETzogYWRkIGEgc2VwYXJhdGUgYXJndW1lbnQgZm9yIG1hdGggY2xhc3MgKGUuZy4gYG1vcGAsIGBtYmluYCksIHdoaWNoXG4gKiBzaG91bGQgaWYgcHJlc2VudCBjb21lIGZpcnN0IGluIGBjbGFzc2VzYC5cbiAqIFRPRE8oIzk1Myk6IE1ha2UgYG9wdGlvbnNgIG1hbmRhdG9yeSBhbmQgYWx3YXlzIHBhc3MgaXQgaW4uXG4gKi9cblxuXG5jb25zdCBtYWtlU3ltYm9sID0gZnVuY3Rpb24gKHZhbHVlLCBmb250TmFtZSwgbW9kZSwgb3B0aW9ucywgY2xhc3Nlcykge1xuICBjb25zdCBsb29rdXAgPSBsb29rdXBTeW1ib2wodmFsdWUsIGZvbnROYW1lLCBtb2RlKTtcbiAgY29uc3QgbWV0cmljcyA9IGxvb2t1cC5tZXRyaWNzO1xuICB2YWx1ZSA9IGxvb2t1cC52YWx1ZTtcbiAgbGV0IHN5bWJvbE5vZGU7XG5cbiAgaWYgKG1ldHJpY3MpIHtcbiAgICBsZXQgaXRhbGljID0gbWV0cmljcy5pdGFsaWM7XG5cbiAgICBpZiAobW9kZSA9PT0gXCJ0ZXh0XCIgfHwgb3B0aW9ucyAmJiBvcHRpb25zLmZvbnQgPT09IFwibWF0aGl0XCIpIHtcbiAgICAgIGl0YWxpYyA9IDA7XG4gICAgfVxuXG4gICAgc3ltYm9sTm9kZSA9IG5ldyBTeW1ib2xOb2RlKHZhbHVlLCBtZXRyaWNzLmhlaWdodCwgbWV0cmljcy5kZXB0aCwgaXRhbGljLCBtZXRyaWNzLnNrZXcsIG1ldHJpY3Mud2lkdGgsIGNsYXNzZXMpO1xuICB9IGVsc2Uge1xuICAgIC8vIFRPRE8oZW1pbHkpOiBGaWd1cmUgb3V0IGEgZ29vZCB3YXkgdG8gb25seSBwcmludCB0aGlzIGluIGRldmVsb3BtZW50XG4gICAgdHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29uc29sZS53YXJuKFwiTm8gY2hhcmFjdGVyIG1ldHJpY3MgXCIgKyAoXCJmb3IgJ1wiICsgdmFsdWUgKyBcIicgaW4gc3R5bGUgJ1wiICsgZm9udE5hbWUgKyBcIicgYW5kIG1vZGUgJ1wiICsgbW9kZSArIFwiJ1wiKSk7XG4gICAgc3ltYm9sTm9kZSA9IG5ldyBTeW1ib2xOb2RlKHZhbHVlLCAwLCAwLCAwLCAwLCAwLCBjbGFzc2VzKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgc3ltYm9sTm9kZS5tYXhGb250U2l6ZSA9IG9wdGlvbnMuc2l6ZU11bHRpcGxpZXI7XG5cbiAgICBpZiAob3B0aW9ucy5zdHlsZS5pc1RpZ2h0KCkpIHtcbiAgICAgIHN5bWJvbE5vZGUuY2xhc3Nlcy5wdXNoKFwibXRpZ2h0XCIpO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbG9yID0gb3B0aW9ucy5nZXRDb2xvcigpO1xuXG4gICAgaWYgKGNvbG9yKSB7XG4gICAgICBzeW1ib2xOb2RlLnN0eWxlLmNvbG9yID0gY29sb3I7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN5bWJvbE5vZGU7XG59O1xuLyoqXG4gKiBNYWtlcyBhIHN5bWJvbCBpbiBNYWluLVJlZ3VsYXIgb3IgQU1TLVJlZ3VsYXIuXG4gKiBVc2VkIGZvciByZWwsIGJpbiwgb3BlbiwgY2xvc2UsIGlubmVyLCBhbmQgcHVuY3QuXG4gKi9cblxuXG5jb25zdCBtYXRoc3ltID0gZnVuY3Rpb24gKHZhbHVlLCBtb2RlLCBvcHRpb25zLCBjbGFzc2VzKSB7XG4gIGlmIChjbGFzc2VzID09PSB2b2lkIDApIHtcbiAgICBjbGFzc2VzID0gW107XG4gIH1cblxuICAvLyBEZWNpZGUgd2hhdCBmb250IHRvIHJlbmRlciB0aGUgc3ltYm9sIGluIGJ5IGl0cyBlbnRyeSBpbiB0aGUgc3ltYm9sc1xuICAvLyB0YWJsZS5cbiAgLy8gSGF2ZSBhIHNwZWNpYWwgY2FzZSBmb3Igd2hlbiB0aGUgdmFsdWUgPSBcXCBiZWNhdXNlIHRoZSBcXCBpcyB1c2VkIGFzIGFcbiAgLy8gdGV4dG9yZCBpbiB1bnN1cHBvcnRlZCBjb21tYW5kIGVycm9ycyBidXQgY2Fubm90IGJlIHBhcnNlZCBhcyBhIHJlZ3VsYXJcbiAgLy8gdGV4dCBvcmRpbmFsIGFuZCBpcyB0aGVyZWZvcmUgbm90IHByZXNlbnQgYXMgYSBzeW1ib2wgaW4gdGhlIHN5bWJvbHNcbiAgLy8gdGFibGUgZm9yIHRleHQsIGFzIHdlbGwgYXMgYSBzcGVjaWFsIGNhc2UgZm9yIGJvbGRzeW1ib2wgYmVjYXVzZSBpdFxuICAvLyBjYW4gYmUgdXNlZCBmb3IgYm9sZCArIGFuZCAtXG4gIGlmIChvcHRpb25zLmZvbnQgPT09IFwiYm9sZHN5bWJvbFwiICYmIGxvb2t1cFN5bWJvbCh2YWx1ZSwgXCJNYWluLUJvbGRcIiwgbW9kZSkubWV0cmljcykge1xuICAgIHJldHVybiBtYWtlU3ltYm9sKHZhbHVlLCBcIk1haW4tQm9sZFwiLCBtb2RlLCBvcHRpb25zLCBjbGFzc2VzLmNvbmNhdChbXCJtYXRoYmZcIl0pKTtcbiAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gXCJcXFxcXCIgfHwgc3JjX3N5bWJvbHNbbW9kZV1bdmFsdWVdLmZvbnQgPT09IFwibWFpblwiKSB7XG4gICAgcmV0dXJuIG1ha2VTeW1ib2wodmFsdWUsIFwiTWFpbi1SZWd1bGFyXCIsIG1vZGUsIG9wdGlvbnMsIGNsYXNzZXMpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBtYWtlU3ltYm9sKHZhbHVlLCBcIkFNUy1SZWd1bGFyXCIsIG1vZGUsIG9wdGlvbnMsIGNsYXNzZXMuY29uY2F0KFtcImFtc3JtXCJdKSk7XG4gIH1cbn07XG4vKipcbiAqIERldGVybWluZXMgd2hpY2ggb2YgdGhlIHR3byBmb250IG5hbWVzIChNYWluLUJvbGQgYW5kIE1hdGgtQm9sZEl0YWxpYykgYW5kXG4gKiBjb3JyZXNwb25kaW5nIHN0eWxlIHRhZ3MgKG1hdGhiZiBvciBib2xkc3ltYm9sKSB0byB1c2UgZm9yIGZvbnQgXCJib2xkc3ltYm9sXCIsXG4gKiBkZXBlbmRpbmcgb24gdGhlIHN5bWJvbC4gIFVzZSB0aGlzIGZ1bmN0aW9uIGluc3RlYWQgb2YgZm9udE1hcCBmb3IgZm9udFxuICogXCJib2xkc3ltYm9sXCIuXG4gKi9cblxuXG5jb25zdCBib2xkc3ltYm9sID0gZnVuY3Rpb24gKHZhbHVlLCBtb2RlLCBvcHRpb25zLCBjbGFzc2VzLCB0eXBlKSB7XG4gIGlmICh0eXBlICE9PSBcInRleHRvcmRcIiAmJiBsb29rdXBTeW1ib2wodmFsdWUsIFwiTWF0aC1Cb2xkSXRhbGljXCIsIG1vZGUpLm1ldHJpY3MpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZm9udE5hbWU6IFwiTWF0aC1Cb2xkSXRhbGljXCIsXG4gICAgICBmb250Q2xhc3M6IFwiYm9sZHN5bWJvbFwiXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBTb21lIGdseXBocyBkbyBub3QgZXhpc3QgaW4gTWF0aC1Cb2xkSXRhbGljIHNvIHdlIG5lZWQgdG8gdXNlXG4gICAgLy8gTWFpbi1Cb2xkIGluc3RlYWQuXG4gICAgcmV0dXJuIHtcbiAgICAgIGZvbnROYW1lOiBcIk1haW4tQm9sZFwiLFxuICAgICAgZm9udENsYXNzOiBcIm1hdGhiZlwiXG4gICAgfTtcbiAgfVxufTtcbi8qKlxuICogTWFrZXMgZWl0aGVyIGEgbWF0aG9yZCBvciB0ZXh0b3JkIGluIHRoZSBjb3JyZWN0IGZvbnQgYW5kIGNvbG9yLlxuICovXG5cblxuY29uc3QgbWFrZU9yZCA9IGZ1bmN0aW9uIChncm91cCwgb3B0aW9ucywgdHlwZSkge1xuICBjb25zdCBtb2RlID0gZ3JvdXAubW9kZTtcbiAgY29uc3QgdGV4dCA9IGdyb3VwLnRleHQ7XG4gIGNvbnN0IGNsYXNzZXMgPSBbXCJtb3JkXCJdOyAvLyBNYXRoIG1vZGUgb3IgT2xkIGZvbnQgKGkuZS4gXFxybSlcblxuICBjb25zdCBpc0ZvbnQgPSBtb2RlID09PSBcIm1hdGhcIiB8fCBtb2RlID09PSBcInRleHRcIiAmJiBvcHRpb25zLmZvbnQ7XG4gIGNvbnN0IGZvbnRPckZhbWlseSA9IGlzRm9udCA/IG9wdGlvbnMuZm9udCA6IG9wdGlvbnMuZm9udEZhbWlseTtcbiAgbGV0IHdpZGVGb250TmFtZSA9IFwiXCI7XG4gIGxldCB3aWRlRm9udENsYXNzID0gXCJcIjtcblxuICBpZiAodGV4dC5jaGFyQ29kZUF0KDApID09PSAweEQ4MzUpIHtcbiAgICBbd2lkZUZvbnROYW1lLCB3aWRlRm9udENsYXNzXSA9IHdpZGVDaGFyYWN0ZXJGb250KHRleHQsIG1vZGUpO1xuICB9XG5cbiAgaWYgKHdpZGVGb250TmFtZS5sZW5ndGggPiAwKSB7XG4gICAgLy8gc3Vycm9nYXRlIHBhaXJzIGdldCBzcGVjaWFsIHRyZWF0bWVudFxuICAgIHJldHVybiBtYWtlU3ltYm9sKHRleHQsIHdpZGVGb250TmFtZSwgbW9kZSwgb3B0aW9ucywgY2xhc3Nlcy5jb25jYXQod2lkZUZvbnRDbGFzcykpO1xuICB9IGVsc2UgaWYgKGZvbnRPckZhbWlseSkge1xuICAgIGxldCBmb250TmFtZTtcbiAgICBsZXQgZm9udENsYXNzZXM7XG5cbiAgICBpZiAoZm9udE9yRmFtaWx5ID09PSBcImJvbGRzeW1ib2xcIikge1xuICAgICAgY29uc3QgZm9udERhdGEgPSBib2xkc3ltYm9sKHRleHQsIG1vZGUsIG9wdGlvbnMsIGNsYXNzZXMsIHR5cGUpO1xuICAgICAgZm9udE5hbWUgPSBmb250RGF0YS5mb250TmFtZTtcbiAgICAgIGZvbnRDbGFzc2VzID0gW2ZvbnREYXRhLmZvbnRDbGFzc107XG4gICAgfSBlbHNlIGlmIChpc0ZvbnQpIHtcbiAgICAgIGZvbnROYW1lID0gZm9udE1hcFtmb250T3JGYW1pbHldLmZvbnROYW1lO1xuICAgICAgZm9udENsYXNzZXMgPSBbZm9udE9yRmFtaWx5XTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9udE5hbWUgPSByZXRyaWV2ZVRleHRGb250TmFtZShmb250T3JGYW1pbHksIG9wdGlvbnMuZm9udFdlaWdodCwgb3B0aW9ucy5mb250U2hhcGUpO1xuICAgICAgZm9udENsYXNzZXMgPSBbZm9udE9yRmFtaWx5LCBvcHRpb25zLmZvbnRXZWlnaHQsIG9wdGlvbnMuZm9udFNoYXBlXTtcbiAgICB9XG5cbiAgICBpZiAobG9va3VwU3ltYm9sKHRleHQsIGZvbnROYW1lLCBtb2RlKS5tZXRyaWNzKSB7XG4gICAgICByZXR1cm4gbWFrZVN5bWJvbCh0ZXh0LCBmb250TmFtZSwgbW9kZSwgb3B0aW9ucywgY2xhc3Nlcy5jb25jYXQoZm9udENsYXNzZXMpKTtcbiAgICB9IGVsc2UgaWYgKGxpZ2F0dXJlcy5oYXNPd25Qcm9wZXJ0eSh0ZXh0KSAmJiBmb250TmFtZS5zbGljZSgwLCAxMCkgPT09IFwiVHlwZXdyaXRlclwiKSB7XG4gICAgICAvLyBEZWNvbnN0cnVjdCBsaWdhdHVyZXMgaW4gbW9ub3NwYWNlIGZvbnRzIChcXHRleHR0dCwgXFx0dCkuXG4gICAgICBjb25zdCBwYXJ0cyA9IFtdO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcGFydHMucHVzaChtYWtlU3ltYm9sKHRleHRbaV0sIGZvbnROYW1lLCBtb2RlLCBvcHRpb25zLCBjbGFzc2VzLmNvbmNhdChmb250Q2xhc3NlcykpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1ha2VGcmFnbWVudChwYXJ0cyk7XG4gICAgfVxuICB9IC8vIE1ha2VzIGEgc3ltYm9sIGluIHRoZSBkZWZhdWx0IGZvbnQgZm9yIG1hdGhvcmRzIGFuZCB0ZXh0b3Jkcy5cblxuXG4gIGlmICh0eXBlID09PSBcIm1hdGhvcmRcIikge1xuICAgIHJldHVybiBtYWtlU3ltYm9sKHRleHQsIFwiTWF0aC1JdGFsaWNcIiwgbW9kZSwgb3B0aW9ucywgY2xhc3Nlcy5jb25jYXQoW1wibWF0aG5vcm1hbFwiXSkpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IFwidGV4dG9yZFwiKSB7XG4gICAgY29uc3QgZm9udCA9IHNyY19zeW1ib2xzW21vZGVdW3RleHRdICYmIHNyY19zeW1ib2xzW21vZGVdW3RleHRdLmZvbnQ7XG5cbiAgICBpZiAoZm9udCA9PT0gXCJhbXNcIikge1xuICAgICAgY29uc3QgZm9udE5hbWUgPSByZXRyaWV2ZVRleHRGb250TmFtZShcImFtc3JtXCIsIG9wdGlvbnMuZm9udFdlaWdodCwgb3B0aW9ucy5mb250U2hhcGUpO1xuICAgICAgcmV0dXJuIG1ha2VTeW1ib2wodGV4dCwgZm9udE5hbWUsIG1vZGUsIG9wdGlvbnMsIGNsYXNzZXMuY29uY2F0KFwiYW1zcm1cIiwgb3B0aW9ucy5mb250V2VpZ2h0LCBvcHRpb25zLmZvbnRTaGFwZSkpO1xuICAgIH0gZWxzZSBpZiAoZm9udCA9PT0gXCJtYWluXCIgfHwgIWZvbnQpIHtcbiAgICAgIGNvbnN0IGZvbnROYW1lID0gcmV0cmlldmVUZXh0Rm9udE5hbWUoXCJ0ZXh0cm1cIiwgb3B0aW9ucy5mb250V2VpZ2h0LCBvcHRpb25zLmZvbnRTaGFwZSk7XG4gICAgICByZXR1cm4gbWFrZVN5bWJvbCh0ZXh0LCBmb250TmFtZSwgbW9kZSwgb3B0aW9ucywgY2xhc3Nlcy5jb25jYXQob3B0aW9ucy5mb250V2VpZ2h0LCBvcHRpb25zLmZvbnRTaGFwZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmb250cyBhZGRlZCBieSBwbHVnaW5zXG4gICAgICBjb25zdCBmb250TmFtZSA9IHJldHJpZXZlVGV4dEZvbnROYW1lKGZvbnQsIG9wdGlvbnMuZm9udFdlaWdodCwgb3B0aW9ucy5mb250U2hhcGUpOyAvLyBXZSBhZGQgZm9udCBuYW1lIGFzIGEgY3NzIGNsYXNzXG5cbiAgICAgIHJldHVybiBtYWtlU3ltYm9sKHRleHQsIGZvbnROYW1lLCBtb2RlLCBvcHRpb25zLCBjbGFzc2VzLmNvbmNhdChmb250TmFtZSwgb3B0aW9ucy5mb250V2VpZ2h0LCBvcHRpb25zLmZvbnRTaGFwZSkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmV4cGVjdGVkIHR5cGU6IFwiICsgdHlwZSArIFwiIGluIG1ha2VPcmRcIik7XG4gIH1cbn07XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBzdWJzZXF1ZW50IHN5bWJvbE5vZGVzIGhhdmUgdGhlIHNhbWUgY2xhc3Nlcywgc2tldywgbWF4Rm9udCxcbiAqIGFuZCBzdHlsZXMuXG4gKi9cblxuXG5jb25zdCBjYW5Db21iaW5lID0gKHByZXYsIG5leHQpID0+IHtcbiAgaWYgKGNyZWF0ZUNsYXNzKHByZXYuY2xhc3NlcykgIT09IGNyZWF0ZUNsYXNzKG5leHQuY2xhc3NlcykgfHwgcHJldi5za2V3ICE9PSBuZXh0LnNrZXcgfHwgcHJldi5tYXhGb250U2l6ZSAhPT0gbmV4dC5tYXhGb250U2l6ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBJZiBwcmV2IGFuZCBuZXh0IGJvdGggYXJlIGp1c3QgXCJtYmluXCJzIG9yIFwibW9yZFwicyB3ZSBkb24ndCBjb21iaW5lIHRoZW1cbiAgLy8gc28gdGhhdCB0aGUgcHJvcGVyIHNwYWNpbmcgY2FuIGJlIHByZXNlcnZlZC5cblxuXG4gIGlmIChwcmV2LmNsYXNzZXMubGVuZ3RoID09PSAxKSB7XG4gICAgY29uc3QgY2xzID0gcHJldi5jbGFzc2VzWzBdO1xuXG4gICAgaWYgKGNscyA9PT0gXCJtYmluXCIgfHwgY2xzID09PSBcIm1vcmRcIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoY29uc3Qgc3R5bGUgaW4gcHJldi5zdHlsZSkge1xuICAgIGlmIChwcmV2LnN0eWxlLmhhc093blByb3BlcnR5KHN0eWxlKSAmJiBwcmV2LnN0eWxlW3N0eWxlXSAhPT0gbmV4dC5zdHlsZVtzdHlsZV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGNvbnN0IHN0eWxlIGluIG5leHQuc3R5bGUpIHtcbiAgICBpZiAobmV4dC5zdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZSkgJiYgcHJldi5zdHlsZVtzdHlsZV0gIT09IG5leHQuc3R5bGVbc3R5bGVdKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG4gKiBDb21iaW5lIGNvbnNlY3V0aXZlIGRvbVRyZWUuc3ltYm9sTm9kZXMgaW50byBhIHNpbmdsZSBzeW1ib2xOb2RlLlxuICogTm90ZTogdGhpcyBmdW5jdGlvbiBtdXRhdGVzIHRoZSBhcmd1bWVudC5cbiAqL1xuXG5cbmNvbnN0IHRyeUNvbWJpbmVDaGFycyA9IGNoYXJzID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICBjb25zdCBwcmV2ID0gY2hhcnNbaV07XG4gICAgY29uc3QgbmV4dCA9IGNoYXJzW2kgKyAxXTtcblxuICAgIGlmIChwcmV2IGluc3RhbmNlb2YgU3ltYm9sTm9kZSAmJiBuZXh0IGluc3RhbmNlb2YgU3ltYm9sTm9kZSAmJiBjYW5Db21iaW5lKHByZXYsIG5leHQpKSB7XG4gICAgICBwcmV2LnRleHQgKz0gbmV4dC50ZXh0O1xuICAgICAgcHJldi5oZWlnaHQgPSBNYXRoLm1heChwcmV2LmhlaWdodCwgbmV4dC5oZWlnaHQpO1xuICAgICAgcHJldi5kZXB0aCA9IE1hdGgubWF4KHByZXYuZGVwdGgsIG5leHQuZGVwdGgpOyAvLyBVc2UgdGhlIGxhc3QgY2hhcmFjdGVyJ3MgaXRhbGljIGNvcnJlY3Rpb24gc2luY2Ugd2UgdXNlXG4gICAgICAvLyBpdCB0byBhZGQgcGFkZGluZyB0byB0aGUgcmlnaHQgb2YgdGhlIHNwYW4gY3JlYXRlZCBmcm9tXG4gICAgICAvLyB0aGUgY29tYmluZWQgY2hhcmFjdGVycy5cblxuICAgICAgcHJldi5pdGFsaWMgPSBuZXh0Lml0YWxpYztcbiAgICAgIGNoYXJzLnNwbGljZShpICsgMSwgMSk7XG4gICAgICBpLS07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNoYXJzO1xufTtcbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBoZWlnaHQsIGRlcHRoLCBhbmQgbWF4Rm9udFNpemUgb2YgYW4gZWxlbWVudCBiYXNlZCBvbiBpdHNcbiAqIGNoaWxkcmVuLlxuICovXG5cblxuY29uc3Qgc2l6ZUVsZW1lbnRGcm9tQ2hpbGRyZW4gPSBmdW5jdGlvbiAoZWxlbSkge1xuICBsZXQgaGVpZ2h0ID0gMDtcbiAgbGV0IGRlcHRoID0gMDtcbiAgbGV0IG1heEZvbnRTaXplID0gMDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW0uY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGlsZCA9IGVsZW0uY2hpbGRyZW5baV07XG5cbiAgICBpZiAoY2hpbGQuaGVpZ2h0ID4gaGVpZ2h0KSB7XG4gICAgICBoZWlnaHQgPSBjaGlsZC5oZWlnaHQ7XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkLmRlcHRoID4gZGVwdGgpIHtcbiAgICAgIGRlcHRoID0gY2hpbGQuZGVwdGg7XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkLm1heEZvbnRTaXplID4gbWF4Rm9udFNpemUpIHtcbiAgICAgIG1heEZvbnRTaXplID0gY2hpbGQubWF4Rm9udFNpemU7XG4gICAgfVxuICB9XG5cbiAgZWxlbS5oZWlnaHQgPSBoZWlnaHQ7XG4gIGVsZW0uZGVwdGggPSBkZXB0aDtcbiAgZWxlbS5tYXhGb250U2l6ZSA9IG1heEZvbnRTaXplO1xufTtcbi8qKlxuICogTWFrZXMgYSBzcGFuIHdpdGggdGhlIGdpdmVuIGxpc3Qgb2YgY2xhc3NlcywgbGlzdCBvZiBjaGlsZHJlbiwgYW5kIG9wdGlvbnMuXG4gKlxuICogVE9ETygjOTUzKTogRW5zdXJlIHRoYXQgYG9wdGlvbnNgIGlzIGFsd2F5cyBwcm92aWRlZCAoY3VycmVudGx5IHNvbWUgY2FsbFxuICogc2l0ZXMgZG9uJ3QgcGFzcyBpdCkgYW5kIG1ha2UgdGhlIHR5cGUgYmVsb3cgbWFuZGF0b3J5LlxuICogVE9ETzogYWRkIGEgc2VwYXJhdGUgYXJndW1lbnQgZm9yIG1hdGggY2xhc3MgKGUuZy4gYG1vcGAsIGBtYmluYCksIHdoaWNoXG4gKiBzaG91bGQgaWYgcHJlc2VudCBjb21lIGZpcnN0IGluIGBjbGFzc2VzYC5cbiAqL1xuXG5cbmNvbnN0IG1ha2VTcGFuID0gZnVuY3Rpb24gKGNsYXNzZXMsIGNoaWxkcmVuLCBvcHRpb25zLCBzdHlsZSkge1xuICBjb25zdCBzcGFuID0gbmV3IFNwYW4oY2xhc3NlcywgY2hpbGRyZW4sIG9wdGlvbnMsIHN0eWxlKTtcbiAgc2l6ZUVsZW1lbnRGcm9tQ2hpbGRyZW4oc3Bhbik7XG4gIHJldHVybiBzcGFuO1xufTsgLy8gU1ZHIG9uZSBpcyBzaW1wbGVyIC0tIGRvZXNuJ3QgcmVxdWlyZSBoZWlnaHQsIGRlcHRoLCBtYXgtZm9udCBzZXR0aW5nLlxuLy8gVGhpcyBpcyBhbHNvIGEgc2VwYXJhdGUgbWV0aG9kIGZvciB0eXBlc2FmZXR5LlxuXG5cbmNvbnN0IG1ha2VTdmdTcGFuID0gKGNsYXNzZXMsIGNoaWxkcmVuLCBvcHRpb25zLCBzdHlsZSkgPT4gbmV3IFNwYW4oY2xhc3NlcywgY2hpbGRyZW4sIG9wdGlvbnMsIHN0eWxlKTtcblxuY29uc3QgbWFrZUxpbmVTcGFuID0gZnVuY3Rpb24gKGNsYXNzTmFtZSwgb3B0aW9ucywgdGhpY2tuZXNzKSB7XG4gIGNvbnN0IGxpbmUgPSBtYWtlU3BhbihbY2xhc3NOYW1lXSwgW10sIG9wdGlvbnMpO1xuICBsaW5lLmhlaWdodCA9IE1hdGgubWF4KHRoaWNrbmVzcyB8fCBvcHRpb25zLmZvbnRNZXRyaWNzKCkuZGVmYXVsdFJ1bGVUaGlja25lc3MsIG9wdGlvbnMubWluUnVsZVRoaWNrbmVzcyk7XG4gIGxpbmUuc3R5bGUuYm9yZGVyQm90dG9tV2lkdGggPSBtYWtlRW0obGluZS5oZWlnaHQpO1xuICBsaW5lLm1heEZvbnRTaXplID0gMS4wO1xuICByZXR1cm4gbGluZTtcbn07XG4vKipcbiAqIE1ha2VzIGFuIGFuY2hvciB3aXRoIHRoZSBnaXZlbiBocmVmLCBsaXN0IG9mIGNsYXNzZXMsIGxpc3Qgb2YgY2hpbGRyZW4sXG4gKiBhbmQgb3B0aW9ucy5cbiAqL1xuXG5cbmNvbnN0IG1ha2VBbmNob3IgPSBmdW5jdGlvbiAoaHJlZiwgY2xhc3NlcywgY2hpbGRyZW4sIG9wdGlvbnMpIHtcbiAgY29uc3QgYW5jaG9yID0gbmV3IEFuY2hvcihocmVmLCBjbGFzc2VzLCBjaGlsZHJlbiwgb3B0aW9ucyk7XG4gIHNpemVFbGVtZW50RnJvbUNoaWxkcmVuKGFuY2hvcik7XG4gIHJldHVybiBhbmNob3I7XG59O1xuLyoqXG4gKiBNYWtlcyBhIGRvY3VtZW50IGZyYWdtZW50IHdpdGggdGhlIGdpdmVuIGxpc3Qgb2YgY2hpbGRyZW4uXG4gKi9cblxuXG5jb25zdCBtYWtlRnJhZ21lbnQgPSBmdW5jdGlvbiAoY2hpbGRyZW4pIHtcbiAgY29uc3QgZnJhZ21lbnQgPSBuZXcgRG9jdW1lbnRGcmFnbWVudChjaGlsZHJlbik7XG4gIHNpemVFbGVtZW50RnJvbUNoaWxkcmVuKGZyYWdtZW50KTtcbiAgcmV0dXJuIGZyYWdtZW50O1xufTtcbi8qKlxuICogV3JhcHMgZ3JvdXAgaW4gYSBzcGFuIGlmIGl0J3MgYSBkb2N1bWVudCBmcmFnbWVudCwgYWxsb3dpbmcgdG8gYXBwbHkgY2xhc3Nlc1xuICogYW5kIHN0eWxlc1xuICovXG5cblxuY29uc3Qgd3JhcEZyYWdtZW50ID0gZnVuY3Rpb24gKGdyb3VwLCBvcHRpb25zKSB7XG4gIGlmIChncm91cCBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpIHtcbiAgICByZXR1cm4gbWFrZVNwYW4oW10sIFtncm91cF0sIG9wdGlvbnMpO1xuICB9XG5cbiAgcmV0dXJuIGdyb3VwO1xufTsgLy8gVGhlc2UgYXJlIGV4YWN0IG9iamVjdCB0eXBlcyB0byBjYXRjaCB0eXBvcyBpbiB0aGUgbmFtZXMgb2YgdGhlIG9wdGlvbmFsIGZpZWxkcy5cblxuXG4vLyBDb21wdXRlcyB0aGUgdXBkYXRlZCBgY2hpbGRyZW5gIGxpc3QgYW5kIHRoZSBvdmVyYWxsIGRlcHRoLlxuLy9cbi8vIFRoaXMgaGVscGVyIGZ1bmN0aW9uIGZvciBtYWtlVkxpc3QgbWFrZXMgaXQgZWFzaWVyIHRvIGVuZm9yY2UgdHlwZSBzYWZldHkgYnlcbi8vIGFsbG93aW5nIGVhcmx5IGV4aXRzIChyZXR1cm5zKSBpbiB0aGUgbG9naWMuXG5jb25zdCBnZXRWTGlzdENoaWxkcmVuQW5kRGVwdGggPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gIGlmIChwYXJhbXMucG9zaXRpb25UeXBlID09PSBcImluZGl2aWR1YWxTaGlmdFwiKSB7XG4gICAgY29uc3Qgb2xkQ2hpbGRyZW4gPSBwYXJhbXMuY2hpbGRyZW47XG4gICAgY29uc3QgY2hpbGRyZW4gPSBbb2xkQ2hpbGRyZW5bMF1dOyAvLyBBZGQgaW4ga2VybnMgdG8gdGhlIGxpc3Qgb2YgcGFyYW1zLmNoaWxkcmVuIHRvIGdldCBlYWNoIGVsZW1lbnQgdG8gYmVcbiAgICAvLyBzaGlmdGVkIHRvIHRoZSBjb3JyZWN0IHNwZWNpZmllZCBzaGlmdFxuXG4gICAgY29uc3QgZGVwdGggPSAtb2xkQ2hpbGRyZW5bMF0uc2hpZnQgLSBvbGRDaGlsZHJlblswXS5lbGVtLmRlcHRoO1xuICAgIGxldCBjdXJyUG9zID0gZGVwdGg7XG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IG9sZENoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBkaWZmID0gLW9sZENoaWxkcmVuW2ldLnNoaWZ0IC0gY3VyclBvcyAtIG9sZENoaWxkcmVuW2ldLmVsZW0uZGVwdGg7XG4gICAgICBjb25zdCBzaXplID0gZGlmZiAtIChvbGRDaGlsZHJlbltpIC0gMV0uZWxlbS5oZWlnaHQgKyBvbGRDaGlsZHJlbltpIC0gMV0uZWxlbS5kZXB0aCk7XG4gICAgICBjdXJyUG9zID0gY3VyclBvcyArIGRpZmY7XG4gICAgICBjaGlsZHJlbi5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJrZXJuXCIsXG4gICAgICAgIHNpemVcbiAgICAgIH0pO1xuICAgICAgY2hpbGRyZW4ucHVzaChvbGRDaGlsZHJlbltpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgZGVwdGhcbiAgICB9O1xuICB9XG5cbiAgbGV0IGRlcHRoO1xuXG4gIGlmIChwYXJhbXMucG9zaXRpb25UeXBlID09PSBcInRvcFwiKSB7XG4gICAgLy8gV2UgYWx3YXlzIHN0YXJ0IGF0IHRoZSBib3R0b20sIHNvIGNhbGN1bGF0ZSB0aGUgYm90dG9tIGJ5IGFkZGluZyB1cFxuICAgIC8vIGFsbCB0aGUgc2l6ZXNcbiAgICBsZXQgYm90dG9tID0gcGFyYW1zLnBvc2l0aW9uRGF0YTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyYW1zLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IHBhcmFtcy5jaGlsZHJlbltpXTtcbiAgICAgIGJvdHRvbSAtPSBjaGlsZC50eXBlID09PSBcImtlcm5cIiA/IGNoaWxkLnNpemUgOiBjaGlsZC5lbGVtLmhlaWdodCArIGNoaWxkLmVsZW0uZGVwdGg7XG4gICAgfVxuXG4gICAgZGVwdGggPSBib3R0b207XG4gIH0gZWxzZSBpZiAocGFyYW1zLnBvc2l0aW9uVHlwZSA9PT0gXCJib3R0b21cIikge1xuICAgIGRlcHRoID0gLXBhcmFtcy5wb3NpdGlvbkRhdGE7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZmlyc3RDaGlsZCA9IHBhcmFtcy5jaGlsZHJlblswXTtcblxuICAgIGlmIChmaXJzdENoaWxkLnR5cGUgIT09IFwiZWxlbVwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpcnN0IGNoaWxkIG11c3QgaGF2ZSB0eXBlIFwiZWxlbVwiLicpO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMucG9zaXRpb25UeXBlID09PSBcInNoaWZ0XCIpIHtcbiAgICAgIGRlcHRoID0gLWZpcnN0Q2hpbGQuZWxlbS5kZXB0aCAtIHBhcmFtcy5wb3NpdGlvbkRhdGE7XG4gICAgfSBlbHNlIGlmIChwYXJhbXMucG9zaXRpb25UeXBlID09PSBcImZpcnN0QmFzZWxpbmVcIikge1xuICAgICAgZGVwdGggPSAtZmlyc3RDaGlsZC5lbGVtLmRlcHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHBvc2l0aW9uVHlwZSBcIiArIHBhcmFtcy5wb3NpdGlvblR5cGUgKyBcIi5cIik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjaGlsZHJlbjogcGFyYW1zLmNoaWxkcmVuLFxuICAgIGRlcHRoXG4gIH07XG59O1xuLyoqXG4gKiBNYWtlcyBhIHZlcnRpY2FsIGxpc3QgYnkgc3RhY2tpbmcgZWxlbWVudHMgYW5kIGtlcm5zIG9uIHRvcCBvZiBlYWNoIG90aGVyLlxuICogQWxsb3dzIGZvciBtYW55IGRpZmZlcmVudCB3YXlzIG9mIHNwZWNpZnlpbmcgdGhlIHBvc2l0aW9uaW5nIG1ldGhvZC5cbiAqXG4gKiBTZWUgVkxpc3RQYXJhbSBkb2N1bWVudGF0aW9uIGFib3ZlLlxuICovXG5cblxuY29uc3QgbWFrZVZMaXN0ID0gZnVuY3Rpb24gKHBhcmFtcywgb3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgY2hpbGRyZW4sXG4gICAgZGVwdGhcbiAgfSA9IGdldFZMaXN0Q2hpbGRyZW5BbmREZXB0aChwYXJhbXMpOyAvLyBDcmVhdGUgYSBzdHJ1dCB0aGF0IGlzIHRhbGxlciB0aGFuIGFueSBsaXN0IGl0ZW0uIFRoZSBzdHJ1dCBpcyBhZGRlZCB0b1xuICAvLyBlYWNoIGl0ZW0sIHdoZXJlIGl0IHdpbGwgZGV0ZXJtaW5lIHRoZSBpdGVtJ3MgYmFzZWxpbmUuIFNpbmNlIGl0IGhhc1xuICAvLyBgb3ZlcmZsb3c6aGlkZGVuYCwgdGhlIHN0cnV0J3MgdG9wIGVkZ2Ugd2lsbCBzaXQgb24gdGhlIGl0ZW0ncyBsaW5lIGJveCdzXG4gIC8vIHRvcCBlZGdlIGFuZCB0aGUgc3RydXQncyBib3R0b20gZWRnZSB3aWxsIHNpdCBvbiB0aGUgaXRlbSdzIGJhc2VsaW5lLFxuICAvLyB3aXRoIG5vIGFkZGl0aW9uYWwgbGluZS1oZWlnaHQgc3BhY2luZy4gVGhpcyBhbGxvd3MgdGhlIGl0ZW0gYmFzZWxpbmUgdG9cbiAgLy8gYmUgcG9zaXRpb25lZCBwcmVjaXNlbHkgd2l0aG91dCB3b3JyeWluZyBhYm91dCBmb250IGFzY2VudCBhbmRcbiAgLy8gbGluZS1oZWlnaHQuXG5cbiAgbGV0IHBzdHJ1dFNpemUgPSAwO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXG4gICAgaWYgKGNoaWxkLnR5cGUgPT09IFwiZWxlbVwiKSB7XG4gICAgICBjb25zdCBlbGVtID0gY2hpbGQuZWxlbTtcbiAgICAgIHBzdHJ1dFNpemUgPSBNYXRoLm1heChwc3RydXRTaXplLCBlbGVtLm1heEZvbnRTaXplLCBlbGVtLmhlaWdodCk7XG4gICAgfVxuICB9XG5cbiAgcHN0cnV0U2l6ZSArPSAyO1xuICBjb25zdCBwc3RydXQgPSBtYWtlU3BhbihbXCJwc3RydXRcIl0sIFtdKTtcbiAgcHN0cnV0LnN0eWxlLmhlaWdodCA9IG1ha2VFbShwc3RydXRTaXplKTsgLy8gQ3JlYXRlIGEgbmV3IGxpc3Qgb2YgYWN0dWFsIGNoaWxkcmVuIGF0IHRoZSBjb3JyZWN0IG9mZnNldHNcblxuICBjb25zdCByZWFsQ2hpbGRyZW4gPSBbXTtcbiAgbGV0IG1pblBvcyA9IGRlcHRoO1xuICBsZXQgbWF4UG9zID0gZGVwdGg7XG4gIGxldCBjdXJyUG9zID0gZGVwdGg7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG5cbiAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJrZXJuXCIpIHtcbiAgICAgIGN1cnJQb3MgKz0gY2hpbGQuc2l6ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZWxlbSA9IGNoaWxkLmVsZW07XG4gICAgICBjb25zdCBjbGFzc2VzID0gY2hpbGQud3JhcHBlckNsYXNzZXMgfHwgW107XG4gICAgICBjb25zdCBzdHlsZSA9IGNoaWxkLndyYXBwZXJTdHlsZSB8fCB7fTtcbiAgICAgIGNvbnN0IGNoaWxkV3JhcCA9IG1ha2VTcGFuKGNsYXNzZXMsIFtwc3RydXQsIGVsZW1dLCB1bmRlZmluZWQsIHN0eWxlKTtcbiAgICAgIGNoaWxkV3JhcC5zdHlsZS50b3AgPSBtYWtlRW0oLXBzdHJ1dFNpemUgLSBjdXJyUG9zIC0gZWxlbS5kZXB0aCk7XG5cbiAgICAgIGlmIChjaGlsZC5tYXJnaW5MZWZ0KSB7XG4gICAgICAgIGNoaWxkV3JhcC5zdHlsZS5tYXJnaW5MZWZ0ID0gY2hpbGQubWFyZ2luTGVmdDtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoaWxkLm1hcmdpblJpZ2h0KSB7XG4gICAgICAgIGNoaWxkV3JhcC5zdHlsZS5tYXJnaW5SaWdodCA9IGNoaWxkLm1hcmdpblJpZ2h0O1xuICAgICAgfVxuXG4gICAgICByZWFsQ2hpbGRyZW4ucHVzaChjaGlsZFdyYXApO1xuICAgICAgY3VyclBvcyArPSBlbGVtLmhlaWdodCArIGVsZW0uZGVwdGg7XG4gICAgfVxuXG4gICAgbWluUG9zID0gTWF0aC5taW4obWluUG9zLCBjdXJyUG9zKTtcbiAgICBtYXhQb3MgPSBNYXRoLm1heChtYXhQb3MsIGN1cnJQb3MpO1xuICB9IC8vIFRoZSB2bGlzdCBjb250ZW50cyBnbyBpbiBhIHRhYmxlLWNlbGwgd2l0aCBgdmVydGljYWwtYWxpZ246Ym90dG9tYC5cbiAgLy8gVGhpcyBjZWxsJ3MgYm90dG9tIGVkZ2Ugd2lsbCBkZXRlcm1pbmUgdGhlIGNvbnRhaW5pbmcgdGFibGUncyBiYXNlbGluZVxuICAvLyB3aXRob3V0IG92ZXJseSBleHBhbmRpbmcgdGhlIGNvbnRhaW5pbmcgbGluZS1ib3guXG5cblxuICBjb25zdCB2bGlzdCA9IG1ha2VTcGFuKFtcInZsaXN0XCJdLCByZWFsQ2hpbGRyZW4pO1xuICB2bGlzdC5zdHlsZS5oZWlnaHQgPSBtYWtlRW0obWF4UG9zKTsgLy8gQSBzZWNvbmQgcm93IGlzIHVzZWQgaWYgbmVjZXNzYXJ5IHRvIHJlcHJlc2VudCB0aGUgdmxpc3QncyBkZXB0aC5cblxuICBsZXQgcm93cztcblxuICBpZiAobWluUG9zIDwgMCkge1xuICAgIC8vIFdlIHdpbGwgZGVmaW5lIGRlcHRoIGluIGFuIGVtcHR5IHNwYW4gd2l0aCBkaXNwbGF5OiB0YWJsZS1jZWxsLlxuICAgIC8vIEl0IHNob3VsZCByZW5kZXIgd2l0aCB0aGUgaGVpZ2h0IHRoYXQgd2UgZGVmaW5lLiBCdXQgQ2hyb21lLCBpblxuICAgIC8vIGNvbnRlbnRlZGl0YWJsZSBtb2RlIG9ubHksIHRyZWF0cyB0aGF0IHNwYW4gYXMgaWYgaXQgY29udGFpbnMgc29tZVxuICAgIC8vIHRleHQgY29udGVudC4gQW5kIHRoYXQgbWluLWhlaWdodCBvdmVyLXJpZGVzIG91ciBkZXNpcmVkIGhlaWdodC5cbiAgICAvLyBTbyB3ZSBwdXQgYW5vdGhlciBlbXB0eSBzcGFuIGluc2lkZSB0aGUgZGVwdGggc3RydXQgc3Bhbi5cbiAgICBjb25zdCBlbXB0eVNwYW4gPSBtYWtlU3BhbihbXSwgW10pO1xuICAgIGNvbnN0IGRlcHRoU3RydXQgPSBtYWtlU3BhbihbXCJ2bGlzdFwiXSwgW2VtcHR5U3Bhbl0pO1xuICAgIGRlcHRoU3RydXQuc3R5bGUuaGVpZ2h0ID0gbWFrZUVtKC1taW5Qb3MpOyAvLyBTYWZhcmkgd2FudHMgdGhlIGZpcnN0IHJvdyB0byBoYXZlIGlubGluZSBjb250ZW50OyBvdGhlcndpc2UgaXRcbiAgICAvLyBwdXRzIHRoZSBib3R0b20gb2YgdGhlICpzZWNvbmQqIHJvdyBvbiB0aGUgYmFzZWxpbmUuXG5cbiAgICBjb25zdCB0b3BTdHJ1dCA9IG1ha2VTcGFuKFtcInZsaXN0LXNcIl0sIFtuZXcgU3ltYm9sTm9kZShcIlxcdTIwMGJcIildKTtcbiAgICByb3dzID0gW21ha2VTcGFuKFtcInZsaXN0LXJcIl0sIFt2bGlzdCwgdG9wU3RydXRdKSwgbWFrZVNwYW4oW1widmxpc3QtclwiXSwgW2RlcHRoU3RydXRdKV07XG4gIH0gZWxzZSB7XG4gICAgcm93cyA9IFttYWtlU3BhbihbXCJ2bGlzdC1yXCJdLCBbdmxpc3RdKV07XG4gIH1cblxuICBjb25zdCB2dGFibGUgPSBtYWtlU3BhbihbXCJ2bGlzdC10XCJdLCByb3dzKTtcblxuICBpZiAocm93cy5sZW5ndGggPT09IDIpIHtcbiAgICB2dGFibGUuY2xhc3Nlcy5wdXNoKFwidmxpc3QtdDJcIik7XG4gIH1cblxuICB2dGFibGUuaGVpZ2h0ID0gbWF4UG9zO1xuICB2dGFibGUuZGVwdGggPSAtbWluUG9zO1xuICByZXR1cm4gdnRhYmxlO1xufTsgLy8gR2x1ZSBpcyBhIGNvbmNlcHQgZnJvbSBUZVggd2hpY2ggaXMgYSBmbGV4aWJsZSBzcGFjZSBiZXR3ZWVuIGVsZW1lbnRzIGluXG4vLyBlaXRoZXIgYSB2ZXJ0aWNhbCBvciBob3Jpem9udGFsIGxpc3QuIEluIEthVGVYLCBhdCBsZWFzdCBmb3Igbm93LCBpdCdzXG4vLyBzdGF0aWMgc3BhY2UgYmV0d2VlbiBlbGVtZW50cyBpbiBhIGhvcml6b250YWwgbGF5b3V0LlxuXG5cbmNvbnN0IG1ha2VHbHVlID0gKG1lYXN1cmVtZW50LCBvcHRpb25zKSA9PiB7XG4gIC8vIE1ha2UgYW4gZW1wdHkgc3BhbiBmb3IgdGhlIHNwYWNlXG4gIGNvbnN0IHJ1bGUgPSBtYWtlU3BhbihbXCJtc3BhY2VcIl0sIFtdLCBvcHRpb25zKTtcbiAgY29uc3Qgc2l6ZSA9IGNhbGN1bGF0ZVNpemUobWVhc3VyZW1lbnQsIG9wdGlvbnMpO1xuICBydWxlLnN0eWxlLm1hcmdpblJpZ2h0ID0gbWFrZUVtKHNpemUpO1xuICByZXR1cm4gcnVsZTtcbn07IC8vIFRha2VzIGZvbnQgb3B0aW9ucywgYW5kIHJldHVybnMgdGhlIGFwcHJvcHJpYXRlIGZvbnRMb29rdXAgbmFtZVxuXG5cbmNvbnN0IHJldHJpZXZlVGV4dEZvbnROYW1lID0gZnVuY3Rpb24gKGZvbnRGYW1pbHksIGZvbnRXZWlnaHQsIGZvbnRTaGFwZSkge1xuICBsZXQgYmFzZUZvbnROYW1lID0gXCJcIjtcblxuICBzd2l0Y2ggKGZvbnRGYW1pbHkpIHtcbiAgICBjYXNlIFwiYW1zcm1cIjpcbiAgICAgIGJhc2VGb250TmFtZSA9IFwiQU1TXCI7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJ0ZXh0cm1cIjpcbiAgICAgIGJhc2VGb250TmFtZSA9IFwiTWFpblwiO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwidGV4dHNmXCI6XG4gICAgICBiYXNlRm9udE5hbWUgPSBcIlNhbnNTZXJpZlwiO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwidGV4dHR0XCI6XG4gICAgICBiYXNlRm9udE5hbWUgPSBcIlR5cGV3cml0ZXJcIjtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGJhc2VGb250TmFtZSA9IGZvbnRGYW1pbHk7XG4gICAgLy8gdXNlIGZvbnRzIGFkZGVkIGJ5IGEgcGx1Z2luXG4gIH1cblxuICBsZXQgZm9udFN0eWxlc05hbWU7XG5cbiAgaWYgKGZvbnRXZWlnaHQgPT09IFwidGV4dGJmXCIgJiYgZm9udFNoYXBlID09PSBcInRleHRpdFwiKSB7XG4gICAgZm9udFN0eWxlc05hbWUgPSBcIkJvbGRJdGFsaWNcIjtcbiAgfSBlbHNlIGlmIChmb250V2VpZ2h0ID09PSBcInRleHRiZlwiKSB7XG4gICAgZm9udFN0eWxlc05hbWUgPSBcIkJvbGRcIjtcbiAgfSBlbHNlIGlmIChmb250V2VpZ2h0ID09PSBcInRleHRpdFwiKSB7XG4gICAgZm9udFN0eWxlc05hbWUgPSBcIkl0YWxpY1wiO1xuICB9IGVsc2Uge1xuICAgIGZvbnRTdHlsZXNOYW1lID0gXCJSZWd1bGFyXCI7XG4gIH1cblxuICByZXR1cm4gYmFzZUZvbnROYW1lICsgXCItXCIgKyBmb250U3R5bGVzTmFtZTtcbn07XG4vKipcbiAqIE1hcHMgVGVYIGZvbnQgY29tbWFuZHMgdG8gb2JqZWN0cyBjb250YWluaW5nOlxuICogLSB2YXJpYW50OiBzdHJpbmcgdXNlZCBmb3IgXCJtYXRodmFyaWFudFwiIGF0dHJpYnV0ZSBpbiBidWlsZE1hdGhNTC5qc1xuICogLSBmb250TmFtZTogdGhlIFwic3R5bGVcIiBwYXJhbWV0ZXIgdG8gZm9udE1ldHJpY3MuZ2V0Q2hhcmFjdGVyTWV0cmljc1xuICovXG4vLyBBIG1hcCBiZXR3ZWVuIHRleCBmb250IGNvbW1hbmRzIGFuIE1hdGhNTCBtYXRodmFyaWFudCBhdHRyaWJ1dGUgdmFsdWVzXG5cblxuY29uc3QgZm9udE1hcCA9IHtcbiAgLy8gc3R5bGVzXG4gIFwibWF0aGJmXCI6IHtcbiAgICB2YXJpYW50OiBcImJvbGRcIixcbiAgICBmb250TmFtZTogXCJNYWluLUJvbGRcIlxuICB9LFxuICBcIm1hdGhybVwiOiB7XG4gICAgdmFyaWFudDogXCJub3JtYWxcIixcbiAgICBmb250TmFtZTogXCJNYWluLVJlZ3VsYXJcIlxuICB9LFxuICBcInRleHRpdFwiOiB7XG4gICAgdmFyaWFudDogXCJpdGFsaWNcIixcbiAgICBmb250TmFtZTogXCJNYWluLUl0YWxpY1wiXG4gIH0sXG4gIFwibWF0aGl0XCI6IHtcbiAgICB2YXJpYW50OiBcIml0YWxpY1wiLFxuICAgIGZvbnROYW1lOiBcIk1haW4tSXRhbGljXCJcbiAgfSxcbiAgXCJtYXRobm9ybWFsXCI6IHtcbiAgICB2YXJpYW50OiBcIml0YWxpY1wiLFxuICAgIGZvbnROYW1lOiBcIk1hdGgtSXRhbGljXCJcbiAgfSxcbiAgLy8gXCJib2xkc3ltYm9sXCIgaXMgbWlzc2luZyBiZWNhdXNlIHRoZXkgcmVxdWlyZSB0aGUgdXNlIG9mIG11bHRpcGxlIGZvbnRzOlxuICAvLyBNYXRoLUJvbGRJdGFsaWMgYW5kIE1haW4tQm9sZC4gIFRoaXMgaXMgaGFuZGxlZCBieSBhIHNwZWNpYWwgY2FzZSBpblxuICAvLyBtYWtlT3JkIHdoaWNoIGVuZHMgdXAgY2FsbGluZyBib2xkc3ltYm9sLlxuICAvLyBmYW1pbGllc1xuICBcIm1hdGhiYlwiOiB7XG4gICAgdmFyaWFudDogXCJkb3VibGUtc3RydWNrXCIsXG4gICAgZm9udE5hbWU6IFwiQU1TLVJlZ3VsYXJcIlxuICB9LFxuICBcIm1hdGhjYWxcIjoge1xuICAgIHZhcmlhbnQ6IFwic2NyaXB0XCIsXG4gICAgZm9udE5hbWU6IFwiQ2FsaWdyYXBoaWMtUmVndWxhclwiXG4gIH0sXG4gIFwibWF0aGZyYWtcIjoge1xuICAgIHZhcmlhbnQ6IFwiZnJha3R1clwiLFxuICAgIGZvbnROYW1lOiBcIkZyYWt0dXItUmVndWxhclwiXG4gIH0sXG4gIFwibWF0aHNjclwiOiB7XG4gICAgdmFyaWFudDogXCJzY3JpcHRcIixcbiAgICBmb250TmFtZTogXCJTY3JpcHQtUmVndWxhclwiXG4gIH0sXG4gIFwibWF0aHNmXCI6IHtcbiAgICB2YXJpYW50OiBcInNhbnMtc2VyaWZcIixcbiAgICBmb250TmFtZTogXCJTYW5zU2VyaWYtUmVndWxhclwiXG4gIH0sXG4gIFwibWF0aHR0XCI6IHtcbiAgICB2YXJpYW50OiBcIm1vbm9zcGFjZVwiLFxuICAgIGZvbnROYW1lOiBcIlR5cGV3cml0ZXItUmVndWxhclwiXG4gIH1cbn07XG5jb25zdCBzdmdEYXRhID0ge1xuICAvLyAgIHBhdGgsIHdpZHRoLCBoZWlnaHRcbiAgdmVjOiBbXCJ2ZWNcIiwgMC40NzEsIDAuNzE0XSxcbiAgLy8gdmFsdWVzIGZyb20gdGhlIGZvbnQgZ2x5cGhcbiAgb2lpbnRTaXplMTogW1wib2lpbnRTaXplMVwiLCAwLjk1NywgMC40OTldLFxuICAvLyBvdmFsIHRvIG92ZXJsYXkgdGhlIGludGVncmFuZFxuICBvaWludFNpemUyOiBbXCJvaWludFNpemUyXCIsIDEuNDcyLCAwLjY1OV0sXG4gIG9paWludFNpemUxOiBbXCJvaWlpbnRTaXplMVwiLCAxLjMwNCwgMC40OTldLFxuICBvaWlpbnRTaXplMjogW1wib2lpaW50U2l6ZTJcIiwgMS45OCwgMC42NTldXG59O1xuXG5jb25zdCBzdGF0aWNTdmcgPSBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcbiAgLy8gQ3JlYXRlIGEgc3BhbiB3aXRoIGlubGluZSBTVkcgZm9yIHRoZSBlbGVtZW50LlxuICBjb25zdCBbcGF0aE5hbWUsIHdpZHRoLCBoZWlnaHRdID0gc3ZnRGF0YVt2YWx1ZV07XG4gIGNvbnN0IHBhdGggPSBuZXcgUGF0aE5vZGUocGF0aE5hbWUpO1xuICBjb25zdCBzdmdOb2RlID0gbmV3IFN2Z05vZGUoW3BhdGhdLCB7XG4gICAgXCJ3aWR0aFwiOiBtYWtlRW0od2lkdGgpLFxuICAgIFwiaGVpZ2h0XCI6IG1ha2VFbShoZWlnaHQpLFxuICAgIC8vIE92ZXJyaWRlIENTUyBydWxlIGAua2F0ZXggc3ZnIHsgd2lkdGg6IDEwMCUgfWBcbiAgICBcInN0eWxlXCI6IFwid2lkdGg6XCIgKyBtYWtlRW0od2lkdGgpLFxuICAgIFwidmlld0JveFwiOiBcIjAgMCBcIiArIDEwMDAgKiB3aWR0aCArIFwiIFwiICsgMTAwMCAqIGhlaWdodCxcbiAgICBcInByZXNlcnZlQXNwZWN0UmF0aW9cIjogXCJ4TWluWU1pblwiXG4gIH0pO1xuICBjb25zdCBzcGFuID0gbWFrZVN2Z1NwYW4oW1wib3ZlcmxheVwiXSwgW3N2Z05vZGVdLCBvcHRpb25zKTtcbiAgc3Bhbi5oZWlnaHQgPSBoZWlnaHQ7XG4gIHNwYW4uc3R5bGUuaGVpZ2h0ID0gbWFrZUVtKGhlaWdodCk7XG4gIHNwYW4uc3R5bGUud2lkdGggPSBtYWtlRW0od2lkdGgpO1xuICByZXR1cm4gc3Bhbjtcbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGJ1aWxkQ29tbW9uID0gKHtcbiAgZm9udE1hcCxcbiAgbWFrZVN5bWJvbCxcbiAgbWF0aHN5bSxcbiAgbWFrZVNwYW4sXG4gIG1ha2VTdmdTcGFuLFxuICBtYWtlTGluZVNwYW4sXG4gIG1ha2VBbmNob3IsXG4gIG1ha2VGcmFnbWVudCxcbiAgd3JhcEZyYWdtZW50LFxuICBtYWtlVkxpc3QsXG4gIG1ha2VPcmQsXG4gIG1ha2VHbHVlLFxuICBzdGF0aWNTdmcsXG4gIHN2Z0RhdGEsXG4gIHRyeUNvbWJpbmVDaGFyc1xufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvc3BhY2luZ0RhdGEuanNcbi8qKlxuICogRGVzY3JpYmVzIHNwYWNlcyBiZXR3ZWVuIGRpZmZlcmVudCBjbGFzc2VzIG9mIGF0b21zLlxuICovXG5jb25zdCB0aGluc3BhY2UgPSB7XG4gIG51bWJlcjogMyxcbiAgdW5pdDogXCJtdVwiXG59O1xuY29uc3QgbWVkaXVtc3BhY2UgPSB7XG4gIG51bWJlcjogNCxcbiAgdW5pdDogXCJtdVwiXG59O1xuY29uc3QgdGhpY2tzcGFjZSA9IHtcbiAgbnVtYmVyOiA1LFxuICB1bml0OiBcIm11XCJcbn07IC8vIE1ha2luZyB0aGUgdHlwZSBiZWxvdyBleGFjdCB3aXRoIGFsbCBvcHRpb25hbCBmaWVsZHMgZG9lc24ndCB3b3JrIGR1ZSB0b1xuLy8gLSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvNDU4MlxuLy8gLSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvNTY4OFxuLy8gSG93ZXZlciwgc2luY2UgKmFsbCogZmllbGRzIGFyZSBvcHRpb25hbCwgJFNoYXBlPD4gd29ya3MgYXMgc3VnZ2VzdGVkIGluIDU2ODhcbi8vIGFib3ZlLlxuXG4vLyBTcGFjaW5nIHJlbGF0aW9uc2hpcHMgZm9yIGRpc3BsYXkgYW5kIHRleHQgc3R5bGVzXG5jb25zdCBzcGFjaW5ncyA9IHtcbiAgbW9yZDoge1xuICAgIG1vcDogdGhpbnNwYWNlLFxuICAgIG1iaW46IG1lZGl1bXNwYWNlLFxuICAgIG1yZWw6IHRoaWNrc3BhY2UsXG4gICAgbWlubmVyOiB0aGluc3BhY2VcbiAgfSxcbiAgbW9wOiB7XG4gICAgbW9yZDogdGhpbnNwYWNlLFxuICAgIG1vcDogdGhpbnNwYWNlLFxuICAgIG1yZWw6IHRoaWNrc3BhY2UsXG4gICAgbWlubmVyOiB0aGluc3BhY2VcbiAgfSxcbiAgbWJpbjoge1xuICAgIG1vcmQ6IG1lZGl1bXNwYWNlLFxuICAgIG1vcDogbWVkaXVtc3BhY2UsXG4gICAgbW9wZW46IG1lZGl1bXNwYWNlLFxuICAgIG1pbm5lcjogbWVkaXVtc3BhY2VcbiAgfSxcbiAgbXJlbDoge1xuICAgIG1vcmQ6IHRoaWNrc3BhY2UsXG4gICAgbW9wOiB0aGlja3NwYWNlLFxuICAgIG1vcGVuOiB0aGlja3NwYWNlLFxuICAgIG1pbm5lcjogdGhpY2tzcGFjZVxuICB9LFxuICBtb3Blbjoge30sXG4gIG1jbG9zZToge1xuICAgIG1vcDogdGhpbnNwYWNlLFxuICAgIG1iaW46IG1lZGl1bXNwYWNlLFxuICAgIG1yZWw6IHRoaWNrc3BhY2UsXG4gICAgbWlubmVyOiB0aGluc3BhY2VcbiAgfSxcbiAgbXB1bmN0OiB7XG4gICAgbW9yZDogdGhpbnNwYWNlLFxuICAgIG1vcDogdGhpbnNwYWNlLFxuICAgIG1yZWw6IHRoaWNrc3BhY2UsXG4gICAgbW9wZW46IHRoaW5zcGFjZSxcbiAgICBtY2xvc2U6IHRoaW5zcGFjZSxcbiAgICBtcHVuY3Q6IHRoaW5zcGFjZSxcbiAgICBtaW5uZXI6IHRoaW5zcGFjZVxuICB9LFxuICBtaW5uZXI6IHtcbiAgICBtb3JkOiB0aGluc3BhY2UsXG4gICAgbW9wOiB0aGluc3BhY2UsXG4gICAgbWJpbjogbWVkaXVtc3BhY2UsXG4gICAgbXJlbDogdGhpY2tzcGFjZSxcbiAgICBtb3BlbjogdGhpbnNwYWNlLFxuICAgIG1wdW5jdDogdGhpbnNwYWNlLFxuICAgIG1pbm5lcjogdGhpbnNwYWNlXG4gIH1cbn07IC8vIFNwYWNpbmcgcmVsYXRpb25zaGlwcyBmb3Igc2NyaXB0IGFuZCBzY3JpcHRzY3JpcHQgc3R5bGVzXG5cbmNvbnN0IHRpZ2h0U3BhY2luZ3MgPSB7XG4gIG1vcmQ6IHtcbiAgICBtb3A6IHRoaW5zcGFjZVxuICB9LFxuICBtb3A6IHtcbiAgICBtb3JkOiB0aGluc3BhY2UsXG4gICAgbW9wOiB0aGluc3BhY2VcbiAgfSxcbiAgbWJpbjoge30sXG4gIG1yZWw6IHt9LFxuICBtb3Blbjoge30sXG4gIG1jbG9zZToge1xuICAgIG1vcDogdGhpbnNwYWNlXG4gIH0sXG4gIG1wdW5jdDoge30sXG4gIG1pbm5lcjoge1xuICAgIG1vcDogdGhpbnNwYWNlXG4gIH1cbn07XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZGVmaW5lRnVuY3Rpb24uanNcbi8qKiBDb250ZXh0IHByb3ZpZGVkIHRvIGZ1bmN0aW9uIGhhbmRsZXJzIGZvciBlcnJvciBtZXNzYWdlcy4gKi9cbi8vIE5vdGU6IHJldmVyc2UgdGhlIG9yZGVyIG9mIHRoZSByZXR1cm4gdHlwZSB1bmlvbiB3aWxsIGNhdXNlIGEgZmxvdyBlcnJvci5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMzY2My5cbi8vIE1vcmUgZ2VuZXJhbCB2ZXJzaW9uIG9mIGBIdG1sQnVpbGRlcmAgZm9yIG5vZGVzIChlLmcuIFxcc3VtLCBhY2NlbnQgdHlwZXMpXG4vLyB3aG9zZSBwcmVzZW5jZSBpbXBhY3RzIHN1cGVyL3N1YnNjcmlwdGluZy4gSW4gdGhpcyBjYXNlLCBQYXJzZU5vZGU8XCJzdXBzdWJcIj5cbi8vIGRlbGVnYXRlcyBpdHMgSFRNTCBidWlsZGluZyB0byB0aGUgSHRtbEJ1aWxkZXIgY29ycmVzcG9uZGluZyB0byB0aGVzZSBub2Rlcy5cblxuLyoqXG4gKiBGaW5hbCBmdW5jdGlvbiBzcGVjIGZvciB1c2UgYXQgcGFyc2UgdGltZS5cbiAqIFRoaXMgaXMgYWxtb3N0IGlkZW50aWNhbCB0byBgRnVuY3Rpb25Qcm9wU3BlY2AsIGV4Y2VwdCBpdFxuICogMS4gaW5jbHVkZXMgdGhlIGZ1bmN0aW9uIGhhbmRsZXIsIGFuZFxuICogMi4gcmVxdWlyZXMgYWxsIGFyZ3VtZW50cyBleGNlcHQgYXJnVHlwZXMuXG4gKiBJdCBpcyBnZW5lcmF0ZWQgYnkgYGRlZmluZUZ1bmN0aW9uKClgIGJlbG93LlxuICovXG5cbi8qKlxuICogQWxsIHJlZ2lzdGVyZWQgZnVuY3Rpb25zLlxuICogYGZ1bmN0aW9ucy5qc2AganVzdCBleHBvcnRzIHRoaXMgc2FtZSBkaWN0aW9uYXJ5IGFnYWluIGFuZCBtYWtlcyBpdCBwdWJsaWMuXG4gKiBgUGFyc2VyLmpzYCByZXF1aXJlcyB0aGlzIGRpY3Rpb25hcnkuXG4gKi9cbmNvbnN0IF9mdW5jdGlvbnMgPSB7fTtcbi8qKlxuICogQWxsIEhUTUwgYnVpbGRlcnMuIFNob3VsZCBiZSBvbmx5IHVzZWQgaW4gdGhlIGBkZWZpbmUqYCBhbmQgdGhlIGBidWlsZCpNTGBcbiAqIGZ1bmN0aW9ucy5cbiAqL1xuXG5jb25zdCBfaHRtbEdyb3VwQnVpbGRlcnMgPSB7fTtcbi8qKlxuICogQWxsIE1hdGhNTCBidWlsZGVycy4gU2hvdWxkIGJlIG9ubHkgdXNlZCBpbiB0aGUgYGRlZmluZSpgIGFuZCB0aGUgYGJ1aWxkKk1MYFxuICogZnVuY3Rpb25zLlxuICovXG5cbmNvbnN0IF9tYXRobWxHcm91cEJ1aWxkZXJzID0ge307XG5mdW5jdGlvbiBkZWZpbmVGdW5jdGlvbihfcmVmKSB7XG4gIGxldCB7XG4gICAgdHlwZSxcbiAgICBuYW1lcyxcbiAgICBwcm9wcyxcbiAgICBoYW5kbGVyLFxuICAgIGh0bWxCdWlsZGVyLFxuICAgIG1hdGhtbEJ1aWxkZXJcbiAgfSA9IF9yZWY7XG4gIC8vIFNldCBkZWZhdWx0IHZhbHVlcyBvZiBmdW5jdGlvbnNcbiAgY29uc3QgZGF0YSA9IHtcbiAgICB0eXBlLFxuICAgIG51bUFyZ3M6IHByb3BzLm51bUFyZ3MsXG4gICAgYXJnVHlwZXM6IHByb3BzLmFyZ1R5cGVzLFxuICAgIGFsbG93ZWRJbkFyZ3VtZW50OiAhIXByb3BzLmFsbG93ZWRJbkFyZ3VtZW50LFxuICAgIGFsbG93ZWRJblRleHQ6ICEhcHJvcHMuYWxsb3dlZEluVGV4dCxcbiAgICBhbGxvd2VkSW5NYXRoOiBwcm9wcy5hbGxvd2VkSW5NYXRoID09PSB1bmRlZmluZWQgPyB0cnVlIDogcHJvcHMuYWxsb3dlZEluTWF0aCxcbiAgICBudW1PcHRpb25hbEFyZ3M6IHByb3BzLm51bU9wdGlvbmFsQXJncyB8fCAwLFxuICAgIGluZml4OiAhIXByb3BzLmluZml4LFxuICAgIHByaW1pdGl2ZTogISFwcm9wcy5wcmltaXRpdmUsXG4gICAgaGFuZGxlcjogaGFuZGxlclxuICB9O1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICBfZnVuY3Rpb25zW25hbWVzW2ldXSA9IGRhdGE7XG4gIH1cblxuICBpZiAodHlwZSkge1xuICAgIGlmIChodG1sQnVpbGRlcikge1xuICAgICAgX2h0bWxHcm91cEJ1aWxkZXJzW3R5cGVdID0gaHRtbEJ1aWxkZXI7XG4gICAgfVxuXG4gICAgaWYgKG1hdGhtbEJ1aWxkZXIpIHtcbiAgICAgIF9tYXRobWxHcm91cEJ1aWxkZXJzW3R5cGVdID0gbWF0aG1sQnVpbGRlcjtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogVXNlIHRoaXMgdG8gcmVnaXN0ZXIgb25seSB0aGUgSFRNTCBhbmQgTWF0aE1MIGJ1aWxkZXJzIGZvciBhIGZ1bmN0aW9uIChlLmcuXG4gKiBpZiB0aGUgZnVuY3Rpb24ncyBQYXJzZU5vZGUgaXMgZ2VuZXJhdGVkIGluIFBhcnNlci5qcyByYXRoZXIgdGhhbiB2aWEgYVxuICogc3RhbmQtYWxvbmUgaGFuZGxlciBwcm92aWRlZCB0byBgZGVmaW5lRnVuY3Rpb25gKS5cbiAqL1xuXG5mdW5jdGlvbiBkZWZpbmVGdW5jdGlvbkJ1aWxkZXJzKF9yZWYyKSB7XG4gIGxldCB7XG4gICAgdHlwZSxcbiAgICBodG1sQnVpbGRlcixcbiAgICBtYXRobWxCdWlsZGVyXG4gIH0gPSBfcmVmMjtcbiAgZGVmaW5lRnVuY3Rpb24oe1xuICAgIHR5cGUsXG4gICAgbmFtZXM6IFtdLFxuICAgIHByb3BzOiB7XG4gICAgICBudW1BcmdzOiAwXG4gICAgfSxcblxuICAgIGhhbmRsZXIoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Nob3VsZCBuZXZlciBiZSBjYWxsZWQuJyk7XG4gICAgfSxcblxuICAgIGh0bWxCdWlsZGVyLFxuICAgIG1hdGhtbEJ1aWxkZXJcbiAgfSk7XG59XG5jb25zdCBub3JtYWxpemVBcmd1bWVudCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgcmV0dXJuIGFyZy50eXBlID09PSBcIm9yZGdyb3VwXCIgJiYgYXJnLmJvZHkubGVuZ3RoID09PSAxID8gYXJnLmJvZHlbMF0gOiBhcmc7XG59OyAvLyBTaW5jZSB0aGUgY29ycmVzcG9uZGluZyBidWlsZEhUTUwvYnVpbGRNYXRoTUwgZnVuY3Rpb24gZXhwZWN0cyBhXG4vLyBsaXN0IG9mIGVsZW1lbnRzLCB3ZSBub3JtYWxpemUgZm9yIGRpZmZlcmVudCBraW5kcyBvZiBhcmd1bWVudHNcblxuY29uc3Qgb3JkYXJndW1lbnQgPSBmdW5jdGlvbiAoYXJnKSB7XG4gIHJldHVybiBhcmcudHlwZSA9PT0gXCJvcmRncm91cFwiID8gYXJnLmJvZHkgOiBbYXJnXTtcbn07XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvYnVpbGRIVE1MLmpzXG4vKipcbiAqIFRoaXMgZmlsZSBkb2VzIHRoZSBtYWluIHdvcmsgb2YgYnVpbGRpbmcgYSBkb21UcmVlIHN0cnVjdHVyZSBmcm9tIGEgcGFyc2VcbiAqIHRyZWUuIFRoZSBlbnRyeSBwb2ludCBpcyB0aGUgYGJ1aWxkSFRNTGAgZnVuY3Rpb24sIHdoaWNoIHRha2VzIGEgcGFyc2UgdHJlZS5cbiAqIFRoZW4sIHRoZSBidWlsZEV4cHJlc3Npb24sIGJ1aWxkR3JvdXAsIGFuZCB2YXJpb3VzIGdyb3VwQnVpbGRlcnMgZnVuY3Rpb25zXG4gKiBhcmUgY2FsbGVkLCB0byBwcm9kdWNlIGEgZmluYWwgSFRNTCB0cmVlLlxuICovXG5cblxuXG5cblxuXG5cblxuXG5jb25zdCBidWlsZEhUTUxfbWFrZVNwYW4gPSBidWlsZENvbW1vbi5tYWtlU3BhbjsgLy8gQmluYXJ5IGF0b21zIChmaXJzdCBjbGFzcyBgbWJpbmApIGNoYW5nZSBpbnRvIG9yZGluYXJ5IGF0b21zIChgbW9yZGApXG4vLyBkZXBlbmRpbmcgb24gdGhlaXIgc3Vycm91bmRpbmdzLiBTZWUgVGVYYm9vayBwZy4gNDQyLTQ0NiwgUnVsZXMgNSBhbmQgNixcbi8vIGFuZCB0aGUgdGV4dCBiZWZvcmUgUnVsZSAxOS5cblxuY29uc3QgYmluTGVmdENhbmNlbGxlciA9IFtcImxlZnRtb3N0XCIsIFwibWJpblwiLCBcIm1vcGVuXCIsIFwibXJlbFwiLCBcIm1vcFwiLCBcIm1wdW5jdFwiXTtcbmNvbnN0IGJpblJpZ2h0Q2FuY2VsbGVyID0gW1wicmlnaHRtb3N0XCIsIFwibXJlbFwiLCBcIm1jbG9zZVwiLCBcIm1wdW5jdFwiXTtcbmNvbnN0IHN0eWxlTWFwID0ge1xuICBcImRpc3BsYXlcIjogc3JjX1N0eWxlLkRJU1BMQVksXG4gIFwidGV4dFwiOiBzcmNfU3R5bGUuVEVYVCxcbiAgXCJzY3JpcHRcIjogc3JjX1N0eWxlLlNDUklQVCxcbiAgXCJzY3JpcHRzY3JpcHRcIjogc3JjX1N0eWxlLlNDUklQVFNDUklQVFxufTtcbmNvbnN0IERvbUVudW0gPSB7XG4gIG1vcmQ6IFwibW9yZFwiLFxuICBtb3A6IFwibW9wXCIsXG4gIG1iaW46IFwibWJpblwiLFxuICBtcmVsOiBcIm1yZWxcIixcbiAgbW9wZW46IFwibW9wZW5cIixcbiAgbWNsb3NlOiBcIm1jbG9zZVwiLFxuICBtcHVuY3Q6IFwibXB1bmN0XCIsXG4gIG1pbm5lcjogXCJtaW5uZXJcIlxufTtcblxuLyoqXG4gKiBUYWtlIGEgbGlzdCBvZiBub2RlcywgYnVpbGQgdGhlbSBpbiBvcmRlciwgYW5kIHJldHVybiBhIGxpc3Qgb2YgdGhlIGJ1aWx0XG4gKiBub2Rlcy4gZG9jdW1lbnRGcmFnbWVudHMgYXJlIGZsYXR0ZW5lZCBpbnRvIHRoZWlyIGNvbnRlbnRzLCBzbyB0aGVcbiAqIHJldHVybmVkIGxpc3QgY29udGFpbnMgbm8gZnJhZ21lbnRzLiBgaXNSZWFsR3JvdXBgIGlzIHRydWUgaWYgYGV4cHJlc3Npb25gXG4gKiBpcyBhIHJlYWwgZ3JvdXAgKG5vIGF0b21zIHdpbGwgYmUgYWRkZWQgb24gZWl0aGVyIHNpZGUpLCBhcyBvcHBvc2VkIHRvXG4gKiBhIHBhcnRpYWwgZ3JvdXAgKGUuZy4gb25lIGNyZWF0ZWQgYnkgXFxjb2xvcikuIGBzdXJyb3VuZGluZ2AgaXMgYW4gYXJyYXlcbiAqIGNvbnNpc3RpbmcgdHlwZSBvZiBub2RlcyB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIGxlZnQgYW5kIHJpZ2h0LlxuICovXG5jb25zdCBidWlsZEV4cHJlc3Npb24gPSBmdW5jdGlvbiAoZXhwcmVzc2lvbiwgb3B0aW9ucywgaXNSZWFsR3JvdXAsIHN1cnJvdW5kaW5nKSB7XG4gIGlmIChzdXJyb3VuZGluZyA9PT0gdm9pZCAwKSB7XG4gICAgc3Vycm91bmRpbmcgPSBbbnVsbCwgbnVsbF07XG4gIH1cblxuICAvLyBQYXJzZSBleHByZXNzaW9ucyBpbnRvIGBncm91cHNgLlxuICBjb25zdCBncm91cHMgPSBbXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGV4cHJlc3Npb24ubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBvdXRwdXQgPSBidWlsZEdyb3VwKGV4cHJlc3Npb25baV0sIG9wdGlvbnMpO1xuXG4gICAgaWYgKG91dHB1dCBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpIHtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gb3V0cHV0LmNoaWxkcmVuO1xuICAgICAgZ3JvdXBzLnB1c2goLi4uY2hpbGRyZW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBncm91cHMucHVzaChvdXRwdXQpO1xuICAgIH1cbiAgfSAvLyBDb21iaW5lIGNvbnNlY3V0aXZlIGRvbVRyZWUuc3ltYm9sTm9kZXMgaW50byBhIHNpbmdsZSBzeW1ib2xOb2RlLlxuXG5cbiAgYnVpbGRDb21tb24udHJ5Q29tYmluZUNoYXJzKGdyb3Vwcyk7IC8vIElmIGBleHByZXNzaW9uYCBpcyBhIHBhcnRpYWwgZ3JvdXAsIGxldCB0aGUgcGFyZW50IGhhbmRsZSBzcGFjaW5nc1xuICAvLyB0byBhdm9pZCBwcm9jZXNzaW5nIGdyb3VwcyBtdWx0aXBsZSB0aW1lcy5cblxuICBpZiAoIWlzUmVhbEdyb3VwKSB7XG4gICAgcmV0dXJuIGdyb3VwcztcbiAgfVxuXG4gIGxldCBnbHVlT3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgaWYgKGV4cHJlc3Npb24ubGVuZ3RoID09PSAxKSB7XG4gICAgY29uc3Qgbm9kZSA9IGV4cHJlc3Npb25bMF07XG5cbiAgICBpZiAobm9kZS50eXBlID09PSBcInNpemluZ1wiKSB7XG4gICAgICBnbHVlT3B0aW9ucyA9IG9wdGlvbnMuaGF2aW5nU2l6ZShub2RlLnNpemUpO1xuICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSBcInN0eWxpbmdcIikge1xuICAgICAgZ2x1ZU9wdGlvbnMgPSBvcHRpb25zLmhhdmluZ1N0eWxlKHN0eWxlTWFwW25vZGUuc3R5bGVdKTtcbiAgICB9XG4gIH0gLy8gRHVtbXkgc3BhbnMgZm9yIGRldGVybWluaW5nIHNwYWNpbmdzIGJldHdlZW4gc3Vycm91bmRpbmcgYXRvbXMuXG4gIC8vIElmIGBleHByZXNzaW9uYCBoYXMgbm8gYXRvbXMgb24gdGhlIGxlZnQgb3IgcmlnaHQsIGNsYXNzIFwibGVmdG1vc3RcIlxuICAvLyBvciBcInJpZ2h0bW9zdFwiLCByZXNwZWN0aXZlbHksIGlzIHVzZWQgdG8gaW5kaWNhdGUgaXQuXG5cblxuICBjb25zdCBkdW1teVByZXYgPSBidWlsZEhUTUxfbWFrZVNwYW4oW3N1cnJvdW5kaW5nWzBdIHx8IFwibGVmdG1vc3RcIl0sIFtdLCBvcHRpb25zKTtcbiAgY29uc3QgZHVtbXlOZXh0ID0gYnVpbGRIVE1MX21ha2VTcGFuKFtzdXJyb3VuZGluZ1sxXSB8fCBcInJpZ2h0bW9zdFwiXSwgW10sIG9wdGlvbnMpOyAvLyBUT0RPOiBUaGVzZSBjb2RlIGFzc3VtZXMgdGhhdCBhIG5vZGUncyBtYXRoIGNsYXNzIGlzIHRoZSBmaXJzdCBlbGVtZW50XG4gIC8vIG9mIGl0cyBgY2xhc3Nlc2AgYXJyYXkuIEEgbGF0ZXIgY2xlYW51cCBzaG91bGQgZW5zdXJlIHRoaXMsIGZvclxuICAvLyBpbnN0YW5jZSBieSBjaGFuZ2luZyB0aGUgc2lnbmF0dXJlIG9mIGBtYWtlU3BhbmAuXG4gIC8vIEJlZm9yZSBkZXRlcm1pbmluZyB3aGF0IHNwYWNlcyB0byBpbnNlcnQsIHBlcmZvcm0gYmluIGNhbmNlbGxhdGlvbi5cbiAgLy8gQmluYXJ5IG9wZXJhdG9ycyBjaGFuZ2UgdG8gb3JkaW5hcnkgc3ltYm9scyBpbiBzb21lIGNvbnRleHRzLlxuXG4gIGNvbnN0IGlzUm9vdCA9IGlzUmVhbEdyb3VwID09PSBcInJvb3RcIjtcbiAgdHJhdmVyc2VOb25TcGFjZU5vZGVzKGdyb3VwcywgKG5vZGUsIHByZXYpID0+IHtcbiAgICBjb25zdCBwcmV2VHlwZSA9IHByZXYuY2xhc3Nlc1swXTtcbiAgICBjb25zdCB0eXBlID0gbm9kZS5jbGFzc2VzWzBdO1xuXG4gICAgaWYgKHByZXZUeXBlID09PSBcIm1iaW5cIiAmJiB1dGlscy5jb250YWlucyhiaW5SaWdodENhbmNlbGxlciwgdHlwZSkpIHtcbiAgICAgIHByZXYuY2xhc3Nlc1swXSA9IFwibW9yZFwiO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJtYmluXCIgJiYgdXRpbHMuY29udGFpbnMoYmluTGVmdENhbmNlbGxlciwgcHJldlR5cGUpKSB7XG4gICAgICBub2RlLmNsYXNzZXNbMF0gPSBcIm1vcmRcIjtcbiAgICB9XG4gIH0sIHtcbiAgICBub2RlOiBkdW1teVByZXZcbiAgfSwgZHVtbXlOZXh0LCBpc1Jvb3QpO1xuICB0cmF2ZXJzZU5vblNwYWNlTm9kZXMoZ3JvdXBzLCAobm9kZSwgcHJldikgPT4ge1xuICAgIGNvbnN0IHByZXZUeXBlID0gZ2V0VHlwZU9mRG9tVHJlZShwcmV2KTtcbiAgICBjb25zdCB0eXBlID0gZ2V0VHlwZU9mRG9tVHJlZShub2RlKTsgLy8gJ210aWdodCcgaW5kaWNhdGVzIHRoYXQgdGhlIG5vZGUgaXMgc2NyaXB0IG9yIHNjcmlwdHNjcmlwdCBzdHlsZS5cblxuICAgIGNvbnN0IHNwYWNlID0gcHJldlR5cGUgJiYgdHlwZSA/IG5vZGUuaGFzQ2xhc3MoXCJtdGlnaHRcIikgPyB0aWdodFNwYWNpbmdzW3ByZXZUeXBlXVt0eXBlXSA6IHNwYWNpbmdzW3ByZXZUeXBlXVt0eXBlXSA6IG51bGw7XG5cbiAgICBpZiAoc3BhY2UpIHtcbiAgICAgIC8vIEluc2VydCBnbHVlIChzcGFjaW5nKSBhZnRlciB0aGUgYHByZXZgLlxuICAgICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VHbHVlKHNwYWNlLCBnbHVlT3B0aW9ucyk7XG4gICAgfVxuICB9LCB7XG4gICAgbm9kZTogZHVtbXlQcmV2XG4gIH0sIGR1bW15TmV4dCwgaXNSb290KTtcbiAgcmV0dXJuIGdyb3Vwcztcbn07IC8vIERlcHRoLWZpcnN0IHRyYXZlcnNlIG5vbi1zcGFjZSBgbm9kZXNgLCBjYWxsaW5nIGBjYWxsYmFja2Agd2l0aCB0aGUgY3VycmVudCBhbmRcbi8vIHByZXZpb3VzIG5vZGUgYXMgYXJndW1lbnRzLCBvcHRpb25hbGx5IHJldHVybmluZyBhIG5vZGUgdG8gaW5zZXJ0IGFmdGVyIHRoZVxuLy8gcHJldmlvdXMgbm9kZS4gYHByZXZgIGlzIGFuIG9iamVjdCB3aXRoIHRoZSBwcmV2aW91cyBub2RlIGFuZCBgaW5zZXJ0QWZ0ZXJgXG4vLyBmdW5jdGlvbiB0byBpbnNlcnQgYWZ0ZXIgaXQuIGBuZXh0YCBpcyBhIG5vZGUgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSByaWdodC5cbi8vIFVzZWQgZm9yIGJpbiBjYW5jZWxsYXRpb24gYW5kIGluc2VydGluZyBzcGFjaW5ncy5cblxuY29uc3QgdHJhdmVyc2VOb25TcGFjZU5vZGVzID0gZnVuY3Rpb24gKG5vZGVzLCBjYWxsYmFjaywgcHJldiwgbmV4dCwgaXNSb290KSB7XG4gIGlmIChuZXh0KSB7XG4gICAgLy8gdGVtcG9yYXJpbHkgYXBwZW5kIHRoZSByaWdodCBub2RlLCBpZiBleGlzdHNcbiAgICBub2Rlcy5wdXNoKG5leHQpO1xuICB9XG5cbiAgbGV0IGkgPSAwO1xuXG4gIGZvciAoOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgY29uc3QgcGFydGlhbEdyb3VwID0gY2hlY2tQYXJ0aWFsR3JvdXAobm9kZSk7XG5cbiAgICBpZiAocGFydGlhbEdyb3VwKSB7XG4gICAgICAvLyBSZWN1cnNpdmUgREZTXG4gICAgICAvLyAkRmxvd0ZpeE1lOiBtYWtlIG5vZGVzIGEgJFJlYWRPbmx5QXJyYXkgYnkgcmV0dXJuaW5nIGEgbmV3IGFycmF5XG4gICAgICB0cmF2ZXJzZU5vblNwYWNlTm9kZXMocGFydGlhbEdyb3VwLmNoaWxkcmVuLCBjYWxsYmFjaywgcHJldiwgbnVsbCwgaXNSb290KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gLy8gSWdub3JlIGV4cGxpY2l0IHNwYWNlcyAoZS5nLiwgXFw7LCBcXCwpIHdoZW4gZGV0ZXJtaW5pbmcgd2hhdCBpbXBsaWNpdFxuICAgIC8vIHNwYWNpbmcgc2hvdWxkIGdvIGJldHdlZW4gYXRvbXMgb2YgZGlmZmVyZW50IGNsYXNzZXNcblxuXG4gICAgY29uc3Qgbm9uc3BhY2UgPSAhbm9kZS5oYXNDbGFzcyhcIm1zcGFjZVwiKTtcblxuICAgIGlmIChub25zcGFjZSkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gY2FsbGJhY2sobm9kZSwgcHJldi5ub2RlKTtcblxuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICBpZiAocHJldi5pbnNlcnRBZnRlcikge1xuICAgICAgICAgIHByZXYuaW5zZXJ0QWZ0ZXIocmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpbnNlcnQgYXQgZnJvbnRcbiAgICAgICAgICBub2Rlcy51bnNoaWZ0KHJlc3VsdCk7XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5vbnNwYWNlKSB7XG4gICAgICBwcmV2Lm5vZGUgPSBub2RlO1xuICAgIH0gZWxzZSBpZiAoaXNSb290ICYmIG5vZGUuaGFzQ2xhc3MoXCJuZXdsaW5lXCIpKSB7XG4gICAgICBwcmV2Lm5vZGUgPSBidWlsZEhUTUxfbWFrZVNwYW4oW1wibGVmdG1vc3RcIl0pOyAvLyB0cmVhdCBsaWtlIGJlZ2lubmluZyBvZiBsaW5lXG4gICAgfVxuXG4gICAgcHJldi5pbnNlcnRBZnRlciA9IChpbmRleCA9PiBuID0+IHtcbiAgICAgIG5vZGVzLnNwbGljZShpbmRleCArIDEsIDAsIG4pO1xuICAgICAgaSsrO1xuICAgIH0pKGkpO1xuICB9XG5cbiAgaWYgKG5leHQpIHtcbiAgICBub2Rlcy5wb3AoKTtcbiAgfVxufTsgLy8gQ2hlY2sgaWYgZ2l2ZW4gbm9kZSBpcyBhIHBhcnRpYWwgZ3JvdXAsIGkuZS4sIGRvZXMgbm90IGFmZmVjdCBzcGFjaW5nIGFyb3VuZC5cblxuXG5jb25zdCBjaGVja1BhcnRpYWxHcm91cCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmIChub2RlIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCB8fCBub2RlIGluc3RhbmNlb2YgQW5jaG9yIHx8IG5vZGUgaW5zdGFuY2VvZiBTcGFuICYmIG5vZGUuaGFzQ2xhc3MoXCJlbmNsb3NpbmdcIikpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTsgLy8gUmV0dXJuIHRoZSBvdXRlcm1vc3Qgbm9kZSBvZiBhIGRvbVRyZWUuXG5cblxuY29uc3QgZ2V0T3V0ZXJtb3N0Tm9kZSA9IGZ1bmN0aW9uIChub2RlLCBzaWRlKSB7XG4gIGNvbnN0IHBhcnRpYWxHcm91cCA9IGNoZWNrUGFydGlhbEdyb3VwKG5vZGUpO1xuXG4gIGlmIChwYXJ0aWFsR3JvdXApIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHBhcnRpYWxHcm91cC5jaGlsZHJlbjtcblxuICAgIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIGlmIChzaWRlID09PSBcInJpZ2h0XCIpIHtcbiAgICAgICAgcmV0dXJuIGdldE91dGVybW9zdE5vZGUoY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0sIFwicmlnaHRcIik7XG4gICAgICB9IGVsc2UgaWYgKHNpZGUgPT09IFwibGVmdFwiKSB7XG4gICAgICAgIHJldHVybiBnZXRPdXRlcm1vc3ROb2RlKGNoaWxkcmVuWzBdLCBcImxlZnRcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59OyAvLyBSZXR1cm4gbWF0aCBhdG9tIGNsYXNzIChtY2xhc3MpIG9mIGEgZG9tVHJlZS5cbi8vIElmIGBzaWRlYCBpcyBnaXZlbiwgaXQgd2lsbCBnZXQgdGhlIHR5cGUgb2YgdGhlIG91dGVybW9zdCBub2RlIGF0IGdpdmVuIHNpZGUuXG5cblxuY29uc3QgZ2V0VHlwZU9mRG9tVHJlZSA9IGZ1bmN0aW9uIChub2RlLCBzaWRlKSB7XG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHNpZGUpIHtcbiAgICBub2RlID0gZ2V0T3V0ZXJtb3N0Tm9kZShub2RlLCBzaWRlKTtcbiAgfSAvLyBUaGlzIG1ha2VzIGEgbG90IG9mIGFzc3VtcHRpb25zIGFzIHRvIHdoZXJlIHRoZSB0eXBlIG9mIGF0b21cbiAgLy8gYXBwZWFycy4gIFdlIHNob3VsZCBkbyBhIGJldHRlciBqb2Igb2YgZW5mb3JjaW5nIHRoaXMuXG5cblxuICByZXR1cm4gRG9tRW51bVtub2RlLmNsYXNzZXNbMF1dIHx8IG51bGw7XG59O1xuY29uc3QgbWFrZU51bGxEZWxpbWl0ZXIgPSBmdW5jdGlvbiAob3B0aW9ucywgY2xhc3Nlcykge1xuICBjb25zdCBtb3JlQ2xhc3NlcyA9IFtcIm51bGxkZWxpbWl0ZXJcIl0uY29uY2F0KG9wdGlvbnMuYmFzZVNpemluZ0NsYXNzZXMoKSk7XG4gIHJldHVybiBidWlsZEhUTUxfbWFrZVNwYW4oY2xhc3Nlcy5jb25jYXQobW9yZUNsYXNzZXMpKTtcbn07XG4vKipcbiAqIGJ1aWxkR3JvdXAgaXMgdGhlIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBncm91cCBhbmQgY2FsbHMgdGhlIGNvcnJlY3QgZ3JvdXBUeXBlXG4gKiBmdW5jdGlvbiBmb3IgaXQuIEl0IGFsc28gaGFuZGxlcyB0aGUgaW50ZXJhY3Rpb24gb2Ygc2l6ZSBhbmQgc3R5bGUgY2hhbmdlc1xuICogYmV0d2VlbiBwYXJlbnRzIGFuZCBjaGlsZHJlbi5cbiAqL1xuXG5jb25zdCBidWlsZEdyb3VwID0gZnVuY3Rpb24gKGdyb3VwLCBvcHRpb25zLCBiYXNlT3B0aW9ucykge1xuICBpZiAoIWdyb3VwKSB7XG4gICAgcmV0dXJuIGJ1aWxkSFRNTF9tYWtlU3BhbigpO1xuICB9XG5cbiAgaWYgKF9odG1sR3JvdXBCdWlsZGVyc1tncm91cC50eXBlXSkge1xuICAgIC8vIENhbGwgdGhlIGdyb3VwQnVpbGRlcnMgZnVuY3Rpb25cbiAgICAvLyAkRmxvd0ZpeE1lXG4gICAgbGV0IGdyb3VwTm9kZSA9IF9odG1sR3JvdXBCdWlsZGVyc1tncm91cC50eXBlXShncm91cCwgb3B0aW9ucyk7IC8vIElmIHRoZSBzaXplIGNoYW5nZWQgYmV0d2VlbiB0aGUgcGFyZW50IGFuZCB0aGUgY3VycmVudCBncm91cCwgYWNjb3VudFxuICAgIC8vIGZvciB0aGF0IHNpemUgZGlmZmVyZW5jZS5cblxuICAgIGlmIChiYXNlT3B0aW9ucyAmJiBvcHRpb25zLnNpemUgIT09IGJhc2VPcHRpb25zLnNpemUpIHtcbiAgICAgIGdyb3VwTm9kZSA9IGJ1aWxkSFRNTF9tYWtlU3BhbihvcHRpb25zLnNpemluZ0NsYXNzZXMoYmFzZU9wdGlvbnMpLCBbZ3JvdXBOb2RlXSwgb3B0aW9ucyk7XG4gICAgICBjb25zdCBtdWx0aXBsaWVyID0gb3B0aW9ucy5zaXplTXVsdGlwbGllciAvIGJhc2VPcHRpb25zLnNpemVNdWx0aXBsaWVyO1xuICAgICAgZ3JvdXBOb2RlLmhlaWdodCAqPSBtdWx0aXBsaWVyO1xuICAgICAgZ3JvdXBOb2RlLmRlcHRoICo9IG11bHRpcGxpZXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdyb3VwTm9kZTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJHb3QgZ3JvdXAgb2YgdW5rbm93biB0eXBlOiAnXCIgKyBncm91cC50eXBlICsgXCInXCIpO1xuICB9XG59O1xuLyoqXG4gKiBDb21iaW5lIGFuIGFycmF5IG9mIEhUTUwgRE9NIG5vZGVzIChlLmcuLCB0aGUgb3V0cHV0IG9mIGBidWlsZEV4cHJlc3Npb25gKVxuICogaW50byBhbiB1bmJyZWFrYWJsZSBIVE1MIG5vZGUgb2YgY2xhc3MgLmJhc2UsIHdpdGggcHJvcGVyIHN0cnV0cyB0b1xuICogZ3VhcmFudGVlIGNvcnJlY3QgdmVydGljYWwgZXh0ZW50LiAgYGJ1aWxkSFRNTGAgY2FsbHMgdGhpcyByZXBlYXRlZGx5IHRvXG4gKiBtYWtlIHVwIHRoZSBlbnRpcmUgZXhwcmVzc2lvbiBhcyBhIHNlcXVlbmNlIG9mIHVuYnJlYWthYmxlIHVuaXRzLlxuICovXG5cbmZ1bmN0aW9uIGJ1aWxkSFRNTFVuYnJlYWthYmxlKGNoaWxkcmVuLCBvcHRpb25zKSB7XG4gIC8vIENvbXB1dGUgaGVpZ2h0IGFuZCBkZXB0aCBvZiB0aGlzIGNodW5rLlxuICBjb25zdCBib2R5ID0gYnVpbGRIVE1MX21ha2VTcGFuKFtcImJhc2VcIl0sIGNoaWxkcmVuLCBvcHRpb25zKTsgLy8gQWRkIHN0cnV0LCB3aGljaCBlbnN1cmVzIHRoYXQgdGhlIHRvcCBvZiB0aGUgSFRNTCBlbGVtZW50IGZhbGxzIGF0XG4gIC8vIHRoZSBoZWlnaHQgb2YgdGhlIGV4cHJlc3Npb24sIGFuZCB0aGUgYm90dG9tIG9mIHRoZSBIVE1MIGVsZW1lbnRcbiAgLy8gZmFsbHMgYXQgdGhlIGRlcHRoIG9mIHRoZSBleHByZXNzaW9uLlxuXG4gIGNvbnN0IHN0cnV0ID0gYnVpbGRIVE1MX21ha2VTcGFuKFtcInN0cnV0XCJdKTtcbiAgc3RydXQuc3R5bGUuaGVpZ2h0ID0gbWFrZUVtKGJvZHkuaGVpZ2h0ICsgYm9keS5kZXB0aCk7XG5cbiAgaWYgKGJvZHkuZGVwdGgpIHtcbiAgICBzdHJ1dC5zdHlsZS52ZXJ0aWNhbEFsaWduID0gbWFrZUVtKC1ib2R5LmRlcHRoKTtcbiAgfVxuXG4gIGJvZHkuY2hpbGRyZW4udW5zaGlmdChzdHJ1dCk7XG4gIHJldHVybiBib2R5O1xufVxuLyoqXG4gKiBUYWtlIGFuIGVudGlyZSBwYXJzZSB0cmVlLCBhbmQgYnVpbGQgaXQgaW50byBhbiBhcHByb3ByaWF0ZSBzZXQgb2YgSFRNTFxuICogbm9kZXMuXG4gKi9cblxuXG5mdW5jdGlvbiBidWlsZEhUTUwodHJlZSwgb3B0aW9ucykge1xuICAvLyBTdHJpcCBvZmYgb3V0ZXIgdGFnIHdyYXBwZXIgZm9yIHByb2Nlc3NpbmcgYmVsb3cuXG4gIGxldCB0YWcgPSBudWxsO1xuXG4gIGlmICh0cmVlLmxlbmd0aCA9PT0gMSAmJiB0cmVlWzBdLnR5cGUgPT09IFwidGFnXCIpIHtcbiAgICB0YWcgPSB0cmVlWzBdLnRhZztcbiAgICB0cmVlID0gdHJlZVswXS5ib2R5O1xuICB9IC8vIEJ1aWxkIHRoZSBleHByZXNzaW9uIGNvbnRhaW5lZCBpbiB0aGUgdHJlZVxuXG5cbiAgY29uc3QgZXhwcmVzc2lvbiA9IGJ1aWxkRXhwcmVzc2lvbih0cmVlLCBvcHRpb25zLCBcInJvb3RcIik7XG4gIGxldCBlcW5OdW07XG5cbiAgaWYgKGV4cHJlc3Npb24ubGVuZ3RoID09PSAyICYmIGV4cHJlc3Npb25bMV0uaGFzQ2xhc3MoXCJ0YWdcIikpIHtcbiAgICAvLyBBbiBlbnZpcm9ubWVudCB3aXRoIGF1dG9tYXRpYyBlcXVhdGlvbiBudW1iZXJzLCBlLmcuIHtnYXRoZXJ9LlxuICAgIGVxbk51bSA9IGV4cHJlc3Npb24ucG9wKCk7XG4gIH1cblxuICBjb25zdCBjaGlsZHJlbiA9IFtdOyAvLyBDcmVhdGUgb25lIGJhc2Ugbm9kZSBmb3IgZWFjaCBjaHVuayBiZXR3ZWVuIHBvdGVudGlhbCBsaW5lIGJyZWFrcy5cbiAgLy8gVGhlIFRlWEJvb2sgW3AuMTczXSBzYXlzIFwiQSBmb3JtdWxhIHdpbGwgYmUgYnJva2VuIG9ubHkgYWZ0ZXIgYVxuICAvLyByZWxhdGlvbiBzeW1ib2wgbGlrZSAkPSQgb3IgJDwkIG9yICRcXHJpZ2h0YXJyb3ckLCBvciBhZnRlciBhIGJpbmFyeVxuICAvLyBvcGVyYXRpb24gc3ltYm9sIGxpa2UgJCskIG9yICQtJCBvciAkXFx0aW1lcyQsIHdoZXJlIHRoZSByZWxhdGlvbiBvclxuICAvLyBiaW5hcnkgb3BlcmF0aW9uIGlzIG9uIHRoZSBgYG91dGVyIGxldmVsJycgb2YgdGhlIGZvcm11bGEgKGkuZS4sIG5vdFxuICAvLyBlbmNsb3NlZCBpbiB7Li4ufSBhbmQgbm90IHBhcnQgb2YgYW4gXFxvdmVyIGNvbnN0cnVjdGlvbikuXCJcblxuICBsZXQgcGFydHMgPSBbXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGV4cHJlc3Npb24ubGVuZ3RoOyBpKyspIHtcbiAgICBwYXJ0cy5wdXNoKGV4cHJlc3Npb25baV0pO1xuXG4gICAgaWYgKGV4cHJlc3Npb25baV0uaGFzQ2xhc3MoXCJtYmluXCIpIHx8IGV4cHJlc3Npb25baV0uaGFzQ2xhc3MoXCJtcmVsXCIpIHx8IGV4cHJlc3Npb25baV0uaGFzQ2xhc3MoXCJhbGxvd2JyZWFrXCIpKSB7XG4gICAgICAvLyBQdXQgYW55IHBvc3Qtb3BlcmF0b3IgZ2x1ZSBvbiBzYW1lIGxpbmUgYXMgb3BlcmF0b3IuXG4gICAgICAvLyBXYXRjaCBmb3IgXFxub2JyZWFrIGFsb25nIHRoZSB3YXksIGFuZCBzdG9wIGF0IFxcbmV3bGluZS5cbiAgICAgIGxldCBub2JyZWFrID0gZmFsc2U7XG5cbiAgICAgIHdoaWxlIChpIDwgZXhwcmVzc2lvbi5sZW5ndGggLSAxICYmIGV4cHJlc3Npb25baSArIDFdLmhhc0NsYXNzKFwibXNwYWNlXCIpICYmICFleHByZXNzaW9uW2kgKyAxXS5oYXNDbGFzcyhcIm5ld2xpbmVcIikpIHtcbiAgICAgICAgaSsrO1xuICAgICAgICBwYXJ0cy5wdXNoKGV4cHJlc3Npb25baV0pO1xuXG4gICAgICAgIGlmIChleHByZXNzaW9uW2ldLmhhc0NsYXNzKFwibm9icmVha1wiKSkge1xuICAgICAgICAgIG5vYnJlYWsgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IC8vIERvbid0IGFsbG93IGJyZWFrIGlmIFxcbm9icmVhayBhbW9uZyB0aGUgcG9zdC1vcGVyYXRvciBnbHVlLlxuXG5cbiAgICAgIGlmICghbm9icmVhaykge1xuICAgICAgICBjaGlsZHJlbi5wdXNoKGJ1aWxkSFRNTFVuYnJlYWthYmxlKHBhcnRzLCBvcHRpb25zKSk7XG4gICAgICAgIHBhcnRzID0gW107XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChleHByZXNzaW9uW2ldLmhhc0NsYXNzKFwibmV3bGluZVwiKSkge1xuICAgICAgLy8gV3JpdGUgdGhlIGxpbmUgZXhjZXB0IHRoZSBuZXdsaW5lXG4gICAgICBwYXJ0cy5wb3AoKTtcblxuICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY2hpbGRyZW4ucHVzaChidWlsZEhUTUxVbmJyZWFrYWJsZShwYXJ0cywgb3B0aW9ucykpO1xuICAgICAgICBwYXJ0cyA9IFtdO1xuICAgICAgfSAvLyBQdXQgdGhlIG5ld2xpbmUgYXQgdGhlIHRvcCBsZXZlbFxuXG5cbiAgICAgIGNoaWxkcmVuLnB1c2goZXhwcmVzc2lvbltpXSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHBhcnRzLmxlbmd0aCA+IDApIHtcbiAgICBjaGlsZHJlbi5wdXNoKGJ1aWxkSFRNTFVuYnJlYWthYmxlKHBhcnRzLCBvcHRpb25zKSk7XG4gIH0gLy8gTm93LCBpZiB0aGVyZSB3YXMgYSB0YWcsIGJ1aWxkIGl0IHRvbyBhbmQgYXBwZW5kIGl0IGFzIGEgZmluYWwgY2hpbGQuXG5cblxuICBsZXQgdGFnQ2hpbGQ7XG5cbiAgaWYgKHRhZykge1xuICAgIHRhZ0NoaWxkID0gYnVpbGRIVE1MVW5icmVha2FibGUoYnVpbGRFeHByZXNzaW9uKHRhZywgb3B0aW9ucywgdHJ1ZSkpO1xuICAgIHRhZ0NoaWxkLmNsYXNzZXMgPSBbXCJ0YWdcIl07XG4gICAgY2hpbGRyZW4ucHVzaCh0YWdDaGlsZCk7XG4gIH0gZWxzZSBpZiAoZXFuTnVtKSB7XG4gICAgY2hpbGRyZW4ucHVzaChlcW5OdW0pO1xuICB9XG5cbiAgY29uc3QgaHRtbE5vZGUgPSBidWlsZEhUTUxfbWFrZVNwYW4oW1wia2F0ZXgtaHRtbFwiXSwgY2hpbGRyZW4pO1xuICBodG1sTm9kZS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7IC8vIEFkanVzdCB0aGUgc3RydXQgb2YgdGhlIHRhZyB0byBiZSB0aGUgbWF4aW11bSBoZWlnaHQgb2YgYWxsIGNoaWxkcmVuXG4gIC8vICh0aGUgaGVpZ2h0IG9mIHRoZSBlbmNsb3NpbmcgaHRtbE5vZGUpIGZvciBwcm9wZXIgdmVydGljYWwgYWxpZ25tZW50LlxuXG4gIGlmICh0YWdDaGlsZCkge1xuICAgIGNvbnN0IHN0cnV0ID0gdGFnQ2hpbGQuY2hpbGRyZW5bMF07XG4gICAgc3RydXQuc3R5bGUuaGVpZ2h0ID0gbWFrZUVtKGh0bWxOb2RlLmhlaWdodCArIGh0bWxOb2RlLmRlcHRoKTtcblxuICAgIGlmIChodG1sTm9kZS5kZXB0aCkge1xuICAgICAgc3RydXQuc3R5bGUudmVydGljYWxBbGlnbiA9IG1ha2VFbSgtaHRtbE5vZGUuZGVwdGgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBodG1sTm9kZTtcbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9tYXRoTUxUcmVlLmpzXG4vKipcbiAqIFRoZXNlIG9iamVjdHMgc3RvcmUgZGF0YSBhYm91dCBNYXRoTUwgbm9kZXMuIFRoaXMgaXMgdGhlIE1hdGhNTCBlcXVpdmFsZW50XG4gKiBvZiB0aGUgdHlwZXMgaW4gZG9tVHJlZS5qcy4gU2luY2UgTWF0aE1MIGhhbmRsZXMgaXRzIG93biByZW5kZXJpbmcsIGFuZFxuICogc2luY2Ugd2UncmUgbWFpbmx5IHVzaW5nIE1hdGhNTCB0byBpbXByb3ZlIGFjY2Vzc2liaWxpdHksIHdlIGRvbid0IG1hbmFnZVxuICogYW55IG9mIHRoZSBzdHlsaW5nIHN0YXRlIHRoYXQgdGhlIHBsYWluIERPTSBub2RlcyBkby5cbiAqXG4gKiBUaGUgYHRvTm9kZWAgYW5kIGB0b01hcmt1cGAgZnVuY3Rpb25zIHdvcmsgc2ltaWxhcmx5IHRvIGhvdyB0aGV5IGRvIGluXG4gKiBkb21UcmVlLmpzLCBjcmVhdGluZyBuYW1lc3BhY2VkIERPTSBub2RlcyBhbmQgSFRNTCB0ZXh0IG1hcmt1cCByZXNwZWN0aXZlbHkuXG4gKi9cblxuXG5cblxuZnVuY3Rpb24gbmV3RG9jdW1lbnRGcmFnbWVudChjaGlsZHJlbikge1xuICByZXR1cm4gbmV3IERvY3VtZW50RnJhZ21lbnQoY2hpbGRyZW4pO1xufVxuLyoqXG4gKiBUaGlzIG5vZGUgcmVwcmVzZW50cyBhIGdlbmVyYWwgcHVycG9zZSBNYXRoTUwgbm9kZSBvZiBhbnkgdHlwZS4gVGhlXG4gKiBjb25zdHJ1Y3RvciByZXF1aXJlcyB0aGUgdHlwZSBvZiBub2RlIHRvIGNyZWF0ZSAoZm9yIGV4YW1wbGUsIGBcIm1vXCJgIG9yXG4gKiBgXCJtc3BhY2VcImAsIGNvcnJlc3BvbmRpbmcgdG8gYDxtbz5gIGFuZCBgPG1zcGFjZT5gIHRhZ3MpLlxuICovXG5cbmNsYXNzIE1hdGhOb2RlIHtcbiAgY29uc3RydWN0b3IodHlwZSwgY2hpbGRyZW4sIGNsYXNzZXMpIHtcbiAgICB0aGlzLnR5cGUgPSB2b2lkIDA7XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gdm9pZCAwO1xuICAgIHRoaXMuY2hpbGRyZW4gPSB2b2lkIDA7XG4gICAgdGhpcy5jbGFzc2VzID0gdm9pZCAwO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0ge307XG4gICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuIHx8IFtdO1xuICAgIHRoaXMuY2xhc3NlcyA9IGNsYXNzZXMgfHwgW107XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgYW4gYXR0cmlidXRlIG9uIGEgTWF0aE1MIG5vZGUuIE1hdGhNTCBkZXBlbmRzIG9uIGF0dHJpYnV0ZXMgdG8gY29udmV5IGFcbiAgICogc2VtYW50aWMgY29udGVudCwgc28gdGhpcyBpcyB1c2VkIGhlYXZpbHkuXG4gICAqL1xuXG5cbiAgc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy5hdHRyaWJ1dGVzW25hbWVdID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgYW4gYXR0cmlidXRlIG9uIGEgTWF0aE1MIG5vZGUuXG4gICAqL1xuXG5cbiAgZ2V0QXR0cmlidXRlKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzW25hbWVdO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgbWF0aCBub2RlIGludG8gYSBNYXRoTUwtbmFtZXNwYWNlZCBET00gZWxlbWVudC5cbiAgICovXG5cblxuICB0b05vZGUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIiwgdGhpcy50eXBlKTtcblxuICAgIGZvciAoY29uc3QgYXR0ciBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5hdHRyaWJ1dGVzLCBhdHRyKSkge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyLCB0aGlzLmF0dHJpYnV0ZXNbYXR0cl0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmNsYXNzZXMubGVuZ3RoID4gMCkge1xuICAgICAgbm9kZS5jbGFzc05hbWUgPSBjcmVhdGVDbGFzcyh0aGlzLmNsYXNzZXMpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgbm9kZS5hcHBlbmRDaGlsZCh0aGlzLmNoaWxkcmVuW2ldLnRvTm9kZSgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgdGhlIG1hdGggbm9kZSBpbnRvIGFuIEhUTUwgbWFya3VwIHN0cmluZy5cbiAgICovXG5cblxuICB0b01hcmt1cCgpIHtcbiAgICBsZXQgbWFya3VwID0gXCI8XCIgKyB0aGlzLnR5cGU7IC8vIEFkZCB0aGUgYXR0cmlidXRlc1xuXG4gICAgZm9yIChjb25zdCBhdHRyIGluIHRoaXMuYXR0cmlidXRlcykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmF0dHJpYnV0ZXMsIGF0dHIpKSB7XG4gICAgICAgIG1hcmt1cCArPSBcIiBcIiArIGF0dHIgKyBcIj1cXFwiXCI7XG4gICAgICAgIG1hcmt1cCArPSB1dGlscy5lc2NhcGUodGhpcy5hdHRyaWJ1dGVzW2F0dHJdKTtcbiAgICAgICAgbWFya3VwICs9IFwiXFxcIlwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmNsYXNzZXMubGVuZ3RoID4gMCkge1xuICAgICAgbWFya3VwICs9IFwiIGNsYXNzID1cXFwiXCIgKyB1dGlscy5lc2NhcGUoY3JlYXRlQ2xhc3ModGhpcy5jbGFzc2VzKSkgKyBcIlxcXCJcIjtcbiAgICB9XG5cbiAgICBtYXJrdXAgKz0gXCI+XCI7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIG1hcmt1cCArPSB0aGlzLmNoaWxkcmVuW2ldLnRvTWFya3VwKCk7XG4gICAgfVxuXG4gICAgbWFya3VwICs9IFwiPC9cIiArIHRoaXMudHlwZSArIFwiPlwiO1xuICAgIHJldHVybiBtYXJrdXA7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBtYXRoIG5vZGUgaW50byBhIHN0cmluZywgc2ltaWxhciB0byBpbm5lclRleHQsIGJ1dCBlc2NhcGVkLlxuICAgKi9cblxuXG4gIHRvVGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5tYXAoY2hpbGQgPT4gY2hpbGQudG9UZXh0KCkpLmpvaW4oXCJcIik7XG4gIH1cblxufVxuLyoqXG4gKiBUaGlzIG5vZGUgcmVwcmVzZW50cyBhIHBpZWNlIG9mIHRleHQuXG4gKi9cblxuY2xhc3MgVGV4dE5vZGUge1xuICBjb25zdHJ1Y3Rvcih0ZXh0KSB7XG4gICAgdGhpcy50ZXh0ID0gdm9pZCAwO1xuICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSB0ZXh0IG5vZGUgaW50byBhIERPTSB0ZXh0IG5vZGUuXG4gICAqL1xuXG5cbiAgdG9Ob2RlKCkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLnRleHQpO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgdGV4dCBub2RlIGludG8gZXNjYXBlZCBIVE1MIG1hcmt1cFxuICAgKiAocmVwcmVzZW50aW5nIHRoZSB0ZXh0IGl0c2VsZikuXG4gICAqL1xuXG5cbiAgdG9NYXJrdXAoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmVzY2FwZSh0aGlzLnRvVGV4dCgpKTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgdGhlIHRleHQgbm9kZSBpbnRvIGEgc3RyaW5nXG4gICAqIChyZXByZXNlbnRpbmcgdGhlIHRleHQgaXRzZWxmKS5cbiAgICovXG5cblxuICB0b1RleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dDtcbiAgfVxuXG59XG4vKipcbiAqIFRoaXMgbm9kZSByZXByZXNlbnRzIGEgc3BhY2UsIGJ1dCBtYXkgcmVuZGVyIGFzIDxtc3BhY2UuLi4vPiBvciBhcyB0ZXh0LFxuICogZGVwZW5kaW5nIG9uIHRoZSB3aWR0aC5cbiAqL1xuXG5jbGFzcyBTcGFjZU5vZGUge1xuICAvKipcbiAgICogQ3JlYXRlIGEgU3BhY2Ugbm9kZSB3aXRoIHdpZHRoIGdpdmVuIGluIENTUyBlbXMuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih3aWR0aCkge1xuICAgIHRoaXMud2lkdGggPSB2b2lkIDA7XG4gICAgdGhpcy5jaGFyYWN0ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoOyAvLyBTZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMDAvV0QtTWF0aE1MMi0yMDAwMDMyOC9jaGFwdGVyNi5odG1sXG4gICAgLy8gZm9yIGEgdGFibGUgb2Ygc3BhY2UtbGlrZSBjaGFyYWN0ZXJzLiAgV2UgdXNlIFVuaWNvZGVcbiAgICAvLyByZXByZXNlbnRhdGlvbnMgaW5zdGVhZCBvZiAmTG9uZ05hbWVzOyBhcyBpdCdzIG5vdCBjbGVhciBob3cgdG9cbiAgICAvLyBtYWtlIHRoZSBsYXR0ZXIgdmlhIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlLlxuXG4gICAgaWYgKHdpZHRoID49IDAuMDU1NTUgJiYgd2lkdGggPD0gMC4wNTU1Nikge1xuICAgICAgdGhpcy5jaGFyYWN0ZXIgPSBcIlxcdTIwMGFcIjsgLy8gJlZlcnlUaGluU3BhY2U7XG4gICAgfSBlbHNlIGlmICh3aWR0aCA+PSAwLjE2NjYgJiYgd2lkdGggPD0gMC4xNjY3KSB7XG4gICAgICB0aGlzLmNoYXJhY3RlciA9IFwiXFx1MjAwOVwiOyAvLyAmVGhpblNwYWNlO1xuICAgIH0gZWxzZSBpZiAod2lkdGggPj0gMC4yMjIyICYmIHdpZHRoIDw9IDAuMjIyMykge1xuICAgICAgdGhpcy5jaGFyYWN0ZXIgPSBcIlxcdTIwMDVcIjsgLy8gJk1lZGl1bVNwYWNlO1xuICAgIH0gZWxzZSBpZiAod2lkdGggPj0gMC4yNzc3ICYmIHdpZHRoIDw9IDAuMjc3OCkge1xuICAgICAgdGhpcy5jaGFyYWN0ZXIgPSBcIlxcdTIwMDVcXHUyMDBhXCI7IC8vICZUaGlja1NwYWNlO1xuICAgIH0gZWxzZSBpZiAod2lkdGggPj0gLTAuMDU1NTYgJiYgd2lkdGggPD0gLTAuMDU1NTUpIHtcbiAgICAgIHRoaXMuY2hhcmFjdGVyID0gXCJcXHUyMDBhXFx1MjA2M1wiOyAvLyAmTmVnYXRpdmVWZXJ5VGhpblNwYWNlO1xuICAgIH0gZWxzZSBpZiAod2lkdGggPj0gLTAuMTY2NyAmJiB3aWR0aCA8PSAtMC4xNjY2KSB7XG4gICAgICB0aGlzLmNoYXJhY3RlciA9IFwiXFx1MjAwOVxcdTIwNjNcIjsgLy8gJk5lZ2F0aXZlVGhpblNwYWNlO1xuICAgIH0gZWxzZSBpZiAod2lkdGggPj0gLTAuMjIyMyAmJiB3aWR0aCA8PSAtMC4yMjIyKSB7XG4gICAgICB0aGlzLmNoYXJhY3RlciA9IFwiXFx1MjA1ZlxcdTIwNjNcIjsgLy8gJk5lZ2F0aXZlTWVkaXVtU3BhY2U7XG4gICAgfSBlbHNlIGlmICh3aWR0aCA+PSAtMC4yNzc4ICYmIHdpZHRoIDw9IC0wLjI3NzcpIHtcbiAgICAgIHRoaXMuY2hhcmFjdGVyID0gXCJcXHUyMDA1XFx1MjA2M1wiOyAvLyAmTmVnYXRpdmVUaGlja1NwYWNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNoYXJhY3RlciA9IG51bGw7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgbWF0aCBub2RlIGludG8gYSBNYXRoTUwtbmFtZXNwYWNlZCBET00gZWxlbWVudC5cbiAgICovXG5cblxuICB0b05vZGUoKSB7XG4gICAgaWYgKHRoaXMuY2hhcmFjdGVyKSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy5jaGFyYWN0ZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwiLCBcIm1zcGFjZVwiKTtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgbWFrZUVtKHRoaXMud2lkdGgpKTtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgdGhlIG1hdGggbm9kZSBpbnRvIGFuIEhUTUwgbWFya3VwIHN0cmluZy5cbiAgICovXG5cblxuICB0b01hcmt1cCgpIHtcbiAgICBpZiAodGhpcy5jaGFyYWN0ZXIpIHtcbiAgICAgIHJldHVybiBcIjxtdGV4dD5cIiArIHRoaXMuY2hhcmFjdGVyICsgXCI8L210ZXh0PlwiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCI8bXNwYWNlIHdpZHRoPVxcXCJcIiArIG1ha2VFbSh0aGlzLndpZHRoKSArIFwiXFxcIi8+XCI7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgbWF0aCBub2RlIGludG8gYSBzdHJpbmcsIHNpbWlsYXIgdG8gaW5uZXJUZXh0LlxuICAgKi9cblxuXG4gIHRvVGV4dCgpIHtcbiAgICBpZiAodGhpcy5jaGFyYWN0ZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmNoYXJhY3RlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFwiIFwiO1xuICAgIH1cbiAgfVxuXG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIG1hdGhNTFRyZWUgPSAoe1xuICBNYXRoTm9kZSxcbiAgVGV4dE5vZGUsXG4gIFNwYWNlTm9kZSxcbiAgbmV3RG9jdW1lbnRGcmFnbWVudFxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvYnVpbGRNYXRoTUwuanNcbi8qKlxuICogVGhpcyBmaWxlIGNvbnZlcnRzIGEgcGFyc2UgdHJlZSBpbnRvIGEgY29ycmVzcG9uZGluZyBNYXRoTUwgdHJlZS4gVGhlIG1haW5cbiAqIGVudHJ5IHBvaW50IGlzIHRoZSBgYnVpbGRNYXRoTUxgIGZ1bmN0aW9uLCB3aGljaCB0YWtlcyBhIHBhcnNlIHRyZWUgZnJvbSB0aGVcbiAqIHBhcnNlci5cbiAqL1xuXG5cblxuXG5cblxuXG5cblxuLyoqXG4gKiBUYWtlcyBhIHN5bWJvbCBhbmQgY29udmVydHMgaXQgaW50byBhIE1hdGhNTCB0ZXh0IG5vZGUgYWZ0ZXIgcGVyZm9ybWluZ1xuICogb3B0aW9uYWwgcmVwbGFjZW1lbnQgZnJvbSBzeW1ib2xzLmpzLlxuICovXG5jb25zdCBtYWtlVGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBtb2RlLCBvcHRpb25zKSB7XG4gIGlmIChzcmNfc3ltYm9sc1ttb2RlXVt0ZXh0XSAmJiBzcmNfc3ltYm9sc1ttb2RlXVt0ZXh0XS5yZXBsYWNlICYmIHRleHQuY2hhckNvZGVBdCgwKSAhPT0gMHhEODM1ICYmICEobGlnYXR1cmVzLmhhc093blByb3BlcnR5KHRleHQpICYmIG9wdGlvbnMgJiYgKG9wdGlvbnMuZm9udEZhbWlseSAmJiBvcHRpb25zLmZvbnRGYW1pbHkuc2xpY2UoNCwgNikgPT09IFwidHRcIiB8fCBvcHRpb25zLmZvbnQgJiYgb3B0aW9ucy5mb250LnNsaWNlKDQsIDYpID09PSBcInR0XCIpKSkge1xuICAgIHRleHQgPSBzcmNfc3ltYm9sc1ttb2RlXVt0ZXh0XS5yZXBsYWNlO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLlRleHROb2RlKHRleHQpO1xufTtcbi8qKlxuICogV3JhcCB0aGUgZ2l2ZW4gYXJyYXkgb2Ygbm9kZXMgaW4gYW4gPG1yb3c+IG5vZGUgaWYgbmVlZGVkLCBpLmUuLFxuICogdW5sZXNzIHRoZSBhcnJheSBoYXMgbGVuZ3RoIDEuICBBbHdheXMgcmV0dXJucyBhIHNpbmdsZSBub2RlLlxuICovXG5cbmNvbnN0IG1ha2VSb3cgPSBmdW5jdGlvbiAoYm9keSkge1xuICBpZiAoYm9keS5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gYm9keVswXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIsIGJvZHkpO1xuICB9XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBtYXRoIHZhcmlhbnQgYXMgYSBzdHJpbmcgb3IgbnVsbCBpZiBub25lIGlzIHJlcXVpcmVkLlxuICovXG5cbmNvbnN0IGdldFZhcmlhbnQgPSBmdW5jdGlvbiAoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgLy8gSGFuZGxlIFxcdGV4dC4uLiBmb250IHNwZWNpZmllcnMgYXMgYmVzdCB3ZSBjYW4uXG4gIC8vIE1hdGhNTCBoYXMgYSBsaW1pdGVkIGxpc3Qgb2YgYWxsb3dhYmxlIG1hdGh2YXJpYW50IHNwZWNpZmllcnM7IHNlZVxuICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvTWF0aE1MMy9jaGFwdGVyMy5odG1sI3ByZXNtLmNvbW1hdHRcbiAgaWYgKG9wdGlvbnMuZm9udEZhbWlseSA9PT0gXCJ0ZXh0dHRcIikge1xuICAgIHJldHVybiBcIm1vbm9zcGFjZVwiO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMuZm9udEZhbWlseSA9PT0gXCJ0ZXh0c2ZcIikge1xuICAgIGlmIChvcHRpb25zLmZvbnRTaGFwZSA9PT0gXCJ0ZXh0aXRcIiAmJiBvcHRpb25zLmZvbnRXZWlnaHQgPT09IFwidGV4dGJmXCIpIHtcbiAgICAgIHJldHVybiBcInNhbnMtc2VyaWYtYm9sZC1pdGFsaWNcIjtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZm9udFNoYXBlID09PSBcInRleHRpdFwiKSB7XG4gICAgICByZXR1cm4gXCJzYW5zLXNlcmlmLWl0YWxpY1wiO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5mb250V2VpZ2h0ID09PSBcInRleHRiZlwiKSB7XG4gICAgICByZXR1cm4gXCJib2xkLXNhbnMtc2VyaWZcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFwic2Fucy1zZXJpZlwiO1xuICAgIH1cbiAgfSBlbHNlIGlmIChvcHRpb25zLmZvbnRTaGFwZSA9PT0gXCJ0ZXh0aXRcIiAmJiBvcHRpb25zLmZvbnRXZWlnaHQgPT09IFwidGV4dGJmXCIpIHtcbiAgICByZXR1cm4gXCJib2xkLWl0YWxpY1wiO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMuZm9udFNoYXBlID09PSBcInRleHRpdFwiKSB7XG4gICAgcmV0dXJuIFwiaXRhbGljXCI7XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5mb250V2VpZ2h0ID09PSBcInRleHRiZlwiKSB7XG4gICAgcmV0dXJuIFwiYm9sZFwiO1xuICB9XG5cbiAgY29uc3QgZm9udCA9IG9wdGlvbnMuZm9udDtcblxuICBpZiAoIWZvbnQgfHwgZm9udCA9PT0gXCJtYXRobm9ybWFsXCIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IG1vZGUgPSBncm91cC5tb2RlO1xuXG4gIGlmIChmb250ID09PSBcIm1hdGhpdFwiKSB7XG4gICAgcmV0dXJuIFwiaXRhbGljXCI7XG4gIH0gZWxzZSBpZiAoZm9udCA9PT0gXCJib2xkc3ltYm9sXCIpIHtcbiAgICByZXR1cm4gZ3JvdXAudHlwZSA9PT0gXCJ0ZXh0b3JkXCIgPyBcImJvbGRcIiA6IFwiYm9sZC1pdGFsaWNcIjtcbiAgfSBlbHNlIGlmIChmb250ID09PSBcIm1hdGhiZlwiKSB7XG4gICAgcmV0dXJuIFwiYm9sZFwiO1xuICB9IGVsc2UgaWYgKGZvbnQgPT09IFwibWF0aGJiXCIpIHtcbiAgICByZXR1cm4gXCJkb3VibGUtc3RydWNrXCI7XG4gIH0gZWxzZSBpZiAoZm9udCA9PT0gXCJtYXRoZnJha1wiKSB7XG4gICAgcmV0dXJuIFwiZnJha3R1clwiO1xuICB9IGVsc2UgaWYgKGZvbnQgPT09IFwibWF0aHNjclwiIHx8IGZvbnQgPT09IFwibWF0aGNhbFwiKSB7XG4gICAgLy8gTWF0aE1MIG1ha2VzIG5vIGRpc3RpbmN0aW9uIGJldHdlZW4gc2NyaXB0IGFuZCBjYWxsaWdyYXBoaWNcbiAgICByZXR1cm4gXCJzY3JpcHRcIjtcbiAgfSBlbHNlIGlmIChmb250ID09PSBcIm1hdGhzZlwiKSB7XG4gICAgcmV0dXJuIFwic2Fucy1zZXJpZlwiO1xuICB9IGVsc2UgaWYgKGZvbnQgPT09IFwibWF0aHR0XCIpIHtcbiAgICByZXR1cm4gXCJtb25vc3BhY2VcIjtcbiAgfVxuXG4gIGxldCB0ZXh0ID0gZ3JvdXAudGV4dDtcblxuICBpZiAodXRpbHMuY29udGFpbnMoW1wiXFxcXGltYXRoXCIsIFwiXFxcXGptYXRoXCJdLCB0ZXh0KSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHNyY19zeW1ib2xzW21vZGVdW3RleHRdICYmIHNyY19zeW1ib2xzW21vZGVdW3RleHRdLnJlcGxhY2UpIHtcbiAgICB0ZXh0ID0gc3JjX3N5bWJvbHNbbW9kZV1bdGV4dF0ucmVwbGFjZTtcbiAgfVxuXG4gIGNvbnN0IGZvbnROYW1lID0gYnVpbGRDb21tb24uZm9udE1hcFtmb250XS5mb250TmFtZTtcblxuICBpZiAoZ2V0Q2hhcmFjdGVyTWV0cmljcyh0ZXh0LCBmb250TmFtZSwgbW9kZSkpIHtcbiAgICByZXR1cm4gYnVpbGRDb21tb24uZm9udE1hcFtmb250XS52YXJpYW50O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuLyoqXG4gKiBUYWtlcyBhIGxpc3Qgb2Ygbm9kZXMsIGJ1aWxkcyB0aGVtLCBhbmQgcmV0dXJucyBhIGxpc3Qgb2YgdGhlIGdlbmVyYXRlZFxuICogTWF0aE1MIG5vZGVzLiAgQWxzbyBjb21iaW5lIGNvbnNlY3V0aXZlIDxtdGV4dD4gb3V0cHV0cyBpbnRvIGEgc2luZ2xlXG4gKiA8bXRleHQ+IHRhZy5cbiAqL1xuXG5jb25zdCBidWlsZE1hdGhNTF9idWlsZEV4cHJlc3Npb24gPSBmdW5jdGlvbiAoZXhwcmVzc2lvbiwgb3B0aW9ucywgaXNPcmRncm91cCkge1xuICBpZiAoZXhwcmVzc2lvbi5sZW5ndGggPT09IDEpIHtcbiAgICBjb25zdCBncm91cCA9IGJ1aWxkTWF0aE1MX2J1aWxkR3JvdXAoZXhwcmVzc2lvblswXSwgb3B0aW9ucyk7XG5cbiAgICBpZiAoaXNPcmRncm91cCAmJiBncm91cCBpbnN0YW5jZW9mIE1hdGhOb2RlICYmIGdyb3VwLnR5cGUgPT09IFwibW9cIikge1xuICAgICAgLy8gV2hlbiBUZVggd3JpdGVycyB3YW50IHRvIHN1cHByZXNzIHNwYWNpbmcgb24gYW4gb3BlcmF0b3IsXG4gICAgICAvLyB0aGV5IG9mdGVuIHB1dCB0aGUgb3BlcmF0b3IgYnkgaXRzZWxmIGluc2lkZSBicmFjZXMuXG4gICAgICBncm91cC5zZXRBdHRyaWJ1dGUoXCJsc3BhY2VcIiwgXCIwZW1cIik7XG4gICAgICBncm91cC5zZXRBdHRyaWJ1dGUoXCJyc3BhY2VcIiwgXCIwZW1cIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtncm91cF07XG4gIH1cblxuICBjb25zdCBncm91cHMgPSBbXTtcbiAgbGV0IGxhc3RHcm91cDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGV4cHJlc3Npb24ubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBncm91cCA9IGJ1aWxkTWF0aE1MX2J1aWxkR3JvdXAoZXhwcmVzc2lvbltpXSwgb3B0aW9ucyk7XG5cbiAgICBpZiAoZ3JvdXAgaW5zdGFuY2VvZiBNYXRoTm9kZSAmJiBsYXN0R3JvdXAgaW5zdGFuY2VvZiBNYXRoTm9kZSkge1xuICAgICAgLy8gQ29uY2F0ZW5hdGUgYWRqYWNlbnQgPG10ZXh0PnNcbiAgICAgIGlmIChncm91cC50eXBlID09PSAnbXRleHQnICYmIGxhc3RHcm91cC50eXBlID09PSAnbXRleHQnICYmIGdyb3VwLmdldEF0dHJpYnV0ZSgnbWF0aHZhcmlhbnQnKSA9PT0gbGFzdEdyb3VwLmdldEF0dHJpYnV0ZSgnbWF0aHZhcmlhbnQnKSkge1xuICAgICAgICBsYXN0R3JvdXAuY2hpbGRyZW4ucHVzaCguLi5ncm91cC5jaGlsZHJlbik7XG4gICAgICAgIGNvbnRpbnVlOyAvLyBDb25jYXRlbmF0ZSBhZGphY2VudCA8bW4+c1xuICAgICAgfSBlbHNlIGlmIChncm91cC50eXBlID09PSAnbW4nICYmIGxhc3RHcm91cC50eXBlID09PSAnbW4nKSB7XG4gICAgICAgIGxhc3RHcm91cC5jaGlsZHJlbi5wdXNoKC4uLmdyb3VwLmNoaWxkcmVuKTtcbiAgICAgICAgY29udGludWU7IC8vIENvbmNhdGVuYXRlIDxtbj4uLi48L21uPiBmb2xsb3dlZCBieSA8bWk+LjwvbWk+XG4gICAgICB9IGVsc2UgaWYgKGdyb3VwLnR5cGUgPT09ICdtaScgJiYgZ3JvdXAuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIGxhc3RHcm91cC50eXBlID09PSAnbW4nKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gZ3JvdXAuY2hpbGRyZW5bMF07XG5cbiAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgVGV4dE5vZGUgJiYgY2hpbGQudGV4dCA9PT0gJy4nKSB7XG4gICAgICAgICAgbGFzdEdyb3VwLmNoaWxkcmVuLnB1c2goLi4uZ3JvdXAuY2hpbGRyZW4pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGxhc3RHcm91cC50eXBlID09PSAnbWknICYmIGxhc3RHcm91cC5jaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgY29uc3QgbGFzdENoaWxkID0gbGFzdEdyb3VwLmNoaWxkcmVuWzBdO1xuXG4gICAgICAgIGlmIChsYXN0Q2hpbGQgaW5zdGFuY2VvZiBUZXh0Tm9kZSAmJiBsYXN0Q2hpbGQudGV4dCA9PT0gJ1xcdTAzMzgnICYmIChncm91cC50eXBlID09PSAnbW8nIHx8IGdyb3VwLnR5cGUgPT09ICdtaScgfHwgZ3JvdXAudHlwZSA9PT0gJ21uJykpIHtcbiAgICAgICAgICBjb25zdCBjaGlsZCA9IGdyb3VwLmNoaWxkcmVuWzBdO1xuXG4gICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgVGV4dE5vZGUgJiYgY2hpbGQudGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBPdmVybGF5IHdpdGggY29tYmluaW5nIGNoYXJhY3RlciBsb25nIHNvbGlkdXNcbiAgICAgICAgICAgIGNoaWxkLnRleHQgPSBjaGlsZC50ZXh0LnNsaWNlKDAsIDEpICsgXCJcXHUwMzM4XCIgKyBjaGlsZC50ZXh0LnNsaWNlKDEpO1xuICAgICAgICAgICAgZ3JvdXBzLnBvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGdyb3Vwcy5wdXNoKGdyb3VwKTtcbiAgICBsYXN0R3JvdXAgPSBncm91cDtcbiAgfVxuXG4gIHJldHVybiBncm91cHM7XG59O1xuLyoqXG4gKiBFcXVpdmFsZW50IHRvIGJ1aWxkRXhwcmVzc2lvbiwgYnV0IHdyYXBzIHRoZSBlbGVtZW50cyBpbiBhbiA8bXJvdz5cbiAqIGlmIHRoZXJlJ3MgbW9yZSB0aGFuIG9uZS4gIFJldHVybnMgYSBzaW5nbGUgbm9kZSBpbnN0ZWFkIG9mIGFuIGFycmF5LlxuICovXG5cbmNvbnN0IGJ1aWxkRXhwcmVzc2lvblJvdyA9IGZ1bmN0aW9uIChleHByZXNzaW9uLCBvcHRpb25zLCBpc09yZGdyb3VwKSB7XG4gIHJldHVybiBtYWtlUm93KGJ1aWxkTWF0aE1MX2J1aWxkRXhwcmVzc2lvbihleHByZXNzaW9uLCBvcHRpb25zLCBpc09yZGdyb3VwKSk7XG59O1xuLyoqXG4gKiBUYWtlcyBhIGdyb3VwIGZyb20gdGhlIHBhcnNlciBhbmQgY2FsbHMgdGhlIGFwcHJvcHJpYXRlIGdyb3VwQnVpbGRlcnMgZnVuY3Rpb25cbiAqIG9uIGl0IHRvIHByb2R1Y2UgYSBNYXRoTUwgbm9kZS5cbiAqL1xuXG5jb25zdCBidWlsZE1hdGhNTF9idWlsZEdyb3VwID0gZnVuY3Rpb24gKGdyb3VwLCBvcHRpb25zKSB7XG4gIGlmICghZ3JvdXApIHtcbiAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIpO1xuICB9XG5cbiAgaWYgKF9tYXRobWxHcm91cEJ1aWxkZXJzW2dyb3VwLnR5cGVdKSB7XG4gICAgLy8gQ2FsbCB0aGUgZ3JvdXBCdWlsZGVycyBmdW5jdGlvblxuICAgIC8vICRGbG93Rml4TWVcbiAgICBjb25zdCByZXN1bHQgPSBfbWF0aG1sR3JvdXBCdWlsZGVyc1tncm91cC50eXBlXShncm91cCwgb3B0aW9ucyk7IC8vICRGbG93Rml4TWVcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiR290IGdyb3VwIG9mIHVua25vd24gdHlwZTogJ1wiICsgZ3JvdXAudHlwZSArIFwiJ1wiKTtcbiAgfVxufTtcbi8qKlxuICogVGFrZXMgYSBmdWxsIHBhcnNlIHRyZWUgYW5kIHNldHRpbmdzIGFuZCBidWlsZHMgYSBNYXRoTUwgcmVwcmVzZW50YXRpb24gb2ZcbiAqIGl0LiBJbiBwYXJ0aWN1bGFyLCB3ZSBwdXQgdGhlIGVsZW1lbnRzIGZyb20gYnVpbGRpbmcgdGhlIHBhcnNlIHRyZWUgaW50byBhXG4gKiA8c2VtYW50aWNzPiB0YWcgc28gd2UgY2FuIGFsc28gaW5jbHVkZSB0aGF0IFRlWCBzb3VyY2UgYXMgYW4gYW5ub3RhdGlvbi5cbiAqXG4gKiBOb3RlIHRoYXQgd2UgYWN0dWFsbHkgcmV0dXJuIGEgZG9tVHJlZSBlbGVtZW50IHdpdGggYSBgPG1hdGg+YCBpbnNpZGUgaXQgc29cbiAqIHdlIGNhbiBkbyBhcHByb3ByaWF0ZSBzdHlsaW5nLlxuICovXG5cbmZ1bmN0aW9uIGJ1aWxkTWF0aE1MKHRyZWUsIHRleEV4cHJlc3Npb24sIG9wdGlvbnMsIGlzRGlzcGxheU1vZGUsIGZvck1hdGhtbE9ubHkpIHtcbiAgY29uc3QgZXhwcmVzc2lvbiA9IGJ1aWxkTWF0aE1MX2J1aWxkRXhwcmVzc2lvbih0cmVlLCBvcHRpb25zKTsgLy8gVE9ETzogTWFrZSBhIHBhc3MgdGhydSB0aGUgTWF0aE1MIHNpbWlsYXIgdG8gYnVpbGRIVE1MLnRyYXZlcnNlTm9uU3BhY2VOb2Rlc1xuICAvLyBhbmQgYWRkIHNwYWNpbmcgbm9kZXMuIFRoaXMgaXMgbmVjZXNzYXJ5IG9ubHkgYWRqYWNlbnQgdG8gbWF0aCBvcGVyYXRvcnNcbiAgLy8gbGlrZSBcXHNpbiBvciBcXGxpbSBvciB0byBzdWJzdXAgZWxlbWVudHMgdGhhdCBjb250YWluIG1hdGggb3BlcmF0b3JzLlxuICAvLyBNYXRoTUwgdGFrZXMgY2FyZSBvZiB0aGUgb3RoZXIgc3BhY2luZyBpc3N1ZXMuXG4gIC8vIFdyYXAgdXAgdGhlIGV4cHJlc3Npb24gaW4gYW4gbXJvdyBzbyBpdCBpcyBwcmVzZW50ZWQgaW4gdGhlIHNlbWFudGljc1xuICAvLyB0YWcgY29ycmVjdGx5LCB1bmxlc3MgaXQncyBhIHNpbmdsZSA8bXJvdz4gb3IgPG10YWJsZT4uXG5cbiAgbGV0IHdyYXBwZXI7XG5cbiAgaWYgKGV4cHJlc3Npb24ubGVuZ3RoID09PSAxICYmIGV4cHJlc3Npb25bMF0gaW5zdGFuY2VvZiBNYXRoTm9kZSAmJiB1dGlscy5jb250YWlucyhbXCJtcm93XCIsIFwibXRhYmxlXCJdLCBleHByZXNzaW9uWzBdLnR5cGUpKSB7XG4gICAgd3JhcHBlciA9IGV4cHJlc3Npb25bMF07XG4gIH0gZWxzZSB7XG4gICAgd3JhcHBlciA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiLCBleHByZXNzaW9uKTtcbiAgfSAvLyBCdWlsZCBhIFRlWCBhbm5vdGF0aW9uIG9mIHRoZSBzb3VyY2VcblxuXG4gIGNvbnN0IGFubm90YXRpb24gPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcImFubm90YXRpb25cIiwgW25ldyBtYXRoTUxUcmVlLlRleHROb2RlKHRleEV4cHJlc3Npb24pXSk7XG4gIGFubm90YXRpb24uc2V0QXR0cmlidXRlKFwiZW5jb2RpbmdcIiwgXCJhcHBsaWNhdGlvbi94LXRleFwiKTtcbiAgY29uc3Qgc2VtYW50aWNzID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJzZW1hbnRpY3NcIiwgW3dyYXBwZXIsIGFubm90YXRpb25dKTtcbiAgY29uc3QgbWF0aCA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibWF0aFwiLCBbc2VtYW50aWNzXSk7XG4gIG1hdGguc2V0QXR0cmlidXRlKFwieG1sbnNcIiwgXCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCIpO1xuXG4gIGlmIChpc0Rpc3BsYXlNb2RlKSB7XG4gICAgbWF0aC5zZXRBdHRyaWJ1dGUoXCJkaXNwbGF5XCIsIFwiYmxvY2tcIik7XG4gIH0gLy8gWW91IGNhbid0IHN0eWxlIDxtYXRoPiBub2Rlcywgc28gd2Ugd3JhcCB0aGUgbm9kZSBpbiBhIHNwYW4uXG4gIC8vIE5PVEU6IFRoZSBzcGFuIGNsYXNzIGlzIG5vdCB0eXBlZCB0byBoYXZlIDxtYXRoPiBub2RlcyBhcyBjaGlsZHJlbiwgYW5kXG4gIC8vIHdlIGRvbid0IHdhbnQgdG8gbWFrZSB0aGUgY2hpbGRyZW4gdHlwZSBtb3JlIGdlbmVyaWMgc2luY2UgdGhlIGNoaWxkcmVuXG4gIC8vIG9mIHNwYW4gYXJlIGV4cGVjdGVkIHRvIGhhdmUgbW9yZSBmaWVsZHMgaW4gYGJ1aWxkSHRtbGAgY29udGV4dHMuXG5cblxuICBjb25zdCB3cmFwcGVyQ2xhc3MgPSBmb3JNYXRobWxPbmx5ID8gXCJrYXRleFwiIDogXCJrYXRleC1tYXRobWxcIjsgLy8gJEZsb3dGaXhNZVxuXG4gIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3Bhbihbd3JhcHBlckNsYXNzXSwgW21hdGhdKTtcbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9idWlsZFRyZWUuanNcblxuXG5cblxuXG5cblxuY29uc3Qgb3B0aW9uc0Zyb21TZXR0aW5ncyA9IGZ1bmN0aW9uIChzZXR0aW5ncykge1xuICByZXR1cm4gbmV3IHNyY19PcHRpb25zKHtcbiAgICBzdHlsZTogc2V0dGluZ3MuZGlzcGxheU1vZGUgPyBzcmNfU3R5bGUuRElTUExBWSA6IHNyY19TdHlsZS5URVhULFxuICAgIG1heFNpemU6IHNldHRpbmdzLm1heFNpemUsXG4gICAgbWluUnVsZVRoaWNrbmVzczogc2V0dGluZ3MubWluUnVsZVRoaWNrbmVzc1xuICB9KTtcbn07XG5cbmNvbnN0IGRpc3BsYXlXcmFwID0gZnVuY3Rpb24gKG5vZGUsIHNldHRpbmdzKSB7XG4gIGlmIChzZXR0aW5ncy5kaXNwbGF5TW9kZSkge1xuICAgIGNvbnN0IGNsYXNzZXMgPSBbXCJrYXRleC1kaXNwbGF5XCJdO1xuXG4gICAgaWYgKHNldHRpbmdzLmxlcW5vKSB7XG4gICAgICBjbGFzc2VzLnB1c2goXCJsZXFub1wiKTtcbiAgICB9XG5cbiAgICBpZiAoc2V0dGluZ3MuZmxlcW4pIHtcbiAgICAgIGNsYXNzZXMucHVzaChcImZsZXFuXCIpO1xuICAgIH1cblxuICAgIG5vZGUgPSBidWlsZENvbW1vbi5tYWtlU3BhbihjbGFzc2VzLCBbbm9kZV0pO1xuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59O1xuXG5jb25zdCBidWlsZFRyZWUgPSBmdW5jdGlvbiAodHJlZSwgZXhwcmVzc2lvbiwgc2V0dGluZ3MpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IG9wdGlvbnNGcm9tU2V0dGluZ3Moc2V0dGluZ3MpO1xuICBsZXQga2F0ZXhOb2RlO1xuXG4gIGlmIChzZXR0aW5ncy5vdXRwdXQgPT09IFwibWF0aG1sXCIpIHtcbiAgICByZXR1cm4gYnVpbGRNYXRoTUwodHJlZSwgZXhwcmVzc2lvbiwgb3B0aW9ucywgc2V0dGluZ3MuZGlzcGxheU1vZGUsIHRydWUpO1xuICB9IGVsc2UgaWYgKHNldHRpbmdzLm91dHB1dCA9PT0gXCJodG1sXCIpIHtcbiAgICBjb25zdCBodG1sTm9kZSA9IGJ1aWxkSFRNTCh0cmVlLCBvcHRpb25zKTtcbiAgICBrYXRleE5vZGUgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJrYXRleFwiXSwgW2h0bWxOb2RlXSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbWF0aE1MTm9kZSA9IGJ1aWxkTWF0aE1MKHRyZWUsIGV4cHJlc3Npb24sIG9wdGlvbnMsIHNldHRpbmdzLmRpc3BsYXlNb2RlLCBmYWxzZSk7XG4gICAgY29uc3QgaHRtbE5vZGUgPSBidWlsZEhUTUwodHJlZSwgb3B0aW9ucyk7XG4gICAga2F0ZXhOb2RlID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wia2F0ZXhcIl0sIFttYXRoTUxOb2RlLCBodG1sTm9kZV0pO1xuICB9XG5cbiAgcmV0dXJuIGRpc3BsYXlXcmFwKGthdGV4Tm9kZSwgc2V0dGluZ3MpO1xufTtcbmNvbnN0IGJ1aWxkSFRNTFRyZWUgPSBmdW5jdGlvbiAodHJlZSwgZXhwcmVzc2lvbiwgc2V0dGluZ3MpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IG9wdGlvbnNGcm9tU2V0dGluZ3Moc2V0dGluZ3MpO1xuICBjb25zdCBodG1sTm9kZSA9IGJ1aWxkSFRNTCh0cmVlLCBvcHRpb25zKTtcbiAgY29uc3Qga2F0ZXhOb2RlID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wia2F0ZXhcIl0sIFtodG1sTm9kZV0pO1xuICByZXR1cm4gZGlzcGxheVdyYXAoa2F0ZXhOb2RlLCBzZXR0aW5ncyk7XG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgc3JjX2J1aWxkVHJlZSA9ICgoLyogdW51c2VkIHB1cmUgZXhwcmVzc2lvbiBvciBzdXBlciAqLyBudWxsICYmIChidWlsZFRyZWUpKSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvc3RyZXRjaHkuanNcbi8qKlxuICogVGhpcyBmaWxlIHByb3ZpZGVzIHN1cHBvcnQgdG8gYnVpbGRNYXRoTUwuanMgYW5kIGJ1aWxkSFRNTC5qc1xuICogZm9yIHN0cmV0Y2h5IHdpZGUgZWxlbWVudHMgcmVuZGVyZWQgZnJvbSBTVkcgZmlsZXNcbiAqIGFuZCBvdGhlciBDU1MgdHJpY2tlcnkuXG4gKi9cblxuXG5cblxuXG5jb25zdCBzdHJldGNoeUNvZGVQb2ludCA9IHtcbiAgd2lkZWhhdDogXCJeXCIsXG4gIHdpZGVjaGVjazogXCLLh1wiLFxuICB3aWRldGlsZGU6IFwiflwiLFxuICB1dGlsZGU6IFwiflwiLFxuICBvdmVybGVmdGFycm93OiBcIlxcdTIxOTBcIixcbiAgdW5kZXJsZWZ0YXJyb3c6IFwiXFx1MjE5MFwiLFxuICB4bGVmdGFycm93OiBcIlxcdTIxOTBcIixcbiAgb3ZlcnJpZ2h0YXJyb3c6IFwiXFx1MjE5MlwiLFxuICB1bmRlcnJpZ2h0YXJyb3c6IFwiXFx1MjE5MlwiLFxuICB4cmlnaHRhcnJvdzogXCJcXHUyMTkyXCIsXG4gIHVuZGVyYnJhY2U6IFwiXFx1MjNkZlwiLFxuICBvdmVyYnJhY2U6IFwiXFx1MjNkZVwiLFxuICBvdmVyZ3JvdXA6IFwiXFx1MjNlMFwiLFxuICB1bmRlcmdyb3VwOiBcIlxcdTIzZTFcIixcbiAgb3ZlcmxlZnRyaWdodGFycm93OiBcIlxcdTIxOTRcIixcbiAgdW5kZXJsZWZ0cmlnaHRhcnJvdzogXCJcXHUyMTk0XCIsXG4gIHhsZWZ0cmlnaHRhcnJvdzogXCJcXHUyMTk0XCIsXG4gIE92ZXJyaWdodGFycm93OiBcIlxcdTIxZDJcIixcbiAgeFJpZ2h0YXJyb3c6IFwiXFx1MjFkMlwiLFxuICBvdmVybGVmdGhhcnBvb246IFwiXFx1MjFiY1wiLFxuICB4bGVmdGhhcnBvb251cDogXCJcXHUyMWJjXCIsXG4gIG92ZXJyaWdodGhhcnBvb246IFwiXFx1MjFjMFwiLFxuICB4cmlnaHRoYXJwb29udXA6IFwiXFx1MjFjMFwiLFxuICB4TGVmdGFycm93OiBcIlxcdTIxZDBcIixcbiAgeExlZnRyaWdodGFycm93OiBcIlxcdTIxZDRcIixcbiAgeGhvb2tsZWZ0YXJyb3c6IFwiXFx1MjFhOVwiLFxuICB4aG9va3JpZ2h0YXJyb3c6IFwiXFx1MjFhYVwiLFxuICB4bWFwc3RvOiBcIlxcdTIxYTZcIixcbiAgeHJpZ2h0aGFycG9vbmRvd246IFwiXFx1MjFjMVwiLFxuICB4bGVmdGhhcnBvb25kb3duOiBcIlxcdTIxYmRcIixcbiAgeHJpZ2h0bGVmdGhhcnBvb25zOiBcIlxcdTIxY2NcIixcbiAgeGxlZnRyaWdodGhhcnBvb25zOiBcIlxcdTIxY2JcIixcbiAgeHR3b2hlYWRsZWZ0YXJyb3c6IFwiXFx1MjE5ZVwiLFxuICB4dHdvaGVhZHJpZ2h0YXJyb3c6IFwiXFx1MjFhMFwiLFxuICB4bG9uZ2VxdWFsOiBcIj1cIixcbiAgeHRvZnJvbTogXCJcXHUyMWM0XCIsXG4gIHhyaWdodGxlZnRhcnJvd3M6IFwiXFx1MjFjNFwiLFxuICB4cmlnaHRlcXVpbGlicml1bTogXCJcXHUyMWNjXCIsXG4gIC8vIE5vdCBhIHBlcmZlY3QgbWF0Y2guXG4gIHhsZWZ0ZXF1aWxpYnJpdW06IFwiXFx1MjFjYlwiLFxuICAvLyBOb25lIGJldHRlciBhdmFpbGFibGUuXG4gIFwiXFxcXGNkcmlnaHRhcnJvd1wiOiBcIlxcdTIxOTJcIixcbiAgXCJcXFxcY2RsZWZ0YXJyb3dcIjogXCJcXHUyMTkwXCIsXG4gIFwiXFxcXGNkbG9uZ2VxdWFsXCI6IFwiPVwiXG59O1xuXG5jb25zdCBtYXRoTUxub2RlID0gZnVuY3Rpb24gKGxhYmVsKSB7XG4gIGNvbnN0IG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vXCIsIFtuZXcgbWF0aE1MVHJlZS5UZXh0Tm9kZShzdHJldGNoeUNvZGVQb2ludFtsYWJlbC5yZXBsYWNlKC9eXFxcXC8sICcnKV0pXSk7XG4gIG5vZGUuc2V0QXR0cmlidXRlKFwic3RyZXRjaHlcIiwgXCJ0cnVlXCIpO1xuICByZXR1cm4gbm9kZTtcbn07IC8vIE1hbnkgb2YgdGhlIEthVGVYIFNWRyBpbWFnZXMgaGF2ZSBiZWVuIGFkYXB0ZWQgZnJvbSBnbHlwaHMgaW4gS2FUZVggZm9udHMuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMDktMjAxMCwgRGVzaWduIFNjaWVuY2UsIEluYy4gKDx3d3cubWF0aGpheC5vcmc+KVxuLy8gQ29weXJpZ2h0IChjKSAyMDE0LTIwMTcgS2hhbiBBY2FkZW15ICg8d3d3LmtoYW5hY2FkZW15Lm9yZz4pXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgU0lMIE9wZW4gRm9udCBMaWNlbnNlLCBWZXJzaW9uIDEuMS5cbi8vIFNlZSBcXG5odHRwOi8vc2NyaXB0cy5zaWwub3JnL09GTFxuLy8gVmVyeSBMb25nIFNWR3Ncbi8vICAgIE1hbnkgb2YgdGhlIEthVGVYIHN0cmV0Y2h5IHdpZGUgZWxlbWVudHMgdXNlIGEgbG9uZyBTVkcgaW1hZ2UgYW5kIGFuXG4vLyAgICBvdmVyZmxvdzogaGlkZGVuIHRhY3RpYyB0byBhY2hpZXZlIGEgc3RyZXRjaHkgaW1hZ2Ugd2hpbGUgYXZvaWRpbmdcbi8vICAgIGRpc3RvcnRpb24gb2YgYXJyb3doZWFkcyBvciBicmFjZSBjb3JuZXJzLlxuLy8gICAgVGhlIFNWRyB0eXBpY2FsbHkgY29udGFpbnMgYSB2ZXJ5IGxvbmcgKDQwMCBlbSkgYXJyb3cuXG4vLyAgICBUaGUgU1ZHIGlzIGluIGEgY29udGFpbmVyIHNwYW4gdGhhdCBoYXMgb3ZlcmZsb3c6IGhpZGRlbiwgc28gdGhlIHNwYW5cbi8vICAgIGFjdHMgbGlrZSBhIHdpbmRvdyB0aGF0IGV4cG9zZXMgb25seSBwYXJ0IG9mIHRoZSAgU1ZHLlxuLy8gICAgVGhlIFNWRyBhbHdheXMgaGFzIGEgbG9uZ2VyLCB0aGlubmVyIGFzcGVjdCByYXRpbyB0aGFuIHRoZSBjb250YWluZXIgc3Bhbi5cbi8vICAgIEFmdGVyIHRoZSBTVkcgZmlsbHMgMTAwJSBvZiB0aGUgaGVpZ2h0IG9mIHRoZSBjb250YWluZXIgc3Bhbixcbi8vICAgIHRoZXJlIGlzIGEgbG9uZyBhcnJvdyBzaGFmdCBsZWZ0IG92ZXIuIFRoYXQgbGVmdC1vdmVyIHNoYWZ0IGlzIG5vdCBzaG93bi5cbi8vICAgIEluc3RlYWQsIGl0IGlzIHNsaWNlZCBvZmYgYmVjYXVzZSB0aGUgc3BhbidzIENTUyBoYXMgb3ZlcmZsb3c6IGhpZGRlbi5cbi8vICAgIFRodXMsIHRoZSByZWFkZXIgc2VlcyBhbiBhcnJvdyB0aGF0IG1hdGNoZXMgdGhlIHN1YmplY3QgbWF0dGVyIHdpZHRoXG4vLyAgICB3aXRob3V0IGRpc3RvcnRpb24uXG4vLyAgICBTb21lIGZ1bmN0aW9ucywgc3VjaCBhcyBcXGNhbmNlbCwgbmVlZCB0byB2YXJ5IHRoZWlyIGFzcGVjdCByYXRpby4gVGhlc2Vcbi8vICAgIGZ1bmN0aW9ucyBkbyBub3QgZ2V0IHRoZSBvdmVyZmxvdyBTVkcgdHJlYXRtZW50LlxuLy8gU2Vjb25kIEJydXNoIFN0cm9rZVxuLy8gICAgTG93IHJlc29sdXRpb24gbW9uaXRvcnMgc3RydWdnbGUgdG8gZGlzcGxheSBpbWFnZXMgaW4gZmluZSBkZXRhaWwuXG4vLyAgICBTbyBicm93c2VycyBhcHBseSBhbnRpLWFsaWFzaW5nLiBBIGxvbmcgc3RyYWlnaHQgYXJyb3cgc2hhZnQgdGhlcmVmb3JlXG4vLyAgICB3aWxsIHNvbWV0aW1lcyBhcHBlYXIgYXMgaWYgaXQgaGFzIGEgYmx1cnJlZCBlZGdlLlxuLy8gICAgVG8gbWl0aWdhdGUgdGhpcywgdGhlc2UgU1ZHIGZpbGVzIGNvbnRhaW4gYSBzZWNvbmQgXCJicnVzaC1zdHJva2VcIiBvbiB0aGVcbi8vICAgIGFycm93IHNoYWZ0cy4gVGhhdCBpcywgYSBzZWNvbmQgbG9uZyB0aGluIHJlY3Rhbmd1bGFyIFNWRyBwYXRoIGhhcyBiZWVuXG4vLyAgICB3cml0dGVuIGRpcmVjdGx5IG9uIHRvcCBvZiBlYWNoIGFycm93IHNoYWZ0LiBUaGlzIHJlaW5mb3JjZW1lbnQgY2F1c2VzXG4vLyAgICBzb21lIG9mIHRoZSBzY3JlZW4gcGl4ZWxzIHRvIGRpc3BsYXkgYXMgYmxhY2sgaW5zdGVhZCBvZiB0aGUgYW50aS1hbGlhc2VkXG4vLyAgICBncmF5IHBpeGVsIHRoYXQgYSAgc2luZ2xlIHBhdGggd291bGQgZ2VuZXJhdGUuIFNvIHdlIGdldCBhcnJvdyBzaGFmdHNcbi8vICAgIHdob3NlIGVkZ2VzIGFwcGVhciB0byBiZSBzaGFycGVyLlxuLy8gSW4gdGhlIGthdGV4SW1hZ2VzRGF0YSBvYmplY3QganVzdCBiZWxvdywgdGhlIGRpbWVuc2lvbnMgYWxsXG4vLyBjb3JyZXNwb25kIHRvIHBhdGggZ2VvbWV0cnkgaW5zaWRlIHRoZSByZWxldmFudCBTVkcuXG4vLyBGb3IgZXhhbXBsZSwgXFxvdmVycmlnaHRhcnJvdyB1c2VzIHRoZSBzYW1lIGFycm93aGVhZCBhcyBnbHlwaCBVKzIxOTJcbi8vIGZyb20gdGhlIEthVGVYIE1haW4gZm9udC4gVGhlIHNjYWxpbmcgZmFjdG9yIGlzIDEwMDAuXG4vLyBUaGF0IGlzLCBpbnNpZGUgdGhlIGZvbnQsIHRoYXQgYXJyb3doZWFkIGlzIDUyMiB1bml0cyB0YWxsLCB3aGljaFxuLy8gY29ycmVzcG9uZHMgdG8gMC41MjIgZW0gaW5zaWRlIHRoZSBkb2N1bWVudC5cblxuXG5jb25zdCBrYXRleEltYWdlc0RhdGEgPSB7XG4gIC8vICAgcGF0aChzKSwgbWluV2lkdGgsIGhlaWdodCwgYWxpZ25cbiAgb3ZlcnJpZ2h0YXJyb3c6IFtbXCJyaWdodGFycm93XCJdLCAwLjg4OCwgNTIyLCBcInhNYXhZTWluXCJdLFxuICBvdmVybGVmdGFycm93OiBbW1wibGVmdGFycm93XCJdLCAwLjg4OCwgNTIyLCBcInhNaW5ZTWluXCJdLFxuICB1bmRlcnJpZ2h0YXJyb3c6IFtbXCJyaWdodGFycm93XCJdLCAwLjg4OCwgNTIyLCBcInhNYXhZTWluXCJdLFxuICB1bmRlcmxlZnRhcnJvdzogW1tcImxlZnRhcnJvd1wiXSwgMC44ODgsIDUyMiwgXCJ4TWluWU1pblwiXSxcbiAgeHJpZ2h0YXJyb3c6IFtbXCJyaWdodGFycm93XCJdLCAxLjQ2OSwgNTIyLCBcInhNYXhZTWluXCJdLFxuICBcIlxcXFxjZHJpZ2h0YXJyb3dcIjogW1tcInJpZ2h0YXJyb3dcIl0sIDMuMCwgNTIyLCBcInhNYXhZTWluXCJdLFxuICAvLyBDRCBtaW53d2lkdGgyLjVwY1xuICB4bGVmdGFycm93OiBbW1wibGVmdGFycm93XCJdLCAxLjQ2OSwgNTIyLCBcInhNaW5ZTWluXCJdLFxuICBcIlxcXFxjZGxlZnRhcnJvd1wiOiBbW1wibGVmdGFycm93XCJdLCAzLjAsIDUyMiwgXCJ4TWluWU1pblwiXSxcbiAgT3ZlcnJpZ2h0YXJyb3c6IFtbXCJkb3VibGVyaWdodGFycm93XCJdLCAwLjg4OCwgNTYwLCBcInhNYXhZTWluXCJdLFxuICB4UmlnaHRhcnJvdzogW1tcImRvdWJsZXJpZ2h0YXJyb3dcIl0sIDEuNTI2LCA1NjAsIFwieE1heFlNaW5cIl0sXG4gIHhMZWZ0YXJyb3c6IFtbXCJkb3VibGVsZWZ0YXJyb3dcIl0sIDEuNTI2LCA1NjAsIFwieE1pbllNaW5cIl0sXG4gIG92ZXJsZWZ0aGFycG9vbjogW1tcImxlZnRoYXJwb29uXCJdLCAwLjg4OCwgNTIyLCBcInhNaW5ZTWluXCJdLFxuICB4bGVmdGhhcnBvb251cDogW1tcImxlZnRoYXJwb29uXCJdLCAwLjg4OCwgNTIyLCBcInhNaW5ZTWluXCJdLFxuICB4bGVmdGhhcnBvb25kb3duOiBbW1wibGVmdGhhcnBvb25kb3duXCJdLCAwLjg4OCwgNTIyLCBcInhNaW5ZTWluXCJdLFxuICBvdmVycmlnaHRoYXJwb29uOiBbW1wicmlnaHRoYXJwb29uXCJdLCAwLjg4OCwgNTIyLCBcInhNYXhZTWluXCJdLFxuICB4cmlnaHRoYXJwb29udXA6IFtbXCJyaWdodGhhcnBvb25cIl0sIDAuODg4LCA1MjIsIFwieE1heFlNaW5cIl0sXG4gIHhyaWdodGhhcnBvb25kb3duOiBbW1wicmlnaHRoYXJwb29uZG93blwiXSwgMC44ODgsIDUyMiwgXCJ4TWF4WU1pblwiXSxcbiAgeGxvbmdlcXVhbDogW1tcImxvbmdlcXVhbFwiXSwgMC44ODgsIDMzNCwgXCJ4TWluWU1pblwiXSxcbiAgXCJcXFxcY2Rsb25nZXF1YWxcIjogW1tcImxvbmdlcXVhbFwiXSwgMy4wLCAzMzQsIFwieE1pbllNaW5cIl0sXG4gIHh0d29oZWFkbGVmdGFycm93OiBbW1widHdvaGVhZGxlZnRhcnJvd1wiXSwgMC44ODgsIDMzNCwgXCJ4TWluWU1pblwiXSxcbiAgeHR3b2hlYWRyaWdodGFycm93OiBbW1widHdvaGVhZHJpZ2h0YXJyb3dcIl0sIDAuODg4LCAzMzQsIFwieE1heFlNaW5cIl0sXG4gIG92ZXJsZWZ0cmlnaHRhcnJvdzogW1tcImxlZnRhcnJvd1wiLCBcInJpZ2h0YXJyb3dcIl0sIDAuODg4LCA1MjJdLFxuICBvdmVyYnJhY2U6IFtbXCJsZWZ0YnJhY2VcIiwgXCJtaWRicmFjZVwiLCBcInJpZ2h0YnJhY2VcIl0sIDEuNiwgNTQ4XSxcbiAgdW5kZXJicmFjZTogW1tcImxlZnRicmFjZXVuZGVyXCIsIFwibWlkYnJhY2V1bmRlclwiLCBcInJpZ2h0YnJhY2V1bmRlclwiXSwgMS42LCA1NDhdLFxuICB1bmRlcmxlZnRyaWdodGFycm93OiBbW1wibGVmdGFycm93XCIsIFwicmlnaHRhcnJvd1wiXSwgMC44ODgsIDUyMl0sXG4gIHhsZWZ0cmlnaHRhcnJvdzogW1tcImxlZnRhcnJvd1wiLCBcInJpZ2h0YXJyb3dcIl0sIDEuNzUsIDUyMl0sXG4gIHhMZWZ0cmlnaHRhcnJvdzogW1tcImRvdWJsZWxlZnRhcnJvd1wiLCBcImRvdWJsZXJpZ2h0YXJyb3dcIl0sIDEuNzUsIDU2MF0sXG4gIHhyaWdodGxlZnRoYXJwb29uczogW1tcImxlZnRoYXJwb29uZG93bnBsdXNcIiwgXCJyaWdodGhhcnBvb25wbHVzXCJdLCAxLjc1LCA3MTZdLFxuICB4bGVmdHJpZ2h0aGFycG9vbnM6IFtbXCJsZWZ0aGFycG9vbnBsdXNcIiwgXCJyaWdodGhhcnBvb25kb3ducGx1c1wiXSwgMS43NSwgNzE2XSxcbiAgeGhvb2tsZWZ0YXJyb3c6IFtbXCJsZWZ0YXJyb3dcIiwgXCJyaWdodGhvb2tcIl0sIDEuMDgsIDUyMl0sXG4gIHhob29rcmlnaHRhcnJvdzogW1tcImxlZnRob29rXCIsIFwicmlnaHRhcnJvd1wiXSwgMS4wOCwgNTIyXSxcbiAgb3ZlcmxpbmVzZWdtZW50OiBbW1wibGVmdGxpbmVzZWdtZW50XCIsIFwicmlnaHRsaW5lc2VnbWVudFwiXSwgMC44ODgsIDUyMl0sXG4gIHVuZGVybGluZXNlZ21lbnQ6IFtbXCJsZWZ0bGluZXNlZ21lbnRcIiwgXCJyaWdodGxpbmVzZWdtZW50XCJdLCAwLjg4OCwgNTIyXSxcbiAgb3Zlcmdyb3VwOiBbW1wibGVmdGdyb3VwXCIsIFwicmlnaHRncm91cFwiXSwgMC44ODgsIDM0Ml0sXG4gIHVuZGVyZ3JvdXA6IFtbXCJsZWZ0Z3JvdXB1bmRlclwiLCBcInJpZ2h0Z3JvdXB1bmRlclwiXSwgMC44ODgsIDM0Ml0sXG4gIHhtYXBzdG86IFtbXCJsZWZ0bWFwc3RvXCIsIFwicmlnaHRhcnJvd1wiXSwgMS41LCA1MjJdLFxuICB4dG9mcm9tOiBbW1wibGVmdFRvRnJvbVwiLCBcInJpZ2h0VG9Gcm9tXCJdLCAxLjc1LCA1MjhdLFxuICAvLyBUaGUgbmV4dCB0aHJlZSBhcnJvd3MgYXJlIGZyb20gdGhlIG1oY2hlbSBwYWNrYWdlLlxuICAvLyBJbiBtaGNoZW0uc3R5LCBtaW4tbGVuZ3RoIGlzIDIuMGVtLiBCdXQgdGhlc2UgYXJyb3dzIG1pZ2h0IGFwcGVhciBpbiB0aGVcbiAgLy8gZG9jdW1lbnQgYXMgXFx4cmlnaHRhcnJvdyBvciBcXHhyaWdodGxlZnRoYXJwb29ucy4gVGhvc2UgaGF2ZVxuICAvLyBtaW4tbGVuZ3RoID0gMS43NWVtLCBzbyB3ZSBzZXQgbWluLWxlbmd0aCBvbiB0aGVzZSBuZXh0IHRocmVlIHRvIG1hdGNoLlxuICB4cmlnaHRsZWZ0YXJyb3dzOiBbW1wiYmFyYWJvdmVsZWZ0YXJyb3dcIiwgXCJyaWdodGFycm93YWJvdmViYXJcIl0sIDEuNzUsIDkwMV0sXG4gIHhyaWdodGVxdWlsaWJyaXVtOiBbW1wiYmFyYWJvdmVzaG9ydGxlZnRoYXJwb29uXCIsIFwicmlnaHRoYXJwb29uYWJvdmVzaG9ydGJhclwiXSwgMS43NSwgNzE2XSxcbiAgeGxlZnRlcXVpbGlicml1bTogW1tcInNob3J0YmFyYWJvdmVsZWZ0aGFycG9vblwiLCBcInNob3J0cmlnaHRoYXJwb29uYWJvdmViYXJcIl0sIDEuNzUsIDcxNl1cbn07XG5cbmNvbnN0IGdyb3VwTGVuZ3RoID0gZnVuY3Rpb24gKGFyZykge1xuICBpZiAoYXJnLnR5cGUgPT09IFwib3JkZ3JvdXBcIikge1xuICAgIHJldHVybiBhcmcuYm9keS5sZW5ndGg7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbn07XG5cbmNvbnN0IHN2Z1NwYW4gPSBmdW5jdGlvbiAoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgLy8gQ3JlYXRlIGEgc3BhbiB3aXRoIGlubGluZSBTVkcgZm9yIHRoZSBlbGVtZW50LlxuICBmdW5jdGlvbiBidWlsZFN2Z1NwYW5fKCkge1xuICAgIGxldCB2aWV3Qm94V2lkdGggPSA0MDAwMDA7IC8vIGRlZmF1bHRcblxuICAgIGNvbnN0IGxhYmVsID0gZ3JvdXAubGFiZWwuc2xpY2UoMSk7XG5cbiAgICBpZiAodXRpbHMuY29udGFpbnMoW1wid2lkZWhhdFwiLCBcIndpZGVjaGVja1wiLCBcIndpZGV0aWxkZVwiLCBcInV0aWxkZVwiXSwgbGFiZWwpKSB7XG4gICAgICAvLyBFYWNoIHR5cGUgaW4gdGhlIGBpZmAgc3RhdGVtZW50IGNvcnJlc3BvbmRzIHRvIG9uZSBvZiB0aGUgUGFyc2VOb2RlXG4gICAgICAvLyB0eXBlcyBiZWxvdy4gVGhpcyBuYXJyb3dpbmcgaXMgcmVxdWlyZWQgdG8gYWNjZXNzIGBncnAuYmFzZWAuXG4gICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICBjb25zdCBncnAgPSBncm91cDsgLy8gVGhlcmUgYXJlIGZvdXIgU1ZHIGltYWdlcyBhdmFpbGFibGUgZm9yIGVhY2ggZnVuY3Rpb24uXG4gICAgICAvLyBDaG9vc2UgYSB0YWxsZXIgaW1hZ2Ugd2hlbiB0aGVyZSBhcmUgbW9yZSBjaGFyYWN0ZXJzLlxuXG4gICAgICBjb25zdCBudW1DaGFycyA9IGdyb3VwTGVuZ3RoKGdycC5iYXNlKTtcbiAgICAgIGxldCB2aWV3Qm94SGVpZ2h0O1xuICAgICAgbGV0IHBhdGhOYW1lO1xuICAgICAgbGV0IGhlaWdodDtcblxuICAgICAgaWYgKG51bUNoYXJzID4gNSkge1xuICAgICAgICBpZiAobGFiZWwgPT09IFwid2lkZWhhdFwiIHx8IGxhYmVsID09PSBcIndpZGVjaGVja1wiKSB7XG4gICAgICAgICAgdmlld0JveEhlaWdodCA9IDQyMDtcbiAgICAgICAgICB2aWV3Qm94V2lkdGggPSAyMzY0O1xuICAgICAgICAgIGhlaWdodCA9IDAuNDI7XG4gICAgICAgICAgcGF0aE5hbWUgPSBsYWJlbCArIFwiNFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZpZXdCb3hIZWlnaHQgPSAzMTI7XG4gICAgICAgICAgdmlld0JveFdpZHRoID0gMjM0MDtcbiAgICAgICAgICBoZWlnaHQgPSAwLjM0O1xuICAgICAgICAgIHBhdGhOYW1lID0gXCJ0aWxkZTRcIjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgaW1nSW5kZXggPSBbMSwgMSwgMiwgMiwgMywgM11bbnVtQ2hhcnNdO1xuXG4gICAgICAgIGlmIChsYWJlbCA9PT0gXCJ3aWRlaGF0XCIgfHwgbGFiZWwgPT09IFwid2lkZWNoZWNrXCIpIHtcbiAgICAgICAgICB2aWV3Qm94V2lkdGggPSBbMCwgMTA2MiwgMjM2NCwgMjM2NCwgMjM2NF1baW1nSW5kZXhdO1xuICAgICAgICAgIHZpZXdCb3hIZWlnaHQgPSBbMCwgMjM5LCAzMDAsIDM2MCwgNDIwXVtpbWdJbmRleF07XG4gICAgICAgICAgaGVpZ2h0ID0gWzAsIDAuMjQsIDAuMywgMC4zLCAwLjM2LCAwLjQyXVtpbWdJbmRleF07XG4gICAgICAgICAgcGF0aE5hbWUgPSBsYWJlbCArIGltZ0luZGV4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZpZXdCb3hXaWR0aCA9IFswLCA2MDAsIDEwMzMsIDIzMzksIDIzNDBdW2ltZ0luZGV4XTtcbiAgICAgICAgICB2aWV3Qm94SGVpZ2h0ID0gWzAsIDI2MCwgMjg2LCAzMDYsIDMxMl1baW1nSW5kZXhdO1xuICAgICAgICAgIGhlaWdodCA9IFswLCAwLjI2LCAwLjI4NiwgMC4zLCAwLjMwNiwgMC4zNF1baW1nSW5kZXhdO1xuICAgICAgICAgIHBhdGhOYW1lID0gXCJ0aWxkZVwiICsgaW1nSW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgcGF0aCA9IG5ldyBQYXRoTm9kZShwYXRoTmFtZSk7XG4gICAgICBjb25zdCBzdmdOb2RlID0gbmV3IFN2Z05vZGUoW3BhdGhdLCB7XG4gICAgICAgIFwid2lkdGhcIjogXCIxMDAlXCIsXG4gICAgICAgIFwiaGVpZ2h0XCI6IG1ha2VFbShoZWlnaHQpLFxuICAgICAgICBcInZpZXdCb3hcIjogXCIwIDAgXCIgKyB2aWV3Qm94V2lkdGggKyBcIiBcIiArIHZpZXdCb3hIZWlnaHQsXG4gICAgICAgIFwicHJlc2VydmVBc3BlY3RSYXRpb1wiOiBcIm5vbmVcIlxuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzcGFuOiBidWlsZENvbW1vbi5tYWtlU3ZnU3BhbihbXSwgW3N2Z05vZGVdLCBvcHRpb25zKSxcbiAgICAgICAgbWluV2lkdGg6IDAsXG4gICAgICAgIGhlaWdodFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc3BhbnMgPSBbXTtcbiAgICAgIGNvbnN0IGRhdGEgPSBrYXRleEltYWdlc0RhdGFbbGFiZWxdO1xuICAgICAgY29uc3QgW3BhdGhzLCBtaW5XaWR0aCwgdmlld0JveEhlaWdodF0gPSBkYXRhO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gdmlld0JveEhlaWdodCAvIDEwMDA7XG4gICAgICBjb25zdCBudW1TdmdDaGlsZHJlbiA9IHBhdGhzLmxlbmd0aDtcbiAgICAgIGxldCB3aWR0aENsYXNzZXM7XG4gICAgICBsZXQgYWxpZ25zO1xuXG4gICAgICBpZiAobnVtU3ZnQ2hpbGRyZW4gPT09IDEpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZTogQWxsIHRoZXNlIGNhc2VzIG11c3QgYmUgb2YgdGhlIDQtdHVwbGUgdHlwZS5cbiAgICAgICAgY29uc3QgYWxpZ24xID0gZGF0YVszXTtcbiAgICAgICAgd2lkdGhDbGFzc2VzID0gW1wiaGlkZS10YWlsXCJdO1xuICAgICAgICBhbGlnbnMgPSBbYWxpZ24xXTtcbiAgICAgIH0gZWxzZSBpZiAobnVtU3ZnQ2hpbGRyZW4gPT09IDIpIHtcbiAgICAgICAgd2lkdGhDbGFzc2VzID0gW1wiaGFsZmFycm93LWxlZnRcIiwgXCJoYWxmYXJyb3ctcmlnaHRcIl07XG4gICAgICAgIGFsaWducyA9IFtcInhNaW5ZTWluXCIsIFwieE1heFlNaW5cIl07XG4gICAgICB9IGVsc2UgaWYgKG51bVN2Z0NoaWxkcmVuID09PSAzKSB7XG4gICAgICAgIHdpZHRoQ2xhc3NlcyA9IFtcImJyYWNlLWxlZnRcIiwgXCJicmFjZS1jZW50ZXJcIiwgXCJicmFjZS1yaWdodFwiXTtcbiAgICAgICAgYWxpZ25zID0gW1wieE1pbllNaW5cIiwgXCJ4TWlkWU1pblwiLCBcInhNYXhZTWluXCJdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29ycmVjdCBrYXRleEltYWdlc0RhdGEgb3IgdXBkYXRlIGNvZGUgaGVyZSB0byBzdXBwb3J0XFxuICAgICAgICAgICAgICAgICAgICBcIiArIG51bVN2Z0NoaWxkcmVuICsgXCIgY2hpbGRyZW4uXCIpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVN2Z0NoaWxkcmVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgcGF0aCA9IG5ldyBQYXRoTm9kZShwYXRoc1tpXSk7XG4gICAgICAgIGNvbnN0IHN2Z05vZGUgPSBuZXcgU3ZnTm9kZShbcGF0aF0sIHtcbiAgICAgICAgICBcIndpZHRoXCI6IFwiNDAwZW1cIixcbiAgICAgICAgICBcImhlaWdodFwiOiBtYWtlRW0oaGVpZ2h0KSxcbiAgICAgICAgICBcInZpZXdCb3hcIjogXCIwIDAgXCIgKyB2aWV3Qm94V2lkdGggKyBcIiBcIiArIHZpZXdCb3hIZWlnaHQsXG4gICAgICAgICAgXCJwcmVzZXJ2ZUFzcGVjdFJhdGlvXCI6IGFsaWduc1tpXSArIFwiIHNsaWNlXCJcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHNwYW4gPSBidWlsZENvbW1vbi5tYWtlU3ZnU3Bhbihbd2lkdGhDbGFzc2VzW2ldXSwgW3N2Z05vZGVdLCBvcHRpb25zKTtcblxuICAgICAgICBpZiAobnVtU3ZnQ2hpbGRyZW4gPT09IDEpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3BhbixcbiAgICAgICAgICAgIG1pbldpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzcGFuLnN0eWxlLmhlaWdodCA9IG1ha2VFbShoZWlnaHQpO1xuICAgICAgICAgIHNwYW5zLnB1c2goc3Bhbik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3BhbjogYnVpbGRDb21tb24ubWFrZVNwYW4oW1wic3RyZXRjaHlcIl0sIHNwYW5zLCBvcHRpb25zKSxcbiAgICAgICAgbWluV2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgfTtcbiAgICB9XG4gIH0gLy8gYnVpbGRTdmdTcGFuXygpXG5cblxuICBjb25zdCB7XG4gICAgc3BhbixcbiAgICBtaW5XaWR0aCxcbiAgICBoZWlnaHRcbiAgfSA9IGJ1aWxkU3ZnU3Bhbl8oKTsgLy8gTm90ZSB0aGF0IHdlIGFyZSByZXR1cm5pbmcgc3Bhbi5kZXB0aCA9IDAuXG4gIC8vIEFueSBhZGp1c3RtZW50cyByZWxhdGl2ZSB0byB0aGUgYmFzZWxpbmUgbXVzdCBiZSBkb25lIGluIGJ1aWxkSFRNTC5cblxuICBzcGFuLmhlaWdodCA9IGhlaWdodDtcbiAgc3Bhbi5zdHlsZS5oZWlnaHQgPSBtYWtlRW0oaGVpZ2h0KTtcblxuICBpZiAobWluV2lkdGggPiAwKSB7XG4gICAgc3Bhbi5zdHlsZS5taW5XaWR0aCA9IG1ha2VFbShtaW5XaWR0aCk7XG4gIH1cblxuICByZXR1cm4gc3Bhbjtcbn07XG5cbmNvbnN0IGVuY2xvc2VTcGFuID0gZnVuY3Rpb24gKGlubmVyLCBsYWJlbCwgdG9wUGFkLCBib3R0b21QYWQsIG9wdGlvbnMpIHtcbiAgLy8gUmV0dXJuIGFuIGltYWdlIHNwYW4gZm9yIFxcY2FuY2VsLCBcXGJjYW5jZWwsIFxceGNhbmNlbCwgXFxmYm94LCBvciBcXGFuZ2xcbiAgbGV0IGltZztcbiAgY29uc3QgdG90YWxIZWlnaHQgPSBpbm5lci5oZWlnaHQgKyBpbm5lci5kZXB0aCArIHRvcFBhZCArIGJvdHRvbVBhZDtcblxuICBpZiAoL2Zib3h8Y29sb3J8YW5nbC8udGVzdChsYWJlbCkpIHtcbiAgICBpbWcgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJzdHJldGNoeVwiLCBsYWJlbF0sIFtdLCBvcHRpb25zKTtcblxuICAgIGlmIChsYWJlbCA9PT0gXCJmYm94XCIpIHtcbiAgICAgIGNvbnN0IGNvbG9yID0gb3B0aW9ucy5jb2xvciAmJiBvcHRpb25zLmdldENvbG9yKCk7XG5cbiAgICAgIGlmIChjb2xvcikge1xuICAgICAgICBpbWcuc3R5bGUuYm9yZGVyQ29sb3IgPSBjb2xvcjtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gXFxjYW5jZWwsIFxcYmNhbmNlbCwgb3IgXFx4Y2FuY2VsXG4gICAgLy8gU2luY2UgXFxjYW5jZWwncyBTVkcgaXMgaW5saW5lIGFuZCBpdCBvbWl0cyB0aGUgdmlld0JveCBhdHRyaWJ1dGUsXG4gICAgLy8gaXRzIHN0cm9rZS13aWR0aCB3aWxsIG5vdCB2YXJ5IHdpdGggc3BhbiBhcmVhLlxuICAgIGNvbnN0IGxpbmVzID0gW107XG5cbiAgICBpZiAoL15bYnhdY2FuY2VsJC8udGVzdChsYWJlbCkpIHtcbiAgICAgIGxpbmVzLnB1c2gobmV3IExpbmVOb2RlKHtcbiAgICAgICAgXCJ4MVwiOiBcIjBcIixcbiAgICAgICAgXCJ5MVwiOiBcIjBcIixcbiAgICAgICAgXCJ4MlwiOiBcIjEwMCVcIixcbiAgICAgICAgXCJ5MlwiOiBcIjEwMCVcIixcbiAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogXCIwLjA0NmVtXCJcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBpZiAoL154P2NhbmNlbCQvLnRlc3QobGFiZWwpKSB7XG4gICAgICBsaW5lcy5wdXNoKG5ldyBMaW5lTm9kZSh7XG4gICAgICAgIFwieDFcIjogXCIwXCIsXG4gICAgICAgIFwieTFcIjogXCIxMDAlXCIsXG4gICAgICAgIFwieDJcIjogXCIxMDAlXCIsXG4gICAgICAgIFwieTJcIjogXCIwXCIsXG4gICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IFwiMC4wNDZlbVwiXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3ZnTm9kZSA9IG5ldyBTdmdOb2RlKGxpbmVzLCB7XG4gICAgICBcIndpZHRoXCI6IFwiMTAwJVwiLFxuICAgICAgXCJoZWlnaHRcIjogbWFrZUVtKHRvdGFsSGVpZ2h0KVxuICAgIH0pO1xuICAgIGltZyA9IGJ1aWxkQ29tbW9uLm1ha2VTdmdTcGFuKFtdLCBbc3ZnTm9kZV0sIG9wdGlvbnMpO1xuICB9XG5cbiAgaW1nLmhlaWdodCA9IHRvdGFsSGVpZ2h0O1xuICBpbWcuc3R5bGUuaGVpZ2h0ID0gbWFrZUVtKHRvdGFsSGVpZ2h0KTtcbiAgcmV0dXJuIGltZztcbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHN0cmV0Y2h5ID0gKHtcbiAgZW5jbG9zZVNwYW4sXG4gIG1hdGhNTG5vZGUsXG4gIHN2Z1NwYW5cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3BhcnNlTm9kZS5qc1xuXG5cbi8qKlxuICogQXNzZXJ0cyB0aGF0IHRoZSBub2RlIGlzIG9mIHRoZSBnaXZlbiB0eXBlIGFuZCByZXR1cm5zIGl0IHdpdGggc3RyaWN0ZXJcbiAqIHR5cGluZy4gVGhyb3dzIGlmIHRoZSBub2RlJ3MgdHlwZSBkb2VzIG5vdCBtYXRjaC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0Tm9kZVR5cGUobm9kZSwgdHlwZSkge1xuICBpZiAoIW5vZGUgfHwgbm9kZS50eXBlICE9PSB0eXBlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgbm9kZSBvZiB0eXBlIFwiICsgdHlwZSArIFwiLCBidXQgZ290IFwiICsgKG5vZGUgPyBcIm5vZGUgb2YgdHlwZSBcIiArIG5vZGUudHlwZSA6IFN0cmluZyhub2RlKSkpO1xuICB9IC8vICRGbG93Rml4TWUsID49MC4xMjVcblxuXG4gIHJldHVybiBub2RlO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBub2RlIG1vcmUgc3RyaWN0bHkgdHlwZWQgaWZmIGl0IGlzIG9mIHRoZSBnaXZlbiB0eXBlLiBPdGhlcndpc2UsXG4gKiByZXR1cm5zIG51bGwuXG4gKi9cblxuZnVuY3Rpb24gYXNzZXJ0U3ltYm9sTm9kZVR5cGUobm9kZSkge1xuICBjb25zdCB0eXBlZE5vZGUgPSBjaGVja1N5bWJvbE5vZGVUeXBlKG5vZGUpO1xuXG4gIGlmICghdHlwZWROb2RlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgbm9kZSBvZiBzeW1ib2wgZ3JvdXAgdHlwZSwgYnV0IGdvdCBcIiArIChub2RlID8gXCJub2RlIG9mIHR5cGUgXCIgKyBub2RlLnR5cGUgOiBTdHJpbmcobm9kZSkpKTtcbiAgfVxuXG4gIHJldHVybiB0eXBlZE5vZGU7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIG5vZGUgbW9yZSBzdHJpY3RseSB0eXBlZCBpZmYgaXQgaXMgb2YgdGhlIGdpdmVuIHR5cGUuIE90aGVyd2lzZSxcbiAqIHJldHVybnMgbnVsbC5cbiAqL1xuXG5mdW5jdGlvbiBjaGVja1N5bWJvbE5vZGVUeXBlKG5vZGUpIHtcbiAgaWYgKG5vZGUgJiYgKG5vZGUudHlwZSA9PT0gXCJhdG9tXCIgfHwgTk9OX0FUT01TLmhhc093blByb3BlcnR5KG5vZGUudHlwZSkpKSB7XG4gICAgLy8gJEZsb3dGaXhNZVxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZnVuY3Rpb25zL2FjY2VudC5qc1xuXG5cblxuXG5cblxuXG5cblxuXG4vLyBOT1RFOiBVbmxpa2UgbW9zdCBgaHRtbEJ1aWxkZXJgcywgdGhpcyBvbmUgaGFuZGxlcyBub3Qgb25seSBcImFjY2VudFwiLCBidXRcbi8vIGFsc28gXCJzdXBzdWJcIiBzaW5jZSBhbiBhY2NlbnQgY2FuIGFmZmVjdCBzdXBlci9zdWJzY3JpcHRpbmcuXG5jb25zdCBodG1sQnVpbGRlciA9IChncnAsIG9wdGlvbnMpID0+IHtcbiAgLy8gQWNjZW50cyBhcmUgaGFuZGxlZCBpbiB0aGUgVGVYYm9vayBwZy4gNDQzLCBydWxlIDEyLlxuICBsZXQgYmFzZTtcbiAgbGV0IGdyb3VwO1xuICBsZXQgc3VwU3ViR3JvdXA7XG5cbiAgaWYgKGdycCAmJiBncnAudHlwZSA9PT0gXCJzdXBzdWJcIikge1xuICAgIC8vIElmIG91ciBiYXNlIGlzIGEgY2hhcmFjdGVyIGJveCwgYW5kIHdlIGhhdmUgc3VwZXJzY3JpcHRzIGFuZFxuICAgIC8vIHN1YnNjcmlwdHMsIHRoZSBzdXBzdWIgd2lsbCBkZWZlciB0byB1cy4gSW4gcGFydGljdWxhciwgd2Ugd2FudFxuICAgIC8vIHRvIGF0dGFjaCB0aGUgc3VwZXJzY3JpcHRzIGFuZCBzdWJzY3JpcHRzIHRvIHRoZSBpbm5lciBib2R5IChzb1xuICAgIC8vIHRoYXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBzdXBlcnNjcmlwdHMgYW5kIHN1YnNjcmlwdHMgd29uJ3QgYmVcbiAgICAvLyBhZmZlY3RlZCBieSB0aGUgaGVpZ2h0IG9mIHRoZSBhY2NlbnQpLiBXZSBhY2NvbXBsaXNoIHRoaXMgYnlcbiAgICAvLyBzdGlja2luZyB0aGUgYmFzZSBvZiB0aGUgYWNjZW50IGludG8gdGhlIGJhc2Ugb2YgdGhlIHN1cHN1YiwgYW5kXG4gICAgLy8gcmVuZGVyaW5nIHRoYXQsIHdoaWxlIGtlZXBpbmcgdHJhY2sgb2Ygd2hlcmUgdGhlIGFjY2VudCBpcy5cbiAgICAvLyBUaGUgcmVhbCBhY2NlbnQgZ3JvdXAgaXMgdGhlIGJhc2Ugb2YgdGhlIHN1cHN1YiBncm91cFxuICAgIGdyb3VwID0gYXNzZXJ0Tm9kZVR5cGUoZ3JwLmJhc2UsIFwiYWNjZW50XCIpOyAvLyBUaGUgY2hhcmFjdGVyIGJveCBpcyB0aGUgYmFzZSBvZiB0aGUgYWNjZW50IGdyb3VwXG5cbiAgICBiYXNlID0gZ3JvdXAuYmFzZTsgLy8gU3RpY2sgdGhlIGNoYXJhY3RlciBib3ggaW50byB0aGUgYmFzZSBvZiB0aGUgc3Vwc3ViIGdyb3VwXG5cbiAgICBncnAuYmFzZSA9IGJhc2U7IC8vIFJlcmVuZGVyIHRoZSBzdXBzdWIgZ3JvdXAgd2l0aCBpdHMgbmV3IGJhc2UsIGFuZCBzdG9yZSB0aGF0XG4gICAgLy8gcmVzdWx0LlxuXG4gICAgc3VwU3ViR3JvdXAgPSBhc3NlcnRTcGFuKGJ1aWxkR3JvdXAoZ3JwLCBvcHRpb25zKSk7IC8vIHJlc2V0IG9yaWdpbmFsIGJhc2VcblxuICAgIGdycC5iYXNlID0gZ3JvdXA7XG4gIH0gZWxzZSB7XG4gICAgZ3JvdXAgPSBhc3NlcnROb2RlVHlwZShncnAsIFwiYWNjZW50XCIpO1xuICAgIGJhc2UgPSBncm91cC5iYXNlO1xuICB9IC8vIEJ1aWxkIHRoZSBiYXNlIGdyb3VwXG5cblxuICBjb25zdCBib2R5ID0gYnVpbGRHcm91cChiYXNlLCBvcHRpb25zLmhhdmluZ0NyYW1wZWRTdHlsZSgpKTsgLy8gRG9lcyB0aGUgYWNjZW50IG5lZWQgdG8gc2hpZnQgZm9yIHRoZSBza2V3IG9mIGEgY2hhcmFjdGVyP1xuXG4gIGNvbnN0IG11c3RTaGlmdCA9IGdyb3VwLmlzU2hpZnR5ICYmIHV0aWxzLmlzQ2hhcmFjdGVyQm94KGJhc2UpOyAvLyBDYWxjdWxhdGUgdGhlIHNrZXcgb2YgdGhlIGFjY2VudC4gVGhpcyBpcyBiYXNlZCBvbiB0aGUgbGluZSBcIklmIHRoZVxuICAvLyBudWNsZXVzIGlzIG5vdCBhIHNpbmdsZSBjaGFyYWN0ZXIsIGxldCBzID0gMDsgb3RoZXJ3aXNlIHNldCBzIHRvIHRoZVxuICAvLyBrZXJuIGFtb3VudCBmb3IgdGhlIG51Y2xldXMgZm9sbG93ZWQgYnkgdGhlIFxcc2tld2NoYXIgb2YgaXRzIGZvbnQuXCJcbiAgLy8gTm90ZSB0aGF0IG91ciBza2V3IG1ldHJpY3MgYXJlIGp1c3QgdGhlIGtlcm4gYmV0d2VlbiBlYWNoIGNoYXJhY3RlclxuICAvLyBhbmQgdGhlIHNrZXdjaGFyLlxuXG4gIGxldCBza2V3ID0gMDtcblxuICBpZiAobXVzdFNoaWZ0KSB7XG4gICAgLy8gSWYgdGhlIGJhc2UgaXMgYSBjaGFyYWN0ZXIgYm94LCB0aGVuIHdlIHdhbnQgdGhlIHNrZXcgb2YgdGhlXG4gICAgLy8gaW5uZXJtb3N0IGNoYXJhY3Rlci4gVG8gZG8gdGhhdCwgd2UgZmluZCB0aGUgaW5uZXJtb3N0IGNoYXJhY3RlcjpcbiAgICBjb25zdCBiYXNlQ2hhciA9IHV0aWxzLmdldEJhc2VFbGVtKGJhc2UpOyAvLyBUaGVuLCB3ZSByZW5kZXIgaXRzIGdyb3VwIHRvIGdldCB0aGUgc3ltYm9sIGluc2lkZSBpdFxuXG4gICAgY29uc3QgYmFzZUdyb3VwID0gYnVpbGRHcm91cChiYXNlQ2hhciwgb3B0aW9ucy5oYXZpbmdDcmFtcGVkU3R5bGUoKSk7IC8vIEZpbmFsbHksIHdlIHB1bGwgdGhlIHNrZXcgb2ZmIG9mIHRoZSBzeW1ib2wuXG5cbiAgICBza2V3ID0gYXNzZXJ0U3ltYm9sRG9tTm9kZShiYXNlR3JvdXApLnNrZXc7IC8vIE5vdGUgdGhhdCB3ZSBub3cgdGhyb3cgYXdheSBiYXNlR3JvdXAsIGJlY2F1c2UgdGhlIGxheWVycyB3ZVxuICAgIC8vIHJlbW92ZWQgd2l0aCBnZXRCYXNlRWxlbSBtaWdodCBjb250YWluIHRoaW5ncyBsaWtlIFxcY29sb3Igd2hpY2hcbiAgICAvLyB3ZSBjYW4ndCBnZXQgcmlkIG9mLlxuICAgIC8vIFRPRE8oZW1pbHkpOiBGaW5kIGEgYmV0dGVyIHdheSB0byBnZXQgdGhlIHNrZXdcbiAgfVxuXG4gIGNvbnN0IGFjY2VudEJlbG93ID0gZ3JvdXAubGFiZWwgPT09IFwiXFxcXGNcIjsgLy8gY2FsY3VsYXRlIHRoZSBhbW91bnQgb2Ygc3BhY2UgYmV0d2VlbiB0aGUgYm9keSBhbmQgdGhlIGFjY2VudFxuXG4gIGxldCBjbGVhcmFuY2UgPSBhY2NlbnRCZWxvdyA/IGJvZHkuaGVpZ2h0ICsgYm9keS5kZXB0aCA6IE1hdGgubWluKGJvZHkuaGVpZ2h0LCBvcHRpb25zLmZvbnRNZXRyaWNzKCkueEhlaWdodCk7IC8vIEJ1aWxkIHRoZSBhY2NlbnRcblxuICBsZXQgYWNjZW50Qm9keTtcblxuICBpZiAoIWdyb3VwLmlzU3RyZXRjaHkpIHtcbiAgICBsZXQgYWNjZW50O1xuICAgIGxldCB3aWR0aDtcblxuICAgIGlmIChncm91cC5sYWJlbCA9PT0gXCJcXFxcdmVjXCIpIHtcbiAgICAgIC8vIEJlZm9yZSB2ZXJzaW9uIDAuOSwgXFx2ZWMgdXNlZCB0aGUgY29tYmluaW5nIGZvbnQgZ2x5cGggVSsyMEQ3LlxuICAgICAgLy8gQnV0IGJyb3dzZXJzLCBlc3BlY2lhbGx5IFNhZmFyaSwgYXJlIG5vdCBjb25zaXN0ZW50IGluIGhvdyB0aGV5XG4gICAgICAvLyByZW5kZXIgY29tYmluaW5nIGNoYXJhY3RlcnMgd2hlbiBub3QgcHJlY2VkZWQgYnkgYSBjaGFyYWN0ZXIuXG4gICAgICAvLyBTbyBub3cgd2UgdXNlIGFuIFNWRy5cbiAgICAgIC8vIElmIFNhZmFyaSByZWZvcm1zLCB3ZSBzaG91bGQgY29uc2lkZXIgcmV2ZXJ0aW5nIHRvIHRoZSBnbHlwaC5cbiAgICAgIGFjY2VudCA9IGJ1aWxkQ29tbW9uLnN0YXRpY1N2ZyhcInZlY1wiLCBvcHRpb25zKTtcbiAgICAgIHdpZHRoID0gYnVpbGRDb21tb24uc3ZnRGF0YS52ZWNbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjY2VudCA9IGJ1aWxkQ29tbW9uLm1ha2VPcmQoe1xuICAgICAgICBtb2RlOiBncm91cC5tb2RlLFxuICAgICAgICB0ZXh0OiBncm91cC5sYWJlbFxuICAgICAgfSwgb3B0aW9ucywgXCJ0ZXh0b3JkXCIpO1xuICAgICAgYWNjZW50ID0gYXNzZXJ0U3ltYm9sRG9tTm9kZShhY2NlbnQpOyAvLyBSZW1vdmUgdGhlIGl0YWxpYyBjb3JyZWN0aW9uIG9mIHRoZSBhY2NlbnQsIGJlY2F1c2UgaXQgb25seSBzZXJ2ZXMgdG9cbiAgICAgIC8vIHNoaWZ0IHRoZSBhY2NlbnQgb3ZlciB0byBhIHBsYWNlIHdlIGRvbid0IHdhbnQuXG5cbiAgICAgIGFjY2VudC5pdGFsaWMgPSAwO1xuICAgICAgd2lkdGggPSBhY2NlbnQud2lkdGg7XG5cbiAgICAgIGlmIChhY2NlbnRCZWxvdykge1xuICAgICAgICBjbGVhcmFuY2UgKz0gYWNjZW50LmRlcHRoO1xuICAgICAgfVxuICAgIH1cblxuICAgIGFjY2VudEJvZHkgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJhY2NlbnQtYm9keVwiXSwgW2FjY2VudF0pOyAvLyBcIkZ1bGxcIiBhY2NlbnRzIGV4cGFuZCB0aGUgd2lkdGggb2YgdGhlIHJlc3VsdGluZyBzeW1ib2wgdG8gYmVcbiAgICAvLyBhdCBsZWFzdCB0aGUgd2lkdGggb2YgdGhlIGFjY2VudCwgYW5kIG92ZXJsYXAgZGlyZWN0bHkgb250byB0aGVcbiAgICAvLyBjaGFyYWN0ZXIgd2l0aG91dCBhbnkgdmVydGljYWwgb2Zmc2V0LlxuXG4gICAgY29uc3QgYWNjZW50RnVsbCA9IGdyb3VwLmxhYmVsID09PSBcIlxcXFx0ZXh0Y2lyY2xlZFwiO1xuXG4gICAgaWYgKGFjY2VudEZ1bGwpIHtcbiAgICAgIGFjY2VudEJvZHkuY2xhc3Nlcy5wdXNoKCdhY2NlbnQtZnVsbCcpO1xuICAgICAgY2xlYXJhbmNlID0gYm9keS5oZWlnaHQ7XG4gICAgfSAvLyBTaGlmdCB0aGUgYWNjZW50IG92ZXIgYnkgdGhlIHNrZXcuXG5cblxuICAgIGxldCBsZWZ0ID0gc2tldzsgLy8gQ1NTIGRlZmluZXMgYC5rYXRleCAuYWNjZW50IC5hY2NlbnQtYm9keTpub3QoLmFjY2VudC1mdWxsKSB7IHdpZHRoOiAwIH1gXG4gICAgLy8gc28gdGhhdCB0aGUgYWNjZW50IGRvZXNuJ3QgY29udHJpYnV0ZSB0byB0aGUgYm91bmRpbmcgYm94LlxuICAgIC8vIFdlIG5lZWQgdG8gc2hpZnQgdGhlIGNoYXJhY3RlciBieSBpdHMgd2lkdGggKGVmZmVjdGl2ZWx5IGhhbGZcbiAgICAvLyBpdHMgd2lkdGgpIHRvIGNvbXBlbnNhdGUuXG5cbiAgICBpZiAoIWFjY2VudEZ1bGwpIHtcbiAgICAgIGxlZnQgLT0gd2lkdGggLyAyO1xuICAgIH1cblxuICAgIGFjY2VudEJvZHkuc3R5bGUubGVmdCA9IG1ha2VFbShsZWZ0KTsgLy8gXFx0ZXh0Y2lyY2xlZCB1c2VzIHRoZSBcXGJpZ2NpcmMgZ2x5cGgsIHNvIGl0IG5lZWRzIHNvbWVcbiAgICAvLyB2ZXJ0aWNhbCBhZGp1c3RtZW50IHRvIG1hdGNoIExhVGVYLlxuXG4gICAgaWYgKGdyb3VwLmxhYmVsID09PSBcIlxcXFx0ZXh0Y2lyY2xlZFwiKSB7XG4gICAgICBhY2NlbnRCb2R5LnN0eWxlLnRvcCA9IFwiLjJlbVwiO1xuICAgIH1cblxuICAgIGFjY2VudEJvZHkgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgcG9zaXRpb25UeXBlOiBcImZpcnN0QmFzZWxpbmVcIixcbiAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogYm9keVxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImtlcm5cIixcbiAgICAgICAgc2l6ZTogLWNsZWFyYW5jZVxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogYWNjZW50Qm9keVxuICAgICAgfV1cbiAgICB9LCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICBhY2NlbnRCb2R5ID0gc3RyZXRjaHkuc3ZnU3Bhbihncm91cCwgb3B0aW9ucyk7XG4gICAgYWNjZW50Qm9keSA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICBwb3NpdGlvblR5cGU6IFwiZmlyc3RCYXNlbGluZVwiLFxuICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBib2R5XG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBhY2NlbnRCb2R5LFxuICAgICAgICB3cmFwcGVyQ2xhc3NlczogW1wic3ZnLWFsaWduXCJdLFxuICAgICAgICB3cmFwcGVyU3R5bGU6IHNrZXcgPiAwID8ge1xuICAgICAgICAgIHdpZHRoOiBcImNhbGMoMTAwJSAtIFwiICsgbWFrZUVtKDIgKiBza2V3KSArIFwiKVwiLFxuICAgICAgICAgIG1hcmdpbkxlZnQ6IG1ha2VFbSgyICogc2tldylcbiAgICAgICAgfSA6IHVuZGVmaW5lZFxuICAgICAgfV1cbiAgICB9LCBvcHRpb25zKTtcbiAgfVxuXG4gIGNvbnN0IGFjY2VudFdyYXAgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtb3JkXCIsIFwiYWNjZW50XCJdLCBbYWNjZW50Qm9keV0sIG9wdGlvbnMpO1xuXG4gIGlmIChzdXBTdWJHcm91cCkge1xuICAgIC8vIEhlcmUsIHdlIHJlcGxhY2UgdGhlIFwiYmFzZVwiIGNoaWxkIG9mIHRoZSBzdXBzdWIgd2l0aCBvdXIgbmV3bHlcbiAgICAvLyBnZW5lcmF0ZWQgYWNjZW50LlxuICAgIHN1cFN1Ykdyb3VwLmNoaWxkcmVuWzBdID0gYWNjZW50V3JhcDsgLy8gU2luY2Ugd2UgZG9uJ3QgcmVydW4gdGhlIGhlaWdodCBjYWxjdWxhdGlvbiBhZnRlciByZXBsYWNpbmcgdGhlXG4gICAgLy8gYWNjZW50LCB3ZSBtYW51YWxseSByZWNhbGN1bGF0ZSBoZWlnaHQuXG5cbiAgICBzdXBTdWJHcm91cC5oZWlnaHQgPSBNYXRoLm1heChhY2NlbnRXcmFwLmhlaWdodCwgc3VwU3ViR3JvdXAuaGVpZ2h0KTsgLy8gQWNjZW50cyBzaG91bGQgYWx3YXlzIGJlIG9yZHMsIGV2ZW4gd2hlbiB0aGVpciBpbm5hcmRzIGFyZSBub3QuXG5cbiAgICBzdXBTdWJHcm91cC5jbGFzc2VzWzBdID0gXCJtb3JkXCI7XG4gICAgcmV0dXJuIHN1cFN1Ykdyb3VwO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhY2NlbnRXcmFwO1xuICB9XG59O1xuXG5jb25zdCBtYXRobWxCdWlsZGVyID0gKGdyb3VwLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IGFjY2VudE5vZGUgPSBncm91cC5pc1N0cmV0Y2h5ID8gc3RyZXRjaHkubWF0aE1Mbm9kZShncm91cC5sYWJlbCkgOiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vXCIsIFttYWtlVGV4dChncm91cC5sYWJlbCwgZ3JvdXAubW9kZSldKTtcbiAgY29uc3Qgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW92ZXJcIiwgW2J1aWxkTWF0aE1MX2J1aWxkR3JvdXAoZ3JvdXAuYmFzZSwgb3B0aW9ucyksIGFjY2VudE5vZGVdKTtcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJhY2NlbnRcIiwgXCJ0cnVlXCIpO1xuICByZXR1cm4gbm9kZTtcbn07XG5cbmNvbnN0IE5PTl9TVFJFVENIWV9BQ0NFTlRfUkVHRVggPSBuZXcgUmVnRXhwKFtcIlxcXFxhY3V0ZVwiLCBcIlxcXFxncmF2ZVwiLCBcIlxcXFxkZG90XCIsIFwiXFxcXHRpbGRlXCIsIFwiXFxcXGJhclwiLCBcIlxcXFxicmV2ZVwiLCBcIlxcXFxjaGVja1wiLCBcIlxcXFxoYXRcIiwgXCJcXFxcdmVjXCIsIFwiXFxcXGRvdFwiLCBcIlxcXFxtYXRocmluZ1wiXS5tYXAoYWNjZW50ID0+IFwiXFxcXFwiICsgYWNjZW50KS5qb2luKFwifFwiKSk7IC8vIEFjY2VudHNcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImFjY2VudFwiLFxuICBuYW1lczogW1wiXFxcXGFjdXRlXCIsIFwiXFxcXGdyYXZlXCIsIFwiXFxcXGRkb3RcIiwgXCJcXFxcdGlsZGVcIiwgXCJcXFxcYmFyXCIsIFwiXFxcXGJyZXZlXCIsIFwiXFxcXGNoZWNrXCIsIFwiXFxcXGhhdFwiLCBcIlxcXFx2ZWNcIiwgXCJcXFxcZG90XCIsIFwiXFxcXG1hdGhyaW5nXCIsIFwiXFxcXHdpZGVjaGVja1wiLCBcIlxcXFx3aWRlaGF0XCIsIFwiXFxcXHdpZGV0aWxkZVwiLCBcIlxcXFxvdmVycmlnaHRhcnJvd1wiLCBcIlxcXFxvdmVybGVmdGFycm93XCIsIFwiXFxcXE92ZXJyaWdodGFycm93XCIsIFwiXFxcXG92ZXJsZWZ0cmlnaHRhcnJvd1wiLCBcIlxcXFxvdmVyZ3JvdXBcIiwgXCJcXFxcb3ZlcmxpbmVzZWdtZW50XCIsIFwiXFxcXG92ZXJsZWZ0aGFycG9vblwiLCBcIlxcXFxvdmVycmlnaHRoYXJwb29uXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDFcbiAgfSxcbiAgaGFuZGxlcjogKGNvbnRleHQsIGFyZ3MpID0+IHtcbiAgICBjb25zdCBiYXNlID0gbm9ybWFsaXplQXJndW1lbnQoYXJnc1swXSk7XG4gICAgY29uc3QgaXNTdHJldGNoeSA9ICFOT05fU1RSRVRDSFlfQUNDRU5UX1JFR0VYLnRlc3QoY29udGV4dC5mdW5jTmFtZSk7XG4gICAgY29uc3QgaXNTaGlmdHkgPSAhaXNTdHJldGNoeSB8fCBjb250ZXh0LmZ1bmNOYW1lID09PSBcIlxcXFx3aWRlaGF0XCIgfHwgY29udGV4dC5mdW5jTmFtZSA9PT0gXCJcXFxcd2lkZXRpbGRlXCIgfHwgY29udGV4dC5mdW5jTmFtZSA9PT0gXCJcXFxcd2lkZWNoZWNrXCI7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiYWNjZW50XCIsXG4gICAgICBtb2RlOiBjb250ZXh0LnBhcnNlci5tb2RlLFxuICAgICAgbGFiZWw6IGNvbnRleHQuZnVuY05hbWUsXG4gICAgICBpc1N0cmV0Y2h5OiBpc1N0cmV0Y2h5LFxuICAgICAgaXNTaGlmdHk6IGlzU2hpZnR5LFxuICAgICAgYmFzZTogYmFzZVxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyLFxuICBtYXRobWxCdWlsZGVyXG59KTsgLy8gVGV4dC1tb2RlIGFjY2VudHNcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImFjY2VudFwiLFxuICBuYW1lczogW1wiXFxcXCdcIiwgXCJcXFxcYFwiLCBcIlxcXFxeXCIsIFwiXFxcXH5cIiwgXCJcXFxcPVwiLCBcIlxcXFx1XCIsIFwiXFxcXC5cIiwgJ1xcXFxcIicsIFwiXFxcXGNcIiwgXCJcXFxcclwiLCBcIlxcXFxIXCIsIFwiXFxcXHZcIiwgXCJcXFxcdGV4dGNpcmNsZWRcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlLFxuICAgIGFsbG93ZWRJbk1hdGg6IHRydWUsXG4gICAgLy8gdW5sZXNzIGluIHN0cmljdCBtb2RlXG4gICAgYXJnVHlwZXM6IFtcInByaW1pdGl2ZVwiXVxuICB9LFxuICBoYW5kbGVyOiAoY29udGV4dCwgYXJncykgPT4ge1xuICAgIGNvbnN0IGJhc2UgPSBhcmdzWzBdO1xuICAgIGxldCBtb2RlID0gY29udGV4dC5wYXJzZXIubW9kZTtcblxuICAgIGlmIChtb2RlID09PSBcIm1hdGhcIikge1xuICAgICAgY29udGV4dC5wYXJzZXIuc2V0dGluZ3MucmVwb3J0Tm9uc3RyaWN0KFwibWF0aFZzVGV4dEFjY2VudHNcIiwgXCJMYVRlWCdzIGFjY2VudCBcIiArIGNvbnRleHQuZnVuY05hbWUgKyBcIiB3b3JrcyBvbmx5IGluIHRleHQgbW9kZVwiKTtcbiAgICAgIG1vZGUgPSBcInRleHRcIjtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJhY2NlbnRcIixcbiAgICAgIG1vZGU6IG1vZGUsXG4gICAgICBsYWJlbDogY29udGV4dC5mdW5jTmFtZSxcbiAgICAgIGlzU3RyZXRjaHk6IGZhbHNlLFxuICAgICAgaXNTaGlmdHk6IHRydWUsXG4gICAgICBiYXNlOiBiYXNlXG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXIsXG4gIG1hdGhtbEJ1aWxkZXJcbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy9hY2NlbnR1bmRlci5qc1xuLy8gSG9yaXpvbnRhbCBvdmVybGFwIGZ1bmN0aW9uc1xuXG5cblxuXG5cblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImFjY2VudFVuZGVyXCIsXG4gIG5hbWVzOiBbXCJcXFxcdW5kZXJsZWZ0YXJyb3dcIiwgXCJcXFxcdW5kZXJyaWdodGFycm93XCIsIFwiXFxcXHVuZGVybGVmdHJpZ2h0YXJyb3dcIiwgXCJcXFxcdW5kZXJncm91cFwiLCBcIlxcXFx1bmRlcmxpbmVzZWdtZW50XCIsIFwiXFxcXHV0aWxkZVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxXG4gIH0sXG4gIGhhbmRsZXI6IChfcmVmLCBhcmdzKSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIHBhcnNlcixcbiAgICAgIGZ1bmNOYW1lXG4gICAgfSA9IF9yZWY7XG4gICAgY29uc3QgYmFzZSA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiYWNjZW50VW5kZXJcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbGFiZWw6IGZ1bmNOYW1lLFxuICAgICAgYmFzZTogYmFzZVxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgICAvLyBUcmVhdCB1bmRlciBhY2NlbnRzIG11Y2ggbGlrZSB1bmRlcmxpbmVzLlxuICAgIGNvbnN0IGlubmVyR3JvdXAgPSBidWlsZEdyb3VwKGdyb3VwLmJhc2UsIG9wdGlvbnMpO1xuICAgIGNvbnN0IGFjY2VudEJvZHkgPSBzdHJldGNoeS5zdmdTcGFuKGdyb3VwLCBvcHRpb25zKTtcbiAgICBjb25zdCBrZXJuID0gZ3JvdXAubGFiZWwgPT09IFwiXFxcXHV0aWxkZVwiID8gMC4xMiA6IDA7IC8vIEdlbmVyYXRlIHRoZSB2bGlzdCwgd2l0aCB0aGUgYXBwcm9wcmlhdGUga2VybnNcblxuICAgIGNvbnN0IHZsaXN0ID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHtcbiAgICAgIHBvc2l0aW9uVHlwZTogXCJ0b3BcIixcbiAgICAgIHBvc2l0aW9uRGF0YTogaW5uZXJHcm91cC5oZWlnaHQsXG4gICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IGFjY2VudEJvZHksXG4gICAgICAgIHdyYXBwZXJDbGFzc2VzOiBbXCJzdmctYWxpZ25cIl1cbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJrZXJuXCIsXG4gICAgICAgIHNpemU6IGtlcm5cbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IGlubmVyR3JvdXBcbiAgICAgIH1dXG4gICAgfSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1vcmRcIiwgXCJhY2NlbnR1bmRlclwiXSwgW3ZsaXN0XSwgb3B0aW9ucyk7XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IChncm91cCwgb3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IGFjY2VudE5vZGUgPSBzdHJldGNoeS5tYXRoTUxub2RlKGdyb3VwLmxhYmVsKTtcbiAgICBjb25zdCBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdW5kZXJcIiwgW2J1aWxkTWF0aE1MX2J1aWxkR3JvdXAoZ3JvdXAuYmFzZSwgb3B0aW9ucyksIGFjY2VudE5vZGVdKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcImFjY2VudHVuZGVyXCIsIFwidHJ1ZVwiKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZnVuY3Rpb25zL2Fycm93LmpzXG5cblxuXG5cblxuXG5cbi8vIEhlbHBlciBmdW5jdGlvblxuY29uc3QgcGFkZGVkTm9kZSA9IGdyb3VwID0+IHtcbiAgY29uc3Qgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXBhZGRlZFwiLCBncm91cCA/IFtncm91cF0gOiBbXSk7XG4gIG5vZGUuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgXCIrMC42ZW1cIik7XG4gIG5vZGUuc2V0QXR0cmlidXRlKFwibHNwYWNlXCIsIFwiMC4zZW1cIik7XG4gIHJldHVybiBub2RlO1xufTsgLy8gU3RyZXRjaHkgYXJyb3dzIHdpdGggYW4gb3B0aW9uYWwgYXJndW1lbnRcblxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwieEFycm93XCIsXG4gIG5hbWVzOiBbXCJcXFxceGxlZnRhcnJvd1wiLCBcIlxcXFx4cmlnaHRhcnJvd1wiLCBcIlxcXFx4TGVmdGFycm93XCIsIFwiXFxcXHhSaWdodGFycm93XCIsIFwiXFxcXHhsZWZ0cmlnaHRhcnJvd1wiLCBcIlxcXFx4TGVmdHJpZ2h0YXJyb3dcIiwgXCJcXFxceGhvb2tsZWZ0YXJyb3dcIiwgXCJcXFxceGhvb2tyaWdodGFycm93XCIsIFwiXFxcXHhtYXBzdG9cIiwgXCJcXFxceHJpZ2h0aGFycG9vbmRvd25cIiwgXCJcXFxceHJpZ2h0aGFycG9vbnVwXCIsIFwiXFxcXHhsZWZ0aGFycG9vbmRvd25cIiwgXCJcXFxceGxlZnRoYXJwb29udXBcIiwgXCJcXFxceHJpZ2h0bGVmdGhhcnBvb25zXCIsIFwiXFxcXHhsZWZ0cmlnaHRoYXJwb29uc1wiLCBcIlxcXFx4bG9uZ2VxdWFsXCIsIFwiXFxcXHh0d29oZWFkcmlnaHRhcnJvd1wiLCBcIlxcXFx4dHdvaGVhZGxlZnRhcnJvd1wiLCBcIlxcXFx4dG9mcm9tXCIsIC8vIFRoZSBuZXh0IDMgZnVuY3Rpb25zIGFyZSBoZXJlIHRvIHN1cHBvcnQgdGhlIG1oY2hlbSBleHRlbnNpb24uXG4gIC8vIERpcmVjdCB1c2Ugb2YgdGhlc2UgZnVuY3Rpb25zIGlzIGRpc2NvdXJhZ2VkIGFuZCBtYXkgYnJlYWsgc29tZWRheS5cbiAgXCJcXFxceHJpZ2h0bGVmdGFycm93c1wiLCBcIlxcXFx4cmlnaHRlcXVpbGlicml1bVwiLCBcIlxcXFx4bGVmdGVxdWlsaWJyaXVtXCIsIC8vIFRoZSBuZXh0IDMgZnVuY3Rpb25zIGFyZSBoZXJlIG9ubHkgdG8gc3VwcG9ydCB0aGUge0NEfSBlbnZpcm9ubWVudC5cbiAgXCJcXFxcXFxcXGNkcmlnaHRhcnJvd1wiLCBcIlxcXFxcXFxcY2RsZWZ0YXJyb3dcIiwgXCJcXFxcXFxcXGNkbG9uZ2VxdWFsXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgbnVtT3B0aW9uYWxBcmdzOiAxXG4gIH0sXG5cbiAgaGFuZGxlcihfcmVmLCBhcmdzLCBvcHRBcmdzKSB7XG4gICAgbGV0IHtcbiAgICAgIHBhcnNlcixcbiAgICAgIGZ1bmNOYW1lXG4gICAgfSA9IF9yZWY7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwieEFycm93XCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGxhYmVsOiBmdW5jTmFtZSxcbiAgICAgIGJvZHk6IGFyZ3NbMF0sXG4gICAgICBiZWxvdzogb3B0QXJnc1swXVxuICAgIH07XG4gIH0sXG5cbiAgLy8gRmxvdyBpcyB1bmFibGUgdG8gY29ycmVjdGx5IGluZmVyIHRoZSB0eXBlIG9mIGBncm91cGAsIGV2ZW4gdGhvdWdoIGl0J3NcbiAgLy8gdW5hbWJpZ3VvdXNseSBkZXRlcm1pbmVkIGZyb20gdGhlIHBhc3NlZC1pbiBgdHlwZWAgYWJvdmUuXG4gIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc3R5bGUgPSBvcHRpb25zLnN0eWxlOyAvLyBCdWlsZCB0aGUgYXJndW1lbnQgZ3JvdXBzIGluIHRoZSBhcHByb3ByaWF0ZSBzdHlsZS5cbiAgICAvLyBSZWY6IGFtc21hdGguZHR4OiAgIFxcaGJveHskXFxzY3JpcHRzdHlsZVxcbWtlcm4jM211eyM2fVxcbWtlcm4jNG11JH0lXG4gICAgLy8gU29tZSBncm91cHMgY2FuIHJldHVybiBkb2N1bWVudCBmcmFnbWVudHMuICBIYW5kbGUgdGhvc2UgYnkgd3JhcHBpbmdcbiAgICAvLyB0aGVtIGluIGEgc3Bhbi5cblxuICAgIGxldCBuZXdPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdTdHlsZShzdHlsZS5zdXAoKSk7XG4gICAgY29uc3QgdXBwZXJHcm91cCA9IGJ1aWxkQ29tbW9uLndyYXBGcmFnbWVudChidWlsZEdyb3VwKGdyb3VwLmJvZHksIG5ld09wdGlvbnMsIG9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICBjb25zdCBhcnJvd1ByZWZpeCA9IGdyb3VwLmxhYmVsLnNsaWNlKDAsIDIpID09PSBcIlxcXFx4XCIgPyBcInhcIiA6IFwiY2RcIjtcbiAgICB1cHBlckdyb3VwLmNsYXNzZXMucHVzaChhcnJvd1ByZWZpeCArIFwiLWFycm93LXBhZFwiKTtcbiAgICBsZXQgbG93ZXJHcm91cDtcblxuICAgIGlmIChncm91cC5iZWxvdykge1xuICAgICAgLy8gQnVpbGQgdGhlIGxvd2VyIGdyb3VwXG4gICAgICBuZXdPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdTdHlsZShzdHlsZS5zdWIoKSk7XG4gICAgICBsb3dlckdyb3VwID0gYnVpbGRDb21tb24ud3JhcEZyYWdtZW50KGJ1aWxkR3JvdXAoZ3JvdXAuYmVsb3csIG5ld09wdGlvbnMsIG9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgIGxvd2VyR3JvdXAuY2xhc3Nlcy5wdXNoKGFycm93UHJlZml4ICsgXCItYXJyb3ctcGFkXCIpO1xuICAgIH1cblxuICAgIGNvbnN0IGFycm93Qm9keSA9IHN0cmV0Y2h5LnN2Z1NwYW4oZ3JvdXAsIG9wdGlvbnMpOyAvLyBSZSBzaGlmdDogTm90ZSB0aGF0IHN0cmV0Y2h5LnN2Z1NwYW4gcmV0dXJuZWQgYXJyb3dCb2R5LmRlcHRoID0gMC5cbiAgICAvLyBUaGUgcG9pbnQgd2Ugd2FudCBvbiB0aGUgbWF0aCBheGlzIGlzIGF0IDAuNSAqIGFycm93Qm9keS5oZWlnaHQuXG5cbiAgICBjb25zdCBhcnJvd1NoaWZ0ID0gLW9wdGlvbnMuZm9udE1ldHJpY3MoKS5heGlzSGVpZ2h0ICsgMC41ICogYXJyb3dCb2R5LmhlaWdodDsgLy8gMiBtdSBrZXJuLiBSZWY6IGFtc21hdGguZHR4OiAjN1xcaWYwIzJcXGVsc2VcXG1rZXJuIzJtdVxcZmlcblxuICAgIGxldCB1cHBlclNoaWZ0ID0gLW9wdGlvbnMuZm9udE1ldHJpY3MoKS5heGlzSGVpZ2h0IC0gMC41ICogYXJyb3dCb2R5LmhlaWdodCAtIDAuMTExOyAvLyAwLjExMSBlbSA9IDIgbXVcblxuICAgIGlmICh1cHBlckdyb3VwLmRlcHRoID4gMC4yNSB8fCBncm91cC5sYWJlbCA9PT0gXCJcXFxceGxlZnRlcXVpbGlicml1bVwiKSB7XG4gICAgICB1cHBlclNoaWZ0IC09IHVwcGVyR3JvdXAuZGVwdGg7IC8vIHNoaWZ0IHVwIGlmIGRlcHRoIGVuY3JvYWNoZXNcbiAgICB9IC8vIEdlbmVyYXRlIHRoZSB2bGlzdFxuXG5cbiAgICBsZXQgdmxpc3Q7XG5cbiAgICBpZiAobG93ZXJHcm91cCkge1xuICAgICAgY29uc3QgbG93ZXJTaGlmdCA9IC1vcHRpb25zLmZvbnRNZXRyaWNzKCkuYXhpc0hlaWdodCArIGxvd2VyR3JvdXAuaGVpZ2h0ICsgMC41ICogYXJyb3dCb2R5LmhlaWdodCArIDAuMTExO1xuICAgICAgdmxpc3QgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgICBwb3NpdGlvblR5cGU6IFwiaW5kaXZpZHVhbFNoaWZ0XCIsXG4gICAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICAgIGVsZW06IHVwcGVyR3JvdXAsXG4gICAgICAgICAgc2hpZnQ6IHVwcGVyU2hpZnRcbiAgICAgICAgfSwge1xuICAgICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICAgIGVsZW06IGFycm93Qm9keSxcbiAgICAgICAgICBzaGlmdDogYXJyb3dTaGlmdFxuICAgICAgICB9LCB7XG4gICAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgICAgZWxlbTogbG93ZXJHcm91cCxcbiAgICAgICAgICBzaGlmdDogbG93ZXJTaGlmdFxuICAgICAgICB9XVxuICAgICAgfSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZsaXN0ID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHtcbiAgICAgICAgcG9zaXRpb25UeXBlOiBcImluZGl2aWR1YWxTaGlmdFwiLFxuICAgICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgICBlbGVtOiB1cHBlckdyb3VwLFxuICAgICAgICAgIHNoaWZ0OiB1cHBlclNoaWZ0XG4gICAgICAgIH0sIHtcbiAgICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgICBlbGVtOiBhcnJvd0JvZHksXG4gICAgICAgICAgc2hpZnQ6IGFycm93U2hpZnRcbiAgICAgICAgfV1cbiAgICAgIH0sIG9wdGlvbnMpO1xuICAgIH0gLy8gJEZsb3dGaXhNZTogUmVwbGFjZSB0aGlzIHdpdGggcGFzc2luZyBcInN2Zy1hbGlnblwiIGludG8gbWFrZVZMaXN0LlxuXG5cbiAgICB2bGlzdC5jaGlsZHJlblswXS5jaGlsZHJlblswXS5jaGlsZHJlblsxXS5jbGFzc2VzLnB1c2goXCJzdmctYWxpZ25cIik7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1yZWxcIiwgXCJ4LWFycm93XCJdLCBbdmxpc3RdLCBvcHRpb25zKTtcbiAgfSxcblxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgY29uc3QgYXJyb3dOb2RlID0gc3RyZXRjaHkubWF0aE1Mbm9kZShncm91cC5sYWJlbCk7XG4gICAgYXJyb3dOb2RlLnNldEF0dHJpYnV0ZShcIm1pbnNpemVcIiwgZ3JvdXAubGFiZWwuY2hhckF0KDApID09PSBcInhcIiA/IFwiMS43NWVtXCIgOiBcIjMuMGVtXCIpO1xuICAgIGxldCBub2RlO1xuXG4gICAgaWYgKGdyb3VwLmJvZHkpIHtcbiAgICAgIGNvbnN0IHVwcGVyTm9kZSA9IHBhZGRlZE5vZGUoYnVpbGRNYXRoTUxfYnVpbGRHcm91cChncm91cC5ib2R5LCBvcHRpb25zKSk7XG5cbiAgICAgIGlmIChncm91cC5iZWxvdykge1xuICAgICAgICBjb25zdCBsb3dlck5vZGUgPSBwYWRkZWROb2RlKGJ1aWxkTWF0aE1MX2J1aWxkR3JvdXAoZ3JvdXAuYmVsb3csIG9wdGlvbnMpKTtcbiAgICAgICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXVuZGVyb3ZlclwiLCBbYXJyb3dOb2RlLCBsb3dlck5vZGUsIHVwcGVyTm9kZV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW92ZXJcIiwgW2Fycm93Tm9kZSwgdXBwZXJOb2RlXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChncm91cC5iZWxvdykge1xuICAgICAgY29uc3QgbG93ZXJOb2RlID0gcGFkZGVkTm9kZShidWlsZE1hdGhNTF9idWlsZEdyb3VwKGdyb3VwLmJlbG93LCBvcHRpb25zKSk7XG4gICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdW5kZXJcIiwgW2Fycm93Tm9kZSwgbG93ZXJOb2RlXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbi5cbiAgICAgIC8vIFBhcnNlci5qcyB0aHJvd3MgYW4gZXJyb3IgaWYgdGhlcmUgaXMgbm8gYXJndW1lbnQuXG4gICAgICBub2RlID0gcGFkZGVkTm9kZSgpO1xuICAgICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW92ZXJcIiwgW2Fycm93Tm9kZSwgbm9kZV0pO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy9tY2xhc3MuanNcblxuXG5cblxuXG5cbmNvbnN0IG1jbGFzc19tYWtlU3BhbiA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuO1xuXG5mdW5jdGlvbiBtY2xhc3NfaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgY29uc3QgZWxlbWVudHMgPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAuYm9keSwgb3B0aW9ucywgdHJ1ZSk7XG4gIHJldHVybiBtY2xhc3NfbWFrZVNwYW4oW2dyb3VwLm1jbGFzc10sIGVsZW1lbnRzLCBvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gbWNsYXNzX21hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgbGV0IG5vZGU7XG4gIGNvbnN0IGlubmVyID0gYnVpbGRNYXRoTUxfYnVpbGRFeHByZXNzaW9uKGdyb3VwLmJvZHksIG9wdGlvbnMpO1xuXG4gIGlmIChncm91cC5tY2xhc3MgPT09IFwibWlubmVyXCIpIHtcbiAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcGFkZGVkXCIsIGlubmVyKTtcbiAgfSBlbHNlIGlmIChncm91cC5tY2xhc3MgPT09IFwibW9yZFwiKSB7XG4gICAgaWYgKGdyb3VwLmlzQ2hhcmFjdGVyQm94KSB7XG4gICAgICBub2RlID0gaW5uZXJbMF07XG4gICAgICBub2RlLnR5cGUgPSBcIm1pXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1pXCIsIGlubmVyKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGdyb3VwLmlzQ2hhcmFjdGVyQm94KSB7XG4gICAgICBub2RlID0gaW5uZXJbMF07XG4gICAgICBub2RlLnR5cGUgPSBcIm1vXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vXCIsIGlubmVyKTtcbiAgICB9IC8vIFNldCBzcGFjaW5nIGJhc2VkIG9uIHdoYXQgaXMgdGhlIG1vc3QgbGlrZWx5IGFkamFjZW50IGF0b20gdHlwZS5cbiAgICAvLyBTZWUgVGVYYm9vayBwMTcwLlxuXG5cbiAgICBpZiAoZ3JvdXAubWNsYXNzID09PSBcIm1iaW5cIikge1xuICAgICAgbm9kZS5hdHRyaWJ1dGVzLmxzcGFjZSA9IFwiMC4yMmVtXCI7IC8vIG1lZGl1bSBzcGFjZVxuXG4gICAgICBub2RlLmF0dHJpYnV0ZXMucnNwYWNlID0gXCIwLjIyZW1cIjtcbiAgICB9IGVsc2UgaWYgKGdyb3VwLm1jbGFzcyA9PT0gXCJtcHVuY3RcIikge1xuICAgICAgbm9kZS5hdHRyaWJ1dGVzLmxzcGFjZSA9IFwiMGVtXCI7XG4gICAgICBub2RlLmF0dHJpYnV0ZXMucnNwYWNlID0gXCIwLjE3ZW1cIjsgLy8gdGhpbnNwYWNlXG4gICAgfSBlbHNlIGlmIChncm91cC5tY2xhc3MgPT09IFwibW9wZW5cIiB8fCBncm91cC5tY2xhc3MgPT09IFwibWNsb3NlXCIpIHtcbiAgICAgIG5vZGUuYXR0cmlidXRlcy5sc3BhY2UgPSBcIjBlbVwiO1xuICAgICAgbm9kZS5hdHRyaWJ1dGVzLnJzcGFjZSA9IFwiMGVtXCI7XG4gICAgfSBlbHNlIGlmIChncm91cC5tY2xhc3MgPT09IFwibWlubmVyXCIpIHtcbiAgICAgIG5vZGUuYXR0cmlidXRlcy5sc3BhY2UgPSBcIjAuMDU1NmVtXCI7IC8vIDEgbXUgaXMgdGhlIG1vc3QgbGlrZWx5IG9wdGlvblxuXG4gICAgICBub2RlLmF0dHJpYnV0ZXMud2lkdGggPSBcIiswLjExMTFlbVwiO1xuICAgIH0gLy8gTWF0aE1MIDxtbz4gZGVmYXVsdCBzcGFjZSBpcyA1LzE4IGVtLCBzbyA8bXJlbD4gbmVlZHMgbm8gYWN0aW9uLlxuICAgIC8vIFJlZjogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvTWF0aE1ML0VsZW1lbnQvbW9cblxuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59IC8vIE1hdGggY2xhc3MgY29tbWFuZHMgZXhjZXB0IFxcbWF0aG9wXG5cblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcIm1jbGFzc1wiLFxuICBuYW1lczogW1wiXFxcXG1hdGhvcmRcIiwgXCJcXFxcbWF0aGJpblwiLCBcIlxcXFxtYXRocmVsXCIsIFwiXFxcXG1hdGhvcGVuXCIsIFwiXFxcXG1hdGhjbG9zZVwiLCBcIlxcXFxtYXRocHVuY3RcIiwgXCJcXFxcbWF0aGlubmVyXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgcHJpbWl0aXZlOiB0cnVlXG4gIH0sXG5cbiAgaGFuZGxlcihfcmVmLCBhcmdzKSB7XG4gICAgbGV0IHtcbiAgICAgIHBhcnNlcixcbiAgICAgIGZ1bmNOYW1lXG4gICAgfSA9IF9yZWY7XG4gICAgY29uc3QgYm9keSA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwibWNsYXNzXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIG1jbGFzczogXCJtXCIgKyBmdW5jTmFtZS5zbGljZSg1KSxcbiAgICAgIC8vIFRPRE8oa2V2aW5iKTogZG9uJ3QgcHJlZml4IHdpdGggJ20nXG4gICAgICBib2R5OiBvcmRhcmd1bWVudChib2R5KSxcbiAgICAgIGlzQ2hhcmFjdGVyQm94OiB1dGlscy5pc0NoYXJhY3RlckJveChib2R5KVxuICAgIH07XG4gIH0sXG5cbiAgaHRtbEJ1aWxkZXI6IG1jbGFzc19odG1sQnVpbGRlcixcbiAgbWF0aG1sQnVpbGRlcjogbWNsYXNzX21hdGhtbEJ1aWxkZXJcbn0pO1xuY29uc3QgYmlucmVsQ2xhc3MgPSBhcmcgPT4ge1xuICAvLyBcXGJpbnJlbEAgc3BhY2luZyB2YXJpZXMgd2l0aCAoYmlufHJlbHxvcmQpIG9mIHRoZSBhdG9tIGluIHRoZSBhcmd1bWVudC5cbiAgLy8gKGJ5IHJlbmRlcmluZyBzZXBhcmF0ZWx5IGFuZCB3aXRoIHt9cyBiZWZvcmUgYW5kIGFmdGVyLCBhbmQgbWVhc3VyaW5nXG4gIC8vIHRoZSBjaGFuZ2UgaW4gc3BhY2luZykuICBXZSdsbCBkbyByb3VnaGx5IHRoZSBzYW1lIGJ5IGRldGVjdGluZyB0aGVcbiAgLy8gYXRvbSB0eXBlIGRpcmVjdGx5LlxuICBjb25zdCBhdG9tID0gYXJnLnR5cGUgPT09IFwib3JkZ3JvdXBcIiAmJiBhcmcuYm9keS5sZW5ndGggPyBhcmcuYm9keVswXSA6IGFyZztcblxuICBpZiAoYXRvbS50eXBlID09PSBcImF0b21cIiAmJiAoYXRvbS5mYW1pbHkgPT09IFwiYmluXCIgfHwgYXRvbS5mYW1pbHkgPT09IFwicmVsXCIpKSB7XG4gICAgcmV0dXJuIFwibVwiICsgYXRvbS5mYW1pbHk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwibW9yZFwiO1xuICB9XG59OyAvLyBcXEBiaW5yZWx7eH17eX0gcmVuZGVycyBsaWtlIHkgYnV0IGFzIG1iaW4vbXJlbC9tb3JkIGlmIHggaXMgbWJpbi9tcmVsL21vcmQuXG4vLyBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gXFxiaW5yZWxAe3h9XFxiaW5yZWxAQHt5fSBpbiBBTVNUZVguXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJtY2xhc3NcIixcbiAgbmFtZXM6IFtcIlxcXFxAYmlucmVsXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDJcbiAgfSxcblxuICBoYW5kbGVyKF9yZWYyLCBhcmdzKSB7XG4gICAgbGV0IHtcbiAgICAgIHBhcnNlclxuICAgIH0gPSBfcmVmMjtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJtY2xhc3NcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbWNsYXNzOiBiaW5yZWxDbGFzcyhhcmdzWzBdKSxcbiAgICAgIGJvZHk6IG9yZGFyZ3VtZW50KGFyZ3NbMV0pLFxuICAgICAgaXNDaGFyYWN0ZXJCb3g6IHV0aWxzLmlzQ2hhcmFjdGVyQm94KGFyZ3NbMV0pXG4gICAgfTtcbiAgfVxuXG59KTsgLy8gQnVpbGQgYSByZWxhdGlvbiBvciBzdGFja2VkIG9wIGJ5IHBsYWNpbmcgb25lIHN5bWJvbCBvbiB0b3Agb2YgYW5vdGhlclxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwibWNsYXNzXCIsXG4gIG5hbWVzOiBbXCJcXFxcc3RhY2tyZWxcIiwgXCJcXFxcb3ZlcnNldFwiLCBcIlxcXFx1bmRlcnNldFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAyXG4gIH0sXG5cbiAgaGFuZGxlcihfcmVmMywgYXJncykge1xuICAgIGxldCB7XG4gICAgICBwYXJzZXIsXG4gICAgICBmdW5jTmFtZVxuICAgIH0gPSBfcmVmMztcbiAgICBjb25zdCBiYXNlQXJnID0gYXJnc1sxXTtcbiAgICBjb25zdCBzaGlmdGVkQXJnID0gYXJnc1swXTtcbiAgICBsZXQgbWNsYXNzO1xuXG4gICAgaWYgKGZ1bmNOYW1lICE9PSBcIlxcXFxzdGFja3JlbFwiKSB7XG4gICAgICAvLyBMYVRlWCBhcHBsaWVzIFxcYmlucmVsIHNwYWNpbmcgdG8gXFxvdmVyc2V0IGFuZCBcXHVuZGVyc2V0LlxuICAgICAgbWNsYXNzID0gYmlucmVsQ2xhc3MoYmFzZUFyZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1jbGFzcyA9IFwibXJlbFwiOyAvLyBmb3IgXFxzdGFja3JlbFxuICAgIH1cblxuICAgIGNvbnN0IGJhc2VPcCA9IHtcbiAgICAgIHR5cGU6IFwib3BcIixcbiAgICAgIG1vZGU6IGJhc2VBcmcubW9kZSxcbiAgICAgIGxpbWl0czogdHJ1ZSxcbiAgICAgIGFsd2F5c0hhbmRsZVN1cFN1YjogdHJ1ZSxcbiAgICAgIHBhcmVudElzU3VwU3ViOiBmYWxzZSxcbiAgICAgIHN5bWJvbDogZmFsc2UsXG4gICAgICBzdXBwcmVzc0Jhc2VTaGlmdDogZnVuY05hbWUgIT09IFwiXFxcXHN0YWNrcmVsXCIsXG4gICAgICBib2R5OiBvcmRhcmd1bWVudChiYXNlQXJnKVxuICAgIH07XG4gICAgY29uc3Qgc3Vwc3ViID0ge1xuICAgICAgdHlwZTogXCJzdXBzdWJcIixcbiAgICAgIG1vZGU6IHNoaWZ0ZWRBcmcubW9kZSxcbiAgICAgIGJhc2U6IGJhc2VPcCxcbiAgICAgIHN1cDogZnVuY05hbWUgPT09IFwiXFxcXHVuZGVyc2V0XCIgPyBudWxsIDogc2hpZnRlZEFyZyxcbiAgICAgIHN1YjogZnVuY05hbWUgPT09IFwiXFxcXHVuZGVyc2V0XCIgPyBzaGlmdGVkQXJnIDogbnVsbFxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwibWNsYXNzXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIG1jbGFzcyxcbiAgICAgIGJvZHk6IFtzdXBzdWJdLFxuICAgICAgaXNDaGFyYWN0ZXJCb3g6IHV0aWxzLmlzQ2hhcmFjdGVyQm94KHN1cHN1YilcbiAgICB9O1xuICB9LFxuXG4gIGh0bWxCdWlsZGVyOiBtY2xhc3NfaHRtbEJ1aWxkZXIsXG4gIG1hdGhtbEJ1aWxkZXI6IG1jbGFzc19tYXRobWxCdWlsZGVyXG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mdW5jdGlvbnMvcG1iLmpzXG5cblxuXG5cblxuXG4vLyBcXHBtYiBpcyBhIHNpbXVsYXRpb24gb2YgYm9sZCBmb250LlxuLy8gVGhlIHZlcnNpb24gb2YgXFxwbWIgaW4gYW1ic3kuc3R5IHdvcmtzIGJ5IHR5cGVzZXR0aW5nIHRocmVlIGNvcGllc1xuLy8gd2l0aCBzbWFsbCBvZmZzZXRzLiBXZSB1c2UgQ1NTIHRleHQtc2hhZG93LlxuLy8gSXQncyBhIGhhY2suIE5vdCBhcyBnb29kIGFzIGEgcmVhbCBib2xkIGZvbnQuIEJldHRlciB0aGFuIG5vdGhpbmcuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwicG1iXCIsXG4gIG5hbWVzOiBbXCJcXFxccG1iXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuXG4gIGhhbmRsZXIoX3JlZiwgYXJncykge1xuICAgIGxldCB7XG4gICAgICBwYXJzZXJcbiAgICB9ID0gX3JlZjtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJwbWJcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbWNsYXNzOiBiaW5yZWxDbGFzcyhhcmdzWzBdKSxcbiAgICAgIGJvZHk6IG9yZGFyZ3VtZW50KGFyZ3NbMF0pXG4gICAgfTtcbiAgfSxcblxuICBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGVsZW1lbnRzID0gYnVpbGRFeHByZXNzaW9uKGdyb3VwLmJvZHksIG9wdGlvbnMsIHRydWUpO1xuICAgIGNvbnN0IG5vZGUgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbZ3JvdXAubWNsYXNzXSwgZWxlbWVudHMsIG9wdGlvbnMpO1xuICAgIG5vZGUuc3R5bGUudGV4dFNoYWRvdyA9IFwiMC4wMmVtIDAuMDFlbSAwLjA0cHhcIjtcbiAgICByZXR1cm4gbm9kZTtcbiAgfSxcblxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBzdHlsZSkge1xuICAgIGNvbnN0IGlubmVyID0gYnVpbGRNYXRoTUxfYnVpbGRFeHByZXNzaW9uKGdyb3VwLmJvZHksIHN0eWxlKTsgLy8gV3JhcCB3aXRoIGFuIDxtc3R5bGU+IGVsZW1lbnQuXG5cbiAgICBjb25zdCBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtc3R5bGVcIiwgaW5uZXIpO1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJ0ZXh0LXNoYWRvdzogMC4wMmVtIDAuMDFlbSAwLjA0cHhcIik7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZW52aXJvbm1lbnRzL2NkLmpzXG5cblxuXG5cblxuXG5cblxuY29uc3QgY2RBcnJvd0Z1bmN0aW9uTmFtZSA9IHtcbiAgXCI+XCI6IFwiXFxcXFxcXFxjZHJpZ2h0YXJyb3dcIixcbiAgXCI8XCI6IFwiXFxcXFxcXFxjZGxlZnRhcnJvd1wiLFxuICBcIj1cIjogXCJcXFxcXFxcXGNkbG9uZ2VxdWFsXCIsXG4gIFwiQVwiOiBcIlxcXFx1cGFycm93XCIsXG4gIFwiVlwiOiBcIlxcXFxkb3duYXJyb3dcIixcbiAgXCJ8XCI6IFwiXFxcXFZlcnRcIixcbiAgXCIuXCI6IFwibm8gYXJyb3dcIlxufTtcblxuY29uc3QgbmV3Q2VsbCA9ICgpID0+IHtcbiAgLy8gQ3JlYXRlIGFuIGVtcHR5IGNlbGwsIHRvIGJlIGZpbGxlZCBiZWxvdyB3aXRoIHBhcnNlIG5vZGVzLlxuICAvLyBUaGUgcGFyc2VUcmVlIGZyb20gdGhpcyBtb2R1bGUgbXVzdCBiZSBjb25zdHJ1Y3RlZCBsaWtlIHRoZVxuICAvLyBvbmUgY3JlYXRlZCBieSBwYXJzZUFycmF5KCksIHNvIGFuIGVtcHR5IENEIGNlbGwgbXVzdFxuICAvLyBiZSBhIFBhcnNlTm9kZTxcInN0eWxpbmdcIj4uIEFuZCBDRCBpcyBhbHdheXMgZGlzcGxheXN0eWxlLlxuICAvLyBTbyB0aGVzZSB2YWx1ZXMgYXJlIGZpeGVkIGFuZCBmbG93IGNhbiBkbyBpbXBsaWNpdCB0eXBpbmcuXG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJzdHlsaW5nXCIsXG4gICAgYm9keTogW10sXG4gICAgbW9kZTogXCJtYXRoXCIsXG4gICAgc3R5bGU6IFwiZGlzcGxheVwiXG4gIH07XG59O1xuXG5jb25zdCBpc1N0YXJ0T2ZBcnJvdyA9IG5vZGUgPT4ge1xuICByZXR1cm4gbm9kZS50eXBlID09PSBcInRleHRvcmRcIiAmJiBub2RlLnRleHQgPT09IFwiQFwiO1xufTtcblxuY29uc3QgaXNMYWJlbEVuZCA9IChub2RlLCBlbmRDaGFyKSA9PiB7XG4gIHJldHVybiAobm9kZS50eXBlID09PSBcIm1hdGhvcmRcIiB8fCBub2RlLnR5cGUgPT09IFwiYXRvbVwiKSAmJiBub2RlLnRleHQgPT09IGVuZENoYXI7XG59O1xuXG5mdW5jdGlvbiBjZEFycm93KGFycm93Q2hhciwgbGFiZWxzLCBwYXJzZXIpIHtcbiAgLy8gUmV0dXJuIGEgcGFyc2UgdHJlZSBvZiBhbiBhcnJvdyBhbmQgaXRzIGxhYmVscy5cbiAgLy8gVGhpcyBhY3RzIGluIGEgd2F5IHNpbWlsYXIgdG8gYSBtYWNybyBleHBhbnNpb24uXG4gIGNvbnN0IGZ1bmNOYW1lID0gY2RBcnJvd0Z1bmN0aW9uTmFtZVthcnJvd0NoYXJdO1xuXG4gIHN3aXRjaCAoZnVuY05hbWUpIHtcbiAgICBjYXNlIFwiXFxcXFxcXFxjZHJpZ2h0YXJyb3dcIjpcbiAgICBjYXNlIFwiXFxcXFxcXFxjZGxlZnRhcnJvd1wiOlxuICAgICAgcmV0dXJuIHBhcnNlci5jYWxsRnVuY3Rpb24oZnVuY05hbWUsIFtsYWJlbHNbMF1dLCBbbGFiZWxzWzFdXSk7XG5cbiAgICBjYXNlIFwiXFxcXHVwYXJyb3dcIjpcbiAgICBjYXNlIFwiXFxcXGRvd25hcnJvd1wiOlxuICAgICAge1xuICAgICAgICBjb25zdCBsZWZ0TGFiZWwgPSBwYXJzZXIuY2FsbEZ1bmN0aW9uKFwiXFxcXFxcXFxjZGxlZnRcIiwgW2xhYmVsc1swXV0sIFtdKTtcbiAgICAgICAgY29uc3QgYmFyZUFycm93ID0ge1xuICAgICAgICAgIHR5cGU6IFwiYXRvbVwiLFxuICAgICAgICAgIHRleHQ6IGZ1bmNOYW1lLFxuICAgICAgICAgIG1vZGU6IFwibWF0aFwiLFxuICAgICAgICAgIGZhbWlseTogXCJyZWxcIlxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzaXplZEFycm93ID0gcGFyc2VyLmNhbGxGdW5jdGlvbihcIlxcXFxCaWdcIiwgW2JhcmVBcnJvd10sIFtdKTtcbiAgICAgICAgY29uc3QgcmlnaHRMYWJlbCA9IHBhcnNlci5jYWxsRnVuY3Rpb24oXCJcXFxcXFxcXGNkcmlnaHRcIiwgW2xhYmVsc1sxXV0sIFtdKTtcbiAgICAgICAgY29uc3QgYXJyb3dHcm91cCA9IHtcbiAgICAgICAgICB0eXBlOiBcIm9yZGdyb3VwXCIsXG4gICAgICAgICAgbW9kZTogXCJtYXRoXCIsXG4gICAgICAgICAgYm9keTogW2xlZnRMYWJlbCwgc2l6ZWRBcnJvdywgcmlnaHRMYWJlbF1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHBhcnNlci5jYWxsRnVuY3Rpb24oXCJcXFxcXFxcXGNkcGFyZW50XCIsIFthcnJvd0dyb3VwXSwgW10pO1xuICAgICAgfVxuXG4gICAgY2FzZSBcIlxcXFxcXFxcY2Rsb25nZXF1YWxcIjpcbiAgICAgIHJldHVybiBwYXJzZXIuY2FsbEZ1bmN0aW9uKFwiXFxcXFxcXFxjZGxvbmdlcXVhbFwiLCBbXSwgW10pO1xuXG4gICAgY2FzZSBcIlxcXFxWZXJ0XCI6XG4gICAgICB7XG4gICAgICAgIGNvbnN0IGFycm93ID0ge1xuICAgICAgICAgIHR5cGU6IFwidGV4dG9yZFwiLFxuICAgICAgICAgIHRleHQ6IFwiXFxcXFZlcnRcIixcbiAgICAgICAgICBtb2RlOiBcIm1hdGhcIlxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcGFyc2VyLmNhbGxGdW5jdGlvbihcIlxcXFxCaWdcIiwgW2Fycm93XSwgW10pO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwidGV4dG9yZFwiLFxuICAgICAgICB0ZXh0OiBcIiBcIixcbiAgICAgICAgbW9kZTogXCJtYXRoXCJcbiAgICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VDRChwYXJzZXIpIHtcbiAgLy8gR2V0IHRoZSBhcnJheSdzIHBhcnNlIG5vZGVzIHdpdGggXFxcXCB0ZW1wb3JhcmlseSBtYXBwZWQgdG8gXFxjci5cbiAgY29uc3QgcGFyc2VkUm93cyA9IFtdO1xuICBwYXJzZXIuZ3VsbGV0LmJlZ2luR3JvdXAoKTtcbiAgcGFyc2VyLmd1bGxldC5tYWNyb3Muc2V0KFwiXFxcXGNyXCIsIFwiXFxcXFxcXFxcXFxccmVsYXhcIik7XG4gIHBhcnNlci5ndWxsZXQuYmVnaW5Hcm91cCgpO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICAvLyBHZXQgdGhlIHBhcnNlIG5vZGVzIGZvciB0aGUgbmV4dCByb3cuXG4gICAgcGFyc2VkUm93cy5wdXNoKHBhcnNlci5wYXJzZUV4cHJlc3Npb24oZmFsc2UsIFwiXFxcXFxcXFxcIikpO1xuICAgIHBhcnNlci5ndWxsZXQuZW5kR3JvdXAoKTtcbiAgICBwYXJzZXIuZ3VsbGV0LmJlZ2luR3JvdXAoKTtcbiAgICBjb25zdCBuZXh0ID0gcGFyc2VyLmZldGNoKCkudGV4dDtcblxuICAgIGlmIChuZXh0ID09PSBcIiZcIiB8fCBuZXh0ID09PSBcIlxcXFxcXFxcXCIpIHtcbiAgICAgIHBhcnNlci5jb25zdW1lKCk7XG4gICAgfSBlbHNlIGlmIChuZXh0ID09PSBcIlxcXFxlbmRcIikge1xuICAgICAgaWYgKHBhcnNlZFJvd3NbcGFyc2VkUm93cy5sZW5ndGggLSAxXS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcGFyc2VkUm93cy5wb3AoKTsgLy8gZmluYWwgcm93IGVuZGVkIGluIFxcXFxcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIkV4cGVjdGVkIFxcXFxcXFxcIG9yIFxcXFxjciBvciBcXFxcZW5kXCIsIHBhcnNlci5uZXh0VG9rZW4pO1xuICAgIH1cbiAgfVxuXG4gIGxldCByb3cgPSBbXTtcbiAgY29uc3QgYm9keSA9IFtyb3ddOyAvLyBMb29wIHRocnUgdGhlIHBhcnNlIG5vZGVzLiBDb2xsZWN0IHRoZW0gaW50byBjZWxscyBhbmQgYXJyb3dzLlxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyc2VkUm93cy5sZW5ndGg7IGkrKykge1xuICAgIC8vIFN0YXJ0IGEgbmV3IHJvdy5cbiAgICBjb25zdCByb3dOb2RlcyA9IHBhcnNlZFJvd3NbaV07IC8vIENyZWF0ZSB0aGUgZmlyc3QgY2VsbC5cblxuICAgIGxldCBjZWxsID0gbmV3Q2VsbCgpO1xuXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCByb3dOb2Rlcy5sZW5ndGg7IGorKykge1xuICAgICAgaWYgKCFpc1N0YXJ0T2ZBcnJvdyhyb3dOb2Rlc1tqXSkpIHtcbiAgICAgICAgLy8gSWYgYSBwYXJzZU5vZGUgaXMgbm90IGFuIGFycm93LCBpdCBnb2VzIGludG8gYSBjZWxsLlxuICAgICAgICBjZWxsLmJvZHkucHVzaChyb3dOb2Rlc1tqXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBQYXJzZSBub2RlIGogaXMgYW4gXCJAXCIsIHRoZSBzdGFydCBvZiBhbiBhcnJvdy5cbiAgICAgICAgLy8gQmVmb3JlIHN0YXJ0aW5nIG9uIHRoZSBhcnJvdywgcHVzaCB0aGUgY2VsbCBpbnRvIGByb3dgLlxuICAgICAgICByb3cucHVzaChjZWxsKTsgLy8gTm93IGNvbGxlY3QgcGFyc2VOb2RlcyBpbnRvIGFuIGFycm93LlxuICAgICAgICAvLyBUaGUgY2hhcmFjdGVyIGFmdGVyIFwiQFwiIGRlZmluZXMgdGhlIGFycm93IHR5cGUuXG5cbiAgICAgICAgaiArPSAxO1xuICAgICAgICBjb25zdCBhcnJvd0NoYXIgPSBhc3NlcnRTeW1ib2xOb2RlVHlwZShyb3dOb2Rlc1tqXSkudGV4dDsgLy8gQ3JlYXRlIHR3byBlbXB0eSBsYWJlbCBub2Rlcy4gV2UgbWF5IG9yIG1heSBub3QgdXNlIHRoZW0uXG5cbiAgICAgICAgY29uc3QgbGFiZWxzID0gbmV3IEFycmF5KDIpO1xuICAgICAgICBsYWJlbHNbMF0gPSB7XG4gICAgICAgICAgdHlwZTogXCJvcmRncm91cFwiLFxuICAgICAgICAgIG1vZGU6IFwibWF0aFwiLFxuICAgICAgICAgIGJvZHk6IFtdXG4gICAgICAgIH07XG4gICAgICAgIGxhYmVsc1sxXSA9IHtcbiAgICAgICAgICB0eXBlOiBcIm9yZGdyb3VwXCIsXG4gICAgICAgICAgbW9kZTogXCJtYXRoXCIsXG4gICAgICAgICAgYm9keTogW11cbiAgICAgICAgfTsgLy8gUHJvY2VzcyB0aGUgYXJyb3cuXG5cbiAgICAgICAgaWYgKFwiPXwuXCIuaW5kZXhPZihhcnJvd0NoYXIpID4gLTEpIHsvLyBUaHJlZSBcImFycm93c1wiLCBgYEA9YCwgYEB8YCwgYW5kIGBALmAsIGRvIG5vdCB0YWtlIGxhYmVscy5cbiAgICAgICAgICAvLyBEbyBub3RoaW5nIGhlcmUuXG4gICAgICAgIH0gZWxzZSBpZiAoXCI8PkFWXCIuaW5kZXhPZihhcnJvd0NoYXIpID4gLTEpIHtcbiAgICAgICAgICAvLyBGb3VyIGFycm93cywgYEA+Pj5gLCBgQDw8PGAsIGBAQUFBYCwgYW5kIGBAVlZWYCwgZWFjaCB0YWtlXG4gICAgICAgICAgLy8gdHdvIG9wdGlvbmFsIGxhYmVscy4gRS5nLiB0aGUgcmlnaHQtcG9pbnQgYXJyb3cgc3ludGF4IGlzXG4gICAgICAgICAgLy8gcmVhbGx5OiAgQD57b3B0aW9uYWwgbGFiZWx9PntvcHRpb25hbCBsYWJlbH0+XG4gICAgICAgICAgLy8gQ29sbGVjdCBwYXJzZU5vZGVzIGludG8gbGFiZWxzLlxuICAgICAgICAgIGZvciAobGV0IGxhYmVsTnVtID0gMDsgbGFiZWxOdW0gPCAyOyBsYWJlbE51bSsrKSB7XG4gICAgICAgICAgICBsZXQgaW5MYWJlbCA9IHRydWU7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGsgPSBqICsgMTsgayA8IHJvd05vZGVzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgIGlmIChpc0xhYmVsRW5kKHJvd05vZGVzW2tdLCBhcnJvd0NoYXIpKSB7XG4gICAgICAgICAgICAgICAgaW5MYWJlbCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGogPSBrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGlzU3RhcnRPZkFycm93KHJvd05vZGVzW2tdKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIk1pc3NpbmcgYSBcIiArIGFycm93Q2hhciArIFwiIGNoYXJhY3RlciB0byBjb21wbGV0ZSBhIENEIGFycm93LlwiLCByb3dOb2Rlc1trXSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBsYWJlbHNbbGFiZWxOdW1dLmJvZHkucHVzaChyb3dOb2Rlc1trXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpbkxhYmVsKSB7XG4gICAgICAgICAgICAgIC8vIGlzTGFiZWxFbmQgbmV2ZXIgcmV0dXJuZWQgYSB0cnVlLlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJNaXNzaW5nIGEgXCIgKyBhcnJvd0NoYXIgKyBcIiBjaGFyYWN0ZXIgdG8gY29tcGxldGUgYSBDRCBhcnJvdy5cIiwgcm93Tm9kZXNbal0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJFeHBlY3RlZCBvbmUgb2YgXFxcIjw+QVY9fC5cXFwiIGFmdGVyIEBcIiwgcm93Tm9kZXNbal0pO1xuICAgICAgICB9IC8vIE5vdyBqb2luIHRoZSBhcnJvdyB0byBpdHMgbGFiZWxzLlxuXG5cbiAgICAgICAgY29uc3QgYXJyb3cgPSBjZEFycm93KGFycm93Q2hhciwgbGFiZWxzLCBwYXJzZXIpOyAvLyBXcmFwIHRoZSBhcnJvdyBpbiAgUGFyc2VOb2RlPFwic3R5bGluZ1wiPi5cbiAgICAgICAgLy8gVGhpcyBpcyBkb25lIHRvIG1hdGNoIHBhcnNlQXJyYXkoKSBiZWhhdmlvci5cblxuICAgICAgICBjb25zdCB3cmFwcGVkQXJyb3cgPSB7XG4gICAgICAgICAgdHlwZTogXCJzdHlsaW5nXCIsXG4gICAgICAgICAgYm9keTogW2Fycm93XSxcbiAgICAgICAgICBtb2RlOiBcIm1hdGhcIixcbiAgICAgICAgICBzdHlsZTogXCJkaXNwbGF5XCIgLy8gQ0QgaXMgYWx3YXlzIGRpc3BsYXlzdHlsZS5cblxuICAgICAgICB9O1xuICAgICAgICByb3cucHVzaCh3cmFwcGVkQXJyb3cpOyAvLyBJbiBDRCdzIHN5bnRheCwgY2VsbHMgYXJlIGltcGxpY2l0LiBUaGF0IGlzLCBldmVyeXRoaW5nIHRoYXRcbiAgICAgICAgLy8gaXMgbm90IGFuIGFycm93IGdldHMgY29sbGVjdGVkIGludG8gYSBjZWxsLiBTbyBjcmVhdGUgYW4gZW1wdHlcbiAgICAgICAgLy8gY2VsbCBub3cuIEl0IHdpbGwgY29sbGVjdCB1cGNvbWluZyBwYXJzZU5vZGVzLlxuXG4gICAgICAgIGNlbGwgPSBuZXdDZWxsKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGkgJSAyID09PSAwKSB7XG4gICAgICAvLyBFdmVuLW51bWJlcmVkIHJvd3MgY29uc2lzdCBvZjogY2VsbCwgYXJyb3csIGNlbGwsIGFycm93LCAuLi4gY2VsbFxuICAgICAgLy8gVGhlIGxhc3QgY2VsbCBpcyBub3QgeWV0IHB1c2hlZCBpbnRvIGByb3dgLCBzbzpcbiAgICAgIHJvdy5wdXNoKGNlbGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPZGQtbnVtYmVyZWQgcm93cyBjb25zaXN0IG9mOiB2ZXJ0IGFycm93LCBlbXB0eSBjZWxsLCAuLi4gdmVydCBhcnJvd1xuICAgICAgLy8gUmVtb3ZlIHRoZSBlbXB0eSBjZWxsIHRoYXQgd2FzIHBsYWNlZCBhdCB0aGUgYmVnaW5uaW5nIG9mIGByb3dgLlxuICAgICAgcm93LnNoaWZ0KCk7XG4gICAgfVxuXG4gICAgcm93ID0gW107XG4gICAgYm9keS5wdXNoKHJvdyk7XG4gIH0gLy8gRW5kIHJvdyBncm91cFxuXG5cbiAgcGFyc2VyLmd1bGxldC5lbmRHcm91cCgpOyAvLyBFbmQgYXJyYXkgZ3JvdXAgZGVmaW5pbmcgXFxcXFxuXG4gIHBhcnNlci5ndWxsZXQuZW5kR3JvdXAoKTsgLy8gZGVmaW5lIGNvbHVtbiBzZXBhcmF0aW9uLlxuXG4gIGNvbnN0IGNvbHMgPSBuZXcgQXJyYXkoYm9keVswXS5sZW5ndGgpLmZpbGwoe1xuICAgIHR5cGU6IFwiYWxpZ25cIixcbiAgICBhbGlnbjogXCJjXCIsXG4gICAgcHJlZ2FwOiAwLjI1LFxuICAgIC8vIENEIHBhY2thZ2Ugc2V0cyBcXGVuc2tpcCBiZXR3ZWVuIGNvbHVtbnMuXG4gICAgcG9zdGdhcDogMC4yNSAvLyBTbyBwcmUgYW5kIHBvc3QgZWFjaCBnZXQgaGFsZiBhbiBcXGVuc2tpcCwgaS5lLiAwLjI1ZW0uXG5cbiAgfSk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIG1vZGU6IFwibWF0aFwiLFxuICAgIGJvZHksXG4gICAgYXJyYXlzdHJldGNoOiAxLFxuICAgIGFkZEpvdDogdHJ1ZSxcbiAgICByb3dHYXBzOiBbbnVsbF0sXG4gICAgY29scyxcbiAgICBjb2xTZXBhcmF0aW9uVHlwZTogXCJDRFwiLFxuICAgIGhMaW5lc0JlZm9yZVJvdzogbmV3IEFycmF5KGJvZHkubGVuZ3RoICsgMSkuZmlsbChbXSlcbiAgfTtcbn0gLy8gVGhlIGZ1bmN0aW9ucyBiZWxvdyBhcmUgbm90IGF2YWlsYWJsZSBmb3IgZ2VuZXJhbCB1c2UuXG4vLyBUaGV5IGFyZSBoZXJlIG9ubHkgZm9yIGludGVybmFsIHVzZSBieSB0aGUge0NEfSBlbnZpcm9ubWVudCBpbiBwbGFjaW5nIGxhYmVsc1xuLy8gbmV4dCB0byB2ZXJ0aWNhbCBhcnJvd3MuXG4vLyBXZSBkb24ndCBuZWVkIGFueSBzdWNoIGZ1bmN0aW9ucyBmb3IgaG9yaXpvbnRhbCBhcnJvd3MgYmVjYXVzZSB3ZSBjYW4gcmV1c2Vcbi8vIHRoZSBmdW5jdGlvbmFsaXR5IHRoYXQgYWxyZWFkeSBleGlzdHMgZm9yIGV4dGVuc2libGUgYXJyb3dzLlxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiY2RsYWJlbFwiLFxuICBuYW1lczogW1wiXFxcXFxcXFxjZGxlZnRcIiwgXCJcXFxcXFxcXGNkcmlnaHRcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMVxuICB9LFxuXG4gIGhhbmRsZXIoX3JlZiwgYXJncykge1xuICAgIGxldCB7XG4gICAgICBwYXJzZXIsXG4gICAgICBmdW5jTmFtZVxuICAgIH0gPSBfcmVmO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImNkbGFiZWxcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgc2lkZTogZnVuY05hbWUuc2xpY2UoNCksXG4gICAgICBsYWJlbDogYXJnc1swXVxuICAgIH07XG4gIH0sXG5cbiAgaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBuZXdPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdTdHlsZShvcHRpb25zLnN0eWxlLnN1cCgpKTtcbiAgICBjb25zdCBsYWJlbCA9IGJ1aWxkQ29tbW9uLndyYXBGcmFnbWVudChidWlsZEdyb3VwKGdyb3VwLmxhYmVsLCBuZXdPcHRpb25zLCBvcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgbGFiZWwuY2xhc3Nlcy5wdXNoKFwiY2QtbGFiZWwtXCIgKyBncm91cC5zaWRlKTtcbiAgICBsYWJlbC5zdHlsZS5ib3R0b20gPSBtYWtlRW0oMC44IC0gbGFiZWwuZGVwdGgpOyAvLyBaZXJvIG91dCBsYWJlbCBoZWlnaHQgJiBkZXB0aCwgc28gdmVydGljYWwgYWxpZ24gb2YgYXJyb3cgaXMgc2V0XG4gICAgLy8gYnkgdGhlIGFycm93IGhlaWdodCwgbm90IGJ5IHRoZSBsYWJlbC5cblxuICAgIGxhYmVsLmhlaWdodCA9IDA7XG4gICAgbGFiZWwuZGVwdGggPSAwO1xuICAgIHJldHVybiBsYWJlbDtcbiAgfSxcblxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgbGV0IGxhYmVsID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIsIFtidWlsZE1hdGhNTF9idWlsZEdyb3VwKGdyb3VwLmxhYmVsLCBvcHRpb25zKV0pO1xuICAgIGxhYmVsID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcGFkZGVkXCIsIFtsYWJlbF0pO1xuICAgIGxhYmVsLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiMFwiKTtcblxuICAgIGlmIChncm91cC5zaWRlID09PSBcImxlZnRcIikge1xuICAgICAgbGFiZWwuc2V0QXR0cmlidXRlKFwibHNwYWNlXCIsIFwiLTF3aWR0aFwiKTtcbiAgICB9IC8vIFdlIGhhdmUgdG8gZ3Vlc3MgYXQgdmVydGljYWwgYWxpZ25tZW50LiBXZSBrbm93IHRoZSBhcnJvdyBpcyAxLjhlbSB0YWxsLFxuICAgIC8vIEJ1dCB3ZSBkb24ndCBrbm93IHRoZSBoZWlnaHQgb3IgZGVwdGggb2YgdGhlIGxhYmVsLlxuXG5cbiAgICBsYWJlbC5zZXRBdHRyaWJ1dGUoXCJ2b2Zmc2V0XCIsIFwiMC43ZW1cIik7XG4gICAgbGFiZWwgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1zdHlsZVwiLCBbbGFiZWxdKTtcbiAgICBsYWJlbC5zZXRBdHRyaWJ1dGUoXCJkaXNwbGF5c3R5bGVcIiwgXCJmYWxzZVwiKTtcbiAgICBsYWJlbC5zZXRBdHRyaWJ1dGUoXCJzY3JpcHRsZXZlbFwiLCBcIjFcIik7XG4gICAgcmV0dXJuIGxhYmVsO1xuICB9XG5cbn0pO1xuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImNkbGFiZWxwYXJlbnRcIixcbiAgbmFtZXM6IFtcIlxcXFxcXFxcY2RwYXJlbnRcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMVxuICB9LFxuXG4gIGhhbmRsZXIoX3JlZjIsIGFyZ3MpIHtcbiAgICBsZXQge1xuICAgICAgcGFyc2VyXG4gICAgfSA9IF9yZWYyO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImNkbGFiZWxwYXJlbnRcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgZnJhZ21lbnQ6IGFyZ3NbMF1cbiAgICB9O1xuICB9LFxuXG4gIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gV3JhcCB0aGUgdmVydGljYWwgYXJyb3cgYW5kIGl0cyBsYWJlbHMuXG4gICAgLy8gVGhlIHBhcmVudCBnZXRzIHBvc2l0aW9uOiByZWxhdGl2ZS4gVGhlIGNoaWxkIGdldHMgcG9zaXRpb246IGFic29sdXRlLlxuICAgIC8vIFNvIENTUyBjYW4gbG9jYXRlIHRoZSBsYWJlbCBjb3JyZWN0bHkuXG4gICAgY29uc3QgcGFyZW50ID0gYnVpbGRDb21tb24ud3JhcEZyYWdtZW50KGJ1aWxkR3JvdXAoZ3JvdXAuZnJhZ21lbnQsIG9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICBwYXJlbnQuY2xhc3Nlcy5wdXNoKFwiY2QtdmVydC1hcnJvd1wiKTtcbiAgICByZXR1cm4gcGFyZW50O1xuICB9LFxuXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIsIFtidWlsZE1hdGhNTF9idWlsZEdyb3VwKGdyb3VwLmZyYWdtZW50LCBvcHRpb25zKV0pO1xuICB9XG5cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy9jaGFyLmpzXG5cblxuIC8vIFxcQGNoYXIgaXMgYW4gaW50ZXJuYWwgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIGdyb3VwZWQgZGVjaW1hbCBhcmd1bWVudCBsaWtlXG4vLyB7MTIzfSBhbmQgY29udmVydHMgaW50byBzeW1ib2wgd2l0aCBjb2RlIDEyMy4gIEl0IGlzIHVzZWQgYnkgdGhlICptYWNybypcbi8vIFxcY2hhciBkZWZpbmVkIGluIG1hY3Jvcy5qcy5cblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInRleHRvcmRcIixcbiAgbmFtZXM6IFtcIlxcXFxAY2hhclwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcblxuICBoYW5kbGVyKF9yZWYsIGFyZ3MpIHtcbiAgICBsZXQge1xuICAgICAgcGFyc2VyXG4gICAgfSA9IF9yZWY7XG4gICAgY29uc3QgYXJnID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJvcmRncm91cFwiKTtcbiAgICBjb25zdCBncm91cCA9IGFyZy5ib2R5O1xuICAgIGxldCBudW1iZXIgPSBcIlwiO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncm91cC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgbm9kZSA9IGFzc2VydE5vZGVUeXBlKGdyb3VwW2ldLCBcInRleHRvcmRcIik7XG4gICAgICBudW1iZXIgKz0gbm9kZS50ZXh0O1xuICAgIH1cblxuICAgIGxldCBjb2RlID0gcGFyc2VJbnQobnVtYmVyKTtcbiAgICBsZXQgdGV4dDtcblxuICAgIGlmIChpc05hTihjb2RlKSkge1xuICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiXFxcXEBjaGFyIGhhcyBub24tbnVtZXJpYyBhcmd1bWVudCBcIiArIG51bWJlcik7IC8vIElmIHdlIGRyb3AgSUUgc3VwcG9ydCwgdGhlIGZvbGxvd2luZyBjb2RlIGNvdWxkIGJlIHJlcGxhY2VkIHdpdGhcbiAgICAgIC8vIHRleHQgPSBTdHJpbmcuZnJvbUNvZGVQb2ludChjb2RlKVxuICAgIH0gZWxzZSBpZiAoY29kZSA8IDAgfHwgY29kZSA+PSAweDEwZmZmZikge1xuICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiXFxcXEBjaGFyIHdpdGggaW52YWxpZCBjb2RlIHBvaW50IFwiICsgbnVtYmVyKTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPD0gMHhmZmZmKSB7XG4gICAgICB0ZXh0ID0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXN0cmFsIGNvZGUgcG9pbnQ7IHNwbGl0IGludG8gc3Vycm9nYXRlIGhhbHZlc1xuICAgICAgY29kZSAtPSAweDEwMDAwO1xuICAgICAgdGV4dCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGNvZGUgPj4gMTApICsgMHhkODAwLCAoY29kZSAmIDB4M2ZmKSArIDB4ZGMwMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwidGV4dG9yZFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICB0ZXh0OiB0ZXh0XG4gICAgfTtcbiAgfVxuXG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mdW5jdGlvbnMvY29sb3IuanNcblxuXG5cblxuXG5cblxuY29uc3QgY29sb3JfaHRtbEJ1aWxkZXIgPSAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgZWxlbWVudHMgPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAuYm9keSwgb3B0aW9ucy53aXRoQ29sb3IoZ3JvdXAuY29sb3IpLCBmYWxzZSk7IC8vIFxcY29sb3IgaXNuJ3Qgc3VwcG9zZWQgdG8gYWZmZWN0IHRoZSB0eXBlIG9mIHRoZSBlbGVtZW50cyBpdCBjb250YWlucy5cbiAgLy8gVG8gYWNjb21wbGlzaCB0aGlzLCB3ZSB3cmFwIHRoZSByZXN1bHRzIGluIGEgZnJhZ21lbnQsIHNvIHRoZSBpbm5lclxuICAvLyBlbGVtZW50cyB3aWxsIGJlIGFibGUgdG8gZGlyZWN0bHkgaW50ZXJhY3Qgd2l0aCB0aGVpciBuZWlnaGJvcnMuIEZvclxuICAvLyBleGFtcGxlLCBgXFxjb2xvcntyZWR9ezIgK30gM2AgaGFzIHRoZSBzYW1lIHNwYWNpbmcgYXMgYDIgKyAzYFxuXG4gIHJldHVybiBidWlsZENvbW1vbi5tYWtlRnJhZ21lbnQoZWxlbWVudHMpO1xufTtcblxuY29uc3QgY29sb3JfbWF0aG1sQnVpbGRlciA9IChncm91cCwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBpbm5lciA9IGJ1aWxkTWF0aE1MX2J1aWxkRXhwcmVzc2lvbihncm91cC5ib2R5LCBvcHRpb25zLndpdGhDb2xvcihncm91cC5jb2xvcikpO1xuICBjb25zdCBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtc3R5bGVcIiwgaW5uZXIpO1xuICBub2RlLnNldEF0dHJpYnV0ZShcIm1hdGhjb2xvclwiLCBncm91cC5jb2xvcik7XG4gIHJldHVybiBub2RlO1xufTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImNvbG9yXCIsXG4gIG5hbWVzOiBbXCJcXFxcdGV4dGNvbG9yXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDIsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZSxcbiAgICBhcmdUeXBlczogW1wiY29sb3JcIiwgXCJvcmlnaW5hbFwiXVxuICB9LFxuXG4gIGhhbmRsZXIoX3JlZiwgYXJncykge1xuICAgIGxldCB7XG4gICAgICBwYXJzZXJcbiAgICB9ID0gX3JlZjtcbiAgICBjb25zdCBjb2xvciA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwiY29sb3ItdG9rZW5cIikuY29sb3I7XG4gICAgY29uc3QgYm9keSA9IGFyZ3NbMV07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgY29sb3IsXG4gICAgICBib2R5OiBvcmRhcmd1bWVudChib2R5KVxuICAgIH07XG4gIH0sXG5cbiAgaHRtbEJ1aWxkZXI6IGNvbG9yX2h0bWxCdWlsZGVyLFxuICBtYXRobWxCdWlsZGVyOiBjb2xvcl9tYXRobWxCdWlsZGVyXG59KTtcbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJjb2xvclwiLFxuICBuYW1lczogW1wiXFxcXGNvbG9yXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZSxcbiAgICBhcmdUeXBlczogW1wiY29sb3JcIl1cbiAgfSxcblxuICBoYW5kbGVyKF9yZWYyLCBhcmdzKSB7XG4gICAgbGV0IHtcbiAgICAgIHBhcnNlcixcbiAgICAgIGJyZWFrT25Ub2tlblRleHRcbiAgICB9ID0gX3JlZjI7XG4gICAgY29uc3QgY29sb3IgPSBhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcImNvbG9yLXRva2VuXCIpLmNvbG9yOyAvLyBTZXQgbWFjcm8gXFxjdXJyZW50QGNvbG9yIGluIGN1cnJlbnQgbmFtZXNwYWNlIHRvIHN0b3JlIHRoZSBjdXJyZW50XG4gICAgLy8gY29sb3IsIG1pbWlja2luZyB0aGUgYmVoYXZpb3Igb2YgY29sb3Iuc3R5LlxuICAgIC8vIFRoaXMgaXMgY3VycmVudGx5IHVzZWQganVzdCB0byBjb3JyZWN0bHkgY29sb3IgYSBcXHJpZ2h0XG4gICAgLy8gdGhhdCBmb2xsb3dzIGEgXFxjb2xvciBjb21tYW5kLlxuXG4gICAgcGFyc2VyLmd1bGxldC5tYWNyb3Muc2V0KFwiXFxcXGN1cnJlbnRAY29sb3JcIiwgY29sb3IpOyAvLyBQYXJzZSBvdXQgdGhlIGltcGxpY2l0IGJvZHkgdGhhdCBzaG91bGQgYmUgY29sb3JlZC5cblxuICAgIGNvbnN0IGJvZHkgPSBwYXJzZXIucGFyc2VFeHByZXNzaW9uKHRydWUsIGJyZWFrT25Ub2tlblRleHQpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGNvbG9yLFxuICAgICAgYm9keVxuICAgIH07XG4gIH0sXG5cbiAgaHRtbEJ1aWxkZXI6IGNvbG9yX2h0bWxCdWlsZGVyLFxuICBtYXRobWxCdWlsZGVyOiBjb2xvcl9tYXRobWxCdWlsZGVyXG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mdW5jdGlvbnMvY3IuanNcbi8vIFJvdyBicmVha3Mgd2l0aGluIHRhYnVsYXIgZW52aXJvbm1lbnRzLCBhbmQgbGluZSBicmVha3MgYXQgdG9wIGxldmVsXG5cblxuXG5cbiAvLyBcXERlY2xhcmVSb2J1c3RDb21tYW5kXFxcXHsuLi5cXEB4bmV3bGluZX1cblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImNyXCIsXG4gIG5hbWVzOiBbXCJcXFxcXFxcXFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwLFxuICAgIG51bU9wdGlvbmFsQXJnczogMCxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG5cbiAgaGFuZGxlcihfcmVmLCBhcmdzLCBvcHRBcmdzKSB7XG4gICAgbGV0IHtcbiAgICAgIHBhcnNlclxuICAgIH0gPSBfcmVmO1xuICAgIGNvbnN0IHNpemUgPSBwYXJzZXIuZ3VsbGV0LmZ1dHVyZSgpLnRleHQgPT09IFwiW1wiID8gcGFyc2VyLnBhcnNlU2l6ZUdyb3VwKHRydWUpIDogbnVsbDtcbiAgICBjb25zdCBuZXdMaW5lID0gIXBhcnNlci5zZXR0aW5ncy5kaXNwbGF5TW9kZSB8fCAhcGFyc2VyLnNldHRpbmdzLnVzZVN0cmljdEJlaGF2aW9yKFwibmV3TGluZUluRGlzcGxheU1vZGVcIiwgXCJJbiBMYVRlWCwgXFxcXFxcXFwgb3IgXFxcXG5ld2xpbmUgXCIgKyBcImRvZXMgbm90aGluZyBpbiBkaXNwbGF5IG1vZGVcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiY3JcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbmV3TGluZSxcbiAgICAgIHNpemU6IHNpemUgJiYgYXNzZXJ0Tm9kZVR5cGUoc2l6ZSwgXCJzaXplXCIpLnZhbHVlXG4gICAgfTtcbiAgfSxcblxuICAvLyBUaGUgZm9sbG93aW5nIGJ1aWxkZXJzIGFyZSBjYWxsZWQgb25seSBhdCB0aGUgdG9wIGxldmVsLFxuICAvLyBub3Qgd2l0aGluIHRhYnVsYXIvYXJyYXkgZW52aXJvbm1lbnRzLlxuICBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHNwYW4gPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtc3BhY2VcIl0sIFtdLCBvcHRpb25zKTtcblxuICAgIGlmIChncm91cC5uZXdMaW5lKSB7XG4gICAgICBzcGFuLmNsYXNzZXMucHVzaChcIm5ld2xpbmVcIik7XG5cbiAgICAgIGlmIChncm91cC5zaXplKSB7XG4gICAgICAgIHNwYW4uc3R5bGUubWFyZ2luVG9wID0gbWFrZUVtKGNhbGN1bGF0ZVNpemUoZ3JvdXAuc2l6ZSwgb3B0aW9ucykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzcGFuO1xuICB9LFxuXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtc3BhY2VcIik7XG5cbiAgICBpZiAoZ3JvdXAubmV3TGluZSkge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJsaW5lYnJlYWtcIiwgXCJuZXdsaW5lXCIpO1xuXG4gICAgICBpZiAoZ3JvdXAuc2l6ZSkge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBtYWtlRW0oY2FsY3VsYXRlU2l6ZShncm91cC5zaXplLCBvcHRpb25zKSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy9kZWYuanNcblxuXG5cbmNvbnN0IGdsb2JhbE1hcCA9IHtcbiAgXCJcXFxcZ2xvYmFsXCI6IFwiXFxcXGdsb2JhbFwiLFxuICBcIlxcXFxsb25nXCI6IFwiXFxcXFxcXFxnbG9iYWxsb25nXCIsXG4gIFwiXFxcXFxcXFxnbG9iYWxsb25nXCI6IFwiXFxcXFxcXFxnbG9iYWxsb25nXCIsXG4gIFwiXFxcXGRlZlwiOiBcIlxcXFxnZGVmXCIsXG4gIFwiXFxcXGdkZWZcIjogXCJcXFxcZ2RlZlwiLFxuICBcIlxcXFxlZGVmXCI6IFwiXFxcXHhkZWZcIixcbiAgXCJcXFxceGRlZlwiOiBcIlxcXFx4ZGVmXCIsXG4gIFwiXFxcXGxldFwiOiBcIlxcXFxcXFxcZ2xvYmFsbGV0XCIsXG4gIFwiXFxcXGZ1dHVyZWxldFwiOiBcIlxcXFxcXFxcZ2xvYmFsZnV0dXJlXCJcbn07XG5cbmNvbnN0IGNoZWNrQ29udHJvbFNlcXVlbmNlID0gdG9rID0+IHtcbiAgY29uc3QgbmFtZSA9IHRvay50ZXh0O1xuXG4gIGlmICgvXig/OltcXFxce30kJiNeX118RU9GKSQvLnRlc3QobmFtZSkpIHtcbiAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJFeHBlY3RlZCBhIGNvbnRyb2wgc2VxdWVuY2VcIiwgdG9rKTtcbiAgfVxuXG4gIHJldHVybiBuYW1lO1xufTtcblxuY29uc3QgZ2V0UkhTID0gcGFyc2VyID0+IHtcbiAgbGV0IHRvayA9IHBhcnNlci5ndWxsZXQucG9wVG9rZW4oKTtcblxuICBpZiAodG9rLnRleHQgPT09IFwiPVwiKSB7XG4gICAgLy8gY29uc3VtZSBvcHRpb25hbCBlcXVhbHNcbiAgICB0b2sgPSBwYXJzZXIuZ3VsbGV0LnBvcFRva2VuKCk7XG5cbiAgICBpZiAodG9rLnRleHQgPT09IFwiIFwiKSB7XG4gICAgICAvLyBjb25zdW1lIG9uZSBvcHRpb25hbCBzcGFjZVxuICAgICAgdG9rID0gcGFyc2VyLmd1bGxldC5wb3BUb2tlbigpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0b2s7XG59O1xuXG5jb25zdCBsZXRDb21tYW5kID0gKHBhcnNlciwgbmFtZSwgdG9rLCBnbG9iYWwpID0+IHtcbiAgbGV0IG1hY3JvID0gcGFyc2VyLmd1bGxldC5tYWNyb3MuZ2V0KHRvay50ZXh0KTtcblxuICBpZiAobWFjcm8gPT0gbnVsbCkge1xuICAgIC8vIGRvbid0IGV4cGFuZCBpdCBsYXRlciBldmVuIGlmIGEgbWFjcm8gd2l0aCB0aGUgc2FtZSBuYW1lIGlzIGRlZmluZWRcbiAgICAvLyBlLmcuLCBcXGxldFxcZm9vPVxcZnJhYyBcXGRlZlxcZnJhY3tcXHJlbGF4fSBcXGZyYWMxMlxuICAgIHRvay5ub2V4cGFuZCA9IHRydWU7XG4gICAgbWFjcm8gPSB7XG4gICAgICB0b2tlbnM6IFt0b2tdLFxuICAgICAgbnVtQXJnczogMCxcbiAgICAgIC8vIHJlcHJvZHVjZSB0aGUgc2FtZSBiZWhhdmlvciBpbiBleHBhbnNpb25cbiAgICAgIHVuZXhwYW5kYWJsZTogIXBhcnNlci5ndWxsZXQuaXNFeHBhbmRhYmxlKHRvay50ZXh0KVxuICAgIH07XG4gIH1cblxuICBwYXJzZXIuZ3VsbGV0Lm1hY3Jvcy5zZXQobmFtZSwgbWFjcm8sIGdsb2JhbCk7XG59OyAvLyA8YXNzaWdubWVudD4gLT4gPG5vbi1tYWNybyBhc3NpZ25tZW50Pnw8bWFjcm8gYXNzaWdubWVudD5cbi8vIDxub24tbWFjcm8gYXNzaWdubWVudD4gLT4gPHNpbXBsZSBhc3NpZ25tZW50PnxcXGdsb2JhbDxub24tbWFjcm8gYXNzaWdubWVudD5cbi8vIDxtYWNybyBhc3NpZ25tZW50PiAtPiA8ZGVmaW5pdGlvbj58PHByZWZpeD48bWFjcm8gYXNzaWdubWVudD5cbi8vIDxwcmVmaXg+IC0+IFxcZ2xvYmFsfFxcbG9uZ3xcXG91dGVyXG5cblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImludGVybmFsXCIsXG4gIG5hbWVzOiBbXCJcXFxcZ2xvYmFsXCIsIFwiXFxcXGxvbmdcIiwgXCJcXFxcXFxcXGdsb2JhbGxvbmdcIiAvLyBjYW7igJl0IGJlIGVudGVyZWQgZGlyZWN0bHlcbiAgXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcblxuICBoYW5kbGVyKF9yZWYpIHtcbiAgICBsZXQge1xuICAgICAgcGFyc2VyLFxuICAgICAgZnVuY05hbWVcbiAgICB9ID0gX3JlZjtcbiAgICBwYXJzZXIuY29uc3VtZVNwYWNlcygpO1xuICAgIGNvbnN0IHRva2VuID0gcGFyc2VyLmZldGNoKCk7XG5cbiAgICBpZiAoZ2xvYmFsTWFwW3Rva2VuLnRleHRdKSB7XG4gICAgICAvLyBLYVRlWCBkb2Vzbid0IGhhdmUgXFxwYXIsIHNvIGlnbm9yZSBcXGxvbmdcbiAgICAgIGlmIChmdW5jTmFtZSA9PT0gXCJcXFxcZ2xvYmFsXCIgfHwgZnVuY05hbWUgPT09IFwiXFxcXFxcXFxnbG9iYWxsb25nXCIpIHtcbiAgICAgICAgdG9rZW4udGV4dCA9IGdsb2JhbE1hcFt0b2tlbi50ZXh0XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFzc2VydE5vZGVUeXBlKHBhcnNlci5wYXJzZUZ1bmN0aW9uKCksIFwiaW50ZXJuYWxcIik7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiSW52YWxpZCB0b2tlbiBhZnRlciBtYWNybyBwcmVmaXhcIiwgdG9rZW4pO1xuICB9XG5cbn0pOyAvLyBCYXNpYyBzdXBwb3J0IGZvciBtYWNybyBkZWZpbml0aW9uczogXFxkZWYsIFxcZ2RlZiwgXFxlZGVmLCBcXHhkZWZcbi8vIDxkZWZpbml0aW9uPiAtPiA8ZGVmPjxjb250cm9sIHNlcXVlbmNlPjxkZWZpbml0aW9uIHRleHQ+XG4vLyA8ZGVmPiAtPiBcXGRlZnxcXGdkZWZ8XFxlZGVmfFxceGRlZlxuLy8gPGRlZmluaXRpb24gdGV4dD4gLT4gPHBhcmFtZXRlciB0ZXh0PjxsZWZ0IGJyYWNlPjxiYWxhbmNlZCB0ZXh0PjxyaWdodCBicmFjZT5cblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImludGVybmFsXCIsXG4gIG5hbWVzOiBbXCJcXFxcZGVmXCIsIFwiXFxcXGdkZWZcIiwgXCJcXFxcZWRlZlwiLCBcIlxcXFx4ZGVmXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDAsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZSxcbiAgICBwcmltaXRpdmU6IHRydWVcbiAgfSxcblxuICBoYW5kbGVyKF9yZWYyKSB7XG4gICAgbGV0IHtcbiAgICAgIHBhcnNlcixcbiAgICAgIGZ1bmNOYW1lXG4gICAgfSA9IF9yZWYyO1xuICAgIGxldCB0b2sgPSBwYXJzZXIuZ3VsbGV0LnBvcFRva2VuKCk7XG4gICAgY29uc3QgbmFtZSA9IHRvay50ZXh0O1xuXG4gICAgaWYgKC9eKD86W1xcXFx7fSQmI15fXXxFT0YpJC8udGVzdChuYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiRXhwZWN0ZWQgYSBjb250cm9sIHNlcXVlbmNlXCIsIHRvayk7XG4gICAgfVxuXG4gICAgbGV0IG51bUFyZ3MgPSAwO1xuICAgIGxldCBpbnNlcnQ7XG4gICAgY29uc3QgZGVsaW1pdGVycyA9IFtbXV07IC8vIDxwYXJhbWV0ZXIgdGV4dD4gY29udGFpbnMgbm8gYnJhY2VzXG5cbiAgICB3aGlsZSAocGFyc2VyLmd1bGxldC5mdXR1cmUoKS50ZXh0ICE9PSBcIntcIikge1xuICAgICAgdG9rID0gcGFyc2VyLmd1bGxldC5wb3BUb2tlbigpO1xuXG4gICAgICBpZiAodG9rLnRleHQgPT09IFwiI1wiKSB7XG4gICAgICAgIC8vIElmIHRoZSB2ZXJ5IGxhc3QgY2hhcmFjdGVyIG9mIHRoZSA8cGFyYW1ldGVyIHRleHQ+IGlzICMsIHNvIHRoYXRcbiAgICAgICAgLy8gdGhpcyAjIGlzIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IHssIFRlWCB3aWxsIGJlaGF2ZSBhcyBpZiB0aGUge1xuICAgICAgICAvLyBoYWQgYmVlbiBpbnNlcnRlZCBhdCB0aGUgcmlnaHQgZW5kIG9mIGJvdGggdGhlIHBhcmFtZXRlciB0ZXh0XG4gICAgICAgIC8vIGFuZCB0aGUgcmVwbGFjZW1lbnQgdGV4dC5cbiAgICAgICAgaWYgKHBhcnNlci5ndWxsZXQuZnV0dXJlKCkudGV4dCA9PT0gXCJ7XCIpIHtcbiAgICAgICAgICBpbnNlcnQgPSBwYXJzZXIuZ3VsbGV0LmZ1dHVyZSgpO1xuICAgICAgICAgIGRlbGltaXRlcnNbbnVtQXJnc10ucHVzaChcIntcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gLy8gQSBwYXJhbWV0ZXIsIHRoZSBmaXJzdCBhcHBlYXJhbmNlIG9mICMgbXVzdCBiZSBmb2xsb3dlZCBieSAxLFxuICAgICAgICAvLyB0aGUgbmV4dCBieSAyLCBhbmQgc28gb247IHVwIHRvIG5pbmUgI+KAmXMgYXJlIGFsbG93ZWRcblxuXG4gICAgICAgIHRvayA9IHBhcnNlci5ndWxsZXQucG9wVG9rZW4oKTtcblxuICAgICAgICBpZiAoIS9eWzEtOV0kLy50ZXN0KHRvay50ZXh0KSkge1xuICAgICAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIkludmFsaWQgYXJndW1lbnQgbnVtYmVyIFxcXCJcIiArIHRvay50ZXh0ICsgXCJcXFwiXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcnNlSW50KHRvay50ZXh0KSAhPT0gbnVtQXJncyArIDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJBcmd1bWVudCBudW1iZXIgXFxcIlwiICsgdG9rLnRleHQgKyBcIlxcXCIgb3V0IG9mIG9yZGVyXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgbnVtQXJncysrO1xuICAgICAgICBkZWxpbWl0ZXJzLnB1c2goW10pO1xuICAgICAgfSBlbHNlIGlmICh0b2sudGV4dCA9PT0gXCJFT0ZcIikge1xuICAgICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJFeHBlY3RlZCBhIG1hY3JvIGRlZmluaXRpb25cIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxpbWl0ZXJzW251bUFyZ3NdLnB1c2godG9rLnRleHQpO1xuICAgICAgfVxuICAgIH0gLy8gcmVwbGFjZW1lbnQgdGV4dCwgZW5jbG9zZWQgaW4gJ3snIGFuZCAnfScgYW5kIHByb3Blcmx5IG5lc3RlZFxuXG5cbiAgICBsZXQge1xuICAgICAgdG9rZW5zXG4gICAgfSA9IHBhcnNlci5ndWxsZXQuY29uc3VtZUFyZygpO1xuXG4gICAgaWYgKGluc2VydCkge1xuICAgICAgdG9rZW5zLnVuc2hpZnQoaW5zZXJ0KTtcbiAgICB9XG5cbiAgICBpZiAoZnVuY05hbWUgPT09IFwiXFxcXGVkZWZcIiB8fCBmdW5jTmFtZSA9PT0gXCJcXFxceGRlZlwiKSB7XG4gICAgICB0b2tlbnMgPSBwYXJzZXIuZ3VsbGV0LmV4cGFuZFRva2Vucyh0b2tlbnMpO1xuICAgICAgdG9rZW5zLnJldmVyc2UoKTsgLy8gdG8gZml0IGluIHdpdGggc3RhY2sgb3JkZXJcbiAgICB9IC8vIEZpbmFsIGFyZyBpcyB0aGUgZXhwYW5zaW9uIG9mIHRoZSBtYWNyb1xuXG5cbiAgICBwYXJzZXIuZ3VsbGV0Lm1hY3Jvcy5zZXQobmFtZSwge1xuICAgICAgdG9rZW5zLFxuICAgICAgbnVtQXJncyxcbiAgICAgIGRlbGltaXRlcnNcbiAgICB9LCBmdW5jTmFtZSA9PT0gZ2xvYmFsTWFwW2Z1bmNOYW1lXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiaW50ZXJuYWxcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlXG4gICAgfTtcbiAgfVxuXG59KTsgLy8gPHNpbXBsZSBhc3NpZ25tZW50PiAtPiA8bGV0IGFzc2lnbm1lbnQ+XG4vLyA8bGV0IGFzc2lnbm1lbnQ+IC0+IFxcZnV0dXJlbGV0PGNvbnRyb2wgc2VxdWVuY2U+PHRva2VuPjx0b2tlbj5cbi8vICAgICB8IFxcbGV0PGNvbnRyb2wgc2VxdWVuY2U+PGVxdWFscz48b25lIG9wdGlvbmFsIHNwYWNlPjx0b2tlbj5cbi8vIDxlcXVhbHM+IC0+IDxvcHRpb25hbCBzcGFjZXM+fDxvcHRpb25hbCBzcGFjZXM+PVxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiaW50ZXJuYWxcIixcbiAgbmFtZXM6IFtcIlxcXFxsZXRcIiwgXCJcXFxcXFxcXGdsb2JhbGxldFwiIC8vIGNhbuKAmXQgYmUgZW50ZXJlZCBkaXJlY3RseVxuICBdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDAsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZSxcbiAgICBwcmltaXRpdmU6IHRydWVcbiAgfSxcblxuICBoYW5kbGVyKF9yZWYzKSB7XG4gICAgbGV0IHtcbiAgICAgIHBhcnNlcixcbiAgICAgIGZ1bmNOYW1lXG4gICAgfSA9IF9yZWYzO1xuICAgIGNvbnN0IG5hbWUgPSBjaGVja0NvbnRyb2xTZXF1ZW5jZShwYXJzZXIuZ3VsbGV0LnBvcFRva2VuKCkpO1xuICAgIHBhcnNlci5ndWxsZXQuY29uc3VtZVNwYWNlcygpO1xuICAgIGNvbnN0IHRvayA9IGdldFJIUyhwYXJzZXIpO1xuICAgIGxldENvbW1hbmQocGFyc2VyLCBuYW1lLCB0b2ssIGZ1bmNOYW1lID09PSBcIlxcXFxcXFxcZ2xvYmFsbGV0XCIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImludGVybmFsXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZVxuICAgIH07XG4gIH1cblxufSk7IC8vIHJlZjogaHR0cHM6Ly93d3cudHVnLm9yZy9UVUdib2F0L3RiMDktMy90YjIyYmVjaHRvbHNoZWltLnBkZlxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiaW50ZXJuYWxcIixcbiAgbmFtZXM6IFtcIlxcXFxmdXR1cmVsZXRcIiwgXCJcXFxcXFxcXGdsb2JhbGZ1dHVyZVwiIC8vIGNhbuKAmXQgYmUgZW50ZXJlZCBkaXJlY3RseVxuICBdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDAsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZSxcbiAgICBwcmltaXRpdmU6IHRydWVcbiAgfSxcblxuICBoYW5kbGVyKF9yZWY0KSB7XG4gICAgbGV0IHtcbiAgICAgIHBhcnNlcixcbiAgICAgIGZ1bmNOYW1lXG4gICAgfSA9IF9yZWY0O1xuICAgIGNvbnN0IG5hbWUgPSBjaGVja0NvbnRyb2xTZXF1ZW5jZShwYXJzZXIuZ3VsbGV0LnBvcFRva2VuKCkpO1xuICAgIGNvbnN0IG1pZGRsZSA9IHBhcnNlci5ndWxsZXQucG9wVG9rZW4oKTtcbiAgICBjb25zdCB0b2sgPSBwYXJzZXIuZ3VsbGV0LnBvcFRva2VuKCk7XG4gICAgbGV0Q29tbWFuZChwYXJzZXIsIG5hbWUsIHRvaywgZnVuY05hbWUgPT09IFwiXFxcXFxcXFxnbG9iYWxmdXR1cmVcIik7XG4gICAgcGFyc2VyLmd1bGxldC5wdXNoVG9rZW4odG9rKTtcbiAgICBwYXJzZXIuZ3VsbGV0LnB1c2hUb2tlbihtaWRkbGUpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImludGVybmFsXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZVxuICAgIH07XG4gIH1cblxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZGVsaW1pdGVyLmpzXG4vKipcbiAqIFRoaXMgZmlsZSBkZWFscyB3aXRoIGNyZWF0aW5nIGRlbGltaXRlcnMgb2YgdmFyaW91cyBzaXplcy4gVGhlIFRlWGJvb2tcbiAqIGRpc2N1c3NlcyB0aGVzZSByb3V0aW5lcyBvbiBwYWdlIDQ0MS00NDIsIGluIHRoZSBcIkFub3RoZXIgc3Vicm91dGluZSBzZXRzIGJveFxuICogeCB0byBhIHNwZWNpZmllZCB2YXJpYWJsZSBkZWxpbWl0ZXJcIiBwYXJhZ3JhcGguXG4gKlxuICogVGhlcmUgYXJlIHRocmVlIG1haW4gcm91dGluZXMgaGVyZS4gYG1ha2VTbWFsbERlbGltYCBtYWtlcyBhIGRlbGltaXRlciBpbiB0aGVcbiAqIG5vcm1hbCBmb250LCBidXQgaW4gZWl0aGVyIHRleHQsIHNjcmlwdCwgb3Igc2NyaXB0c2NyaXB0IHN0eWxlLlxuICogYG1ha2VMYXJnZURlbGltYCBtYWtlcyBhIGRlbGltaXRlciBpbiB0ZXh0c3R5bGUsIGJ1dCBpbiBvbmUgb2YgdGhlIFNpemUxLFxuICogU2l6ZTIsIFNpemUzLCBvciBTaXplNCBmb250cy4gYG1ha2VTdGFja2VkRGVsaW1gIG1ha2VzIGEgZGVsaW1pdGVyIG91dCBvZlxuICogc21hbGxlciBwaWVjZXMgdGhhdCBhcmUgc3RhY2tlZCBvbiB0b3Agb2Ygb25lIGFub3RoZXIuXG4gKlxuICogVGhlIGZ1bmN0aW9ucyB0YWtlIGEgcGFyYW1ldGVyIGBjZW50ZXJgLCB3aGljaCBkZXRlcm1pbmVzIGlmIHRoZSBkZWxpbWl0ZXJcbiAqIHNob3VsZCBiZSBjZW50ZXJlZCBhcm91bmQgdGhlIGF4aXMuXG4gKlxuICogVGhlbiwgdGhlcmUgYXJlIHRocmVlIGV4cG9zZWQgZnVuY3Rpb25zLiBgc2l6ZWREZWxpbWAgbWFrZXMgYSBkZWxpbWl0ZXIgaW5cbiAqIG9uZSBvZiB0aGUgZ2l2ZW4gc2l6ZXMuIFRoaXMgaXMgdXNlZCBmb3IgdGhpbmdzIGxpa2UgYFxcYmlnbGAuXG4gKiBgY3VzdG9tU2l6ZWREZWxpbWAgbWFrZXMgYSBkZWxpbWl0ZXIgd2l0aCBhIGdpdmVuIHRvdGFsIGhlaWdodCtkZXB0aC4gSXQgaXNcbiAqIGNhbGxlZCBpbiBwbGFjZXMgbGlrZSBgXFxzcXJ0YC4gYGxlZnRSaWdodERlbGltYCBtYWtlcyBhbiBhcHByb3ByaWF0ZVxuICogZGVsaW1pdGVyIHdoaWNoIHN1cnJvdW5kcyBhbiBleHByZXNzaW9uIG9mIGEgZ2l2ZW4gaGVpZ2h0IGFuIGRlcHRoLiBJdCBpc1xuICogdXNlZCBpbiBgXFxsZWZ0YCBhbmQgYFxccmlnaHRgLlxuICovXG5cblxuXG5cblxuXG5cblxuXG5cblxuLyoqXG4gKiBHZXQgdGhlIG1ldHJpY3MgZm9yIGEgZ2l2ZW4gc3ltYm9sIGFuZCBmb250LCBhZnRlciB0cmFuc2Zvcm1hdGlvbiAoaS5lLlxuICogYWZ0ZXIgZm9sbG93aW5nIHJlcGxhY2VtZW50IGZyb20gc3ltYm9scy5qcylcbiAqL1xuY29uc3QgZ2V0TWV0cmljcyA9IGZ1bmN0aW9uIChzeW1ib2wsIGZvbnQsIG1vZGUpIHtcbiAgY29uc3QgcmVwbGFjZSA9IHNyY19zeW1ib2xzLm1hdGhbc3ltYm9sXSAmJiBzcmNfc3ltYm9scy5tYXRoW3N5bWJvbF0ucmVwbGFjZTtcbiAgY29uc3QgbWV0cmljcyA9IGdldENoYXJhY3Rlck1ldHJpY3MocmVwbGFjZSB8fCBzeW1ib2wsIGZvbnQsIG1vZGUpO1xuXG4gIGlmICghbWV0cmljcykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIHN5bWJvbCBcIiArIHN5bWJvbCArIFwiIGFuZCBmb250IHNpemUgXCIgKyBmb250ICsgXCIuXCIpO1xuICB9XG5cbiAgcmV0dXJuIG1ldHJpY3M7XG59O1xuLyoqXG4gKiBQdXRzIGEgZGVsaW1pdGVyIHNwYW4gaW4gYSBnaXZlbiBzdHlsZSwgYW5kIGFkZHMgYXBwcm9wcmlhdGUgaGVpZ2h0LCBkZXB0aCxcbiAqIGFuZCBtYXhGb250U2l6ZXMuXG4gKi9cblxuXG5jb25zdCBzdHlsZVdyYXAgPSBmdW5jdGlvbiAoZGVsaW0sIHRvU3R5bGUsIG9wdGlvbnMsIGNsYXNzZXMpIHtcbiAgY29uc3QgbmV3T3B0aW9ucyA9IG9wdGlvbnMuaGF2aW5nQmFzZVN0eWxlKHRvU3R5bGUpO1xuICBjb25zdCBzcGFuID0gYnVpbGRDb21tb24ubWFrZVNwYW4oY2xhc3Nlcy5jb25jYXQobmV3T3B0aW9ucy5zaXppbmdDbGFzc2VzKG9wdGlvbnMpKSwgW2RlbGltXSwgb3B0aW9ucyk7XG4gIGNvbnN0IGRlbGltU2l6ZU11bHRpcGxpZXIgPSBuZXdPcHRpb25zLnNpemVNdWx0aXBsaWVyIC8gb3B0aW9ucy5zaXplTXVsdGlwbGllcjtcbiAgc3Bhbi5oZWlnaHQgKj0gZGVsaW1TaXplTXVsdGlwbGllcjtcbiAgc3Bhbi5kZXB0aCAqPSBkZWxpbVNpemVNdWx0aXBsaWVyO1xuICBzcGFuLm1heEZvbnRTaXplID0gbmV3T3B0aW9ucy5zaXplTXVsdGlwbGllcjtcbiAgcmV0dXJuIHNwYW47XG59O1xuXG5jb25zdCBjZW50ZXJTcGFuID0gZnVuY3Rpb24gKHNwYW4sIG9wdGlvbnMsIHN0eWxlKSB7XG4gIGNvbnN0IG5ld09wdGlvbnMgPSBvcHRpb25zLmhhdmluZ0Jhc2VTdHlsZShzdHlsZSk7XG4gIGNvbnN0IHNoaWZ0ID0gKDEgLSBvcHRpb25zLnNpemVNdWx0aXBsaWVyIC8gbmV3T3B0aW9ucy5zaXplTXVsdGlwbGllcikgKiBvcHRpb25zLmZvbnRNZXRyaWNzKCkuYXhpc0hlaWdodDtcbiAgc3Bhbi5jbGFzc2VzLnB1c2goXCJkZWxpbWNlbnRlclwiKTtcbiAgc3Bhbi5zdHlsZS50b3AgPSBtYWtlRW0oc2hpZnQpO1xuICBzcGFuLmhlaWdodCAtPSBzaGlmdDtcbiAgc3Bhbi5kZXB0aCArPSBzaGlmdDtcbn07XG4vKipcbiAqIE1ha2VzIGEgc21hbGwgZGVsaW1pdGVyLiBUaGlzIGlzIGEgZGVsaW1pdGVyIHRoYXQgY29tZXMgaW4gdGhlIE1haW4tUmVndWxhclxuICogZm9udCwgYnV0IGlzIHJlc3R5bGVkIHRvIGVpdGhlciBiZSBpbiB0ZXh0c3R5bGUsIHNjcmlwdHN0eWxlLCBvclxuICogc2NyaXB0c2NyaXB0c3R5bGUuXG4gKi9cblxuXG5jb25zdCBtYWtlU21hbGxEZWxpbSA9IGZ1bmN0aW9uIChkZWxpbSwgc3R5bGUsIGNlbnRlciwgb3B0aW9ucywgbW9kZSwgY2xhc3Nlcykge1xuICBjb25zdCB0ZXh0ID0gYnVpbGRDb21tb24ubWFrZVN5bWJvbChkZWxpbSwgXCJNYWluLVJlZ3VsYXJcIiwgbW9kZSwgb3B0aW9ucyk7XG4gIGNvbnN0IHNwYW4gPSBzdHlsZVdyYXAodGV4dCwgc3R5bGUsIG9wdGlvbnMsIGNsYXNzZXMpO1xuXG4gIGlmIChjZW50ZXIpIHtcbiAgICBjZW50ZXJTcGFuKHNwYW4sIG9wdGlvbnMsIHN0eWxlKTtcbiAgfVxuXG4gIHJldHVybiBzcGFuO1xufTtcbi8qKlxuICogQnVpbGRzIGEgc3ltYm9sIGluIHRoZSBnaXZlbiBmb250IHNpemUgKG5vdGUgc2l6ZSBpcyBhbiBpbnRlZ2VyKVxuICovXG5cblxuY29uc3QgbWF0aHJtU2l6ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgc2l6ZSwgbW9kZSwgb3B0aW9ucykge1xuICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVN5bWJvbCh2YWx1ZSwgXCJTaXplXCIgKyBzaXplICsgXCItUmVndWxhclwiLCBtb2RlLCBvcHRpb25zKTtcbn07XG4vKipcbiAqIE1ha2VzIGEgbGFyZ2UgZGVsaW1pdGVyLiBUaGlzIGlzIGEgZGVsaW1pdGVyIHRoYXQgY29tZXMgaW4gdGhlIFNpemUxLCBTaXplMixcbiAqIFNpemUzLCBvciBTaXplNCBmb250cy4gSXQgaXMgYWx3YXlzIHJlbmRlcmVkIGluIHRleHRzdHlsZS5cbiAqL1xuXG5cbmNvbnN0IG1ha2VMYXJnZURlbGltID0gZnVuY3Rpb24gKGRlbGltLCBzaXplLCBjZW50ZXIsIG9wdGlvbnMsIG1vZGUsIGNsYXNzZXMpIHtcbiAgY29uc3QgaW5uZXIgPSBtYXRocm1TaXplKGRlbGltLCBzaXplLCBtb2RlLCBvcHRpb25zKTtcbiAgY29uc3Qgc3BhbiA9IHN0eWxlV3JhcChidWlsZENvbW1vbi5tYWtlU3BhbihbXCJkZWxpbXNpemluZ1wiLCBcInNpemVcIiArIHNpemVdLCBbaW5uZXJdLCBvcHRpb25zKSwgc3JjX1N0eWxlLlRFWFQsIG9wdGlvbnMsIGNsYXNzZXMpO1xuXG4gIGlmIChjZW50ZXIpIHtcbiAgICBjZW50ZXJTcGFuKHNwYW4sIG9wdGlvbnMsIHNyY19TdHlsZS5URVhUKTtcbiAgfVxuXG4gIHJldHVybiBzcGFuO1xufTtcbi8qKlxuICogTWFrZSBhIHNwYW4gZnJvbSBhIGZvbnQgZ2x5cGggd2l0aCB0aGUgZ2l2ZW4gb2Zmc2V0IGFuZCBpbiB0aGUgZ2l2ZW4gZm9udC5cbiAqIFRoaXMgaXMgdXNlZCBpbiBtYWtlU3RhY2tlZERlbGltIHRvIG1ha2UgdGhlIHN0YWNraW5nIHBpZWNlcyBmb3IgdGhlIGRlbGltaXRlci5cbiAqL1xuXG5cbmNvbnN0IG1ha2VHbHlwaFNwYW4gPSBmdW5jdGlvbiAoc3ltYm9sLCBmb250LCBtb2RlKSB7XG4gIGxldCBzaXplQ2xhc3M7IC8vIEFwcGx5IHRoZSBjb3JyZWN0IENTUyBjbGFzcyB0byBjaG9vc2UgdGhlIHJpZ2h0IGZvbnQuXG5cbiAgaWYgKGZvbnQgPT09IFwiU2l6ZTEtUmVndWxhclwiKSB7XG4gICAgc2l6ZUNsYXNzID0gXCJkZWxpbS1zaXplMVwiO1xuICB9IGVsc2VcbiAgICAvKiBpZiAoZm9udCA9PT0gXCJTaXplNC1SZWd1bGFyXCIpICovXG4gICAge1xuICAgICAgc2l6ZUNsYXNzID0gXCJkZWxpbS1zaXplNFwiO1xuICAgIH1cblxuICBjb25zdCBjb3JuZXIgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJkZWxpbXNpemluZ2lubmVyXCIsIHNpemVDbGFzc10sIFtidWlsZENvbW1vbi5tYWtlU3BhbihbXSwgW2J1aWxkQ29tbW9uLm1ha2VTeW1ib2woc3ltYm9sLCBmb250LCBtb2RlKV0pXSk7IC8vIFNpbmNlIHRoaXMgd2lsbCBiZSBwYXNzZWQgaW50byBgbWFrZVZMaXN0YCBpbiB0aGUgZW5kLCB3cmFwIHRoZSBlbGVtZW50XG4gIC8vIGluIHRoZSBhcHByb3ByaWF0ZSB0YWcgdGhhdCBWTGlzdCB1c2VzLlxuXG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJlbGVtXCIsXG4gICAgZWxlbTogY29ybmVyXG4gIH07XG59O1xuXG5jb25zdCBtYWtlSW5uZXIgPSBmdW5jdGlvbiAoY2gsIGhlaWdodCwgb3B0aW9ucykge1xuICAvLyBDcmVhdGUgYSBzcGFuIHdpdGggaW5saW5lIFNWRyBmb3IgdGhlIGlubmVyIHBhcnQgb2YgYSB0YWxsIHN0YWNrZWQgZGVsaW1pdGVyLlxuICBjb25zdCB3aWR0aCA9IGZvbnRNZXRyaWNzRGF0YVtcIlNpemU0LVJlZ3VsYXJcIl1bY2guY2hhckNvZGVBdCgwKV0gPyBmb250TWV0cmljc0RhdGFbXCJTaXplNC1SZWd1bGFyXCJdW2NoLmNoYXJDb2RlQXQoMCldWzRdIDogZm9udE1ldHJpY3NEYXRhW1wiU2l6ZTEtUmVndWxhclwiXVtjaC5jaGFyQ29kZUF0KDApXVs0XTtcbiAgY29uc3QgcGF0aCA9IG5ldyBQYXRoTm9kZShcImlubmVyXCIsIGlubmVyUGF0aChjaCwgTWF0aC5yb3VuZCgxMDAwICogaGVpZ2h0KSkpO1xuICBjb25zdCBzdmdOb2RlID0gbmV3IFN2Z05vZGUoW3BhdGhdLCB7XG4gICAgXCJ3aWR0aFwiOiBtYWtlRW0od2lkdGgpLFxuICAgIFwiaGVpZ2h0XCI6IG1ha2VFbShoZWlnaHQpLFxuICAgIC8vIE92ZXJyaWRlIENTUyBydWxlIGAua2F0ZXggc3ZnIHsgd2lkdGg6IDEwMCUgfWBcbiAgICBcInN0eWxlXCI6IFwid2lkdGg6XCIgKyBtYWtlRW0od2lkdGgpLFxuICAgIFwidmlld0JveFwiOiBcIjAgMCBcIiArIDEwMDAgKiB3aWR0aCArIFwiIFwiICsgTWF0aC5yb3VuZCgxMDAwICogaGVpZ2h0KSxcbiAgICBcInByZXNlcnZlQXNwZWN0UmF0aW9cIjogXCJ4TWluWU1pblwiXG4gIH0pO1xuICBjb25zdCBzcGFuID0gYnVpbGRDb21tb24ubWFrZVN2Z1NwYW4oW10sIFtzdmdOb2RlXSwgb3B0aW9ucyk7XG4gIHNwYW4uaGVpZ2h0ID0gaGVpZ2h0O1xuICBzcGFuLnN0eWxlLmhlaWdodCA9IG1ha2VFbShoZWlnaHQpO1xuICBzcGFuLnN0eWxlLndpZHRoID0gbWFrZUVtKHdpZHRoKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImVsZW1cIixcbiAgICBlbGVtOiBzcGFuXG4gIH07XG59OyAvLyBIZWxwZXJzIGZvciBtYWtlU3RhY2tlZERlbGltXG5cblxuY29uc3QgbGFwSW5FbXMgPSAwLjAwODtcbmNvbnN0IGxhcCA9IHtcbiAgdHlwZTogXCJrZXJuXCIsXG4gIHNpemU6IC0xICogbGFwSW5FbXNcbn07XG5jb25zdCB2ZXJ0cyA9IFtcInxcIiwgXCJcXFxcbHZlcnRcIiwgXCJcXFxccnZlcnRcIiwgXCJcXFxcdmVydFwiXTtcbmNvbnN0IGRvdWJsZVZlcnRzID0gW1wiXFxcXHxcIiwgXCJcXFxcbFZlcnRcIiwgXCJcXFxcclZlcnRcIiwgXCJcXFxcVmVydFwiXTtcbi8qKlxuICogTWFrZSBhIHN0YWNrZWQgZGVsaW1pdGVyIG91dCBvZiBhIGdpdmVuIGRlbGltaXRlciwgd2l0aCB0aGUgdG90YWwgaGVpZ2h0IGF0XG4gKiBsZWFzdCBgaGVpZ2h0VG90YWxgLiBUaGlzIHJvdXRpbmUgaXMgbWVudGlvbmVkIG9uIHBhZ2UgNDQyIG9mIHRoZSBUZVhib29rLlxuICovXG5cbmNvbnN0IG1ha2VTdGFja2VkRGVsaW0gPSBmdW5jdGlvbiAoZGVsaW0sIGhlaWdodFRvdGFsLCBjZW50ZXIsIG9wdGlvbnMsIG1vZGUsIGNsYXNzZXMpIHtcbiAgLy8gVGhlcmUgYXJlIGZvdXIgcGFydHMsIHRoZSB0b3AsIGFuIG9wdGlvbmFsIG1pZGRsZSwgYSByZXBlYXRlZCBwYXJ0LCBhbmQgYVxuICAvLyBib3R0b20uXG4gIGxldCB0b3A7XG4gIGxldCBtaWRkbGU7XG4gIGxldCByZXBlYXQ7XG4gIGxldCBib3R0b207XG4gIGxldCBzdmdMYWJlbCA9IFwiXCI7XG4gIGxldCB2aWV3Qm94V2lkdGggPSAwO1xuICB0b3AgPSByZXBlYXQgPSBib3R0b20gPSBkZWxpbTtcbiAgbWlkZGxlID0gbnVsbDsgLy8gQWxzbyBrZWVwIHRyYWNrIG9mIHdoYXQgZm9udCB0aGUgZGVsaW1pdGVycyBhcmUgaW5cblxuICBsZXQgZm9udCA9IFwiU2l6ZTEtUmVndWxhclwiOyAvLyBXZSBzZXQgdGhlIHBhcnRzIGFuZCBmb250IGJhc2VkIG9uIHRoZSBzeW1ib2wuIE5vdGUgdGhhdCB3ZSB1c2VcbiAgLy8gJ1xcdTIzZDAnIGluc3RlYWQgb2YgJ3wnIGFuZCAnXFx1MjAxNicgaW5zdGVhZCBvZiAnXFxcXHwnIGZvciB0aGVcbiAgLy8gcmVwZWF0cyBvZiB0aGUgYXJyb3dzXG5cbiAgaWYgKGRlbGltID09PSBcIlxcXFx1cGFycm93XCIpIHtcbiAgICByZXBlYXQgPSBib3R0b20gPSBcIlxcdTIzZDBcIjtcbiAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCJcXFxcVXBhcnJvd1wiKSB7XG4gICAgcmVwZWF0ID0gYm90dG9tID0gXCJcXHUyMDE2XCI7XG4gIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXGRvd25hcnJvd1wiKSB7XG4gICAgdG9wID0gcmVwZWF0ID0gXCJcXHUyM2QwXCI7XG4gIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXERvd25hcnJvd1wiKSB7XG4gICAgdG9wID0gcmVwZWF0ID0gXCJcXHUyMDE2XCI7XG4gIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXHVwZG93bmFycm93XCIpIHtcbiAgICB0b3AgPSBcIlxcXFx1cGFycm93XCI7XG4gICAgcmVwZWF0ID0gXCJcXHUyM2QwXCI7XG4gICAgYm90dG9tID0gXCJcXFxcZG93bmFycm93XCI7XG4gIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXFVwZG93bmFycm93XCIpIHtcbiAgICB0b3AgPSBcIlxcXFxVcGFycm93XCI7XG4gICAgcmVwZWF0ID0gXCJcXHUyMDE2XCI7XG4gICAgYm90dG9tID0gXCJcXFxcRG93bmFycm93XCI7XG4gIH0gZWxzZSBpZiAodXRpbHMuY29udGFpbnModmVydHMsIGRlbGltKSkge1xuICAgIHJlcGVhdCA9IFwiXFx1MjIyM1wiO1xuICAgIHN2Z0xhYmVsID0gXCJ2ZXJ0XCI7XG4gICAgdmlld0JveFdpZHRoID0gMzMzO1xuICB9IGVsc2UgaWYgKHV0aWxzLmNvbnRhaW5zKGRvdWJsZVZlcnRzLCBkZWxpbSkpIHtcbiAgICByZXBlYXQgPSBcIlxcdTIyMjVcIjtcbiAgICBzdmdMYWJlbCA9IFwiZG91YmxldmVydFwiO1xuICAgIHZpZXdCb3hXaWR0aCA9IDU1NjtcbiAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCJbXCIgfHwgZGVsaW0gPT09IFwiXFxcXGxicmFja1wiKSB7XG4gICAgdG9wID0gXCJcXHUyM2ExXCI7XG4gICAgcmVwZWF0ID0gXCJcXHUyM2EyXCI7XG4gICAgYm90dG9tID0gXCJcXHUyM2EzXCI7XG4gICAgZm9udCA9IFwiU2l6ZTQtUmVndWxhclwiO1xuICAgIHN2Z0xhYmVsID0gXCJsYnJhY2tcIjtcbiAgICB2aWV3Qm94V2lkdGggPSA2Njc7XG4gIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXVwiIHx8IGRlbGltID09PSBcIlxcXFxyYnJhY2tcIikge1xuICAgIHRvcCA9IFwiXFx1MjNhNFwiO1xuICAgIHJlcGVhdCA9IFwiXFx1MjNhNVwiO1xuICAgIGJvdHRvbSA9IFwiXFx1MjNhNlwiO1xuICAgIGZvbnQgPSBcIlNpemU0LVJlZ3VsYXJcIjtcbiAgICBzdmdMYWJlbCA9IFwicmJyYWNrXCI7XG4gICAgdmlld0JveFdpZHRoID0gNjY3O1xuICB9IGVsc2UgaWYgKGRlbGltID09PSBcIlxcXFxsZmxvb3JcIiB8fCBkZWxpbSA9PT0gXCJcXHUyMzBhXCIpIHtcbiAgICByZXBlYXQgPSB0b3AgPSBcIlxcdTIzYTJcIjtcbiAgICBib3R0b20gPSBcIlxcdTIzYTNcIjtcbiAgICBmb250ID0gXCJTaXplNC1SZWd1bGFyXCI7XG4gICAgc3ZnTGFiZWwgPSBcImxmbG9vclwiO1xuICAgIHZpZXdCb3hXaWR0aCA9IDY2NztcbiAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCJcXFxcbGNlaWxcIiB8fCBkZWxpbSA9PT0gXCJcXHUyMzA4XCIpIHtcbiAgICB0b3AgPSBcIlxcdTIzYTFcIjtcbiAgICByZXBlYXQgPSBib3R0b20gPSBcIlxcdTIzYTJcIjtcbiAgICBmb250ID0gXCJTaXplNC1SZWd1bGFyXCI7XG4gICAgc3ZnTGFiZWwgPSBcImxjZWlsXCI7XG4gICAgdmlld0JveFdpZHRoID0gNjY3O1xuICB9IGVsc2UgaWYgKGRlbGltID09PSBcIlxcXFxyZmxvb3JcIiB8fCBkZWxpbSA9PT0gXCJcXHUyMzBiXCIpIHtcbiAgICByZXBlYXQgPSB0b3AgPSBcIlxcdTIzYTVcIjtcbiAgICBib3R0b20gPSBcIlxcdTIzYTZcIjtcbiAgICBmb250ID0gXCJTaXplNC1SZWd1bGFyXCI7XG4gICAgc3ZnTGFiZWwgPSBcInJmbG9vclwiO1xuICAgIHZpZXdCb3hXaWR0aCA9IDY2NztcbiAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCJcXFxccmNlaWxcIiB8fCBkZWxpbSA9PT0gXCJcXHUyMzA5XCIpIHtcbiAgICB0b3AgPSBcIlxcdTIzYTRcIjtcbiAgICByZXBlYXQgPSBib3R0b20gPSBcIlxcdTIzYTVcIjtcbiAgICBmb250ID0gXCJTaXplNC1SZWd1bGFyXCI7XG4gICAgc3ZnTGFiZWwgPSBcInJjZWlsXCI7XG4gICAgdmlld0JveFdpZHRoID0gNjY3O1xuICB9IGVsc2UgaWYgKGRlbGltID09PSBcIihcIiB8fCBkZWxpbSA9PT0gXCJcXFxcbHBhcmVuXCIpIHtcbiAgICB0b3AgPSBcIlxcdTIzOWJcIjtcbiAgICByZXBlYXQgPSBcIlxcdTIzOWNcIjtcbiAgICBib3R0b20gPSBcIlxcdTIzOWRcIjtcbiAgICBmb250ID0gXCJTaXplNC1SZWd1bGFyXCI7XG4gICAgc3ZnTGFiZWwgPSBcImxwYXJlblwiO1xuICAgIHZpZXdCb3hXaWR0aCA9IDg3NTtcbiAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCIpXCIgfHwgZGVsaW0gPT09IFwiXFxcXHJwYXJlblwiKSB7XG4gICAgdG9wID0gXCJcXHUyMzllXCI7XG4gICAgcmVwZWF0ID0gXCJcXHUyMzlmXCI7XG4gICAgYm90dG9tID0gXCJcXHUyM2EwXCI7XG4gICAgZm9udCA9IFwiU2l6ZTQtUmVndWxhclwiO1xuICAgIHN2Z0xhYmVsID0gXCJycGFyZW5cIjtcbiAgICB2aWV3Qm94V2lkdGggPSA4NzU7XG4gIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXHtcIiB8fCBkZWxpbSA9PT0gXCJcXFxcbGJyYWNlXCIpIHtcbiAgICB0b3AgPSBcIlxcdTIzYTdcIjtcbiAgICBtaWRkbGUgPSBcIlxcdTIzYThcIjtcbiAgICBib3R0b20gPSBcIlxcdTIzYTlcIjtcbiAgICByZXBlYXQgPSBcIlxcdTIzYWFcIjtcbiAgICBmb250ID0gXCJTaXplNC1SZWd1bGFyXCI7XG4gIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXH1cIiB8fCBkZWxpbSA9PT0gXCJcXFxccmJyYWNlXCIpIHtcbiAgICB0b3AgPSBcIlxcdTIzYWJcIjtcbiAgICBtaWRkbGUgPSBcIlxcdTIzYWNcIjtcbiAgICBib3R0b20gPSBcIlxcdTIzYWRcIjtcbiAgICByZXBlYXQgPSBcIlxcdTIzYWFcIjtcbiAgICBmb250ID0gXCJTaXplNC1SZWd1bGFyXCI7XG4gIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXGxncm91cFwiIHx8IGRlbGltID09PSBcIlxcdTI3ZWVcIikge1xuICAgIHRvcCA9IFwiXFx1MjNhN1wiO1xuICAgIGJvdHRvbSA9IFwiXFx1MjNhOVwiO1xuICAgIHJlcGVhdCA9IFwiXFx1MjNhYVwiO1xuICAgIGZvbnQgPSBcIlNpemU0LVJlZ3VsYXJcIjtcbiAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCJcXFxccmdyb3VwXCIgfHwgZGVsaW0gPT09IFwiXFx1MjdlZlwiKSB7XG4gICAgdG9wID0gXCJcXHUyM2FiXCI7XG4gICAgYm90dG9tID0gXCJcXHUyM2FkXCI7XG4gICAgcmVwZWF0ID0gXCJcXHUyM2FhXCI7XG4gICAgZm9udCA9IFwiU2l6ZTQtUmVndWxhclwiO1xuICB9IGVsc2UgaWYgKGRlbGltID09PSBcIlxcXFxsbW91c3RhY2hlXCIgfHwgZGVsaW0gPT09IFwiXFx1MjNiMFwiKSB7XG4gICAgdG9wID0gXCJcXHUyM2E3XCI7XG4gICAgYm90dG9tID0gXCJcXHUyM2FkXCI7XG4gICAgcmVwZWF0ID0gXCJcXHUyM2FhXCI7XG4gICAgZm9udCA9IFwiU2l6ZTQtUmVndWxhclwiO1xuICB9IGVsc2UgaWYgKGRlbGltID09PSBcIlxcXFxybW91c3RhY2hlXCIgfHwgZGVsaW0gPT09IFwiXFx1MjNiMVwiKSB7XG4gICAgdG9wID0gXCJcXHUyM2FiXCI7XG4gICAgYm90dG9tID0gXCJcXHUyM2E5XCI7XG4gICAgcmVwZWF0ID0gXCJcXHUyM2FhXCI7XG4gICAgZm9udCA9IFwiU2l6ZTQtUmVndWxhclwiO1xuICB9IC8vIEdldCB0aGUgbWV0cmljcyBvZiB0aGUgZm91ciBzZWN0aW9uc1xuXG5cbiAgY29uc3QgdG9wTWV0cmljcyA9IGdldE1ldHJpY3ModG9wLCBmb250LCBtb2RlKTtcbiAgY29uc3QgdG9wSGVpZ2h0VG90YWwgPSB0b3BNZXRyaWNzLmhlaWdodCArIHRvcE1ldHJpY3MuZGVwdGg7XG4gIGNvbnN0IHJlcGVhdE1ldHJpY3MgPSBnZXRNZXRyaWNzKHJlcGVhdCwgZm9udCwgbW9kZSk7XG4gIGNvbnN0IHJlcGVhdEhlaWdodFRvdGFsID0gcmVwZWF0TWV0cmljcy5oZWlnaHQgKyByZXBlYXRNZXRyaWNzLmRlcHRoO1xuICBjb25zdCBib3R0b21NZXRyaWNzID0gZ2V0TWV0cmljcyhib3R0b20sIGZvbnQsIG1vZGUpO1xuICBjb25zdCBib3R0b21IZWlnaHRUb3RhbCA9IGJvdHRvbU1ldHJpY3MuaGVpZ2h0ICsgYm90dG9tTWV0cmljcy5kZXB0aDtcbiAgbGV0IG1pZGRsZUhlaWdodFRvdGFsID0gMDtcbiAgbGV0IG1pZGRsZUZhY3RvciA9IDE7XG5cbiAgaWYgKG1pZGRsZSAhPT0gbnVsbCkge1xuICAgIGNvbnN0IG1pZGRsZU1ldHJpY3MgPSBnZXRNZXRyaWNzKG1pZGRsZSwgZm9udCwgbW9kZSk7XG4gICAgbWlkZGxlSGVpZ2h0VG90YWwgPSBtaWRkbGVNZXRyaWNzLmhlaWdodCArIG1pZGRsZU1ldHJpY3MuZGVwdGg7XG4gICAgbWlkZGxlRmFjdG9yID0gMjsgLy8gcmVwZWF0IHN5bW1ldHJpY2FsbHkgYWJvdmUgYW5kIGJlbG93IG1pZGRsZVxuICB9IC8vIENhbGN1bGF0ZSB0aGUgbWluaW1hbCBoZWlnaHQgdGhhdCB0aGUgZGVsaW1pdGVyIGNhbiBoYXZlLlxuICAvLyBJdCBpcyBhdCBsZWFzdCB0aGUgc2l6ZSBvZiB0aGUgdG9wLCBib3R0b20sIGFuZCBvcHRpb25hbCBtaWRkbGUgY29tYmluZWQuXG5cblxuICBjb25zdCBtaW5IZWlnaHQgPSB0b3BIZWlnaHRUb3RhbCArIGJvdHRvbUhlaWdodFRvdGFsICsgbWlkZGxlSGVpZ2h0VG90YWw7IC8vIENvbXB1dGUgdGhlIG51bWJlciBvZiBjb3BpZXMgb2YgdGhlIHJlcGVhdCBzeW1ib2wgd2Ugd2lsbCBuZWVkXG5cbiAgY29uc3QgcmVwZWF0Q291bnQgPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwoKGhlaWdodFRvdGFsIC0gbWluSGVpZ2h0KSAvIChtaWRkbGVGYWN0b3IgKiByZXBlYXRIZWlnaHRUb3RhbCkpKTsgLy8gQ29tcHV0ZSB0aGUgdG90YWwgaGVpZ2h0IG9mIHRoZSBkZWxpbWl0ZXIgaW5jbHVkaW5nIGFsbCB0aGUgc3ltYm9sc1xuXG4gIGNvbnN0IHJlYWxIZWlnaHRUb3RhbCA9IG1pbkhlaWdodCArIHJlcGVhdENvdW50ICogbWlkZGxlRmFjdG9yICogcmVwZWF0SGVpZ2h0VG90YWw7IC8vIFRoZSBjZW50ZXIgb2YgdGhlIGRlbGltaXRlciBpcyBwbGFjZWQgYXQgdGhlIGNlbnRlciBvZiB0aGUgYXhpcy4gTm90ZVxuICAvLyB0aGF0IGluIHRoaXMgY29udGV4dCwgXCJjZW50ZXJcIiBtZWFucyB0aGF0IHRoZSBkZWxpbWl0ZXIgc2hvdWxkIGJlXG4gIC8vIGNlbnRlcmVkIGFyb3VuZCB0aGUgYXhpcyBpbiB0aGUgY3VycmVudCBzdHlsZSwgd2hpbGUgbm9ybWFsbHkgaXQgaXNcbiAgLy8gY2VudGVyZWQgYXJvdW5kIHRoZSBheGlzIGluIHRleHRzdHlsZS5cblxuICBsZXQgYXhpc0hlaWdodCA9IG9wdGlvbnMuZm9udE1ldHJpY3MoKS5heGlzSGVpZ2h0O1xuXG4gIGlmIChjZW50ZXIpIHtcbiAgICBheGlzSGVpZ2h0ICo9IG9wdGlvbnMuc2l6ZU11bHRpcGxpZXI7XG4gIH0gLy8gQ2FsY3VsYXRlIHRoZSBkZXB0aFxuXG5cbiAgY29uc3QgZGVwdGggPSByZWFsSGVpZ2h0VG90YWwgLyAyIC0gYXhpc0hlaWdodDsgLy8gTm93LCB3ZSBzdGFydCBidWlsZGluZyB0aGUgcGllY2VzIHRoYXQgd2lsbCBnbyBpbnRvIHRoZSB2bGlzdFxuICAvLyBLZWVwIGEgbGlzdCBvZiB0aGUgcGllY2VzIG9mIHRoZSBzdGFja2VkIGRlbGltaXRlclxuXG4gIGNvbnN0IHN0YWNrID0gW107XG5cbiAgaWYgKHN2Z0xhYmVsLmxlbmd0aCA+IDApIHtcbiAgICAvLyBJbnN0ZWFkIG9mIHN0YWNraW5nIGdseXBocywgY3JlYXRlIGEgc2luZ2xlIFNWRy5cbiAgICAvLyBUaGlzIGV2YWRlcyBicm93c2VyIHByb2JsZW1zIHdpdGggaW1wcmVjaXNlIHBvc2l0aW9uaW5nIG9mIHNwYW5zLlxuICAgIGNvbnN0IG1pZEhlaWdodCA9IHJlYWxIZWlnaHRUb3RhbCAtIHRvcEhlaWdodFRvdGFsIC0gYm90dG9tSGVpZ2h0VG90YWw7XG4gICAgY29uc3Qgdmlld0JveEhlaWdodCA9IE1hdGgucm91bmQocmVhbEhlaWdodFRvdGFsICogMTAwMCk7XG4gICAgY29uc3QgcGF0aFN0ciA9IHRhbGxEZWxpbShzdmdMYWJlbCwgTWF0aC5yb3VuZChtaWRIZWlnaHQgKiAxMDAwKSk7XG4gICAgY29uc3QgcGF0aCA9IG5ldyBQYXRoTm9kZShzdmdMYWJlbCwgcGF0aFN0cik7XG4gICAgY29uc3Qgd2lkdGggPSAodmlld0JveFdpZHRoIC8gMTAwMCkudG9GaXhlZCgzKSArIFwiZW1cIjtcbiAgICBjb25zdCBoZWlnaHQgPSAodmlld0JveEhlaWdodCAvIDEwMDApLnRvRml4ZWQoMykgKyBcImVtXCI7XG4gICAgY29uc3Qgc3ZnID0gbmV3IFN2Z05vZGUoW3BhdGhdLCB7XG4gICAgICBcIndpZHRoXCI6IHdpZHRoLFxuICAgICAgXCJoZWlnaHRcIjogaGVpZ2h0LFxuICAgICAgXCJ2aWV3Qm94XCI6IFwiMCAwIFwiICsgdmlld0JveFdpZHRoICsgXCIgXCIgKyB2aWV3Qm94SGVpZ2h0XG4gICAgfSk7XG4gICAgY29uc3Qgd3JhcHBlciA9IGJ1aWxkQ29tbW9uLm1ha2VTdmdTcGFuKFtdLCBbc3ZnXSwgb3B0aW9ucyk7XG4gICAgd3JhcHBlci5oZWlnaHQgPSB2aWV3Qm94SGVpZ2h0IC8gMTAwMDtcbiAgICB3cmFwcGVyLnN0eWxlLndpZHRoID0gd2lkdGg7XG4gICAgd3JhcHBlci5zdHlsZS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgc3RhY2sucHVzaCh7XG4gICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgIGVsZW06IHdyYXBwZXJcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBTdGFjayBnbHlwaHNcbiAgICAvLyBTdGFydCBieSBhZGRpbmcgdGhlIGJvdHRvbSBzeW1ib2xcbiAgICBzdGFjay5wdXNoKG1ha2VHbHlwaFNwYW4oYm90dG9tLCBmb250LCBtb2RlKSk7XG4gICAgc3RhY2sucHVzaChsYXApOyAvLyBvdmVybGFwXG5cbiAgICBpZiAobWlkZGxlID09PSBudWxsKSB7XG4gICAgICAvLyBUaGUgbWlkZGxlIHNlY3Rpb24gd2lsbCBiZSBhbiBTVkcuIE1ha2UgaXQgYW4gZXh0cmEgMC4wMTZlbSB0YWxsLlxuICAgICAgLy8gV2UnbGwgb3ZlcmxhcCBieSAwLjAwOGVtIGF0IHRvcCBhbmQgYm90dG9tLlxuICAgICAgY29uc3QgaW5uZXJIZWlnaHQgPSByZWFsSGVpZ2h0VG90YWwgLSB0b3BIZWlnaHRUb3RhbCAtIGJvdHRvbUhlaWdodFRvdGFsICsgMiAqIGxhcEluRW1zO1xuICAgICAgc3RhY2sucHVzaChtYWtlSW5uZXIocmVwZWF0LCBpbm5lckhlaWdodCwgb3B0aW9ucykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXaGVuIHRoZXJlIGlzIGEgbWlkZGxlIGJpdCwgd2UgbmVlZCB0aGUgbWlkZGxlIHBhcnQgYW5kIHR3byByZXBlYXRlZFxuICAgICAgLy8gc2VjdGlvbnNcbiAgICAgIGNvbnN0IGlubmVySGVpZ2h0ID0gKHJlYWxIZWlnaHRUb3RhbCAtIHRvcEhlaWdodFRvdGFsIC0gYm90dG9tSGVpZ2h0VG90YWwgLSBtaWRkbGVIZWlnaHRUb3RhbCkgLyAyICsgMiAqIGxhcEluRW1zO1xuICAgICAgc3RhY2sucHVzaChtYWtlSW5uZXIocmVwZWF0LCBpbm5lckhlaWdodCwgb3B0aW9ucykpOyAvLyBOb3cgaW5zZXJ0IHRoZSBtaWRkbGUgb2YgdGhlIGJyYWNlLlxuXG4gICAgICBzdGFjay5wdXNoKGxhcCk7XG4gICAgICBzdGFjay5wdXNoKG1ha2VHbHlwaFNwYW4obWlkZGxlLCBmb250LCBtb2RlKSk7XG4gICAgICBzdGFjay5wdXNoKGxhcCk7XG4gICAgICBzdGFjay5wdXNoKG1ha2VJbm5lcihyZXBlYXQsIGlubmVySGVpZ2h0LCBvcHRpb25zKSk7XG4gICAgfSAvLyBBZGQgdGhlIHRvcCBzeW1ib2xcblxuXG4gICAgc3RhY2sucHVzaChsYXApO1xuICAgIHN0YWNrLnB1c2gobWFrZUdseXBoU3Bhbih0b3AsIGZvbnQsIG1vZGUpKTtcbiAgfSAvLyBGaW5hbGx5LCBidWlsZCB0aGUgdmxpc3RcblxuXG4gIGNvbnN0IG5ld09wdGlvbnMgPSBvcHRpb25zLmhhdmluZ0Jhc2VTdHlsZShzcmNfU3R5bGUuVEVYVCk7XG4gIGNvbnN0IGlubmVyID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHtcbiAgICBwb3NpdGlvblR5cGU6IFwiYm90dG9tXCIsXG4gICAgcG9zaXRpb25EYXRhOiBkZXB0aCxcbiAgICBjaGlsZHJlbjogc3RhY2tcbiAgfSwgbmV3T3B0aW9ucyk7XG4gIHJldHVybiBzdHlsZVdyYXAoYnVpbGRDb21tb24ubWFrZVNwYW4oW1wiZGVsaW1zaXppbmdcIiwgXCJtdWx0XCJdLCBbaW5uZXJdLCBuZXdPcHRpb25zKSwgc3JjX1N0eWxlLlRFWFQsIG9wdGlvbnMsIGNsYXNzZXMpO1xufTsgLy8gQWxsIHN1cmRzIGhhdmUgMC4wOGVtIHBhZGRpbmcgYWJvdmUgdGhlIHZpbmN1bHVtIGluc2lkZSB0aGUgU1ZHLlxuLy8gVGhhdCBrZWVwcyBicm93c2VyIHNwYW4gaGVpZ2h0IHJvdW5kaW5nIGVycm9yIGZyb20gcGluY2hpbmcgdGhlIGxpbmUuXG5cblxuY29uc3QgdmJQYWQgPSA4MDsgLy8gcGFkZGluZyBhYm92ZSB0aGUgc3VyZCwgbWVhc3VyZWQgaW5zaWRlIHRoZSB2aWV3Qm94LlxuXG5jb25zdCBlbVBhZCA9IDAuMDg7IC8vIHBhZGRpbmcsIGluIGVtcywgbWVhc3VyZWQgaW4gdGhlIGRvY3VtZW50LlxuXG5jb25zdCBzcXJ0U3ZnID0gZnVuY3Rpb24gKHNxcnROYW1lLCBoZWlnaHQsIHZpZXdCb3hIZWlnaHQsIGV4dHJhVmluY3VsdW0sIG9wdGlvbnMpIHtcbiAgY29uc3QgcGF0aCA9IHNxcnRQYXRoKHNxcnROYW1lLCBleHRyYVZpbmN1bHVtLCB2aWV3Qm94SGVpZ2h0KTtcbiAgY29uc3QgcGF0aE5vZGUgPSBuZXcgUGF0aE5vZGUoc3FydE5hbWUsIHBhdGgpO1xuICBjb25zdCBzdmcgPSBuZXcgU3ZnTm9kZShbcGF0aE5vZGVdLCB7XG4gICAgLy8gTm90ZTogMTAwMDoxIHJhdGlvIG9mIHZpZXdCb3ggdG8gZG9jdW1lbnQgZW0gd2lkdGguXG4gICAgXCJ3aWR0aFwiOiBcIjQwMGVtXCIsXG4gICAgXCJoZWlnaHRcIjogbWFrZUVtKGhlaWdodCksXG4gICAgXCJ2aWV3Qm94XCI6IFwiMCAwIDQwMDAwMCBcIiArIHZpZXdCb3hIZWlnaHQsXG4gICAgXCJwcmVzZXJ2ZUFzcGVjdFJhdGlvXCI6IFwieE1pbllNaW4gc2xpY2VcIlxuICB9KTtcbiAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTdmdTcGFuKFtcImhpZGUtdGFpbFwiXSwgW3N2Z10sIG9wdGlvbnMpO1xufTtcbi8qKlxuICogTWFrZSBhIHNxcnQgaW1hZ2Ugb2YgdGhlIGdpdmVuIGhlaWdodCxcbiAqL1xuXG5cbmNvbnN0IG1ha2VTcXJ0SW1hZ2UgPSBmdW5jdGlvbiAoaGVpZ2h0LCBvcHRpb25zKSB7XG4gIC8vIERlZmluZSBhIG5ld09wdGlvbnMgdGhhdCByZW1vdmVzIHRoZSBlZmZlY3Qgb2Ygc2l6ZSBjaGFuZ2VzIHN1Y2ggYXMgXFxIdWdlLlxuICAvLyBXZSBkb24ndCBwaWNrIGRpZmZlcmVudCBhIGhlaWdodCBzdXJkIGZvciBcXEh1Z2UuIEZvciBpdCwgd2Ugc2NhbGUgdXAuXG4gIGNvbnN0IG5ld09wdGlvbnMgPSBvcHRpb25zLmhhdmluZ0Jhc2VTaXppbmcoKTsgLy8gUGljayB0aGUgZGVzaXJlZCBzdXJkIGdseXBoIGZyb20gYSBzZXF1ZW5jZSBvZiBzdXJkcy5cblxuICBjb25zdCBkZWxpbSA9IHRyYXZlcnNlU2VxdWVuY2UoXCJcXFxcc3VyZFwiLCBoZWlnaHQgKiBuZXdPcHRpb25zLnNpemVNdWx0aXBsaWVyLCBzdGFja0xhcmdlRGVsaW1pdGVyU2VxdWVuY2UsIG5ld09wdGlvbnMpO1xuICBsZXQgc2l6ZU11bHRpcGxpZXIgPSBuZXdPcHRpb25zLnNpemVNdWx0aXBsaWVyOyAvLyBkZWZhdWx0XG4gIC8vIFRoZSBzdGFuZGFyZCBzcXJ0IFNWR3MgZWFjaCBoYXZlIGEgMC4wNGVtIHRoaWNrIHZpbmN1bHVtLlxuICAvLyBJZiBTZXR0aW5ncy5taW5SdWxlVGhpY2tuZXNzIGlzIGxhcmdlciB0aGFuIHRoYXQsIHdlIGFkZCBleHRyYVZpbmN1bHVtLlxuXG4gIGNvbnN0IGV4dHJhVmluY3VsdW0gPSBNYXRoLm1heCgwLCBvcHRpb25zLm1pblJ1bGVUaGlja25lc3MgLSBvcHRpb25zLmZvbnRNZXRyaWNzKCkuc3FydFJ1bGVUaGlja25lc3MpOyAvLyBDcmVhdGUgYSBzcGFuIGNvbnRhaW5pbmcgYW4gU1ZHIGltYWdlIG9mIGEgc3FydCBzeW1ib2wuXG5cbiAgbGV0IHNwYW47XG4gIGxldCBzcGFuSGVpZ2h0ID0gMDtcbiAgbGV0IHRleEhlaWdodCA9IDA7XG4gIGxldCB2aWV3Qm94SGVpZ2h0ID0gMDtcbiAgbGV0IGFkdmFuY2VXaWR0aDsgLy8gV2UgY3JlYXRlIHZpZXdCb3hlcyB3aXRoIDgwIHVuaXRzIG9mIFwicGFkZGluZ1wiIGFib3ZlIGVhY2ggc3VyZC5cbiAgLy8gVGhlbiBicm93c2VyIHJvdW5kaW5nIGVycm9yIG9uIHRoZSBwYXJlbnQgc3BhbiBoZWlnaHQgd2lsbCBub3RcbiAgLy8gZW5jcm9hY2ggb24gdGhlIGluayBvZiB0aGUgdmluY3VsdW0uIEJ1dCB0aGF0IHBhZGRpbmcgaXMgbm90XG4gIC8vIGluY2x1ZGVkIGluIHRoZSBUZVgtbGlrZSBgaGVpZ2h0YCB1c2VkIGZvciBjYWxjdWxhdGlvbiBvZlxuICAvLyB2ZXJ0aWNhbCBhbGlnbm1lbnQuIFNvIHRleEhlaWdodCA9IHNwYW4uaGVpZ2h0IDwgc3Bhbi5zdHlsZS5oZWlnaHQuXG5cbiAgaWYgKGRlbGltLnR5cGUgPT09IFwic21hbGxcIikge1xuICAgIC8vIEdldCBhbiBTVkcgdGhhdCBpcyBkZXJpdmVkIGZyb20gZ2x5cGggVSsyMjFBIGluIGZvbnQgS2FUZVgtTWFpbi5cbiAgICAvLyAxMDAwIHVuaXQgbm9ybWFsIGdseXBoIGhlaWdodC5cbiAgICB2aWV3Qm94SGVpZ2h0ID0gMTAwMCArIDEwMDAgKiBleHRyYVZpbmN1bHVtICsgdmJQYWQ7XG5cbiAgICBpZiAoaGVpZ2h0IDwgMS4wKSB7XG4gICAgICBzaXplTXVsdGlwbGllciA9IDEuMDsgLy8gbWltaWMgYSBcXHRleHRmb250IHJhZGljYWxcbiAgICB9IGVsc2UgaWYgKGhlaWdodCA8IDEuNCkge1xuICAgICAgc2l6ZU11bHRpcGxpZXIgPSAwLjc7IC8vIG1pbWljIGEgXFxzY3JpcHRmb250IHJhZGljYWxcbiAgICB9XG5cbiAgICBzcGFuSGVpZ2h0ID0gKDEuMCArIGV4dHJhVmluY3VsdW0gKyBlbVBhZCkgLyBzaXplTXVsdGlwbGllcjtcbiAgICB0ZXhIZWlnaHQgPSAoMS4wMCArIGV4dHJhVmluY3VsdW0pIC8gc2l6ZU11bHRpcGxpZXI7XG4gICAgc3BhbiA9IHNxcnRTdmcoXCJzcXJ0TWFpblwiLCBzcGFuSGVpZ2h0LCB2aWV3Qm94SGVpZ2h0LCBleHRyYVZpbmN1bHVtLCBvcHRpb25zKTtcbiAgICBzcGFuLnN0eWxlLm1pbldpZHRoID0gXCIwLjg1M2VtXCI7XG4gICAgYWR2YW5jZVdpZHRoID0gMC44MzMgLyBzaXplTXVsdGlwbGllcjsgLy8gZnJvbSB0aGUgZm9udC5cbiAgfSBlbHNlIGlmIChkZWxpbS50eXBlID09PSBcImxhcmdlXCIpIHtcbiAgICAvLyBUaGVzZSBTVkdzIGNvbWUgZnJvbSBmb250czogS2FUZVhfU2l6ZTEsIF9TaXplMiwgZXRjLlxuICAgIHZpZXdCb3hIZWlnaHQgPSAoMTAwMCArIHZiUGFkKSAqIHNpemVUb01heEhlaWdodFtkZWxpbS5zaXplXTtcbiAgICB0ZXhIZWlnaHQgPSAoc2l6ZVRvTWF4SGVpZ2h0W2RlbGltLnNpemVdICsgZXh0cmFWaW5jdWx1bSkgLyBzaXplTXVsdGlwbGllcjtcbiAgICBzcGFuSGVpZ2h0ID0gKHNpemVUb01heEhlaWdodFtkZWxpbS5zaXplXSArIGV4dHJhVmluY3VsdW0gKyBlbVBhZCkgLyBzaXplTXVsdGlwbGllcjtcbiAgICBzcGFuID0gc3FydFN2ZyhcInNxcnRTaXplXCIgKyBkZWxpbS5zaXplLCBzcGFuSGVpZ2h0LCB2aWV3Qm94SGVpZ2h0LCBleHRyYVZpbmN1bHVtLCBvcHRpb25zKTtcbiAgICBzcGFuLnN0eWxlLm1pbldpZHRoID0gXCIxLjAyZW1cIjtcbiAgICBhZHZhbmNlV2lkdGggPSAxLjAgLyBzaXplTXVsdGlwbGllcjsgLy8gMS4wIGZyb20gdGhlIGZvbnQuXG4gIH0gZWxzZSB7XG4gICAgLy8gVGFsbCBzcXJ0LiBJbiBUZVgsIHRoaXMgd291bGQgYmUgc3RhY2tlZCB1c2luZyBtdWx0aXBsZSBnbHlwaHMuXG4gICAgLy8gV2UnbGwgdXNlIGEgc2luZ2xlIFNWRyB0byBhY2NvbXBsaXNoIHRoZSBzYW1lIHRoaW5nLlxuICAgIHNwYW5IZWlnaHQgPSBoZWlnaHQgKyBleHRyYVZpbmN1bHVtICsgZW1QYWQ7XG4gICAgdGV4SGVpZ2h0ID0gaGVpZ2h0ICsgZXh0cmFWaW5jdWx1bTtcbiAgICB2aWV3Qm94SGVpZ2h0ID0gTWF0aC5mbG9vcigxMDAwICogaGVpZ2h0ICsgZXh0cmFWaW5jdWx1bSkgKyB2YlBhZDtcbiAgICBzcGFuID0gc3FydFN2ZyhcInNxcnRUYWxsXCIsIHNwYW5IZWlnaHQsIHZpZXdCb3hIZWlnaHQsIGV4dHJhVmluY3VsdW0sIG9wdGlvbnMpO1xuICAgIHNwYW4uc3R5bGUubWluV2lkdGggPSBcIjAuNzQyZW1cIjtcbiAgICBhZHZhbmNlV2lkdGggPSAxLjA1NjtcbiAgfVxuXG4gIHNwYW4uaGVpZ2h0ID0gdGV4SGVpZ2h0O1xuICBzcGFuLnN0eWxlLmhlaWdodCA9IG1ha2VFbShzcGFuSGVpZ2h0KTtcbiAgcmV0dXJuIHtcbiAgICBzcGFuLFxuICAgIGFkdmFuY2VXaWR0aCxcbiAgICAvLyBDYWxjdWxhdGUgdGhlIGFjdHVhbCBsaW5lIHdpZHRoLlxuICAgIC8vIFRoaXMgYWN0dWFsbHkgc2hvdWxkIGRlcGVuZCBvbiB0aGUgY2hvc2VuIGZvbnQgLS0gZS5nLiBcXGJvbGRtYXRoXG4gICAgLy8gc2hvdWxkIHVzZSB0aGUgdGhpY2tlciBzdXJkIHN5bWJvbHMgZnJvbSBlLmcuIEthVGVYX01haW4tQm9sZCwgYW5kXG4gICAgLy8gaGF2ZSB0aGlja2VyIHJ1bGVzLlxuICAgIHJ1bGVXaWR0aDogKG9wdGlvbnMuZm9udE1ldHJpY3MoKS5zcXJ0UnVsZVRoaWNrbmVzcyArIGV4dHJhVmluY3VsdW0pICogc2l6ZU11bHRpcGxpZXJcbiAgfTtcbn07IC8vIFRoZXJlIGFyZSB0aHJlZSBraW5kcyBvZiBkZWxpbWl0ZXJzLCBkZWxpbWl0ZXJzIHRoYXQgc3RhY2sgd2hlbiB0aGV5IGJlY29tZVxuLy8gdG9vIGxhcmdlXG5cblxuY29uc3Qgc3RhY2tMYXJnZURlbGltaXRlcnMgPSBbXCIoXCIsIFwiXFxcXGxwYXJlblwiLCBcIilcIiwgXCJcXFxccnBhcmVuXCIsIFwiW1wiLCBcIlxcXFxsYnJhY2tcIiwgXCJdXCIsIFwiXFxcXHJicmFja1wiLCBcIlxcXFx7XCIsIFwiXFxcXGxicmFjZVwiLCBcIlxcXFx9XCIsIFwiXFxcXHJicmFjZVwiLCBcIlxcXFxsZmxvb3JcIiwgXCJcXFxccmZsb29yXCIsIFwiXFx1MjMwYVwiLCBcIlxcdTIzMGJcIiwgXCJcXFxcbGNlaWxcIiwgXCJcXFxccmNlaWxcIiwgXCJcXHUyMzA4XCIsIFwiXFx1MjMwOVwiLCBcIlxcXFxzdXJkXCJdOyAvLyBkZWxpbWl0ZXJzIHRoYXQgYWx3YXlzIHN0YWNrXG5cbmNvbnN0IHN0YWNrQWx3YXlzRGVsaW1pdGVycyA9IFtcIlxcXFx1cGFycm93XCIsIFwiXFxcXGRvd25hcnJvd1wiLCBcIlxcXFx1cGRvd25hcnJvd1wiLCBcIlxcXFxVcGFycm93XCIsIFwiXFxcXERvd25hcnJvd1wiLCBcIlxcXFxVcGRvd25hcnJvd1wiLCBcInxcIiwgXCJcXFxcfFwiLCBcIlxcXFx2ZXJ0XCIsIFwiXFxcXFZlcnRcIiwgXCJcXFxcbHZlcnRcIiwgXCJcXFxccnZlcnRcIiwgXCJcXFxcbFZlcnRcIiwgXCJcXFxcclZlcnRcIiwgXCJcXFxcbGdyb3VwXCIsIFwiXFxcXHJncm91cFwiLCBcIlxcdTI3ZWVcIiwgXCJcXHUyN2VmXCIsIFwiXFxcXGxtb3VzdGFjaGVcIiwgXCJcXFxccm1vdXN0YWNoZVwiLCBcIlxcdTIzYjBcIiwgXCJcXHUyM2IxXCJdOyAvLyBhbmQgZGVsaW1pdGVycyB0aGF0IG5ldmVyIHN0YWNrXG5cbmNvbnN0IHN0YWNrTmV2ZXJEZWxpbWl0ZXJzID0gW1wiPFwiLCBcIj5cIiwgXCJcXFxcbGFuZ2xlXCIsIFwiXFxcXHJhbmdsZVwiLCBcIi9cIiwgXCJcXFxcYmFja3NsYXNoXCIsIFwiXFxcXGx0XCIsIFwiXFxcXGd0XCJdOyAvLyBNZXRyaWNzIG9mIHRoZSBkaWZmZXJlbnQgc2l6ZXMuIEZvdW5kIGJ5IGxvb2tpbmcgYXQgVGVYJ3Mgb3V0cHV0IG9mXG4vLyAkXFxiaWdsfCAvLyBcXEJpZ2x8IFxcYmlnZ2x8IFxcQmlnZ2x8IFxcc2hvd2xpc3RzJFxuLy8gVXNlZCB0byBjcmVhdGUgc3RhY2tlZCBkZWxpbWl0ZXJzIG9mIGFwcHJvcHJpYXRlIHNpemVzIGluIG1ha2VTaXplZERlbGltLlxuXG5jb25zdCBzaXplVG9NYXhIZWlnaHQgPSBbMCwgMS4yLCAxLjgsIDIuNCwgMy4wXTtcbi8qKlxuICogVXNlZCB0byBjcmVhdGUgYSBkZWxpbWl0ZXIgb2YgYSBzcGVjaWZpYyBzaXplLCB3aGVyZSBgc2l6ZWAgaXMgMSwgMiwgMywgb3IgNC5cbiAqL1xuXG5jb25zdCBtYWtlU2l6ZWREZWxpbSA9IGZ1bmN0aW9uIChkZWxpbSwgc2l6ZSwgb3B0aW9ucywgbW9kZSwgY2xhc3Nlcykge1xuICAvLyA8IGFuZCA+IHR1cm4gaW50byBcXGxhbmdsZSBhbmQgXFxyYW5nbGUgaW4gZGVsaW1pdGVyc1xuICBpZiAoZGVsaW0gPT09IFwiPFwiIHx8IGRlbGltID09PSBcIlxcXFxsdFwiIHx8IGRlbGltID09PSBcIlxcdTI3ZThcIikge1xuICAgIGRlbGltID0gXCJcXFxcbGFuZ2xlXCI7XG4gIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiPlwiIHx8IGRlbGltID09PSBcIlxcXFxndFwiIHx8IGRlbGltID09PSBcIlxcdTI3ZTlcIikge1xuICAgIGRlbGltID0gXCJcXFxccmFuZ2xlXCI7XG4gIH0gLy8gU2l6ZWQgZGVsaW1pdGVycyBhcmUgbmV2ZXIgY2VudGVyZWQuXG5cblxuICBpZiAodXRpbHMuY29udGFpbnMoc3RhY2tMYXJnZURlbGltaXRlcnMsIGRlbGltKSB8fCB1dGlscy5jb250YWlucyhzdGFja05ldmVyRGVsaW1pdGVycywgZGVsaW0pKSB7XG4gICAgcmV0dXJuIG1ha2VMYXJnZURlbGltKGRlbGltLCBzaXplLCBmYWxzZSwgb3B0aW9ucywgbW9kZSwgY2xhc3Nlcyk7XG4gIH0gZWxzZSBpZiAodXRpbHMuY29udGFpbnMoc3RhY2tBbHdheXNEZWxpbWl0ZXJzLCBkZWxpbSkpIHtcbiAgICByZXR1cm4gbWFrZVN0YWNrZWREZWxpbShkZWxpbSwgc2l6ZVRvTWF4SGVpZ2h0W3NpemVdLCBmYWxzZSwgb3B0aW9ucywgbW9kZSwgY2xhc3Nlcyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiSWxsZWdhbCBkZWxpbWl0ZXI6ICdcIiArIGRlbGltICsgXCInXCIpO1xuICB9XG59O1xuLyoqXG4gKiBUaGVyZSBhcmUgdGhyZWUgZGlmZmVyZW50IHNlcXVlbmNlcyBvZiBkZWxpbWl0ZXIgc2l6ZXMgdGhhdCB0aGUgZGVsaW1pdGVyc1xuICogZm9sbG93IGRlcGVuZGluZyBvbiB0aGUga2luZCBvZiBkZWxpbWl0ZXIuIFRoaXMgaXMgdXNlZCB3aGVuIGNyZWF0aW5nIGN1c3RvbVxuICogc2l6ZWQgZGVsaW1pdGVycyB0byBkZWNpZGUgd2hldGhlciB0byBjcmVhdGUgYSBzbWFsbCwgbGFyZ2UsIG9yIHN0YWNrZWRcbiAqIGRlbGltaXRlci5cbiAqXG4gKiBJbiByZWFsIFRlWCwgdGhlc2Ugc2VxdWVuY2VzIGFyZW4ndCBleHBsaWNpdGx5IGRlZmluZWQsIGJ1dCBhcmUgaW5zdGVhZFxuICogZGVmaW5lZCBpbnNpZGUgdGhlIGZvbnQgbWV0cmljcy4gU2luY2UgdGhlcmUgYXJlIG9ubHkgdGhyZWUgc2VxdWVuY2VzIHRoYXRcbiAqIGFyZSBwb3NzaWJsZSBmb3IgdGhlIGRlbGltaXRlcnMgdGhhdCBUZVggZGVmaW5lcywgaXQgaXMgZWFzaWVyIHRvIGp1c3QgZW5jb2RlXG4gKiB0aGVtIGV4cGxpY2l0bHkgaGVyZS5cbiAqL1xuXG5cbi8vIERlbGltaXRlcnMgdGhhdCBuZXZlciBzdGFjayB0cnkgc21hbGwgZGVsaW1pdGVycyBhbmQgbGFyZ2UgZGVsaW1pdGVycyBvbmx5XG5jb25zdCBzdGFja05ldmVyRGVsaW1pdGVyU2VxdWVuY2UgPSBbe1xuICB0eXBlOiBcInNtYWxsXCIsXG4gIHN0eWxlOiBzcmNfU3R5bGUuU0NSSVBUU0NSSVBUXG59LCB7XG4gIHR5cGU6IFwic21hbGxcIixcbiAgc3R5bGU6IHNyY19TdHlsZS5TQ1JJUFRcbn0sIHtcbiAgdHlwZTogXCJzbWFsbFwiLFxuICBzdHlsZTogc3JjX1N0eWxlLlRFWFRcbn0sIHtcbiAgdHlwZTogXCJsYXJnZVwiLFxuICBzaXplOiAxXG59LCB7XG4gIHR5cGU6IFwibGFyZ2VcIixcbiAgc2l6ZTogMlxufSwge1xuICB0eXBlOiBcImxhcmdlXCIsXG4gIHNpemU6IDNcbn0sIHtcbiAgdHlwZTogXCJsYXJnZVwiLFxuICBzaXplOiA0XG59XTsgLy8gRGVsaW1pdGVycyB0aGF0IGFsd2F5cyBzdGFjayB0cnkgdGhlIHNtYWxsIGRlbGltaXRlcnMgZmlyc3QsIHRoZW4gc3RhY2tcblxuY29uc3Qgc3RhY2tBbHdheXNEZWxpbWl0ZXJTZXF1ZW5jZSA9IFt7XG4gIHR5cGU6IFwic21hbGxcIixcbiAgc3R5bGU6IHNyY19TdHlsZS5TQ1JJUFRTQ1JJUFRcbn0sIHtcbiAgdHlwZTogXCJzbWFsbFwiLFxuICBzdHlsZTogc3JjX1N0eWxlLlNDUklQVFxufSwge1xuICB0eXBlOiBcInNtYWxsXCIsXG4gIHN0eWxlOiBzcmNfU3R5bGUuVEVYVFxufSwge1xuICB0eXBlOiBcInN0YWNrXCJcbn1dOyAvLyBEZWxpbWl0ZXJzIHRoYXQgc3RhY2sgd2hlbiBsYXJnZSB0cnkgdGhlIHNtYWxsIGFuZCB0aGVuIGxhcmdlIGRlbGltaXRlcnMsIGFuZFxuLy8gc3RhY2sgYWZ0ZXJ3YXJkc1xuXG5jb25zdCBzdGFja0xhcmdlRGVsaW1pdGVyU2VxdWVuY2UgPSBbe1xuICB0eXBlOiBcInNtYWxsXCIsXG4gIHN0eWxlOiBzcmNfU3R5bGUuU0NSSVBUU0NSSVBUXG59LCB7XG4gIHR5cGU6IFwic21hbGxcIixcbiAgc3R5bGU6IHNyY19TdHlsZS5TQ1JJUFRcbn0sIHtcbiAgdHlwZTogXCJzbWFsbFwiLFxuICBzdHlsZTogc3JjX1N0eWxlLlRFWFRcbn0sIHtcbiAgdHlwZTogXCJsYXJnZVwiLFxuICBzaXplOiAxXG59LCB7XG4gIHR5cGU6IFwibGFyZ2VcIixcbiAgc2l6ZTogMlxufSwge1xuICB0eXBlOiBcImxhcmdlXCIsXG4gIHNpemU6IDNcbn0sIHtcbiAgdHlwZTogXCJsYXJnZVwiLFxuICBzaXplOiA0XG59LCB7XG4gIHR5cGU6IFwic3RhY2tcIlxufV07XG4vKipcbiAqIEdldCB0aGUgZm9udCB1c2VkIGluIGEgZGVsaW1pdGVyIGJhc2VkIG9uIHdoYXQga2luZCBvZiBkZWxpbWl0ZXIgaXQgaXMuXG4gKiBUT0RPKCM5NjMpIFVzZSBtb3JlIHNwZWNpZmljIGZvbnQgZmFtaWx5IHJldHVybiB0eXBlIG9uY2UgdGhhdCBpcyBpbnRyb2R1Y2VkLlxuICovXG5cbmNvbnN0IGRlbGltVHlwZVRvRm9udCA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gIGlmICh0eXBlLnR5cGUgPT09IFwic21hbGxcIikge1xuICAgIHJldHVybiBcIk1haW4tUmVndWxhclwiO1xuICB9IGVsc2UgaWYgKHR5cGUudHlwZSA9PT0gXCJsYXJnZVwiKSB7XG4gICAgcmV0dXJuIFwiU2l6ZVwiICsgdHlwZS5zaXplICsgXCItUmVndWxhclwiO1xuICB9IGVsc2UgaWYgKHR5cGUudHlwZSA9PT0gXCJzdGFja1wiKSB7XG4gICAgcmV0dXJuIFwiU2l6ZTQtUmVndWxhclwiO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkFkZCBzdXBwb3J0IGZvciBkZWxpbSB0eXBlICdcIiArIHR5cGUudHlwZSArIFwiJyBoZXJlLlwiKTtcbiAgfVxufTtcbi8qKlxuICogVHJhdmVyc2UgYSBzZXF1ZW5jZSBvZiB0eXBlcyBvZiBkZWxpbWl0ZXJzIHRvIGRlY2lkZSB3aGF0IGtpbmQgb2YgZGVsaW1pdGVyXG4gKiBzaG91bGQgYmUgdXNlZCB0byBjcmVhdGUgYSBkZWxpbWl0ZXIgb2YgdGhlIGdpdmVuIGhlaWdodCtkZXB0aC5cbiAqL1xuXG5cbmNvbnN0IHRyYXZlcnNlU2VxdWVuY2UgPSBmdW5jdGlvbiAoZGVsaW0sIGhlaWdodCwgc2VxdWVuY2UsIG9wdGlvbnMpIHtcbiAgLy8gSGVyZSwgd2UgY2hvb3NlIHRoZSBpbmRleCB3ZSBzaG91bGQgc3RhcnQgYXQgaW4gdGhlIHNlcXVlbmNlcy4gSW4gc21hbGxlclxuICAvLyBzaXplcyAod2hpY2ggY29ycmVzcG9uZCB0byBsYXJnZXIgbnVtYmVycyBpbiBzdHlsZS5zaXplKSB3ZSBzdGFydCBlYXJsaWVyXG4gIC8vIGluIHRoZSBzZXF1ZW5jZS4gVGh1cywgc2NyaXB0c2NyaXB0IHN0YXJ0cyBhdCBpbmRleCAzLTM9MCwgc2NyaXB0IHN0YXJ0c1xuICAvLyBhdCBpbmRleCAzLTI9MSwgdGV4dCBzdGFydHMgYXQgMy0xPTIsIGFuZCBkaXNwbGF5IHN0YXJ0cyBhdCBtaW4oMiwzLTApPTJcbiAgY29uc3Qgc3RhcnQgPSBNYXRoLm1pbigyLCAzIC0gb3B0aW9ucy5zdHlsZS5zaXplKTtcblxuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBzZXF1ZW5jZS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzZXF1ZW5jZVtpXS50eXBlID09PSBcInN0YWNrXCIpIHtcbiAgICAgIC8vIFRoaXMgaXMgYWx3YXlzIHRoZSBsYXN0IGRlbGltaXRlciwgc28gd2UganVzdCBicmVhayB0aGUgbG9vcCBub3cuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjb25zdCBtZXRyaWNzID0gZ2V0TWV0cmljcyhkZWxpbSwgZGVsaW1UeXBlVG9Gb250KHNlcXVlbmNlW2ldKSwgXCJtYXRoXCIpO1xuICAgIGxldCBoZWlnaHREZXB0aCA9IG1ldHJpY3MuaGVpZ2h0ICsgbWV0cmljcy5kZXB0aDsgLy8gU21hbGwgZGVsaW1pdGVycyBhcmUgc2NhbGVkIGRvd24gdmVyc2lvbnMgb2YgdGhlIHNhbWUgZm9udCwgc28gd2VcbiAgICAvLyBhY2NvdW50IGZvciB0aGUgc3R5bGUgY2hhbmdlIHNpemUuXG5cbiAgICBpZiAoc2VxdWVuY2VbaV0udHlwZSA9PT0gXCJzbWFsbFwiKSB7XG4gICAgICBjb25zdCBuZXdPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdCYXNlU3R5bGUoc2VxdWVuY2VbaV0uc3R5bGUpO1xuICAgICAgaGVpZ2h0RGVwdGggKj0gbmV3T3B0aW9ucy5zaXplTXVsdGlwbGllcjtcbiAgICB9IC8vIENoZWNrIGlmIHRoZSBkZWxpbWl0ZXIgYXQgdGhpcyBzaXplIHdvcmtzIGZvciB0aGUgZ2l2ZW4gaGVpZ2h0LlxuXG5cbiAgICBpZiAoaGVpZ2h0RGVwdGggPiBoZWlnaHQpIHtcbiAgICAgIHJldHVybiBzZXF1ZW5jZVtpXTtcbiAgICB9XG4gIH0gLy8gSWYgd2UgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBzZXF1ZW5jZSwgcmV0dXJuIHRoZSBsYXN0IHNlcXVlbmNlIGVsZW1lbnQuXG5cblxuICByZXR1cm4gc2VxdWVuY2Vbc2VxdWVuY2UubGVuZ3RoIC0gMV07XG59O1xuLyoqXG4gKiBNYWtlIGEgZGVsaW1pdGVyIG9mIGEgZ2l2ZW4gaGVpZ2h0K2RlcHRoLCB3aXRoIG9wdGlvbmFsIGNlbnRlcmluZy4gSGVyZSwgd2VcbiAqIHRyYXZlcnNlIHRoZSBzZXF1ZW5jZXMsIGFuZCBjcmVhdGUgYSBkZWxpbWl0ZXIgdGhhdCB0aGUgc2VxdWVuY2UgdGVsbHMgdXMgdG8uXG4gKi9cblxuXG5jb25zdCBtYWtlQ3VzdG9tU2l6ZWREZWxpbSA9IGZ1bmN0aW9uIChkZWxpbSwgaGVpZ2h0LCBjZW50ZXIsIG9wdGlvbnMsIG1vZGUsIGNsYXNzZXMpIHtcbiAgaWYgKGRlbGltID09PSBcIjxcIiB8fCBkZWxpbSA9PT0gXCJcXFxcbHRcIiB8fCBkZWxpbSA9PT0gXCJcXHUyN2U4XCIpIHtcbiAgICBkZWxpbSA9IFwiXFxcXGxhbmdsZVwiO1xuICB9IGVsc2UgaWYgKGRlbGltID09PSBcIj5cIiB8fCBkZWxpbSA9PT0gXCJcXFxcZ3RcIiB8fCBkZWxpbSA9PT0gXCJcXHUyN2U5XCIpIHtcbiAgICBkZWxpbSA9IFwiXFxcXHJhbmdsZVwiO1xuICB9IC8vIERlY2lkZSB3aGF0IHNlcXVlbmNlIHRvIHVzZVxuXG5cbiAgbGV0IHNlcXVlbmNlO1xuXG4gIGlmICh1dGlscy5jb250YWlucyhzdGFja05ldmVyRGVsaW1pdGVycywgZGVsaW0pKSB7XG4gICAgc2VxdWVuY2UgPSBzdGFja05ldmVyRGVsaW1pdGVyU2VxdWVuY2U7XG4gIH0gZWxzZSBpZiAodXRpbHMuY29udGFpbnMoc3RhY2tMYXJnZURlbGltaXRlcnMsIGRlbGltKSkge1xuICAgIHNlcXVlbmNlID0gc3RhY2tMYXJnZURlbGltaXRlclNlcXVlbmNlO1xuICB9IGVsc2Uge1xuICAgIHNlcXVlbmNlID0gc3RhY2tBbHdheXNEZWxpbWl0ZXJTZXF1ZW5jZTtcbiAgfSAvLyBMb29rIHRocm91Z2ggdGhlIHNlcXVlbmNlXG5cblxuICBjb25zdCBkZWxpbVR5cGUgPSB0cmF2ZXJzZVNlcXVlbmNlKGRlbGltLCBoZWlnaHQsIHNlcXVlbmNlLCBvcHRpb25zKTsgLy8gR2V0IHRoZSBkZWxpbWl0ZXIgZnJvbSBmb250IGdseXBocy5cbiAgLy8gRGVwZW5kaW5nIG9uIHRoZSBzZXF1ZW5jZSBlbGVtZW50IHdlIGRlY2lkZWQgb24sIGNhbGwgdGhlXG4gIC8vIGFwcHJvcHJpYXRlIGZ1bmN0aW9uLlxuXG4gIGlmIChkZWxpbVR5cGUudHlwZSA9PT0gXCJzbWFsbFwiKSB7XG4gICAgcmV0dXJuIG1ha2VTbWFsbERlbGltKGRlbGltLCBkZWxpbVR5cGUuc3R5bGUsIGNlbnRlciwgb3B0aW9ucywgbW9kZSwgY2xhc3Nlcyk7XG4gIH0gZWxzZSBpZiAoZGVsaW1UeXBlLnR5cGUgPT09IFwibGFyZ2VcIikge1xuICAgIHJldHVybiBtYWtlTGFyZ2VEZWxpbShkZWxpbSwgZGVsaW1UeXBlLnNpemUsIGNlbnRlciwgb3B0aW9ucywgbW9kZSwgY2xhc3Nlcyk7XG4gIH0gZWxzZVxuICAgIC8qIGlmIChkZWxpbVR5cGUudHlwZSA9PT0gXCJzdGFja1wiKSAqL1xuICAgIHtcbiAgICAgIHJldHVybiBtYWtlU3RhY2tlZERlbGltKGRlbGltLCBoZWlnaHQsIGNlbnRlciwgb3B0aW9ucywgbW9kZSwgY2xhc3Nlcyk7XG4gICAgfVxufTtcbi8qKlxuICogTWFrZSBhIGRlbGltaXRlciBmb3IgdXNlIHdpdGggYFxcbGVmdGAgYW5kIGBcXHJpZ2h0YCwgZ2l2ZW4gYSBoZWlnaHQgYW5kIGRlcHRoXG4gKiBvZiBhbiBleHByZXNzaW9uIHRoYXQgdGhlIGRlbGltaXRlcnMgc3Vycm91bmQuXG4gKi9cblxuXG5jb25zdCBtYWtlTGVmdFJpZ2h0RGVsaW0gPSBmdW5jdGlvbiAoZGVsaW0sIGhlaWdodCwgZGVwdGgsIG9wdGlvbnMsIG1vZGUsIGNsYXNzZXMpIHtcbiAgLy8gV2UgYWx3YXlzIGNlbnRlciBcXGxlZnQvXFxyaWdodCBkZWxpbWl0ZXJzLCBzbyB0aGUgYXhpcyBpcyBhbHdheXMgc2hpZnRlZFxuICBjb25zdCBheGlzSGVpZ2h0ID0gb3B0aW9ucy5mb250TWV0cmljcygpLmF4aXNIZWlnaHQgKiBvcHRpb25zLnNpemVNdWx0aXBsaWVyOyAvLyBUYWtlbiBmcm9tIFRlWCBzb3VyY2UsIHRleC53ZWIsIGZ1bmN0aW9uIG1ha2VfbGVmdF9yaWdodFxuXG4gIGNvbnN0IGRlbGltaXRlckZhY3RvciA9IDkwMTtcbiAgY29uc3QgZGVsaW1pdGVyRXh0ZW5kID0gNS4wIC8gb3B0aW9ucy5mb250TWV0cmljcygpLnB0UGVyRW07XG4gIGNvbnN0IG1heERpc3RGcm9tQXhpcyA9IE1hdGgubWF4KGhlaWdodCAtIGF4aXNIZWlnaHQsIGRlcHRoICsgYXhpc0hlaWdodCk7XG4gIGNvbnN0IHRvdGFsSGVpZ2h0ID0gTWF0aC5tYXgoIC8vIEluIHJlYWwgVGVYLCBjYWxjdWxhdGlvbnMgYXJlIGRvbmUgdXNpbmcgaW50ZWdyYWwgdmFsdWVzIHdoaWNoIGFyZVxuICAvLyA2NTUzNiBwZXIgcHQsIG9yIDY1NTM2MCBwZXIgZW0uIFNvLCB0aGUgZGl2aXNpb24gaGVyZSB0cnVuY2F0ZXMgaW5cbiAgLy8gVGVYIGJ1dCBkb2Vzbid0IGhlcmUsIHByb2R1Y2luZyBkaWZmZXJlbnQgcmVzdWx0cy4gSWYgd2Ugd2FudGVkIHRvXG4gIC8vIGV4YWN0bHkgbWF0Y2ggVGVYJ3MgY2FsY3VsYXRpb24sIHdlIGNvdWxkIGRvXG4gIC8vICAgTWF0aC5mbG9vcig2NTUzNjAgKiBtYXhEaXN0RnJvbUF4aXMgLyA1MDApICpcbiAgLy8gICAgZGVsaW1pdGVyRmFjdG9yIC8gNjU1MzYwXG4gIC8vIChUbyBzZWUgdGhlIGRpZmZlcmVuY2UsIGNvbXBhcmVcbiAgLy8gICAgeF57eF57XFxsZWZ0KFxccnVsZXswLjFlbX17MC42OGVtfVxccmlnaHQpfX1cbiAgLy8gaW4gVGVYIGFuZCBLYVRlWClcbiAgbWF4RGlzdEZyb21BeGlzIC8gNTAwICogZGVsaW1pdGVyRmFjdG9yLCAyICogbWF4RGlzdEZyb21BeGlzIC0gZGVsaW1pdGVyRXh0ZW5kKTsgLy8gRmluYWxseSwgd2UgZGVmZXIgdG8gYG1ha2VDdXN0b21TaXplZERlbGltYCB3aXRoIG91ciBjYWxjdWxhdGVkIHRvdGFsXG4gIC8vIGhlaWdodFxuXG4gIHJldHVybiBtYWtlQ3VzdG9tU2l6ZWREZWxpbShkZWxpbSwgdG90YWxIZWlnaHQsIHRydWUsIG9wdGlvbnMsIG1vZGUsIGNsYXNzZXMpO1xufTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgZGVsaW1pdGVyID0gKHtcbiAgc3FydEltYWdlOiBtYWtlU3FydEltYWdlLFxuICBzaXplZERlbGltOiBtYWtlU2l6ZWREZWxpbSxcbiAgc2l6ZVRvTWF4SGVpZ2h0OiBzaXplVG9NYXhIZWlnaHQsXG4gIGN1c3RvbVNpemVkRGVsaW06IG1ha2VDdXN0b21TaXplZERlbGltLFxuICBsZWZ0UmlnaHREZWxpbTogbWFrZUxlZnRSaWdodERlbGltXG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mdW5jdGlvbnMvZGVsaW1zaXppbmcuanNcblxuXG5cblxuXG5cblxuXG5cblxuLy8gRXh0cmEgZGF0YSBuZWVkZWQgZm9yIHRoZSBkZWxpbWl0ZXIgaGFuZGxlciBkb3duIGJlbG93XG5jb25zdCBkZWxpbWl0ZXJTaXplcyA9IHtcbiAgXCJcXFxcYmlnbFwiOiB7XG4gICAgbWNsYXNzOiBcIm1vcGVuXCIsXG4gICAgc2l6ZTogMVxuICB9LFxuICBcIlxcXFxCaWdsXCI6IHtcbiAgICBtY2xhc3M6IFwibW9wZW5cIixcbiAgICBzaXplOiAyXG4gIH0sXG4gIFwiXFxcXGJpZ2dsXCI6IHtcbiAgICBtY2xhc3M6IFwibW9wZW5cIixcbiAgICBzaXplOiAzXG4gIH0sXG4gIFwiXFxcXEJpZ2dsXCI6IHtcbiAgICBtY2xhc3M6IFwibW9wZW5cIixcbiAgICBzaXplOiA0XG4gIH0sXG4gIFwiXFxcXGJpZ3JcIjoge1xuICAgIG1jbGFzczogXCJtY2xvc2VcIixcbiAgICBzaXplOiAxXG4gIH0sXG4gIFwiXFxcXEJpZ3JcIjoge1xuICAgIG1jbGFzczogXCJtY2xvc2VcIixcbiAgICBzaXplOiAyXG4gIH0sXG4gIFwiXFxcXGJpZ2dyXCI6IHtcbiAgICBtY2xhc3M6IFwibWNsb3NlXCIsXG4gICAgc2l6ZTogM1xuICB9LFxuICBcIlxcXFxCaWdnclwiOiB7XG4gICAgbWNsYXNzOiBcIm1jbG9zZVwiLFxuICAgIHNpemU6IDRcbiAgfSxcbiAgXCJcXFxcYmlnbVwiOiB7XG4gICAgbWNsYXNzOiBcIm1yZWxcIixcbiAgICBzaXplOiAxXG4gIH0sXG4gIFwiXFxcXEJpZ21cIjoge1xuICAgIG1jbGFzczogXCJtcmVsXCIsXG4gICAgc2l6ZTogMlxuICB9LFxuICBcIlxcXFxiaWdnbVwiOiB7XG4gICAgbWNsYXNzOiBcIm1yZWxcIixcbiAgICBzaXplOiAzXG4gIH0sXG4gIFwiXFxcXEJpZ2dtXCI6IHtcbiAgICBtY2xhc3M6IFwibXJlbFwiLFxuICAgIHNpemU6IDRcbiAgfSxcbiAgXCJcXFxcYmlnXCI6IHtcbiAgICBtY2xhc3M6IFwibW9yZFwiLFxuICAgIHNpemU6IDFcbiAgfSxcbiAgXCJcXFxcQmlnXCI6IHtcbiAgICBtY2xhc3M6IFwibW9yZFwiLFxuICAgIHNpemU6IDJcbiAgfSxcbiAgXCJcXFxcYmlnZ1wiOiB7XG4gICAgbWNsYXNzOiBcIm1vcmRcIixcbiAgICBzaXplOiAzXG4gIH0sXG4gIFwiXFxcXEJpZ2dcIjoge1xuICAgIG1jbGFzczogXCJtb3JkXCIsXG4gICAgc2l6ZTogNFxuICB9XG59O1xuY29uc3QgZGVsaW1pdGVycyA9IFtcIihcIiwgXCJcXFxcbHBhcmVuXCIsIFwiKVwiLCBcIlxcXFxycGFyZW5cIiwgXCJbXCIsIFwiXFxcXGxicmFja1wiLCBcIl1cIiwgXCJcXFxccmJyYWNrXCIsIFwiXFxcXHtcIiwgXCJcXFxcbGJyYWNlXCIsIFwiXFxcXH1cIiwgXCJcXFxccmJyYWNlXCIsIFwiXFxcXGxmbG9vclwiLCBcIlxcXFxyZmxvb3JcIiwgXCJcXHUyMzBhXCIsIFwiXFx1MjMwYlwiLCBcIlxcXFxsY2VpbFwiLCBcIlxcXFxyY2VpbFwiLCBcIlxcdTIzMDhcIiwgXCJcXHUyMzA5XCIsIFwiPFwiLCBcIj5cIiwgXCJcXFxcbGFuZ2xlXCIsIFwiXFx1MjdlOFwiLCBcIlxcXFxyYW5nbGVcIiwgXCJcXHUyN2U5XCIsIFwiXFxcXGx0XCIsIFwiXFxcXGd0XCIsIFwiXFxcXGx2ZXJ0XCIsIFwiXFxcXHJ2ZXJ0XCIsIFwiXFxcXGxWZXJ0XCIsIFwiXFxcXHJWZXJ0XCIsIFwiXFxcXGxncm91cFwiLCBcIlxcXFxyZ3JvdXBcIiwgXCJcXHUyN2VlXCIsIFwiXFx1MjdlZlwiLCBcIlxcXFxsbW91c3RhY2hlXCIsIFwiXFxcXHJtb3VzdGFjaGVcIiwgXCJcXHUyM2IwXCIsIFwiXFx1MjNiMVwiLCBcIi9cIiwgXCJcXFxcYmFja3NsYXNoXCIsIFwifFwiLCBcIlxcXFx2ZXJ0XCIsIFwiXFxcXHxcIiwgXCJcXFxcVmVydFwiLCBcIlxcXFx1cGFycm93XCIsIFwiXFxcXFVwYXJyb3dcIiwgXCJcXFxcZG93bmFycm93XCIsIFwiXFxcXERvd25hcnJvd1wiLCBcIlxcXFx1cGRvd25hcnJvd1wiLCBcIlxcXFxVcGRvd25hcnJvd1wiLCBcIi5cIl07XG5cbi8vIERlbGltaXRlciBmdW5jdGlvbnNcbmZ1bmN0aW9uIGNoZWNrRGVsaW1pdGVyKGRlbGltLCBjb250ZXh0KSB7XG4gIGNvbnN0IHN5bURlbGltID0gY2hlY2tTeW1ib2xOb2RlVHlwZShkZWxpbSk7XG5cbiAgaWYgKHN5bURlbGltICYmIHV0aWxzLmNvbnRhaW5zKGRlbGltaXRlcnMsIHN5bURlbGltLnRleHQpKSB7XG4gICAgcmV0dXJuIHN5bURlbGltO1xuICB9IGVsc2UgaWYgKHN5bURlbGltKSB7XG4gICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiSW52YWxpZCBkZWxpbWl0ZXIgJ1wiICsgc3ltRGVsaW0udGV4dCArIFwiJyBhZnRlciAnXCIgKyBjb250ZXh0LmZ1bmNOYW1lICsgXCInXCIsIGRlbGltKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJJbnZhbGlkIGRlbGltaXRlciB0eXBlICdcIiArIGRlbGltLnR5cGUgKyBcIidcIiwgZGVsaW0pO1xuICB9XG59XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJkZWxpbXNpemluZ1wiLFxuICBuYW1lczogW1wiXFxcXGJpZ2xcIiwgXCJcXFxcQmlnbFwiLCBcIlxcXFxiaWdnbFwiLCBcIlxcXFxCaWdnbFwiLCBcIlxcXFxiaWdyXCIsIFwiXFxcXEJpZ3JcIiwgXCJcXFxcYmlnZ3JcIiwgXCJcXFxcQmlnZ3JcIiwgXCJcXFxcYmlnbVwiLCBcIlxcXFxCaWdtXCIsIFwiXFxcXGJpZ2dtXCIsIFwiXFxcXEJpZ2dtXCIsIFwiXFxcXGJpZ1wiLCBcIlxcXFxCaWdcIiwgXCJcXFxcYmlnZ1wiLCBcIlxcXFxCaWdnXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYXJnVHlwZXM6IFtcInByaW1pdGl2ZVwiXVxuICB9LFxuICBoYW5kbGVyOiAoY29udGV4dCwgYXJncykgPT4ge1xuICAgIGNvbnN0IGRlbGltID0gY2hlY2tEZWxpbWl0ZXIoYXJnc1swXSwgY29udGV4dCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZGVsaW1zaXppbmdcIixcbiAgICAgIG1vZGU6IGNvbnRleHQucGFyc2VyLm1vZGUsXG4gICAgICBzaXplOiBkZWxpbWl0ZXJTaXplc1tjb250ZXh0LmZ1bmNOYW1lXS5zaXplLFxuICAgICAgbWNsYXNzOiBkZWxpbWl0ZXJTaXplc1tjb250ZXh0LmZ1bmNOYW1lXS5tY2xhc3MsXG4gICAgICBkZWxpbTogZGVsaW0udGV4dFxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgICBpZiAoZ3JvdXAuZGVsaW0gPT09IFwiLlwiKSB7XG4gICAgICAvLyBFbXB0eSBkZWxpbWl0ZXJzIHN0aWxsIGNvdW50IGFzIGVsZW1lbnRzLCBldmVuIHRob3VnaCB0aGV5IGRvbid0XG4gICAgICAvLyBzaG93IGFueXRoaW5nLlxuICAgICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtncm91cC5tY2xhc3NdKTtcbiAgICB9IC8vIFVzZSBkZWxpbWl0ZXIuc2l6ZWREZWxpbSB0byBnZW5lcmF0ZSB0aGUgZGVsaW1pdGVyLlxuXG5cbiAgICByZXR1cm4gZGVsaW1pdGVyLnNpemVkRGVsaW0oZ3JvdXAuZGVsaW0sIGdyb3VwLnNpemUsIG9wdGlvbnMsIGdyb3VwLm1vZGUsIFtncm91cC5tY2xhc3NdKTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogZ3JvdXAgPT4ge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gW107XG5cbiAgICBpZiAoZ3JvdXAuZGVsaW0gIT09IFwiLlwiKSB7XG4gICAgICBjaGlsZHJlbi5wdXNoKG1ha2VUZXh0KGdyb3VwLmRlbGltLCBncm91cC5tb2RlKSk7XG4gICAgfVxuXG4gICAgY29uc3Qgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIiwgY2hpbGRyZW4pO1xuXG4gICAgaWYgKGdyb3VwLm1jbGFzcyA9PT0gXCJtb3BlblwiIHx8IGdyb3VwLm1jbGFzcyA9PT0gXCJtY2xvc2VcIikge1xuICAgICAgLy8gT25seSBzb21lIG9mIHRoZSBkZWxpbXNpemluZyBmdW5jdGlvbnMgYWN0IGFzIGZlbmNlcywgYW5kIHRoZXlcbiAgICAgIC8vIHJldHVybiBcIm1vcGVuXCIgb3IgXCJtY2xvc2VcIiBtY2xhc3MuXG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcImZlbmNlXCIsIFwidHJ1ZVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRXhwbGljaXRseSBkaXNhYmxlIGZlbmNpbmcgaWYgaXQncyBub3QgYSBmZW5jZSwgdG8gb3ZlcnJpZGUgdGhlXG4gICAgICAvLyBkZWZhdWx0cy5cbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiZmVuY2VcIiwgXCJmYWxzZVwiKTtcbiAgICB9XG5cbiAgICBub2RlLnNldEF0dHJpYnV0ZShcInN0cmV0Y2h5XCIsIFwidHJ1ZVwiKTtcbiAgICBjb25zdCBzaXplID0gbWFrZUVtKGRlbGltaXRlci5zaXplVG9NYXhIZWlnaHRbZ3JvdXAuc2l6ZV0pO1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibWluc2l6ZVwiLCBzaXplKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcIm1heHNpemVcIiwgc2l6ZSk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBhc3NlcnRQYXJzZWQoZ3JvdXApIHtcbiAgaWYgKCFncm91cC5ib2R5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQnVnOiBUaGUgbGVmdHJpZ2h0IFBhcnNlTm9kZSB3YXNuJ3QgZnVsbHkgcGFyc2VkLlwiKTtcbiAgfVxufVxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwibGVmdHJpZ2h0LXJpZ2h0XCIsXG4gIG5hbWVzOiBbXCJcXFxccmlnaHRcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBwcmltaXRpdmU6IHRydWVcbiAgfSxcbiAgaGFuZGxlcjogKGNvbnRleHQsIGFyZ3MpID0+IHtcbiAgICAvLyBcXGxlZnQgY2FzZSBiZWxvdyB0cmlnZ2VycyBwYXJzaW5nIG9mIFxccmlnaHQgaW5cbiAgICAvLyAgIGBjb25zdCByaWdodCA9IHBhcnNlci5wYXJzZUZ1bmN0aW9uKCk7YFxuICAgIC8vIHVzZXMgdGhpcyByZXR1cm4gdmFsdWUuXG4gICAgY29uc3QgY29sb3IgPSBjb250ZXh0LnBhcnNlci5ndWxsZXQubWFjcm9zLmdldChcIlxcXFxjdXJyZW50QGNvbG9yXCIpO1xuXG4gICAgaWYgKGNvbG9yICYmIHR5cGVvZiBjb2xvciAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiXFxcXGN1cnJlbnRAY29sb3Igc2V0IHRvIG5vbi1zdHJpbmcgaW4gXFxcXHJpZ2h0XCIpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImxlZnRyaWdodC1yaWdodFwiLFxuICAgICAgbW9kZTogY29udGV4dC5wYXJzZXIubW9kZSxcbiAgICAgIGRlbGltOiBjaGVja0RlbGltaXRlcihhcmdzWzBdLCBjb250ZXh0KS50ZXh0LFxuICAgICAgY29sb3IgLy8gdW5kZWZpbmVkIGlmIG5vdCBzZXQgdmlhIFxcY29sb3JcblxuICAgIH07XG4gIH1cbn0pO1xuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImxlZnRyaWdodFwiLFxuICBuYW1lczogW1wiXFxcXGxlZnRcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBwcmltaXRpdmU6IHRydWVcbiAgfSxcbiAgaGFuZGxlcjogKGNvbnRleHQsIGFyZ3MpID0+IHtcbiAgICBjb25zdCBkZWxpbSA9IGNoZWNrRGVsaW1pdGVyKGFyZ3NbMF0sIGNvbnRleHQpO1xuICAgIGNvbnN0IHBhcnNlciA9IGNvbnRleHQucGFyc2VyOyAvLyBQYXJzZSBvdXQgdGhlIGltcGxpY2l0IGJvZHlcblxuICAgICsrcGFyc2VyLmxlZnRyaWdodERlcHRoOyAvLyBwYXJzZUV4cHJlc3Npb24gc3RvcHMgYmVmb3JlICdcXFxccmlnaHQnXG5cbiAgICBjb25zdCBib2R5ID0gcGFyc2VyLnBhcnNlRXhwcmVzc2lvbihmYWxzZSk7XG4gICAgLS1wYXJzZXIubGVmdHJpZ2h0RGVwdGg7IC8vIENoZWNrIHRoZSBuZXh0IHRva2VuXG5cbiAgICBwYXJzZXIuZXhwZWN0KFwiXFxcXHJpZ2h0XCIsIGZhbHNlKTtcbiAgICBjb25zdCByaWdodCA9IGFzc2VydE5vZGVUeXBlKHBhcnNlci5wYXJzZUZ1bmN0aW9uKCksIFwibGVmdHJpZ2h0LXJpZ2h0XCIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImxlZnRyaWdodFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBib2R5LFxuICAgICAgbGVmdDogZGVsaW0udGV4dCxcbiAgICAgIHJpZ2h0OiByaWdodC5kZWxpbSxcbiAgICAgIHJpZ2h0Q29sb3I6IHJpZ2h0LmNvbG9yXG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IChncm91cCwgb3B0aW9ucykgPT4ge1xuICAgIGFzc2VydFBhcnNlZChncm91cCk7IC8vIEJ1aWxkIHRoZSBpbm5lciBleHByZXNzaW9uXG5cbiAgICBjb25zdCBpbm5lciA9IGJ1aWxkRXhwcmVzc2lvbihncm91cC5ib2R5LCBvcHRpb25zLCB0cnVlLCBbXCJtb3BlblwiLCBcIm1jbG9zZVwiXSk7XG4gICAgbGV0IGlubmVySGVpZ2h0ID0gMDtcbiAgICBsZXQgaW5uZXJEZXB0aCA9IDA7XG4gICAgbGV0IGhhZE1pZGRsZSA9IGZhbHNlOyAvLyBDYWxjdWxhdGUgaXRzIGhlaWdodCBhbmQgZGVwdGhcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5uZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIFByb3BlcnR5IGBpc01pZGRsZWAgbm90IGRlZmluZWQgb24gYHNwYW5gLiBTZWUgY29tbWVudCBpblxuICAgICAgLy8gXCJtaWRkbGVcIidzIGh0bWxCdWlsZGVyLlxuICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgaWYgKGlubmVyW2ldLmlzTWlkZGxlKSB7XG4gICAgICAgIGhhZE1pZGRsZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbm5lckhlaWdodCA9IE1hdGgubWF4KGlubmVyW2ldLmhlaWdodCwgaW5uZXJIZWlnaHQpO1xuICAgICAgICBpbm5lckRlcHRoID0gTWF0aC5tYXgoaW5uZXJbaV0uZGVwdGgsIGlubmVyRGVwdGgpO1xuICAgICAgfVxuICAgIH0gLy8gVGhlIHNpemUgb2YgZGVsaW1pdGVycyBpcyB0aGUgc2FtZSwgcmVnYXJkbGVzcyBvZiB3aGF0IHN0eWxlIHdlIGFyZVxuICAgIC8vIGluLiBUaHVzLCB0byBjb3JyZWN0bHkgY2FsY3VsYXRlIHRoZSBzaXplIG9mIGRlbGltaXRlciB3ZSBuZWVkIGFyb3VuZFxuICAgIC8vIGEgZ3JvdXAsIHdlIHNjYWxlIGRvd24gdGhlIGlubmVyIHNpemUgYmFzZWQgb24gdGhlIHNpemUuXG5cblxuICAgIGlubmVySGVpZ2h0ICo9IG9wdGlvbnMuc2l6ZU11bHRpcGxpZXI7XG4gICAgaW5uZXJEZXB0aCAqPSBvcHRpb25zLnNpemVNdWx0aXBsaWVyO1xuICAgIGxldCBsZWZ0RGVsaW07XG5cbiAgICBpZiAoZ3JvdXAubGVmdCA9PT0gXCIuXCIpIHtcbiAgICAgIC8vIEVtcHR5IGRlbGltaXRlcnMgaW4gXFxsZWZ0IGFuZCBcXHJpZ2h0IG1ha2UgbnVsbCBkZWxpbWl0ZXIgc3BhY2VzLlxuICAgICAgbGVmdERlbGltID0gbWFrZU51bGxEZWxpbWl0ZXIob3B0aW9ucywgW1wibW9wZW5cIl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPdGhlcndpc2UsIHVzZSBsZWZ0UmlnaHREZWxpbSB0byBnZW5lcmF0ZSB0aGUgY29ycmVjdCBzaXplZFxuICAgICAgLy8gZGVsaW1pdGVyLlxuICAgICAgbGVmdERlbGltID0gZGVsaW1pdGVyLmxlZnRSaWdodERlbGltKGdyb3VwLmxlZnQsIGlubmVySGVpZ2h0LCBpbm5lckRlcHRoLCBvcHRpb25zLCBncm91cC5tb2RlLCBbXCJtb3BlblwiXSk7XG4gICAgfSAvLyBBZGQgaXQgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgZXhwcmVzc2lvblxuXG5cbiAgICBpbm5lci51bnNoaWZ0KGxlZnREZWxpbSk7IC8vIEhhbmRsZSBtaWRkbGUgZGVsaW1pdGVyc1xuXG4gICAgaWYgKGhhZE1pZGRsZSkge1xuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBpbm5lci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBtaWRkbGVEZWxpbSA9IGlubmVyW2ldOyAvLyBQcm9wZXJ0eSBgaXNNaWRkbGVgIG5vdCBkZWZpbmVkIG9uIGBzcGFuYC4gU2VlIGNvbW1lbnQgaW5cbiAgICAgICAgLy8gXCJtaWRkbGVcIidzIGh0bWxCdWlsZGVyLlxuICAgICAgICAvLyAkRmxvd0ZpeE1lXG5cbiAgICAgICAgY29uc3QgaXNNaWRkbGUgPSBtaWRkbGVEZWxpbS5pc01pZGRsZTtcblxuICAgICAgICBpZiAoaXNNaWRkbGUpIHtcbiAgICAgICAgICAvLyBBcHBseSB0aGUgb3B0aW9ucyB0aGF0IHdlcmUgYWN0aXZlIHdoZW4gXFxtaWRkbGUgd2FzIGNhbGxlZFxuICAgICAgICAgIGlubmVyW2ldID0gZGVsaW1pdGVyLmxlZnRSaWdodERlbGltKGlzTWlkZGxlLmRlbGltLCBpbm5lckhlaWdodCwgaW5uZXJEZXB0aCwgaXNNaWRkbGUub3B0aW9ucywgZ3JvdXAubW9kZSwgW10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHJpZ2h0RGVsaW07IC8vIFNhbWUgZm9yIHRoZSByaWdodCBkZWxpbWl0ZXIsIGJ1dCB1c2luZyBjb2xvciBzcGVjaWZpZWQgYnkgXFxjb2xvclxuXG4gICAgaWYgKGdyb3VwLnJpZ2h0ID09PSBcIi5cIikge1xuICAgICAgcmlnaHREZWxpbSA9IG1ha2VOdWxsRGVsaW1pdGVyKG9wdGlvbnMsIFtcIm1jbG9zZVwiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNvbG9yT3B0aW9ucyA9IGdyb3VwLnJpZ2h0Q29sb3IgPyBvcHRpb25zLndpdGhDb2xvcihncm91cC5yaWdodENvbG9yKSA6IG9wdGlvbnM7XG4gICAgICByaWdodERlbGltID0gZGVsaW1pdGVyLmxlZnRSaWdodERlbGltKGdyb3VwLnJpZ2h0LCBpbm5lckhlaWdodCwgaW5uZXJEZXB0aCwgY29sb3JPcHRpb25zLCBncm91cC5tb2RlLCBbXCJtY2xvc2VcIl0pO1xuICAgIH0gLy8gQWRkIGl0IHRvIHRoZSBlbmQgb2YgdGhlIGV4cHJlc3Npb24uXG5cblxuICAgIGlubmVyLnB1c2gocmlnaHREZWxpbSk7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1pbm5lclwiXSwgaW5uZXIsIG9wdGlvbnMpO1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgICBhc3NlcnRQYXJzZWQoZ3JvdXApO1xuICAgIGNvbnN0IGlubmVyID0gYnVpbGRNYXRoTUxfYnVpbGRFeHByZXNzaW9uKGdyb3VwLmJvZHksIG9wdGlvbnMpO1xuXG4gICAgaWYgKGdyb3VwLmxlZnQgIT09IFwiLlwiKSB7XG4gICAgICBjb25zdCBsZWZ0Tm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIiwgW21ha2VUZXh0KGdyb3VwLmxlZnQsIGdyb3VwLm1vZGUpXSk7XG4gICAgICBsZWZ0Tm9kZS5zZXRBdHRyaWJ1dGUoXCJmZW5jZVwiLCBcInRydWVcIik7XG4gICAgICBpbm5lci51bnNoaWZ0KGxlZnROb2RlKTtcbiAgICB9XG5cbiAgICBpZiAoZ3JvdXAucmlnaHQgIT09IFwiLlwiKSB7XG4gICAgICBjb25zdCByaWdodE5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vXCIsIFttYWtlVGV4dChncm91cC5yaWdodCwgZ3JvdXAubW9kZSldKTtcbiAgICAgIHJpZ2h0Tm9kZS5zZXRBdHRyaWJ1dGUoXCJmZW5jZVwiLCBcInRydWVcIik7XG5cbiAgICAgIGlmIChncm91cC5yaWdodENvbG9yKSB7XG4gICAgICAgIHJpZ2h0Tm9kZS5zZXRBdHRyaWJ1dGUoXCJtYXRoY29sb3JcIiwgZ3JvdXAucmlnaHRDb2xvcik7XG4gICAgICB9XG5cbiAgICAgIGlubmVyLnB1c2gocmlnaHROb2RlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFrZVJvdyhpbm5lcik7XG4gIH1cbn0pO1xuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcIm1pZGRsZVwiLFxuICBuYW1lczogW1wiXFxcXG1pZGRsZVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIHByaW1pdGl2ZTogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiAoY29udGV4dCwgYXJncykgPT4ge1xuICAgIGNvbnN0IGRlbGltID0gY2hlY2tEZWxpbWl0ZXIoYXJnc1swXSwgY29udGV4dCk7XG5cbiAgICBpZiAoIWNvbnRleHQucGFyc2VyLmxlZnRyaWdodERlcHRoKSB7XG4gICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJcXFxcbWlkZGxlIHdpdGhvdXQgcHJlY2VkaW5nIFxcXFxsZWZ0XCIsIGRlbGltKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJtaWRkbGVcIixcbiAgICAgIG1vZGU6IGNvbnRleHQucGFyc2VyLm1vZGUsXG4gICAgICBkZWxpbTogZGVsaW0udGV4dFxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgICBsZXQgbWlkZGxlRGVsaW07XG5cbiAgICBpZiAoZ3JvdXAuZGVsaW0gPT09IFwiLlwiKSB7XG4gICAgICBtaWRkbGVEZWxpbSA9IG1ha2VOdWxsRGVsaW1pdGVyKG9wdGlvbnMsIFtdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWlkZGxlRGVsaW0gPSBkZWxpbWl0ZXIuc2l6ZWREZWxpbShncm91cC5kZWxpbSwgMSwgb3B0aW9ucywgZ3JvdXAubW9kZSwgW10pO1xuICAgICAgY29uc3QgaXNNaWRkbGUgPSB7XG4gICAgICAgIGRlbGltOiBncm91cC5kZWxpbSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfTsgLy8gUHJvcGVydHkgYGlzTWlkZGxlYCBub3QgZGVmaW5lZCBvbiBgc3BhbmAuIEl0IGlzIG9ubHkgdXNlZCBpblxuICAgICAgLy8gdGhpcyBmaWxlIGFib3ZlLlxuICAgICAgLy8gVE9ETzogRml4IHRoaXMgdmlvbGF0aW9uIG9mIHRoZSBgc3BhbmAgdHlwZSBhbmQgcG9zc2libHkgcmVuYW1lXG4gICAgICAvLyB0aGluZ3Mgc2luY2UgYGlzTWlkZGxlYCBzb3VuZHMgbGlrZSBhIGJvb2xlYW4sIGJ1dCBpcyBhIHN0cnVjdC5cbiAgICAgIC8vICRGbG93Rml4TWVcblxuICAgICAgbWlkZGxlRGVsaW0uaXNNaWRkbGUgPSBpc01pZGRsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWlkZGxlRGVsaW07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IChncm91cCwgb3B0aW9ucykgPT4ge1xuICAgIC8vIEEgRmlyZWZveCBcXG1pZGRsZSB3aWxsIHN0cmV0Y2ggYSBjaGFyYWN0ZXIgdmVydGljYWxseSBvbmx5IGlmIGl0XG4gICAgLy8gaXMgaW4gdGhlIGZlbmNlIHBhcnQgb2YgdGhlIG9wZXJhdG9yIGRpY3Rpb25hcnkgYXQ6XG4gICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL01hdGhNTDMvYXBwZW5kaXhjLmh0bWwuXG4gICAgLy8gU28gd2UgbmVlZCB0byBhdm9pZCBVKzIyMjMgYW5kIHVzZSBwbGFpbiBcInxcIiBpbnN0ZWFkLlxuICAgIGNvbnN0IHRleHROb2RlID0gZ3JvdXAuZGVsaW0gPT09IFwiXFxcXHZlcnRcIiB8fCBncm91cC5kZWxpbSA9PT0gXCJ8XCIgPyBtYWtlVGV4dChcInxcIiwgXCJ0ZXh0XCIpIDogbWFrZVRleHQoZ3JvdXAuZGVsaW0sIGdyb3VwLm1vZGUpO1xuICAgIGNvbnN0IG1pZGRsZU5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vXCIsIFt0ZXh0Tm9kZV0pO1xuICAgIG1pZGRsZU5vZGUuc2V0QXR0cmlidXRlKFwiZmVuY2VcIiwgXCJ0cnVlXCIpOyAvLyBNYXRoTUwgZ2l2ZXMgNS8xOGVtIHNwYWNpbmcgdG8gZWFjaCA8bW8+IGVsZW1lbnQuXG4gICAgLy8gXFxtaWRkbGUgc2hvdWxkIGdldCBkZWxpbWl0ZXIgc3BhY2luZyBpbnN0ZWFkLlxuXG4gICAgbWlkZGxlTm9kZS5zZXRBdHRyaWJ1dGUoXCJsc3BhY2VcIiwgXCIwLjA1ZW1cIik7XG4gICAgbWlkZGxlTm9kZS5zZXRBdHRyaWJ1dGUoXCJyc3BhY2VcIiwgXCIwLjA1ZW1cIik7XG4gICAgcmV0dXJuIG1pZGRsZU5vZGU7XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy9lbmNsb3NlLmpzXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5jb25zdCBlbmNsb3NlX2h0bWxCdWlsZGVyID0gKGdyb3VwLCBvcHRpb25zKSA9PiB7XG4gIC8vIFxcY2FuY2VsLCBcXGJjYW5jZWwsIFxceGNhbmNlbCwgXFxzb3V0LCBcXGZib3gsIFxcY29sb3Jib3gsIFxcZmNvbG9yYm94LCBcXHBoYXNlXG4gIC8vIFNvbWUgZ3JvdXBzIGNhbiByZXR1cm4gZG9jdW1lbnQgZnJhZ21lbnRzLiAgSGFuZGxlIHRob3NlIGJ5IHdyYXBwaW5nXG4gIC8vIHRoZW0gaW4gYSBzcGFuLlxuICBjb25zdCBpbm5lciA9IGJ1aWxkQ29tbW9uLndyYXBGcmFnbWVudChidWlsZEdyb3VwKGdyb3VwLmJvZHksIG9wdGlvbnMpLCBvcHRpb25zKTtcbiAgY29uc3QgbGFiZWwgPSBncm91cC5sYWJlbC5zbGljZSgxKTtcbiAgbGV0IHNjYWxlID0gb3B0aW9ucy5zaXplTXVsdGlwbGllcjtcbiAgbGV0IGltZztcbiAgbGV0IGltZ1NoaWZ0ID0gMDsgLy8gSW4gdGhlIExhVGVYIGNhbmNlbCBwYWNrYWdlLCBsaW5lIGdlb21ldHJ5IGlzIHNsaWdodGx5IGRpZmZlcmVudFxuICAvLyBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgc3ViamVjdCBpcyB3aWRlciB0aGFuIGl0IGlzIHRhbGwsIG9yIHZpY2UgdmVyc2EuXG4gIC8vIFdlIGRvbid0IGtub3cgdGhlIHdpZHRoIG9mIGEgZ3JvdXAsIHNvIGFzIGEgcHJveHksIHdlIHRlc3QgaWZcbiAgLy8gdGhlIHN1YmplY3QgaXMgYSBzaW5nbGUgY2hhcmFjdGVyLiBUaGlzIGNhcHR1cmVzIG1vc3Qgb2YgdGhlXG4gIC8vIHN1YmplY3RzIHRoYXQgc2hvdWxkIGdldCB0aGUgXCJ0YWxsXCIgdHJlYXRtZW50LlxuXG4gIGNvbnN0IGlzU2luZ2xlQ2hhciA9IHV0aWxzLmlzQ2hhcmFjdGVyQm94KGdyb3VwLmJvZHkpO1xuXG4gIGlmIChsYWJlbCA9PT0gXCJzb3V0XCIpIHtcbiAgICBpbWcgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJzdHJldGNoeVwiLCBcInNvdXRcIl0pO1xuICAgIGltZy5oZWlnaHQgPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkuZGVmYXVsdFJ1bGVUaGlja25lc3MgLyBzY2FsZTtcbiAgICBpbWdTaGlmdCA9IC0wLjUgKiBvcHRpb25zLmZvbnRNZXRyaWNzKCkueEhlaWdodDtcbiAgfSBlbHNlIGlmIChsYWJlbCA9PT0gXCJwaGFzZVwiKSB7XG4gICAgLy8gU2V0IGEgY291cGxlIG9mIGRpbWVuc2lvbnMgZnJvbSB0aGUgc3RlaW5tZXR6IHBhY2thZ2UuXG4gICAgY29uc3QgbGluZVdlaWdodCA9IGNhbGN1bGF0ZVNpemUoe1xuICAgICAgbnVtYmVyOiAwLjYsXG4gICAgICB1bml0OiBcInB0XCJcbiAgICB9LCBvcHRpb25zKTtcbiAgICBjb25zdCBjbGVhcmFuY2UgPSBjYWxjdWxhdGVTaXplKHtcbiAgICAgIG51bWJlcjogMC4zNSxcbiAgICAgIHVuaXQ6IFwiZXhcIlxuICAgIH0sIG9wdGlvbnMpOyAvLyBQcmV2ZW50IHNpemUgY2hhbmdlcyBsaWtlIFxcSHVnZSBmcm9tIGFmZmVjdGluZyBsaW5lIHRoaWNrbmVzc1xuXG4gICAgY29uc3QgbmV3T3B0aW9ucyA9IG9wdGlvbnMuaGF2aW5nQmFzZVNpemluZygpO1xuICAgIHNjYWxlID0gc2NhbGUgLyBuZXdPcHRpb25zLnNpemVNdWx0aXBsaWVyO1xuICAgIGNvbnN0IGFuZ2xlSGVpZ2h0ID0gaW5uZXIuaGVpZ2h0ICsgaW5uZXIuZGVwdGggKyBsaW5lV2VpZ2h0ICsgY2xlYXJhbmNlOyAvLyBSZXNlcnZlIGEgbGVmdCBwYWQgZm9yIHRoZSBhbmdsZS5cblxuICAgIGlubmVyLnN0eWxlLnBhZGRpbmdMZWZ0ID0gbWFrZUVtKGFuZ2xlSGVpZ2h0IC8gMiArIGxpbmVXZWlnaHQpOyAvLyBDcmVhdGUgYW4gU1ZHXG5cbiAgICBjb25zdCB2aWV3Qm94SGVpZ2h0ID0gTWF0aC5mbG9vcigxMDAwICogYW5nbGVIZWlnaHQgKiBzY2FsZSk7XG4gICAgY29uc3QgcGF0aCA9IHBoYXNlUGF0aCh2aWV3Qm94SGVpZ2h0KTtcbiAgICBjb25zdCBzdmdOb2RlID0gbmV3IFN2Z05vZGUoW25ldyBQYXRoTm9kZShcInBoYXNlXCIsIHBhdGgpXSwge1xuICAgICAgXCJ3aWR0aFwiOiBcIjQwMGVtXCIsXG4gICAgICBcImhlaWdodFwiOiBtYWtlRW0odmlld0JveEhlaWdodCAvIDEwMDApLFxuICAgICAgXCJ2aWV3Qm94XCI6IFwiMCAwIDQwMDAwMCBcIiArIHZpZXdCb3hIZWlnaHQsXG4gICAgICBcInByZXNlcnZlQXNwZWN0UmF0aW9cIjogXCJ4TWluWU1pbiBzbGljZVwiXG4gICAgfSk7IC8vIFdyYXAgaXQgaW4gYSBzcGFuIHdpdGggb3ZlcmZsb3c6IGhpZGRlbi5cblxuICAgIGltZyA9IGJ1aWxkQ29tbW9uLm1ha2VTdmdTcGFuKFtcImhpZGUtdGFpbFwiXSwgW3N2Z05vZGVdLCBvcHRpb25zKTtcbiAgICBpbWcuc3R5bGUuaGVpZ2h0ID0gbWFrZUVtKGFuZ2xlSGVpZ2h0KTtcbiAgICBpbWdTaGlmdCA9IGlubmVyLmRlcHRoICsgbGluZVdlaWdodCArIGNsZWFyYW5jZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBBZGQgaG9yaXpvbnRhbCBwYWRkaW5nXG4gICAgaWYgKC9jYW5jZWwvLnRlc3QobGFiZWwpKSB7XG4gICAgICBpZiAoIWlzU2luZ2xlQ2hhcikge1xuICAgICAgICBpbm5lci5jbGFzc2VzLnB1c2goXCJjYW5jZWwtcGFkXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobGFiZWwgPT09IFwiYW5nbFwiKSB7XG4gICAgICBpbm5lci5jbGFzc2VzLnB1c2goXCJhbmdscGFkXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbm5lci5jbGFzc2VzLnB1c2goXCJib3hwYWRcIik7XG4gICAgfSAvLyBBZGQgdmVydGljYWwgcGFkZGluZ1xuXG5cbiAgICBsZXQgdG9wUGFkID0gMDtcbiAgICBsZXQgYm90dG9tUGFkID0gMDtcbiAgICBsZXQgcnVsZVRoaWNrbmVzcyA9IDA7IC8vIHJlZjogY2FuY2VsIHBhY2thZ2U6IFxcYWR2YW5jZVxcdG90YWxoZWlnaHQyXFxwQCAlIFwiKzJcIlxuXG4gICAgaWYgKC9ib3gvLnRlc3QobGFiZWwpKSB7XG4gICAgICBydWxlVGhpY2tuZXNzID0gTWF0aC5tYXgob3B0aW9ucy5mb250TWV0cmljcygpLmZib3hydWxlLCAvLyBkZWZhdWx0XG4gICAgICBvcHRpb25zLm1pblJ1bGVUaGlja25lc3MgLy8gVXNlciBvdmVycmlkZS5cbiAgICAgICk7XG4gICAgICB0b3BQYWQgPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkuZmJveHNlcCArIChsYWJlbCA9PT0gXCJjb2xvcmJveFwiID8gMCA6IHJ1bGVUaGlja25lc3MpO1xuICAgICAgYm90dG9tUGFkID0gdG9wUGFkO1xuICAgIH0gZWxzZSBpZiAobGFiZWwgPT09IFwiYW5nbFwiKSB7XG4gICAgICBydWxlVGhpY2tuZXNzID0gTWF0aC5tYXgob3B0aW9ucy5mb250TWV0cmljcygpLmRlZmF1bHRSdWxlVGhpY2tuZXNzLCBvcHRpb25zLm1pblJ1bGVUaGlja25lc3MpO1xuICAgICAgdG9wUGFkID0gNCAqIHJ1bGVUaGlja25lc3M7IC8vIGdhcCA9IDMgw5cgbGluZSwgcGx1cyB0aGUgbGluZSBpdHNlbGYuXG5cbiAgICAgIGJvdHRvbVBhZCA9IE1hdGgubWF4KDAsIDAuMjUgLSBpbm5lci5kZXB0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvcFBhZCA9IGlzU2luZ2xlQ2hhciA/IDAuMiA6IDA7XG4gICAgICBib3R0b21QYWQgPSB0b3BQYWQ7XG4gICAgfVxuXG4gICAgaW1nID0gc3RyZXRjaHkuZW5jbG9zZVNwYW4oaW5uZXIsIGxhYmVsLCB0b3BQYWQsIGJvdHRvbVBhZCwgb3B0aW9ucyk7XG5cbiAgICBpZiAoL2Zib3h8Ym94ZWR8ZmNvbG9yYm94Ly50ZXN0KGxhYmVsKSkge1xuICAgICAgaW1nLnN0eWxlLmJvcmRlclN0eWxlID0gXCJzb2xpZFwiO1xuICAgICAgaW1nLnN0eWxlLmJvcmRlcldpZHRoID0gbWFrZUVtKHJ1bGVUaGlja25lc3MpO1xuICAgIH0gZWxzZSBpZiAobGFiZWwgPT09IFwiYW5nbFwiICYmIHJ1bGVUaGlja25lc3MgIT09IDAuMDQ5KSB7XG4gICAgICBpbWcuc3R5bGUuYm9yZGVyVG9wV2lkdGggPSBtYWtlRW0ocnVsZVRoaWNrbmVzcyk7XG4gICAgICBpbWcuc3R5bGUuYm9yZGVyUmlnaHRXaWR0aCA9IG1ha2VFbShydWxlVGhpY2tuZXNzKTtcbiAgICB9XG5cbiAgICBpbWdTaGlmdCA9IGlubmVyLmRlcHRoICsgYm90dG9tUGFkO1xuXG4gICAgaWYgKGdyb3VwLmJhY2tncm91bmRDb2xvcikge1xuICAgICAgaW1nLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGdyb3VwLmJhY2tncm91bmRDb2xvcjtcblxuICAgICAgaWYgKGdyb3VwLmJvcmRlckNvbG9yKSB7XG4gICAgICAgIGltZy5zdHlsZS5ib3JkZXJDb2xvciA9IGdyb3VwLmJvcmRlckNvbG9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxldCB2bGlzdDtcblxuICBpZiAoZ3JvdXAuYmFja2dyb3VuZENvbG9yKSB7XG4gICAgdmxpc3QgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgcG9zaXRpb25UeXBlOiBcImluZGl2aWR1YWxTaGlmdFwiLFxuICAgICAgY2hpbGRyZW46IFsvLyBQdXQgdGhlIGNvbG9yIGJhY2tncm91bmQgYmVoaW5kIGlubmVyO1xuICAgICAge1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogaW1nLFxuICAgICAgICBzaGlmdDogaW1nU2hpZnRcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IGlubmVyLFxuICAgICAgICBzaGlmdDogMFxuICAgICAgfV1cbiAgICB9LCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjbGFzc2VzID0gL2NhbmNlbHxwaGFzZS8udGVzdChsYWJlbCkgPyBbXCJzdmctYWxpZ25cIl0gOiBbXTtcbiAgICB2bGlzdCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICBwb3NpdGlvblR5cGU6IFwiaW5kaXZpZHVhbFNoaWZ0XCIsXG4gICAgICBjaGlsZHJlbjogWy8vIFdyaXRlIHRoZSBcXGNhbmNlbCBzdHJva2Ugb24gdG9wIG9mIGlubmVyLlxuICAgICAge1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogaW5uZXIsXG4gICAgICAgIHNoaWZ0OiAwXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBpbWcsXG4gICAgICAgIHNoaWZ0OiBpbWdTaGlmdCxcbiAgICAgICAgd3JhcHBlckNsYXNzZXM6IGNsYXNzZXNcbiAgICAgIH1dXG4gICAgfSwgb3B0aW9ucyk7XG4gIH1cblxuICBpZiAoL2NhbmNlbC8udGVzdChsYWJlbCkpIHtcbiAgICAvLyBUaGUgY2FuY2VsIHBhY2thZ2UgZG9jdW1lbnRhdGlvbiBzYXlzIHRoYXQgY2FuY2VsIGxpbmVzIGFkZCB0aGVpciBoZWlnaHRcbiAgICAvLyB0byB0aGUgZXhwcmVzc2lvbiwgYnV0IHRlc3RzIHNob3cgdGhhdCBpc24ndCBob3cgaXQgYWN0dWFsbHkgd29ya3MuXG4gICAgdmxpc3QuaGVpZ2h0ID0gaW5uZXIuaGVpZ2h0O1xuICAgIHZsaXN0LmRlcHRoID0gaW5uZXIuZGVwdGg7XG4gIH1cblxuICBpZiAoL2NhbmNlbC8udGVzdChsYWJlbCkgJiYgIWlzU2luZ2xlQ2hhcikge1xuICAgIC8vIGNhbmNlbCBkb2VzIG5vdCBjcmVhdGUgaG9yaXogc3BhY2UgZm9yIGl0cyBsaW5lIGV4dGVuc2lvbi5cbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibW9yZFwiLCBcImNhbmNlbC1sYXBcIl0sIFt2bGlzdF0sIG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtb3JkXCJdLCBbdmxpc3RdLCBvcHRpb25zKTtcbiAgfVxufTtcblxuY29uc3QgZW5jbG9zZV9tYXRobWxCdWlsZGVyID0gKGdyb3VwLCBvcHRpb25zKSA9PiB7XG4gIGxldCBmYm94c2VwID0gMDtcbiAgY29uc3Qgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKGdyb3VwLmxhYmVsLmluZGV4T2YoXCJjb2xvcmJveFwiKSA+IC0xID8gXCJtcGFkZGVkXCIgOiBcIm1lbmNsb3NlXCIsIFtidWlsZE1hdGhNTF9idWlsZEdyb3VwKGdyb3VwLmJvZHksIG9wdGlvbnMpXSk7XG5cbiAgc3dpdGNoIChncm91cC5sYWJlbCkge1xuICAgIGNhc2UgXCJcXFxcY2FuY2VsXCI6XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcIm5vdGF0aW9uXCIsIFwidXBkaWFnb25hbHN0cmlrZVwiKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcIlxcXFxiY2FuY2VsXCI6XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcIm5vdGF0aW9uXCIsIFwiZG93bmRpYWdvbmFsc3RyaWtlXCIpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwiXFxcXHBoYXNlXCI6XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcIm5vdGF0aW9uXCIsIFwicGhhc29yYW5nbGVcIik7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJcXFxcc291dFwiOlxuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJub3RhdGlvblwiLCBcImhvcml6b250YWxzdHJpa2VcIik7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJcXFxcZmJveFwiOlxuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJub3RhdGlvblwiLCBcImJveFwiKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcIlxcXFxhbmdsXCI6XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcIm5vdGF0aW9uXCIsIFwiYWN0dWFyaWFsXCIpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwiXFxcXGZjb2xvcmJveFwiOlxuICAgIGNhc2UgXCJcXFxcY29sb3Jib3hcIjpcbiAgICAgIC8vIDxtZW5jbG9zZT4gZG9lc24ndCBoYXZlIGEgZ29vZCBub3RhdGlvbiBvcHRpb24uIFNvIHVzZSA8bXBhZGRlZD5cbiAgICAgIC8vIGluc3RlYWQuIFNldCBzb21lIGF0dHJpYnV0ZXMgdGhhdCBjb21lIGluY2x1ZGVkIHdpdGggPG1lbmNsb3NlPi5cbiAgICAgIGZib3hzZXAgPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkuZmJveHNlcCAqIG9wdGlvbnMuZm9udE1ldHJpY3MoKS5wdFBlckVtO1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIitcIiArIDIgKiBmYm94c2VwICsgXCJwdFwiKTtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIFwiK1wiICsgMiAqIGZib3hzZXAgKyBcInB0XCIpO1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJsc3BhY2VcIiwgZmJveHNlcCArIFwicHRcIik7IC8vXG5cbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwidm9mZnNldFwiLCBmYm94c2VwICsgXCJwdFwiKTtcblxuICAgICAgaWYgKGdyb3VwLmxhYmVsID09PSBcIlxcXFxmY29sb3Jib3hcIikge1xuICAgICAgICBjb25zdCB0aGsgPSBNYXRoLm1heChvcHRpb25zLmZvbnRNZXRyaWNzKCkuZmJveHJ1bGUsIC8vIGRlZmF1bHRcbiAgICAgICAgb3B0aW9ucy5taW5SdWxlVGhpY2tuZXNzIC8vIHVzZXIgb3ZlcnJpZGVcbiAgICAgICAgKTtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcImJvcmRlcjogXCIgKyB0aGsgKyBcImVtIHNvbGlkIFwiICsgU3RyaW5nKGdyb3VwLmJvcmRlckNvbG9yKSk7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcIlxcXFx4Y2FuY2VsXCI6XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcIm5vdGF0aW9uXCIsIFwidXBkaWFnb25hbHN0cmlrZSBkb3duZGlhZ29uYWxzdHJpa2VcIik7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIGlmIChncm91cC5iYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcIm1hdGhiYWNrZ3JvdW5kXCIsIGdyb3VwLmJhY2tncm91bmRDb2xvcik7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn07XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJlbmNsb3NlXCIsXG4gIG5hbWVzOiBbXCJcXFxcY29sb3Jib3hcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMixcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlLFxuICAgIGFyZ1R5cGVzOiBbXCJjb2xvclwiLCBcInRleHRcIl1cbiAgfSxcblxuICBoYW5kbGVyKF9yZWYsIGFyZ3MsIG9wdEFyZ3MpIHtcbiAgICBsZXQge1xuICAgICAgcGFyc2VyLFxuICAgICAgZnVuY05hbWVcbiAgICB9ID0gX3JlZjtcbiAgICBjb25zdCBjb2xvciA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwiY29sb3ItdG9rZW5cIikuY29sb3I7XG4gICAgY29uc3QgYm9keSA9IGFyZ3NbMV07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZW5jbG9zZVwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBsYWJlbDogZnVuY05hbWUsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IGNvbG9yLFxuICAgICAgYm9keVxuICAgIH07XG4gIH0sXG5cbiAgaHRtbEJ1aWxkZXI6IGVuY2xvc2VfaHRtbEJ1aWxkZXIsXG4gIG1hdGhtbEJ1aWxkZXI6IGVuY2xvc2VfbWF0aG1sQnVpbGRlclxufSk7XG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiZW5jbG9zZVwiLFxuICBuYW1lczogW1wiXFxcXGZjb2xvcmJveFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAzLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWUsXG4gICAgYXJnVHlwZXM6IFtcImNvbG9yXCIsIFwiY29sb3JcIiwgXCJ0ZXh0XCJdXG4gIH0sXG5cbiAgaGFuZGxlcihfcmVmMiwgYXJncywgb3B0QXJncykge1xuICAgIGxldCB7XG4gICAgICBwYXJzZXIsXG4gICAgICBmdW5jTmFtZVxuICAgIH0gPSBfcmVmMjtcbiAgICBjb25zdCBib3JkZXJDb2xvciA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwiY29sb3ItdG9rZW5cIikuY29sb3I7XG4gICAgY29uc3QgYmFja2dyb3VuZENvbG9yID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1sxXSwgXCJjb2xvci10b2tlblwiKS5jb2xvcjtcbiAgICBjb25zdCBib2R5ID0gYXJnc1syXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJlbmNsb3NlXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGxhYmVsOiBmdW5jTmFtZSxcbiAgICAgIGJhY2tncm91bmRDb2xvcixcbiAgICAgIGJvcmRlckNvbG9yLFxuICAgICAgYm9keVxuICAgIH07XG4gIH0sXG5cbiAgaHRtbEJ1aWxkZXI6IGVuY2xvc2VfaHRtbEJ1aWxkZXIsXG4gIG1hdGhtbEJ1aWxkZXI6IGVuY2xvc2VfbWF0aG1sQnVpbGRlclxufSk7XG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiZW5jbG9zZVwiLFxuICBuYW1lczogW1wiXFxcXGZib3hcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhcmdUeXBlczogW1wiaGJveFwiXSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG5cbiAgaGFuZGxlcihfcmVmMywgYXJncykge1xuICAgIGxldCB7XG4gICAgICBwYXJzZXJcbiAgICB9ID0gX3JlZjM7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZW5jbG9zZVwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBsYWJlbDogXCJcXFxcZmJveFwiLFxuICAgICAgYm9keTogYXJnc1swXVxuICAgIH07XG4gIH1cblxufSk7XG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiZW5jbG9zZVwiLFxuICBuYW1lczogW1wiXFxcXGNhbmNlbFwiLCBcIlxcXFxiY2FuY2VsXCIsIFwiXFxcXHhjYW5jZWxcIiwgXCJcXFxcc291dFwiLCBcIlxcXFxwaGFzZVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxXG4gIH0sXG5cbiAgaGFuZGxlcihfcmVmNCwgYXJncykge1xuICAgIGxldCB7XG4gICAgICBwYXJzZXIsXG4gICAgICBmdW5jTmFtZVxuICAgIH0gPSBfcmVmNDtcbiAgICBjb25zdCBib2R5ID0gYXJnc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJlbmNsb3NlXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGxhYmVsOiBmdW5jTmFtZSxcbiAgICAgIGJvZHlcbiAgICB9O1xuICB9LFxuXG4gIGh0bWxCdWlsZGVyOiBlbmNsb3NlX2h0bWxCdWlsZGVyLFxuICBtYXRobWxCdWlsZGVyOiBlbmNsb3NlX21hdGhtbEJ1aWxkZXJcbn0pO1xuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImVuY2xvc2VcIixcbiAgbmFtZXM6IFtcIlxcXFxhbmdsXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYXJnVHlwZXM6IFtcImhib3hcIl0sXG4gICAgYWxsb3dlZEluVGV4dDogZmFsc2VcbiAgfSxcblxuICBoYW5kbGVyKF9yZWY1LCBhcmdzKSB7XG4gICAgbGV0IHtcbiAgICAgIHBhcnNlclxuICAgIH0gPSBfcmVmNTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJlbmNsb3NlXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGxhYmVsOiBcIlxcXFxhbmdsXCIsXG4gICAgICBib2R5OiBhcmdzWzBdXG4gICAgfTtcbiAgfVxuXG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9kZWZpbmVFbnZpcm9ubWVudC5qc1xuXG5cbi8qKlxuICogQWxsIHJlZ2lzdGVyZWQgZW52aXJvbm1lbnRzLlxuICogYGVudmlyb25tZW50cy5qc2AgZXhwb3J0cyB0aGlzIHNhbWUgZGljdGlvbmFyeSBhZ2FpbiBhbmQgbWFrZXMgaXQgcHVibGljLlxuICogYFBhcnNlci5qc2AgcmVxdWlyZXMgdGhpcyBkaWN0aW9uYXJ5IHZpYSBgZW52aXJvbm1lbnRzLmpzYC5cbiAqL1xuY29uc3QgX2Vudmlyb25tZW50cyA9IHt9O1xuZnVuY3Rpb24gZGVmaW5lRW52aXJvbm1lbnQoX3JlZikge1xuICBsZXQge1xuICAgIHR5cGUsXG4gICAgbmFtZXMsXG4gICAgcHJvcHMsXG4gICAgaGFuZGxlcixcbiAgICBodG1sQnVpbGRlcixcbiAgICBtYXRobWxCdWlsZGVyXG4gIH0gPSBfcmVmO1xuICAvLyBTZXQgZGVmYXVsdCB2YWx1ZXMgb2YgZW52aXJvbm1lbnRzLlxuICBjb25zdCBkYXRhID0ge1xuICAgIHR5cGUsXG4gICAgbnVtQXJnczogcHJvcHMubnVtQXJncyB8fCAwLFxuICAgIGFsbG93ZWRJblRleHQ6IGZhbHNlLFxuICAgIG51bU9wdGlvbmFsQXJnczogMCxcbiAgICBoYW5kbGVyXG4gIH07XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7ICsraSkge1xuICAgIC8vIFRPRE86IFRoZSB2YWx1ZSB0eXBlIG9mIF9lbnZpcm9ubWVudHMgc2hvdWxkIGJlIGEgdHlwZSB1bmlvbiBvZiBhbGxcbiAgICAvLyBwb3NzaWJsZSBgRW52U3BlYzw+YCBwb3NzaWJpbGl0aWVzIGluc3RlYWQgb2YgYEVudlNwZWM8Kj5gLCB3aGljaCBpc1xuICAgIC8vIGFuIGV4aXN0ZW50aWFsIHR5cGUuXG4gICAgX2Vudmlyb25tZW50c1tuYW1lc1tpXV0gPSBkYXRhO1xuICB9XG5cbiAgaWYgKGh0bWxCdWlsZGVyKSB7XG4gICAgX2h0bWxHcm91cEJ1aWxkZXJzW3R5cGVdID0gaHRtbEJ1aWxkZXI7XG4gIH1cblxuICBpZiAobWF0aG1sQnVpbGRlcikge1xuICAgIF9tYXRobWxHcm91cEJ1aWxkZXJzW3R5cGVdID0gbWF0aG1sQnVpbGRlcjtcbiAgfVxufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2RlZmluZU1hY3JvLmpzXG5cblxuLyoqXG4gKiBBbGwgcmVnaXN0ZXJlZCBnbG9iYWwvYnVpbHQtaW4gbWFjcm9zLlxuICogYG1hY3Jvcy5qc2AgZXhwb3J0cyB0aGlzIHNhbWUgZGljdGlvbmFyeSBhZ2FpbiBhbmQgbWFrZXMgaXQgcHVibGljLlxuICogYFBhcnNlci5qc2AgcmVxdWlyZXMgdGhpcyBkaWN0aW9uYXJ5IHZpYSBgbWFjcm9zLmpzYC5cbiAqL1xuY29uc3QgX21hY3JvcyA9IHt9OyAvLyBUaGlzIGZ1bmN0aW9uIG1pZ2h0IG9uZSBkYXkgYWNjZXB0IGFuIGFkZGl0aW9uYWwgYXJndW1lbnQgYW5kIGRvIG1vcmUgdGhpbmdzLlxuXG5mdW5jdGlvbiBkZWZpbmVNYWNybyhuYW1lLCBib2R5KSB7XG4gIF9tYWNyb3NbbmFtZV0gPSBib2R5O1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL1NvdXJjZUxvY2F0aW9uLmpzXG4vKipcbiAqIExleGluZyBvciBwYXJzaW5nIHBvc2l0aW9uYWwgaW5mb3JtYXRpb24gZm9yIGVycm9yIHJlcG9ydGluZy5cbiAqIFRoaXMgb2JqZWN0IGlzIGltbXV0YWJsZS5cbiAqL1xuY2xhc3MgU291cmNlTG9jYXRpb24ge1xuICAvLyBUaGUgKyBwcmVmaXggaW5kaWNhdGVzIHRoYXQgdGhlc2UgZmllbGRzIGFyZW4ndCB3cml0ZWFibGVcbiAgLy8gTGV4ZXIgaG9sZGluZyB0aGUgaW5wdXQgc3RyaW5nLlxuICAvLyBTdGFydCBvZmZzZXQsIHplcm8tYmFzZWQgaW5jbHVzaXZlLlxuICAvLyBFbmQgb2Zmc2V0LCB6ZXJvLWJhc2VkIGV4Y2x1c2l2ZS5cbiAgY29uc3RydWN0b3IobGV4ZXIsIHN0YXJ0LCBlbmQpIHtcbiAgICB0aGlzLmxleGVyID0gdm9pZCAwO1xuICAgIHRoaXMuc3RhcnQgPSB2b2lkIDA7XG4gICAgdGhpcy5lbmQgPSB2b2lkIDA7XG4gICAgdGhpcy5sZXhlciA9IGxleGVyO1xuICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICB0aGlzLmVuZCA9IGVuZDtcbiAgfVxuICAvKipcbiAgICogTWVyZ2VzIHR3byBgU291cmNlTG9jYXRpb25gcyBmcm9tIGxvY2F0aW9uIHByb3ZpZGVycywgZ2l2ZW4gdGhleSBhcmVcbiAgICogcHJvdmlkZWQgaW4gb3JkZXIgb2YgYXBwZWFyYW5jZS5cbiAgICogLSBSZXR1cm5zIHRoZSBmaXJzdCBvbmUncyBsb2NhdGlvbiBpZiBvbmx5IHRoZSBmaXJzdCBpcyBwcm92aWRlZC5cbiAgICogLSBSZXR1cm5zIGEgbWVyZ2VkIHJhbmdlIG9mIHRoZSBmaXJzdCBhbmQgdGhlIGxhc3QgaWYgYm90aCBhcmUgcHJvdmlkZWRcbiAgICogICBhbmQgdGhlaXIgbGV4ZXJzIG1hdGNoLlxuICAgKiAtIE90aGVyd2lzZSwgcmV0dXJucyBudWxsLlxuICAgKi9cblxuXG4gIHN0YXRpYyByYW5nZShmaXJzdCwgc2Vjb25kKSB7XG4gICAgaWYgKCFzZWNvbmQpIHtcbiAgICAgIHJldHVybiBmaXJzdCAmJiBmaXJzdC5sb2M7XG4gICAgfSBlbHNlIGlmICghZmlyc3QgfHwgIWZpcnN0LmxvYyB8fCAhc2Vjb25kLmxvYyB8fCBmaXJzdC5sb2MubGV4ZXIgIT09IHNlY29uZC5sb2MubGV4ZXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFNvdXJjZUxvY2F0aW9uKGZpcnN0LmxvYy5sZXhlciwgZmlyc3QubG9jLnN0YXJ0LCBzZWNvbmQubG9jLmVuZCk7XG4gICAgfVxuICB9XG5cbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9Ub2tlbi5qc1xuXG4vKipcbiAqIEludGVyZmFjZSByZXF1aXJlZCB0byBicmVhayBjaXJjdWxhciBkZXBlbmRlbmN5IGJldHdlZW4gVG9rZW4sIExleGVyLCBhbmRcbiAqIFBhcnNlRXJyb3IuXG4gKi9cblxuLyoqXG4gKiBUaGUgcmVzdWx0aW5nIHRva2VuIHJldHVybmVkIGZyb20gYGxleGAuXG4gKlxuICogSXQgY29uc2lzdHMgb2YgdGhlIHRva2VuIHRleHQgcGx1cyBzb21lIHBvc2l0aW9uIGluZm9ybWF0aW9uLlxuICogVGhlIHBvc2l0aW9uIGluZm9ybWF0aW9uIGlzIGVzc2VudGlhbGx5IGEgcmFuZ2UgaW4gYW4gaW5wdXQgc3RyaW5nLFxuICogYnV0IGluc3RlYWQgb2YgcmVmZXJlbmNpbmcgdGhlIGJhcmUgaW5wdXQgc3RyaW5nLCB3ZSByZWZlciB0byB0aGUgbGV4ZXIuXG4gKiBUaGF0IHdheSBpdCBpcyBwb3NzaWJsZSB0byBhdHRhY2ggZXh0cmEgbWV0YWRhdGEgdG8gdGhlIGlucHV0IHN0cmluZyxcbiAqIGxpa2UgZm9yIGV4YW1wbGUgYSBmaWxlIG5hbWUgb3Igc2ltaWxhci5cbiAqXG4gKiBUaGUgcG9zaXRpb24gaW5mb3JtYXRpb24gaXMgb3B0aW9uYWwsIHNvIGl0IGlzIE9LIHRvIGNvbnN0cnVjdCBzeW50aGV0aWNcbiAqIHRva2VucyBpZiBhcHByb3ByaWF0ZS4gTm90IHByb3ZpZGluZyBhdmFpbGFibGUgcG9zaXRpb24gaW5mb3JtYXRpb24gbWF5XG4gKiBsZWFkIHRvIGRlZ3JhZGVkIGVycm9yIHJlcG9ydGluZywgdGhvdWdoLlxuICovXG5jbGFzcyBUb2tlbiB7XG4gIC8vIGRvbid0IGV4cGFuZCB0aGUgdG9rZW5cbiAgLy8gdXNlZCBpbiBcXG5vZXhwYW5kXG4gIGNvbnN0cnVjdG9yKHRleHQsIC8vIHRoZSB0ZXh0IG9mIHRoaXMgdG9rZW5cbiAgbG9jKSB7XG4gICAgdGhpcy50ZXh0ID0gdm9pZCAwO1xuICAgIHRoaXMubG9jID0gdm9pZCAwO1xuICAgIHRoaXMubm9leHBhbmQgPSB2b2lkIDA7XG4gICAgdGhpcy50cmVhdEFzUmVsYXggPSB2b2lkIDA7XG4gICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICB0aGlzLmxvYyA9IGxvYztcbiAgfVxuICAvKipcbiAgICogR2l2ZW4gYSBwYWlyIG9mIHRva2VucyAodGhpcyBhbmQgZW5kVG9rZW4pLCBjb21wdXRlIGEgYFRva2VuYCBlbmNvbXBhc3NpbmdcbiAgICogdGhlIHdob2xlIGlucHV0IHJhbmdlIGVuY2xvc2VkIGJ5IHRoZXNlIHR3by5cbiAgICovXG5cblxuICByYW5nZShlbmRUb2tlbiwgLy8gbGFzdCB0b2tlbiBvZiB0aGUgcmFuZ2UsIGluY2x1c2l2ZVxuICB0ZXh0IC8vIHRoZSB0ZXh0IG9mIHRoZSBuZXdseSBjb25zdHJ1Y3RlZCB0b2tlblxuICApIHtcbiAgICByZXR1cm4gbmV3IFRva2VuKHRleHQsIFNvdXJjZUxvY2F0aW9uLnJhbmdlKHRoaXMsIGVuZFRva2VuKSk7XG4gIH1cblxufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Vudmlyb25tZW50cy9hcnJheS5qc1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG4vLyBIZWxwZXIgZnVuY3Rpb25zXG5mdW5jdGlvbiBnZXRITGluZXMocGFyc2VyKSB7XG4gIC8vIFJldHVybiBhbiBhcnJheS4gVGhlIGFycmF5IGxlbmd0aCA9IG51bWJlciBvZiBobGluZXMuXG4gIC8vIEVhY2ggZWxlbWVudCBpbiB0aGUgYXJyYXkgdGVsbHMgaWYgdGhlIGxpbmUgaXMgZGFzaGVkLlxuICBjb25zdCBobGluZUluZm8gPSBbXTtcbiAgcGFyc2VyLmNvbnN1bWVTcGFjZXMoKTtcbiAgbGV0IG54dCA9IHBhcnNlci5mZXRjaCgpLnRleHQ7XG5cbiAgaWYgKG54dCA9PT0gXCJcXFxccmVsYXhcIikge1xuICAgIC8vIFxccmVsYXggaXMgYW4gYXJ0aWZhY3Qgb2YgdGhlIFxcY3IgbWFjcm8gYmVsb3dcbiAgICBwYXJzZXIuY29uc3VtZSgpO1xuICAgIHBhcnNlci5jb25zdW1lU3BhY2VzKCk7XG4gICAgbnh0ID0gcGFyc2VyLmZldGNoKCkudGV4dDtcbiAgfVxuXG4gIHdoaWxlIChueHQgPT09IFwiXFxcXGhsaW5lXCIgfHwgbnh0ID09PSBcIlxcXFxoZGFzaGxpbmVcIikge1xuICAgIHBhcnNlci5jb25zdW1lKCk7XG4gICAgaGxpbmVJbmZvLnB1c2gobnh0ID09PSBcIlxcXFxoZGFzaGxpbmVcIik7XG4gICAgcGFyc2VyLmNvbnN1bWVTcGFjZXMoKTtcbiAgICBueHQgPSBwYXJzZXIuZmV0Y2goKS50ZXh0O1xuICB9XG5cbiAgcmV0dXJuIGhsaW5lSW5mbztcbn1cblxuY29uc3QgdmFsaWRhdGVBbXNFbnZpcm9ubWVudENvbnRleHQgPSBjb250ZXh0ID0+IHtcbiAgY29uc3Qgc2V0dGluZ3MgPSBjb250ZXh0LnBhcnNlci5zZXR0aW5ncztcblxuICBpZiAoIXNldHRpbmdzLmRpc3BsYXlNb2RlKSB7XG4gICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwie1wiICsgY29udGV4dC5lbnZOYW1lICsgXCJ9IGNhbiBiZSB1c2VkIG9ubHkgaW5cIiArIFwiIGRpc3BsYXkgbW9kZS5cIik7XG4gIH1cbn07IC8vIGF1dG9UYWcgKGFuIGFyZ3VtZW50IHRvIHBhcnNlQXJyYXkpIGNhbiBiZSBvbmUgb2YgdGhyZWUgdmFsdWVzOlxuLy8gKiB1bmRlZmluZWQ6IFJlZ3VsYXIgKG5vdC10b3AtbGV2ZWwpIGFycmF5OyBubyB0YWdzIG9uIGVhY2ggcm93XG4vLyAqIHRydWU6IEF1dG9tYXRpYyBlcXVhdGlvbiBudW1iZXJpbmcsIG92ZXJyaWRhYmxlIGJ5IFxcdGFnXG4vLyAqIGZhbHNlOiBUYWdzIGFsbG93ZWQgb24gZWFjaCByb3csIGJ1dCBubyBhdXRvbWF0aWMgbnVtYmVyaW5nXG4vLyBUaGlzIGZ1bmN0aW9uICpkb2Vzbid0KiB3b3JrIHdpdGggdGhlIFwic3BsaXRcIiBlbnZpcm9ubWVudCBuYW1lLlxuXG5cbmZ1bmN0aW9uIGdldEF1dG9UYWcobmFtZSkge1xuICBpZiAobmFtZS5pbmRleE9mKFwiZWRcIikgPT09IC0xKSB7XG4gICAgcmV0dXJuIG5hbWUuaW5kZXhPZihcIipcIikgPT09IC0xO1xuICB9IC8vIHJldHVybiB1bmRlZmluZWQ7XG5cbn1cbi8qKlxuICogUGFyc2UgdGhlIGJvZHkgb2YgdGhlIGVudmlyb25tZW50LCB3aXRoIHJvd3MgZGVsaW1pdGVkIGJ5IFxcXFwgYW5kXG4gKiBjb2x1bW5zIGRlbGltaXRlZCBieSAmLCBhbmQgY3JlYXRlIGEgbmVzdGVkIGxpc3QgaW4gcm93LW1ham9yIG9yZGVyXG4gKiB3aXRoIG9uZSBncm91cCBwZXIgY2VsbC4gIElmIGdpdmVuIGFuIG9wdGlvbmFsIGFyZ3VtZW50IHN0eWxlXG4gKiAoXCJ0ZXh0XCIsIFwiZGlzcGxheVwiLCBldGMuKSwgdGhlbiBlYWNoIGNlbGwgaXMgY2FzdCBpbnRvIHRoYXQgc3R5bGUuXG4gKi9cblxuXG5mdW5jdGlvbiBwYXJzZUFycmF5KHBhcnNlciwgX3JlZiwgc3R5bGUpIHtcbiAgbGV0IHtcbiAgICBoc2tpcEJlZm9yZUFuZEFmdGVyLFxuICAgIGFkZEpvdCxcbiAgICBjb2xzLFxuICAgIGFycmF5c3RyZXRjaCxcbiAgICBjb2xTZXBhcmF0aW9uVHlwZSxcbiAgICBhdXRvVGFnLFxuICAgIHNpbmdsZVJvdyxcbiAgICBlbXB0eVNpbmdsZVJvdyxcbiAgICBtYXhOdW1Db2xzLFxuICAgIGxlcW5vXG4gIH0gPSBfcmVmO1xuICBwYXJzZXIuZ3VsbGV0LmJlZ2luR3JvdXAoKTtcblxuICBpZiAoIXNpbmdsZVJvdykge1xuICAgIC8vIFxcY3IgaXMgZXF1aXZhbGVudCB0byBcXFxcIHdpdGhvdXQgdGhlIG9wdGlvbmFsIHNpemUgYXJndW1lbnQgKHNlZSBiZWxvdylcbiAgICAvLyBUT0RPOiBwcm92aWRlIGhlbHBmdWwgZXJyb3Igd2hlbiBcXGNyIGlzIHVzZWQgb3V0c2lkZSBhcnJheSBlbnZpcm9ubWVudFxuICAgIHBhcnNlci5ndWxsZXQubWFjcm9zLnNldChcIlxcXFxjclwiLCBcIlxcXFxcXFxcXFxcXHJlbGF4XCIpO1xuICB9IC8vIEdldCBjdXJyZW50IGFycmF5c3RyZXRjaCBpZiBpdCdzIG5vdCBzZXQgYnkgdGhlIGVudmlyb25tZW50XG5cblxuICBpZiAoIWFycmF5c3RyZXRjaCkge1xuICAgIGNvbnN0IHN0cmV0Y2ggPSBwYXJzZXIuZ3VsbGV0LmV4cGFuZE1hY3JvQXNUZXh0KFwiXFxcXGFycmF5c3RyZXRjaFwiKTtcblxuICAgIGlmIChzdHJldGNoID09IG51bGwpIHtcbiAgICAgIC8vIERlZmF1bHQgXFxhcnJheXN0cmV0Y2ggZnJvbSBsdHRhYi5kdHhcbiAgICAgIGFycmF5c3RyZXRjaCA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFycmF5c3RyZXRjaCA9IHBhcnNlRmxvYXQoc3RyZXRjaCk7XG5cbiAgICAgIGlmICghYXJyYXlzdHJldGNoIHx8IGFycmF5c3RyZXRjaCA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiSW52YWxpZCBcXFxcYXJyYXlzdHJldGNoOiBcIiArIHN0cmV0Y2gpO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBTdGFydCBncm91cCBmb3IgZmlyc3QgY2VsbFxuXG5cbiAgcGFyc2VyLmd1bGxldC5iZWdpbkdyb3VwKCk7XG4gIGxldCByb3cgPSBbXTtcbiAgY29uc3QgYm9keSA9IFtyb3ddO1xuICBjb25zdCByb3dHYXBzID0gW107XG4gIGNvbnN0IGhMaW5lc0JlZm9yZVJvdyA9IFtdO1xuICBjb25zdCB0YWdzID0gYXV0b1RhZyAhPSBudWxsID8gW10gOiB1bmRlZmluZWQ7IC8vIGFtc21hdGggdXNlcyBcXGdsb2JhbFxcQGVxbnN3dHJ1ZSBhbmQgXFxnbG9iYWxcXEBlcW5zd2ZhbHNlIHRvIHJlcHJlc2VudFxuICAvLyB3aGV0aGVyIHRoaXMgcm93IHNob3VsZCBoYXZlIGFuIGVxdWF0aW9uIG51bWJlci4gIFNpbXVsYXRlIHRoaXMgd2l0aFxuICAvLyBhIFxcQGVxbnN3IG1hY3JvIHNldCB0byAxIG9yIDAuXG5cbiAgZnVuY3Rpb24gYmVnaW5Sb3coKSB7XG4gICAgaWYgKGF1dG9UYWcpIHtcbiAgICAgIHBhcnNlci5ndWxsZXQubWFjcm9zLnNldChcIlxcXFxAZXFuc3dcIiwgXCIxXCIsIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVuZFJvdygpIHtcbiAgICBpZiAodGFncykge1xuICAgICAgaWYgKHBhcnNlci5ndWxsZXQubWFjcm9zLmdldChcIlxcXFxkZkB0YWdcIikpIHtcbiAgICAgICAgdGFncy5wdXNoKHBhcnNlci5zdWJwYXJzZShbbmV3IFRva2VuKFwiXFxcXGRmQHRhZ1wiKV0pKTtcbiAgICAgICAgcGFyc2VyLmd1bGxldC5tYWNyb3Muc2V0KFwiXFxcXGRmQHRhZ1wiLCB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFncy5wdXNoKEJvb2xlYW4oYXV0b1RhZykgJiYgcGFyc2VyLmd1bGxldC5tYWNyb3MuZ2V0KFwiXFxcXEBlcW5zd1wiKSA9PT0gXCIxXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGJlZ2luUm93KCk7IC8vIFRlc3QgZm9yIFxcaGxpbmUgYXQgdGhlIHRvcCBvZiB0aGUgYXJyYXkuXG5cbiAgaExpbmVzQmVmb3JlUm93LnB1c2goZ2V0SExpbmVzKHBhcnNlcikpO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICAvLyBQYXJzZSBlYWNoIGNlbGwgaW4gaXRzIG93biBncm91cCAobmFtZXNwYWNlKVxuICAgIGxldCBjZWxsID0gcGFyc2VyLnBhcnNlRXhwcmVzc2lvbihmYWxzZSwgc2luZ2xlUm93ID8gXCJcXFxcZW5kXCIgOiBcIlxcXFxcXFxcXCIpO1xuICAgIHBhcnNlci5ndWxsZXQuZW5kR3JvdXAoKTtcbiAgICBwYXJzZXIuZ3VsbGV0LmJlZ2luR3JvdXAoKTtcbiAgICBjZWxsID0ge1xuICAgICAgdHlwZTogXCJvcmRncm91cFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBib2R5OiBjZWxsXG4gICAgfTtcblxuICAgIGlmIChzdHlsZSkge1xuICAgICAgY2VsbCA9IHtcbiAgICAgICAgdHlwZTogXCJzdHlsaW5nXCIsXG4gICAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgICBzdHlsZSxcbiAgICAgICAgYm9keTogW2NlbGxdXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJvdy5wdXNoKGNlbGwpO1xuICAgIGNvbnN0IG5leHQgPSBwYXJzZXIuZmV0Y2goKS50ZXh0O1xuXG4gICAgaWYgKG5leHQgPT09IFwiJlwiKSB7XG4gICAgICBpZiAobWF4TnVtQ29scyAmJiByb3cubGVuZ3RoID09PSBtYXhOdW1Db2xzKSB7XG4gICAgICAgIGlmIChzaW5nbGVSb3cgfHwgY29sU2VwYXJhdGlvblR5cGUpIHtcbiAgICAgICAgICAvLyB7ZXF1YXRpb259IG9yIHtzcGxpdH1cbiAgICAgICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJUb28gbWFueSB0YWIgY2hhcmFjdGVyczogJlwiLCBwYXJzZXIubmV4dFRva2VuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB7YXJyYXl9IGVudmlyb25tZW50XG4gICAgICAgICAgcGFyc2VyLnNldHRpbmdzLnJlcG9ydE5vbnN0cmljdChcInRleHRFbnZcIiwgXCJUb28gZmV3IGNvbHVtbnMgXCIgKyBcInNwZWNpZmllZCBpbiB0aGUge2FycmF5fSBjb2x1bW4gYXJndW1lbnQuXCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHBhcnNlci5jb25zdW1lKCk7XG4gICAgfSBlbHNlIGlmIChuZXh0ID09PSBcIlxcXFxlbmRcIikge1xuICAgICAgZW5kUm93KCk7IC8vIEFycmF5cyB0ZXJtaW5hdGUgbmV3bGluZXMgd2l0aCBgXFxjcmNyYCB3aGljaCBjb25zdW1lcyBhIGBcXGNyYCBpZlxuICAgICAgLy8gdGhlIGxhc3QgbGluZSBpcyBlbXB0eS4gIEhvd2V2ZXIsIEFNUyBlbnZpcm9ubWVudHMga2VlcCB0aGVcbiAgICAgIC8vIGVtcHR5IHJvdyBpZiBpdCdzIHRoZSBvbmx5IG9uZS5cbiAgICAgIC8vIE5PVEU6IEN1cnJlbnRseSwgYGNlbGxgIGlzIHRoZSBsYXN0IGl0ZW0gYWRkZWQgaW50byBgcm93YC5cblxuICAgICAgaWYgKHJvdy5sZW5ndGggPT09IDEgJiYgY2VsbC50eXBlID09PSBcInN0eWxpbmdcIiAmJiBjZWxsLmJvZHlbMF0uYm9keS5sZW5ndGggPT09IDAgJiYgKGJvZHkubGVuZ3RoID4gMSB8fCAhZW1wdHlTaW5nbGVSb3cpKSB7XG4gICAgICAgIGJvZHkucG9wKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChoTGluZXNCZWZvcmVSb3cubGVuZ3RoIDwgYm9keS5sZW5ndGggKyAxKSB7XG4gICAgICAgIGhMaW5lc0JlZm9yZVJvdy5wdXNoKFtdKTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIGlmIChuZXh0ID09PSBcIlxcXFxcXFxcXCIpIHtcbiAgICAgIHBhcnNlci5jb25zdW1lKCk7XG4gICAgICBsZXQgc2l6ZTsgLy8gXFxkZWZcXExldEB7XFxsZXRcXFxcXFxtYXRoQGNyfVxuICAgICAgLy8gXFxkZWZcXG1hdGhAY3J7Li4uXFxtYXRoQGNyQH1cbiAgICAgIC8vIFxcZGVmXFxtYXRoQGNyQHtcXG5ld0BpZm5leHRjaGFyW1xcbWF0aEBjckBAe1xcbWF0aEBjckBAW1xcekBdfX1cbiAgICAgIC8vIFxcZGVmXFxtYXRoQGNyQEBbIzFdey4uLlxcbWF0aEBjckBAQC4uLn1cbiAgICAgIC8vIFxcZGVmXFxtYXRoQGNyQEBAe1xcY3J9XG5cbiAgICAgIGlmIChwYXJzZXIuZ3VsbGV0LmZ1dHVyZSgpLnRleHQgIT09IFwiIFwiKSB7XG4gICAgICAgIHNpemUgPSBwYXJzZXIucGFyc2VTaXplR3JvdXAodHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJvd0dhcHMucHVzaChzaXplID8gc2l6ZS52YWx1ZSA6IG51bGwpO1xuICAgICAgZW5kUm93KCk7IC8vIGNoZWNrIGZvciBcXGhsaW5lKHMpIGZvbGxvd2luZyB0aGUgcm93IHNlcGFyYXRvclxuXG4gICAgICBoTGluZXNCZWZvcmVSb3cucHVzaChnZXRITGluZXMocGFyc2VyKSk7XG4gICAgICByb3cgPSBbXTtcbiAgICAgIGJvZHkucHVzaChyb3cpO1xuICAgICAgYmVnaW5Sb3coKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiRXhwZWN0ZWQgJiBvciBcXFxcXFxcXCBvciBcXFxcY3Igb3IgXFxcXGVuZFwiLCBwYXJzZXIubmV4dFRva2VuKTtcbiAgICB9XG4gIH0gLy8gRW5kIGNlbGwgZ3JvdXBcblxuXG4gIHBhcnNlci5ndWxsZXQuZW5kR3JvdXAoKTsgLy8gRW5kIGFycmF5IGdyb3VwIGRlZmluaW5nIFxcY3JcblxuICBwYXJzZXIuZ3VsbGV0LmVuZEdyb3VwKCk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgIGFkZEpvdCxcbiAgICBhcnJheXN0cmV0Y2gsXG4gICAgYm9keSxcbiAgICBjb2xzLFxuICAgIHJvd0dhcHMsXG4gICAgaHNraXBCZWZvcmVBbmRBZnRlcixcbiAgICBoTGluZXNCZWZvcmVSb3csXG4gICAgY29sU2VwYXJhdGlvblR5cGUsXG4gICAgdGFncyxcbiAgICBsZXFub1xuICB9O1xufSAvLyBEZWNpZGVzIG9uIGEgc3R5bGUgZm9yIGNlbGxzIGluIGFuIGFycmF5IGFjY29yZGluZyB0byB3aGV0aGVyIHRoZSBnaXZlblxuLy8gZW52aXJvbm1lbnQgbmFtZSBzdGFydHMgd2l0aCB0aGUgbGV0dGVyICdkJy5cblxuXG5mdW5jdGlvbiBkQ2VsbFN0eWxlKGVudk5hbWUpIHtcbiAgaWYgKGVudk5hbWUuc2xpY2UoMCwgMSkgPT09IFwiZFwiKSB7XG4gICAgcmV0dXJuIFwiZGlzcGxheVwiO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBcInRleHRcIjtcbiAgfVxufVxuXG5jb25zdCBhcnJheV9odG1sQnVpbGRlciA9IGZ1bmN0aW9uIChncm91cCwgb3B0aW9ucykge1xuICBsZXQgcjtcbiAgbGV0IGM7XG4gIGNvbnN0IG5yID0gZ3JvdXAuYm9keS5sZW5ndGg7XG4gIGNvbnN0IGhMaW5lc0JlZm9yZVJvdyA9IGdyb3VwLmhMaW5lc0JlZm9yZVJvdztcbiAgbGV0IG5jID0gMDtcbiAgbGV0IGJvZHkgPSBuZXcgQXJyYXkobnIpO1xuICBjb25zdCBobGluZXMgPSBbXTtcbiAgY29uc3QgcnVsZVRoaWNrbmVzcyA9IE1hdGgubWF4KCAvLyBGcm9tIExhVGVYIFxcc2hvd3RoZVxcYXJyYXlydWxld2lkdGguIEVxdWFscyAwLjA0IGVtLlxuICBvcHRpb25zLmZvbnRNZXRyaWNzKCkuYXJyYXlSdWxlV2lkdGgsIG9wdGlvbnMubWluUnVsZVRoaWNrbmVzcyAvLyBVc2VyIG92ZXJyaWRlLlxuICApOyAvLyBIb3Jpem9udGFsIHNwYWNpbmdcblxuICBjb25zdCBwdCA9IDEgLyBvcHRpb25zLmZvbnRNZXRyaWNzKCkucHRQZXJFbTtcbiAgbGV0IGFycmF5Y29sc2VwID0gNSAqIHB0OyAvLyBkZWZhdWx0IHZhbHVlLCBpLmUuIFxcYXJyYXljb2xzZXAgaW4gYXJ0aWNsZS5jbHNcblxuICBpZiAoZ3JvdXAuY29sU2VwYXJhdGlvblR5cGUgJiYgZ3JvdXAuY29sU2VwYXJhdGlvblR5cGUgPT09IFwic21hbGxcIikge1xuICAgIC8vIFdlJ3JlIGluIGEge3NtYWxsbWF0cml4fS4gRGVmYXVsdCBjb2x1bW4gc3BhY2UgaXMgXFx0aGlja3NwYWNlLFxuICAgIC8vIGkuZS4gNS8xOGVtID0gMC4yNzc4ZW0sIHBlciBhbXNtYXRoLmR0eCBmb3Ige3NtYWxsbWF0cml4fS5cbiAgICAvLyBCdXQgdGhhdCBuZWVkcyBhZGp1c3RtZW50IGJlY2F1c2UgTGFUZVggYXBwbGllcyBcXHNjcmlwdHN0eWxlIHRvIHRoZVxuICAgIC8vIGVudGlyZSBhcnJheSwgaW5jbHVkaW5nIHRoZSBjb2xzcGFjZSwgYnV0IHRoaXMgZnVuY3Rpb24gYXBwbGllc1xuICAgIC8vIFxcc2NyaXB0c3R5bGUgb25seSBpbnNpZGUgZWFjaCBlbGVtZW50LlxuICAgIGNvbnN0IGxvY2FsTXVsdGlwbGllciA9IG9wdGlvbnMuaGF2aW5nU3R5bGUoc3JjX1N0eWxlLlNDUklQVCkuc2l6ZU11bHRpcGxpZXI7XG4gICAgYXJyYXljb2xzZXAgPSAwLjI3NzggKiAobG9jYWxNdWx0aXBsaWVyIC8gb3B0aW9ucy5zaXplTXVsdGlwbGllcik7XG4gIH0gLy8gVmVydGljYWwgc3BhY2luZ1xuXG5cbiAgY29uc3QgYmFzZWxpbmVza2lwID0gZ3JvdXAuY29sU2VwYXJhdGlvblR5cGUgPT09IFwiQ0RcIiA/IGNhbGN1bGF0ZVNpemUoe1xuICAgIG51bWJlcjogMyxcbiAgICB1bml0OiBcImV4XCJcbiAgfSwgb3B0aW9ucykgOiAxMiAqIHB0OyAvLyBzZWUgc2l6ZTEwLmNsb1xuICAvLyBEZWZhdWx0IFxcam90IGZyb20gbHRtYXRoLmR0eFxuICAvLyBUT0RPKGVkZW1haW5lKTogYWxsb3cgb3ZlcnJpZGluZyBcXGpvdCB2aWEgXFxzZXRsZW5ndGggKCM2ODcpXG5cbiAgY29uc3Qgam90ID0gMyAqIHB0O1xuICBjb25zdCBhcnJheXNraXAgPSBncm91cC5hcnJheXN0cmV0Y2ggKiBiYXNlbGluZXNraXA7XG4gIGNvbnN0IGFyc3RydXRIZWlnaHQgPSAwLjcgKiBhcnJheXNraXA7IC8vIFxcc3RydXRib3ggaW4gbHRmc3N0cmMuZHR4IGFuZFxuXG4gIGNvbnN0IGFyc3RydXREZXB0aCA9IDAuMyAqIGFycmF5c2tpcDsgLy8gXFxAYXJzdHJ1dGJveCBpbiBsdHRhYi5kdHhcblxuICBsZXQgdG90YWxIZWlnaHQgPSAwOyAvLyBTZXQgYSBwb3NpdGlvbiBmb3IgXFxobGluZShzKSBhdCB0aGUgdG9wIG9mIHRoZSBhcnJheSwgaWYgYW55LlxuXG4gIGZ1bmN0aW9uIHNldEhMaW5lUG9zKGhsaW5lc0luR2FwKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBobGluZXNJbkdhcC5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIHRvdGFsSGVpZ2h0ICs9IDAuMjU7XG4gICAgICB9XG5cbiAgICAgIGhsaW5lcy5wdXNoKHtcbiAgICAgICAgcG9zOiB0b3RhbEhlaWdodCxcbiAgICAgICAgaXNEYXNoZWQ6IGhsaW5lc0luR2FwW2ldXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBzZXRITGluZVBvcyhoTGluZXNCZWZvcmVSb3dbMF0pO1xuXG4gIGZvciAociA9IDA7IHIgPCBncm91cC5ib2R5Lmxlbmd0aDsgKytyKSB7XG4gICAgY29uc3QgaW5yb3cgPSBncm91cC5ib2R5W3JdO1xuICAgIGxldCBoZWlnaHQgPSBhcnN0cnV0SGVpZ2h0OyAvLyBcXEBhcnJheSBhZGRzIGFuIFxcQGFyc3RydXRcblxuICAgIGxldCBkZXB0aCA9IGFyc3RydXREZXB0aDsgLy8gdG8gZWFjaCB0b3cgKHZpYSB0aGUgdGVtcGxhdGUpXG5cbiAgICBpZiAobmMgPCBpbnJvdy5sZW5ndGgpIHtcbiAgICAgIG5jID0gaW5yb3cubGVuZ3RoO1xuICAgIH1cblxuICAgIGNvbnN0IG91dHJvdyA9IG5ldyBBcnJheShpbnJvdy5sZW5ndGgpO1xuXG4gICAgZm9yIChjID0gMDsgYyA8IGlucm93Lmxlbmd0aDsgKytjKSB7XG4gICAgICBjb25zdCBlbHQgPSBidWlsZEdyb3VwKGlucm93W2NdLCBvcHRpb25zKTtcblxuICAgICAgaWYgKGRlcHRoIDwgZWx0LmRlcHRoKSB7XG4gICAgICAgIGRlcHRoID0gZWx0LmRlcHRoO1xuICAgICAgfVxuXG4gICAgICBpZiAoaGVpZ2h0IDwgZWx0LmhlaWdodCkge1xuICAgICAgICBoZWlnaHQgPSBlbHQuaGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICBvdXRyb3dbY10gPSBlbHQ7XG4gICAgfVxuXG4gICAgY29uc3Qgcm93R2FwID0gZ3JvdXAucm93R2Fwc1tyXTtcbiAgICBsZXQgZ2FwID0gMDtcblxuICAgIGlmIChyb3dHYXApIHtcbiAgICAgIGdhcCA9IGNhbGN1bGF0ZVNpemUocm93R2FwLCBvcHRpb25zKTtcblxuICAgICAgaWYgKGdhcCA+IDApIHtcbiAgICAgICAgLy8gXFxAYXJnYXJyYXljclxuICAgICAgICBnYXAgKz0gYXJzdHJ1dERlcHRoO1xuXG4gICAgICAgIGlmIChkZXB0aCA8IGdhcCkge1xuICAgICAgICAgIGRlcHRoID0gZ2FwOyAvLyBcXEB4YXJnYXJyYXljclxuICAgICAgICB9XG5cbiAgICAgICAgZ2FwID0gMDtcbiAgICAgIH1cbiAgICB9IC8vIEluIEFNUyBtdWx0aWxpbmUgZW52aXJvbm1lbnRzIHN1Y2ggYXMgYWxpZ25lZCBhbmQgZ2F0aGVyZWQsIHJvd3NcbiAgICAvLyBjb3JyZXNwb25kIHRvIGxpbmVzIHRoYXQgaGF2ZSBhZGRpdGlvbmFsIFxcam90IGFkZGVkIHRvIHRoZVxuICAgIC8vIFxcYmFzZWxpbmVza2lwIHZpYSBcXG9wZW51cC5cblxuXG4gICAgaWYgKGdyb3VwLmFkZEpvdCkge1xuICAgICAgZGVwdGggKz0gam90O1xuICAgIH1cblxuICAgIG91dHJvdy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgb3V0cm93LmRlcHRoID0gZGVwdGg7XG4gICAgdG90YWxIZWlnaHQgKz0gaGVpZ2h0O1xuICAgIG91dHJvdy5wb3MgPSB0b3RhbEhlaWdodDtcbiAgICB0b3RhbEhlaWdodCArPSBkZXB0aCArIGdhcDsgLy8gXFxAeWFyZ2FycmF5Y3JcblxuICAgIGJvZHlbcl0gPSBvdXRyb3c7IC8vIFNldCBhIHBvc2l0aW9uIGZvciBcXGhsaW5lKHMpLCBpZiBhbnkuXG5cbiAgICBzZXRITGluZVBvcyhoTGluZXNCZWZvcmVSb3dbciArIDFdKTtcbiAgfVxuXG4gIGNvbnN0IG9mZnNldCA9IHRvdGFsSGVpZ2h0IC8gMiArIG9wdGlvbnMuZm9udE1ldHJpY3MoKS5heGlzSGVpZ2h0O1xuICBjb25zdCBjb2xEZXNjcmlwdGlvbnMgPSBncm91cC5jb2xzIHx8IFtdO1xuICBjb25zdCBjb2xzID0gW107XG4gIGxldCBjb2xTZXA7XG4gIGxldCBjb2xEZXNjck51bTtcbiAgY29uc3QgdGFnU3BhbnMgPSBbXTtcblxuICBpZiAoZ3JvdXAudGFncyAmJiBncm91cC50YWdzLnNvbWUodGFnID0+IHRhZykpIHtcbiAgICAvLyBBbiBlbnZpcm9ubWVudCB3aXRoIG1hbnVhbCB0YWdzIGFuZC9vciBhdXRvbWF0aWMgZXF1YXRpb24gbnVtYmVycy5cbiAgICAvLyBDcmVhdGUgbm9kZShzKSwgdGhlIGxhdHRlciBvZiB3aGljaCB0cmlnZ2VyIENTUyBjb3VudGVyIGluY3JlbWVudC5cbiAgICBmb3IgKHIgPSAwOyByIDwgbnI7ICsrcikge1xuICAgICAgY29uc3QgcncgPSBib2R5W3JdO1xuICAgICAgY29uc3Qgc2hpZnQgPSBydy5wb3MgLSBvZmZzZXQ7XG4gICAgICBjb25zdCB0YWcgPSBncm91cC50YWdzW3JdO1xuICAgICAgbGV0IHRhZ1NwYW47XG5cbiAgICAgIGlmICh0YWcgPT09IHRydWUpIHtcbiAgICAgICAgLy8gYXV0b21hdGljIG51bWJlcmluZ1xuICAgICAgICB0YWdTcGFuID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wiZXFuLW51bVwiXSwgW10sIG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIGlmICh0YWcgPT09IGZhbHNlKSB7XG4gICAgICAgIC8vIFxcbm9udW1iZXIvXFxub3RhZyBvciBzdGFycmVkIGVudmlyb25tZW50XG4gICAgICAgIHRhZ1NwYW4gPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXSwgW10sIG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbWFudWFsIFxcdGFnXG4gICAgICAgIHRhZ1NwYW4gPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXSwgYnVpbGRFeHByZXNzaW9uKHRhZywgb3B0aW9ucywgdHJ1ZSksIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICB0YWdTcGFuLmRlcHRoID0gcncuZGVwdGg7XG4gICAgICB0YWdTcGFuLmhlaWdodCA9IHJ3LmhlaWdodDtcbiAgICAgIHRhZ1NwYW5zLnB1c2goe1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogdGFnU3BhbixcbiAgICAgICAgc2hpZnRcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoYyA9IDAsIGNvbERlc2NyTnVtID0gMDsgLy8gQ29udGludWUgd2hpbGUgZWl0aGVyIHRoZXJlIGFyZSBtb3JlIGNvbHVtbnMgb3IgbW9yZSBjb2x1bW5cbiAgLy8gZGVzY3JpcHRpb25zLCBzbyB0cmFpbGluZyBzZXBhcmF0b3JzIGRvbid0IGdldCBsb3N0LlxuICBjIDwgbmMgfHwgY29sRGVzY3JOdW0gPCBjb2xEZXNjcmlwdGlvbnMubGVuZ3RoOyArK2MsICsrY29sRGVzY3JOdW0pIHtcbiAgICBsZXQgY29sRGVzY3IgPSBjb2xEZXNjcmlwdGlvbnNbY29sRGVzY3JOdW1dIHx8IHt9O1xuICAgIGxldCBmaXJzdFNlcGFyYXRvciA9IHRydWU7XG5cbiAgICB3aGlsZSAoY29sRGVzY3IudHlwZSA9PT0gXCJzZXBhcmF0b3JcIikge1xuICAgICAgLy8gSWYgdGhlcmUgaXMgbW9yZSB0aGFuIG9uZSBzZXBhcmF0b3IgaW4gYSByb3csIGFkZCBhIHNwYWNlXG4gICAgICAvLyBiZXR3ZWVuIHRoZW0uXG4gICAgICBpZiAoIWZpcnN0U2VwYXJhdG9yKSB7XG4gICAgICAgIGNvbFNlcCA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcImFycmF5Y29sc2VwXCJdLCBbXSk7XG4gICAgICAgIGNvbFNlcC5zdHlsZS53aWR0aCA9IG1ha2VFbShvcHRpb25zLmZvbnRNZXRyaWNzKCkuZG91YmxlUnVsZVNlcCk7XG4gICAgICAgIGNvbHMucHVzaChjb2xTZXApO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29sRGVzY3Iuc2VwYXJhdG9yID09PSBcInxcIiB8fCBjb2xEZXNjci5zZXBhcmF0b3IgPT09IFwiOlwiKSB7XG4gICAgICAgIGNvbnN0IGxpbmVUeXBlID0gY29sRGVzY3Iuc2VwYXJhdG9yID09PSBcInxcIiA/IFwic29saWRcIiA6IFwiZGFzaGVkXCI7XG4gICAgICAgIGNvbnN0IHNlcGFyYXRvciA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcInZlcnRpY2FsLXNlcGFyYXRvclwiXSwgW10sIG9wdGlvbnMpO1xuICAgICAgICBzZXBhcmF0b3Iuc3R5bGUuaGVpZ2h0ID0gbWFrZUVtKHRvdGFsSGVpZ2h0KTtcbiAgICAgICAgc2VwYXJhdG9yLnN0eWxlLmJvcmRlclJpZ2h0V2lkdGggPSBtYWtlRW0ocnVsZVRoaWNrbmVzcyk7XG4gICAgICAgIHNlcGFyYXRvci5zdHlsZS5ib3JkZXJSaWdodFN0eWxlID0gbGluZVR5cGU7XG4gICAgICAgIHNlcGFyYXRvci5zdHlsZS5tYXJnaW4gPSBcIjAgXCIgKyBtYWtlRW0oLXJ1bGVUaGlja25lc3MgLyAyKTtcbiAgICAgICAgY29uc3Qgc2hpZnQgPSB0b3RhbEhlaWdodCAtIG9mZnNldDtcblxuICAgICAgICBpZiAoc2hpZnQpIHtcbiAgICAgICAgICBzZXBhcmF0b3Iuc3R5bGUudmVydGljYWxBbGlnbiA9IG1ha2VFbSgtc2hpZnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29scy5wdXNoKHNlcGFyYXRvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJJbnZhbGlkIHNlcGFyYXRvciB0eXBlOiBcIiArIGNvbERlc2NyLnNlcGFyYXRvcik7XG4gICAgICB9XG5cbiAgICAgIGNvbERlc2NyTnVtKys7XG4gICAgICBjb2xEZXNjciA9IGNvbERlc2NyaXB0aW9uc1tjb2xEZXNjck51bV0gfHwge307XG4gICAgICBmaXJzdFNlcGFyYXRvciA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChjID49IG5jKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBsZXQgc2Vwd2lkdGg7XG5cbiAgICBpZiAoYyA+IDAgfHwgZ3JvdXAuaHNraXBCZWZvcmVBbmRBZnRlcikge1xuICAgICAgc2Vwd2lkdGggPSB1dGlscy5kZWZsdChjb2xEZXNjci5wcmVnYXAsIGFycmF5Y29sc2VwKTtcblxuICAgICAgaWYgKHNlcHdpZHRoICE9PSAwKSB7XG4gICAgICAgIGNvbFNlcCA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcImFycmF5Y29sc2VwXCJdLCBbXSk7XG4gICAgICAgIGNvbFNlcC5zdHlsZS53aWR0aCA9IG1ha2VFbShzZXB3aWR0aCk7XG4gICAgICAgIGNvbHMucHVzaChjb2xTZXApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBjb2wgPSBbXTtcblxuICAgIGZvciAociA9IDA7IHIgPCBucjsgKytyKSB7XG4gICAgICBjb25zdCByb3cgPSBib2R5W3JdO1xuICAgICAgY29uc3QgZWxlbSA9IHJvd1tjXTtcblxuICAgICAgaWYgKCFlbGVtKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzaGlmdCA9IHJvdy5wb3MgLSBvZmZzZXQ7XG4gICAgICBlbGVtLmRlcHRoID0gcm93LmRlcHRoO1xuICAgICAgZWxlbS5oZWlnaHQgPSByb3cuaGVpZ2h0O1xuICAgICAgY29sLnB1c2goe1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogZWxlbSxcbiAgICAgICAgc2hpZnQ6IHNoaWZ0XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb2wgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgcG9zaXRpb25UeXBlOiBcImluZGl2aWR1YWxTaGlmdFwiLFxuICAgICAgY2hpbGRyZW46IGNvbFxuICAgIH0sIG9wdGlvbnMpO1xuICAgIGNvbCA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcImNvbC1hbGlnbi1cIiArIChjb2xEZXNjci5hbGlnbiB8fCBcImNcIildLCBbY29sXSk7XG4gICAgY29scy5wdXNoKGNvbCk7XG5cbiAgICBpZiAoYyA8IG5jIC0gMSB8fCBncm91cC5oc2tpcEJlZm9yZUFuZEFmdGVyKSB7XG4gICAgICBzZXB3aWR0aCA9IHV0aWxzLmRlZmx0KGNvbERlc2NyLnBvc3RnYXAsIGFycmF5Y29sc2VwKTtcblxuICAgICAgaWYgKHNlcHdpZHRoICE9PSAwKSB7XG4gICAgICAgIGNvbFNlcCA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcImFycmF5Y29sc2VwXCJdLCBbXSk7XG4gICAgICAgIGNvbFNlcC5zdHlsZS53aWR0aCA9IG1ha2VFbShzZXB3aWR0aCk7XG4gICAgICAgIGNvbHMucHVzaChjb2xTZXApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGJvZHkgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtdGFibGVcIl0sIGNvbHMpOyAvLyBBZGQgXFxobGluZShzKSwgaWYgYW55LlxuXG4gIGlmIChobGluZXMubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGxpbmUgPSBidWlsZENvbW1vbi5tYWtlTGluZVNwYW4oXCJobGluZVwiLCBvcHRpb25zLCBydWxlVGhpY2tuZXNzKTtcbiAgICBjb25zdCBkYXNoZXMgPSBidWlsZENvbW1vbi5tYWtlTGluZVNwYW4oXCJoZGFzaGxpbmVcIiwgb3B0aW9ucywgcnVsZVRoaWNrbmVzcyk7XG4gICAgY29uc3Qgdkxpc3RFbGVtcyA9IFt7XG4gICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgIGVsZW06IGJvZHksXG4gICAgICBzaGlmdDogMFxuICAgIH1dO1xuXG4gICAgd2hpbGUgKGhsaW5lcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBobGluZSA9IGhsaW5lcy5wb3AoKTtcbiAgICAgIGNvbnN0IGxpbmVTaGlmdCA9IGhsaW5lLnBvcyAtIG9mZnNldDtcblxuICAgICAgaWYgKGhsaW5lLmlzRGFzaGVkKSB7XG4gICAgICAgIHZMaXN0RWxlbXMucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgICAgZWxlbTogZGFzaGVzLFxuICAgICAgICAgIHNoaWZ0OiBsaW5lU2hpZnRcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2TGlzdEVsZW1zLnB1c2goe1xuICAgICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICAgIGVsZW06IGxpbmUsXG4gICAgICAgICAgc2hpZnQ6IGxpbmVTaGlmdFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBib2R5ID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHtcbiAgICAgIHBvc2l0aW9uVHlwZTogXCJpbmRpdmlkdWFsU2hpZnRcIixcbiAgICAgIGNoaWxkcmVuOiB2TGlzdEVsZW1zXG4gICAgfSwgb3B0aW9ucyk7XG4gIH1cblxuICBpZiAodGFnU3BhbnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1vcmRcIl0sIFtib2R5XSwgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IGVxbk51bUNvbCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICBwb3NpdGlvblR5cGU6IFwiaW5kaXZpZHVhbFNoaWZ0XCIsXG4gICAgICBjaGlsZHJlbjogdGFnU3BhbnNcbiAgICB9LCBvcHRpb25zKTtcbiAgICBlcW5OdW1Db2wgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJ0YWdcIl0sIFtlcW5OdW1Db2xdLCBvcHRpb25zKTtcbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZUZyYWdtZW50KFtib2R5LCBlcW5OdW1Db2xdKTtcbiAgfVxufTtcblxuY29uc3QgYWxpZ25NYXAgPSB7XG4gIGM6IFwiY2VudGVyIFwiLFxuICBsOiBcImxlZnQgXCIsXG4gIHI6IFwicmlnaHQgXCJcbn07XG5cbmNvbnN0IGFycmF5X21hdGhtbEJ1aWxkZXIgPSBmdW5jdGlvbiAoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgY29uc3QgdGJsID0gW107XG4gIGNvbnN0IGdsdWUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10ZFwiLCBbXSwgW1wibXRyLWdsdWVcIl0pO1xuICBjb25zdCB0YWcgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10ZFwiLCBbXSwgW1wibW1sLWVxbi1udW1cIl0pO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JvdXAuYm9keS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHJ3ID0gZ3JvdXAuYm9keVtpXTtcbiAgICBjb25zdCByb3cgPSBbXTtcblxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgcncubGVuZ3RoOyBqKyspIHtcbiAgICAgIHJvdy5wdXNoKG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRkXCIsIFtidWlsZE1hdGhNTF9idWlsZEdyb3VwKHJ3W2pdLCBvcHRpb25zKV0pKTtcbiAgICB9XG5cbiAgICBpZiAoZ3JvdXAudGFncyAmJiBncm91cC50YWdzW2ldKSB7XG4gICAgICByb3cudW5zaGlmdChnbHVlKTtcbiAgICAgIHJvdy5wdXNoKGdsdWUpO1xuXG4gICAgICBpZiAoZ3JvdXAubGVxbm8pIHtcbiAgICAgICAgcm93LnVuc2hpZnQodGFnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvdy5wdXNoKHRhZyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGJsLnB1c2gobmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdHJcIiwgcm93KSk7XG4gIH1cblxuICBsZXQgdGFibGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10YWJsZVwiLCB0YmwpOyAvLyBTZXQgY29sdW1uIGFsaWdubWVudCwgcm93IHNwYWNpbmcsIGNvbHVtbiBzcGFjaW5nLCBhbmRcbiAgLy8gYXJyYXkgbGluZXMgYnkgc2V0dGluZyBhdHRyaWJ1dGVzIG9uIHRoZSB0YWJsZSBlbGVtZW50LlxuICAvLyBTZXQgdGhlIHJvdyBzcGFjaW5nLiBJbiBNYXRoTUwsIHdlIHNwZWNpZnkgYSBnYXAgZGlzdGFuY2UuXG4gIC8vIFdlIGRvIG5vdCB1c2Ugcm93R2FwW10gYmVjYXVzZSBNYXRoTUwgYXV0b21hdGljYWxseSBpbmNyZWFzZXNcbiAgLy8gY2VsbCBoZWlnaHQgd2l0aCB0aGUgaGVpZ2h0L2RlcHRoIG9mIHRoZSBlbGVtZW50IGNvbnRlbnQuXG4gIC8vIExhVGVYIFxcYXJyYXlzdHJldGNoIG11bHRpcGxpZXMgdGhlIHJvdyBiYXNlbGluZS10by1iYXNlbGluZSBkaXN0YW5jZS5cbiAgLy8gV2Ugc2ltdWxhdGUgdGhpcyBieSBhZGRpbmcgKGFycmF5c3RyZXRjaCAtIDEpZW0gdG8gdGhlIGdhcC4gVGhpc1xuICAvLyBkb2VzIGEgcmVhc29uYWJsZSBqb2Igb2YgYWRqdXN0aW5nIGFycmF5cyBjb250YWluaW5nIDEgZW0gdGFsbCBjb250ZW50LlxuICAvLyBUaGUgMC4xNiBhbmQgMC4wOSB2YWx1ZXMgYXJlIGZvdW5kIGVtcGlyaWNhbGx5LiBUaGV5IHByb2R1Y2UgYW4gYXJyYXlcbiAgLy8gc2ltaWxhciB0byBMYVRlWCBhbmQgaW4gd2hpY2ggY29udGVudCBkb2VzIG5vdCBpbnRlcmZlcmUgd2l0aCBcXGhsaW5lcy5cblxuICBjb25zdCBnYXAgPSBncm91cC5hcnJheXN0cmV0Y2ggPT09IDAuNSA/IDAuMSAvLyB7c21hbGxtYXRyaXh9LCB7c3ViYXJyYXl9XG4gIDogMC4xNiArIGdyb3VwLmFycmF5c3RyZXRjaCAtIDEgKyAoZ3JvdXAuYWRkSm90ID8gMC4wOSA6IDApO1xuICB0YWJsZS5zZXRBdHRyaWJ1dGUoXCJyb3dzcGFjaW5nXCIsIG1ha2VFbShnYXApKTsgLy8gTWF0aE1MIHRhYmxlIGxpbmVzIGdvIG9ubHkgYmV0d2VlbiBjZWxscy5cbiAgLy8gVG8gcGxhY2UgYSBsaW5lIG9uIGFuIGVkZ2Ugd2UnbGwgdXNlIDxtZW5jbG9zZT4sIGlmIG5lY2Vzc2FyeS5cblxuICBsZXQgbWVuY2xvc2UgPSBcIlwiO1xuICBsZXQgYWxpZ24gPSBcIlwiO1xuXG4gIGlmIChncm91cC5jb2xzICYmIGdyb3VwLmNvbHMubGVuZ3RoID4gMCkge1xuICAgIC8vIEZpbmQgY29sdW1uIGFsaWdubWVudCwgY29sdW1uIHNwYWNpbmcsIGFuZCAgdmVydGljYWwgbGluZXMuXG4gICAgY29uc3QgY29scyA9IGdyb3VwLmNvbHM7XG4gICAgbGV0IGNvbHVtbkxpbmVzID0gXCJcIjtcbiAgICBsZXQgcHJldlR5cGVXYXNBbGlnbiA9IGZhbHNlO1xuICAgIGxldCBpU3RhcnQgPSAwO1xuICAgIGxldCBpRW5kID0gY29scy5sZW5ndGg7XG5cbiAgICBpZiAoY29sc1swXS50eXBlID09PSBcInNlcGFyYXRvclwiKSB7XG4gICAgICBtZW5jbG9zZSArPSBcInRvcCBcIjtcbiAgICAgIGlTdGFydCA9IDE7XG4gICAgfVxuXG4gICAgaWYgKGNvbHNbY29scy5sZW5ndGggLSAxXS50eXBlID09PSBcInNlcGFyYXRvclwiKSB7XG4gICAgICBtZW5jbG9zZSArPSBcImJvdHRvbSBcIjtcbiAgICAgIGlFbmQgLT0gMTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gaVN0YXJ0OyBpIDwgaUVuZDsgaSsrKSB7XG4gICAgICBpZiAoY29sc1tpXS50eXBlID09PSBcImFsaWduXCIpIHtcbiAgICAgICAgYWxpZ24gKz0gYWxpZ25NYXBbY29sc1tpXS5hbGlnbl07XG5cbiAgICAgICAgaWYgKHByZXZUeXBlV2FzQWxpZ24pIHtcbiAgICAgICAgICBjb2x1bW5MaW5lcyArPSBcIm5vbmUgXCI7XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2VHlwZVdhc0FsaWduID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoY29sc1tpXS50eXBlID09PSBcInNlcGFyYXRvclwiKSB7XG4gICAgICAgIC8vIE1hdGhNTCBhY2NlcHRzIG9ubHkgc2luZ2xlIGxpbmVzIGJldHdlZW4gY2VsbHMuXG4gICAgICAgIC8vIFNvIHdlIHJlYWQgb25seSB0aGUgZmlyc3Qgb2YgY29uc2VjdXRpdmUgc2VwYXJhdG9ycy5cbiAgICAgICAgaWYgKHByZXZUeXBlV2FzQWxpZ24pIHtcbiAgICAgICAgICBjb2x1bW5MaW5lcyArPSBjb2xzW2ldLnNlcGFyYXRvciA9PT0gXCJ8XCIgPyBcInNvbGlkIFwiIDogXCJkYXNoZWQgXCI7XG4gICAgICAgICAgcHJldlR5cGVXYXNBbGlnbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGFibGUuc2V0QXR0cmlidXRlKFwiY29sdW1uYWxpZ25cIiwgYWxpZ24udHJpbSgpKTtcblxuICAgIGlmICgvW3NkXS8udGVzdChjb2x1bW5MaW5lcykpIHtcbiAgICAgIHRhYmxlLnNldEF0dHJpYnV0ZShcImNvbHVtbmxpbmVzXCIsIGNvbHVtbkxpbmVzLnRyaW0oKSk7XG4gICAgfVxuICB9IC8vIFNldCBjb2x1bW4gc3BhY2luZy5cblxuXG4gIGlmIChncm91cC5jb2xTZXBhcmF0aW9uVHlwZSA9PT0gXCJhbGlnblwiKSB7XG4gICAgY29uc3QgY29scyA9IGdyb3VwLmNvbHMgfHwgW107XG4gICAgbGV0IHNwYWNpbmcgPSBcIlwiO1xuXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBjb2xzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzcGFjaW5nICs9IGkgJSAyID8gXCIwZW0gXCIgOiBcIjFlbSBcIjtcbiAgICB9XG5cbiAgICB0YWJsZS5zZXRBdHRyaWJ1dGUoXCJjb2x1bW5zcGFjaW5nXCIsIHNwYWNpbmcudHJpbSgpKTtcbiAgfSBlbHNlIGlmIChncm91cC5jb2xTZXBhcmF0aW9uVHlwZSA9PT0gXCJhbGlnbmF0XCIgfHwgZ3JvdXAuY29sU2VwYXJhdGlvblR5cGUgPT09IFwiZ2F0aGVyXCIpIHtcbiAgICB0YWJsZS5zZXRBdHRyaWJ1dGUoXCJjb2x1bW5zcGFjaW5nXCIsIFwiMGVtXCIpO1xuICB9IGVsc2UgaWYgKGdyb3VwLmNvbFNlcGFyYXRpb25UeXBlID09PSBcInNtYWxsXCIpIHtcbiAgICB0YWJsZS5zZXRBdHRyaWJ1dGUoXCJjb2x1bW5zcGFjaW5nXCIsIFwiMC4yNzc4ZW1cIik7XG4gIH0gZWxzZSBpZiAoZ3JvdXAuY29sU2VwYXJhdGlvblR5cGUgPT09IFwiQ0RcIikge1xuICAgIHRhYmxlLnNldEF0dHJpYnV0ZShcImNvbHVtbnNwYWNpbmdcIiwgXCIwLjVlbVwiKTtcbiAgfSBlbHNlIHtcbiAgICB0YWJsZS5zZXRBdHRyaWJ1dGUoXCJjb2x1bW5zcGFjaW5nXCIsIFwiMWVtXCIpO1xuICB9IC8vIEFkZHJlc3MgXFxobGluZSBhbmQgXFxoZGFzaGxpbmVcblxuXG4gIGxldCByb3dMaW5lcyA9IFwiXCI7XG4gIGNvbnN0IGhsaW5lcyA9IGdyb3VwLmhMaW5lc0JlZm9yZVJvdztcbiAgbWVuY2xvc2UgKz0gaGxpbmVzWzBdLmxlbmd0aCA+IDAgPyBcImxlZnQgXCIgOiBcIlwiO1xuICBtZW5jbG9zZSArPSBobGluZXNbaGxpbmVzLmxlbmd0aCAtIDFdLmxlbmd0aCA+IDAgPyBcInJpZ2h0IFwiIDogXCJcIjtcblxuICBmb3IgKGxldCBpID0gMTsgaSA8IGhsaW5lcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICByb3dMaW5lcyArPSBobGluZXNbaV0ubGVuZ3RoID09PSAwID8gXCJub25lIFwiIC8vIE1hdGhNTCBhY2NlcHRzIG9ubHkgYSBzaW5nbGUgbGluZSBiZXR3ZWVuIHJvd3MuIFJlYWQgb25lIGVsZW1lbnQuXG4gICAgOiBobGluZXNbaV1bMF0gPyBcImRhc2hlZCBcIiA6IFwic29saWQgXCI7XG4gIH1cblxuICBpZiAoL1tzZF0vLnRlc3Qocm93TGluZXMpKSB7XG4gICAgdGFibGUuc2V0QXR0cmlidXRlKFwicm93bGluZXNcIiwgcm93TGluZXMudHJpbSgpKTtcbiAgfVxuXG4gIGlmIChtZW5jbG9zZSAhPT0gXCJcIikge1xuICAgIHRhYmxlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtZW5jbG9zZVwiLCBbdGFibGVdKTtcbiAgICB0YWJsZS5zZXRBdHRyaWJ1dGUoXCJub3RhdGlvblwiLCBtZW5jbG9zZS50cmltKCkpO1xuICB9XG5cbiAgaWYgKGdyb3VwLmFycmF5c3RyZXRjaCAmJiBncm91cC5hcnJheXN0cmV0Y2ggPCAxKSB7XG4gICAgLy8gQSBzbWFsbCBhcnJheS4gV3JhcCBpbiBzY3JpcHRzdHlsZSBzbyByb3cgZ2FwIGlzIG5vdCB0b28gbGFyZ2UuXG4gICAgdGFibGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1zdHlsZVwiLCBbdGFibGVdKTtcbiAgICB0YWJsZS5zZXRBdHRyaWJ1dGUoXCJzY3JpcHRsZXZlbFwiLCBcIjFcIik7XG4gIH1cblxuICByZXR1cm4gdGFibGU7XG59OyAvLyBDb252ZW5pZW5jZSBmdW5jdGlvbiBmb3IgYWxpZ24sIGFsaWduKiwgYWxpZ25lZCwgYWxpZ25hdCwgYWxpZ25hdCosIGFsaWduZWRhdC5cblxuXG5jb25zdCBhbGlnbmVkSGFuZGxlciA9IGZ1bmN0aW9uIChjb250ZXh0LCBhcmdzKSB7XG4gIGlmIChjb250ZXh0LmVudk5hbWUuaW5kZXhPZihcImVkXCIpID09PSAtMSkge1xuICAgIHZhbGlkYXRlQW1zRW52aXJvbm1lbnRDb250ZXh0KGNvbnRleHQpO1xuICB9XG5cbiAgY29uc3QgY29scyA9IFtdO1xuICBjb25zdCBzZXBhcmF0aW9uVHlwZSA9IGNvbnRleHQuZW52TmFtZS5pbmRleE9mKFwiYXRcIikgPiAtMSA/IFwiYWxpZ25hdFwiIDogXCJhbGlnblwiO1xuICBjb25zdCBpc1NwbGl0ID0gY29udGV4dC5lbnZOYW1lID09PSBcInNwbGl0XCI7XG4gIGNvbnN0IHJlcyA9IHBhcnNlQXJyYXkoY29udGV4dC5wYXJzZXIsIHtcbiAgICBjb2xzLFxuICAgIGFkZEpvdDogdHJ1ZSxcbiAgICBhdXRvVGFnOiBpc1NwbGl0ID8gdW5kZWZpbmVkIDogZ2V0QXV0b1RhZyhjb250ZXh0LmVudk5hbWUpLFxuICAgIGVtcHR5U2luZ2xlUm93OiB0cnVlLFxuICAgIGNvbFNlcGFyYXRpb25UeXBlOiBzZXBhcmF0aW9uVHlwZSxcbiAgICBtYXhOdW1Db2xzOiBpc1NwbGl0ID8gMiA6IHVuZGVmaW5lZCxcbiAgICBsZXFubzogY29udGV4dC5wYXJzZXIuc2V0dGluZ3MubGVxbm9cbiAgfSwgXCJkaXNwbGF5XCIpOyAvLyBEZXRlcm1pbmluZyBudW1iZXIgb2YgY29sdW1ucy5cbiAgLy8gMS4gSWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGdpdmVuLCB3ZSB1c2UgaXQgYXMgYSBudW1iZXIgb2YgY29sdW1ucyxcbiAgLy8gICAgYW5kIG1ha2VzIHN1cmUgdGhhdCBlYWNoIHJvdyBkb2Vzbid0IGV4Y2VlZCB0aGF0IG51bWJlci5cbiAgLy8gMi4gT3RoZXJ3aXNlLCBqdXN0IGNvdW50IG51bWJlciBvZiBjb2x1bW5zID0gbWF4aW11bSBudW1iZXJcbiAgLy8gICAgb2YgY2VsbHMgaW4gZWFjaCByb3cgKFwiYWxpZ25lZFwiIG1vZGUgLS0gaXNBbGlnbmVkIHdpbGwgYmUgdHJ1ZSkuXG4gIC8vXG4gIC8vIEF0IHRoZSBzYW1lIHRpbWUsIHByZXBlbmQgZW1wdHkgZ3JvdXAge30gYXQgYmVnaW5uaW5nIG9mIGV2ZXJ5IHNlY29uZFxuICAvLyBjZWxsIGluIGVhY2ggcm93IChzdGFydGluZyB3aXRoIHNlY29uZCBjZWxsKSBzbyB0aGF0IG9wZXJhdG9ycyBiZWNvbWVcbiAgLy8gYmluYXJ5LiAgVGhpcyBiZWhhdmlvciBpcyBpbXBsZW1lbnRlZCBpbiBhbXNtYXRoJ3MgXFxzdGFydEBhbGlnbmVkLlxuXG4gIGxldCBudW1NYXRocztcbiAgbGV0IG51bUNvbHMgPSAwO1xuICBjb25zdCBlbXB0eUdyb3VwID0ge1xuICAgIHR5cGU6IFwib3JkZ3JvdXBcIixcbiAgICBtb2RlOiBjb250ZXh0Lm1vZGUsXG4gICAgYm9keTogW11cbiAgfTtcblxuICBpZiAoYXJnc1swXSAmJiBhcmdzWzBdLnR5cGUgPT09IFwib3JkZ3JvdXBcIikge1xuICAgIGxldCBhcmcwID0gXCJcIjtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJnc1swXS5ib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB0ZXh0b3JkID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXS5ib2R5W2ldLCBcInRleHRvcmRcIik7XG4gICAgICBhcmcwICs9IHRleHRvcmQudGV4dDtcbiAgICB9XG5cbiAgICBudW1NYXRocyA9IE51bWJlcihhcmcwKTtcbiAgICBudW1Db2xzID0gbnVtTWF0aHMgKiAyO1xuICB9XG5cbiAgY29uc3QgaXNBbGlnbmVkID0gIW51bUNvbHM7XG4gIHJlcy5ib2R5LmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcm93Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAvLyBNb2RpZnkgb3JkZ3JvdXAgbm9kZSB3aXRoaW4gc3R5bGluZyBub2RlXG4gICAgICBjb25zdCBzdHlsaW5nID0gYXNzZXJ0Tm9kZVR5cGUocm93W2ldLCBcInN0eWxpbmdcIik7XG4gICAgICBjb25zdCBvcmRncm91cCA9IGFzc2VydE5vZGVUeXBlKHN0eWxpbmcuYm9keVswXSwgXCJvcmRncm91cFwiKTtcbiAgICAgIG9yZGdyb3VwLmJvZHkudW5zaGlmdChlbXB0eUdyb3VwKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzQWxpZ25lZCkge1xuICAgICAgLy8gQ2FzZSAxXG4gICAgICBjb25zdCBjdXJNYXRocyA9IHJvdy5sZW5ndGggLyAyO1xuXG4gICAgICBpZiAobnVtTWF0aHMgPCBjdXJNYXRocykge1xuICAgICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJUb28gbWFueSBtYXRoIGluIGEgcm93OiBcIiArIChcImV4cGVjdGVkIFwiICsgbnVtTWF0aHMgKyBcIiwgYnV0IGdvdCBcIiArIGN1ck1hdGhzKSwgcm93WzBdKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG51bUNvbHMgPCByb3cubGVuZ3RoKSB7XG4gICAgICAvLyBDYXNlIDJcbiAgICAgIG51bUNvbHMgPSByb3cubGVuZ3RoO1xuICAgIH1cbiAgfSk7IC8vIEFkanVzdGluZyBhbGlnbm1lbnQuXG4gIC8vIEluIGFsaWduZWQgbW9kZSwgd2UgYWRkIG9uZSBcXHFxdWFkIGJldHdlZW4gY29sdW1ucztcbiAgLy8gb3RoZXJ3aXNlIHdlIGFkZCBub3RoaW5nLlxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ29sczsgKytpKSB7XG4gICAgbGV0IGFsaWduID0gXCJyXCI7XG4gICAgbGV0IHByZWdhcCA9IDA7XG5cbiAgICBpZiAoaSAlIDIgPT09IDEpIHtcbiAgICAgIGFsaWduID0gXCJsXCI7XG4gICAgfSBlbHNlIGlmIChpID4gMCAmJiBpc0FsaWduZWQpIHtcbiAgICAgIC8vIFwiYWxpZ25lZFwiIG1vZGUuXG4gICAgICBwcmVnYXAgPSAxOyAvLyBhZGQgb25lIFxccXVhZFxuICAgIH1cblxuICAgIGNvbHNbaV0gPSB7XG4gICAgICB0eXBlOiBcImFsaWduXCIsXG4gICAgICBhbGlnbjogYWxpZ24sXG4gICAgICBwcmVnYXA6IHByZWdhcCxcbiAgICAgIHBvc3RnYXA6IDBcbiAgICB9O1xuICB9XG5cbiAgcmVzLmNvbFNlcGFyYXRpb25UeXBlID0gaXNBbGlnbmVkID8gXCJhbGlnblwiIDogXCJhbGlnbmF0XCI7XG4gIHJldHVybiByZXM7XG59OyAvLyBBcnJheXMgYXJlIHBhcnQgb2YgTGFUZVgsIGRlZmluZWQgaW4gbHR0YWIuZHR4IHNvIGl0cyBkb2N1bWVudGF0aW9uXG4vLyBpcyBwYXJ0IG9mIHRoZSBzb3VyY2UyZS5wZGYgZmlsZSBvZiBMYVRlWDJlIHNvdXJjZSBkb2N1bWVudGF0aW9uLlxuLy8ge2RhcnJheX0gaXMgYW4ge2FycmF5fSBlbnZpcm9ubWVudCB3aGVyZSBjZWxscyBhcmUgc2V0IGluIFxcZGlzcGxheXN0eWxlLFxuLy8gYXMgZGVmaW5lZCBpbiBuY2NtYXRoLnN0eS5cblxuXG5kZWZpbmVFbnZpcm9ubWVudCh7XG4gIHR5cGU6IFwiYXJyYXlcIixcbiAgbmFtZXM6IFtcImFycmF5XCIsIFwiZGFycmF5XCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDFcbiAgfSxcblxuICBoYW5kbGVyKGNvbnRleHQsIGFyZ3MpIHtcbiAgICAvLyBTaW5jZSBubyB0eXBlcyBhcmUgc3BlY2lmaWVkIGFib3ZlLCB0aGUgdHdvIHBvc3NpYmlsaXRpZXMgYXJlXG4gICAgLy8gLSBUaGUgYXJndW1lbnQgaXMgd3JhcHBlZCBpbiB7fSBvciBbXSwgaW4gd2hpY2ggY2FzZSBQYXJzZXInc1xuICAgIC8vICAgcGFyc2VHcm91cCgpIHJldHVybnMgYW4gXCJvcmRncm91cFwiIHdyYXBwaW5nIHNvbWUgc3ltYm9sIG5vZGUuXG4gICAgLy8gLSBUaGUgYXJndW1lbnQgaXMgYSBiYXJlIHN5bWJvbCBub2RlLlxuICAgIGNvbnN0IHN5bU5vZGUgPSBjaGVja1N5bWJvbE5vZGVUeXBlKGFyZ3NbMF0pO1xuICAgIGNvbnN0IGNvbGFsaWduID0gc3ltTm9kZSA/IFthcmdzWzBdXSA6IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwib3JkZ3JvdXBcIikuYm9keTtcbiAgICBjb25zdCBjb2xzID0gY29sYWxpZ24ubWFwKGZ1bmN0aW9uIChuZGUpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBhc3NlcnRTeW1ib2xOb2RlVHlwZShuZGUpO1xuICAgICAgY29uc3QgY2EgPSBub2RlLnRleHQ7XG5cbiAgICAgIGlmIChcImxjclwiLmluZGV4T2YoY2EpICE9PSAtMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwiYWxpZ25cIixcbiAgICAgICAgICBhbGlnbjogY2FcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoY2EgPT09IFwifFwiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJzZXBhcmF0b3JcIixcbiAgICAgICAgICBzZXBhcmF0b3I6IFwifFwiXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKGNhID09PSBcIjpcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwic2VwYXJhdG9yXCIsXG4gICAgICAgICAgc2VwYXJhdG9yOiBcIjpcIlxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJVbmtub3duIGNvbHVtbiBhbGlnbm1lbnQ6IFwiICsgY2EsIG5kZSk7XG4gICAgfSk7XG4gICAgY29uc3QgcmVzID0ge1xuICAgICAgY29scyxcbiAgICAgIGhza2lwQmVmb3JlQW5kQWZ0ZXI6IHRydWUsXG4gICAgICAvLyBcXEBwcmVhbWJsZSBpbiBsdHRhYi5kdHhcbiAgICAgIG1heE51bUNvbHM6IGNvbHMubGVuZ3RoXG4gICAgfTtcbiAgICByZXR1cm4gcGFyc2VBcnJheShjb250ZXh0LnBhcnNlciwgcmVzLCBkQ2VsbFN0eWxlKGNvbnRleHQuZW52TmFtZSkpO1xuICB9LFxuXG4gIGh0bWxCdWlsZGVyOiBhcnJheV9odG1sQnVpbGRlcixcbiAgbWF0aG1sQnVpbGRlcjogYXJyYXlfbWF0aG1sQnVpbGRlclxufSk7IC8vIFRoZSBtYXRyaXggZW52aXJvbm1lbnRzIG9mIGFtc21hdGggYnVpbGRzIG9uIHRoZSBhcnJheSBlbnZpcm9ubWVudFxuLy8gb2YgTGFUZVgsIHdoaWNoIGlzIGRpc2N1c3NlZCBhYm92ZS5cbi8vIFRoZSBtYXRodG9vbHMgcGFja2FnZSBhZGRzIHN0YXJyZWQgdmVyc2lvbnMgb2YgdGhlIHNhbWUgZW52aXJvbm1lbnRzLlxuLy8gVGhlc2UgaGF2ZSBhbiBvcHRpb25hbCBhcmd1bWVudCB0byBjaG9vc2UgbGVmdHxjZW50ZXJ8cmlnaHQganVzdGlmaWNhdGlvbi5cblxuZGVmaW5lRW52aXJvbm1lbnQoe1xuICB0eXBlOiBcImFycmF5XCIsXG4gIG5hbWVzOiBbXCJtYXRyaXhcIiwgXCJwbWF0cml4XCIsIFwiYm1hdHJpeFwiLCBcIkJtYXRyaXhcIiwgXCJ2bWF0cml4XCIsIFwiVm1hdHJpeFwiLCBcIm1hdHJpeCpcIiwgXCJwbWF0cml4KlwiLCBcImJtYXRyaXgqXCIsIFwiQm1hdHJpeCpcIiwgXCJ2bWF0cml4KlwiLCBcIlZtYXRyaXgqXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDBcbiAgfSxcblxuICBoYW5kbGVyKGNvbnRleHQpIHtcbiAgICBjb25zdCBkZWxpbWl0ZXJzID0ge1xuICAgICAgXCJtYXRyaXhcIjogbnVsbCxcbiAgICAgIFwicG1hdHJpeFwiOiBbXCIoXCIsIFwiKVwiXSxcbiAgICAgIFwiYm1hdHJpeFwiOiBbXCJbXCIsIFwiXVwiXSxcbiAgICAgIFwiQm1hdHJpeFwiOiBbXCJcXFxce1wiLCBcIlxcXFx9XCJdLFxuICAgICAgXCJ2bWF0cml4XCI6IFtcInxcIiwgXCJ8XCJdLFxuICAgICAgXCJWbWF0cml4XCI6IFtcIlxcXFxWZXJ0XCIsIFwiXFxcXFZlcnRcIl1cbiAgICB9W2NvbnRleHQuZW52TmFtZS5yZXBsYWNlKFwiKlwiLCBcIlwiKV07IC8vIFxcaHNraXAgLVxcYXJyYXljb2xzZXAgaW4gYW1zbWF0aFxuXG4gICAgbGV0IGNvbEFsaWduID0gXCJjXCI7XG4gICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgIGhza2lwQmVmb3JlQW5kQWZ0ZXI6IGZhbHNlLFxuICAgICAgY29sczogW3tcbiAgICAgICAgdHlwZTogXCJhbGlnblwiLFxuICAgICAgICBhbGlnbjogY29sQWxpZ25cbiAgICAgIH1dXG4gICAgfTtcblxuICAgIGlmIChjb250ZXh0LmVudk5hbWUuY2hhckF0KGNvbnRleHQuZW52TmFtZS5sZW5ndGggLSAxKSA9PT0gXCIqXCIpIHtcbiAgICAgIC8vIEl0J3Mgb25lIG9mIHRoZSBtYXRodG9vbHMgc3RhcnJlZCBmdW5jdGlvbnMuXG4gICAgICAvLyBQYXJzZSB0aGUgb3B0aW9uYWwgYWxpZ25tZW50IGFyZ3VtZW50LlxuICAgICAgY29uc3QgcGFyc2VyID0gY29udGV4dC5wYXJzZXI7XG4gICAgICBwYXJzZXIuY29uc3VtZVNwYWNlcygpO1xuXG4gICAgICBpZiAocGFyc2VyLmZldGNoKCkudGV4dCA9PT0gXCJbXCIpIHtcbiAgICAgICAgcGFyc2VyLmNvbnN1bWUoKTtcbiAgICAgICAgcGFyc2VyLmNvbnN1bWVTcGFjZXMoKTtcbiAgICAgICAgY29sQWxpZ24gPSBwYXJzZXIuZmV0Y2goKS50ZXh0O1xuXG4gICAgICAgIGlmIChcImxjclwiLmluZGV4T2YoY29sQWxpZ24pID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIkV4cGVjdGVkIGwgb3IgYyBvciByXCIsIHBhcnNlci5uZXh0VG9rZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyc2VyLmNvbnN1bWUoKTtcbiAgICAgICAgcGFyc2VyLmNvbnN1bWVTcGFjZXMoKTtcbiAgICAgICAgcGFyc2VyLmV4cGVjdChcIl1cIik7XG4gICAgICAgIHBhcnNlci5jb25zdW1lKCk7XG4gICAgICAgIHBheWxvYWQuY29scyA9IFt7XG4gICAgICAgICAgdHlwZTogXCJhbGlnblwiLFxuICAgICAgICAgIGFsaWduOiBjb2xBbGlnblxuICAgICAgICB9XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCByZXMgPSBwYXJzZUFycmF5KGNvbnRleHQucGFyc2VyLCBwYXlsb2FkLCBkQ2VsbFN0eWxlKGNvbnRleHQuZW52TmFtZSkpOyAvLyBQb3B1bGF0ZSBjb2xzIHdpdGggdGhlIGNvcnJlY3QgbnVtYmVyIG9mIGNvbHVtbiBhbGlnbm1lbnQgc3BlY3MuXG5cbiAgICBjb25zdCBudW1Db2xzID0gTWF0aC5tYXgoMCwgLi4ucmVzLmJvZHkubWFwKHJvdyA9PiByb3cubGVuZ3RoKSk7XG4gICAgcmVzLmNvbHMgPSBuZXcgQXJyYXkobnVtQ29scykuZmlsbCh7XG4gICAgICB0eXBlOiBcImFsaWduXCIsXG4gICAgICBhbGlnbjogY29sQWxpZ25cbiAgICB9KTtcbiAgICByZXR1cm4gZGVsaW1pdGVycyA/IHtcbiAgICAgIHR5cGU6IFwibGVmdHJpZ2h0XCIsXG4gICAgICBtb2RlOiBjb250ZXh0Lm1vZGUsXG4gICAgICBib2R5OiBbcmVzXSxcbiAgICAgIGxlZnQ6IGRlbGltaXRlcnNbMF0sXG4gICAgICByaWdodDogZGVsaW1pdGVyc1sxXSxcbiAgICAgIHJpZ2h0Q29sb3I6IHVuZGVmaW5lZCAvLyBcXHJpZ2h0IHVuaW5mbHVlbmNlZCBieSBcXGNvbG9yIGluIGFycmF5XG5cbiAgICB9IDogcmVzO1xuICB9LFxuXG4gIGh0bWxCdWlsZGVyOiBhcnJheV9odG1sQnVpbGRlcixcbiAgbWF0aG1sQnVpbGRlcjogYXJyYXlfbWF0aG1sQnVpbGRlclxufSk7XG5kZWZpbmVFbnZpcm9ubWVudCh7XG4gIHR5cGU6IFwiYXJyYXlcIixcbiAgbmFtZXM6IFtcInNtYWxsbWF0cml4XCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDBcbiAgfSxcblxuICBoYW5kbGVyKGNvbnRleHQpIHtcbiAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgYXJyYXlzdHJldGNoOiAwLjVcbiAgICB9O1xuICAgIGNvbnN0IHJlcyA9IHBhcnNlQXJyYXkoY29udGV4dC5wYXJzZXIsIHBheWxvYWQsIFwic2NyaXB0XCIpO1xuICAgIHJlcy5jb2xTZXBhcmF0aW9uVHlwZSA9IFwic21hbGxcIjtcbiAgICByZXR1cm4gcmVzO1xuICB9LFxuXG4gIGh0bWxCdWlsZGVyOiBhcnJheV9odG1sQnVpbGRlcixcbiAgbWF0aG1sQnVpbGRlcjogYXJyYXlfbWF0aG1sQnVpbGRlclxufSk7XG5kZWZpbmVFbnZpcm9ubWVudCh7XG4gIHR5cGU6IFwiYXJyYXlcIixcbiAgbmFtZXM6IFtcInN1YmFycmF5XCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDFcbiAgfSxcblxuICBoYW5kbGVyKGNvbnRleHQsIGFyZ3MpIHtcbiAgICAvLyBQYXJzaW5nIG9mIHtzdWJhcnJheX0gaXMgc2ltaWxhciB0byB7YXJyYXl9XG4gICAgY29uc3Qgc3ltTm9kZSA9IGNoZWNrU3ltYm9sTm9kZVR5cGUoYXJnc1swXSk7XG4gICAgY29uc3QgY29sYWxpZ24gPSBzeW1Ob2RlID8gW2FyZ3NbMF1dIDogYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJvcmRncm91cFwiKS5ib2R5O1xuICAgIGNvbnN0IGNvbHMgPSBjb2xhbGlnbi5tYXAoZnVuY3Rpb24gKG5kZSkge1xuICAgICAgY29uc3Qgbm9kZSA9IGFzc2VydFN5bWJvbE5vZGVUeXBlKG5kZSk7XG4gICAgICBjb25zdCBjYSA9IG5vZGUudGV4dDsgLy8ge3N1YmFycmF5fSBvbmx5IHJlY29nbml6ZXMgXCJsXCIgJiBcImNcIlxuXG4gICAgICBpZiAoXCJsY1wiLmluZGV4T2YoY2EpICE9PSAtMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwiYWxpZ25cIixcbiAgICAgICAgICBhbGlnbjogY2FcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiVW5rbm93biBjb2x1bW4gYWxpZ25tZW50OiBcIiArIGNhLCBuZGUpO1xuICAgIH0pO1xuXG4gICAgaWYgKGNvbHMubGVuZ3RoID4gMSkge1xuICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwie3N1YmFycmF5fSBjYW4gY29udGFpbiBvbmx5IG9uZSBjb2x1bW5cIik7XG4gICAgfVxuXG4gICAgbGV0IHJlcyA9IHtcbiAgICAgIGNvbHMsXG4gICAgICBoc2tpcEJlZm9yZUFuZEFmdGVyOiBmYWxzZSxcbiAgICAgIGFycmF5c3RyZXRjaDogMC41XG4gICAgfTtcbiAgICByZXMgPSBwYXJzZUFycmF5KGNvbnRleHQucGFyc2VyLCByZXMsIFwic2NyaXB0XCIpO1xuXG4gICAgaWYgKHJlcy5ib2R5Lmxlbmd0aCA+IDAgJiYgcmVzLmJvZHlbMF0ubGVuZ3RoID4gMSkge1xuICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwie3N1YmFycmF5fSBjYW4gY29udGFpbiBvbmx5IG9uZSBjb2x1bW5cIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfSxcblxuICBodG1sQnVpbGRlcjogYXJyYXlfaHRtbEJ1aWxkZXIsXG4gIG1hdGhtbEJ1aWxkZXI6IGFycmF5X21hdGhtbEJ1aWxkZXJcbn0pOyAvLyBBIGNhc2VzIGVudmlyb25tZW50IChpbiBhbXNtYXRoLnN0eSkgaXMgYWxtb3N0IGVxdWl2YWxlbnQgdG9cbi8vIFxcZGVmXFxhcnJheXN0cmV0Y2h7MS4yfSVcbi8vIFxcbGVmdFxce1xcYmVnaW57YXJyYXl9e0B7fWxAe1xccXVhZH1sQHt9fSDigKYgXFxlbmR7YXJyYXl9XFxyaWdodC5cbi8vIHtkY2FzZXN9IGlzIGEge2Nhc2VzfSBlbnZpcm9ubWVudCB3aGVyZSBjZWxscyBhcmUgc2V0IGluIFxcZGlzcGxheXN0eWxlLFxuLy8gYXMgZGVmaW5lZCBpbiBtYXRodG9vbHMuc3R5LlxuLy8ge3JjYXNlc30gaXMgYW5vdGhlciBtYXRodG9vbHMgZW52aXJvbm1lbnQuIEl0J3MgYnJhY2UgaXMgb24gdGhlIHJpZ2h0IHNpZGUuXG5cbmRlZmluZUVudmlyb25tZW50KHtcbiAgdHlwZTogXCJhcnJheVwiLFxuICBuYW1lczogW1wiY2FzZXNcIiwgXCJkY2FzZXNcIiwgXCJyY2FzZXNcIiwgXCJkcmNhc2VzXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDBcbiAgfSxcblxuICBoYW5kbGVyKGNvbnRleHQpIHtcbiAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgYXJyYXlzdHJldGNoOiAxLjIsXG4gICAgICBjb2xzOiBbe1xuICAgICAgICB0eXBlOiBcImFsaWduXCIsXG4gICAgICAgIGFsaWduOiBcImxcIixcbiAgICAgICAgcHJlZ2FwOiAwLFxuICAgICAgICAvLyBUT0RPKGtldmluYikgZ2V0IHRoZSBjdXJyZW50IHN0eWxlLlxuICAgICAgICAvLyBGb3Igbm93IHdlIHVzZSB0aGUgbWV0cmljcyBmb3IgVEVYVCBzdHlsZSB3aGljaCBpcyB3aGF0IHdlIHdlcmVcbiAgICAgICAgLy8gZG9pbmcgYmVmb3JlLiAgQmVmb3JlIGF0dGVtcHRpbmcgdG8gZ2V0IHRoZSBjdXJyZW50IHN0eWxlIHdlXG4gICAgICAgIC8vIHNob3VsZCBsb29rIGF0IFRlWCdzIGJlaGF2aW9yIGVzcGVjaWFsbHkgZm9yIFxcb3ZlciBhbmQgbWF0cmljZXMuXG4gICAgICAgIHBvc3RnYXA6IDEuMFxuICAgICAgICAvKiAxZW0gcXVhZCAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwiYWxpZ25cIixcbiAgICAgICAgYWxpZ246IFwibFwiLFxuICAgICAgICBwcmVnYXA6IDAsXG4gICAgICAgIHBvc3RnYXA6IDBcbiAgICAgIH1dXG4gICAgfTtcbiAgICBjb25zdCByZXMgPSBwYXJzZUFycmF5KGNvbnRleHQucGFyc2VyLCBwYXlsb2FkLCBkQ2VsbFN0eWxlKGNvbnRleHQuZW52TmFtZSkpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImxlZnRyaWdodFwiLFxuICAgICAgbW9kZTogY29udGV4dC5tb2RlLFxuICAgICAgYm9keTogW3Jlc10sXG4gICAgICBsZWZ0OiBjb250ZXh0LmVudk5hbWUuaW5kZXhPZihcInJcIikgPiAtMSA/IFwiLlwiIDogXCJcXFxce1wiLFxuICAgICAgcmlnaHQ6IGNvbnRleHQuZW52TmFtZS5pbmRleE9mKFwiclwiKSA+IC0xID8gXCJcXFxcfVwiIDogXCIuXCIsXG4gICAgICByaWdodENvbG9yOiB1bmRlZmluZWRcbiAgICB9O1xuICB9LFxuXG4gIGh0bWxCdWlsZGVyOiBhcnJheV9odG1sQnVpbGRlcixcbiAgbWF0aG1sQnVpbGRlcjogYXJyYXlfbWF0aG1sQnVpbGRlclxufSk7IC8vIEluIHRoZSBhbGlnbiBlbnZpcm9ubWVudCwgb25lIHVzZXMgYW1wZXJzYW5kcywgJiwgdG8gc3BlY2lmeSBudW1iZXIgb2Zcbi8vIGNvbHVtbnMgaW4gZWFjaCByb3csIGFuZCB0byBsb2NhdGUgc3BhY2luZyBiZXR3ZWVuIGVhY2ggY29sdW1uLlxuLy8gYWxpZ24gZ2V0cyBhdXRvbWF0aWMgbnVtYmVyaW5nLiBhbGlnbiogYW5kIGFsaWduZWQgZG8gbm90LlxuLy8gVGhlIGFsaWduZWRhdCBlbnZpcm9ubWVudCBjYW4gYmUgdXNlZCBpbiBtYXRoIG1vZGUuXG4vLyBOb3RlIHRoYXQgd2UgYXNzdW1lIFxcbm9tYWxsaW5lc2tpcGxpbWl0IHRvIGJlIHplcm8sXG4vLyBzbyB0aGF0IFxcc3RydXRAIGlzIHRoZSBzYW1lIGFzIFxcc3RydXQuXG5cbmRlZmluZUVudmlyb25tZW50KHtcbiAgdHlwZTogXCJhcnJheVwiLFxuICBuYW1lczogW1wiYWxpZ25cIiwgXCJhbGlnbipcIiwgXCJhbGlnbmVkXCIsIFwic3BsaXRcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMFxuICB9LFxuICBoYW5kbGVyOiBhbGlnbmVkSGFuZGxlcixcbiAgaHRtbEJ1aWxkZXI6IGFycmF5X2h0bWxCdWlsZGVyLFxuICBtYXRobWxCdWlsZGVyOiBhcnJheV9tYXRobWxCdWlsZGVyXG59KTsgLy8gQSBnYXRoZXJlZCBlbnZpcm9ubWVudCBpcyBsaWtlIGFuIGFycmF5IGVudmlyb25tZW50IHdpdGggb25lIGNlbnRlcmVkXG4vLyBjb2x1bW4sIGJ1dCB3aGVyZSByb3dzIGFyZSBjb25zaWRlcmVkIGxpbmVzIHNvIGdldCBcXGpvdCBsaW5lIHNwYWNpbmdcbi8vIGFuZCBjb250ZW50cyBhcmUgc2V0IGluIFxcZGlzcGxheXN0eWxlLlxuXG5kZWZpbmVFbnZpcm9ubWVudCh7XG4gIHR5cGU6IFwiYXJyYXlcIixcbiAgbmFtZXM6IFtcImdhdGhlcmVkXCIsIFwiZ2F0aGVyXCIsIFwiZ2F0aGVyKlwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwXG4gIH0sXG5cbiAgaGFuZGxlcihjb250ZXh0KSB7XG4gICAgaWYgKHV0aWxzLmNvbnRhaW5zKFtcImdhdGhlclwiLCBcImdhdGhlcipcIl0sIGNvbnRleHQuZW52TmFtZSkpIHtcbiAgICAgIHZhbGlkYXRlQW1zRW52aXJvbm1lbnRDb250ZXh0KGNvbnRleHQpO1xuICAgIH1cblxuICAgIGNvbnN0IHJlcyA9IHtcbiAgICAgIGNvbHM6IFt7XG4gICAgICAgIHR5cGU6IFwiYWxpZ25cIixcbiAgICAgICAgYWxpZ246IFwiY1wiXG4gICAgICB9XSxcbiAgICAgIGFkZEpvdDogdHJ1ZSxcbiAgICAgIGNvbFNlcGFyYXRpb25UeXBlOiBcImdhdGhlclwiLFxuICAgICAgYXV0b1RhZzogZ2V0QXV0b1RhZyhjb250ZXh0LmVudk5hbWUpLFxuICAgICAgZW1wdHlTaW5nbGVSb3c6IHRydWUsXG4gICAgICBsZXFubzogY29udGV4dC5wYXJzZXIuc2V0dGluZ3MubGVxbm9cbiAgICB9O1xuICAgIHJldHVybiBwYXJzZUFycmF5KGNvbnRleHQucGFyc2VyLCByZXMsIFwiZGlzcGxheVwiKTtcbiAgfSxcblxuICBodG1sQnVpbGRlcjogYXJyYXlfaHRtbEJ1aWxkZXIsXG4gIG1hdGhtbEJ1aWxkZXI6IGFycmF5X21hdGhtbEJ1aWxkZXJcbn0pOyAvLyBhbGlnbmF0IGVudmlyb25tZW50IGlzIGxpa2UgYW4gYWxpZ24gZW52aXJvbm1lbnQsIGJ1dCBvbmUgbXVzdCBleHBsaWNpdGx5XG4vLyBzcGVjaWZ5IG1heGltdW0gbnVtYmVyIG9mIGNvbHVtbnMgaW4gZWFjaCByb3csIGFuZCBjYW4gYWRqdXN0IHNwYWNpbmcgYmV0d2VlblxuLy8gZWFjaCBjb2x1bW5zLlxuXG5kZWZpbmVFbnZpcm9ubWVudCh7XG4gIHR5cGU6IFwiYXJyYXlcIixcbiAgbmFtZXM6IFtcImFsaWduYXRcIiwgXCJhbGlnbmF0KlwiLCBcImFsaWduZWRhdFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxXG4gIH0sXG4gIGhhbmRsZXI6IGFsaWduZWRIYW5kbGVyLFxuICBodG1sQnVpbGRlcjogYXJyYXlfaHRtbEJ1aWxkZXIsXG4gIG1hdGhtbEJ1aWxkZXI6IGFycmF5X21hdGhtbEJ1aWxkZXJcbn0pO1xuZGVmaW5lRW52aXJvbm1lbnQoe1xuICB0eXBlOiBcImFycmF5XCIsXG4gIG5hbWVzOiBbXCJlcXVhdGlvblwiLCBcImVxdWF0aW9uKlwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwXG4gIH0sXG5cbiAgaGFuZGxlcihjb250ZXh0KSB7XG4gICAgdmFsaWRhdGVBbXNFbnZpcm9ubWVudENvbnRleHQoY29udGV4dCk7XG4gICAgY29uc3QgcmVzID0ge1xuICAgICAgYXV0b1RhZzogZ2V0QXV0b1RhZyhjb250ZXh0LmVudk5hbWUpLFxuICAgICAgZW1wdHlTaW5nbGVSb3c6IHRydWUsXG4gICAgICBzaW5nbGVSb3c6IHRydWUsXG4gICAgICBtYXhOdW1Db2xzOiAxLFxuICAgICAgbGVxbm86IGNvbnRleHQucGFyc2VyLnNldHRpbmdzLmxlcW5vXG4gICAgfTtcbiAgICByZXR1cm4gcGFyc2VBcnJheShjb250ZXh0LnBhcnNlciwgcmVzLCBcImRpc3BsYXlcIik7XG4gIH0sXG5cbiAgaHRtbEJ1aWxkZXI6IGFycmF5X2h0bWxCdWlsZGVyLFxuICBtYXRobWxCdWlsZGVyOiBhcnJheV9tYXRobWxCdWlsZGVyXG59KTtcbmRlZmluZUVudmlyb25tZW50KHtcbiAgdHlwZTogXCJhcnJheVwiLFxuICBuYW1lczogW1wiQ0RcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMFxuICB9LFxuXG4gIGhhbmRsZXIoY29udGV4dCkge1xuICAgIHZhbGlkYXRlQW1zRW52aXJvbm1lbnRDb250ZXh0KGNvbnRleHQpO1xuICAgIHJldHVybiBwYXJzZUNEKGNvbnRleHQucGFyc2VyKTtcbiAgfSxcblxuICBodG1sQnVpbGRlcjogYXJyYXlfaHRtbEJ1aWxkZXIsXG4gIG1hdGhtbEJ1aWxkZXI6IGFycmF5X21hdGhtbEJ1aWxkZXJcbn0pO1xuZGVmaW5lTWFjcm8oXCJcXFxcbm9udW1iZXJcIiwgXCJcXFxcZ2RlZlxcXFxAZXFuc3d7MH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxub3RhZ1wiLCBcIlxcXFxub251bWJlclwiKTsgLy8gQ2F0Y2ggXFxobGluZSBvdXRzaWRlIGFycmF5IGVudmlyb25tZW50XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJ0ZXh0XCIsXG4gIC8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhpcyBpcy5cbiAgbmFtZXM6IFtcIlxcXFxobGluZVwiLCBcIlxcXFxoZGFzaGxpbmVcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMCxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlLFxuICAgIGFsbG93ZWRJbk1hdGg6IHRydWVcbiAgfSxcblxuICBoYW5kbGVyKGNvbnRleHQsIGFyZ3MpIHtcbiAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoY29udGV4dC5mdW5jTmFtZSArIFwiIHZhbGlkIG9ubHkgd2l0aGluIGFycmF5IGVudmlyb25tZW50XCIpO1xuICB9XG5cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Vudmlyb25tZW50cy5qc1xuXG5jb25zdCBlbnZpcm9ubWVudHMgPSBfZW52aXJvbm1lbnRzO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgc3JjX2Vudmlyb25tZW50cyA9IChlbnZpcm9ubWVudHMpOyAvLyBBbGwgZW52aXJvbm1lbnQgZGVmaW5pdGlvbnMgc2hvdWxkIGJlIGltcG9ydGVkIGJlbG93XG5cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy9lbnZpcm9ubWVudC5qc1xuXG5cblxuIC8vIEVudmlyb25tZW50IGRlbGltaXRlcnMuIEhUTUwvTWF0aE1MIHJlbmRlcmluZyBpcyBkZWZpbmVkIGluIHRoZSBjb3JyZXNwb25kaW5nXG4vLyBkZWZpbmVFbnZpcm9ubWVudCBkZWZpbml0aW9ucy5cblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImVudmlyb25tZW50XCIsXG4gIG5hbWVzOiBbXCJcXFxcYmVnaW5cIiwgXCJcXFxcZW5kXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYXJnVHlwZXM6IFtcInRleHRcIl1cbiAgfSxcblxuICBoYW5kbGVyKF9yZWYsIGFyZ3MpIHtcbiAgICBsZXQge1xuICAgICAgcGFyc2VyLFxuICAgICAgZnVuY05hbWVcbiAgICB9ID0gX3JlZjtcbiAgICBjb25zdCBuYW1lR3JvdXAgPSBhcmdzWzBdO1xuXG4gICAgaWYgKG5hbWVHcm91cC50eXBlICE9PSBcIm9yZGdyb3VwXCIpIHtcbiAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIkludmFsaWQgZW52aXJvbm1lbnQgbmFtZVwiLCBuYW1lR3JvdXApO1xuICAgIH1cblxuICAgIGxldCBlbnZOYW1lID0gXCJcIjtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZUdyb3VwLmJvZHkubGVuZ3RoOyArK2kpIHtcbiAgICAgIGVudk5hbWUgKz0gYXNzZXJ0Tm9kZVR5cGUobmFtZUdyb3VwLmJvZHlbaV0sIFwidGV4dG9yZFwiKS50ZXh0O1xuICAgIH1cblxuICAgIGlmIChmdW5jTmFtZSA9PT0gXCJcXFxcYmVnaW5cIikge1xuICAgICAgLy8gYmVnaW4uLi5lbmQgaXMgc2ltaWxhciB0byBsZWZ0Li4ucmlnaHRcbiAgICAgIGlmICghc3JjX2Vudmlyb25tZW50cy5oYXNPd25Qcm9wZXJ0eShlbnZOYW1lKSkge1xuICAgICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJObyBzdWNoIGVudmlyb25tZW50OiBcIiArIGVudk5hbWUsIG5hbWVHcm91cCk7XG4gICAgICB9IC8vIEJ1aWxkIHRoZSBlbnZpcm9ubWVudCBvYmplY3QuIEFyZ3VtZW50cyBhbmQgb3RoZXIgaW5mb3JtYXRpb24gd2lsbFxuICAgICAgLy8gYmUgbWFkZSBhdmFpbGFibGUgdG8gdGhlIGJlZ2luIGFuZCBlbmQgbWV0aG9kcyB1c2luZyBwcm9wZXJ0aWVzLlxuXG5cbiAgICAgIGNvbnN0IGVudiA9IHNyY19lbnZpcm9ubWVudHNbZW52TmFtZV07XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFyZ3MsXG4gICAgICAgIG9wdEFyZ3NcbiAgICAgIH0gPSBwYXJzZXIucGFyc2VBcmd1bWVudHMoXCJcXFxcYmVnaW57XCIgKyBlbnZOYW1lICsgXCJ9XCIsIGVudik7XG4gICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgICAgZW52TmFtZSxcbiAgICAgICAgcGFyc2VyXG4gICAgICB9O1xuICAgICAgY29uc3QgcmVzdWx0ID0gZW52LmhhbmRsZXIoY29udGV4dCwgYXJncywgb3B0QXJncyk7XG4gICAgICBwYXJzZXIuZXhwZWN0KFwiXFxcXGVuZFwiLCBmYWxzZSk7XG4gICAgICBjb25zdCBlbmROYW1lVG9rZW4gPSBwYXJzZXIubmV4dFRva2VuO1xuICAgICAgY29uc3QgZW5kID0gYXNzZXJ0Tm9kZVR5cGUocGFyc2VyLnBhcnNlRnVuY3Rpb24oKSwgXCJlbnZpcm9ubWVudFwiKTtcblxuICAgICAgaWYgKGVuZC5uYW1lICE9PSBlbnZOYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIk1pc21hdGNoOiBcXFxcYmVnaW57XCIgKyBlbnZOYW1lICsgXCJ9IG1hdGNoZWQgYnkgXFxcXGVuZHtcIiArIGVuZC5uYW1lICsgXCJ9XCIsIGVuZE5hbWVUb2tlbik7XG4gICAgICB9IC8vICRGbG93Rml4TWUsIFwiZW52aXJvbm1lbnRcIiBoYW5kbGVyIHJldHVybnMgYW4gZW52aXJvbm1lbnQgUGFyc2VOb2RlXG5cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJlbnZpcm9ubWVudFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBuYW1lOiBlbnZOYW1lLFxuICAgICAgbmFtZUdyb3VwXG4gICAgfTtcbiAgfVxuXG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mdW5jdGlvbnMvZm9udC5qc1xuLy8gVE9ETyhrZXZpbmIpOiBpbXBsZW1lbnQgXFxcXHNsIGFuZCBcXFxcc2NcblxuXG5cblxuXG5cbmNvbnN0IGZvbnRfaHRtbEJ1aWxkZXIgPSAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgZm9udCA9IGdyb3VwLmZvbnQ7XG4gIGNvbnN0IG5ld09wdGlvbnMgPSBvcHRpb25zLndpdGhGb250KGZvbnQpO1xuICByZXR1cm4gYnVpbGRHcm91cChncm91cC5ib2R5LCBuZXdPcHRpb25zKTtcbn07XG5cbmNvbnN0IGZvbnRfbWF0aG1sQnVpbGRlciA9IChncm91cCwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBmb250ID0gZ3JvdXAuZm9udDtcbiAgY29uc3QgbmV3T3B0aW9ucyA9IG9wdGlvbnMud2l0aEZvbnQoZm9udCk7XG4gIHJldHVybiBidWlsZE1hdGhNTF9idWlsZEdyb3VwKGdyb3VwLmJvZHksIG5ld09wdGlvbnMpO1xufTtcblxuY29uc3QgZm9udEFsaWFzZXMgPSB7XG4gIFwiXFxcXEJiYlwiOiBcIlxcXFxtYXRoYmJcIixcbiAgXCJcXFxcYm9sZFwiOiBcIlxcXFxtYXRoYmZcIixcbiAgXCJcXFxcZnJha1wiOiBcIlxcXFxtYXRoZnJha1wiLFxuICBcIlxcXFxibVwiOiBcIlxcXFxib2xkc3ltYm9sXCJcbn07XG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiZm9udFwiLFxuICBuYW1lczogWy8vIHN0eWxlcywgZXhjZXB0IFxcYm9sZHN5bWJvbCBkZWZpbmVkIGJlbG93XG4gIFwiXFxcXG1hdGhybVwiLCBcIlxcXFxtYXRoaXRcIiwgXCJcXFxcbWF0aGJmXCIsIFwiXFxcXG1hdGhub3JtYWxcIiwgLy8gZmFtaWxpZXNcbiAgXCJcXFxcbWF0aGJiXCIsIFwiXFxcXG1hdGhjYWxcIiwgXCJcXFxcbWF0aGZyYWtcIiwgXCJcXFxcbWF0aHNjclwiLCBcIlxcXFxtYXRoc2ZcIiwgXCJcXFxcbWF0aHR0XCIsIC8vIGFsaWFzZXMsIGV4Y2VwdCBcXGJtIGRlZmluZWQgYmVsb3dcbiAgXCJcXFxcQmJiXCIsIFwiXFxcXGJvbGRcIiwgXCJcXFxcZnJha1wiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFsbG93ZWRJbkFyZ3VtZW50OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6IChfcmVmLCBhcmdzKSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIHBhcnNlcixcbiAgICAgIGZ1bmNOYW1lXG4gICAgfSA9IF9yZWY7XG4gICAgY29uc3QgYm9keSA9IG5vcm1hbGl6ZUFyZ3VtZW50KGFyZ3NbMF0pO1xuICAgIGxldCBmdW5jID0gZnVuY05hbWU7XG5cbiAgICBpZiAoZnVuYyBpbiBmb250QWxpYXNlcykge1xuICAgICAgZnVuYyA9IGZvbnRBbGlhc2VzW2Z1bmNdO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImZvbnRcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgZm9udDogZnVuYy5zbGljZSgxKSxcbiAgICAgIGJvZHlcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogZm9udF9odG1sQnVpbGRlcixcbiAgbWF0aG1sQnVpbGRlcjogZm9udF9tYXRobWxCdWlsZGVyXG59KTtcbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJtY2xhc3NcIixcbiAgbmFtZXM6IFtcIlxcXFxib2xkc3ltYm9sXCIsIFwiXFxcXGJtXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDFcbiAgfSxcbiAgaGFuZGxlcjogKF9yZWYyLCBhcmdzKSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIHBhcnNlclxuICAgIH0gPSBfcmVmMjtcbiAgICBjb25zdCBib2R5ID0gYXJnc1swXTtcbiAgICBjb25zdCBpc0NoYXJhY3RlckJveCA9IHV0aWxzLmlzQ2hhcmFjdGVyQm94KGJvZHkpOyAvLyBhbXNic3kuc3R5J3MgXFxib2xkc3ltYm9sIHVzZXMgXFxiaW5yZWwgc3BhY2luZyB0byBpbmhlcml0IHRoZVxuICAgIC8vIGFyZ3VtZW50J3MgYmlufHJlbHxvcmQgc3RhdHVzXG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJtY2xhc3NcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbWNsYXNzOiBiaW5yZWxDbGFzcyhib2R5KSxcbiAgICAgIGJvZHk6IFt7XG4gICAgICAgIHR5cGU6IFwiZm9udFwiLFxuICAgICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgICAgZm9udDogXCJib2xkc3ltYm9sXCIsXG4gICAgICAgIGJvZHlcbiAgICAgIH1dLFxuICAgICAgaXNDaGFyYWN0ZXJCb3g6IGlzQ2hhcmFjdGVyQm94XG4gICAgfTtcbiAgfVxufSk7IC8vIE9sZCBmb250IGNoYW5naW5nIGZ1bmN0aW9uc1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiZm9udFwiLFxuICBuYW1lczogW1wiXFxcXHJtXCIsIFwiXFxcXHNmXCIsIFwiXFxcXHR0XCIsIFwiXFxcXGJmXCIsIFwiXFxcXGl0XCIsIFwiXFxcXGNhbFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcjogKF9yZWYzLCBhcmdzKSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIHBhcnNlcixcbiAgICAgIGZ1bmNOYW1lLFxuICAgICAgYnJlYWtPblRva2VuVGV4dFxuICAgIH0gPSBfcmVmMztcbiAgICBjb25zdCB7XG4gICAgICBtb2RlXG4gICAgfSA9IHBhcnNlcjtcbiAgICBjb25zdCBib2R5ID0gcGFyc2VyLnBhcnNlRXhwcmVzc2lvbih0cnVlLCBicmVha09uVG9rZW5UZXh0KTtcbiAgICBjb25zdCBzdHlsZSA9IFwibWF0aFwiICsgZnVuY05hbWUuc2xpY2UoMSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZm9udFwiLFxuICAgICAgbW9kZTogbW9kZSxcbiAgICAgIGZvbnQ6IHN0eWxlLFxuICAgICAgYm9keToge1xuICAgICAgICB0eXBlOiBcIm9yZGdyb3VwXCIsXG4gICAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgICBib2R5XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IGZvbnRfaHRtbEJ1aWxkZXIsXG4gIG1hdGhtbEJ1aWxkZXI6IGZvbnRfbWF0aG1sQnVpbGRlclxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZnVuY3Rpb25zL2dlbmZyYWMuanNcblxuXG5cblxuXG5cblxuXG5cblxuXG5jb25zdCBhZGp1c3RTdHlsZSA9IChzaXplLCBvcmlnaW5hbFN0eWxlKSA9PiB7XG4gIC8vIEZpZ3VyZSBvdXQgd2hhdCBzdHlsZSB0aGlzIGZyYWN0aW9uIHNob3VsZCBiZSBpbiBiYXNlZCBvbiB0aGVcbiAgLy8gZnVuY3Rpb24gdXNlZFxuICBsZXQgc3R5bGUgPSBvcmlnaW5hbFN0eWxlO1xuXG4gIGlmIChzaXplID09PSBcImRpc3BsYXlcIikge1xuICAgIC8vIEdldCBkaXNwbGF5IHN0eWxlIGFzIGEgZGVmYXVsdC5cbiAgICAvLyBJZiBpbmNvbWluZyBzdHlsZSBpcyBzdWIvc3VwLCB1c2Ugc3R5bGUudGV4dCgpIHRvIGdldCBjb3JyZWN0IHNpemUuXG4gICAgc3R5bGUgPSBzdHlsZS5pZCA+PSBzcmNfU3R5bGUuU0NSSVBULmlkID8gc3R5bGUudGV4dCgpIDogc3JjX1N0eWxlLkRJU1BMQVk7XG4gIH0gZWxzZSBpZiAoc2l6ZSA9PT0gXCJ0ZXh0XCIgJiYgc3R5bGUuc2l6ZSA9PT0gc3JjX1N0eWxlLkRJU1BMQVkuc2l6ZSkge1xuICAgIC8vIFdlJ3JlIGluIGEgXFx0ZnJhYyBidXQgaW5jb21pbmcgc3R5bGUgaXMgZGlzcGxheXN0eWxlLCBzbzpcbiAgICBzdHlsZSA9IHNyY19TdHlsZS5URVhUO1xuICB9IGVsc2UgaWYgKHNpemUgPT09IFwic2NyaXB0XCIpIHtcbiAgICBzdHlsZSA9IHNyY19TdHlsZS5TQ1JJUFQ7XG4gIH0gZWxzZSBpZiAoc2l6ZSA9PT0gXCJzY3JpcHRzY3JpcHRcIikge1xuICAgIHN0eWxlID0gc3JjX1N0eWxlLlNDUklQVFNDUklQVDtcbiAgfVxuXG4gIHJldHVybiBzdHlsZTtcbn07XG5cbmNvbnN0IGdlbmZyYWNfaHRtbEJ1aWxkZXIgPSAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgLy8gRnJhY3Rpb25zIGFyZSBoYW5kbGVkIGluIHRoZSBUZVhib29rIG9uIHBhZ2VzIDQ0NC00NDUsIHJ1bGVzIDE1KGEtZSkuXG4gIGNvbnN0IHN0eWxlID0gYWRqdXN0U3R5bGUoZ3JvdXAuc2l6ZSwgb3B0aW9ucy5zdHlsZSk7XG4gIGNvbnN0IG5zdHlsZSA9IHN0eWxlLmZyYWNOdW0oKTtcbiAgY29uc3QgZHN0eWxlID0gc3R5bGUuZnJhY0RlbigpO1xuICBsZXQgbmV3T3B0aW9ucztcbiAgbmV3T3B0aW9ucyA9IG9wdGlvbnMuaGF2aW5nU3R5bGUobnN0eWxlKTtcbiAgY29uc3QgbnVtZXJtID0gYnVpbGRHcm91cChncm91cC5udW1lciwgbmV3T3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgaWYgKGdyb3VwLmNvbnRpbnVlZCkge1xuICAgIC8vIFxcY2ZyYWMgaW5zZXJ0cyBhIFxcc3RydXQgaW50byB0aGUgbnVtZXJhdG9yLlxuICAgIC8vIEdldCBcXHN0cnV0IGRpbWVuc2lvbnMgZnJvbSBUZVhib29rIHBhZ2UgMzUzLlxuICAgIGNvbnN0IGhTdHJ1dCA9IDguNSAvIG9wdGlvbnMuZm9udE1ldHJpY3MoKS5wdFBlckVtO1xuICAgIGNvbnN0IGRTdHJ1dCA9IDMuNSAvIG9wdGlvbnMuZm9udE1ldHJpY3MoKS5wdFBlckVtO1xuICAgIG51bWVybS5oZWlnaHQgPSBudW1lcm0uaGVpZ2h0IDwgaFN0cnV0ID8gaFN0cnV0IDogbnVtZXJtLmhlaWdodDtcbiAgICBudW1lcm0uZGVwdGggPSBudW1lcm0uZGVwdGggPCBkU3RydXQgPyBkU3RydXQgOiBudW1lcm0uZGVwdGg7XG4gIH1cblxuICBuZXdPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdTdHlsZShkc3R5bGUpO1xuICBjb25zdCBkZW5vbW0gPSBidWlsZEdyb3VwKGdyb3VwLmRlbm9tLCBuZXdPcHRpb25zLCBvcHRpb25zKTtcbiAgbGV0IHJ1bGU7XG4gIGxldCBydWxlV2lkdGg7XG4gIGxldCBydWxlU3BhY2luZztcblxuICBpZiAoZ3JvdXAuaGFzQmFyTGluZSkge1xuICAgIGlmIChncm91cC5iYXJTaXplKSB7XG4gICAgICBydWxlV2lkdGggPSBjYWxjdWxhdGVTaXplKGdyb3VwLmJhclNpemUsIG9wdGlvbnMpO1xuICAgICAgcnVsZSA9IGJ1aWxkQ29tbW9uLm1ha2VMaW5lU3BhbihcImZyYWMtbGluZVwiLCBvcHRpb25zLCBydWxlV2lkdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBydWxlID0gYnVpbGRDb21tb24ubWFrZUxpbmVTcGFuKFwiZnJhYy1saW5lXCIsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJ1bGVXaWR0aCA9IHJ1bGUuaGVpZ2h0O1xuICAgIHJ1bGVTcGFjaW5nID0gcnVsZS5oZWlnaHQ7XG4gIH0gZWxzZSB7XG4gICAgcnVsZSA9IG51bGw7XG4gICAgcnVsZVdpZHRoID0gMDtcbiAgICBydWxlU3BhY2luZyA9IG9wdGlvbnMuZm9udE1ldHJpY3MoKS5kZWZhdWx0UnVsZVRoaWNrbmVzcztcbiAgfSAvLyBSdWxlIDE1YlxuXG5cbiAgbGV0IG51bVNoaWZ0O1xuICBsZXQgY2xlYXJhbmNlO1xuICBsZXQgZGVub21TaGlmdDtcblxuICBpZiAoc3R5bGUuc2l6ZSA9PT0gc3JjX1N0eWxlLkRJU1BMQVkuc2l6ZSB8fCBncm91cC5zaXplID09PSBcImRpc3BsYXlcIikge1xuICAgIG51bVNoaWZ0ID0gb3B0aW9ucy5mb250TWV0cmljcygpLm51bTE7XG5cbiAgICBpZiAocnVsZVdpZHRoID4gMCkge1xuICAgICAgY2xlYXJhbmNlID0gMyAqIHJ1bGVTcGFjaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGVhcmFuY2UgPSA3ICogcnVsZVNwYWNpbmc7XG4gICAgfVxuXG4gICAgZGVub21TaGlmdCA9IG9wdGlvbnMuZm9udE1ldHJpY3MoKS5kZW5vbTE7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHJ1bGVXaWR0aCA+IDApIHtcbiAgICAgIG51bVNoaWZ0ID0gb3B0aW9ucy5mb250TWV0cmljcygpLm51bTI7XG4gICAgICBjbGVhcmFuY2UgPSBydWxlU3BhY2luZztcbiAgICB9IGVsc2Uge1xuICAgICAgbnVtU2hpZnQgPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkubnVtMztcbiAgICAgIGNsZWFyYW5jZSA9IDMgKiBydWxlU3BhY2luZztcbiAgICB9XG5cbiAgICBkZW5vbVNoaWZ0ID0gb3B0aW9ucy5mb250TWV0cmljcygpLmRlbm9tMjtcbiAgfVxuXG4gIGxldCBmcmFjO1xuXG4gIGlmICghcnVsZSkge1xuICAgIC8vIFJ1bGUgMTVjXG4gICAgY29uc3QgY2FuZGlkYXRlQ2xlYXJhbmNlID0gbnVtU2hpZnQgLSBudW1lcm0uZGVwdGggLSAoZGVub21tLmhlaWdodCAtIGRlbm9tU2hpZnQpO1xuXG4gICAgaWYgKGNhbmRpZGF0ZUNsZWFyYW5jZSA8IGNsZWFyYW5jZSkge1xuICAgICAgbnVtU2hpZnQgKz0gMC41ICogKGNsZWFyYW5jZSAtIGNhbmRpZGF0ZUNsZWFyYW5jZSk7XG4gICAgICBkZW5vbVNoaWZ0ICs9IDAuNSAqIChjbGVhcmFuY2UgLSBjYW5kaWRhdGVDbGVhcmFuY2UpO1xuICAgIH1cblxuICAgIGZyYWMgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgcG9zaXRpb25UeXBlOiBcImluZGl2aWR1YWxTaGlmdFwiLFxuICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBkZW5vbW0sXG4gICAgICAgIHNoaWZ0OiBkZW5vbVNoaWZ0XG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBudW1lcm0sXG4gICAgICAgIHNoaWZ0OiAtbnVtU2hpZnRcbiAgICAgIH1dXG4gICAgfSwgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gUnVsZSAxNWRcbiAgICBjb25zdCBheGlzSGVpZ2h0ID0gb3B0aW9ucy5mb250TWV0cmljcygpLmF4aXNIZWlnaHQ7XG5cbiAgICBpZiAobnVtU2hpZnQgLSBudW1lcm0uZGVwdGggLSAoYXhpc0hlaWdodCArIDAuNSAqIHJ1bGVXaWR0aCkgPCBjbGVhcmFuY2UpIHtcbiAgICAgIG51bVNoaWZ0ICs9IGNsZWFyYW5jZSAtIChudW1TaGlmdCAtIG51bWVybS5kZXB0aCAtIChheGlzSGVpZ2h0ICsgMC41ICogcnVsZVdpZHRoKSk7XG4gICAgfVxuXG4gICAgaWYgKGF4aXNIZWlnaHQgLSAwLjUgKiBydWxlV2lkdGggLSAoZGVub21tLmhlaWdodCAtIGRlbm9tU2hpZnQpIDwgY2xlYXJhbmNlKSB7XG4gICAgICBkZW5vbVNoaWZ0ICs9IGNsZWFyYW5jZSAtIChheGlzSGVpZ2h0IC0gMC41ICogcnVsZVdpZHRoIC0gKGRlbm9tbS5oZWlnaHQgLSBkZW5vbVNoaWZ0KSk7XG4gICAgfVxuXG4gICAgY29uc3QgbWlkU2hpZnQgPSAtKGF4aXNIZWlnaHQgLSAwLjUgKiBydWxlV2lkdGgpO1xuICAgIGZyYWMgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgcG9zaXRpb25UeXBlOiBcImluZGl2aWR1YWxTaGlmdFwiLFxuICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBkZW5vbW0sXG4gICAgICAgIHNoaWZ0OiBkZW5vbVNoaWZ0XG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBydWxlLFxuICAgICAgICBzaGlmdDogbWlkU2hpZnRcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IG51bWVybSxcbiAgICAgICAgc2hpZnQ6IC1udW1TaGlmdFxuICAgICAgfV1cbiAgICB9LCBvcHRpb25zKTtcbiAgfSAvLyBTaW5jZSB3ZSBtYW51YWxseSBjaGFuZ2UgdGhlIHN0eWxlIHNvbWV0aW1lcyAod2l0aCBcXGRmcmFjIG9yIFxcdGZyYWMpLFxuICAvLyBhY2NvdW50IGZvciB0aGUgcG9zc2libGUgc2l6ZSBjaGFuZ2UgaGVyZS5cblxuXG4gIG5ld09wdGlvbnMgPSBvcHRpb25zLmhhdmluZ1N0eWxlKHN0eWxlKTtcbiAgZnJhYy5oZWlnaHQgKj0gbmV3T3B0aW9ucy5zaXplTXVsdGlwbGllciAvIG9wdGlvbnMuc2l6ZU11bHRpcGxpZXI7XG4gIGZyYWMuZGVwdGggKj0gbmV3T3B0aW9ucy5zaXplTXVsdGlwbGllciAvIG9wdGlvbnMuc2l6ZU11bHRpcGxpZXI7IC8vIFJ1bGUgMTVlXG5cbiAgbGV0IGRlbGltU2l6ZTtcblxuICBpZiAoc3R5bGUuc2l6ZSA9PT0gc3JjX1N0eWxlLkRJU1BMQVkuc2l6ZSkge1xuICAgIGRlbGltU2l6ZSA9IG9wdGlvbnMuZm9udE1ldHJpY3MoKS5kZWxpbTE7XG4gIH0gZWxzZSBpZiAoc3R5bGUuc2l6ZSA9PT0gc3JjX1N0eWxlLlNDUklQVFNDUklQVC5zaXplKSB7XG4gICAgZGVsaW1TaXplID0gb3B0aW9ucy5oYXZpbmdTdHlsZShzcmNfU3R5bGUuU0NSSVBUKS5mb250TWV0cmljcygpLmRlbGltMjtcbiAgfSBlbHNlIHtcbiAgICBkZWxpbVNpemUgPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkuZGVsaW0yO1xuICB9XG5cbiAgbGV0IGxlZnREZWxpbTtcbiAgbGV0IHJpZ2h0RGVsaW07XG5cbiAgaWYgKGdyb3VwLmxlZnREZWxpbSA9PSBudWxsKSB7XG4gICAgbGVmdERlbGltID0gbWFrZU51bGxEZWxpbWl0ZXIob3B0aW9ucywgW1wibW9wZW5cIl0pO1xuICB9IGVsc2Uge1xuICAgIGxlZnREZWxpbSA9IGRlbGltaXRlci5jdXN0b21TaXplZERlbGltKGdyb3VwLmxlZnREZWxpbSwgZGVsaW1TaXplLCB0cnVlLCBvcHRpb25zLmhhdmluZ1N0eWxlKHN0eWxlKSwgZ3JvdXAubW9kZSwgW1wibW9wZW5cIl0pO1xuICB9XG5cbiAgaWYgKGdyb3VwLmNvbnRpbnVlZCkge1xuICAgIHJpZ2h0RGVsaW0gPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXSk7IC8vIHplcm8gd2lkdGggZm9yIFxcY2ZyYWNcbiAgfSBlbHNlIGlmIChncm91cC5yaWdodERlbGltID09IG51bGwpIHtcbiAgICByaWdodERlbGltID0gbWFrZU51bGxEZWxpbWl0ZXIob3B0aW9ucywgW1wibWNsb3NlXCJdKTtcbiAgfSBlbHNlIHtcbiAgICByaWdodERlbGltID0gZGVsaW1pdGVyLmN1c3RvbVNpemVkRGVsaW0oZ3JvdXAucmlnaHREZWxpbSwgZGVsaW1TaXplLCB0cnVlLCBvcHRpb25zLmhhdmluZ1N0eWxlKHN0eWxlKSwgZ3JvdXAubW9kZSwgW1wibWNsb3NlXCJdKTtcbiAgfVxuXG4gIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtb3JkXCJdLmNvbmNhdChuZXdPcHRpb25zLnNpemluZ0NsYXNzZXMob3B0aW9ucykpLCBbbGVmdERlbGltLCBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtZnJhY1wiXSwgW2ZyYWNdKSwgcmlnaHREZWxpbV0sIG9wdGlvbnMpO1xufTtcblxuY29uc3QgZ2VuZnJhY19tYXRobWxCdWlsZGVyID0gKGdyb3VwLCBvcHRpb25zKSA9PiB7XG4gIGxldCBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtZnJhY1wiLCBbYnVpbGRNYXRoTUxfYnVpbGRHcm91cChncm91cC5udW1lciwgb3B0aW9ucyksIGJ1aWxkTWF0aE1MX2J1aWxkR3JvdXAoZ3JvdXAuZGVub20sIG9wdGlvbnMpXSk7XG5cbiAgaWYgKCFncm91cC5oYXNCYXJMaW5lKSB7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJsaW5ldGhpY2tuZXNzXCIsIFwiMHB4XCIpO1xuICB9IGVsc2UgaWYgKGdyb3VwLmJhclNpemUpIHtcbiAgICBjb25zdCBydWxlV2lkdGggPSBjYWxjdWxhdGVTaXplKGdyb3VwLmJhclNpemUsIG9wdGlvbnMpO1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibGluZXRoaWNrbmVzc1wiLCBtYWtlRW0ocnVsZVdpZHRoKSk7XG4gIH1cblxuICBjb25zdCBzdHlsZSA9IGFkanVzdFN0eWxlKGdyb3VwLnNpemUsIG9wdGlvbnMuc3R5bGUpO1xuXG4gIGlmIChzdHlsZS5zaXplICE9PSBvcHRpb25zLnN0eWxlLnNpemUpIHtcbiAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtc3R5bGVcIiwgW25vZGVdKTtcbiAgICBjb25zdCBpc0Rpc3BsYXkgPSBzdHlsZS5zaXplID09PSBzcmNfU3R5bGUuRElTUExBWS5zaXplID8gXCJ0cnVlXCIgOiBcImZhbHNlXCI7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJkaXNwbGF5c3R5bGVcIiwgaXNEaXNwbGF5KTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcInNjcmlwdGxldmVsXCIsIFwiMFwiKTtcbiAgfVxuXG4gIGlmIChncm91cC5sZWZ0RGVsaW0gIT0gbnVsbCB8fCBncm91cC5yaWdodERlbGltICE9IG51bGwpIHtcbiAgICBjb25zdCB3aXRoRGVsaW1zID0gW107XG5cbiAgICBpZiAoZ3JvdXAubGVmdERlbGltICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IGxlZnRPcCA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIiwgW25ldyBtYXRoTUxUcmVlLlRleHROb2RlKGdyb3VwLmxlZnREZWxpbS5yZXBsYWNlKFwiXFxcXFwiLCBcIlwiKSldKTtcbiAgICAgIGxlZnRPcC5zZXRBdHRyaWJ1dGUoXCJmZW5jZVwiLCBcInRydWVcIik7XG4gICAgICB3aXRoRGVsaW1zLnB1c2gobGVmdE9wKTtcbiAgICB9XG5cbiAgICB3aXRoRGVsaW1zLnB1c2gobm9kZSk7XG5cbiAgICBpZiAoZ3JvdXAucmlnaHREZWxpbSAhPSBudWxsKSB7XG4gICAgICBjb25zdCByaWdodE9wID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb1wiLCBbbmV3IG1hdGhNTFRyZWUuVGV4dE5vZGUoZ3JvdXAucmlnaHREZWxpbS5yZXBsYWNlKFwiXFxcXFwiLCBcIlwiKSldKTtcbiAgICAgIHJpZ2h0T3Auc2V0QXR0cmlidXRlKFwiZmVuY2VcIiwgXCJ0cnVlXCIpO1xuICAgICAgd2l0aERlbGltcy5wdXNoKHJpZ2h0T3ApO1xuICAgIH1cblxuICAgIHJldHVybiBtYWtlUm93KHdpdGhEZWxpbXMpO1xuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59O1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiZ2VuZnJhY1wiLFxuICBuYW1lczogW1wiXFxcXGRmcmFjXCIsIFwiXFxcXGZyYWNcIiwgXCJcXFxcdGZyYWNcIiwgXCJcXFxcZGJpbm9tXCIsIFwiXFxcXGJpbm9tXCIsIFwiXFxcXHRiaW5vbVwiLCBcIlxcXFxcXFxcYXRvcGZyYWNcIiwgLy8gY2Fu4oCZdCBiZSBlbnRlcmVkIGRpcmVjdGx5XG4gIFwiXFxcXFxcXFxicmFjZWZyYWNcIiwgXCJcXFxcXFxcXGJyYWNrZnJhY1wiIC8vIGRpdHRvXG4gIF0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMixcbiAgICBhbGxvd2VkSW5Bcmd1bWVudDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiAoX3JlZiwgYXJncykgPT4ge1xuICAgIGxldCB7XG4gICAgICBwYXJzZXIsXG4gICAgICBmdW5jTmFtZVxuICAgIH0gPSBfcmVmO1xuICAgIGNvbnN0IG51bWVyID0gYXJnc1swXTtcbiAgICBjb25zdCBkZW5vbSA9IGFyZ3NbMV07XG4gICAgbGV0IGhhc0JhckxpbmU7XG4gICAgbGV0IGxlZnREZWxpbSA9IG51bGw7XG4gICAgbGV0IHJpZ2h0RGVsaW0gPSBudWxsO1xuICAgIGxldCBzaXplID0gXCJhdXRvXCI7XG5cbiAgICBzd2l0Y2ggKGZ1bmNOYW1lKSB7XG4gICAgICBjYXNlIFwiXFxcXGRmcmFjXCI6XG4gICAgICBjYXNlIFwiXFxcXGZyYWNcIjpcbiAgICAgIGNhc2UgXCJcXFxcdGZyYWNcIjpcbiAgICAgICAgaGFzQmFyTGluZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiXFxcXFxcXFxhdG9wZnJhY1wiOlxuICAgICAgICBoYXNCYXJMaW5lID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiXFxcXGRiaW5vbVwiOlxuICAgICAgY2FzZSBcIlxcXFxiaW5vbVwiOlxuICAgICAgY2FzZSBcIlxcXFx0Ymlub21cIjpcbiAgICAgICAgaGFzQmFyTGluZSA9IGZhbHNlO1xuICAgICAgICBsZWZ0RGVsaW0gPSBcIihcIjtcbiAgICAgICAgcmlnaHREZWxpbSA9IFwiKVwiO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIlxcXFxcXFxcYnJhY2VmcmFjXCI6XG4gICAgICAgIGhhc0JhckxpbmUgPSBmYWxzZTtcbiAgICAgICAgbGVmdERlbGltID0gXCJcXFxce1wiO1xuICAgICAgICByaWdodERlbGltID0gXCJcXFxcfVwiO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIlxcXFxcXFxcYnJhY2tmcmFjXCI6XG4gICAgICAgIGhhc0JhckxpbmUgPSBmYWxzZTtcbiAgICAgICAgbGVmdERlbGltID0gXCJbXCI7XG4gICAgICAgIHJpZ2h0RGVsaW0gPSBcIl1cIjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXplZCBnZW5mcmFjIGNvbW1hbmRcIik7XG4gICAgfVxuXG4gICAgc3dpdGNoIChmdW5jTmFtZSkge1xuICAgICAgY2FzZSBcIlxcXFxkZnJhY1wiOlxuICAgICAgY2FzZSBcIlxcXFxkYmlub21cIjpcbiAgICAgICAgc2l6ZSA9IFwiZGlzcGxheVwiO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIlxcXFx0ZnJhY1wiOlxuICAgICAgY2FzZSBcIlxcXFx0Ymlub21cIjpcbiAgICAgICAgc2l6ZSA9IFwidGV4dFwiO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJnZW5mcmFjXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGNvbnRpbnVlZDogZmFsc2UsXG4gICAgICBudW1lcixcbiAgICAgIGRlbm9tLFxuICAgICAgaGFzQmFyTGluZSxcbiAgICAgIGxlZnREZWxpbSxcbiAgICAgIHJpZ2h0RGVsaW0sXG4gICAgICBzaXplLFxuICAgICAgYmFyU2l6ZTogbnVsbFxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiBnZW5mcmFjX2h0bWxCdWlsZGVyLFxuICBtYXRobWxCdWlsZGVyOiBnZW5mcmFjX21hdGhtbEJ1aWxkZXJcbn0pO1xuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImdlbmZyYWNcIixcbiAgbmFtZXM6IFtcIlxcXFxjZnJhY1wiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAyXG4gIH0sXG4gIGhhbmRsZXI6IChfcmVmMiwgYXJncykgPT4ge1xuICAgIGxldCB7XG4gICAgICBwYXJzZXIsXG4gICAgICBmdW5jTmFtZVxuICAgIH0gPSBfcmVmMjtcbiAgICBjb25zdCBudW1lciA9IGFyZ3NbMF07XG4gICAgY29uc3QgZGVub20gPSBhcmdzWzFdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImdlbmZyYWNcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgY29udGludWVkOiB0cnVlLFxuICAgICAgbnVtZXIsXG4gICAgICBkZW5vbSxcbiAgICAgIGhhc0JhckxpbmU6IHRydWUsXG4gICAgICBsZWZ0RGVsaW06IG51bGwsXG4gICAgICByaWdodERlbGltOiBudWxsLFxuICAgICAgc2l6ZTogXCJkaXNwbGF5XCIsXG4gICAgICBiYXJTaXplOiBudWxsXG4gICAgfTtcbiAgfVxufSk7IC8vIEluZml4IGdlbmVyYWxpemVkIGZyYWN0aW9ucyAtLSB0aGVzZSBhcmUgbm90IHJlbmRlcmVkIGRpcmVjdGx5LCBidXQgcmVwbGFjZWRcbi8vIGltbWVkaWF0ZWx5IGJ5IG9uZSBvZiB0aGUgdmFyaWFudHMgYWJvdmUuXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJpbmZpeFwiLFxuICBuYW1lczogW1wiXFxcXG92ZXJcIiwgXCJcXFxcY2hvb3NlXCIsIFwiXFxcXGF0b3BcIiwgXCJcXFxcYnJhY2VcIiwgXCJcXFxcYnJhY2tcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMCxcbiAgICBpbmZpeDogdHJ1ZVxuICB9LFxuXG4gIGhhbmRsZXIoX3JlZjMpIHtcbiAgICBsZXQge1xuICAgICAgcGFyc2VyLFxuICAgICAgZnVuY05hbWUsXG4gICAgICB0b2tlblxuICAgIH0gPSBfcmVmMztcbiAgICBsZXQgcmVwbGFjZVdpdGg7XG5cbiAgICBzd2l0Y2ggKGZ1bmNOYW1lKSB7XG4gICAgICBjYXNlIFwiXFxcXG92ZXJcIjpcbiAgICAgICAgcmVwbGFjZVdpdGggPSBcIlxcXFxmcmFjXCI7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiXFxcXGNob29zZVwiOlxuICAgICAgICByZXBsYWNlV2l0aCA9IFwiXFxcXGJpbm9tXCI7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiXFxcXGF0b3BcIjpcbiAgICAgICAgcmVwbGFjZVdpdGggPSBcIlxcXFxcXFxcYXRvcGZyYWNcIjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJcXFxcYnJhY2VcIjpcbiAgICAgICAgcmVwbGFjZVdpdGggPSBcIlxcXFxcXFxcYnJhY2VmcmFjXCI7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiXFxcXGJyYWNrXCI6XG4gICAgICAgIHJlcGxhY2VXaXRoID0gXCJcXFxcXFxcXGJyYWNrZnJhY1wiO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIGluZml4IGdlbmZyYWMgY29tbWFuZFwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJpbmZpeFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICByZXBsYWNlV2l0aCxcbiAgICAgIHRva2VuXG4gICAgfTtcbiAgfVxuXG59KTtcbmNvbnN0IHN0eWxBcnJheSA9IFtcImRpc3BsYXlcIiwgXCJ0ZXh0XCIsIFwic2NyaXB0XCIsIFwic2NyaXB0c2NyaXB0XCJdO1xuXG5jb25zdCBkZWxpbUZyb21WYWx1ZSA9IGZ1bmN0aW9uIChkZWxpbVN0cmluZykge1xuICBsZXQgZGVsaW0gPSBudWxsO1xuXG4gIGlmIChkZWxpbVN0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgZGVsaW0gPSBkZWxpbVN0cmluZztcbiAgICBkZWxpbSA9IGRlbGltID09PSBcIi5cIiA/IG51bGwgOiBkZWxpbTtcbiAgfVxuXG4gIHJldHVybiBkZWxpbTtcbn07XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJnZW5mcmFjXCIsXG4gIG5hbWVzOiBbXCJcXFxcZ2VuZnJhY1wiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiA2LFxuICAgIGFsbG93ZWRJbkFyZ3VtZW50OiB0cnVlLFxuICAgIGFyZ1R5cGVzOiBbXCJtYXRoXCIsIFwibWF0aFwiLCBcInNpemVcIiwgXCJ0ZXh0XCIsIFwibWF0aFwiLCBcIm1hdGhcIl1cbiAgfSxcblxuICBoYW5kbGVyKF9yZWY0LCBhcmdzKSB7XG4gICAgbGV0IHtcbiAgICAgIHBhcnNlclxuICAgIH0gPSBfcmVmNDtcbiAgICBjb25zdCBudW1lciA9IGFyZ3NbNF07XG4gICAgY29uc3QgZGVub20gPSBhcmdzWzVdOyAvLyBMb29rIGludG8gdGhlIHBhcnNlIG5vZGVzIHRvIGdldCB0aGUgZGVzaXJlZCBkZWxpbWl0ZXJzLlxuXG4gICAgY29uc3QgbGVmdE5vZGUgPSBub3JtYWxpemVBcmd1bWVudChhcmdzWzBdKTtcbiAgICBjb25zdCBsZWZ0RGVsaW0gPSBsZWZ0Tm9kZS50eXBlID09PSBcImF0b21cIiAmJiBsZWZ0Tm9kZS5mYW1pbHkgPT09IFwib3BlblwiID8gZGVsaW1Gcm9tVmFsdWUobGVmdE5vZGUudGV4dCkgOiBudWxsO1xuICAgIGNvbnN0IHJpZ2h0Tm9kZSA9IG5vcm1hbGl6ZUFyZ3VtZW50KGFyZ3NbMV0pO1xuICAgIGNvbnN0IHJpZ2h0RGVsaW0gPSByaWdodE5vZGUudHlwZSA9PT0gXCJhdG9tXCIgJiYgcmlnaHROb2RlLmZhbWlseSA9PT0gXCJjbG9zZVwiID8gZGVsaW1Gcm9tVmFsdWUocmlnaHROb2RlLnRleHQpIDogbnVsbDtcbiAgICBjb25zdCBiYXJOb2RlID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1syXSwgXCJzaXplXCIpO1xuICAgIGxldCBoYXNCYXJMaW5lO1xuICAgIGxldCBiYXJTaXplID0gbnVsbDtcblxuICAgIGlmIChiYXJOb2RlLmlzQmxhbmspIHtcbiAgICAgIC8vIFxcZ2VuZnJhYyBhY3RzIGRpZmZlcmVudGx5IHRoYW4gXFxhYm92ZS5cbiAgICAgIC8vIFxcZ2VuZnJhYyB0cmVhdHMgYW4gZW1wdHkgc2l6ZSBncm91cCBhcyBhIHNpZ25hbCB0byB1c2UgYVxuICAgICAgLy8gc3RhbmRhcmQgYmFyIHNpemUuIFxcYWJvdmUgd291bGQgc2VlIHNpemUgPSAwIGFuZCBvbWl0IHRoZSBiYXIuXG4gICAgICBoYXNCYXJMaW5lID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmFyU2l6ZSA9IGJhck5vZGUudmFsdWU7XG4gICAgICBoYXNCYXJMaW5lID0gYmFyU2l6ZS5udW1iZXIgPiAwO1xuICAgIH0gLy8gRmluZCBvdXQgaWYgd2Ugd2FudCBkaXNwbGF5c3R5bGUsIHRleHRzdHlsZSwgZXRjLlxuXG5cbiAgICBsZXQgc2l6ZSA9IFwiYXV0b1wiO1xuICAgIGxldCBzdHlsID0gYXJnc1szXTtcblxuICAgIGlmIChzdHlsLnR5cGUgPT09IFwib3JkZ3JvdXBcIikge1xuICAgICAgaWYgKHN0eWwuYm9keS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHRleHRPcmQgPSBhc3NlcnROb2RlVHlwZShzdHlsLmJvZHlbMF0sIFwidGV4dG9yZFwiKTtcbiAgICAgICAgc2l6ZSA9IHN0eWxBcnJheVtOdW1iZXIodGV4dE9yZC50ZXh0KV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWwgPSBhc3NlcnROb2RlVHlwZShzdHlsLCBcInRleHRvcmRcIik7XG4gICAgICBzaXplID0gc3R5bEFycmF5W051bWJlcihzdHlsLnRleHQpXTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJnZW5mcmFjXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIG51bWVyLFxuICAgICAgZGVub20sXG4gICAgICBjb250aW51ZWQ6IGZhbHNlLFxuICAgICAgaGFzQmFyTGluZSxcbiAgICAgIGJhclNpemUsXG4gICAgICBsZWZ0RGVsaW0sXG4gICAgICByaWdodERlbGltLFxuICAgICAgc2l6ZVxuICAgIH07XG4gIH0sXG5cbiAgaHRtbEJ1aWxkZXI6IGdlbmZyYWNfaHRtbEJ1aWxkZXIsXG4gIG1hdGhtbEJ1aWxkZXI6IGdlbmZyYWNfbWF0aG1sQnVpbGRlclxufSk7IC8vIFxcYWJvdmUgaXMgYW4gaW5maXggZnJhY3Rpb24gdGhhdCBhbHNvIGRlZmluZXMgYSBmcmFjdGlvbiBiYXIgc2l6ZS5cblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImluZml4XCIsXG4gIG5hbWVzOiBbXCJcXFxcYWJvdmVcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhcmdUeXBlczogW1wic2l6ZVwiXSxcbiAgICBpbmZpeDogdHJ1ZVxuICB9LFxuXG4gIGhhbmRsZXIoX3JlZjUsIGFyZ3MpIHtcbiAgICBsZXQge1xuICAgICAgcGFyc2VyLFxuICAgICAgZnVuY05hbWUsXG4gICAgICB0b2tlblxuICAgIH0gPSBfcmVmNTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJpbmZpeFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICByZXBsYWNlV2l0aDogXCJcXFxcXFxcXGFib3ZlZnJhY1wiLFxuICAgICAgc2l6ZTogYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJzaXplXCIpLnZhbHVlLFxuICAgICAgdG9rZW5cbiAgICB9O1xuICB9XG5cbn0pO1xuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImdlbmZyYWNcIixcbiAgbmFtZXM6IFtcIlxcXFxcXFxcYWJvdmVmcmFjXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDMsXG4gICAgYXJnVHlwZXM6IFtcIm1hdGhcIiwgXCJzaXplXCIsIFwibWF0aFwiXVxuICB9LFxuICBoYW5kbGVyOiAoX3JlZjYsIGFyZ3MpID0+IHtcbiAgICBsZXQge1xuICAgICAgcGFyc2VyLFxuICAgICAgZnVuY05hbWVcbiAgICB9ID0gX3JlZjY7XG4gICAgY29uc3QgbnVtZXIgPSBhcmdzWzBdO1xuICAgIGNvbnN0IGJhclNpemUgPSBhc3NlcnQoYXNzZXJ0Tm9kZVR5cGUoYXJnc1sxXSwgXCJpbmZpeFwiKS5zaXplKTtcbiAgICBjb25zdCBkZW5vbSA9IGFyZ3NbMl07XG4gICAgY29uc3QgaGFzQmFyTGluZSA9IGJhclNpemUubnVtYmVyID4gMDtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJnZW5mcmFjXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIG51bWVyLFxuICAgICAgZGVub20sXG4gICAgICBjb250aW51ZWQ6IGZhbHNlLFxuICAgICAgaGFzQmFyTGluZSxcbiAgICAgIGJhclNpemUsXG4gICAgICBsZWZ0RGVsaW06IG51bGwsXG4gICAgICByaWdodERlbGltOiBudWxsLFxuICAgICAgc2l6ZTogXCJhdXRvXCJcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogZ2VuZnJhY19odG1sQnVpbGRlcixcbiAgbWF0aG1sQnVpbGRlcjogZ2VuZnJhY19tYXRobWxCdWlsZGVyXG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mdW5jdGlvbnMvaG9yaXpCcmFjZS5qc1xuXG5cblxuXG5cblxuXG5cbi8vIE5PVEU6IFVubGlrZSBtb3N0IGBodG1sQnVpbGRlcmBzLCB0aGlzIG9uZSBoYW5kbGVzIG5vdCBvbmx5IFwiaG9yaXpCcmFjZVwiLCBidXRcbi8vIGFsc28gXCJzdXBzdWJcIiBzaW5jZSBhbiBvdmVyL3VuZGVyYnJhY2UgY2FuIGFmZmVjdCBzdXBlci9zdWJzY3JpcHRpbmcuXG5jb25zdCBob3JpekJyYWNlX2h0bWxCdWlsZGVyID0gKGdycCwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBzdHlsZSA9IG9wdGlvbnMuc3R5bGU7IC8vIFB1bGwgb3V0IHRoZSBgUGFyc2VOb2RlPFwiaG9yaXpCcmFjZVwiPmAgaWYgYGdycGAgaXMgYSBcInN1cHN1YlwiIG5vZGUuXG5cbiAgbGV0IHN1cFN1Ykdyb3VwO1xuICBsZXQgZ3JvdXA7XG5cbiAgaWYgKGdycC50eXBlID09PSBcInN1cHN1YlwiKSB7XG4gICAgLy8gUmVmOiBMYVRlWCBzb3VyY2UyZTogfX19fVxcbGltaXRzfVxuICAgIC8vIGkuZS4gTGFUZVggdHJlYXRzIHRoZSBicmFjZSBzaW1pbGFyIHRvIGFuIG9wIGFuZCBwYXNzZXMgaXRcbiAgICAvLyB3aXRoIFxcbGltaXRzLCBzbyB3ZSBuZWVkIHRvIGFzc2lnbiBzdXBzdWIgc3R5bGUuXG4gICAgc3VwU3ViR3JvdXAgPSBncnAuc3VwID8gYnVpbGRHcm91cChncnAuc3VwLCBvcHRpb25zLmhhdmluZ1N0eWxlKHN0eWxlLnN1cCgpKSwgb3B0aW9ucykgOiBidWlsZEdyb3VwKGdycC5zdWIsIG9wdGlvbnMuaGF2aW5nU3R5bGUoc3R5bGUuc3ViKCkpLCBvcHRpb25zKTtcbiAgICBncm91cCA9IGFzc2VydE5vZGVUeXBlKGdycC5iYXNlLCBcImhvcml6QnJhY2VcIik7XG4gIH0gZWxzZSB7XG4gICAgZ3JvdXAgPSBhc3NlcnROb2RlVHlwZShncnAsIFwiaG9yaXpCcmFjZVwiKTtcbiAgfSAvLyBCdWlsZCB0aGUgYmFzZSBncm91cFxuXG5cbiAgY29uc3QgYm9keSA9IGJ1aWxkR3JvdXAoZ3JvdXAuYmFzZSwgb3B0aW9ucy5oYXZpbmdCYXNlU3R5bGUoc3JjX1N0eWxlLkRJU1BMQVkpKTsgLy8gQ3JlYXRlIHRoZSBzdHJldGNoeSBlbGVtZW50XG5cbiAgY29uc3QgYnJhY2VCb2R5ID0gc3RyZXRjaHkuc3ZnU3Bhbihncm91cCwgb3B0aW9ucyk7IC8vIEdlbmVyYXRlIHRoZSB2bGlzdCwgd2l0aCB0aGUgYXBwcm9wcmlhdGUga2VybnMgICAgICAgIOKUj+KUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUk1xuICAvLyBUaGlzIGZpcnN0IHZsaXN0IGNvbnRhaW5zIHRoZSBjb250ZW50IGFuZCB0aGUgYnJhY2U6ICAgZXF1YXRpb25cblxuICBsZXQgdmxpc3Q7XG5cbiAgaWYgKGdyb3VwLmlzT3Zlcikge1xuICAgIHZsaXN0ID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHtcbiAgICAgIHBvc2l0aW9uVHlwZTogXCJmaXJzdEJhc2VsaW5lXCIsXG4gICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IGJvZHlcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJrZXJuXCIsXG4gICAgICAgIHNpemU6IDAuMVxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogYnJhY2VCb2R5XG4gICAgICB9XVxuICAgIH0sIG9wdGlvbnMpOyAvLyAkRmxvd0ZpeE1lOiBSZXBsYWNlIHRoaXMgd2l0aCBwYXNzaW5nIFwic3ZnLWFsaWduXCIgaW50byBtYWtlVkxpc3QuXG5cbiAgICB2bGlzdC5jaGlsZHJlblswXS5jaGlsZHJlblswXS5jaGlsZHJlblsxXS5jbGFzc2VzLnB1c2goXCJzdmctYWxpZ25cIik7XG4gIH0gZWxzZSB7XG4gICAgdmxpc3QgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgcG9zaXRpb25UeXBlOiBcImJvdHRvbVwiLFxuICAgICAgcG9zaXRpb25EYXRhOiBib2R5LmRlcHRoICsgMC4xICsgYnJhY2VCb2R5LmhlaWdodCxcbiAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogYnJhY2VCb2R5XG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwia2VyblwiLFxuICAgICAgICBzaXplOiAwLjFcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IGJvZHlcbiAgICAgIH1dXG4gICAgfSwgb3B0aW9ucyk7IC8vICRGbG93Rml4TWU6IFJlcGxhY2UgdGhpcyB3aXRoIHBhc3NpbmcgXCJzdmctYWxpZ25cIiBpbnRvIG1ha2VWTGlzdC5cblxuICAgIHZsaXN0LmNoaWxkcmVuWzBdLmNoaWxkcmVuWzBdLmNoaWxkcmVuWzBdLmNsYXNzZXMucHVzaChcInN2Zy1hbGlnblwiKTtcbiAgfVxuXG4gIGlmIChzdXBTdWJHcm91cCkge1xuICAgIC8vIFRvIHdyaXRlIHRoZSBzdXBzdWIsIHdyYXAgdGhlIGZpcnN0IHZsaXN0IGluIGFub3RoZXIgdmxpc3Q6XG4gICAgLy8gVGhleSBjYW4ndCBhbGwgZ28gaW4gdGhlIHNhbWUgdmxpc3QsIGJlY2F1c2UgdGhlIG5vdGUgbWlnaHQgYmVcbiAgICAvLyB3aWRlciB0aGFuIHRoZSBlcXVhdGlvbi4gV2Ugd2FudCB0aGUgZXF1YXRpb24gdG8gY29udHJvbCB0aGVcbiAgICAvLyBicmFjZSB3aWR0aC5cbiAgICAvLyAgICAgIG5vdGUgICAgICAgICAgbG9uZyBub3RlICAgICAgICAgICBsb25nIG5vdGVcbiAgICAvLyAgIOKUj+KUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUkyAgIG9yICAgIOKUj+KUgeKUgeKUgeKUkyAgICAgbm90ICAgIOKUj+KUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUk1xuICAgIC8vICAgIGVxdWF0aW9uICAgICAgICAgICBlcW4gICAgICAgICAgICAgICAgIGVxblxuICAgIGNvbnN0IHZTcGFuID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibW9yZFwiLCBncm91cC5pc092ZXIgPyBcIm1vdmVyXCIgOiBcIm11bmRlclwiXSwgW3ZsaXN0XSwgb3B0aW9ucyk7XG5cbiAgICBpZiAoZ3JvdXAuaXNPdmVyKSB7XG4gICAgICB2bGlzdCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICAgIHBvc2l0aW9uVHlwZTogXCJmaXJzdEJhc2VsaW5lXCIsXG4gICAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICAgIGVsZW06IHZTcGFuXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB0eXBlOiBcImtlcm5cIixcbiAgICAgICAgICBzaXplOiAwLjJcbiAgICAgICAgfSwge1xuICAgICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICAgIGVsZW06IHN1cFN1Ykdyb3VwXG4gICAgICAgIH1dXG4gICAgICB9LCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmxpc3QgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgICBwb3NpdGlvblR5cGU6IFwiYm90dG9tXCIsXG4gICAgICAgIHBvc2l0aW9uRGF0YTogdlNwYW4uZGVwdGggKyAwLjIgKyBzdXBTdWJHcm91cC5oZWlnaHQgKyBzdXBTdWJHcm91cC5kZXB0aCxcbiAgICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgICAgZWxlbTogc3VwU3ViR3JvdXBcbiAgICAgICAgfSwge1xuICAgICAgICAgIHR5cGU6IFwia2VyblwiLFxuICAgICAgICAgIHNpemU6IDAuMlxuICAgICAgICB9LCB7XG4gICAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgICAgZWxlbTogdlNwYW5cbiAgICAgICAgfV1cbiAgICAgIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtb3JkXCIsIGdyb3VwLmlzT3ZlciA/IFwibW92ZXJcIiA6IFwibXVuZGVyXCJdLCBbdmxpc3RdLCBvcHRpb25zKTtcbn07XG5cbmNvbnN0IGhvcml6QnJhY2VfbWF0aG1sQnVpbGRlciA9IChncm91cCwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBhY2NlbnROb2RlID0gc3RyZXRjaHkubWF0aE1Mbm9kZShncm91cC5sYWJlbCk7XG4gIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShncm91cC5pc092ZXIgPyBcIm1vdmVyXCIgOiBcIm11bmRlclwiLCBbYnVpbGRNYXRoTUxfYnVpbGRHcm91cChncm91cC5iYXNlLCBvcHRpb25zKSwgYWNjZW50Tm9kZV0pO1xufTsgLy8gSG9yaXpvbnRhbCBzdHJldGNoeSBicmFjZXNcblxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiaG9yaXpCcmFjZVwiLFxuICBuYW1lczogW1wiXFxcXG92ZXJicmFjZVwiLCBcIlxcXFx1bmRlcmJyYWNlXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDFcbiAgfSxcblxuICBoYW5kbGVyKF9yZWYsIGFyZ3MpIHtcbiAgICBsZXQge1xuICAgICAgcGFyc2VyLFxuICAgICAgZnVuY05hbWVcbiAgICB9ID0gX3JlZjtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJob3JpekJyYWNlXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGxhYmVsOiBmdW5jTmFtZSxcbiAgICAgIGlzT3ZlcjogL15cXFxcb3Zlci8udGVzdChmdW5jTmFtZSksXG4gICAgICBiYXNlOiBhcmdzWzBdXG4gICAgfTtcbiAgfSxcblxuICBodG1sQnVpbGRlcjogaG9yaXpCcmFjZV9odG1sQnVpbGRlcixcbiAgbWF0aG1sQnVpbGRlcjogaG9yaXpCcmFjZV9tYXRobWxCdWlsZGVyXG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mdW5jdGlvbnMvaHJlZi5qc1xuXG5cblxuXG5cblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImhyZWZcIixcbiAgbmFtZXM6IFtcIlxcXFxocmVmXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDIsXG4gICAgYXJnVHlwZXM6IFtcInVybFwiLCBcIm9yaWdpbmFsXCJdLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcjogKF9yZWYsIGFyZ3MpID0+IHtcbiAgICBsZXQge1xuICAgICAgcGFyc2VyXG4gICAgfSA9IF9yZWY7XG4gICAgY29uc3QgYm9keSA9IGFyZ3NbMV07XG4gICAgY29uc3QgaHJlZiA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwidXJsXCIpLnVybDtcblxuICAgIGlmICghcGFyc2VyLnNldHRpbmdzLmlzVHJ1c3RlZCh7XG4gICAgICBjb21tYW5kOiBcIlxcXFxocmVmXCIsXG4gICAgICB1cmw6IGhyZWZcbiAgICB9KSkge1xuICAgICAgcmV0dXJuIHBhcnNlci5mb3JtYXRVbnN1cHBvcnRlZENtZChcIlxcXFxocmVmXCIpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImhyZWZcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgaHJlZixcbiAgICAgIGJvZHk6IG9yZGFyZ3VtZW50KGJvZHkpXG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IChncm91cCwgb3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IGVsZW1lbnRzID0gYnVpbGRFeHByZXNzaW9uKGdyb3VwLmJvZHksIG9wdGlvbnMsIGZhbHNlKTtcbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZUFuY2hvcihncm91cC5ocmVmLCBbXSwgZWxlbWVudHMsIG9wdGlvbnMpO1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgICBsZXQgbWF0aCA9IGJ1aWxkRXhwcmVzc2lvblJvdyhncm91cC5ib2R5LCBvcHRpb25zKTtcblxuICAgIGlmICghKG1hdGggaW5zdGFuY2VvZiBNYXRoTm9kZSkpIHtcbiAgICAgIG1hdGggPSBuZXcgTWF0aE5vZGUoXCJtcm93XCIsIFttYXRoXSk7XG4gICAgfVxuXG4gICAgbWF0aC5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIGdyb3VwLmhyZWYpO1xuICAgIHJldHVybiBtYXRoO1xuICB9XG59KTtcbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJocmVmXCIsXG4gIG5hbWVzOiBbXCJcXFxcdXJsXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYXJnVHlwZXM6IFtcInVybFwiXSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6IChfcmVmMiwgYXJncykgPT4ge1xuICAgIGxldCB7XG4gICAgICBwYXJzZXJcbiAgICB9ID0gX3JlZjI7XG4gICAgY29uc3QgaHJlZiA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwidXJsXCIpLnVybDtcblxuICAgIGlmICghcGFyc2VyLnNldHRpbmdzLmlzVHJ1c3RlZCh7XG4gICAgICBjb21tYW5kOiBcIlxcXFx1cmxcIixcbiAgICAgIHVybDogaHJlZlxuICAgIH0pKSB7XG4gICAgICByZXR1cm4gcGFyc2VyLmZvcm1hdFVuc3VwcG9ydGVkQ21kKFwiXFxcXHVybFwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBjaGFycyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBocmVmLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgYyA9IGhyZWZbaV07XG5cbiAgICAgIGlmIChjID09PSBcIn5cIikge1xuICAgICAgICBjID0gXCJcXFxcdGV4dGFzY2lpdGlsZGVcIjtcbiAgICAgIH1cblxuICAgICAgY2hhcnMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwidGV4dG9yZFwiLFxuICAgICAgICBtb2RlOiBcInRleHRcIixcbiAgICAgICAgdGV4dDogY1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgYm9keSA9IHtcbiAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBmb250OiBcIlxcXFx0ZXh0dHRcIixcbiAgICAgIGJvZHk6IGNoYXJzXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJocmVmXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGhyZWYsXG4gICAgICBib2R5OiBvcmRhcmd1bWVudChib2R5KVxuICAgIH07XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy9oYm94LmpzXG5cblxuXG5cbiAvLyBcXGhib3ggaXMgcHJvdmlkZWQgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBMYVRlWCBcXHZjZW50ZXIuXG4vLyBJbiBMYVRlWCwgXFx2Y2VudGVyIGNhbiBhY3Qgb25seSBvbiBhIGJveCwgYXMgaW5cbi8vIFxcdmNlbnRlcntcXGhib3h7JFxcZnJhY3thK2J9e1xcZGZyYWN7Y317ZH19JH19XG4vLyBUaGlzIGZ1bmN0aW9uIGJ5IGl0c2VsZiBkb2Vzbid0IGRvIGFueXRoaW5nIGJ1dCBwcmV2ZW50IGEgc29mdCBsaW5lIGJyZWFrLlxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiaGJveFwiLFxuICBuYW1lczogW1wiXFxcXGhib3hcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhcmdUeXBlczogW1widGV4dFwiXSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlLFxuICAgIHByaW1pdGl2ZTogdHJ1ZVxuICB9LFxuXG4gIGhhbmRsZXIoX3JlZiwgYXJncykge1xuICAgIGxldCB7XG4gICAgICBwYXJzZXJcbiAgICB9ID0gX3JlZjtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJoYm94XCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGJvZHk6IG9yZGFyZ3VtZW50KGFyZ3NbMF0pXG4gICAgfTtcbiAgfSxcblxuICBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGVsZW1lbnRzID0gYnVpbGRFeHByZXNzaW9uKGdyb3VwLmJvZHksIG9wdGlvbnMsIGZhbHNlKTtcbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZUZyYWdtZW50KGVsZW1lbnRzKTtcbiAgfSxcblxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiLCBidWlsZE1hdGhNTF9idWlsZEV4cHJlc3Npb24oZ3JvdXAuYm9keSwgb3B0aW9ucykpO1xuICB9XG5cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy9odG1sLmpzXG5cblxuXG5cblxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiaHRtbFwiLFxuICBuYW1lczogW1wiXFxcXGh0bWxDbGFzc1wiLCBcIlxcXFxodG1sSWRcIiwgXCJcXFxcaHRtbFN0eWxlXCIsIFwiXFxcXGh0bWxEYXRhXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDIsXG4gICAgYXJnVHlwZXM6IFtcInJhd1wiLCBcIm9yaWdpbmFsXCJdLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcjogKF9yZWYsIGFyZ3MpID0+IHtcbiAgICBsZXQge1xuICAgICAgcGFyc2VyLFxuICAgICAgZnVuY05hbWUsXG4gICAgICB0b2tlblxuICAgIH0gPSBfcmVmO1xuICAgIGNvbnN0IHZhbHVlID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJyYXdcIikuc3RyaW5nO1xuICAgIGNvbnN0IGJvZHkgPSBhcmdzWzFdO1xuXG4gICAgaWYgKHBhcnNlci5zZXR0aW5ncy5zdHJpY3QpIHtcbiAgICAgIHBhcnNlci5zZXR0aW5ncy5yZXBvcnROb25zdHJpY3QoXCJodG1sRXh0ZW5zaW9uXCIsIFwiSFRNTCBleHRlbnNpb24gaXMgZGlzYWJsZWQgb24gc3RyaWN0IG1vZGVcIik7XG4gICAgfVxuXG4gICAgbGV0IHRydXN0Q29udGV4dDtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0ge307XG5cbiAgICBzd2l0Y2ggKGZ1bmNOYW1lKSB7XG4gICAgICBjYXNlIFwiXFxcXGh0bWxDbGFzc1wiOlxuICAgICAgICBhdHRyaWJ1dGVzLmNsYXNzID0gdmFsdWU7XG4gICAgICAgIHRydXN0Q29udGV4dCA9IHtcbiAgICAgICAgICBjb21tYW5kOiBcIlxcXFxodG1sQ2xhc3NcIixcbiAgICAgICAgICBjbGFzczogdmFsdWVcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJcXFxcaHRtbElkXCI6XG4gICAgICAgIGF0dHJpYnV0ZXMuaWQgPSB2YWx1ZTtcbiAgICAgICAgdHJ1c3RDb250ZXh0ID0ge1xuICAgICAgICAgIGNvbW1hbmQ6IFwiXFxcXGh0bWxJZFwiLFxuICAgICAgICAgIGlkOiB2YWx1ZVxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIlxcXFxodG1sU3R5bGVcIjpcbiAgICAgICAgYXR0cmlidXRlcy5zdHlsZSA9IHZhbHVlO1xuICAgICAgICB0cnVzdENvbnRleHQgPSB7XG4gICAgICAgICAgY29tbWFuZDogXCJcXFxcaHRtbFN0eWxlXCIsXG4gICAgICAgICAgc3R5bGU6IHZhbHVlXG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiXFxcXGh0bWxEYXRhXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBkYXRhID0gdmFsdWUuc3BsaXQoXCIsXCIpO1xuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBrZXlWYWwgPSBkYXRhW2ldLnNwbGl0KFwiPVwiKTtcblxuICAgICAgICAgICAgaWYgKGtleVZhbC5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiRXJyb3IgcGFyc2luZyBrZXktdmFsdWUgZm9yIFxcXFxodG1sRGF0YVwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXR0cmlidXRlc1tcImRhdGEtXCIgKyBrZXlWYWxbMF0udHJpbSgpXSA9IGtleVZhbFsxXS50cmltKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdHJ1c3RDb250ZXh0ID0ge1xuICAgICAgICAgICAgY29tbWFuZDogXCJcXFxcaHRtbERhdGFcIixcbiAgICAgICAgICAgIGF0dHJpYnV0ZXNcbiAgICAgICAgICB9O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXplZCBodG1sIGNvbW1hbmRcIik7XG4gICAgfVxuXG4gICAgaWYgKCFwYXJzZXIuc2V0dGluZ3MuaXNUcnVzdGVkKHRydXN0Q29udGV4dCkpIHtcbiAgICAgIHJldHVybiBwYXJzZXIuZm9ybWF0VW5zdXBwb3J0ZWRDbWQoZnVuY05hbWUpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImh0bWxcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgYXR0cmlidXRlcyxcbiAgICAgIGJvZHk6IG9yZGFyZ3VtZW50KGJvZHkpXG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IChncm91cCwgb3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IGVsZW1lbnRzID0gYnVpbGRFeHByZXNzaW9uKGdyb3VwLmJvZHksIG9wdGlvbnMsIGZhbHNlKTtcbiAgICBjb25zdCBjbGFzc2VzID0gW1wiZW5jbG9zaW5nXCJdO1xuXG4gICAgaWYgKGdyb3VwLmF0dHJpYnV0ZXMuY2xhc3MpIHtcbiAgICAgIGNsYXNzZXMucHVzaCguLi5ncm91cC5hdHRyaWJ1dGVzLmNsYXNzLnRyaW0oKS5zcGxpdCgvXFxzKy8pKTtcbiAgICB9XG5cbiAgICBjb25zdCBzcGFuID0gYnVpbGRDb21tb24ubWFrZVNwYW4oY2xhc3NlcywgZWxlbWVudHMsIG9wdGlvbnMpO1xuXG4gICAgZm9yIChjb25zdCBhdHRyIGluIGdyb3VwLmF0dHJpYnV0ZXMpIHtcbiAgICAgIGlmIChhdHRyICE9PSBcImNsYXNzXCIgJiYgZ3JvdXAuYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShhdHRyKSkge1xuICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShhdHRyLCBncm91cC5hdHRyaWJ1dGVzW2F0dHJdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3BhbjtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogKGdyb3VwLCBvcHRpb25zKSA9PiB7XG4gICAgcmV0dXJuIGJ1aWxkRXhwcmVzc2lvblJvdyhncm91cC5ib2R5LCBvcHRpb25zKTtcbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZnVuY3Rpb25zL2h0bWxtYXRobWwuanNcblxuXG5cblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImh0bWxtYXRobWxcIixcbiAgbmFtZXM6IFtcIlxcXFxodG1sQG1hdGhtbFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAyLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcjogKF9yZWYsIGFyZ3MpID0+IHtcbiAgICBsZXQge1xuICAgICAgcGFyc2VyXG4gICAgfSA9IF9yZWY7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiaHRtbG1hdGhtbFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBodG1sOiBvcmRhcmd1bWVudChhcmdzWzBdKSxcbiAgICAgIG1hdGhtbDogb3JkYXJndW1lbnQoYXJnc1sxXSlcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogKGdyb3VwLCBvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgZWxlbWVudHMgPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAuaHRtbCwgb3B0aW9ucywgZmFsc2UpO1xuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlRnJhZ21lbnQoZWxlbWVudHMpO1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgICByZXR1cm4gYnVpbGRFeHByZXNzaW9uUm93KGdyb3VwLm1hdGhtbCwgb3B0aW9ucyk7XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy9pbmNsdWRlZ3JhcGhpY3MuanNcblxuXG5cblxuXG5cblxuY29uc3Qgc2l6ZURhdGEgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIGlmICgvXlstK10/ICooXFxkKyhcXC5cXGQqKT98XFwuXFxkKykkLy50ZXN0KHN0cikpIHtcbiAgICAvLyBzdHIgaXMgYSBudW1iZXIgd2l0aCBubyB1bml0IHNwZWNpZmllZC5cbiAgICAvLyBkZWZhdWx0IHVuaXQgaXMgYnAsIHBlciBncmFwaGl4IHBhY2thZ2UuXG4gICAgcmV0dXJuIHtcbiAgICAgIG51bWJlcjogK3N0cixcbiAgICAgIHVuaXQ6IFwiYnBcIlxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbWF0Y2ggPSAvKFstK10/KSAqKFxcZCsoPzpcXC5cXGQqKT98XFwuXFxkKykgKihbYS16XXsyfSkvLmV4ZWMoc3RyKTtcblxuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIkludmFsaWQgc2l6ZTogJ1wiICsgc3RyICsgXCInIGluIFxcXFxpbmNsdWRlZ3JhcGhpY3NcIik7XG4gICAgfVxuXG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgIG51bWJlcjogKyhtYXRjaFsxXSArIG1hdGNoWzJdKSxcbiAgICAgIC8vIHNpZ24gKyBtYWduaXR1ZGUsIGNhc3QgdG8gbnVtYmVyXG4gICAgICB1bml0OiBtYXRjaFszXVxuICAgIH07XG5cbiAgICBpZiAoIXZhbGlkVW5pdChkYXRhKSkge1xuICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiSW52YWxpZCB1bml0OiAnXCIgKyBkYXRhLnVuaXQgKyBcIicgaW4gXFxcXGluY2x1ZGVncmFwaGljcy5cIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbn07XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJpbmNsdWRlZ3JhcGhpY3NcIixcbiAgbmFtZXM6IFtcIlxcXFxpbmNsdWRlZ3JhcGhpY3NcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBudW1PcHRpb25hbEFyZ3M6IDEsXG4gICAgYXJnVHlwZXM6IFtcInJhd1wiLCBcInVybFwiXSxcbiAgICBhbGxvd2VkSW5UZXh0OiBmYWxzZVxuICB9LFxuICBoYW5kbGVyOiAoX3JlZiwgYXJncywgb3B0QXJncykgPT4ge1xuICAgIGxldCB7XG4gICAgICBwYXJzZXJcbiAgICB9ID0gX3JlZjtcbiAgICBsZXQgd2lkdGggPSB7XG4gICAgICBudW1iZXI6IDAsXG4gICAgICB1bml0OiBcImVtXCJcbiAgICB9O1xuICAgIGxldCBoZWlnaHQgPSB7XG4gICAgICBudW1iZXI6IDAuOSxcbiAgICAgIHVuaXQ6IFwiZW1cIlxuICAgIH07IC8vIHNvcnRhIGNoYXJhY3RlciBzaXplZC5cblxuICAgIGxldCB0b3RhbGhlaWdodCA9IHtcbiAgICAgIG51bWJlcjogMCxcbiAgICAgIHVuaXQ6IFwiZW1cIlxuICAgIH07XG4gICAgbGV0IGFsdCA9IFwiXCI7XG5cbiAgICBpZiAob3B0QXJnc1swXSkge1xuICAgICAgY29uc3QgYXR0cmlidXRlU3RyID0gYXNzZXJ0Tm9kZVR5cGUob3B0QXJnc1swXSwgXCJyYXdcIikuc3RyaW5nOyAvLyBQYXJzZXIuanMgZG9lcyBub3QgcGFyc2Uga2V5L3ZhbHVlIHBhaXJzLiBXZSBnZXQgYSBzdHJpbmcuXG5cbiAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVTdHIuc3BsaXQoXCIsXCIpO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5VmFsID0gYXR0cmlidXRlc1tpXS5zcGxpdChcIj1cIik7XG5cbiAgICAgICAgaWYgKGtleVZhbC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICBjb25zdCBzdHIgPSBrZXlWYWxbMV0udHJpbSgpO1xuXG4gICAgICAgICAgc3dpdGNoIChrZXlWYWxbMF0udHJpbSgpKSB7XG4gICAgICAgICAgICBjYXNlIFwiYWx0XCI6XG4gICAgICAgICAgICAgIGFsdCA9IHN0cjtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJ3aWR0aFwiOlxuICAgICAgICAgICAgICB3aWR0aCA9IHNpemVEYXRhKHN0cik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwiaGVpZ2h0XCI6XG4gICAgICAgICAgICAgIGhlaWdodCA9IHNpemVEYXRhKHN0cik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwidG90YWxoZWlnaHRcIjpcbiAgICAgICAgICAgICAgdG90YWxoZWlnaHQgPSBzaXplRGF0YShzdHIpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiSW52YWxpZCBrZXk6ICdcIiArIGtleVZhbFswXSArIFwiJyBpbiBcXFxcaW5jbHVkZWdyYXBoaWNzLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzcmMgPSBhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcInVybFwiKS51cmw7XG5cbiAgICBpZiAoYWx0ID09PSBcIlwiKSB7XG4gICAgICAvLyBObyBhbHQgZ2l2ZW4uIFVzZSB0aGUgZmlsZSBuYW1lLiBTdHJpcCBhd2F5IHRoZSBwYXRoLlxuICAgICAgYWx0ID0gc3JjO1xuICAgICAgYWx0ID0gYWx0LnJlcGxhY2UoL14uKltcXFxcL10vLCAnJyk7XG4gICAgICBhbHQgPSBhbHQuc3Vic3RyaW5nKDAsIGFsdC5sYXN0SW5kZXhPZignLicpKTtcbiAgICB9XG5cbiAgICBpZiAoIXBhcnNlci5zZXR0aW5ncy5pc1RydXN0ZWQoe1xuICAgICAgY29tbWFuZDogXCJcXFxcaW5jbHVkZWdyYXBoaWNzXCIsXG4gICAgICB1cmw6IHNyY1xuICAgIH0pKSB7XG4gICAgICByZXR1cm4gcGFyc2VyLmZvcm1hdFVuc3VwcG9ydGVkQ21kKFwiXFxcXGluY2x1ZGVncmFwaGljc1wiKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJpbmNsdWRlZ3JhcGhpY3NcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgYWx0OiBhbHQsXG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgIHRvdGFsaGVpZ2h0OiB0b3RhbGhlaWdodCxcbiAgICAgIHNyYzogc3JjXG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IChncm91cCwgb3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IGhlaWdodCA9IGNhbGN1bGF0ZVNpemUoZ3JvdXAuaGVpZ2h0LCBvcHRpb25zKTtcbiAgICBsZXQgZGVwdGggPSAwO1xuXG4gICAgaWYgKGdyb3VwLnRvdGFsaGVpZ2h0Lm51bWJlciA+IDApIHtcbiAgICAgIGRlcHRoID0gY2FsY3VsYXRlU2l6ZShncm91cC50b3RhbGhlaWdodCwgb3B0aW9ucykgLSBoZWlnaHQ7XG4gICAgfVxuXG4gICAgbGV0IHdpZHRoID0gMDtcblxuICAgIGlmIChncm91cC53aWR0aC5udW1iZXIgPiAwKSB7XG4gICAgICB3aWR0aCA9IGNhbGN1bGF0ZVNpemUoZ3JvdXAud2lkdGgsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGNvbnN0IHN0eWxlID0ge1xuICAgICAgaGVpZ2h0OiBtYWtlRW0oaGVpZ2h0ICsgZGVwdGgpXG4gICAgfTtcblxuICAgIGlmICh3aWR0aCA+IDApIHtcbiAgICAgIHN0eWxlLndpZHRoID0gbWFrZUVtKHdpZHRoKTtcbiAgICB9XG5cbiAgICBpZiAoZGVwdGggPiAwKSB7XG4gICAgICBzdHlsZS52ZXJ0aWNhbEFsaWduID0gbWFrZUVtKC1kZXB0aCk7XG4gICAgfVxuXG4gICAgY29uc3Qgbm9kZSA9IG5ldyBJbWcoZ3JvdXAuc3JjLCBncm91cC5hbHQsIHN0eWxlKTtcbiAgICBub2RlLmhlaWdodCA9IGhlaWdodDtcbiAgICBub2RlLmRlcHRoID0gZGVwdGg7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IChncm91cCwgb3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1nbHlwaFwiLCBbXSk7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJhbHRcIiwgZ3JvdXAuYWx0KTtcbiAgICBjb25zdCBoZWlnaHQgPSBjYWxjdWxhdGVTaXplKGdyb3VwLmhlaWdodCwgb3B0aW9ucyk7XG4gICAgbGV0IGRlcHRoID0gMDtcblxuICAgIGlmIChncm91cC50b3RhbGhlaWdodC5udW1iZXIgPiAwKSB7XG4gICAgICBkZXB0aCA9IGNhbGN1bGF0ZVNpemUoZ3JvdXAudG90YWxoZWlnaHQsIG9wdGlvbnMpIC0gaGVpZ2h0O1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJ2YWxpZ25cIiwgbWFrZUVtKC1kZXB0aCkpO1xuICAgIH1cblxuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIG1ha2VFbShoZWlnaHQgKyBkZXB0aCkpO1xuXG4gICAgaWYgKGdyb3VwLndpZHRoLm51bWJlciA+IDApIHtcbiAgICAgIGNvbnN0IHdpZHRoID0gY2FsY3VsYXRlU2l6ZShncm91cC53aWR0aCwgb3B0aW9ucyk7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIG1ha2VFbSh3aWR0aCkpO1xuICAgIH1cblxuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwic3JjXCIsIGdyb3VwLnNyYyk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy9rZXJuLmpzXG4vLyBIb3Jpem9udGFsIHNwYWNpbmcgY29tbWFuZHNcblxuXG5cblxuIC8vIFRPRE86IFxcaHNraXAgYW5kIFxcbXNraXAgc2hvdWxkIHN1cHBvcnQgcGx1cyBhbmQgbWludXMgaW4gbGVuZ3Roc1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwia2VyblwiLFxuICBuYW1lczogW1wiXFxcXGtlcm5cIiwgXCJcXFxcbWtlcm5cIiwgXCJcXFxcaHNraXBcIiwgXCJcXFxcbXNraXBcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhcmdUeXBlczogW1wic2l6ZVwiXSxcbiAgICBwcmltaXRpdmU6IHRydWUsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuXG4gIGhhbmRsZXIoX3JlZiwgYXJncykge1xuICAgIGxldCB7XG4gICAgICBwYXJzZXIsXG4gICAgICBmdW5jTmFtZVxuICAgIH0gPSBfcmVmO1xuICAgIGNvbnN0IHNpemUgPSBhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcInNpemVcIik7XG5cbiAgICBpZiAocGFyc2VyLnNldHRpbmdzLnN0cmljdCkge1xuICAgICAgY29uc3QgbWF0aEZ1bmN0aW9uID0gZnVuY05hbWVbMV0gPT09ICdtJzsgLy8gXFxta2VybiwgXFxtc2tpcFxuXG4gICAgICBjb25zdCBtdVVuaXQgPSBzaXplLnZhbHVlLnVuaXQgPT09ICdtdSc7XG5cbiAgICAgIGlmIChtYXRoRnVuY3Rpb24pIHtcbiAgICAgICAgaWYgKCFtdVVuaXQpIHtcbiAgICAgICAgICBwYXJzZXIuc2V0dGluZ3MucmVwb3J0Tm9uc3RyaWN0KFwibWF0aFZzVGV4dFVuaXRzXCIsIFwiTGFUZVgncyBcIiArIGZ1bmNOYW1lICsgXCIgc3VwcG9ydHMgb25seSBtdSB1bml0cywgXCIgKyAoXCJub3QgXCIgKyBzaXplLnZhbHVlLnVuaXQgKyBcIiB1bml0c1wiKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyc2VyLm1vZGUgIT09IFwibWF0aFwiKSB7XG4gICAgICAgICAgcGFyc2VyLnNldHRpbmdzLnJlcG9ydE5vbnN0cmljdChcIm1hdGhWc1RleHRVbml0c1wiLCBcIkxhVGVYJ3MgXCIgKyBmdW5jTmFtZSArIFwiIHdvcmtzIG9ubHkgaW4gbWF0aCBtb2RlXCIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyAhbWF0aEZ1bmN0aW9uXG4gICAgICAgIGlmIChtdVVuaXQpIHtcbiAgICAgICAgICBwYXJzZXIuc2V0dGluZ3MucmVwb3J0Tm9uc3RyaWN0KFwibWF0aFZzVGV4dFVuaXRzXCIsIFwiTGFUZVgncyBcIiArIGZ1bmNOYW1lICsgXCIgZG9lc24ndCBzdXBwb3J0IG11IHVuaXRzXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwia2VyblwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBkaW1lbnNpb246IHNpemUudmFsdWVcbiAgICB9O1xuICB9LFxuXG4gIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VHbHVlKGdyb3VwLmRpbWVuc2lvbiwgb3B0aW9ucyk7XG4gIH0sXG5cbiAgbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGRpbWVuc2lvbiA9IGNhbGN1bGF0ZVNpemUoZ3JvdXAuZGltZW5zaW9uLCBvcHRpb25zKTtcbiAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuU3BhY2VOb2RlKGRpbWVuc2lvbik7XG4gIH1cblxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZnVuY3Rpb25zL2xhcC5qc1xuLy8gSG9yaXpvbnRhbCBvdmVybGFwIGZ1bmN0aW9uc1xuXG5cblxuXG5cblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImxhcFwiLFxuICBuYW1lczogW1wiXFxcXG1hdGhsbGFwXCIsIFwiXFxcXG1hdGhybGFwXCIsIFwiXFxcXG1hdGhjbGFwXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiAoX3JlZiwgYXJncykgPT4ge1xuICAgIGxldCB7XG4gICAgICBwYXJzZXIsXG4gICAgICBmdW5jTmFtZVxuICAgIH0gPSBfcmVmO1xuICAgIGNvbnN0IGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImxhcFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBhbGlnbm1lbnQ6IGZ1bmNOYW1lLnNsaWNlKDUpLFxuICAgICAgYm9keVxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgICAvLyBtYXRobGxhcCwgbWF0aHJsYXAsIG1hdGhjbGFwXG4gICAgbGV0IGlubmVyO1xuXG4gICAgaWYgKGdyb3VwLmFsaWdubWVudCA9PT0gXCJjbGFwXCIpIHtcbiAgICAgIC8vIHJlZjogaHR0cHM6Ly93d3cubWF0aC5sc3UuZWR1L35hcGVybGlzL3B1YmxpY2F0aW9ucy9tYXRoY2xhcC9cbiAgICAgIGlubmVyID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW10sIFtidWlsZEdyb3VwKGdyb3VwLmJvZHksIG9wdGlvbnMpXSk7IC8vIHdyYXAsIHNpbmNlIENTUyB3aWxsIGNlbnRlciBhIC5jbGFwID4gLmlubmVyID4gc3BhblxuXG4gICAgICBpbm5lciA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcImlubmVyXCJdLCBbaW5uZXJdLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5uZXIgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJpbm5lclwiXSwgW2J1aWxkR3JvdXAoZ3JvdXAuYm9keSwgb3B0aW9ucyldKTtcbiAgICB9XG5cbiAgICBjb25zdCBmaXggPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJmaXhcIl0sIFtdKTtcbiAgICBsZXQgbm9kZSA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtncm91cC5hbGlnbm1lbnRdLCBbaW5uZXIsIGZpeF0sIG9wdGlvbnMpOyAvLyBBdCB0aGlzIHBvaW50LCB3ZSBoYXZlIGNvcnJlY3RseSBzZXQgaG9yaXpvbnRhbCBhbGlnbm1lbnQgb2YgdGhlXG4gICAgLy8gdHdvIGl0ZW1zIGludm9sdmVkIGluIHRoZSBsYXAuXG4gICAgLy8gTmV4dCwgdXNlIGEgc3RydXQgdG8gc2V0IHRoZSBoZWlnaHQgb2YgdGhlIEhUTUwgYm91bmRpbmcgYm94LlxuICAgIC8vIE90aGVyd2lzZSwgYSB0YWxsIGFyZ3VtZW50IG1heSBiZSBtaXNwbGFjZWQuXG4gICAgLy8gVGhpcyBjb2RlIHJlc29sdmVkIGlzc3VlICMxMTUzXG5cbiAgICBjb25zdCBzdHJ1dCA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcInN0cnV0XCJdKTtcbiAgICBzdHJ1dC5zdHlsZS5oZWlnaHQgPSBtYWtlRW0obm9kZS5oZWlnaHQgKyBub2RlLmRlcHRoKTtcblxuICAgIGlmIChub2RlLmRlcHRoKSB7XG4gICAgICBzdHJ1dC5zdHlsZS52ZXJ0aWNhbEFsaWduID0gbWFrZUVtKC1ub2RlLmRlcHRoKTtcbiAgICB9XG5cbiAgICBub2RlLmNoaWxkcmVuLnVuc2hpZnQoc3RydXQpOyAvLyBOZXh0LCBwcmV2ZW50IHZlcnRpY2FsIG1pc3BsYWNlbWVudCB3aGVuIG5leHQgdG8gc29tZXRoaW5nIHRhbGwuXG4gICAgLy8gVGhpcyBjb2RlIHJlc29sdmVzIGlzc3VlICMxMjM0XG5cbiAgICBub2RlID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1widGhpbmJveFwiXSwgW25vZGVdLCBvcHRpb25zKTtcbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibW9yZFwiLCBcInZib3hcIl0sIFtub2RlXSwgb3B0aW9ucyk7XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IChncm91cCwgb3B0aW9ucykgPT4ge1xuICAgIC8vIG1hdGhsbGFwLCBtYXRocmxhcCwgbWF0aGNsYXBcbiAgICBjb25zdCBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcGFkZGVkXCIsIFtidWlsZE1hdGhNTF9idWlsZEdyb3VwKGdyb3VwLmJvZHksIG9wdGlvbnMpXSk7XG5cbiAgICBpZiAoZ3JvdXAuYWxpZ25tZW50ICE9PSBcInJsYXBcIikge1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gZ3JvdXAuYWxpZ25tZW50ID09PSBcImxsYXBcIiA/IFwiLTFcIiA6IFwiLTAuNVwiO1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJsc3BhY2VcIiwgb2Zmc2V0ICsgXCJ3aWR0aFwiKTtcbiAgICB9XG5cbiAgICBub2RlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiMHB4XCIpO1xuICAgIHJldHVybiBub2RlO1xuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mdW5jdGlvbnMvbWF0aC5qc1xuXG4gLy8gU3dpdGNoaW5nIGZyb20gdGV4dCBtb2RlIGJhY2sgdG8gbWF0aCBtb2RlXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJzdHlsaW5nXCIsXG4gIG5hbWVzOiBbXCJcXFxcKFwiLCBcIiRcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMCxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlLFxuICAgIGFsbG93ZWRJbk1hdGg6IGZhbHNlXG4gIH0sXG5cbiAgaGFuZGxlcihfcmVmLCBhcmdzKSB7XG4gICAgbGV0IHtcbiAgICAgIGZ1bmNOYW1lLFxuICAgICAgcGFyc2VyXG4gICAgfSA9IF9yZWY7XG4gICAgY29uc3Qgb3V0ZXJNb2RlID0gcGFyc2VyLm1vZGU7XG4gICAgcGFyc2VyLnN3aXRjaE1vZGUoXCJtYXRoXCIpO1xuICAgIGNvbnN0IGNsb3NlID0gZnVuY05hbWUgPT09IFwiXFxcXChcIiA/IFwiXFxcXClcIiA6IFwiJFwiO1xuICAgIGNvbnN0IGJvZHkgPSBwYXJzZXIucGFyc2VFeHByZXNzaW9uKGZhbHNlLCBjbG9zZSk7XG4gICAgcGFyc2VyLmV4cGVjdChjbG9zZSk7XG4gICAgcGFyc2VyLnN3aXRjaE1vZGUob3V0ZXJNb2RlKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJzdHlsaW5nXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIHN0eWxlOiBcInRleHRcIixcbiAgICAgIGJvZHlcbiAgICB9O1xuICB9XG5cbn0pOyAvLyBDaGVjayBmb3IgZXh0cmEgY2xvc2luZyBtYXRoIGRlbGltaXRlcnNcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInRleHRcIixcbiAgLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGlzIGlzLlxuICBuYW1lczogW1wiXFxcXClcIiwgXCJcXFxcXVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWUsXG4gICAgYWxsb3dlZEluTWF0aDogZmFsc2VcbiAgfSxcblxuICBoYW5kbGVyKGNvbnRleHQsIGFyZ3MpIHtcbiAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJNaXNtYXRjaGVkIFwiICsgY29udGV4dC5mdW5jTmFtZSk7XG4gIH1cblxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZnVuY3Rpb25zL21hdGhjaG9pY2UuanNcblxuXG5cblxuXG5cbmNvbnN0IGNob29zZU1hdGhTdHlsZSA9IChncm91cCwgb3B0aW9ucykgPT4ge1xuICBzd2l0Y2ggKG9wdGlvbnMuc3R5bGUuc2l6ZSkge1xuICAgIGNhc2Ugc3JjX1N0eWxlLkRJU1BMQVkuc2l6ZTpcbiAgICAgIHJldHVybiBncm91cC5kaXNwbGF5O1xuXG4gICAgY2FzZSBzcmNfU3R5bGUuVEVYVC5zaXplOlxuICAgICAgcmV0dXJuIGdyb3VwLnRleHQ7XG5cbiAgICBjYXNlIHNyY19TdHlsZS5TQ1JJUFQuc2l6ZTpcbiAgICAgIHJldHVybiBncm91cC5zY3JpcHQ7XG5cbiAgICBjYXNlIHNyY19TdHlsZS5TQ1JJUFRTQ1JJUFQuc2l6ZTpcbiAgICAgIHJldHVybiBncm91cC5zY3JpcHRzY3JpcHQ7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGdyb3VwLnRleHQ7XG4gIH1cbn07XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJtYXRoY2hvaWNlXCIsXG4gIG5hbWVzOiBbXCJcXFxcbWF0aGNob2ljZVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiA0LFxuICAgIHByaW1pdGl2ZTogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiAoX3JlZiwgYXJncykgPT4ge1xuICAgIGxldCB7XG4gICAgICBwYXJzZXJcbiAgICB9ID0gX3JlZjtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJtYXRoY2hvaWNlXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGRpc3BsYXk6IG9yZGFyZ3VtZW50KGFyZ3NbMF0pLFxuICAgICAgdGV4dDogb3JkYXJndW1lbnQoYXJnc1sxXSksXG4gICAgICBzY3JpcHQ6IG9yZGFyZ3VtZW50KGFyZ3NbMl0pLFxuICAgICAgc2NyaXB0c2NyaXB0OiBvcmRhcmd1bWVudChhcmdzWzNdKVxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgICBjb25zdCBib2R5ID0gY2hvb3NlTWF0aFN0eWxlKGdyb3VwLCBvcHRpb25zKTtcbiAgICBjb25zdCBlbGVtZW50cyA9IGJ1aWxkRXhwcmVzc2lvbihib2R5LCBvcHRpb25zLCBmYWxzZSk7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VGcmFnbWVudChlbGVtZW50cyk7XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IChncm91cCwgb3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IGJvZHkgPSBjaG9vc2VNYXRoU3R5bGUoZ3JvdXAsIG9wdGlvbnMpO1xuICAgIHJldHVybiBidWlsZEV4cHJlc3Npb25Sb3coYm9keSwgb3B0aW9ucyk7XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy91dGlscy9hc3NlbWJsZVN1cFN1Yi5qc1xuXG5cblxuIC8vIEZvciBhbiBvcGVyYXRvciB3aXRoIGxpbWl0cywgYXNzZW1ibGUgdGhlIGJhc2UsIHN1cCwgYW5kIHN1YiBpbnRvIGEgc3Bhbi5cblxuY29uc3QgYXNzZW1ibGVTdXBTdWIgPSAoYmFzZSwgc3VwR3JvdXAsIHN1Ykdyb3VwLCBvcHRpb25zLCBzdHlsZSwgc2xhbnQsIGJhc2VTaGlmdCkgPT4ge1xuICBiYXNlID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW10sIFtiYXNlXSk7XG4gIGNvbnN0IHN1YklzU2luZ2xlQ2hhcmFjdGVyID0gc3ViR3JvdXAgJiYgdXRpbHMuaXNDaGFyYWN0ZXJCb3goc3ViR3JvdXApO1xuICBsZXQgc3ViO1xuICBsZXQgc3VwOyAvLyBXZSBtYW51YWxseSBoYXZlIHRvIGhhbmRsZSB0aGUgc3VwZXJzY3JpcHRzIGFuZCBzdWJzY3JpcHRzLiBUaGlzLFxuICAvLyBhc2lkZSBmcm9tIHRoZSBrZXJuIGNhbGN1bGF0aW9ucywgaXMgY29waWVkIGZyb20gc3Vwc3ViLlxuXG4gIGlmIChzdXBHcm91cCkge1xuICAgIGNvbnN0IGVsZW0gPSBidWlsZEdyb3VwKHN1cEdyb3VwLCBvcHRpb25zLmhhdmluZ1N0eWxlKHN0eWxlLnN1cCgpKSwgb3B0aW9ucyk7XG4gICAgc3VwID0ge1xuICAgICAgZWxlbSxcbiAgICAgIGtlcm46IE1hdGgubWF4KG9wdGlvbnMuZm9udE1ldHJpY3MoKS5iaWdPcFNwYWNpbmcxLCBvcHRpb25zLmZvbnRNZXRyaWNzKCkuYmlnT3BTcGFjaW5nMyAtIGVsZW0uZGVwdGgpXG4gICAgfTtcbiAgfVxuXG4gIGlmIChzdWJHcm91cCkge1xuICAgIGNvbnN0IGVsZW0gPSBidWlsZEdyb3VwKHN1Ykdyb3VwLCBvcHRpb25zLmhhdmluZ1N0eWxlKHN0eWxlLnN1YigpKSwgb3B0aW9ucyk7XG4gICAgc3ViID0ge1xuICAgICAgZWxlbSxcbiAgICAgIGtlcm46IE1hdGgubWF4KG9wdGlvbnMuZm9udE1ldHJpY3MoKS5iaWdPcFNwYWNpbmcyLCBvcHRpb25zLmZvbnRNZXRyaWNzKCkuYmlnT3BTcGFjaW5nNCAtIGVsZW0uaGVpZ2h0KVxuICAgIH07XG4gIH0gLy8gQnVpbGQgdGhlIGZpbmFsIGdyb3VwIGFzIGEgdmxpc3Qgb2YgdGhlIHBvc3NpYmxlIHN1YnNjcmlwdCwgYmFzZSxcbiAgLy8gYW5kIHBvc3NpYmxlIHN1cGVyc2NyaXB0LlxuXG5cbiAgbGV0IGZpbmFsR3JvdXA7XG5cbiAgaWYgKHN1cCAmJiBzdWIpIHtcbiAgICBjb25zdCBib3R0b20gPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkuYmlnT3BTcGFjaW5nNSArIHN1Yi5lbGVtLmhlaWdodCArIHN1Yi5lbGVtLmRlcHRoICsgc3ViLmtlcm4gKyBiYXNlLmRlcHRoICsgYmFzZVNoaWZ0O1xuICAgIGZpbmFsR3JvdXAgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgcG9zaXRpb25UeXBlOiBcImJvdHRvbVwiLFxuICAgICAgcG9zaXRpb25EYXRhOiBib3R0b20sXG4gICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgdHlwZTogXCJrZXJuXCIsXG4gICAgICAgIHNpemU6IG9wdGlvbnMuZm9udE1ldHJpY3MoKS5iaWdPcFNwYWNpbmc1XG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBzdWIuZWxlbSxcbiAgICAgICAgbWFyZ2luTGVmdDogbWFrZUVtKC1zbGFudClcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJrZXJuXCIsXG4gICAgICAgIHNpemU6IHN1Yi5rZXJuXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBiYXNlXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwia2VyblwiLFxuICAgICAgICBzaXplOiBzdXAua2VyblxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogc3VwLmVsZW0sXG4gICAgICAgIG1hcmdpbkxlZnQ6IG1ha2VFbShzbGFudClcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJrZXJuXCIsXG4gICAgICAgIHNpemU6IG9wdGlvbnMuZm9udE1ldHJpY3MoKS5iaWdPcFNwYWNpbmc1XG4gICAgICB9XVxuICAgIH0sIG9wdGlvbnMpO1xuICB9IGVsc2UgaWYgKHN1Yikge1xuICAgIGNvbnN0IHRvcCA9IGJhc2UuaGVpZ2h0IC0gYmFzZVNoaWZ0OyAvLyBTaGlmdCB0aGUgbGltaXRzIGJ5IHRoZSBzbGFudCBvZiB0aGUgc3ltYm9sLiBOb3RlXG4gICAgLy8gdGhhdCB3ZSBhcmUgc3VwcG9zZWQgdG8gc2hpZnQgdGhlIGxpbWl0cyBieSAxLzIgb2YgdGhlIHNsYW50LFxuICAgIC8vIGJ1dCBzaW5jZSB3ZSBhcmUgY2VudGVyaW5nIHRoZSBsaW1pdHMgYWRkaW5nIGEgZnVsbCBzbGFudCBvZlxuICAgIC8vIG1hcmdpbiB3aWxsIHNoaWZ0IGJ5IDEvMiB0aGF0LlxuXG4gICAgZmluYWxHcm91cCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICBwb3NpdGlvblR5cGU6IFwidG9wXCIsXG4gICAgICBwb3NpdGlvbkRhdGE6IHRvcCxcbiAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICB0eXBlOiBcImtlcm5cIixcbiAgICAgICAgc2l6ZTogb3B0aW9ucy5mb250TWV0cmljcygpLmJpZ09wU3BhY2luZzVcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IHN1Yi5lbGVtLFxuICAgICAgICBtYXJnaW5MZWZ0OiBtYWtlRW0oLXNsYW50KVxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImtlcm5cIixcbiAgICAgICAgc2l6ZTogc3ViLmtlcm5cbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IGJhc2VcbiAgICAgIH1dXG4gICAgfSwgb3B0aW9ucyk7XG4gIH0gZWxzZSBpZiAoc3VwKSB7XG4gICAgY29uc3QgYm90dG9tID0gYmFzZS5kZXB0aCArIGJhc2VTaGlmdDtcbiAgICBmaW5hbEdyb3VwID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHtcbiAgICAgIHBvc2l0aW9uVHlwZTogXCJib3R0b21cIixcbiAgICAgIHBvc2l0aW9uRGF0YTogYm90dG9tLFxuICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBiYXNlXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwia2VyblwiLFxuICAgICAgICBzaXplOiBzdXAua2VyblxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogc3VwLmVsZW0sXG4gICAgICAgIG1hcmdpbkxlZnQ6IG1ha2VFbShzbGFudClcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJrZXJuXCIsXG4gICAgICAgIHNpemU6IG9wdGlvbnMuZm9udE1ldHJpY3MoKS5iaWdPcFNwYWNpbmc1XG4gICAgICB9XVxuICAgIH0sIG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgY2FzZSBwcm9iYWJseSBzaG91bGRuJ3Qgb2NjdXIgKHRoaXMgd291bGQgbWVhbiB0aGVcbiAgICAvLyBzdXBzdWIgd2FzIHNlbmRpbmcgdXMgYSBncm91cCB3aXRoIG5vIHN1cGVyc2NyaXB0IG9yXG4gICAgLy8gc3Vic2NyaXB0KSBidXQgYmUgc2FmZS5cbiAgICByZXR1cm4gYmFzZTtcbiAgfVxuXG4gIGNvbnN0IHBhcnRzID0gW2ZpbmFsR3JvdXBdO1xuXG4gIGlmIChzdWIgJiYgc2xhbnQgIT09IDAgJiYgIXN1YklzU2luZ2xlQ2hhcmFjdGVyKSB7XG4gICAgLy8gQSBuZWdhdGl2ZSBtYXJnaW4tbGVmdCB3YXMgYXBwbGllZCB0byB0aGUgbG93ZXIgbGltaXQuXG4gICAgLy8gQXZvaWQgYW4gb3ZlcmxhcCBieSBwbGFjaW5nIGEgc3BhY2VyIG9uIHRoZSBsZWZ0IG9uIHRoZSBncm91cC5cbiAgICBjb25zdCBzcGFjZXIgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtc3BhY2VcIl0sIFtdLCBvcHRpb25zKTtcbiAgICBzcGFjZXIuc3R5bGUubWFyZ2luUmlnaHQgPSBtYWtlRW0oc2xhbnQpO1xuICAgIHBhcnRzLnVuc2hpZnQoc3BhY2VyKTtcbiAgfVxuXG4gIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtb3BcIiwgXCJvcC1saW1pdHNcIl0sIHBhcnRzLCBvcHRpb25zKTtcbn07XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZnVuY3Rpb25zL29wLmpzXG4vLyBMaW1pdHMsIHN5bWJvbHNcblxuXG5cblxuXG5cblxuXG5cblxuXG4vLyBNb3N0IG9wZXJhdG9ycyBoYXZlIGEgbGFyZ2Ugc3VjY2Vzc29yIHN5bWJvbCwgYnV0IHRoZXNlIGRvbid0LlxuY29uc3Qgbm9TdWNjZXNzb3IgPSBbXCJcXFxcc21hbGxpbnRcIl07IC8vIE5PVEU6IFVubGlrZSBtb3N0IGBodG1sQnVpbGRlcmBzLCB0aGlzIG9uZSBoYW5kbGVzIG5vdCBvbmx5IFwib3BcIiwgYnV0IGFsc29cbi8vIFwic3Vwc3ViXCIgc2luY2Ugc29tZSBvZiB0aGVtIChsaWtlIFxcaW50KSBjYW4gYWZmZWN0IHN1cGVyL3N1YnNjcmlwdGluZy5cblxuY29uc3Qgb3BfaHRtbEJ1aWxkZXIgPSAoZ3JwLCBvcHRpb25zKSA9PiB7XG4gIC8vIE9wZXJhdG9ycyBhcmUgaGFuZGxlZCBpbiB0aGUgVGVYYm9vayBwZy4gNDQzLTQ0NCwgcnVsZSAxMyhhKS5cbiAgbGV0IHN1cEdyb3VwO1xuICBsZXQgc3ViR3JvdXA7XG4gIGxldCBoYXNMaW1pdHMgPSBmYWxzZTtcbiAgbGV0IGdyb3VwO1xuXG4gIGlmIChncnAudHlwZSA9PT0gXCJzdXBzdWJcIikge1xuICAgIC8vIElmIHdlIGhhdmUgbGltaXRzLCBzdXBzdWIgd2lsbCBwYXNzIHVzIGl0cyBncm91cCB0byBoYW5kbGUuIFB1bGxcbiAgICAvLyBvdXQgdGhlIHN1cGVyc2NyaXB0IGFuZCBzdWJzY3JpcHQgYW5kIHNldCB0aGUgZ3JvdXAgdG8gdGhlIG9wIGluXG4gICAgLy8gaXRzIGJhc2UuXG4gICAgc3VwR3JvdXAgPSBncnAuc3VwO1xuICAgIHN1Ykdyb3VwID0gZ3JwLnN1YjtcbiAgICBncm91cCA9IGFzc2VydE5vZGVUeXBlKGdycC5iYXNlLCBcIm9wXCIpO1xuICAgIGhhc0xpbWl0cyA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgZ3JvdXAgPSBhc3NlcnROb2RlVHlwZShncnAsIFwib3BcIik7XG4gIH1cblxuICBjb25zdCBzdHlsZSA9IG9wdGlvbnMuc3R5bGU7XG4gIGxldCBsYXJnZSA9IGZhbHNlO1xuXG4gIGlmIChzdHlsZS5zaXplID09PSBzcmNfU3R5bGUuRElTUExBWS5zaXplICYmIGdyb3VwLnN5bWJvbCAmJiAhdXRpbHMuY29udGFpbnMobm9TdWNjZXNzb3IsIGdyb3VwLm5hbWUpKSB7XG4gICAgLy8gTW9zdCBzeW1ib2wgb3BlcmF0b3JzIGdldCBsYXJnZXIgaW4gZGlzcGxheXN0eWxlIChydWxlIDEzKVxuICAgIGxhcmdlID0gdHJ1ZTtcbiAgfVxuXG4gIGxldCBiYXNlO1xuXG4gIGlmIChncm91cC5zeW1ib2wpIHtcbiAgICAvLyBJZiB0aGlzIGlzIGEgc3ltYm9sLCBjcmVhdGUgdGhlIHN5bWJvbC5cbiAgICBjb25zdCBmb250TmFtZSA9IGxhcmdlID8gXCJTaXplMi1SZWd1bGFyXCIgOiBcIlNpemUxLVJlZ3VsYXJcIjtcbiAgICBsZXQgc3Rhc2ggPSBcIlwiO1xuXG4gICAgaWYgKGdyb3VwLm5hbWUgPT09IFwiXFxcXG9paW50XCIgfHwgZ3JvdXAubmFtZSA9PT0gXCJcXFxcb2lpaW50XCIpIHtcbiAgICAgIC8vIE5vIGZvbnQgZ2x5cGhzIHlldCwgc28gdXNlIGEgZ2x5cGggdy9vIHRoZSBvdmFsLlxuICAgICAgLy8gVE9ETzogV2hlbiBmb250IGdseXBocyBhcmUgYXZhaWxhYmxlLCBkZWxldGUgdGhpcyBjb2RlLlxuICAgICAgc3Rhc2ggPSBncm91cC5uYW1lLnNsaWNlKDEpO1xuICAgICAgZ3JvdXAubmFtZSA9IHN0YXNoID09PSBcIm9paW50XCIgPyBcIlxcXFxpaW50XCIgOiBcIlxcXFxpaWludFwiO1xuICAgIH1cblxuICAgIGJhc2UgPSBidWlsZENvbW1vbi5tYWtlU3ltYm9sKGdyb3VwLm5hbWUsIGZvbnROYW1lLCBcIm1hdGhcIiwgb3B0aW9ucywgW1wibW9wXCIsIFwib3Atc3ltYm9sXCIsIGxhcmdlID8gXCJsYXJnZS1vcFwiIDogXCJzbWFsbC1vcFwiXSk7XG5cbiAgICBpZiAoc3Rhc2gubGVuZ3RoID4gMCkge1xuICAgICAgLy8gV2UncmUgaW4gXFxvaWludCBvciBcXG9paWludC4gT3ZlcmxheSB0aGUgb3ZhbC5cbiAgICAgIC8vIFRPRE86IFdoZW4gZm9udCBnbHlwaHMgYXJlIGF2YWlsYWJsZSwgZGVsZXRlIHRoaXMgY29kZS5cbiAgICAgIGNvbnN0IGl0YWxpYyA9IGJhc2UuaXRhbGljO1xuICAgICAgY29uc3Qgb3ZhbCA9IGJ1aWxkQ29tbW9uLnN0YXRpY1N2ZyhzdGFzaCArIFwiU2l6ZVwiICsgKGxhcmdlID8gXCIyXCIgOiBcIjFcIiksIG9wdGlvbnMpO1xuICAgICAgYmFzZSA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICAgIHBvc2l0aW9uVHlwZTogXCJpbmRpdmlkdWFsU2hpZnRcIixcbiAgICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgICAgZWxlbTogYmFzZSxcbiAgICAgICAgICBzaGlmdDogMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgICAgZWxlbTogb3ZhbCxcbiAgICAgICAgICBzaGlmdDogbGFyZ2UgPyAwLjA4IDogMFxuICAgICAgICB9XVxuICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICBncm91cC5uYW1lID0gXCJcXFxcXCIgKyBzdGFzaDtcbiAgICAgIGJhc2UuY2xhc3Nlcy51bnNoaWZ0KFwibW9wXCIpOyAvLyAkRmxvd0ZpeE1lXG5cbiAgICAgIGJhc2UuaXRhbGljID0gaXRhbGljO1xuICAgIH1cbiAgfSBlbHNlIGlmIChncm91cC5ib2R5KSB7XG4gICAgLy8gSWYgdGhpcyBpcyBhIGxpc3QsIGNvbXBvc2UgdGhhdCBsaXN0LlxuICAgIGNvbnN0IGlubmVyID0gYnVpbGRFeHByZXNzaW9uKGdyb3VwLmJvZHksIG9wdGlvbnMsIHRydWUpO1xuXG4gICAgaWYgKGlubmVyLmxlbmd0aCA9PT0gMSAmJiBpbm5lclswXSBpbnN0YW5jZW9mIFN5bWJvbE5vZGUpIHtcbiAgICAgIGJhc2UgPSBpbm5lclswXTtcbiAgICAgIGJhc2UuY2xhc3Nlc1swXSA9IFwibW9wXCI7IC8vIHJlcGxhY2Ugb2xkIG1jbGFzc1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXNlID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibW9wXCJdLCBpbm5lciwgb3B0aW9ucyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIE90aGVyd2lzZSwgdGhpcyBpcyBhIHRleHQgb3BlcmF0b3IuIEJ1aWxkIHRoZSB0ZXh0IGZyb20gdGhlXG4gICAgLy8gb3BlcmF0b3IncyBuYW1lLlxuICAgIGNvbnN0IG91dHB1dCA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBncm91cC5uYW1lLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvdXRwdXQucHVzaChidWlsZENvbW1vbi5tYXRoc3ltKGdyb3VwLm5hbWVbaV0sIGdyb3VwLm1vZGUsIG9wdGlvbnMpKTtcbiAgICB9XG5cbiAgICBiYXNlID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibW9wXCJdLCBvdXRwdXQsIG9wdGlvbnMpO1xuICB9IC8vIElmIGNvbnRlbnQgb2Ygb3AgaXMgYSBzaW5nbGUgc3ltYm9sLCBzaGlmdCBpdCB2ZXJ0aWNhbGx5LlxuXG5cbiAgbGV0IGJhc2VTaGlmdCA9IDA7XG4gIGxldCBzbGFudCA9IDA7XG5cbiAgaWYgKChiYXNlIGluc3RhbmNlb2YgU3ltYm9sTm9kZSB8fCBncm91cC5uYW1lID09PSBcIlxcXFxvaWludFwiIHx8IGdyb3VwLm5hbWUgPT09IFwiXFxcXG9paWludFwiKSAmJiAhZ3JvdXAuc3VwcHJlc3NCYXNlU2hpZnQpIHtcbiAgICAvLyBXZSBzdXBwcmVzcyB0aGUgc2hpZnQgb2YgdGhlIGJhc2Ugb2YgXFxvdmVyc2V0IGFuZCBcXHVuZGVyc2V0LiBPdGhlcndpc2UsXG4gICAgLy8gc2hpZnQgdGhlIHN5bWJvbCBzbyBpdHMgY2VudGVyIGxpZXMgb24gdGhlIGF4aXMgKHJ1bGUgMTMpLiBJdFxuICAgIC8vIGFwcGVhcnMgdGhhdCBvdXIgZm9udHMgaGF2ZSB0aGUgY2VudGVycyBvZiB0aGUgc3ltYm9scyBhbHJlYWR5XG4gICAgLy8gYWxtb3N0IG9uIHRoZSBheGlzLCBzbyB0aGVzZSBudW1iZXJzIGFyZSB2ZXJ5IHNtYWxsLiBOb3RlIHdlXG4gICAgLy8gZG9uJ3QgYWN0dWFsbHkgYXBwbHkgdGhpcyBoZXJlLCBidXQgaW5zdGVhZCBpdCBpcyB1c2VkIGVpdGhlciBpblxuICAgIC8vIHRoZSB2bGlzdCBjcmVhdGlvbiBvciBzZXBhcmF0ZWx5IHdoZW4gdGhlcmUgYXJlIG5vIGxpbWl0cy5cbiAgICBiYXNlU2hpZnQgPSAoYmFzZS5oZWlnaHQgLSBiYXNlLmRlcHRoKSAvIDIgLSBvcHRpb25zLmZvbnRNZXRyaWNzKCkuYXhpc0hlaWdodDsgLy8gVGhlIHNsYW50IG9mIHRoZSBzeW1ib2wgaXMganVzdCBpdHMgaXRhbGljIGNvcnJlY3Rpb24uXG4gICAgLy8gJEZsb3dGaXhNZVxuXG4gICAgc2xhbnQgPSBiYXNlLml0YWxpYztcbiAgfVxuXG4gIGlmIChoYXNMaW1pdHMpIHtcbiAgICByZXR1cm4gYXNzZW1ibGVTdXBTdWIoYmFzZSwgc3VwR3JvdXAsIHN1Ykdyb3VwLCBvcHRpb25zLCBzdHlsZSwgc2xhbnQsIGJhc2VTaGlmdCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJhc2VTaGlmdCkge1xuICAgICAgYmFzZS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcbiAgICAgIGJhc2Uuc3R5bGUudG9wID0gbWFrZUVtKGJhc2VTaGlmdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cbn07XG5cbmNvbnN0IG9wX21hdGhtbEJ1aWxkZXIgPSAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgbGV0IG5vZGU7XG5cbiAgaWYgKGdyb3VwLnN5bWJvbCkge1xuICAgIC8vIFRoaXMgaXMgYSBzeW1ib2wuIEp1c3QgYWRkIHRoZSBzeW1ib2wuXG4gICAgbm9kZSA9IG5ldyBNYXRoTm9kZShcIm1vXCIsIFttYWtlVGV4dChncm91cC5uYW1lLCBncm91cC5tb2RlKV0pO1xuXG4gICAgaWYgKHV0aWxzLmNvbnRhaW5zKG5vU3VjY2Vzc29yLCBncm91cC5uYW1lKSkge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJsYXJnZW9wXCIsIFwiZmFsc2VcIik7XG4gICAgfVxuICB9IGVsc2UgaWYgKGdyb3VwLmJvZHkpIHtcbiAgICAvLyBUaGlzIGlzIGFuIG9wZXJhdG9yIHdpdGggY2hpbGRyZW4uIEFkZCB0aGVtLlxuICAgIG5vZGUgPSBuZXcgTWF0aE5vZGUoXCJtb1wiLCBidWlsZE1hdGhNTF9idWlsZEV4cHJlc3Npb24oZ3JvdXAuYm9keSwgb3B0aW9ucykpO1xuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgaXMgYSB0ZXh0IG9wZXJhdG9yLiBBZGQgYWxsIG9mIHRoZSBjaGFyYWN0ZXJzIGZyb20gdGhlXG4gICAgLy8gb3BlcmF0b3IncyBuYW1lLlxuICAgIG5vZGUgPSBuZXcgTWF0aE5vZGUoXCJtaVwiLCBbbmV3IFRleHROb2RlKGdyb3VwLm5hbWUuc2xpY2UoMSkpXSk7IC8vIEFwcGVuZCBhbiA8bW8+JkFwcGx5RnVuY3Rpb247PC9tbz4uXG4gICAgLy8gcmVmOiBodHRwczovL3d3dy53My5vcmcvVFIvUkVDLU1hdGhNTC9jaGFwM18yLmh0bWwjc2VjMy4yLjRcblxuICAgIGNvbnN0IG9wZXJhdG9yID0gbmV3IE1hdGhOb2RlKFwibW9cIiwgW21ha2VUZXh0KFwiXFx1MjA2MVwiLCBcInRleHRcIildKTtcblxuICAgIGlmIChncm91cC5wYXJlbnRJc1N1cFN1Yikge1xuICAgICAgbm9kZSA9IG5ldyBNYXRoTm9kZShcIm1yb3dcIiwgW25vZGUsIG9wZXJhdG9yXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUgPSBuZXdEb2N1bWVudEZyYWdtZW50KFtub2RlLCBvcGVyYXRvcl0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBub2RlO1xufTtcblxuY29uc3Qgc2luZ2xlQ2hhckJpZ09wcyA9IHtcbiAgXCJcXHUyMjBGXCI6IFwiXFxcXHByb2RcIixcbiAgXCJcXHUyMjEwXCI6IFwiXFxcXGNvcHJvZFwiLFxuICBcIlxcdTIyMTFcIjogXCJcXFxcc3VtXCIsXG4gIFwiXFx1MjJjMFwiOiBcIlxcXFxiaWd3ZWRnZVwiLFxuICBcIlxcdTIyYzFcIjogXCJcXFxcYmlndmVlXCIsXG4gIFwiXFx1MjJjMlwiOiBcIlxcXFxiaWdjYXBcIixcbiAgXCJcXHUyMmMzXCI6IFwiXFxcXGJpZ2N1cFwiLFxuICBcIlxcdTJhMDBcIjogXCJcXFxcYmlnb2RvdFwiLFxuICBcIlxcdTJhMDFcIjogXCJcXFxcYmlnb3BsdXNcIixcbiAgXCJcXHUyYTAyXCI6IFwiXFxcXGJpZ290aW1lc1wiLFxuICBcIlxcdTJhMDRcIjogXCJcXFxcYmlndXBsdXNcIixcbiAgXCJcXHUyYTA2XCI6IFwiXFxcXGJpZ3NxY3VwXCJcbn07XG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwib3BcIixcbiAgbmFtZXM6IFtcIlxcXFxjb3Byb2RcIiwgXCJcXFxcYmlndmVlXCIsIFwiXFxcXGJpZ3dlZGdlXCIsIFwiXFxcXGJpZ3VwbHVzXCIsIFwiXFxcXGJpZ2NhcFwiLCBcIlxcXFxiaWdjdXBcIiwgXCJcXFxcaW50b3BcIiwgXCJcXFxccHJvZFwiLCBcIlxcXFxzdW1cIiwgXCJcXFxcYmlnb3RpbWVzXCIsIFwiXFxcXGJpZ29wbHVzXCIsIFwiXFxcXGJpZ29kb3RcIiwgXCJcXFxcYmlnc3FjdXBcIiwgXCJcXFxcc21hbGxpbnRcIiwgXCJcXHUyMjBGXCIsIFwiXFx1MjIxMFwiLCBcIlxcdTIyMTFcIiwgXCJcXHUyMmMwXCIsIFwiXFx1MjJjMVwiLCBcIlxcdTIyYzJcIiwgXCJcXHUyMmMzXCIsIFwiXFx1MmEwMFwiLCBcIlxcdTJhMDFcIiwgXCJcXHUyYTAyXCIsIFwiXFx1MmEwNFwiLCBcIlxcdTJhMDZcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMFxuICB9LFxuICBoYW5kbGVyOiAoX3JlZiwgYXJncykgPT4ge1xuICAgIGxldCB7XG4gICAgICBwYXJzZXIsXG4gICAgICBmdW5jTmFtZVxuICAgIH0gPSBfcmVmO1xuICAgIGxldCBmTmFtZSA9IGZ1bmNOYW1lO1xuXG4gICAgaWYgKGZOYW1lLmxlbmd0aCA9PT0gMSkge1xuICAgICAgZk5hbWUgPSBzaW5nbGVDaGFyQmlnT3BzW2ZOYW1lXTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJvcFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBsaW1pdHM6IHRydWUsXG4gICAgICBwYXJlbnRJc1N1cFN1YjogZmFsc2UsXG4gICAgICBzeW1ib2w6IHRydWUsXG4gICAgICBuYW1lOiBmTmFtZVxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiBvcF9odG1sQnVpbGRlcixcbiAgbWF0aG1sQnVpbGRlcjogb3BfbWF0aG1sQnVpbGRlclxufSk7IC8vIE5vdGU6IGNhbGxpbmcgZGVmaW5lRnVuY3Rpb24gd2l0aCBhIHR5cGUgdGhhdCdzIGFscmVhZHkgYmVlbiBkZWZpbmVkIG9ubHlcbi8vIHdvcmtzIGJlY2F1c2UgdGhlIHNhbWUgaHRtbEJ1aWxkZXIgYW5kIG1hdGhtbEJ1aWxkZXIgYXJlIGJlaW5nIHVzZWQuXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJvcFwiLFxuICBuYW1lczogW1wiXFxcXG1hdGhvcFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIHByaW1pdGl2ZTogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiAoX3JlZjIsIGFyZ3MpID0+IHtcbiAgICBsZXQge1xuICAgICAgcGFyc2VyXG4gICAgfSA9IF9yZWYyO1xuICAgIGNvbnN0IGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIm9wXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGxpbWl0czogZmFsc2UsXG4gICAgICBwYXJlbnRJc1N1cFN1YjogZmFsc2UsXG4gICAgICBzeW1ib2w6IGZhbHNlLFxuICAgICAgYm9keTogb3JkYXJndW1lbnQoYm9keSlcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogb3BfaHRtbEJ1aWxkZXIsXG4gIG1hdGhtbEJ1aWxkZXI6IG9wX21hdGhtbEJ1aWxkZXJcbn0pOyAvLyBUaGVyZSBhcmUgMiBmbGFncyBmb3Igb3BlcmF0b3JzOyB3aGV0aGVyIHRoZXkgcHJvZHVjZSBsaW1pdHMgaW5cbi8vIGRpc3BsYXlzdHlsZSwgYW5kIHdoZXRoZXIgdGhleSBhcmUgc3ltYm9scyBhbmQgc2hvdWxkIGdyb3cgaW5cbi8vIGRpc3BsYXlzdHlsZS4gVGhlc2UgZm91ciBncm91cHMgY292ZXIgdGhlIGZvdXIgcG9zc2libGUgY2hvaWNlcy5cblxuY29uc3Qgc2luZ2xlQ2hhckludGVncmFscyA9IHtcbiAgXCJcXHUyMjJiXCI6IFwiXFxcXGludFwiLFxuICBcIlxcdTIyMmNcIjogXCJcXFxcaWludFwiLFxuICBcIlxcdTIyMmRcIjogXCJcXFxcaWlpbnRcIixcbiAgXCJcXHUyMjJlXCI6IFwiXFxcXG9pbnRcIixcbiAgXCJcXHUyMjJmXCI6IFwiXFxcXG9paW50XCIsXG4gIFwiXFx1MjIzMFwiOiBcIlxcXFxvaWlpbnRcIlxufTsgLy8gTm8gbGltaXRzLCBub3Qgc3ltYm9sc1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwib3BcIixcbiAgbmFtZXM6IFtcIlxcXFxhcmNzaW5cIiwgXCJcXFxcYXJjY29zXCIsIFwiXFxcXGFyY3RhblwiLCBcIlxcXFxhcmN0Z1wiLCBcIlxcXFxhcmNjdGdcIiwgXCJcXFxcYXJnXCIsIFwiXFxcXGNoXCIsIFwiXFxcXGNvc1wiLCBcIlxcXFxjb3NlY1wiLCBcIlxcXFxjb3NoXCIsIFwiXFxcXGNvdFwiLCBcIlxcXFxjb3RnXCIsIFwiXFxcXGNvdGhcIiwgXCJcXFxcY3NjXCIsIFwiXFxcXGN0Z1wiLCBcIlxcXFxjdGhcIiwgXCJcXFxcZGVnXCIsIFwiXFxcXGRpbVwiLCBcIlxcXFxleHBcIiwgXCJcXFxcaG9tXCIsIFwiXFxcXGtlclwiLCBcIlxcXFxsZ1wiLCBcIlxcXFxsblwiLCBcIlxcXFxsb2dcIiwgXCJcXFxcc2VjXCIsIFwiXFxcXHNpblwiLCBcIlxcXFxzaW5oXCIsIFwiXFxcXHNoXCIsIFwiXFxcXHRhblwiLCBcIlxcXFx0YW5oXCIsIFwiXFxcXHRnXCIsIFwiXFxcXHRoXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDBcbiAgfSxcblxuICBoYW5kbGVyKF9yZWYzKSB7XG4gICAgbGV0IHtcbiAgICAgIHBhcnNlcixcbiAgICAgIGZ1bmNOYW1lXG4gICAgfSA9IF9yZWYzO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIm9wXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGxpbWl0czogZmFsc2UsXG4gICAgICBwYXJlbnRJc1N1cFN1YjogZmFsc2UsXG4gICAgICBzeW1ib2w6IGZhbHNlLFxuICAgICAgbmFtZTogZnVuY05hbWVcbiAgICB9O1xuICB9LFxuXG4gIGh0bWxCdWlsZGVyOiBvcF9odG1sQnVpbGRlcixcbiAgbWF0aG1sQnVpbGRlcjogb3BfbWF0aG1sQnVpbGRlclxufSk7IC8vIExpbWl0cywgbm90IHN5bWJvbHNcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcIm9wXCIsXG4gIG5hbWVzOiBbXCJcXFxcZGV0XCIsIFwiXFxcXGdjZFwiLCBcIlxcXFxpbmZcIiwgXCJcXFxcbGltXCIsIFwiXFxcXG1heFwiLCBcIlxcXFxtaW5cIiwgXCJcXFxcUHJcIiwgXCJcXFxcc3VwXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDBcbiAgfSxcblxuICBoYW5kbGVyKF9yZWY0KSB7XG4gICAgbGV0IHtcbiAgICAgIHBhcnNlcixcbiAgICAgIGZ1bmNOYW1lXG4gICAgfSA9IF9yZWY0O1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIm9wXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGxpbWl0czogdHJ1ZSxcbiAgICAgIHBhcmVudElzU3VwU3ViOiBmYWxzZSxcbiAgICAgIHN5bWJvbDogZmFsc2UsXG4gICAgICBuYW1lOiBmdW5jTmFtZVxuICAgIH07XG4gIH0sXG5cbiAgaHRtbEJ1aWxkZXI6IG9wX2h0bWxCdWlsZGVyLFxuICBtYXRobWxCdWlsZGVyOiBvcF9tYXRobWxCdWlsZGVyXG59KTsgLy8gTm8gbGltaXRzLCBzeW1ib2xzXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJvcFwiLFxuICBuYW1lczogW1wiXFxcXGludFwiLCBcIlxcXFxpaW50XCIsIFwiXFxcXGlpaW50XCIsIFwiXFxcXG9pbnRcIiwgXCJcXFxcb2lpbnRcIiwgXCJcXFxcb2lpaW50XCIsIFwiXFx1MjIyYlwiLCBcIlxcdTIyMmNcIiwgXCJcXHUyMjJkXCIsIFwiXFx1MjIyZVwiLCBcIlxcdTIyMmZcIiwgXCJcXHUyMjMwXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDBcbiAgfSxcblxuICBoYW5kbGVyKF9yZWY1KSB7XG4gICAgbGV0IHtcbiAgICAgIHBhcnNlcixcbiAgICAgIGZ1bmNOYW1lXG4gICAgfSA9IF9yZWY1O1xuICAgIGxldCBmTmFtZSA9IGZ1bmNOYW1lO1xuXG4gICAgaWYgKGZOYW1lLmxlbmd0aCA9PT0gMSkge1xuICAgICAgZk5hbWUgPSBzaW5nbGVDaGFySW50ZWdyYWxzW2ZOYW1lXTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJvcFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBsaW1pdHM6IGZhbHNlLFxuICAgICAgcGFyZW50SXNTdXBTdWI6IGZhbHNlLFxuICAgICAgc3ltYm9sOiB0cnVlLFxuICAgICAgbmFtZTogZk5hbWVcbiAgICB9O1xuICB9LFxuXG4gIGh0bWxCdWlsZGVyOiBvcF9odG1sQnVpbGRlcixcbiAgbWF0aG1sQnVpbGRlcjogb3BfbWF0aG1sQnVpbGRlclxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZnVuY3Rpb25zL29wZXJhdG9ybmFtZS5qc1xuXG5cblxuXG5cblxuXG5cblxuLy8gTk9URTogVW5saWtlIG1vc3QgYGh0bWxCdWlsZGVyYHMsIHRoaXMgb25lIGhhbmRsZXMgbm90IG9ubHlcbi8vIFwib3BlcmF0b3JuYW1lXCIsIGJ1dCBhbHNvICBcInN1cHN1YlwiIHNpbmNlIFxcb3BlcmF0b3JuYW1lKiBjYW5cbi8vIGFmZmVjdCBzdXBlci9zdWJzY3JpcHRpbmcuXG5jb25zdCBvcGVyYXRvcm5hbWVfaHRtbEJ1aWxkZXIgPSAoZ3JwLCBvcHRpb25zKSA9PiB7XG4gIC8vIE9wZXJhdG9ycyBhcmUgaGFuZGxlZCBpbiB0aGUgVGVYYm9vayBwZy4gNDQzLTQ0NCwgcnVsZSAxMyhhKS5cbiAgbGV0IHN1cEdyb3VwO1xuICBsZXQgc3ViR3JvdXA7XG4gIGxldCBoYXNMaW1pdHMgPSBmYWxzZTtcbiAgbGV0IGdyb3VwO1xuXG4gIGlmIChncnAudHlwZSA9PT0gXCJzdXBzdWJcIikge1xuICAgIC8vIElmIHdlIGhhdmUgbGltaXRzLCBzdXBzdWIgd2lsbCBwYXNzIHVzIGl0cyBncm91cCB0byBoYW5kbGUuIFB1bGxcbiAgICAvLyBvdXQgdGhlIHN1cGVyc2NyaXB0IGFuZCBzdWJzY3JpcHQgYW5kIHNldCB0aGUgZ3JvdXAgdG8gdGhlIG9wIGluXG4gICAgLy8gaXRzIGJhc2UuXG4gICAgc3VwR3JvdXAgPSBncnAuc3VwO1xuICAgIHN1Ykdyb3VwID0gZ3JwLnN1YjtcbiAgICBncm91cCA9IGFzc2VydE5vZGVUeXBlKGdycC5iYXNlLCBcIm9wZXJhdG9ybmFtZVwiKTtcbiAgICBoYXNMaW1pdHMgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIGdyb3VwID0gYXNzZXJ0Tm9kZVR5cGUoZ3JwLCBcIm9wZXJhdG9ybmFtZVwiKTtcbiAgfVxuXG4gIGxldCBiYXNlO1xuXG4gIGlmIChncm91cC5ib2R5Lmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBib2R5ID0gZ3JvdXAuYm9keS5tYXAoY2hpbGQgPT4ge1xuICAgICAgLy8gJEZsb3dGaXhNZTogQ2hlY2sgaWYgdGhlIG5vZGUgaGFzIGEgc3RyaW5nIGB0ZXh0YCBwcm9wZXJ0eS5cbiAgICAgIGNvbnN0IGNoaWxkVGV4dCA9IGNoaWxkLnRleHQ7XG5cbiAgICAgIGlmICh0eXBlb2YgY2hpbGRUZXh0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJ0ZXh0b3JkXCIsXG4gICAgICAgICAgbW9kZTogY2hpbGQubW9kZSxcbiAgICAgICAgICB0ZXh0OiBjaGlsZFRleHRcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgIH1cbiAgICB9KTsgLy8gQ29uc29saWRhdGUgZnVuY3Rpb24gbmFtZXMgaW50byBzeW1ib2wgY2hhcmFjdGVycy5cblxuICAgIGNvbnN0IGV4cHJlc3Npb24gPSBidWlsZEV4cHJlc3Npb24oYm9keSwgb3B0aW9ucy53aXRoRm9udChcIm1hdGhybVwiKSwgdHJ1ZSk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4cHJlc3Npb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gZXhwcmVzc2lvbltpXTtcblxuICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgU3ltYm9sTm9kZSkge1xuICAgICAgICAvLyBQZXIgYW1zb3BuIHBhY2thZ2UsXG4gICAgICAgIC8vIGNoYW5nZSBtaW51cyB0byBoeXBoZW4gYW5kIFxcYXN0IHRvIGFzdGVyaXNrXG4gICAgICAgIGNoaWxkLnRleHQgPSBjaGlsZC50ZXh0LnJlcGxhY2UoL1xcdTIyMTIvLCBcIi1cIikucmVwbGFjZSgvXFx1MjIxNy8sIFwiKlwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBiYXNlID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibW9wXCJdLCBleHByZXNzaW9uLCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICBiYXNlID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibW9wXCJdLCBbXSwgb3B0aW9ucyk7XG4gIH1cblxuICBpZiAoaGFzTGltaXRzKSB7XG4gICAgcmV0dXJuIGFzc2VtYmxlU3VwU3ViKGJhc2UsIHN1cEdyb3VwLCBzdWJHcm91cCwgb3B0aW9ucywgb3B0aW9ucy5zdHlsZSwgMCwgMCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cbn07XG5cbmNvbnN0IG9wZXJhdG9ybmFtZV9tYXRobWxCdWlsZGVyID0gKGdyb3VwLCBvcHRpb25zKSA9PiB7XG4gIC8vIFRoZSBzdGVwcyB0YWtlbiBoZXJlIGFyZSBzaW1pbGFyIHRvIHRoZSBodG1sIHZlcnNpb24uXG4gIGxldCBleHByZXNzaW9uID0gYnVpbGRNYXRoTUxfYnVpbGRFeHByZXNzaW9uKGdyb3VwLmJvZHksIG9wdGlvbnMud2l0aEZvbnQoXCJtYXRocm1cIikpOyAvLyBJcyBleHByZXNzaW9uIGEgc3RyaW5nIG9yIGhhcyBpdCBzb21ldGhpbmcgbGlrZSBhIGZyYWN0aW9uP1xuXG4gIGxldCBpc0FsbFN0cmluZyA9IHRydWU7IC8vIGRlZmF1bHRcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGV4cHJlc3Npb24ubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gZXhwcmVzc2lvbltpXTtcblxuICAgIGlmIChub2RlIGluc3RhbmNlb2YgbWF0aE1MVHJlZS5TcGFjZU5vZGUpIHsvLyBEbyBub3RoaW5nXG4gICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgbWF0aE1MVHJlZS5NYXRoTm9kZSkge1xuICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcIm1pXCI6XG4gICAgICAgIGNhc2UgXCJtblwiOlxuICAgICAgICBjYXNlIFwibXNcIjpcbiAgICAgICAgY2FzZSBcIm1zcGFjZVwiOlxuICAgICAgICBjYXNlIFwibXRleHRcIjpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gRG8gbm90aGluZyB5ZXQuXG5cbiAgICAgICAgY2FzZSBcIm1vXCI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmNoaWxkcmVuWzBdO1xuXG4gICAgICAgICAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgY2hpbGQgaW5zdGFuY2VvZiBtYXRoTUxUcmVlLlRleHROb2RlKSB7XG4gICAgICAgICAgICAgIGNoaWxkLnRleHQgPSBjaGlsZC50ZXh0LnJlcGxhY2UoL1xcdTIyMTIvLCBcIi1cIikucmVwbGFjZSgvXFx1MjIxNy8sIFwiKlwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlzQWxsU3RyaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlzQWxsU3RyaW5nID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlzQWxsU3RyaW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzQWxsU3RyaW5nKSB7XG4gICAgLy8gV3JpdGUgYSBzaW5nbGUgVGV4dE5vZGUgaW5zdGVhZCBvZiBtdWx0aXBsZSBuZXN0ZWQgdGFncy5cbiAgICBjb25zdCB3b3JkID0gZXhwcmVzc2lvbi5tYXAobm9kZSA9PiBub2RlLnRvVGV4dCgpKS5qb2luKFwiXCIpO1xuICAgIGV4cHJlc3Npb24gPSBbbmV3IG1hdGhNTFRyZWUuVGV4dE5vZGUod29yZCldO1xuICB9XG5cbiAgY29uc3QgaWRlbnRpZmllciA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibWlcIiwgZXhwcmVzc2lvbik7XG4gIGlkZW50aWZpZXIuc2V0QXR0cmlidXRlKFwibWF0aHZhcmlhbnRcIiwgXCJub3JtYWxcIik7IC8vIFxcdTIwNjEgaXMgdGhlIHNhbWUgYXMgJkFwcGx5RnVuY3Rpb247XG4gIC8vIHJlZjogaHR0cHM6Ly93d3cudzNzY2hvb2xzLmNvbS9jaGFyc2V0cy9yZWZfaHRtbF9lbnRpdGllc19hLmFzcFxuXG4gIGNvbnN0IG9wZXJhdG9yID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb1wiLCBbbWFrZVRleHQoXCJcXHUyMDYxXCIsIFwidGV4dFwiKV0pO1xuXG4gIGlmIChncm91cC5wYXJlbnRJc1N1cFN1Yikge1xuICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb3dcIiwgW2lkZW50aWZpZXIsIG9wZXJhdG9yXSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG1hdGhNTFRyZWUubmV3RG9jdW1lbnRGcmFnbWVudChbaWRlbnRpZmllciwgb3BlcmF0b3JdKTtcbiAgfVxufTsgLy8gXFxvcGVyYXRvcm5hbWVcbi8vIGFtc29wbi5kdHg6IFxcbWF0aG9weyMxXFxrZXJuXFx6QFxcb3BlcmF0b3JAZm9udCMzfVxcbmV3bWNvZGVzQFxuXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJvcGVyYXRvcm5hbWVcIixcbiAgbmFtZXM6IFtcIlxcXFxvcGVyYXRvcm5hbWVAXCIsIFwiXFxcXG9wZXJhdG9ybmFtZXdpdGhsaW1pdHNcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMVxuICB9LFxuICBoYW5kbGVyOiAoX3JlZiwgYXJncykgPT4ge1xuICAgIGxldCB7XG4gICAgICBwYXJzZXIsXG4gICAgICBmdW5jTmFtZVxuICAgIH0gPSBfcmVmO1xuICAgIGNvbnN0IGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIm9wZXJhdG9ybmFtZVwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBib2R5OiBvcmRhcmd1bWVudChib2R5KSxcbiAgICAgIGFsd2F5c0hhbmRsZVN1cFN1YjogZnVuY05hbWUgPT09IFwiXFxcXG9wZXJhdG9ybmFtZXdpdGhsaW1pdHNcIixcbiAgICAgIGxpbWl0czogZmFsc2UsXG4gICAgICBwYXJlbnRJc1N1cFN1YjogZmFsc2VcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogb3BlcmF0b3JuYW1lX2h0bWxCdWlsZGVyLFxuICBtYXRobWxCdWlsZGVyOiBvcGVyYXRvcm5hbWVfbWF0aG1sQnVpbGRlclxufSk7XG5kZWZpbmVNYWNybyhcIlxcXFxvcGVyYXRvcm5hbWVcIiwgXCJcXFxcQGlmc3RhclxcXFxvcGVyYXRvcm5hbWV3aXRobGltaXRzXFxcXG9wZXJhdG9ybmFtZUBcIik7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZnVuY3Rpb25zL29yZGdyb3VwLmpzXG5cblxuXG5cbmRlZmluZUZ1bmN0aW9uQnVpbGRlcnMoe1xuICB0eXBlOiBcIm9yZGdyb3VwXCIsXG5cbiAgaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICBpZiAoZ3JvdXAuc2VtaXNpbXBsZSkge1xuICAgICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VGcmFnbWVudChidWlsZEV4cHJlc3Npb24oZ3JvdXAuYm9keSwgb3B0aW9ucywgZmFsc2UpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibW9yZFwiXSwgYnVpbGRFeHByZXNzaW9uKGdyb3VwLmJvZHksIG9wdGlvbnMsIHRydWUpLCBvcHRpb25zKTtcbiAgfSxcblxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGJ1aWxkRXhwcmVzc2lvblJvdyhncm91cC5ib2R5LCBvcHRpb25zLCB0cnVlKTtcbiAgfVxuXG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mdW5jdGlvbnMvb3ZlcmxpbmUuanNcblxuXG5cblxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwib3ZlcmxpbmVcIixcbiAgbmFtZXM6IFtcIlxcXFxvdmVybGluZVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxXG4gIH0sXG5cbiAgaGFuZGxlcihfcmVmLCBhcmdzKSB7XG4gICAgbGV0IHtcbiAgICAgIHBhcnNlclxuICAgIH0gPSBfcmVmO1xuICAgIGNvbnN0IGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIm92ZXJsaW5lXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGJvZHlcbiAgICB9O1xuICB9LFxuXG4gIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gT3ZlcmxpbmVzIGFyZSBoYW5kbGVkIGluIHRoZSBUZVhib29rIHBnIDQ0MywgUnVsZSA5LlxuICAgIC8vIEJ1aWxkIHRoZSBpbm5lciBncm91cCBpbiB0aGUgY3JhbXBlZCBzdHlsZS5cbiAgICBjb25zdCBpbm5lckdyb3VwID0gYnVpbGRHcm91cChncm91cC5ib2R5LCBvcHRpb25zLmhhdmluZ0NyYW1wZWRTdHlsZSgpKTsgLy8gQ3JlYXRlIHRoZSBsaW5lIGFib3ZlIHRoZSBib2R5XG5cbiAgICBjb25zdCBsaW5lID0gYnVpbGRDb21tb24ubWFrZUxpbmVTcGFuKFwib3ZlcmxpbmUtbGluZVwiLCBvcHRpb25zKTsgLy8gR2VuZXJhdGUgdGhlIHZsaXN0LCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBrZXJuc1xuXG4gICAgY29uc3QgZGVmYXVsdFJ1bGVUaGlja25lc3MgPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkuZGVmYXVsdFJ1bGVUaGlja25lc3M7XG4gICAgY29uc3Qgdmxpc3QgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgcG9zaXRpb25UeXBlOiBcImZpcnN0QmFzZWxpbmVcIixcbiAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogaW5uZXJHcm91cFxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImtlcm5cIixcbiAgICAgICAgc2l6ZTogMyAqIGRlZmF1bHRSdWxlVGhpY2tuZXNzXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBsaW5lXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwia2VyblwiLFxuICAgICAgICBzaXplOiBkZWZhdWx0UnVsZVRoaWNrbmVzc1xuICAgICAgfV1cbiAgICB9LCBvcHRpb25zKTtcbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibW9yZFwiLCBcIm92ZXJsaW5lXCJdLCBbdmxpc3RdLCBvcHRpb25zKTtcbiAgfSxcblxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgb3BlcmF0b3IgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vXCIsIFtuZXcgbWF0aE1MVHJlZS5UZXh0Tm9kZShcIlxcdTIwM2VcIildKTtcbiAgICBvcGVyYXRvci5zZXRBdHRyaWJ1dGUoXCJzdHJldGNoeVwiLCBcInRydWVcIik7XG4gICAgY29uc3Qgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW92ZXJcIiwgW2J1aWxkTWF0aE1MX2J1aWxkR3JvdXAoZ3JvdXAuYm9keSwgb3B0aW9ucyksIG9wZXJhdG9yXSk7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJhY2NlbnRcIiwgXCJ0cnVlXCIpO1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy9waGFudG9tLmpzXG5cblxuXG5cblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInBoYW50b21cIixcbiAgbmFtZXM6IFtcIlxcXFxwaGFudG9tXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiAoX3JlZiwgYXJncykgPT4ge1xuICAgIGxldCB7XG4gICAgICBwYXJzZXJcbiAgICB9ID0gX3JlZjtcbiAgICBjb25zdCBib2R5ID0gYXJnc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJwaGFudG9tXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGJvZHk6IG9yZGFyZ3VtZW50KGJvZHkpXG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IChncm91cCwgb3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IGVsZW1lbnRzID0gYnVpbGRFeHByZXNzaW9uKGdyb3VwLmJvZHksIG9wdGlvbnMud2l0aFBoYW50b20oKSwgZmFsc2UpOyAvLyBcXHBoYW50b20gaXNuJ3Qgc3VwcG9zZWQgdG8gYWZmZWN0IHRoZSBlbGVtZW50cyBpdCBjb250YWlucy5cbiAgICAvLyBTZWUgXCJjb2xvclwiIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZUZyYWdtZW50KGVsZW1lbnRzKTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogKGdyb3VwLCBvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgaW5uZXIgPSBidWlsZE1hdGhNTF9idWlsZEV4cHJlc3Npb24oZ3JvdXAuYm9keSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXBoYW50b21cIiwgaW5uZXIpO1xuICB9XG59KTtcbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJocGhhbnRvbVwiLFxuICBuYW1lczogW1wiXFxcXGhwaGFudG9tXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiAoX3JlZjIsIGFyZ3MpID0+IHtcbiAgICBsZXQge1xuICAgICAgcGFyc2VyXG4gICAgfSA9IF9yZWYyO1xuICAgIGNvbnN0IGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImhwaGFudG9tXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGJvZHlcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogKGdyb3VwLCBvcHRpb25zKSA9PiB7XG4gICAgbGV0IG5vZGUgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXSwgW2J1aWxkR3JvdXAoZ3JvdXAuYm9keSwgb3B0aW9ucy53aXRoUGhhbnRvbSgpKV0pO1xuICAgIG5vZGUuaGVpZ2h0ID0gMDtcbiAgICBub2RlLmRlcHRoID0gMDtcblxuICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbm9kZS5jaGlsZHJlbltpXS5oZWlnaHQgPSAwO1xuICAgICAgICBub2RlLmNoaWxkcmVuW2ldLmRlcHRoID0gMDtcbiAgICAgIH1cbiAgICB9IC8vIFNlZSBzbWFzaCBmb3IgY29tbWVudCByZTogdXNlIG9mIG1ha2VWTGlzdFxuXG5cbiAgICBub2RlID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHtcbiAgICAgIHBvc2l0aW9uVHlwZTogXCJmaXJzdEJhc2VsaW5lXCIsXG4gICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IG5vZGVcbiAgICAgIH1dXG4gICAgfSwgb3B0aW9ucyk7IC8vIEZvciBzcGFjaW5nLCBUZVggdHJlYXRzIFxcc21hc2ggYXMgYSBtYXRoIGdyb3VwIChzYW1lIHNwYWNpbmcgYXMgb3JkKS5cblxuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtb3JkXCJdLCBbbm9kZV0sIG9wdGlvbnMpO1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgICBjb25zdCBpbm5lciA9IGJ1aWxkTWF0aE1MX2J1aWxkRXhwcmVzc2lvbihvcmRhcmd1bWVudChncm91cC5ib2R5KSwgb3B0aW9ucyk7XG4gICAgY29uc3QgcGhhbnRvbSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXBoYW50b21cIiwgaW5uZXIpO1xuICAgIGNvbnN0IG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1wYWRkZWRcIiwgW3BoYW50b21dKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBcIjBweFwiKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcImRlcHRoXCIsIFwiMHB4XCIpO1xuICAgIHJldHVybiBub2RlO1xuICB9XG59KTtcbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJ2cGhhbnRvbVwiLFxuICBuYW1lczogW1wiXFxcXHZwaGFudG9tXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiAoX3JlZjMsIGFyZ3MpID0+IHtcbiAgICBsZXQge1xuICAgICAgcGFyc2VyXG4gICAgfSA9IF9yZWYzO1xuICAgIGNvbnN0IGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInZwaGFudG9tXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGJvZHlcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogKGdyb3VwLCBvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgaW5uZXIgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJpbm5lclwiXSwgW2J1aWxkR3JvdXAoZ3JvdXAuYm9keSwgb3B0aW9ucy53aXRoUGhhbnRvbSgpKV0pO1xuICAgIGNvbnN0IGZpeCA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcImZpeFwiXSwgW10pO1xuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtb3JkXCIsIFwicmxhcFwiXSwgW2lubmVyLCBmaXhdLCBvcHRpb25zKTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogKGdyb3VwLCBvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgaW5uZXIgPSBidWlsZE1hdGhNTF9idWlsZEV4cHJlc3Npb24ob3JkYXJndW1lbnQoZ3JvdXAuYm9keSksIG9wdGlvbnMpO1xuICAgIGNvbnN0IHBoYW50b20gPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1waGFudG9tXCIsIGlubmVyKTtcbiAgICBjb25zdCBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcGFkZGVkXCIsIFtwaGFudG9tXSk7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIjBweFwiKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZnVuY3Rpb25zL3JhaXNlYm94LmpzXG5cblxuXG5cblxuXG4gLy8gQm94IG1hbmlwdWxhdGlvblxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwicmFpc2Vib3hcIixcbiAgbmFtZXM6IFtcIlxcXFxyYWlzZWJveFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAyLFxuICAgIGFyZ1R5cGVzOiBbXCJzaXplXCIsIFwiaGJveFwiXSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG5cbiAgaGFuZGxlcihfcmVmLCBhcmdzKSB7XG4gICAgbGV0IHtcbiAgICAgIHBhcnNlclxuICAgIH0gPSBfcmVmO1xuICAgIGNvbnN0IGFtb3VudCA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwic2l6ZVwiKS52YWx1ZTtcbiAgICBjb25zdCBib2R5ID0gYXJnc1sxXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJyYWlzZWJveFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBkeTogYW1vdW50LFxuICAgICAgYm9keVxuICAgIH07XG4gIH0sXG5cbiAgaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBib2R5ID0gYnVpbGRHcm91cChncm91cC5ib2R5LCBvcHRpb25zKTtcbiAgICBjb25zdCBkeSA9IGNhbGN1bGF0ZVNpemUoZ3JvdXAuZHksIG9wdGlvbnMpO1xuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgcG9zaXRpb25UeXBlOiBcInNoaWZ0XCIsXG4gICAgICBwb3NpdGlvbkRhdGE6IC1keSxcbiAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogYm9keVxuICAgICAgfV1cbiAgICB9LCBvcHRpb25zKTtcbiAgfSxcblxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXBhZGRlZFwiLCBbYnVpbGRNYXRoTUxfYnVpbGRHcm91cChncm91cC5ib2R5LCBvcHRpb25zKV0pO1xuICAgIGNvbnN0IGR5ID0gZ3JvdXAuZHkubnVtYmVyICsgZ3JvdXAuZHkudW5pdDtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcInZvZmZzZXRcIiwgZHkpO1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy9yZWxheC5qc1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiaW50ZXJuYWxcIixcbiAgbmFtZXM6IFtcIlxcXFxyZWxheFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcblxuICBoYW5kbGVyKF9yZWYpIHtcbiAgICBsZXQge1xuICAgICAgcGFyc2VyXG4gICAgfSA9IF9yZWY7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiaW50ZXJuYWxcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlXG4gICAgfTtcbiAgfVxuXG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mdW5jdGlvbnMvcnVsZS5qc1xuXG5cblxuXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJydWxlXCIsXG4gIG5hbWVzOiBbXCJcXFxccnVsZVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAyLFxuICAgIG51bU9wdGlvbmFsQXJnczogMSxcbiAgICBhcmdUeXBlczogW1wic2l6ZVwiLCBcInNpemVcIiwgXCJzaXplXCJdXG4gIH0sXG5cbiAgaGFuZGxlcihfcmVmLCBhcmdzLCBvcHRBcmdzKSB7XG4gICAgbGV0IHtcbiAgICAgIHBhcnNlclxuICAgIH0gPSBfcmVmO1xuICAgIGNvbnN0IHNoaWZ0ID0gb3B0QXJnc1swXTtcbiAgICBjb25zdCB3aWR0aCA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwic2l6ZVwiKTtcbiAgICBjb25zdCBoZWlnaHQgPSBhc3NlcnROb2RlVHlwZShhcmdzWzFdLCBcInNpemVcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwicnVsZVwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBzaGlmdDogc2hpZnQgJiYgYXNzZXJ0Tm9kZVR5cGUoc2hpZnQsIFwic2l6ZVwiKS52YWx1ZSxcbiAgICAgIHdpZHRoOiB3aWR0aC52YWx1ZSxcbiAgICAgIGhlaWdodDogaGVpZ2h0LnZhbHVlXG4gICAgfTtcbiAgfSxcblxuICBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIC8vIE1ha2UgYW4gZW1wdHkgc3BhbiBmb3IgdGhlIHJ1bGVcbiAgICBjb25zdCBydWxlID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibW9yZFwiLCBcInJ1bGVcIl0sIFtdLCBvcHRpb25zKTsgLy8gQ2FsY3VsYXRlIHRoZSBzaGlmdCwgd2lkdGgsIGFuZCBoZWlnaHQgb2YgdGhlIHJ1bGUsIGFuZCBhY2NvdW50IGZvciB1bml0c1xuXG4gICAgY29uc3Qgd2lkdGggPSBjYWxjdWxhdGVTaXplKGdyb3VwLndpZHRoLCBvcHRpb25zKTtcbiAgICBjb25zdCBoZWlnaHQgPSBjYWxjdWxhdGVTaXplKGdyb3VwLmhlaWdodCwgb3B0aW9ucyk7XG4gICAgY29uc3Qgc2hpZnQgPSBncm91cC5zaGlmdCA/IGNhbGN1bGF0ZVNpemUoZ3JvdXAuc2hpZnQsIG9wdGlvbnMpIDogMDsgLy8gU3R5bGUgdGhlIHJ1bGUgdG8gdGhlIHJpZ2h0IHNpemVcblxuICAgIHJ1bGUuc3R5bGUuYm9yZGVyUmlnaHRXaWR0aCA9IG1ha2VFbSh3aWR0aCk7XG4gICAgcnVsZS5zdHlsZS5ib3JkZXJUb3BXaWR0aCA9IG1ha2VFbShoZWlnaHQpO1xuICAgIHJ1bGUuc3R5bGUuYm90dG9tID0gbWFrZUVtKHNoaWZ0KTsgLy8gUmVjb3JkIHRoZSBoZWlnaHQgYW5kIHdpZHRoXG5cbiAgICBydWxlLndpZHRoID0gd2lkdGg7XG4gICAgcnVsZS5oZWlnaHQgPSBoZWlnaHQgKyBzaGlmdDtcbiAgICBydWxlLmRlcHRoID0gLXNoaWZ0OyAvLyBGb250IHNpemUgaXMgdGhlIG51bWJlciBsYXJnZSBlbm91Z2ggdGhhdCB0aGUgYnJvd3NlciB3aWxsXG4gICAgLy8gcmVzZXJ2ZSBhdCBsZWFzdCBgYWJzSGVpZ2h0YCBzcGFjZSBhYm92ZSB0aGUgYmFzZWxpbmUuXG4gICAgLy8gVGhlIDEuMTI1IGZhY3RvciB3YXMgZW1waXJpY2FsbHkgZGV0ZXJtaW5lZFxuXG4gICAgcnVsZS5tYXhGb250U2l6ZSA9IGhlaWdodCAqIDEuMTI1ICogb3B0aW9ucy5zaXplTXVsdGlwbGllcjtcbiAgICByZXR1cm4gcnVsZTtcbiAgfSxcblxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgd2lkdGggPSBjYWxjdWxhdGVTaXplKGdyb3VwLndpZHRoLCBvcHRpb25zKTtcbiAgICBjb25zdCBoZWlnaHQgPSBjYWxjdWxhdGVTaXplKGdyb3VwLmhlaWdodCwgb3B0aW9ucyk7XG4gICAgY29uc3Qgc2hpZnQgPSBncm91cC5zaGlmdCA/IGNhbGN1bGF0ZVNpemUoZ3JvdXAuc2hpZnQsIG9wdGlvbnMpIDogMDtcbiAgICBjb25zdCBjb2xvciA9IG9wdGlvbnMuY29sb3IgJiYgb3B0aW9ucy5nZXRDb2xvcigpIHx8IFwiYmxhY2tcIjtcbiAgICBjb25zdCBydWxlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtc3BhY2VcIik7XG4gICAgcnVsZS5zZXRBdHRyaWJ1dGUoXCJtYXRoYmFja2dyb3VuZFwiLCBjb2xvcik7XG4gICAgcnVsZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBtYWtlRW0od2lkdGgpKTtcbiAgICBydWxlLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBtYWtlRW0oaGVpZ2h0KSk7XG4gICAgY29uc3Qgd3JhcHBlciA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXBhZGRlZFwiLCBbcnVsZV0pO1xuXG4gICAgaWYgKHNoaWZ0ID49IDApIHtcbiAgICAgIHdyYXBwZXIuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIG1ha2VFbShzaGlmdCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3cmFwcGVyLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBtYWtlRW0oc2hpZnQpKTtcbiAgICAgIHdyYXBwZXIuc2V0QXR0cmlidXRlKFwiZGVwdGhcIiwgbWFrZUVtKC1zaGlmdCkpO1xuICAgIH1cblxuICAgIHdyYXBwZXIuc2V0QXR0cmlidXRlKFwidm9mZnNldFwiLCBtYWtlRW0oc2hpZnQpKTtcbiAgICByZXR1cm4gd3JhcHBlcjtcbiAgfVxuXG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mdW5jdGlvbnMvc2l6aW5nLmpzXG5cblxuXG5cblxuXG5mdW5jdGlvbiBzaXppbmdHcm91cCh2YWx1ZSwgb3B0aW9ucywgYmFzZU9wdGlvbnMpIHtcbiAgY29uc3QgaW5uZXIgPSBidWlsZEV4cHJlc3Npb24odmFsdWUsIG9wdGlvbnMsIGZhbHNlKTtcbiAgY29uc3QgbXVsdGlwbGllciA9IG9wdGlvbnMuc2l6ZU11bHRpcGxpZXIgLyBiYXNlT3B0aW9ucy5zaXplTXVsdGlwbGllcjsgLy8gQWRkIHNpemUtcmVzZXR0aW5nIGNsYXNzZXMgdG8gdGhlIGlubmVyIGxpc3QgYW5kIHNldCBtYXhGb250U2l6ZVxuICAvLyBtYW51YWxseS4gSGFuZGxlIG5lc3RlZCBzaXplIGNoYW5nZXMuXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbm5lci5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHBvcyA9IGlubmVyW2ldLmNsYXNzZXMuaW5kZXhPZihcInNpemluZ1wiKTtcblxuICAgIGlmIChwb3MgPCAwKSB7XG4gICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShpbm5lcltpXS5jbGFzc2VzLCBvcHRpb25zLnNpemluZ0NsYXNzZXMoYmFzZU9wdGlvbnMpKTtcbiAgICB9IGVsc2UgaWYgKGlubmVyW2ldLmNsYXNzZXNbcG9zICsgMV0gPT09IFwicmVzZXQtc2l6ZVwiICsgb3B0aW9ucy5zaXplKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgbmVzdGVkIHNpemUgY2hhbmdlOiBlLmcuLCBpbm5lcltpXSBpcyB0aGUgXCJiXCIgaW5cbiAgICAgIC8vIGBcXEh1Z2UgYSBcXHNtYWxsIGJgLiBPdmVycmlkZSB0aGUgb2xkIHNpemUgKHRoZSBgcmVzZXQtYCBjbGFzcylcbiAgICAgIC8vIGJ1dCBub3QgdGhlIG5ldyBzaXplLlxuICAgICAgaW5uZXJbaV0uY2xhc3Nlc1twb3MgKyAxXSA9IFwicmVzZXQtc2l6ZVwiICsgYmFzZU9wdGlvbnMuc2l6ZTtcbiAgICB9XG5cbiAgICBpbm5lcltpXS5oZWlnaHQgKj0gbXVsdGlwbGllcjtcbiAgICBpbm5lcltpXS5kZXB0aCAqPSBtdWx0aXBsaWVyO1xuICB9XG5cbiAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VGcmFnbWVudChpbm5lcik7XG59XG5jb25zdCBzaXplRnVuY3MgPSBbXCJcXFxcdGlueVwiLCBcIlxcXFxzaXhwdHNpemVcIiwgXCJcXFxcc2NyaXB0c2l6ZVwiLCBcIlxcXFxmb290bm90ZXNpemVcIiwgXCJcXFxcc21hbGxcIiwgXCJcXFxcbm9ybWFsc2l6ZVwiLCBcIlxcXFxsYXJnZVwiLCBcIlxcXFxMYXJnZVwiLCBcIlxcXFxMQVJHRVwiLCBcIlxcXFxodWdlXCIsIFwiXFxcXEh1Z2VcIl07XG5jb25zdCBzaXppbmdfaHRtbEJ1aWxkZXIgPSAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgLy8gSGFuZGxlIHNpemluZyBvcGVyYXRvcnMgbGlrZSBcXEh1Z2UuIFJlYWwgVGVYIGRvZXNuJ3QgYWN0dWFsbHkgYWxsb3dcbiAgLy8gdGhlc2UgZnVuY3Rpb25zIGluc2lkZSBvZiBtYXRoIGV4cHJlc3Npb25zLCBzbyB3ZSBkbyBzb21lIHNwZWNpYWxcbiAgLy8gaGFuZGxpbmcuXG4gIGNvbnN0IG5ld09wdGlvbnMgPSBvcHRpb25zLmhhdmluZ1NpemUoZ3JvdXAuc2l6ZSk7XG4gIHJldHVybiBzaXppbmdHcm91cChncm91cC5ib2R5LCBuZXdPcHRpb25zLCBvcHRpb25zKTtcbn07XG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwic2l6aW5nXCIsXG4gIG5hbWVzOiBzaXplRnVuY3MsXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMCxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6IChfcmVmLCBhcmdzKSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIGJyZWFrT25Ub2tlblRleHQsXG4gICAgICBmdW5jTmFtZSxcbiAgICAgIHBhcnNlclxuICAgIH0gPSBfcmVmO1xuICAgIGNvbnN0IGJvZHkgPSBwYXJzZXIucGFyc2VFeHByZXNzaW9uKGZhbHNlLCBicmVha09uVG9rZW5UZXh0KTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJzaXppbmdcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgLy8gRmlndXJlIG91dCB3aGF0IHNpemUgdG8gdXNlIGJhc2VkIG9uIHRoZSBsaXN0IG9mIGZ1bmN0aW9ucyBhYm92ZVxuICAgICAgc2l6ZTogc2l6ZUZ1bmNzLmluZGV4T2YoZnVuY05hbWUpICsgMSxcbiAgICAgIGJvZHlcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogc2l6aW5nX2h0bWxCdWlsZGVyLFxuICBtYXRobWxCdWlsZGVyOiAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgICBjb25zdCBuZXdPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdTaXplKGdyb3VwLnNpemUpO1xuICAgIGNvbnN0IGlubmVyID0gYnVpbGRNYXRoTUxfYnVpbGRFeHByZXNzaW9uKGdyb3VwLmJvZHksIG5ld09wdGlvbnMpO1xuICAgIGNvbnN0IG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1zdHlsZVwiLCBpbm5lcik7IC8vIFRPRE8oZW1pbHkpOiBUaGlzIGRvZXNuJ3QgcHJvZHVjZSB0aGUgY29ycmVjdCBzaXplIGZvciBuZXN0ZWQgc2l6ZVxuICAgIC8vIGNoYW5nZXMsIGJlY2F1c2Ugd2UgZG9uJ3Qga2VlcCBzdGF0ZSBvZiB3aGF0IHN0eWxlIHdlJ3JlIGN1cnJlbnRseVxuICAgIC8vIGluLCBzbyB3ZSBjYW4ndCByZXNldCB0aGUgc2l6ZSB0byBub3JtYWwgYmVmb3JlIGNoYW5naW5nIGl0LiAgTm93XG4gICAgLy8gdGhhdCB3ZSdyZSBwYXNzaW5nIGFuIG9wdGlvbnMgcGFyYW1ldGVyIHdlIHNob3VsZCBiZSBhYmxlIHRvIGZpeFxuICAgIC8vIHRoaXMuXG5cbiAgICBub2RlLnNldEF0dHJpYnV0ZShcIm1hdGhzaXplXCIsIG1ha2VFbShuZXdPcHRpb25zLnNpemVNdWx0aXBsaWVyKSk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy9zbWFzaC5qc1xuLy8gc21hc2gsIHdpdGggb3B0aW9uYWwgW3RiXSwgYXMgaW4gQU1TXG5cblxuXG5cblxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwic21hc2hcIixcbiAgbmFtZXM6IFtcIlxcXFxzbWFzaFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIG51bU9wdGlvbmFsQXJnczogMSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6IChfcmVmLCBhcmdzLCBvcHRBcmdzKSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIHBhcnNlclxuICAgIH0gPSBfcmVmO1xuICAgIGxldCBzbWFzaEhlaWdodCA9IGZhbHNlO1xuICAgIGxldCBzbWFzaERlcHRoID0gZmFsc2U7XG4gICAgY29uc3QgdGJBcmcgPSBvcHRBcmdzWzBdICYmIGFzc2VydE5vZGVUeXBlKG9wdEFyZ3NbMF0sIFwib3JkZ3JvdXBcIik7XG5cbiAgICBpZiAodGJBcmcpIHtcbiAgICAgIC8vIE9wdGlvbmFsIFt0Yl0gYXJndW1lbnQgaXMgZW5nYWdlZC5cbiAgICAgIC8vIHJlZjogYW1zbWF0aDogXFxyZW5ld2NvbW1hbmR7XFxzbWFzaH1bMV1bdGJdeyVcbiAgICAgIC8vICAgICAgICAgICAgICAgZGVmXFxtYkB0e1xcaHR9XFxkZWZcXG1iQGJ7XFxkcH1cXGRlZlxcbWJAdGJ7XFxodFxcekBcXHpAXFxkcH0lXG4gICAgICBsZXQgbGV0dGVyID0gXCJcIjtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YkFyZy5ib2R5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0YkFyZy5ib2R5W2ldOyAvLyAkRmxvd0ZpeE1lOiBOb3QgZXZlcnkgbm9kZSB0eXBlIGhhcyBhIGB0ZXh0YCBwcm9wZXJ0eS5cblxuICAgICAgICBsZXR0ZXIgPSBub2RlLnRleHQ7XG5cbiAgICAgICAgaWYgKGxldHRlciA9PT0gXCJ0XCIpIHtcbiAgICAgICAgICBzbWFzaEhlaWdodCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAobGV0dGVyID09PSBcImJcIikge1xuICAgICAgICAgIHNtYXNoRGVwdGggPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNtYXNoSGVpZ2h0ID0gZmFsc2U7XG4gICAgICAgICAgc21hc2hEZXB0aCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNtYXNoSGVpZ2h0ID0gdHJ1ZTtcbiAgICAgIHNtYXNoRGVwdGggPSB0cnVlO1xuICAgIH1cblxuICAgIGNvbnN0IGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInNtYXNoXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGJvZHksXG4gICAgICBzbWFzaEhlaWdodCxcbiAgICAgIHNtYXNoRGVwdGhcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogKGdyb3VwLCBvcHRpb25zKSA9PiB7XG4gICAgY29uc3Qgbm9kZSA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtdLCBbYnVpbGRHcm91cChncm91cC5ib2R5LCBvcHRpb25zKV0pO1xuXG4gICAgaWYgKCFncm91cC5zbWFzaEhlaWdodCAmJiAhZ3JvdXAuc21hc2hEZXB0aCkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgaWYgKGdyb3VwLnNtYXNoSGVpZ2h0KSB7XG4gICAgICBub2RlLmhlaWdodCA9IDA7IC8vIEluIG9yZGVyIHRvIGluZmx1ZW5jZSBtYWtlVkxpc3QsIHdlIGhhdmUgdG8gcmVzZXQgdGhlIGNoaWxkcmVuLlxuXG4gICAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBub2RlLmNoaWxkcmVuW2ldLmhlaWdodCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZ3JvdXAuc21hc2hEZXB0aCkge1xuICAgICAgbm9kZS5kZXB0aCA9IDA7XG5cbiAgICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG5vZGUuY2hpbGRyZW5baV0uZGVwdGggPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBBdCB0aGlzIHBvaW50LCB3ZSd2ZSByZXNldCB0aGUgVGVYLWxpa2UgaGVpZ2h0IGFuZCBkZXB0aCB2YWx1ZXMuXG4gICAgLy8gQnV0IHRoZSBzcGFuIHN0aWxsIGhhcyBhbiBIVE1MIGxpbmUgaGVpZ2h0LlxuICAgIC8vIG1ha2VWTGlzdCBhcHBsaWVzIFwiZGlzcGxheTogdGFibGUtY2VsbFwiLCB3aGljaCBwcmV2ZW50cyB0aGUgYnJvd3NlclxuICAgIC8vIGZyb20gYWN0aW5nIG9uIHRoYXQgbGluZSBoZWlnaHQuIFNvIHdlJ2xsIGNhbGwgbWFrZVZMaXN0IG5vdy5cblxuXG4gICAgY29uc3Qgc21hc2hlZE5vZGUgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgcG9zaXRpb25UeXBlOiBcImZpcnN0QmFzZWxpbmVcIixcbiAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogbm9kZVxuICAgICAgfV1cbiAgICB9LCBvcHRpb25zKTsgLy8gRm9yIHNwYWNpbmcsIFRlWCB0cmVhdHMgXFxocGhhbnRvbSBhcyBhIG1hdGggZ3JvdXAgKHNhbWUgc3BhY2luZyBhcyBvcmQpLlxuXG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1vcmRcIl0sIFtzbWFzaGVkTm9kZV0sIG9wdGlvbnMpO1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgICBjb25zdCBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcGFkZGVkXCIsIFtidWlsZE1hdGhNTF9idWlsZEdyb3VwKGdyb3VwLmJvZHksIG9wdGlvbnMpXSk7XG5cbiAgICBpZiAoZ3JvdXAuc21hc2hIZWlnaHQpIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIFwiMHB4XCIpO1xuICAgIH1cblxuICAgIGlmIChncm91cC5zbWFzaERlcHRoKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcImRlcHRoXCIsIFwiMHB4XCIpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mdW5jdGlvbnMvc3FydC5qc1xuXG5cblxuXG5cblxuXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJzcXJ0XCIsXG4gIG5hbWVzOiBbXCJcXFxcc3FydFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIG51bU9wdGlvbmFsQXJnczogMVxuICB9LFxuXG4gIGhhbmRsZXIoX3JlZiwgYXJncywgb3B0QXJncykge1xuICAgIGxldCB7XG4gICAgICBwYXJzZXJcbiAgICB9ID0gX3JlZjtcbiAgICBjb25zdCBpbmRleCA9IG9wdEFyZ3NbMF07XG4gICAgY29uc3QgYm9keSA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwic3FydFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBib2R5LFxuICAgICAgaW5kZXhcbiAgICB9O1xuICB9LFxuXG4gIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gU3F1YXJlIHJvb3RzIGFyZSBoYW5kbGVkIGluIHRoZSBUZVhib29rIHBnLiA0NDMsIFJ1bGUgMTEuXG4gICAgLy8gRmlyc3QsIHdlIGRvIHRoZSBzYW1lIHN0ZXBzIGFzIGluIG92ZXJsaW5lIHRvIGJ1aWxkIHRoZSBpbm5lciBncm91cFxuICAgIC8vIGFuZCBsaW5lXG4gICAgbGV0IGlubmVyID0gYnVpbGRHcm91cChncm91cC5ib2R5LCBvcHRpb25zLmhhdmluZ0NyYW1wZWRTdHlsZSgpKTtcblxuICAgIGlmIChpbm5lci5oZWlnaHQgPT09IDApIHtcbiAgICAgIC8vIFJlbmRlciBhIHNtYWxsIHN1cmQuXG4gICAgICBpbm5lci5oZWlnaHQgPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkueEhlaWdodDtcbiAgICB9IC8vIFNvbWUgZ3JvdXBzIGNhbiByZXR1cm4gZG9jdW1lbnQgZnJhZ21lbnRzLiAgSGFuZGxlIHRob3NlIGJ5IHdyYXBwaW5nXG4gICAgLy8gdGhlbSBpbiBhIHNwYW4uXG5cblxuICAgIGlubmVyID0gYnVpbGRDb21tb24ud3JhcEZyYWdtZW50KGlubmVyLCBvcHRpb25zKTsgLy8gQ2FsY3VsYXRlIHRoZSBtaW5pbXVtIHNpemUgZm9yIHRoZSBcXHN1cmQgZGVsaW1pdGVyXG5cbiAgICBjb25zdCBtZXRyaWNzID0gb3B0aW9ucy5mb250TWV0cmljcygpO1xuICAgIGNvbnN0IHRoZXRhID0gbWV0cmljcy5kZWZhdWx0UnVsZVRoaWNrbmVzcztcbiAgICBsZXQgcGhpID0gdGhldGE7XG5cbiAgICBpZiAob3B0aW9ucy5zdHlsZS5pZCA8IHNyY19TdHlsZS5URVhULmlkKSB7XG4gICAgICBwaGkgPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkueEhlaWdodDtcbiAgICB9IC8vIENhbGN1bGF0ZSB0aGUgY2xlYXJhbmNlIGJldHdlZW4gdGhlIGJvZHkgYW5kIGxpbmVcblxuXG4gICAgbGV0IGxpbmVDbGVhcmFuY2UgPSB0aGV0YSArIHBoaSAvIDQ7XG4gICAgY29uc3QgbWluRGVsaW1pdGVySGVpZ2h0ID0gaW5uZXIuaGVpZ2h0ICsgaW5uZXIuZGVwdGggKyBsaW5lQ2xlYXJhbmNlICsgdGhldGE7IC8vIENyZWF0ZSBhIHNxcnQgU1ZHIG9mIHRoZSByZXF1aXJlZCBtaW5pbXVtIHNpemVcblxuICAgIGNvbnN0IHtcbiAgICAgIHNwYW46IGltZyxcbiAgICAgIHJ1bGVXaWR0aCxcbiAgICAgIGFkdmFuY2VXaWR0aFxuICAgIH0gPSBkZWxpbWl0ZXIuc3FydEltYWdlKG1pbkRlbGltaXRlckhlaWdodCwgb3B0aW9ucyk7XG4gICAgY29uc3QgZGVsaW1EZXB0aCA9IGltZy5oZWlnaHQgLSBydWxlV2lkdGg7IC8vIEFkanVzdCB0aGUgY2xlYXJhbmNlIGJhc2VkIG9uIHRoZSBkZWxpbWl0ZXIgc2l6ZVxuXG4gICAgaWYgKGRlbGltRGVwdGggPiBpbm5lci5oZWlnaHQgKyBpbm5lci5kZXB0aCArIGxpbmVDbGVhcmFuY2UpIHtcbiAgICAgIGxpbmVDbGVhcmFuY2UgPSAobGluZUNsZWFyYW5jZSArIGRlbGltRGVwdGggLSBpbm5lci5oZWlnaHQgLSBpbm5lci5kZXB0aCkgLyAyO1xuICAgIH0gLy8gU2hpZnQgdGhlIHNxcnQgaW1hZ2VcblxuXG4gICAgY29uc3QgaW1nU2hpZnQgPSBpbWcuaGVpZ2h0IC0gaW5uZXIuaGVpZ2h0IC0gbGluZUNsZWFyYW5jZSAtIHJ1bGVXaWR0aDtcbiAgICBpbm5lci5zdHlsZS5wYWRkaW5nTGVmdCA9IG1ha2VFbShhZHZhbmNlV2lkdGgpOyAvLyBPdmVybGF5IHRoZSBpbWFnZSBhbmQgdGhlIGFyZ3VtZW50LlxuXG4gICAgY29uc3QgYm9keSA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICBwb3NpdGlvblR5cGU6IFwiZmlyc3RCYXNlbGluZVwiLFxuICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBpbm5lcixcbiAgICAgICAgd3JhcHBlckNsYXNzZXM6IFtcInN2Zy1hbGlnblwiXVxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImtlcm5cIixcbiAgICAgICAgc2l6ZTogLShpbm5lci5oZWlnaHQgKyBpbWdTaGlmdClcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IGltZ1xuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImtlcm5cIixcbiAgICAgICAgc2l6ZTogcnVsZVdpZHRoXG4gICAgICB9XVxuICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgaWYgKCFncm91cC5pbmRleCkge1xuICAgICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1vcmRcIiwgXCJzcXJ0XCJdLCBbYm9keV0sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBIYW5kbGUgdGhlIG9wdGlvbmFsIHJvb3QgaW5kZXhcbiAgICAgIC8vIFRoZSBpbmRleCBpcyBhbHdheXMgaW4gc2NyaXB0c2NyaXB0IHN0eWxlXG4gICAgICBjb25zdCBuZXdPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdTdHlsZShzcmNfU3R5bGUuU0NSSVBUU0NSSVBUKTtcbiAgICAgIGNvbnN0IHJvb3RtID0gYnVpbGRHcm91cChncm91cC5pbmRleCwgbmV3T3B0aW9ucywgb3B0aW9ucyk7IC8vIFRoZSBhbW91bnQgdGhlIGluZGV4IGlzIHNoaWZ0ZWQgYnkuIFRoaXMgaXMgdGFrZW4gZnJvbSB0aGUgVGVYXG4gICAgICAvLyBzb3VyY2UsIGluIHRoZSBkZWZpbml0aW9uIG9mIGBcXHJAQHRgLlxuXG4gICAgICBjb25zdCB0b1NoaWZ0ID0gMC42ICogKGJvZHkuaGVpZ2h0IC0gYm9keS5kZXB0aCk7IC8vIEJ1aWxkIGEgVkxpc3Qgd2l0aCB0aGUgc3VwZXJzY3JpcHQgc2hpZnRlZCB1cCBjb3JyZWN0bHlcblxuICAgICAgY29uc3Qgcm9vdFZMaXN0ID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHtcbiAgICAgICAgcG9zaXRpb25UeXBlOiBcInNoaWZ0XCIsXG4gICAgICAgIHBvc2l0aW9uRGF0YTogLXRvU2hpZnQsXG4gICAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICAgIGVsZW06IHJvb3RtXG4gICAgICAgIH1dXG4gICAgICB9LCBvcHRpb25zKTsgLy8gQWRkIGEgY2xhc3Mgc3Vycm91bmRpbmcgaXQgc28gd2UgY2FuIGFkZCBvbiB0aGUgYXBwcm9wcmlhdGVcbiAgICAgIC8vIGtlcm5pbmdcblxuICAgICAgY29uc3Qgcm9vdFZMaXN0V3JhcCA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcInJvb3RcIl0sIFtyb290Vkxpc3RdKTtcbiAgICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtb3JkXCIsIFwic3FydFwiXSwgW3Jvb3RWTGlzdFdyYXAsIGJvZHldLCBvcHRpb25zKTtcbiAgICB9XG4gIH0sXG5cbiAgbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHtcbiAgICAgIGJvZHksXG4gICAgICBpbmRleFxuICAgIH0gPSBncm91cDtcbiAgICByZXR1cm4gaW5kZXggPyBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb290XCIsIFtidWlsZE1hdGhNTF9idWlsZEdyb3VwKGJvZHksIG9wdGlvbnMpLCBidWlsZE1hdGhNTF9idWlsZEdyb3VwKGluZGV4LCBvcHRpb25zKV0pIDogbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtc3FydFwiLCBbYnVpbGRNYXRoTUxfYnVpbGRHcm91cChib2R5LCBvcHRpb25zKV0pO1xuICB9XG5cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy9zdHlsaW5nLmpzXG5cblxuXG5cblxuY29uc3Qgc3R5bGluZ19zdHlsZU1hcCA9IHtcbiAgXCJkaXNwbGF5XCI6IHNyY19TdHlsZS5ESVNQTEFZLFxuICBcInRleHRcIjogc3JjX1N0eWxlLlRFWFQsXG4gIFwic2NyaXB0XCI6IHNyY19TdHlsZS5TQ1JJUFQsXG4gIFwic2NyaXB0c2NyaXB0XCI6IHNyY19TdHlsZS5TQ1JJUFRTQ1JJUFRcbn07XG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwic3R5bGluZ1wiLFxuICBuYW1lczogW1wiXFxcXGRpc3BsYXlzdHlsZVwiLCBcIlxcXFx0ZXh0c3R5bGVcIiwgXCJcXFxcc2NyaXB0c3R5bGVcIiwgXCJcXFxcc2NyaXB0c2NyaXB0c3R5bGVcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMCxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlLFxuICAgIHByaW1pdGl2ZTogdHJ1ZVxuICB9LFxuXG4gIGhhbmRsZXIoX3JlZiwgYXJncykge1xuICAgIGxldCB7XG4gICAgICBicmVha09uVG9rZW5UZXh0LFxuICAgICAgZnVuY05hbWUsXG4gICAgICBwYXJzZXJcbiAgICB9ID0gX3JlZjtcbiAgICAvLyBwYXJzZSBvdXQgdGhlIGltcGxpY2l0IGJvZHlcbiAgICBjb25zdCBib2R5ID0gcGFyc2VyLnBhcnNlRXhwcmVzc2lvbih0cnVlLCBicmVha09uVG9rZW5UZXh0KTsgLy8gVE9ETzogUmVmYWN0b3IgdG8gYXZvaWQgZHVwbGljYXRpbmcgc3R5bGVNYXAgaW4gbXVsdGlwbGUgcGxhY2VzIChlLmcuXG4gICAgLy8gaGVyZSBhbmQgaW4gYnVpbGRIVE1MIGFuZCBkZS1kdXBlIHRoZSBlbnVtZXJhdGlvbiBvZiBhbGwgdGhlIHN0eWxlcykuXG4gICAgLy8gJEZsb3dGaXhNZTogVGhlIG5hbWVzIGFib3ZlIGV4YWN0bHkgbWF0Y2ggdGhlIHN0eWxlcy5cblxuICAgIGNvbnN0IHN0eWxlID0gZnVuY05hbWUuc2xpY2UoMSwgZnVuY05hbWUubGVuZ3RoIC0gNSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwic3R5bGluZ1wiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICAvLyBGaWd1cmUgb3V0IHdoYXQgc3R5bGUgdG8gdXNlIGJ5IHB1bGxpbmcgb3V0IHRoZSBzdHlsZSBmcm9tXG4gICAgICAvLyB0aGUgZnVuY3Rpb24gbmFtZVxuICAgICAgc3R5bGUsXG4gICAgICBib2R5XG4gICAgfTtcbiAgfSxcblxuICBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIC8vIFN0eWxlIGNoYW5nZXMgYXJlIGhhbmRsZWQgaW4gdGhlIFRlWGJvb2sgb24gcGcuIDQ0MiwgUnVsZSAzLlxuICAgIGNvbnN0IG5ld1N0eWxlID0gc3R5bGluZ19zdHlsZU1hcFtncm91cC5zdHlsZV07XG4gICAgY29uc3QgbmV3T3B0aW9ucyA9IG9wdGlvbnMuaGF2aW5nU3R5bGUobmV3U3R5bGUpLndpdGhGb250KCcnKTtcbiAgICByZXR1cm4gc2l6aW5nR3JvdXAoZ3JvdXAuYm9keSwgbmV3T3B0aW9ucywgb3B0aW9ucyk7XG4gIH0sXG5cbiAgbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIC8vIEZpZ3VyZSBvdXQgd2hhdCBzdHlsZSB3ZSdyZSBjaGFuZ2luZyB0by5cbiAgICBjb25zdCBuZXdTdHlsZSA9IHN0eWxpbmdfc3R5bGVNYXBbZ3JvdXAuc3R5bGVdO1xuICAgIGNvbnN0IG5ld09wdGlvbnMgPSBvcHRpb25zLmhhdmluZ1N0eWxlKG5ld1N0eWxlKTtcbiAgICBjb25zdCBpbm5lciA9IGJ1aWxkTWF0aE1MX2J1aWxkRXhwcmVzc2lvbihncm91cC5ib2R5LCBuZXdPcHRpb25zKTtcbiAgICBjb25zdCBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtc3R5bGVcIiwgaW5uZXIpO1xuICAgIGNvbnN0IHN0eWxlQXR0cmlidXRlcyA9IHtcbiAgICAgIFwiZGlzcGxheVwiOiBbXCIwXCIsIFwidHJ1ZVwiXSxcbiAgICAgIFwidGV4dFwiOiBbXCIwXCIsIFwiZmFsc2VcIl0sXG4gICAgICBcInNjcmlwdFwiOiBbXCIxXCIsIFwiZmFsc2VcIl0sXG4gICAgICBcInNjcmlwdHNjcmlwdFwiOiBbXCIyXCIsIFwiZmFsc2VcIl1cbiAgICB9O1xuICAgIGNvbnN0IGF0dHIgPSBzdHlsZUF0dHJpYnV0ZXNbZ3JvdXAuc3R5bGVdO1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwic2NyaXB0bGV2ZWxcIiwgYXR0clswXSk7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJkaXNwbGF5c3R5bGVcIiwgYXR0clsxXSk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZnVuY3Rpb25zL3N1cHN1Yi5qc1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbi8qKlxuICogU29tZXRpbWVzLCBncm91cHMgcGVyZm9ybSBzcGVjaWFsIHJ1bGVzIHdoZW4gdGhleSBoYXZlIHN1cGVyc2NyaXB0cyBvclxuICogc3Vic2NyaXB0cyBhdHRhY2hlZCB0byB0aGVtLiBUaGlzIGZ1bmN0aW9uIGxldHMgdGhlIGBzdXBzdWJgIGdyb3VwIGtub3cgdGhhdFxuICogU29tZXRpbWVzLCBncm91cHMgcGVyZm9ybSBzcGVjaWFsIHJ1bGVzIHdoZW4gdGhleSBoYXZlIHN1cGVyc2NyaXB0cyBvclxuICogaXRzIGlubmVyIGVsZW1lbnQgc2hvdWxkIGhhbmRsZSB0aGUgc3VwZXJzY3JpcHRzIGFuZCBzdWJzY3JpcHRzIGluc3RlYWQgb2ZcbiAqIGhhbmRsaW5nIHRoZW0gaXRzZWxmLlxuICovXG5jb25zdCBodG1sQnVpbGRlckRlbGVnYXRlID0gZnVuY3Rpb24gKGdyb3VwLCBvcHRpb25zKSB7XG4gIGNvbnN0IGJhc2UgPSBncm91cC5iYXNlO1xuXG4gIGlmICghYmFzZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2UgaWYgKGJhc2UudHlwZSA9PT0gXCJvcFwiKSB7XG4gICAgLy8gT3BlcmF0b3JzIGhhbmRsZSBzdXBzdWJzIGRpZmZlcmVudGx5IHdoZW4gdGhleSBoYXZlIGxpbWl0c1xuICAgIC8vIChlLmcuIGBcXGRpc3BsYXlzdHlsZVxcc3VtXzJeM2ApXG4gICAgY29uc3QgZGVsZWdhdGUgPSBiYXNlLmxpbWl0cyAmJiAob3B0aW9ucy5zdHlsZS5zaXplID09PSBzcmNfU3R5bGUuRElTUExBWS5zaXplIHx8IGJhc2UuYWx3YXlzSGFuZGxlU3VwU3ViKTtcbiAgICByZXR1cm4gZGVsZWdhdGUgPyBvcF9odG1sQnVpbGRlciA6IG51bGw7XG4gIH0gZWxzZSBpZiAoYmFzZS50eXBlID09PSBcIm9wZXJhdG9ybmFtZVwiKSB7XG4gICAgY29uc3QgZGVsZWdhdGUgPSBiYXNlLmFsd2F5c0hhbmRsZVN1cFN1YiAmJiAob3B0aW9ucy5zdHlsZS5zaXplID09PSBzcmNfU3R5bGUuRElTUExBWS5zaXplIHx8IGJhc2UubGltaXRzKTtcbiAgICByZXR1cm4gZGVsZWdhdGUgPyBvcGVyYXRvcm5hbWVfaHRtbEJ1aWxkZXIgOiBudWxsO1xuICB9IGVsc2UgaWYgKGJhc2UudHlwZSA9PT0gXCJhY2NlbnRcIikge1xuICAgIHJldHVybiB1dGlscy5pc0NoYXJhY3RlckJveChiYXNlLmJhc2UpID8gaHRtbEJ1aWxkZXIgOiBudWxsO1xuICB9IGVsc2UgaWYgKGJhc2UudHlwZSA9PT0gXCJob3JpekJyYWNlXCIpIHtcbiAgICBjb25zdCBpc1N1cCA9ICFncm91cC5zdWI7XG4gICAgcmV0dXJuIGlzU3VwID09PSBiYXNlLmlzT3ZlciA/IGhvcml6QnJhY2VfaHRtbEJ1aWxkZXIgOiBudWxsO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59OyAvLyBTdXBlciBzY3JpcHRzIGFuZCBzdWJzY3JpcHRzLCB3aG9zZSBwcmVjaXNlIHBsYWNlbWVudCBjYW4gZGVwZW5kIG9uIG90aGVyXG4vLyBmdW5jdGlvbnMgdGhhdCBwcmVjZWRlIHRoZW0uXG5cblxuZGVmaW5lRnVuY3Rpb25CdWlsZGVycyh7XG4gIHR5cGU6IFwic3Vwc3ViXCIsXG5cbiAgaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICAvLyBTdXBlcnNjcmlwdCBhbmQgc3Vic2NyaXB0cyBhcmUgaGFuZGxlZCBpbiB0aGUgVGVYYm9vayBvbiBwYWdlXG4gICAgLy8gNDQ1LTQ0NiwgcnVsZXMgMTgoYS1mKS5cbiAgICAvLyBIZXJlIGlzIHdoZXJlIHdlIGRlZmVyIHRvIHRoZSBpbm5lciBncm91cCBpZiBpdCBzaG91bGQgaGFuZGxlXG4gICAgLy8gc3VwZXJzY3JpcHRzIGFuZCBzdWJzY3JpcHRzIGl0c2VsZi5cbiAgICBjb25zdCBidWlsZGVyRGVsZWdhdGUgPSBodG1sQnVpbGRlckRlbGVnYXRlKGdyb3VwLCBvcHRpb25zKTtcblxuICAgIGlmIChidWlsZGVyRGVsZWdhdGUpIHtcbiAgICAgIHJldHVybiBidWlsZGVyRGVsZWdhdGUoZ3JvdXAsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIGJhc2U6IHZhbHVlQmFzZSxcbiAgICAgIHN1cDogdmFsdWVTdXAsXG4gICAgICBzdWI6IHZhbHVlU3ViXG4gICAgfSA9IGdyb3VwO1xuICAgIGNvbnN0IGJhc2UgPSBidWlsZEdyb3VwKHZhbHVlQmFzZSwgb3B0aW9ucyk7XG4gICAgbGV0IHN1cG07XG4gICAgbGV0IHN1Ym07XG4gICAgY29uc3QgbWV0cmljcyA9IG9wdGlvbnMuZm9udE1ldHJpY3MoKTsgLy8gUnVsZSAxOGFcblxuICAgIGxldCBzdXBTaGlmdCA9IDA7XG4gICAgbGV0IHN1YlNoaWZ0ID0gMDtcbiAgICBjb25zdCBpc0NoYXJhY3RlckJveCA9IHZhbHVlQmFzZSAmJiB1dGlscy5pc0NoYXJhY3RlckJveCh2YWx1ZUJhc2UpO1xuXG4gICAgaWYgKHZhbHVlU3VwKSB7XG4gICAgICBjb25zdCBuZXdPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdTdHlsZShvcHRpb25zLnN0eWxlLnN1cCgpKTtcbiAgICAgIHN1cG0gPSBidWlsZEdyb3VwKHZhbHVlU3VwLCBuZXdPcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgaWYgKCFpc0NoYXJhY3RlckJveCkge1xuICAgICAgICBzdXBTaGlmdCA9IGJhc2UuaGVpZ2h0IC0gbmV3T3B0aW9ucy5mb250TWV0cmljcygpLnN1cERyb3AgKiBuZXdPcHRpb25zLnNpemVNdWx0aXBsaWVyIC8gb3B0aW9ucy5zaXplTXVsdGlwbGllcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodmFsdWVTdWIpIHtcbiAgICAgIGNvbnN0IG5ld09wdGlvbnMgPSBvcHRpb25zLmhhdmluZ1N0eWxlKG9wdGlvbnMuc3R5bGUuc3ViKCkpO1xuICAgICAgc3VibSA9IGJ1aWxkR3JvdXAodmFsdWVTdWIsIG5ld09wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICBpZiAoIWlzQ2hhcmFjdGVyQm94KSB7XG4gICAgICAgIHN1YlNoaWZ0ID0gYmFzZS5kZXB0aCArIG5ld09wdGlvbnMuZm9udE1ldHJpY3MoKS5zdWJEcm9wICogbmV3T3B0aW9ucy5zaXplTXVsdGlwbGllciAvIG9wdGlvbnMuc2l6ZU11bHRpcGxpZXI7XG4gICAgICB9XG4gICAgfSAvLyBSdWxlIDE4Y1xuXG5cbiAgICBsZXQgbWluU3VwU2hpZnQ7XG5cbiAgICBpZiAob3B0aW9ucy5zdHlsZSA9PT0gc3JjX1N0eWxlLkRJU1BMQVkpIHtcbiAgICAgIG1pblN1cFNoaWZ0ID0gbWV0cmljcy5zdXAxO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5zdHlsZS5jcmFtcGVkKSB7XG4gICAgICBtaW5TdXBTaGlmdCA9IG1ldHJpY3Muc3VwMztcbiAgICB9IGVsc2Uge1xuICAgICAgbWluU3VwU2hpZnQgPSBtZXRyaWNzLnN1cDI7XG4gICAgfSAvLyBzY3JpcHRzcGFjZSBpcyBhIGZvbnQtc2l6ZS1pbmRlcGVuZGVudCBzaXplLCBzbyBzY2FsZSBpdFxuICAgIC8vIGFwcHJvcHJpYXRlbHkgZm9yIHVzZSBhcyB0aGUgbWFyZ2luUmlnaHQuXG5cblxuICAgIGNvbnN0IG11bHRpcGxpZXIgPSBvcHRpb25zLnNpemVNdWx0aXBsaWVyO1xuICAgIGNvbnN0IG1hcmdpblJpZ2h0ID0gbWFrZUVtKDAuNSAvIG1ldHJpY3MucHRQZXJFbSAvIG11bHRpcGxpZXIpO1xuICAgIGxldCBtYXJnaW5MZWZ0ID0gbnVsbDtcblxuICAgIGlmIChzdWJtKSB7XG4gICAgICAvLyBTdWJzY3JpcHRzIHNob3VsZG4ndCBiZSBzaGlmdGVkIGJ5IHRoZSBiYXNlJ3MgaXRhbGljIGNvcnJlY3Rpb24uXG4gICAgICAvLyBBY2NvdW50IGZvciB0aGF0IGJ5IHNoaWZ0aW5nIHRoZSBzdWJzY3JpcHQgYmFjayB0aGUgYXBwcm9wcmlhdGVcbiAgICAgIC8vIGFtb3VudC4gTm90ZSB3ZSBvbmx5IGRvIHRoaXMgd2hlbiB0aGUgYmFzZSBpcyBhIHNpbmdsZSBzeW1ib2wuXG4gICAgICBjb25zdCBpc09paW50ID0gZ3JvdXAuYmFzZSAmJiBncm91cC5iYXNlLnR5cGUgPT09IFwib3BcIiAmJiBncm91cC5iYXNlLm5hbWUgJiYgKGdyb3VwLmJhc2UubmFtZSA9PT0gXCJcXFxcb2lpbnRcIiB8fCBncm91cC5iYXNlLm5hbWUgPT09IFwiXFxcXG9paWludFwiKTtcblxuICAgICAgaWYgKGJhc2UgaW5zdGFuY2VvZiBTeW1ib2xOb2RlIHx8IGlzT2lpbnQpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgICBtYXJnaW5MZWZ0ID0gbWFrZUVtKC1iYXNlLml0YWxpYyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHN1cHN1YjtcblxuICAgIGlmIChzdXBtICYmIHN1Ym0pIHtcbiAgICAgIHN1cFNoaWZ0ID0gTWF0aC5tYXgoc3VwU2hpZnQsIG1pblN1cFNoaWZ0LCBzdXBtLmRlcHRoICsgMC4yNSAqIG1ldHJpY3MueEhlaWdodCk7XG4gICAgICBzdWJTaGlmdCA9IE1hdGgubWF4KHN1YlNoaWZ0LCBtZXRyaWNzLnN1YjIpO1xuICAgICAgY29uc3QgcnVsZVdpZHRoID0gbWV0cmljcy5kZWZhdWx0UnVsZVRoaWNrbmVzczsgLy8gUnVsZSAxOGVcblxuICAgICAgY29uc3QgbWF4V2lkdGggPSA0ICogcnVsZVdpZHRoO1xuXG4gICAgICBpZiAoc3VwU2hpZnQgLSBzdXBtLmRlcHRoIC0gKHN1Ym0uaGVpZ2h0IC0gc3ViU2hpZnQpIDwgbWF4V2lkdGgpIHtcbiAgICAgICAgc3ViU2hpZnQgPSBtYXhXaWR0aCAtIChzdXBTaGlmdCAtIHN1cG0uZGVwdGgpICsgc3VibS5oZWlnaHQ7XG4gICAgICAgIGNvbnN0IHBzaSA9IDAuOCAqIG1ldHJpY3MueEhlaWdodCAtIChzdXBTaGlmdCAtIHN1cG0uZGVwdGgpO1xuXG4gICAgICAgIGlmIChwc2kgPiAwKSB7XG4gICAgICAgICAgc3VwU2hpZnQgKz0gcHNpO1xuICAgICAgICAgIHN1YlNoaWZ0IC09IHBzaTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCB2bGlzdEVsZW0gPSBbe1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogc3VibSxcbiAgICAgICAgc2hpZnQ6IHN1YlNoaWZ0LFxuICAgICAgICBtYXJnaW5SaWdodCxcbiAgICAgICAgbWFyZ2luTGVmdFxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogc3VwbSxcbiAgICAgICAgc2hpZnQ6IC1zdXBTaGlmdCxcbiAgICAgICAgbWFyZ2luUmlnaHRcbiAgICAgIH1dO1xuICAgICAgc3Vwc3ViID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHtcbiAgICAgICAgcG9zaXRpb25UeXBlOiBcImluZGl2aWR1YWxTaGlmdFwiLFxuICAgICAgICBjaGlsZHJlbjogdmxpc3RFbGVtXG4gICAgICB9LCBvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKHN1Ym0pIHtcbiAgICAgIC8vIFJ1bGUgMThiXG4gICAgICBzdWJTaGlmdCA9IE1hdGgubWF4KHN1YlNoaWZ0LCBtZXRyaWNzLnN1YjEsIHN1Ym0uaGVpZ2h0IC0gMC44ICogbWV0cmljcy54SGVpZ2h0KTtcbiAgICAgIGNvbnN0IHZsaXN0RWxlbSA9IFt7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBzdWJtLFxuICAgICAgICBtYXJnaW5MZWZ0LFxuICAgICAgICBtYXJnaW5SaWdodFxuICAgICAgfV07XG4gICAgICBzdXBzdWIgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgICBwb3NpdGlvblR5cGU6IFwic2hpZnRcIixcbiAgICAgICAgcG9zaXRpb25EYXRhOiBzdWJTaGlmdCxcbiAgICAgICAgY2hpbGRyZW46IHZsaXN0RWxlbVxuICAgICAgfSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmIChzdXBtKSB7XG4gICAgICAvLyBSdWxlIDE4YywgZFxuICAgICAgc3VwU2hpZnQgPSBNYXRoLm1heChzdXBTaGlmdCwgbWluU3VwU2hpZnQsIHN1cG0uZGVwdGggKyAwLjI1ICogbWV0cmljcy54SGVpZ2h0KTtcbiAgICAgIHN1cHN1YiA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICAgIHBvc2l0aW9uVHlwZTogXCJzaGlmdFwiLFxuICAgICAgICBwb3NpdGlvbkRhdGE6IC1zdXBTaGlmdCxcbiAgICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgICAgZWxlbTogc3VwbSxcbiAgICAgICAgICBtYXJnaW5SaWdodFxuICAgICAgICB9XVxuICAgICAgfSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInN1cHN1YiBtdXN0IGhhdmUgZWl0aGVyIHN1cCBvciBzdWIuXCIpO1xuICAgIH0gLy8gV3JhcCB0aGUgc3Vwc3ViIHZsaXN0IGluIGEgc3Bhbi5tc3Vwc3ViIHRvIHJlc2V0IHRleHQtYWxpZ24uXG5cblxuICAgIGNvbnN0IG1jbGFzcyA9IGdldFR5cGVPZkRvbVRyZWUoYmFzZSwgXCJyaWdodFwiKSB8fCBcIm1vcmRcIjtcbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oW21jbGFzc10sIFtiYXNlLCBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtc3Vwc3ViXCJdLCBbc3Vwc3ViXSldLCBvcHRpb25zKTtcbiAgfSxcblxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gSXMgdGhlIGlubmVyIGdyb3VwIGEgcmVsZXZhbnQgaG9yaXpvbmFsIGJyYWNlP1xuICAgIGxldCBpc0JyYWNlID0gZmFsc2U7XG4gICAgbGV0IGlzT3ZlcjtcbiAgICBsZXQgaXNTdXA7XG5cbiAgICBpZiAoZ3JvdXAuYmFzZSAmJiBncm91cC5iYXNlLnR5cGUgPT09IFwiaG9yaXpCcmFjZVwiKSB7XG4gICAgICBpc1N1cCA9ICEhZ3JvdXAuc3VwO1xuXG4gICAgICBpZiAoaXNTdXAgPT09IGdyb3VwLmJhc2UuaXNPdmVyKSB7XG4gICAgICAgIGlzQnJhY2UgPSB0cnVlO1xuICAgICAgICBpc092ZXIgPSBncm91cC5iYXNlLmlzT3ZlcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZ3JvdXAuYmFzZSAmJiAoZ3JvdXAuYmFzZS50eXBlID09PSBcIm9wXCIgfHwgZ3JvdXAuYmFzZS50eXBlID09PSBcIm9wZXJhdG9ybmFtZVwiKSkge1xuICAgICAgZ3JvdXAuYmFzZS5wYXJlbnRJc1N1cFN1YiA9IHRydWU7XG4gICAgfVxuXG4gICAgY29uc3QgY2hpbGRyZW4gPSBbYnVpbGRNYXRoTUxfYnVpbGRHcm91cChncm91cC5iYXNlLCBvcHRpb25zKV07XG5cbiAgICBpZiAoZ3JvdXAuc3ViKSB7XG4gICAgICBjaGlsZHJlbi5wdXNoKGJ1aWxkTWF0aE1MX2J1aWxkR3JvdXAoZ3JvdXAuc3ViLCBvcHRpb25zKSk7XG4gICAgfVxuXG4gICAgaWYgKGdyb3VwLnN1cCkge1xuICAgICAgY2hpbGRyZW4ucHVzaChidWlsZE1hdGhNTF9idWlsZEdyb3VwKGdyb3VwLnN1cCwgb3B0aW9ucykpO1xuICAgIH1cblxuICAgIGxldCBub2RlVHlwZTtcblxuICAgIGlmIChpc0JyYWNlKSB7XG4gICAgICBub2RlVHlwZSA9IGlzT3ZlciA/IFwibW92ZXJcIiA6IFwibXVuZGVyXCI7XG4gICAgfSBlbHNlIGlmICghZ3JvdXAuc3ViKSB7XG4gICAgICBjb25zdCBiYXNlID0gZ3JvdXAuYmFzZTtcblxuICAgICAgaWYgKGJhc2UgJiYgYmFzZS50eXBlID09PSBcIm9wXCIgJiYgYmFzZS5saW1pdHMgJiYgKG9wdGlvbnMuc3R5bGUgPT09IHNyY19TdHlsZS5ESVNQTEFZIHx8IGJhc2UuYWx3YXlzSGFuZGxlU3VwU3ViKSkge1xuICAgICAgICBub2RlVHlwZSA9IFwibW92ZXJcIjtcbiAgICAgIH0gZWxzZSBpZiAoYmFzZSAmJiBiYXNlLnR5cGUgPT09IFwib3BlcmF0b3JuYW1lXCIgJiYgYmFzZS5hbHdheXNIYW5kbGVTdXBTdWIgJiYgKGJhc2UubGltaXRzIHx8IG9wdGlvbnMuc3R5bGUgPT09IHNyY19TdHlsZS5ESVNQTEFZKSkge1xuICAgICAgICBub2RlVHlwZSA9IFwibW92ZXJcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVUeXBlID0gXCJtc3VwXCI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghZ3JvdXAuc3VwKSB7XG4gICAgICBjb25zdCBiYXNlID0gZ3JvdXAuYmFzZTtcblxuICAgICAgaWYgKGJhc2UgJiYgYmFzZS50eXBlID09PSBcIm9wXCIgJiYgYmFzZS5saW1pdHMgJiYgKG9wdGlvbnMuc3R5bGUgPT09IHNyY19TdHlsZS5ESVNQTEFZIHx8IGJhc2UuYWx3YXlzSGFuZGxlU3VwU3ViKSkge1xuICAgICAgICBub2RlVHlwZSA9IFwibXVuZGVyXCI7XG4gICAgICB9IGVsc2UgaWYgKGJhc2UgJiYgYmFzZS50eXBlID09PSBcIm9wZXJhdG9ybmFtZVwiICYmIGJhc2UuYWx3YXlzSGFuZGxlU3VwU3ViICYmIChiYXNlLmxpbWl0cyB8fCBvcHRpb25zLnN0eWxlID09PSBzcmNfU3R5bGUuRElTUExBWSkpIHtcbiAgICAgICAgbm9kZVR5cGUgPSBcIm11bmRlclwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZVR5cGUgPSBcIm1zdWJcIjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYmFzZSA9IGdyb3VwLmJhc2U7XG5cbiAgICAgIGlmIChiYXNlICYmIGJhc2UudHlwZSA9PT0gXCJvcFwiICYmIGJhc2UubGltaXRzICYmIG9wdGlvbnMuc3R5bGUgPT09IHNyY19TdHlsZS5ESVNQTEFZKSB7XG4gICAgICAgIG5vZGVUeXBlID0gXCJtdW5kZXJvdmVyXCI7XG4gICAgICB9IGVsc2UgaWYgKGJhc2UgJiYgYmFzZS50eXBlID09PSBcIm9wZXJhdG9ybmFtZVwiICYmIGJhc2UuYWx3YXlzSGFuZGxlU3VwU3ViICYmIChvcHRpb25zLnN0eWxlID09PSBzcmNfU3R5bGUuRElTUExBWSB8fCBiYXNlLmxpbWl0cykpIHtcbiAgICAgICAgbm9kZVR5cGUgPSBcIm11bmRlcm92ZXJcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVUeXBlID0gXCJtc3Vic3VwXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKG5vZGVUeXBlLCBjaGlsZHJlbik7XG4gIH1cblxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZnVuY3Rpb25zL3N5bWJvbHNPcC5qc1xuXG5cblxuIC8vIE9wZXJhdG9yIFBhcnNlTm9kZXMgY3JlYXRlZCBpbiBQYXJzZXIuanMgZnJvbSBzeW1ib2wgR3JvdXBzIGluIHNyYy9zeW1ib2xzLmpzLlxuXG5kZWZpbmVGdW5jdGlvbkJ1aWxkZXJzKHtcbiAgdHlwZTogXCJhdG9tXCIsXG5cbiAgaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWF0aHN5bShncm91cC50ZXh0LCBncm91cC5tb2RlLCBvcHRpb25zLCBbXCJtXCIgKyBncm91cC5mYW1pbHldKTtcbiAgfSxcblxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIiwgW21ha2VUZXh0KGdyb3VwLnRleHQsIGdyb3VwLm1vZGUpXSk7XG5cbiAgICBpZiAoZ3JvdXAuZmFtaWx5ID09PSBcImJpblwiKSB7XG4gICAgICBjb25zdCB2YXJpYW50ID0gZ2V0VmFyaWFudChncm91cCwgb3B0aW9ucyk7XG5cbiAgICAgIGlmICh2YXJpYW50ID09PSBcImJvbGQtaXRhbGljXCIpIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJtYXRodmFyaWFudFwiLCB2YXJpYW50KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGdyb3VwLmZhbWlseSA9PT0gXCJwdW5jdFwiKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcInNlcGFyYXRvclwiLCBcInRydWVcIik7XG4gICAgfSBlbHNlIGlmIChncm91cC5mYW1pbHkgPT09IFwib3BlblwiIHx8IGdyb3VwLmZhbWlseSA9PT0gXCJjbG9zZVwiKSB7XG4gICAgICAvLyBEZWxpbXMgYnVpbHQgaGVyZSBzaG91bGQgbm90IHN0cmV0Y2ggdmVydGljYWxseS5cbiAgICAgIC8vIFNlZSBkZWxpbXNpemluZy5qcyBmb3Igc3RyZXRjaHkgZGVsaW1zLlxuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJzdHJldGNoeVwiLCBcImZhbHNlXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy9zeW1ib2xzT3JkLmpzXG5cblxuXG5cbi8vIFwibWF0aG9yZFwiIGFuZCBcInRleHRvcmRcIiBQYXJzZU5vZGVzIGNyZWF0ZWQgaW4gUGFyc2VyLmpzIGZyb20gc3ltYm9sIEdyb3VwcyBpblxuLy8gc3JjL3N5bWJvbHMuanMuXG5jb25zdCBkZWZhdWx0VmFyaWFudCA9IHtcbiAgXCJtaVwiOiBcIml0YWxpY1wiLFxuICBcIm1uXCI6IFwibm9ybWFsXCIsXG4gIFwibXRleHRcIjogXCJub3JtYWxcIlxufTtcbmRlZmluZUZ1bmN0aW9uQnVpbGRlcnMoe1xuICB0eXBlOiBcIm1hdGhvcmRcIixcblxuICBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlT3JkKGdyb3VwLCBvcHRpb25zLCBcIm1hdGhvcmRcIik7XG4gIH0sXG5cbiAgbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIGNvbnN0IG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1pXCIsIFttYWtlVGV4dChncm91cC50ZXh0LCBncm91cC5tb2RlLCBvcHRpb25zKV0pO1xuICAgIGNvbnN0IHZhcmlhbnQgPSBnZXRWYXJpYW50KGdyb3VwLCBvcHRpb25zKSB8fCBcIml0YWxpY1wiO1xuXG4gICAgaWYgKHZhcmlhbnQgIT09IGRlZmF1bHRWYXJpYW50W25vZGUudHlwZV0pIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibWF0aHZhcmlhbnRcIiwgdmFyaWFudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxufSk7XG5kZWZpbmVGdW5jdGlvbkJ1aWxkZXJzKHtcbiAgdHlwZTogXCJ0ZXh0b3JkXCIsXG5cbiAgaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZU9yZChncm91cCwgb3B0aW9ucywgXCJ0ZXh0b3JkXCIpO1xuICB9LFxuXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0ZXh0ID0gbWFrZVRleHQoZ3JvdXAudGV4dCwgZ3JvdXAubW9kZSwgb3B0aW9ucyk7XG4gICAgY29uc3QgdmFyaWFudCA9IGdldFZhcmlhbnQoZ3JvdXAsIG9wdGlvbnMpIHx8IFwibm9ybWFsXCI7XG4gICAgbGV0IG5vZGU7XG5cbiAgICBpZiAoZ3JvdXAubW9kZSA9PT0gJ3RleHQnKSB7XG4gICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGV4dFwiLCBbdGV4dF0pO1xuICAgIH0gZWxzZSBpZiAoL1swLTldLy50ZXN0KGdyb3VwLnRleHQpKSB7XG4gICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtblwiLCBbdGV4dF0pO1xuICAgIH0gZWxzZSBpZiAoZ3JvdXAudGV4dCA9PT0gXCJcXFxccHJpbWVcIikge1xuICAgICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIiwgW3RleHRdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibWlcIiwgW3RleHRdKTtcbiAgICB9XG5cbiAgICBpZiAodmFyaWFudCAhPT0gZGVmYXVsdFZhcmlhbnRbbm9kZS50eXBlXSkge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJtYXRodmFyaWFudFwiLCB2YXJpYW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mdW5jdGlvbnMvc3ltYm9sc1NwYWNpbmcuanNcblxuXG5cbiAvLyBBIG1hcCBvZiBDU1MtYmFzZWQgc3BhY2luZyBmdW5jdGlvbnMgdG8gdGhlaXIgQ1NTIGNsYXNzLlxuXG5jb25zdCBjc3NTcGFjZSA9IHtcbiAgXCJcXFxcbm9icmVha1wiOiBcIm5vYnJlYWtcIixcbiAgXCJcXFxcYWxsb3dicmVha1wiOiBcImFsbG93YnJlYWtcIlxufTsgLy8gQSBsb29rdXAgdGFibGUgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSBzcGFjaW5nIGZ1bmN0aW9uL3N5bWJvbCBzaG91bGQgYmVcbi8vIHRyZWF0ZWQgbGlrZSBhIHJlZ3VsYXIgc3BhY2UgY2hhcmFjdGVyLiAgSWYgYSBzeW1ib2wgb3IgY29tbWFuZCBpcyBhIGtleVxuLy8gaW4gdGhpcyB0YWJsZSwgdGhlbiBpdCBzaG91bGQgYmUgYSByZWd1bGFyIHNwYWNlIGNoYXJhY3Rlci4gIEZ1cnRoZXJtb3JlLFxuLy8gdGhlIGFzc29jaWF0ZWQgdmFsdWUgbWF5IGhhdmUgYSBgY2xhc3NOYW1lYCBzcGVjaWZ5aW5nIGFuIGV4dHJhIENTUyBjbGFzc1xuLy8gdG8gYWRkIHRvIHRoZSBjcmVhdGVkIGBzcGFuYC5cblxuY29uc3QgcmVndWxhclNwYWNlID0ge1xuICBcIiBcIjoge30sXG4gIFwiXFxcXCBcIjoge30sXG4gIFwiflwiOiB7XG4gICAgY2xhc3NOYW1lOiBcIm5vYnJlYWtcIlxuICB9LFxuICBcIlxcXFxzcGFjZVwiOiB7fSxcbiAgXCJcXFxcbm9icmVha3NwYWNlXCI6IHtcbiAgICBjbGFzc05hbWU6IFwibm9icmVha1wiXG4gIH1cbn07IC8vIFBhcnNlTm9kZTxcInNwYWNpbmdcIj4gY3JlYXRlZCBpbiBQYXJzZXIuanMgZnJvbSB0aGUgXCJzcGFjaW5nXCIgc3ltYm9sIEdyb3VwcyBpblxuLy8gc3JjL3N5bWJvbHMuanMuXG5cbmRlZmluZUZ1bmN0aW9uQnVpbGRlcnMoe1xuICB0eXBlOiBcInNwYWNpbmdcIixcblxuICBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIGlmIChyZWd1bGFyU3BhY2UuaGFzT3duUHJvcGVydHkoZ3JvdXAudGV4dCkpIHtcbiAgICAgIGNvbnN0IGNsYXNzTmFtZSA9IHJlZ3VsYXJTcGFjZVtncm91cC50ZXh0XS5jbGFzc05hbWUgfHwgXCJcIjsgLy8gU3BhY2VzIGFyZSBnZW5lcmF0ZWQgYnkgYWRkaW5nIGFuIGFjdHVhbCBzcGFjZS4gRWFjaCBvZiB0aGVzZVxuICAgICAgLy8gdGhpbmdzIGhhcyBhbiBlbnRyeSBpbiB0aGUgc3ltYm9scyB0YWJsZSwgc28gdGhlc2Ugd2lsbCBiZSB0dXJuZWRcbiAgICAgIC8vIGludG8gYXBwcm9wcmlhdGUgb3V0cHV0cy5cblxuICAgICAgaWYgKGdyb3VwLm1vZGUgPT09IFwidGV4dFwiKSB7XG4gICAgICAgIGNvbnN0IG9yZCA9IGJ1aWxkQ29tbW9uLm1ha2VPcmQoZ3JvdXAsIG9wdGlvbnMsIFwidGV4dG9yZFwiKTtcbiAgICAgICAgb3JkLmNsYXNzZXMucHVzaChjbGFzc05hbWUpO1xuICAgICAgICByZXR1cm4gb3JkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1zcGFjZVwiLCBjbGFzc05hbWVdLCBbYnVpbGRDb21tb24ubWF0aHN5bShncm91cC50ZXh0LCBncm91cC5tb2RlLCBvcHRpb25zKV0sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY3NzU3BhY2UuaGFzT3duUHJvcGVydHkoZ3JvdXAudGV4dCkpIHtcbiAgICAgIC8vIFNwYWNlcyBiYXNlZCBvbiBqdXN0IGEgQ1NTIGNsYXNzLlxuICAgICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1zcGFjZVwiLCBjc3NTcGFjZVtncm91cC50ZXh0XV0sIFtdLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiVW5rbm93biB0eXBlIG9mIHNwYWNlIFxcXCJcIiArIGdyb3VwLnRleHQgKyBcIlxcXCJcIik7XG4gICAgfVxuICB9LFxuXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICBsZXQgbm9kZTtcblxuICAgIGlmIChyZWd1bGFyU3BhY2UuaGFzT3duUHJvcGVydHkoZ3JvdXAudGV4dCkpIHtcbiAgICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10ZXh0XCIsIFtuZXcgbWF0aE1MVHJlZS5UZXh0Tm9kZShcIlxcdTAwYTBcIildKTtcbiAgICB9IGVsc2UgaWYgKGNzc1NwYWNlLmhhc093blByb3BlcnR5KGdyb3VwLnRleHQpKSB7XG4gICAgICAvLyBDU1MtYmFzZWQgTWF0aE1MIHNwYWNlcyAoXFxub2JyZWFrLCBcXGFsbG93YnJlYWspIGFyZSBpZ25vcmVkXG4gICAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtc3BhY2VcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIlVua25vd24gdHlwZSBvZiBzcGFjZSBcXFwiXCIgKyBncm91cC50ZXh0ICsgXCJcXFwiXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy90YWcuanNcblxuXG5cblxuY29uc3QgcGFkID0gKCkgPT4ge1xuICBjb25zdCBwYWROb2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGRcIiwgW10pO1xuICBwYWROb2RlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiNTAlXCIpO1xuICByZXR1cm4gcGFkTm9kZTtcbn07XG5cbmRlZmluZUZ1bmN0aW9uQnVpbGRlcnMoe1xuICB0eXBlOiBcInRhZ1wiLFxuXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0YWJsZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRhYmxlXCIsIFtuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10clwiLCBbcGFkKCksIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRkXCIsIFtidWlsZEV4cHJlc3Npb25Sb3coZ3JvdXAuYm9keSwgb3B0aW9ucyldKSwgcGFkKCksIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRkXCIsIFtidWlsZEV4cHJlc3Npb25Sb3coZ3JvdXAudGFnLCBvcHRpb25zKV0pXSldKTtcbiAgICB0YWJsZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIjEwMCVcIik7XG4gICAgcmV0dXJuIHRhYmxlOyAvLyBUT0RPOiBMZWZ0LWFsaWduZWQgdGFncy5cbiAgICAvLyBDdXJyZW50bHksIHRoZSBncm91cCBhbmQgb3B0aW9ucyBwYXNzZWQgaGVyZSBkbyBub3QgY29udGFpblxuICAgIC8vIGVub3VnaCBpbmZvIHRvIHNldCB0YWcgYWxpZ25tZW50LiBgbGVxbm9gIGlzIGluIFNldHRpbmdzIGJ1dCBpdCBpc1xuICAgIC8vIG5vdCBwYXNzZWQgdG8gT3B0aW9ucy4gT24gdGhlIEhUTUwgc2lkZSwgbGVxbm8gaXNcbiAgICAvLyBzZXQgYnkgYSBDU1MgY2xhc3MgYXBwbGllZCBpbiBidWlsZFRyZWUuanMuIFRoYXQgd291bGQgaGF2ZSB3b3JrZWRcbiAgICAvLyBpbiBNYXRoTUwgaWYgYnJvd3NlcnMgc3VwcG9ydGVkIDxtbGFiZWxlZHRyPi4gU2luY2UgdGhleSBkb24ndCwgd2VcbiAgICAvLyBuZWVkIHRvIHJld3JpdGUgdGhlIHdheSB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZC5cbiAgfVxuXG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mdW5jdGlvbnMvdGV4dC5qc1xuXG5cblxuIC8vIE5vbi1tYXRoeSB0ZXh0LCBwb3NzaWJseSBpbiBhIGZvbnRcblxuY29uc3QgdGV4dEZvbnRGYW1pbGllcyA9IHtcbiAgXCJcXFxcdGV4dFwiOiB1bmRlZmluZWQsXG4gIFwiXFxcXHRleHRybVwiOiBcInRleHRybVwiLFxuICBcIlxcXFx0ZXh0c2ZcIjogXCJ0ZXh0c2ZcIixcbiAgXCJcXFxcdGV4dHR0XCI6IFwidGV4dHR0XCIsXG4gIFwiXFxcXHRleHRub3JtYWxcIjogXCJ0ZXh0cm1cIlxufTtcbmNvbnN0IHRleHRGb250V2VpZ2h0cyA9IHtcbiAgXCJcXFxcdGV4dGJmXCI6IFwidGV4dGJmXCIsXG4gIFwiXFxcXHRleHRtZFwiOiBcInRleHRtZFwiXG59O1xuY29uc3QgdGV4dEZvbnRTaGFwZXMgPSB7XG4gIFwiXFxcXHRleHRpdFwiOiBcInRleHRpdFwiLFxuICBcIlxcXFx0ZXh0dXBcIjogXCJ0ZXh0dXBcIlxufTtcblxuY29uc3Qgb3B0aW9uc1dpdGhGb250ID0gKGdyb3VwLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IGZvbnQgPSBncm91cC5mb250OyAvLyBDaGVja3MgaWYgdGhlIGFyZ3VtZW50IGlzIGEgZm9udCBmYW1pbHkgb3IgYSBmb250IHN0eWxlLlxuXG4gIGlmICghZm9udCkge1xuICAgIHJldHVybiBvcHRpb25zO1xuICB9IGVsc2UgaWYgKHRleHRGb250RmFtaWxpZXNbZm9udF0pIHtcbiAgICByZXR1cm4gb3B0aW9ucy53aXRoVGV4dEZvbnRGYW1pbHkodGV4dEZvbnRGYW1pbGllc1tmb250XSk7XG4gIH0gZWxzZSBpZiAodGV4dEZvbnRXZWlnaHRzW2ZvbnRdKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMud2l0aFRleHRGb250V2VpZ2h0KHRleHRGb250V2VpZ2h0c1tmb250XSk7XG4gIH0gZWxzZSBpZiAoZm9udCA9PT0gXCJcXFxcZW1waFwiKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMuZm9udFNoYXBlID09PSBcInRleHRpdFwiID8gb3B0aW9ucy53aXRoVGV4dEZvbnRTaGFwZShcInRleHR1cFwiKSA6IG9wdGlvbnMud2l0aFRleHRGb250U2hhcGUoXCJ0ZXh0aXRcIik7XG4gIH1cblxuICByZXR1cm4gb3B0aW9ucy53aXRoVGV4dEZvbnRTaGFwZSh0ZXh0Rm9udFNoYXBlc1tmb250XSk7XG59O1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwidGV4dFwiLFxuICBuYW1lczogWy8vIEZvbnQgZmFtaWxpZXNcbiAgXCJcXFxcdGV4dFwiLCBcIlxcXFx0ZXh0cm1cIiwgXCJcXFxcdGV4dHNmXCIsIFwiXFxcXHRleHR0dFwiLCBcIlxcXFx0ZXh0bm9ybWFsXCIsIC8vIEZvbnQgd2VpZ2h0c1xuICBcIlxcXFx0ZXh0YmZcIiwgXCJcXFxcdGV4dG1kXCIsIC8vIEZvbnQgU2hhcGVzXG4gIFwiXFxcXHRleHRpdFwiLCBcIlxcXFx0ZXh0dXBcIiwgXCJcXFxcZW1waFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFyZ1R5cGVzOiBbXCJ0ZXh0XCJdLFxuICAgIGFsbG93ZWRJbkFyZ3VtZW50OiB0cnVlLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcblxuICBoYW5kbGVyKF9yZWYsIGFyZ3MpIHtcbiAgICBsZXQge1xuICAgICAgcGFyc2VyLFxuICAgICAgZnVuY05hbWVcbiAgICB9ID0gX3JlZjtcbiAgICBjb25zdCBib2R5ID0gYXJnc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGJvZHk6IG9yZGFyZ3VtZW50KGJvZHkpLFxuICAgICAgZm9udDogZnVuY05hbWVcbiAgICB9O1xuICB9LFxuXG4gIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbmV3T3B0aW9ucyA9IG9wdGlvbnNXaXRoRm9udChncm91cCwgb3B0aW9ucyk7XG4gICAgY29uc3QgaW5uZXIgPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAuYm9keSwgbmV3T3B0aW9ucywgdHJ1ZSk7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1vcmRcIiwgXCJ0ZXh0XCJdLCBpbm5lciwgbmV3T3B0aW9ucyk7XG4gIH0sXG5cbiAgbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIGNvbnN0IG5ld09wdGlvbnMgPSBvcHRpb25zV2l0aEZvbnQoZ3JvdXAsIG9wdGlvbnMpO1xuICAgIHJldHVybiBidWlsZEV4cHJlc3Npb25Sb3coZ3JvdXAuYm9keSwgbmV3T3B0aW9ucyk7XG4gIH1cblxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZnVuY3Rpb25zL3VuZGVybGluZS5qc1xuXG5cblxuXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJ1bmRlcmxpbmVcIixcbiAgbmFtZXM6IFtcIlxcXFx1bmRlcmxpbmVcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG5cbiAgaGFuZGxlcihfcmVmLCBhcmdzKSB7XG4gICAgbGV0IHtcbiAgICAgIHBhcnNlclxuICAgIH0gPSBfcmVmO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInVuZGVybGluZVwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBib2R5OiBhcmdzWzBdXG4gICAgfTtcbiAgfSxcblxuICBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIC8vIFVuZGVybGluZXMgYXJlIGhhbmRsZWQgaW4gdGhlIFRlWGJvb2sgcGcgNDQzLCBSdWxlIDEwLlxuICAgIC8vIEJ1aWxkIHRoZSBpbm5lciBncm91cC5cbiAgICBjb25zdCBpbm5lckdyb3VwID0gYnVpbGRHcm91cChncm91cC5ib2R5LCBvcHRpb25zKTsgLy8gQ3JlYXRlIHRoZSBsaW5lIHRvIGdvIGJlbG93IHRoZSBib2R5XG5cbiAgICBjb25zdCBsaW5lID0gYnVpbGRDb21tb24ubWFrZUxpbmVTcGFuKFwidW5kZXJsaW5lLWxpbmVcIiwgb3B0aW9ucyk7IC8vIEdlbmVyYXRlIHRoZSB2bGlzdCwgd2l0aCB0aGUgYXBwcm9wcmlhdGUga2VybnNcblxuICAgIGNvbnN0IGRlZmF1bHRSdWxlVGhpY2tuZXNzID0gb3B0aW9ucy5mb250TWV0cmljcygpLmRlZmF1bHRSdWxlVGhpY2tuZXNzO1xuICAgIGNvbnN0IHZsaXN0ID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHtcbiAgICAgIHBvc2l0aW9uVHlwZTogXCJ0b3BcIixcbiAgICAgIHBvc2l0aW9uRGF0YTogaW5uZXJHcm91cC5oZWlnaHQsXG4gICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgdHlwZTogXCJrZXJuXCIsXG4gICAgICAgIHNpemU6IGRlZmF1bHRSdWxlVGhpY2tuZXNzXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBsaW5lXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwia2VyblwiLFxuICAgICAgICBzaXplOiAzICogZGVmYXVsdFJ1bGVUaGlja25lc3NcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IGlubmVyR3JvdXBcbiAgICAgIH1dXG4gICAgfSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1vcmRcIiwgXCJ1bmRlcmxpbmVcIl0sIFt2bGlzdF0sIG9wdGlvbnMpO1xuICB9LFxuXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBvcGVyYXRvciA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIiwgW25ldyBtYXRoTUxUcmVlLlRleHROb2RlKFwiXFx1MjAzZVwiKV0pO1xuICAgIG9wZXJhdG9yLnNldEF0dHJpYnV0ZShcInN0cmV0Y2h5XCIsIFwidHJ1ZVwiKTtcbiAgICBjb25zdCBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdW5kZXJcIiwgW2J1aWxkTWF0aE1MX2J1aWxkR3JvdXAoZ3JvdXAuYm9keSwgb3B0aW9ucyksIG9wZXJhdG9yXSk7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJhY2NlbnR1bmRlclwiLCBcInRydWVcIik7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZnVuY3Rpb25zL3ZjZW50ZXIuanNcblxuXG5cblxuIC8vIFxcdmNlbnRlcjogIFZlcnRpY2FsbHkgY2VudGVyIHRoZSBhcmd1bWVudCBncm91cCBvbiB0aGUgbWF0aCBheGlzLlxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwidmNlbnRlclwiLFxuICBuYW1lczogW1wiXFxcXHZjZW50ZXJcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhcmdUeXBlczogW1wib3JpZ2luYWxcIl0sXG4gICAgLy8gSW4gTGFUZVgsIFxcdmNlbnRlciBjYW4gYWN0IG9ubHkgb24gYSBib3guXG4gICAgYWxsb3dlZEluVGV4dDogZmFsc2VcbiAgfSxcblxuICBoYW5kbGVyKF9yZWYsIGFyZ3MpIHtcbiAgICBsZXQge1xuICAgICAgcGFyc2VyXG4gICAgfSA9IF9yZWY7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwidmNlbnRlclwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBib2R5OiBhcmdzWzBdXG4gICAgfTtcbiAgfSxcblxuICBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGJvZHkgPSBidWlsZEdyb3VwKGdyb3VwLmJvZHksIG9wdGlvbnMpO1xuICAgIGNvbnN0IGF4aXNIZWlnaHQgPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkuYXhpc0hlaWdodDtcbiAgICBjb25zdCBkeSA9IDAuNSAqIChib2R5LmhlaWdodCAtIGF4aXNIZWlnaHQgLSAoYm9keS5kZXB0aCArIGF4aXNIZWlnaHQpKTtcbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVZMaXN0KHtcbiAgICAgIHBvc2l0aW9uVHlwZTogXCJzaGlmdFwiLFxuICAgICAgcG9zaXRpb25EYXRhOiBkeSxcbiAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogYm9keVxuICAgICAgfV1cbiAgICB9LCBvcHRpb25zKTtcbiAgfSxcblxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gVGhlcmUgaXMgbm8gd2F5IHRvIGRvIHRoaXMgaW4gTWF0aE1MLlxuICAgIC8vIFdyaXRlIGEgY2xhc3MgYXMgYSBicmVhZGNydW1iIGluIGNhc2Ugc29tZSBwb3N0LXByb2Nlc3NvciB3YW50c1xuICAgIC8vIHRvIHBlcmZvcm0gYSB2Y2VudGVyIGFkanVzdG1lbnQuXG4gICAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXBhZGRlZFwiLCBbYnVpbGRNYXRoTUxfYnVpbGRHcm91cChncm91cC5ib2R5LCBvcHRpb25zKV0sIFtcInZjZW50ZXJcIl0pO1xuICB9XG5cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy92ZXJiLmpzXG5cblxuXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJ2ZXJiXCIsXG4gIG5hbWVzOiBbXCJcXFxcdmVyYlwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcblxuICBoYW5kbGVyKGNvbnRleHQsIGFyZ3MsIG9wdEFyZ3MpIHtcbiAgICAvLyBcXHZlcmIgYW5kIFxcdmVyYiogYXJlIGRlYWx0IHdpdGggZGlyZWN0bHkgaW4gUGFyc2VyLmpzLlxuICAgIC8vIElmIHdlIGVuZCB1cCBoZXJlLCBpdCdzIGJlY2F1c2Ugb2YgYSBmYWlsdXJlIHRvIG1hdGNoIHRoZSB0d28gZGVsaW1pdGVyc1xuICAgIC8vIGluIHRoZSByZWdleCBpbiBMZXhlci5qcy4gIExhVGVYIHJhaXNlcyB0aGUgZm9sbG93aW5nIGVycm9yIHdoZW4gXFx2ZXJiIGlzXG4gICAgLy8gdGVybWluYXRlZCBieSBlbmQgb2YgbGluZSAob3IgZmlsZSkuXG4gICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiXFxcXHZlcmIgZW5kZWQgYnkgZW5kIG9mIGxpbmUgaW5zdGVhZCBvZiBtYXRjaGluZyBkZWxpbWl0ZXJcIik7XG4gIH0sXG5cbiAgaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0ZXh0ID0gbWFrZVZlcmIoZ3JvdXApO1xuICAgIGNvbnN0IGJvZHkgPSBbXTsgLy8gXFx2ZXJiIGVudGVycyB0ZXh0IG1vZGUgYW5kIHRoZXJlZm9yZSBpcyBzaXplZCBsaWtlIFxcdGV4dHN0eWxlXG5cbiAgICBjb25zdCBuZXdPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdTdHlsZShvcHRpb25zLnN0eWxlLnRleHQoKSk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBjID0gdGV4dFtpXTtcblxuICAgICAgaWYgKGMgPT09ICd+Jykge1xuICAgICAgICBjID0gJ1xcXFx0ZXh0YXNjaWl0aWxkZSc7XG4gICAgICB9XG5cbiAgICAgIGJvZHkucHVzaChidWlsZENvbW1vbi5tYWtlU3ltYm9sKGMsIFwiVHlwZXdyaXRlci1SZWd1bGFyXCIsIGdyb3VwLm1vZGUsIG5ld09wdGlvbnMsIFtcIm1vcmRcIiwgXCJ0ZXh0dHRcIl0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibW9yZFwiLCBcInRleHRcIl0uY29uY2F0KG5ld09wdGlvbnMuc2l6aW5nQ2xhc3NlcyhvcHRpb25zKSksIGJ1aWxkQ29tbW9uLnRyeUNvbWJpbmVDaGFycyhib2R5KSwgbmV3T3B0aW9ucyk7XG4gIH0sXG5cbiAgbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHRleHQgPSBuZXcgbWF0aE1MVHJlZS5UZXh0Tm9kZShtYWtlVmVyYihncm91cCkpO1xuICAgIGNvbnN0IG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10ZXh0XCIsIFt0ZXh0XSk7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJtYXRodmFyaWFudFwiLCBcIm1vbm9zcGFjZVwiKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG59KTtcbi8qKlxuICogQ29udmVydHMgdmVyYiBncm91cCBpbnRvIGJvZHkgc3RyaW5nLlxuICpcbiAqIFxcdmVyYiogcmVwbGFjZXMgZWFjaCBzcGFjZSB3aXRoIGFuIG9wZW4gYm94IFxcdTI0MjNcbiAqIFxcdmVyYiByZXBsYWNlcyBlYWNoIHNwYWNlIHdpdGggYSBuby1icmVhayBzcGFjZSBcXHhBMFxuICovXG5cbmNvbnN0IG1ha2VWZXJiID0gZ3JvdXAgPT4gZ3JvdXAuYm9keS5yZXBsYWNlKC8gL2csIGdyb3VwLnN0YXIgPyAnXFx1MjQyMycgOiAnXFx4QTAnKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mdW5jdGlvbnMuanNcbi8qKiBJbmNsdWRlIHRoaXMgdG8gZW5zdXJlIHRoYXQgYWxsIGZ1bmN0aW9ucyBhcmUgZGVmaW5lZC4gKi9cblxuY29uc3QgZnVuY3Rpb25zID0gX2Z1bmN0aW9ucztcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHNyY19mdW5jdGlvbnMgPSAoZnVuY3Rpb25zKTsgLy8gVE9ETyhrZXZpbmIpOiBoYXZlIGZ1bmN0aW9ucyByZXR1cm4gYW4gb2JqZWN0IGFuZCBjYWxsIGRlZmluZUZ1bmN0aW9uIHdpdGhcbi8vIHRoYXQgb2JqZWN0IGluIHRoaXMgZmlsZSBpbnN0ZWFkIG9mIHJlbHlpbmcgb24gc2lkZS1lZmZlY3RzLlxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9MZXhlci5qc1xuLyoqXG4gKiBUaGUgTGV4ZXIgY2xhc3MgaGFuZGxlcyB0b2tlbml6aW5nIHRoZSBpbnB1dCBpbiB2YXJpb3VzIHdheXMuIFNpbmNlIG91clxuICogcGFyc2VyIGV4cGVjdHMgdXMgdG8gYmUgYWJsZSB0byBiYWNrdHJhY2ssIHRoZSBsZXhlciBhbGxvd3MgbGV4aW5nIGZyb20gYW55XG4gKiBnaXZlbiBzdGFydGluZyBwb2ludC5cbiAqXG4gKiBJdHMgbWFpbiBleHBvc2VkIGZ1bmN0aW9uIGlzIHRoZSBgbGV4YCBmdW5jdGlvbiwgd2hpY2ggdGFrZXMgYSBwb3NpdGlvbiB0b1xuICogbGV4IGZyb20gYW5kIGEgdHlwZSBvZiB0b2tlbiB0byBsZXguIEl0IGRlZmVycyB0byB0aGUgYXBwcm9wcmlhdGUgYF9pbm5lckxleGBcbiAqIGZ1bmN0aW9uLlxuICpcbiAqIFRoZSB2YXJpb3VzIGBfaW5uZXJMZXhgIGZ1bmN0aW9ucyBwZXJmb3JtIHRoZSBhY3R1YWwgbGV4aW5nIG9mIGRpZmZlcmVudFxuICoga2luZHMuXG4gKi9cblxuXG5cblxuLyogVGhlIGZvbGxvd2luZyB0b2tlblJlZ2V4XG4gKiAtIG1hdGNoZXMgdHlwaWNhbCB3aGl0ZXNwYWNlIChidXQgbm90IE5CU1AgZXRjLikgdXNpbmcgaXRzIGZpcnN0IGdyb3VwXG4gKiAtIGRvZXMgbm90IG1hdGNoIGFueSBjb250cm9sIGNoYXJhY3RlciBcXHgwMC1cXHgxZiBleGNlcHQgd2hpdGVzcGFjZVxuICogLSBkb2VzIG5vdCBtYXRjaCBhIGJhcmUgYmFja3NsYXNoXG4gKiAtIG1hdGNoZXMgYW55IEFTQ0lJIGNoYXJhY3RlciBleGNlcHQgdGhvc2UganVzdCBtZW50aW9uZWRcbiAqIC0gZG9lcyBub3QgbWF0Y2ggdGhlIEJNUCBwcml2YXRlIHVzZSBhcmVhIFxcdUUwMDAtXFx1RjhGRlxuICogLSBkb2VzIG5vdCBtYXRjaCBiYXJlIHN1cnJvZ2F0ZSBjb2RlIHVuaXRzXG4gKiAtIG1hdGNoZXMgYW55IEJNUCBjaGFyYWN0ZXIgZXhjZXB0IGZvciB0aG9zZSBqdXN0IGRlc2NyaWJlZFxuICogLSBtYXRjaGVzIGFueSB2YWxpZCBVbmljb2RlIHN1cnJvZ2F0ZSBwYWlyXG4gKiAtIG1hdGNoZXMgYSBiYWNrc2xhc2ggZm9sbG93ZWQgYnkgb25lIG9yIG1vcmUgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzXG4gKiAtIG1hdGNoZXMgYSBiYWNrc2xhc2ggZm9sbG93ZWQgYnkgb25lIG9yIG1vcmUgbGV0dGVycyB0aGVuIHdoaXRlc3BhY2VcbiAqIC0gbWF0Y2hlcyBhIGJhY2tzbGFzaCBmb2xsb3dlZCBieSBhbnkgQk1QIGNoYXJhY3RlclxuICogQ2FwdHVyaW5nIGdyb3VwczpcbiAqICAgWzFdIHJlZ3VsYXIgd2hpdGVzcGFjZVxuICogICBbMl0gYmFja3NsYXNoIGZvbGxvd2VkIGJ5IHdoaXRlc3BhY2VcbiAqICAgWzNdIGFueXRoaW5nIGVsc2UsIHdoaWNoIG1heSBpbmNsdWRlOlxuICogICAgIFs0XSBsZWZ0IGNoYXJhY3RlciBvZiBcXHZlcmIqXG4gKiAgICAgWzVdIGxlZnQgY2hhcmFjdGVyIG9mIFxcdmVyYlxuICogICAgIFs2XSBiYWNrc2xhc2ggZm9sbG93ZWQgYnkgd29yZCwgZXhjbHVkaW5nIGFueSB0cmFpbGluZyB3aGl0ZXNwYWNlXG4gKiBKdXN0IGJlY2F1c2UgdGhlIExleGVyIG1hdGNoZXMgc29tZXRoaW5nIGRvZXNuJ3QgbWVhbiBpdCdzIHZhbGlkIGlucHV0OlxuICogSWYgdGhlcmUgaXMgbm8gbWF0Y2hpbmcgZnVuY3Rpb24gb3Igc3ltYm9sIGRlZmluaXRpb24sIHRoZSBQYXJzZXIgd2lsbFxuICogc3RpbGwgcmVqZWN0IHRoZSBpbnB1dC5cbiAqL1xuY29uc3Qgc3BhY2VSZWdleFN0cmluZyA9IFwiWyBcXHJcXG5cXHRdXCI7XG5jb25zdCBjb250cm9sV29yZFJlZ2V4U3RyaW5nID0gXCJcXFxcXFxcXFthLXpBLVpAXStcIjtcbmNvbnN0IGNvbnRyb2xTeW1ib2xSZWdleFN0cmluZyA9IFwiXFxcXFxcXFxbXlxcdUQ4MDAtXFx1REZGRl1cIjtcbmNvbnN0IGNvbnRyb2xXb3JkV2hpdGVzcGFjZVJlZ2V4U3RyaW5nID0gXCIoXCIgKyBjb250cm9sV29yZFJlZ2V4U3RyaW5nICsgXCIpXCIgKyBzcGFjZVJlZ2V4U3RyaW5nICsgXCIqXCI7XG5jb25zdCBjb250cm9sU3BhY2VSZWdleFN0cmluZyA9IFwiXFxcXFxcXFwoXFxufFsgXFxyXFx0XStcXG4/KVsgXFxyXFx0XSpcIjtcbmNvbnN0IGNvbWJpbmluZ0RpYWNyaXRpY2FsTWFya1N0cmluZyA9IFwiW1xcdTAzMDAtXFx1MDM2Zl1cIjtcbmNvbnN0IGNvbWJpbmluZ0RpYWNyaXRpY2FsTWFya3NFbmRSZWdleCA9IG5ldyBSZWdFeHAoY29tYmluaW5nRGlhY3JpdGljYWxNYXJrU3RyaW5nICsgXCIrJFwiKTtcbmNvbnN0IHRva2VuUmVnZXhTdHJpbmcgPSBcIihcIiArIHNwYWNlUmVnZXhTdHJpbmcgKyBcIispfFwiICsgKCAvLyB3aGl0ZXNwYWNlXG5jb250cm9sU3BhY2VSZWdleFN0cmluZyArIFwifFwiKSArIC8vIFxcd2hpdGVzcGFjZVxuXCIoWyEtXFxcXFtcXFxcXS1cXHUyMDI3XFx1MjAyQS1cXHVEN0ZGXFx1RjkwMC1cXHVGRkZGXVwiICsgKCAvLyBzaW5nbGUgY29kZXBvaW50XG5jb21iaW5pbmdEaWFjcml0aWNhbE1hcmtTdHJpbmcgKyBcIipcIikgKyAvLyAuLi5wbHVzIGFjY2VudHNcblwifFtcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl1cIiArICggLy8gc3Vycm9nYXRlIHBhaXJcbmNvbWJpbmluZ0RpYWNyaXRpY2FsTWFya1N0cmluZyArIFwiKlwiKSArIC8vIC4uLnBsdXMgYWNjZW50c1xuXCJ8XFxcXFxcXFx2ZXJiXFxcXCooW15dKS4qP1xcXFw0XCIgKyAvLyBcXHZlcmIqXG5cInxcXFxcXFxcXHZlcmIoW14qYS16QS1aXSkuKj9cXFxcNVwiICsgKCAvLyBcXHZlcmIgdW5zdGFycmVkXG5cInxcIiArIGNvbnRyb2xXb3JkV2hpdGVzcGFjZVJlZ2V4U3RyaW5nKSArICggLy8gXFxtYWNyb05hbWUgKyBzcGFjZXNcblwifFwiICsgY29udHJvbFN5bWJvbFJlZ2V4U3RyaW5nICsgXCIpXCIpOyAvLyBcXFxcLCBcXCcsIGV0Yy5cblxuLyoqIE1haW4gTGV4ZXIgY2xhc3MgKi9cblxuY2xhc3MgTGV4ZXIge1xuICAvLyBDYXRlZ29yeSBjb2Rlcy4gVGhlIGxleGVyIG9ubHkgc3VwcG9ydHMgY29tbWVudCBjaGFyYWN0ZXJzICgxNCkgZm9yIG5vdy5cbiAgLy8gTWFjcm9FeHBhbmRlciBhZGRpdGlvbmFsbHkgZGlzdGluZ3Vpc2hlcyBhY3RpdmUgKDEzKS5cbiAgY29uc3RydWN0b3IoaW5wdXQsIHNldHRpbmdzKSB7XG4gICAgdGhpcy5pbnB1dCA9IHZvaWQgMDtcbiAgICB0aGlzLnNldHRpbmdzID0gdm9pZCAwO1xuICAgIHRoaXMudG9rZW5SZWdleCA9IHZvaWQgMDtcbiAgICB0aGlzLmNhdGNvZGVzID0gdm9pZCAwO1xuICAgIC8vIFNlcGFyYXRlIGFjY2VudHMgZnJvbSBjaGFyYWN0ZXJzXG4gICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICB0aGlzLnRva2VuUmVnZXggPSBuZXcgUmVnRXhwKHRva2VuUmVnZXhTdHJpbmcsICdnJyk7XG4gICAgdGhpcy5jYXRjb2RlcyA9IHtcbiAgICAgIFwiJVwiOiAxNCxcbiAgICAgIC8vIGNvbW1lbnQgY2hhcmFjdGVyXG4gICAgICBcIn5cIjogMTMgLy8gYWN0aXZlIGNoYXJhY3RlclxuXG4gICAgfTtcbiAgfVxuXG4gIHNldENhdGNvZGUoY2hhciwgY29kZSkge1xuICAgIHRoaXMuY2F0Y29kZXNbY2hhcl0gPSBjb2RlO1xuICB9XG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGxleGVzIGEgc2luZ2xlIHRva2VuLlxuICAgKi9cblxuXG4gIGxleCgpIHtcbiAgICBjb25zdCBpbnB1dCA9IHRoaXMuaW5wdXQ7XG4gICAgY29uc3QgcG9zID0gdGhpcy50b2tlblJlZ2V4Lmxhc3RJbmRleDtcblxuICAgIGlmIChwb3MgPT09IGlucHV0Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG5ldyBUb2tlbihcIkVPRlwiLCBuZXcgU291cmNlTG9jYXRpb24odGhpcywgcG9zLCBwb3MpKTtcbiAgICB9XG5cbiAgICBjb25zdCBtYXRjaCA9IHRoaXMudG9rZW5SZWdleC5leGVjKGlucHV0KTtcblxuICAgIGlmIChtYXRjaCA9PT0gbnVsbCB8fCBtYXRjaC5pbmRleCAhPT0gcG9zKSB7XG4gICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJVbmV4cGVjdGVkIGNoYXJhY3RlcjogJ1wiICsgaW5wdXRbcG9zXSArIFwiJ1wiLCBuZXcgVG9rZW4oaW5wdXRbcG9zXSwgbmV3IFNvdXJjZUxvY2F0aW9uKHRoaXMsIHBvcywgcG9zICsgMSkpKTtcbiAgICB9XG5cbiAgICBjb25zdCB0ZXh0ID0gbWF0Y2hbNl0gfHwgbWF0Y2hbM10gfHwgKG1hdGNoWzJdID8gXCJcXFxcIFwiIDogXCIgXCIpO1xuXG4gICAgaWYgKHRoaXMuY2F0Y29kZXNbdGV4dF0gPT09IDE0KSB7XG4gICAgICAvLyBjb21tZW50IGNoYXJhY3RlclxuICAgICAgY29uc3QgbmxJbmRleCA9IGlucHV0LmluZGV4T2YoJ1xcbicsIHRoaXMudG9rZW5SZWdleC5sYXN0SW5kZXgpO1xuXG4gICAgICBpZiAobmxJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy50b2tlblJlZ2V4Lmxhc3RJbmRleCA9IGlucHV0Lmxlbmd0aDsgLy8gRU9GXG5cbiAgICAgICAgdGhpcy5zZXR0aW5ncy5yZXBvcnROb25zdHJpY3QoXCJjb21tZW50QXRFbmRcIiwgXCIlIGNvbW1lbnQgaGFzIG5vIHRlcm1pbmF0aW5nIG5ld2xpbmU7IExhVGVYIHdvdWxkIFwiICsgXCJmYWlsIGJlY2F1c2Ugb2YgY29tbWVudGluZyB0aGUgZW5kIG9mIG1hdGggbW9kZSAoZS5nLiAkKVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudG9rZW5SZWdleC5sYXN0SW5kZXggPSBubEluZGV4ICsgMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMubGV4KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBUb2tlbih0ZXh0LCBuZXcgU291cmNlTG9jYXRpb24odGhpcywgcG9zLCB0aGlzLnRva2VuUmVnZXgubGFzdEluZGV4KSk7XG4gIH1cblxufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL05hbWVzcGFjZS5qc1xuLyoqXG4gKiBBIGBOYW1lc3BhY2VgIHJlZmVycyB0byBhIHNwYWNlIG9mIG5hbWVhYmxlIHRoaW5ncyBsaWtlIG1hY3JvcyBvciBsZW5ndGhzLFxuICogd2hpY2ggY2FuIGJlIGBzZXRgIGVpdGhlciBnbG9iYWxseSBvciBsb2NhbCB0byBhIG5lc3RlZCBncm91cCwgdXNpbmcgYW5cbiAqIHVuZG8gc3RhY2sgc2ltaWxhciB0byBob3cgVGVYIGltcGxlbWVudHMgdGhpcyBmdW5jdGlvbmFsaXR5LlxuICogUGVyZm9ybWFuY2Utd2lzZSwgYGdldGAgYW5kIGxvY2FsIGBzZXRgIHRha2UgY29uc3RhbnQgdGltZSwgd2hpbGUgZ2xvYmFsXG4gKiBgc2V0YCB0YWtlcyB0aW1lIHByb3BvcnRpb25hbCB0byB0aGUgZGVwdGggb2YgZ3JvdXAgbmVzdGluZy5cbiAqL1xuXG5jbGFzcyBOYW1lc3BhY2Uge1xuICAvKipcbiAgICogQm90aCBhcmd1bWVudHMgYXJlIG9wdGlvbmFsLiAgVGhlIGZpcnN0IGFyZ3VtZW50IGlzIGFuIG9iamVjdCBvZlxuICAgKiBidWlsdC1pbiBtYXBwaW5ncyB3aGljaCBuZXZlciBjaGFuZ2UuICBUaGUgc2Vjb25kIGFyZ3VtZW50IGlzIGFuIG9iamVjdFxuICAgKiBvZiBpbml0aWFsIChnbG9iYWwtbGV2ZWwpIG1hcHBpbmdzLCB3aGljaCB3aWxsIGNvbnN0YW50bHkgY2hhbmdlXG4gICAqIGFjY29yZGluZyB0byBhbnkgZ2xvYmFsL3RvcC1sZXZlbCBgc2V0YHMgZG9uZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGJ1aWx0aW5zLCBnbG9iYWxNYWNyb3MpIHtcbiAgICBpZiAoYnVpbHRpbnMgPT09IHZvaWQgMCkge1xuICAgICAgYnVpbHRpbnMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAoZ2xvYmFsTWFjcm9zID09PSB2b2lkIDApIHtcbiAgICAgIGdsb2JhbE1hY3JvcyA9IHt9O1xuICAgIH1cblxuICAgIHRoaXMuY3VycmVudCA9IHZvaWQgMDtcbiAgICB0aGlzLmJ1aWx0aW5zID0gdm9pZCAwO1xuICAgIHRoaXMudW5kZWZTdGFjayA9IHZvaWQgMDtcbiAgICB0aGlzLmN1cnJlbnQgPSBnbG9iYWxNYWNyb3M7XG4gICAgdGhpcy5idWlsdGlucyA9IGJ1aWx0aW5zO1xuICAgIHRoaXMudW5kZWZTdGFjayA9IFtdO1xuICB9XG4gIC8qKlxuICAgKiBTdGFydCBhIG5ldyBuZXN0ZWQgZ3JvdXAsIGFmZmVjdGluZyBmdXR1cmUgbG9jYWwgYHNldGBzLlxuICAgKi9cblxuXG4gIGJlZ2luR3JvdXAoKSB7XG4gICAgdGhpcy51bmRlZlN0YWNrLnB1c2goe30pO1xuICB9XG4gIC8qKlxuICAgKiBFbmQgY3VycmVudCBuZXN0ZWQgZ3JvdXAsIHJlc3RvcmluZyB2YWx1ZXMgYmVmb3JlIHRoZSBncm91cCBiZWdhbi5cbiAgICovXG5cblxuICBlbmRHcm91cCgpIHtcbiAgICBpZiAodGhpcy51bmRlZlN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiVW5iYWxhbmNlZCBuYW1lc3BhY2UgZGVzdHJ1Y3Rpb246IGF0dGVtcHQgXCIgKyBcInRvIHBvcCBnbG9iYWwgbmFtZXNwYWNlOyBwbGVhc2UgcmVwb3J0IHRoaXMgYXMgYSBidWdcIik7XG4gICAgfVxuXG4gICAgY29uc3QgdW5kZWZzID0gdGhpcy51bmRlZlN0YWNrLnBvcCgpO1xuXG4gICAgZm9yIChjb25zdCB1bmRlZiBpbiB1bmRlZnMpIHtcbiAgICAgIGlmICh1bmRlZnMuaGFzT3duUHJvcGVydHkodW5kZWYpKSB7XG4gICAgICAgIGlmICh1bmRlZnNbdW5kZWZdID09IG51bGwpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5jdXJyZW50W3VuZGVmXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmN1cnJlbnRbdW5kZWZdID0gdW5kZWZzW3VuZGVmXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogRW5kcyBhbGwgY3VycmVudGx5IG5lc3RlZCBncm91cHMgKGlmIGFueSksIHJlc3RvcmluZyB2YWx1ZXMgYmVmb3JlIHRoZVxuICAgKiBncm91cHMgYmVnYW4uICBVc2VmdWwgaW4gY2FzZSBvZiBhbiBlcnJvciBpbiB0aGUgbWlkZGxlIG9mIHBhcnNpbmcuXG4gICAqL1xuXG5cbiAgZW5kR3JvdXBzKCkge1xuICAgIHdoaWxlICh0aGlzLnVuZGVmU3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5lbmRHcm91cCgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRGV0ZWN0IHdoZXRoZXIgYG5hbWVgIGhhcyBhIGRlZmluaXRpb24uICBFcXVpdmFsZW50IHRvXG4gICAqIGBnZXQobmFtZSkgIT0gbnVsbGAuXG4gICAqL1xuXG5cbiAgaGFzKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50Lmhhc093blByb3BlcnR5KG5hbWUpIHx8IHRoaXMuYnVpbHRpbnMuaGFzT3duUHJvcGVydHkobmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCB2YWx1ZSBvZiBhIG5hbWUsIG9yIGB1bmRlZmluZWRgIGlmIHRoZXJlIGlzIG5vIHZhbHVlLlxuICAgKlxuICAgKiBOb3RlOiBEbyBub3QgdXNlIGBpZiAobmFtZXNwYWNlLmdldCguLi4pKWAgdG8gZGV0ZWN0IHdoZXRoZXIgYSBtYWNyb1xuICAgKiBpcyBkZWZpbmVkLCBhcyB0aGUgZGVmaW5pdGlvbiBtYXkgYmUgdGhlIGVtcHR5IHN0cmluZyB3aGljaCBldmFsdWF0ZXNcbiAgICogdG8gYGZhbHNlYCBpbiBKYXZhU2NyaXB0LiAgVXNlIGBpZiAobmFtZXNwYWNlLmdldCguLi4pICE9IG51bGwpYCBvclxuICAgKiBgaWYgKG5hbWVzcGFjZS5oYXMoLi4uKSlgLlxuICAgKi9cblxuXG4gIGdldChuYW1lKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFtuYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuYnVpbHRpbnNbbmFtZV07XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTZXQgdGhlIGN1cnJlbnQgdmFsdWUgb2YgYSBuYW1lLCBhbmQgb3B0aW9uYWxseSBzZXQgaXQgZ2xvYmFsbHkgdG9vLlxuICAgKiBMb2NhbCBzZXQoKSBzZXRzIHRoZSBjdXJyZW50IHZhbHVlIGFuZCAod2hlbiBhcHByb3ByaWF0ZSkgYWRkcyBhbiB1bmRvXG4gICAqIG9wZXJhdGlvbiB0byB0aGUgdW5kbyBzdGFjay4gIEdsb2JhbCBzZXQoKSBtYXkgY2hhbmdlIHRoZSB1bmRvXG4gICAqIG9wZXJhdGlvbiBhdCBldmVyeSBsZXZlbCwgc28gdGFrZXMgdGltZSBsaW5lYXIgaW4gdGhlaXIgbnVtYmVyLlxuICAgKiBBIHZhbHVlIG9mIHVuZGVmaW5lZCBtZWFucyB0byBkZWxldGUgZXhpc3RpbmcgZGVmaW5pdGlvbnMuXG4gICAqL1xuXG5cbiAgc2V0KG5hbWUsIHZhbHVlLCBnbG9iYWwpIHtcbiAgICBpZiAoZ2xvYmFsID09PSB2b2lkIDApIHtcbiAgICAgIGdsb2JhbCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChnbG9iYWwpIHtcbiAgICAgIC8vIEdsb2JhbCBzZXQgaXMgZXF1aXZhbGVudCB0byBzZXR0aW5nIGluIGFsbCBncm91cHMuICBTaW11bGF0ZSB0aGlzXG4gICAgICAvLyBieSBkZXN0cm95aW5nIGFueSB1bmRvcyBjdXJyZW50bHkgc2NoZWR1bGVkIGZvciB0aGlzIG5hbWUsXG4gICAgICAvLyBhbmQgYWRkaW5nIGFuIHVuZG8gd2l0aCB0aGUgKm5ldyogdmFsdWUgKGluIGNhc2UgaXQgbGF0ZXIgZ2V0c1xuICAgICAgLy8gbG9jYWxseSByZXNldCB3aXRoaW4gdGhpcyBlbnZpcm9ubWVudCkuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudW5kZWZTdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgICBkZWxldGUgdGhpcy51bmRlZlN0YWNrW2ldW25hbWVdO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy51bmRlZlN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy51bmRlZlN0YWNrW3RoaXMudW5kZWZTdGFjay5sZW5ndGggLSAxXVtuYW1lXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVbmRvIHRoaXMgc2V0IGF0IGVuZCBvZiB0aGlzIGdyb3VwIChwb3NzaWJseSB0byBgdW5kZWZpbmVkYCksXG4gICAgICAvLyB1bmxlc3MgYW4gdW5kbyBpcyBhbHJlYWR5IGluIHBsYWNlLCBpbiB3aGljaCBjYXNlIHRoYXQgb2xkZXJcbiAgICAgIC8vIHZhbHVlIGlzIHRoZSBjb3JyZWN0IG9uZS5cbiAgICAgIGNvbnN0IHRvcCA9IHRoaXMudW5kZWZTdGFja1t0aGlzLnVuZGVmU3RhY2subGVuZ3RoIC0gMV07XG5cbiAgICAgIGlmICh0b3AgJiYgIXRvcC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICB0b3BbbmFtZV0gPSB0aGlzLmN1cnJlbnRbbmFtZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmN1cnJlbnRbbmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3VycmVudFtuYW1lXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvbWFjcm9zLmpzXG4vKipcbiAqIFByZWRlZmluZWQgbWFjcm9zIGZvciBLYVRlWC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gZGVmaW5lIHNvbWUgY29tbWFuZHMgaW4gdGVybXMgb2Ygb3RoZXJzLlxuICovXG4vLyBFeHBvcnQgZ2xvYmFsIG1hY3JvcyBvYmplY3QgZnJvbSBkZWZpbmVNYWNyb1xuXG5jb25zdCBtYWNyb3MgPSBfbWFjcm9zO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgc3JjX21hY3JvcyA9IChtYWNyb3MpO1xuXG5cblxuXG5cbiAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBtYWNybyB0b29sc1xuXG5kZWZpbmVNYWNybyhcIlxcXFxub2V4cGFuZFwiLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICAvLyBUaGUgZXhwYW5zaW9uIGlzIHRoZSB0b2tlbiBpdHNlbGY7IGJ1dCB0aGF0IHRva2VuIGlzIGludGVycHJldGVkXG4gIC8vIGFzIGlmIGl0cyBtZWFuaW5nIHdlcmUg4oCYXFxyZWxheOKAmSBpZiBpdCBpcyBhIGNvbnRyb2wgc2VxdWVuY2UgdGhhdFxuICAvLyB3b3VsZCBvcmRpbmFyaWx5IGJlIGV4cGFuZGVkIGJ5IFRlWOKAmXMgZXhwYW5zaW9uIHJ1bGVzLlxuICBjb25zdCB0ID0gY29udGV4dC5wb3BUb2tlbigpO1xuXG4gIGlmIChjb250ZXh0LmlzRXhwYW5kYWJsZSh0LnRleHQpKSB7XG4gICAgdC5ub2V4cGFuZCA9IHRydWU7XG4gICAgdC50cmVhdEFzUmVsYXggPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0b2tlbnM6IFt0XSxcbiAgICBudW1BcmdzOiAwXG4gIH07XG59KTtcbmRlZmluZU1hY3JvKFwiXFxcXGV4cGFuZGFmdGVyXCIsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gIC8vIFRlWCBmaXJzdCByZWFkcyB0aGUgdG9rZW4gdGhhdCBjb21lcyBpbW1lZGlhdGVseSBhZnRlciBcXGV4cGFuZGFmdGVyLFxuICAvLyB3aXRob3V0IGV4cGFuZGluZyBpdDsgbGV04oCZcyBjYWxsIHRoaXMgdG9rZW4gdC4gVGhlbiBUZVggcmVhZHMgdGhlXG4gIC8vIHRva2VuIHRoYXQgY29tZXMgYWZ0ZXIgdCAoYW5kIHBvc3NpYmx5IG1vcmUgdG9rZW5zLCBpZiB0aGF0IHRva2VuXG4gIC8vIGhhcyBhbiBhcmd1bWVudCksIHJlcGxhY2luZyBpdCBieSBpdHMgZXhwYW5zaW9uLiBGaW5hbGx5IFRlWCBwdXRzXG4gIC8vIHQgYmFjayBpbiBmcm9udCBvZiB0aGF0IGV4cGFuc2lvbi5cbiAgY29uc3QgdCA9IGNvbnRleHQucG9wVG9rZW4oKTtcbiAgY29udGV4dC5leHBhbmRPbmNlKHRydWUpOyAvLyBleHBhbmQgb25seSBhbiBleHBhbmRhYmxlIHRva2VuXG5cbiAgcmV0dXJuIHtcbiAgICB0b2tlbnM6IFt0XSxcbiAgICBudW1BcmdzOiAwXG4gIH07XG59KTsgLy8gTGFUZVgncyBcXEBmaXJzdG9mdHdveyMxfXsjMn0gZXhwYW5kcyB0byAjMSwgc2tpcHBpbmcgIzJcbi8vIFRlWCBzb3VyY2U6IFxcbG9uZ1xcZGVmXFxAZmlyc3RvZnR3byMxIzJ7IzF9XG5cbmRlZmluZU1hY3JvKFwiXFxcXEBmaXJzdG9mdHdvXCIsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gIGNvbnN0IGFyZ3MgPSBjb250ZXh0LmNvbnN1bWVBcmdzKDIpO1xuICByZXR1cm4ge1xuICAgIHRva2VuczogYXJnc1swXSxcbiAgICBudW1BcmdzOiAwXG4gIH07XG59KTsgLy8gTGFUZVgncyBcXEBzZWNvbmRvZnR3b3sjMX17IzJ9IGV4cGFuZHMgdG8gIzIsIHNraXBwaW5nICMxXG4vLyBUZVggc291cmNlOiBcXGxvbmdcXGRlZlxcQHNlY29uZG9mdHdvIzEjMnsjMn1cblxuZGVmaW5lTWFjcm8oXCJcXFxcQHNlY29uZG9mdHdvXCIsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gIGNvbnN0IGFyZ3MgPSBjb250ZXh0LmNvbnN1bWVBcmdzKDIpO1xuICByZXR1cm4ge1xuICAgIHRva2VuczogYXJnc1sxXSxcbiAgICBudW1BcmdzOiAwXG4gIH07XG59KTsgLy8gTGFUZVgncyBcXEBpZm5leHRjaGFyeyMxfXsjMn17IzN9IGxvb2tzIGFoZWFkIHRvIHRoZSBuZXh0ICh1bmV4cGFuZGVkKVxuLy8gc3ltYm9sIHRoYXQgaXNuJ3QgYSBzcGFjZSwgY29uc3VtaW5nIGFueSBzcGFjZXMgYnV0IG5vdCBjb25zdW1pbmcgdGhlXG4vLyBmaXJzdCBub25zcGFjZSBjaGFyYWN0ZXIuICBJZiB0aGF0IG5vbnNwYWNlIGNoYXJhY3RlciBtYXRjaGVzICMxLCB0aGVuXG4vLyB0aGUgbWFjcm8gZXhwYW5kcyB0byAjMjsgb3RoZXJ3aXNlLCBpdCBleHBhbmRzIHRvICMzLlxuXG5kZWZpbmVNYWNybyhcIlxcXFxAaWZuZXh0Y2hhclwiLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICBjb25zdCBhcmdzID0gY29udGV4dC5jb25zdW1lQXJncygzKTsgLy8gc3ltYm9sLCBpZiwgZWxzZVxuXG4gIGNvbnRleHQuY29uc3VtZVNwYWNlcygpO1xuICBjb25zdCBuZXh0VG9rZW4gPSBjb250ZXh0LmZ1dHVyZSgpO1xuXG4gIGlmIChhcmdzWzBdLmxlbmd0aCA9PT0gMSAmJiBhcmdzWzBdWzBdLnRleHQgPT09IG5leHRUb2tlbi50ZXh0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRva2VuczogYXJnc1sxXSxcbiAgICAgIG51bUFyZ3M6IDBcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICB0b2tlbnM6IGFyZ3NbMl0sXG4gICAgICBudW1BcmdzOiAwXG4gICAgfTtcbiAgfVxufSk7IC8vIExhVGVYJ3MgXFxAaWZzdGFyeyMxfXsjMn0gbG9va3MgYWhlYWQgdG8gdGhlIG5leHQgKHVuZXhwYW5kZWQpIHN5bWJvbC5cbi8vIElmIGl0IGlzIGAqYCwgdGhlbiBpdCBjb25zdW1lcyB0aGUgc3ltYm9sLCBhbmQgdGhlIG1hY3JvIGV4cGFuZHMgdG8gIzE7XG4vLyBvdGhlcndpc2UsIHRoZSBtYWNybyBleHBhbmRzIHRvICMyICh3aXRob3V0IGNvbnN1bWluZyB0aGUgc3ltYm9sKS5cbi8vIFRlWCBzb3VyY2U6IFxcZGVmXFxAaWZzdGFyIzF7XFxAaWZuZXh0Y2hhciAqe1xcQGZpcnN0b2Z0d297IzF9fX1cblxuZGVmaW5lTWFjcm8oXCJcXFxcQGlmc3RhclwiLCBcIlxcXFxAaWZuZXh0Y2hhciAqe1xcXFxAZmlyc3RvZnR3b3sjMX19XCIpOyAvLyBMYVRlWCdzIFxcVGV4dE9yTWF0aHsjMX17IzJ9IGV4cGFuZHMgdG8gIzEgaW4gdGV4dCBtb2RlLCAjMiBpbiBtYXRoIG1vZGVcblxuZGVmaW5lTWFjcm8oXCJcXFxcVGV4dE9yTWF0aFwiLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICBjb25zdCBhcmdzID0gY29udGV4dC5jb25zdW1lQXJncygyKTtcblxuICBpZiAoY29udGV4dC5tb2RlID09PSAndGV4dCcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9rZW5zOiBhcmdzWzBdLFxuICAgICAgbnVtQXJnczogMFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRva2VuczogYXJnc1sxXSxcbiAgICAgIG51bUFyZ3M6IDBcbiAgICB9O1xuICB9XG59KTsgLy8gTG9va3VwIHRhYmxlIGZvciBwYXJzaW5nIG51bWJlcnMgaW4gYmFzZSA4IHRocm91Z2ggMTZcblxuY29uc3QgZGlnaXRUb051bWJlciA9IHtcbiAgXCIwXCI6IDAsXG4gIFwiMVwiOiAxLFxuICBcIjJcIjogMixcbiAgXCIzXCI6IDMsXG4gIFwiNFwiOiA0LFxuICBcIjVcIjogNSxcbiAgXCI2XCI6IDYsXG4gIFwiN1wiOiA3LFxuICBcIjhcIjogOCxcbiAgXCI5XCI6IDksXG4gIFwiYVwiOiAxMCxcbiAgXCJBXCI6IDEwLFxuICBcImJcIjogMTEsXG4gIFwiQlwiOiAxMSxcbiAgXCJjXCI6IDEyLFxuICBcIkNcIjogMTIsXG4gIFwiZFwiOiAxMyxcbiAgXCJEXCI6IDEzLFxuICBcImVcIjogMTQsXG4gIFwiRVwiOiAxNCxcbiAgXCJmXCI6IDE1LFxuICBcIkZcIjogMTVcbn07IC8vIFRlWCBcXGNoYXIgbWFrZXMgYSBsaXRlcmFsIGNoYXJhY3RlciAoY2F0Y29kZSAxMikgdXNpbmcgdGhlIGZvbGxvd2luZyBmb3Jtczpcbi8vIChzZWUgVGhlIFRlWEJvb2ssIHAuIDQzKVxuLy8gICBcXGNoYXIxMjMgIC0tIGRlY2ltYWxcbi8vICAgXFxjaGFyJzEyMyAtLSBvY3RhbFxuLy8gICBcXGNoYXJcIjEyMyAtLSBoZXhcbi8vICAgXFxjaGFyYHggICAtLSBjaGFyYWN0ZXIgdGhhdCBjYW4gYmUgd3JpdHRlbiAoaS5lLiBpc24ndCBhY3RpdmUpXG4vLyAgIFxcY2hhcmBcXHggIC0tIGNoYXJhY3RlciB0aGF0IGNhbm5vdCBiZSB3cml0dGVuIChlLmcuICUpXG4vLyBUaGVzZSBhbGwgcmVmZXIgdG8gY2hhcmFjdGVycyBmcm9tIHRoZSBmb250LCBzbyB3ZSB0dXJuIHRoZW0gaW50byBzcGVjaWFsXG4vLyBjYWxscyB0byBhIGZ1bmN0aW9uIFxcQGNoYXIgZGVhbHQgd2l0aCBpbiB0aGUgUGFyc2VyLlxuXG5kZWZpbmVNYWNybyhcIlxcXFxjaGFyXCIsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gIGxldCB0b2tlbiA9IGNvbnRleHQucG9wVG9rZW4oKTtcbiAgbGV0IGJhc2U7XG4gIGxldCBudW1iZXIgPSAnJztcblxuICBpZiAodG9rZW4udGV4dCA9PT0gXCInXCIpIHtcbiAgICBiYXNlID0gODtcbiAgICB0b2tlbiA9IGNvbnRleHQucG9wVG9rZW4oKTtcbiAgfSBlbHNlIGlmICh0b2tlbi50ZXh0ID09PSAnXCInKSB7XG4gICAgYmFzZSA9IDE2O1xuICAgIHRva2VuID0gY29udGV4dC5wb3BUb2tlbigpO1xuICB9IGVsc2UgaWYgKHRva2VuLnRleHQgPT09IFwiYFwiKSB7XG4gICAgdG9rZW4gPSBjb250ZXh0LnBvcFRva2VuKCk7XG5cbiAgICBpZiAodG9rZW4udGV4dFswXSA9PT0gXCJcXFxcXCIpIHtcbiAgICAgIG51bWJlciA9IHRva2VuLnRleHQuY2hhckNvZGVBdCgxKTtcbiAgICB9IGVsc2UgaWYgKHRva2VuLnRleHQgPT09IFwiRU9GXCIpIHtcbiAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIlxcXFxjaGFyYCBtaXNzaW5nIGFyZ3VtZW50XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBudW1iZXIgPSB0b2tlbi50ZXh0LmNoYXJDb2RlQXQoMCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJhc2UgPSAxMDtcbiAgfVxuXG4gIGlmIChiYXNlKSB7XG4gICAgLy8gUGFyc2UgYSBudW1iZXIgaW4gdGhlIGdpdmVuIGJhc2UsIHN0YXJ0aW5nIHdpdGggZmlyc3QgYHRva2VuYC5cbiAgICBudW1iZXIgPSBkaWdpdFRvTnVtYmVyW3Rva2VuLnRleHRdO1xuXG4gICAgaWYgKG51bWJlciA9PSBudWxsIHx8IG51bWJlciA+PSBiYXNlKSB7XG4gICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJJbnZhbGlkIGJhc2UtXCIgKyBiYXNlICsgXCIgZGlnaXQgXCIgKyB0b2tlbi50ZXh0KTtcbiAgICB9XG5cbiAgICBsZXQgZGlnaXQ7XG5cbiAgICB3aGlsZSAoKGRpZ2l0ID0gZGlnaXRUb051bWJlcltjb250ZXh0LmZ1dHVyZSgpLnRleHRdKSAhPSBudWxsICYmIGRpZ2l0IDwgYmFzZSkge1xuICAgICAgbnVtYmVyICo9IGJhc2U7XG4gICAgICBudW1iZXIgKz0gZGlnaXQ7XG4gICAgICBjb250ZXh0LnBvcFRva2VuKCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFwiXFxcXEBjaGFye1wiICsgbnVtYmVyICsgXCJ9XCI7XG59KTsgLy8gXFxuZXdjb21tYW5ke1xcbWFjcm99W2FyZ3Nde2RlZmluaXRpb259XG4vLyBcXHJlbmV3Y29tbWFuZHtcXG1hY3JvfVthcmdzXXtkZWZpbml0aW9ufVxuLy8gVE9ETzogT3B0aW9uYWwgYXJndW1lbnRzOiBcXG5ld2NvbW1hbmR7XFxtYWNyb31bYXJnc11bZGVmYXVsdF17ZGVmaW5pdGlvbn1cblxuY29uc3QgbmV3Y29tbWFuZCA9IChjb250ZXh0LCBleGlzdHNPSywgbm9uZXhpc3RzT0spID0+IHtcbiAgbGV0IGFyZyA9IGNvbnRleHQuY29uc3VtZUFyZygpLnRva2VucztcblxuICBpZiAoYXJnLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIlxcXFxuZXdjb21tYW5kJ3MgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIG1hY3JvIG5hbWVcIik7XG4gIH1cblxuICBjb25zdCBuYW1lID0gYXJnWzBdLnRleHQ7XG4gIGNvbnN0IGV4aXN0cyA9IGNvbnRleHQuaXNEZWZpbmVkKG5hbWUpO1xuXG4gIGlmIChleGlzdHMgJiYgIWV4aXN0c09LKSB7XG4gICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiXFxcXG5ld2NvbW1hbmR7XCIgKyBuYW1lICsgXCJ9IGF0dGVtcHRpbmcgdG8gcmVkZWZpbmUgXCIgKyAobmFtZSArIFwiOyB1c2UgXFxcXHJlbmV3Y29tbWFuZFwiKSk7XG4gIH1cblxuICBpZiAoIWV4aXN0cyAmJiAhbm9uZXhpc3RzT0spIHtcbiAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJcXFxccmVuZXdjb21tYW5ke1wiICsgbmFtZSArIFwifSB3aGVuIGNvbW1hbmQgXCIgKyBuYW1lICsgXCIgXCIgKyBcImRvZXMgbm90IHlldCBleGlzdDsgdXNlIFxcXFxuZXdjb21tYW5kXCIpO1xuICB9XG5cbiAgbGV0IG51bUFyZ3MgPSAwO1xuICBhcmcgPSBjb250ZXh0LmNvbnN1bWVBcmcoKS50b2tlbnM7XG5cbiAgaWYgKGFyZy5sZW5ndGggPT09IDEgJiYgYXJnWzBdLnRleHQgPT09IFwiW1wiKSB7XG4gICAgbGV0IGFyZ1RleHQgPSAnJztcbiAgICBsZXQgdG9rZW4gPSBjb250ZXh0LmV4cGFuZE5leHRUb2tlbigpO1xuXG4gICAgd2hpbGUgKHRva2VuLnRleHQgIT09IFwiXVwiICYmIHRva2VuLnRleHQgIT09IFwiRU9GXCIpIHtcbiAgICAgIC8vIFRPRE86IFNob3VsZCBwcm9wZXJseSBleHBhbmQgYXJnLCBlLmcuLCBpZ25vcmUge31zXG4gICAgICBhcmdUZXh0ICs9IHRva2VuLnRleHQ7XG4gICAgICB0b2tlbiA9IGNvbnRleHQuZXhwYW5kTmV4dFRva2VuKCk7XG4gICAgfVxuXG4gICAgaWYgKCFhcmdUZXh0Lm1hdGNoKC9eXFxzKlswLTldK1xccyokLykpIHtcbiAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIkludmFsaWQgbnVtYmVyIG9mIGFyZ3VtZW50czogXCIgKyBhcmdUZXh0KTtcbiAgICB9XG5cbiAgICBudW1BcmdzID0gcGFyc2VJbnQoYXJnVGV4dCk7XG4gICAgYXJnID0gY29udGV4dC5jb25zdW1lQXJnKCkudG9rZW5zO1xuICB9IC8vIEZpbmFsIGFyZyBpcyB0aGUgZXhwYW5zaW9uIG9mIHRoZSBtYWNyb1xuXG5cbiAgY29udGV4dC5tYWNyb3Muc2V0KG5hbWUsIHtcbiAgICB0b2tlbnM6IGFyZyxcbiAgICBudW1BcmdzXG4gIH0pO1xuICByZXR1cm4gJyc7XG59O1xuXG5kZWZpbmVNYWNybyhcIlxcXFxuZXdjb21tYW5kXCIsIGNvbnRleHQgPT4gbmV3Y29tbWFuZChjb250ZXh0LCBmYWxzZSwgdHJ1ZSkpO1xuZGVmaW5lTWFjcm8oXCJcXFxccmVuZXdjb21tYW5kXCIsIGNvbnRleHQgPT4gbmV3Y29tbWFuZChjb250ZXh0LCB0cnVlLCBmYWxzZSkpO1xuZGVmaW5lTWFjcm8oXCJcXFxccHJvdmlkZWNvbW1hbmRcIiwgY29udGV4dCA9PiBuZXdjb21tYW5kKGNvbnRleHQsIHRydWUsIHRydWUpKTsgLy8gdGVybWluYWwgKGNvbnNvbGUpIHRvb2xzXG5cbmRlZmluZU1hY3JvKFwiXFxcXG1lc3NhZ2VcIiwgY29udGV4dCA9PiB7XG4gIGNvbnN0IGFyZyA9IGNvbnRleHQuY29uc3VtZUFyZ3MoMSlbMF07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG5cbiAgY29uc29sZS5sb2coYXJnLnJldmVyc2UoKS5tYXAodG9rZW4gPT4gdG9rZW4udGV4dCkuam9pbihcIlwiKSk7XG4gIHJldHVybiAnJztcbn0pO1xuZGVmaW5lTWFjcm8oXCJcXFxcZXJybWVzc2FnZVwiLCBjb250ZXh0ID0+IHtcbiAgY29uc3QgYXJnID0gY29udGV4dC5jb25zdW1lQXJncygxKVswXTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcblxuICBjb25zb2xlLmVycm9yKGFyZy5yZXZlcnNlKCkubWFwKHRva2VuID0+IHRva2VuLnRleHQpLmpvaW4oXCJcIikpO1xuICByZXR1cm4gJyc7XG59KTtcbmRlZmluZU1hY3JvKFwiXFxcXHNob3dcIiwgY29udGV4dCA9PiB7XG4gIGNvbnN0IHRvayA9IGNvbnRleHQucG9wVG9rZW4oKTtcbiAgY29uc3QgbmFtZSA9IHRvay50ZXh0OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuXG4gIGNvbnNvbGUubG9nKHRvaywgY29udGV4dC5tYWNyb3MuZ2V0KG5hbWUpLCBzcmNfZnVuY3Rpb25zW25hbWVdLCBzcmNfc3ltYm9scy5tYXRoW25hbWVdLCBzcmNfc3ltYm9scy50ZXh0W25hbWVdKTtcbiAgcmV0dXJuICcnO1xufSk7IC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEdyb3VwaW5nXG4vLyBcXGxldFxcYmdyb3VwPXsgXFxsZXRcXGVncm91cD19XG5cbmRlZmluZU1hY3JvKFwiXFxcXGJncm91cFwiLCBcIntcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxlZ3JvdXBcIiwgXCJ9XCIpOyAvLyBTeW1ib2xzIGZyb20gbGF0ZXgubHR4OlxuLy8gXFxkZWZ+e1xcbm9icmVha3NwYWNle319XG4vLyBcXGRlZlxcbHF7YH1cbi8vIFxcZGVmXFxycXsnfVxuLy8gXFxkZWYgXFxhYSB7XFxyIGF9XG4vLyBcXGRlZiBcXEFBIHtcXHIgQX1cblxuZGVmaW5lTWFjcm8oXCJ+XCIsIFwiXFxcXG5vYnJlYWtzcGFjZVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGxxXCIsIFwiYFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHJxXCIsIFwiJ1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGFhXCIsIFwiXFxcXHIgYVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXEFBXCIsIFwiXFxcXHIgQVwiKTsgLy8gQ29weXJpZ2h0IChDKSBhbmQgcmVnaXN0ZXJlZCAoUikgc3ltYm9scy4gVXNlIHJhdyBzeW1ib2wgaW4gTWF0aE1MLlxuLy8gXFxEZWNsYXJlVGV4dENvbW1hbmREZWZhdWx0e1xcdGV4dGNvcHlyaWdodH17XFx0ZXh0Y2lyY2xlZHtjfX1cbi8vIFxcRGVjbGFyZVRleHRDb21tYW5kRGVmYXVsdHtcXHRleHRyZWdpc3RlcmVkfXtcXHRleHRjaXJjbGVkeyVcbi8vICAgICAgXFxjaGVja0BtYXRoZm9udHNcXGZvbnRzaXplXFxzZkBzaXplXFx6QFxcbWF0aEBmb250c2ZhbHNlXFxzZWxlY3Rmb250IFJ9fVxuLy8gXFxEZWNsYXJlUm9idXN0Q29tbWFuZHtcXGNvcHlyaWdodH17JVxuLy8gICAgXFxpZm1tb2Rle1xcbmZzc0B0ZXh0e1xcdGV4dGNvcHlyaWdodH19XFxlbHNlXFx0ZXh0Y29weXJpZ2h0XFxmaX1cblxuZGVmaW5lTWFjcm8oXCJcXFxcdGV4dGNvcHlyaWdodFwiLCBcIlxcXFxodG1sQG1hdGhtbHtcXFxcdGV4dGNpcmNsZWR7Y319e1xcXFxjaGFyYMKpfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGNvcHlyaWdodFwiLCBcIlxcXFxUZXh0T3JNYXRoe1xcXFx0ZXh0Y29weXJpZ2h0fXtcXFxcdGV4dHtcXFxcdGV4dGNvcHlyaWdodH19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdGV4dHJlZ2lzdGVyZWRcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXHRleHRjaXJjbGVke1xcXFxzY3JpcHRzaXplIFJ9fXtcXFxcY2hhcmDCrn1cIik7IC8vIENoYXJhY3RlcnMgb21pdHRlZCBmcm9tIFVuaWNvZGUgcmFuZ2UgMUQ0MDDigJMxRDdGRlxuXG5kZWZpbmVNYWNybyhcIlxcdTIxMkNcIiwgXCJcXFxcbWF0aHNjcntCfVwiKTsgLy8gc2NyaXB0XG5cbmRlZmluZU1hY3JvKFwiXFx1MjEzMFwiLCBcIlxcXFxtYXRoc2Nye0V9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyMTMxXCIsIFwiXFxcXG1hdGhzY3J7Rn1cIik7XG5kZWZpbmVNYWNybyhcIlxcdTIxMEJcIiwgXCJcXFxcbWF0aHNjcntIfVwiKTtcbmRlZmluZU1hY3JvKFwiXFx1MjExMFwiLCBcIlxcXFxtYXRoc2Nye0l9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyMTEyXCIsIFwiXFxcXG1hdGhzY3J7TH1cIik7XG5kZWZpbmVNYWNybyhcIlxcdTIxMzNcIiwgXCJcXFxcbWF0aHNjcntNfVwiKTtcbmRlZmluZU1hY3JvKFwiXFx1MjExQlwiLCBcIlxcXFxtYXRoc2Nye1J9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyMTJEXCIsIFwiXFxcXG1hdGhmcmFre0N9XCIpOyAvLyBGcmFrdHVyXG5cbmRlZmluZU1hY3JvKFwiXFx1MjEwQ1wiLCBcIlxcXFxtYXRoZnJha3tIfVwiKTtcbmRlZmluZU1hY3JvKFwiXFx1MjEyOFwiLCBcIlxcXFxtYXRoZnJha3tafVwiKTsgLy8gRGVmaW5lIFxcQmJiayB3aXRoIGEgbWFjcm8gdGhhdCB3b3JrcyBpbiBib3RoIEhUTUwgYW5kIE1hdGhNTC5cblxuZGVmaW5lTWFjcm8oXCJcXFxcQmJia1wiLCBcIlxcXFxCYmJ7a31cIik7IC8vIFVuaWNvZGUgbWlkZGxlIGRvdFxuLy8gVGhlIEthVGVYIGZvbnRzIGRvIG5vdCBjb250YWluIFUrMDBCNy4gSW5zdGVhZCwgXFxjZG90cCBkaXNwbGF5c1xuLy8gdGhlIGRvdCBhdCBVKzIyQzUgYW5kIGdpdmVzIGl0IHB1bmN0IHNwYWNpbmcuXG5cbmRlZmluZU1hY3JvKFwiXFx1MDBiN1wiLCBcIlxcXFxjZG90cFwiKTsgLy8gXFxsbGFwIGFuZCBcXHJsYXAgcmVuZGVyIHRoZWlyIGNvbnRlbnRzIGluIHRleHQgbW9kZVxuXG5kZWZpbmVNYWNybyhcIlxcXFxsbGFwXCIsIFwiXFxcXG1hdGhsbGFwe1xcXFx0ZXh0cm17IzF9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHJsYXBcIiwgXCJcXFxcbWF0aHJsYXB7XFxcXHRleHRybXsjMX19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcY2xhcFwiLCBcIlxcXFxtYXRoY2xhcHtcXFxcdGV4dHJteyMxfX1cIik7IC8vIFxcbWF0aHN0cnV0IGZyb20gdGhlIFRlWGJvb2ssIHAgMzYwXG5cbmRlZmluZU1hY3JvKFwiXFxcXG1hdGhzdHJ1dFwiLCBcIlxcXFx2cGhhbnRvbXsofVwiKTsgLy8gXFx1bmRlcmJhciBmcm9tIFRlWGJvb2sgcCAzNTNcblxuZGVmaW5lTWFjcm8oXCJcXFxcdW5kZXJiYXJcIiwgXCJcXFxcdW5kZXJsaW5le1xcXFx0ZXh0eyMxfX1cIik7IC8vIFxcbm90IGlzIGRlZmluZWQgYnkgYmFzZS9mb250bWF0aC5sdHggdmlhXG4vLyBcXERlY2xhcmVNYXRoU3ltYm9se1xcbm90fXtcXG1hdGhyZWx9e3N5bWJvbHN9e1wiMzZ9XG4vLyBJdCdzIHRodXMgdHJlYXRlZCBsaWtlIGEgXFxtYXRocmVsLCBidXQgZGVmaW5lZCBieSBhIHN5bWJvbCB0aGF0IGhhcyB6ZXJvXG4vLyB3aWR0aCBidXQgZXh0ZW5kcyB0byB0aGUgcmlnaHQuICBXZSB1c2UgXFxybGFwIHRvIGdldCB0aGF0IHNwYWNpbmcuXG4vLyBGb3IgTWF0aE1MIHdlIHdyaXRlIFUrMDMzOCBoZXJlLiBidWlsZE1hdGhNTC5qcyB3aWxsIHRoZW4gZG8gdGhlIG92ZXJsYXkuXG5cbmRlZmluZU1hY3JvKFwiXFxcXG5vdFwiLCAnXFxcXGh0bWxAbWF0aG1se1xcXFxtYXRocmVse1xcXFxtYXRocmxhcFxcXFxAbm90fX17XFxcXGNoYXJcIjMzOH0nKTsgLy8gTmVnYXRlZCBzeW1ib2xzIGZyb20gYmFzZS9mb250bWF0aC5sdHg6XG4vLyBcXGRlZlxcbmVxe1xcbm90PX0gXFxsZXRcXG5lPVxcbmVxXG4vLyBcXERlY2xhcmVSb2J1c3RDb21tYW5kXG4vLyAgIFxcbm90aW57XFxtYXRocmVse1xcbUB0aFxcbWF0aHBhbGV0dGVcXGNAbmNlbFxcaW59fVxuLy8gXFxkZWZcXGNAbmNlbCMxIzJ7XFxtQHRoXFxvb2FsaWdueyRcXGhmaWwjMVxcbWtlcm4xbXUvXFxoZmlsJFxcY3JjciQjMSMyJH19XG5cbmRlZmluZU1hY3JvKFwiXFxcXG5lcVwiLCBcIlxcXFxodG1sQG1hdGhtbHtcXFxcbWF0aHJlbHtcXFxcbm90PX19e1xcXFxtYXRocmVse1xcXFxjaGFyYOKJoH19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbmVcIiwgXCJcXFxcbmVxXCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyMjYwXCIsIFwiXFxcXG5lcVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG5vdGluXCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxtYXRocmVse3tcXFxcaW59XFxcXG1hdGhsbGFwey9cXFxcbXNraXAxbXV9fX1cIiArIFwie1xcXFxtYXRocmVse1xcXFxjaGFyYOKIiX19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyMjA5XCIsIFwiXFxcXG5vdGluXCIpOyAvLyBVbmljb2RlIHN0YWNrZWQgcmVsYXRpb25zXG5cbmRlZmluZU1hY3JvKFwiXFx1MjI1OFwiLCBcIlxcXFxodG1sQG1hdGhtbHtcIiArIFwiXFxcXG1hdGhyZWx7PVxcXFxrZXJuey0xZW19XFxcXHJhaXNlYm94ezAuNGVtfXskXFxcXHNjcmlwdHNpemVcXFxcZnJvd24kfX1cIiArIFwifXtcXFxcbWF0aHJlbHtcXFxcY2hhcmBcXHUyMjU4fX1cIik7XG5kZWZpbmVNYWNybyhcIlxcdTIyNTlcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXHN0YWNrcmVse1xcXFx0aW55XFxcXHdlZGdlfXs9fX17XFxcXG1hdGhyZWx7XFxcXGNoYXJgXFx1MjI1OH19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyMjVBXCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxzdGFja3JlbHtcXFxcdGlueVxcXFx2ZWV9ez19fXtcXFxcbWF0aHJlbHtcXFxcY2hhcmBcXHUyMjVBfX1cIik7XG5kZWZpbmVNYWNybyhcIlxcdTIyNUJcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXHN0YWNrcmVse1xcXFxzY3JpcHRzaXplXFxcXHN0YXJ9ez19fVwiICsgXCJ7XFxcXG1hdGhyZWx7XFxcXGNoYXJgXFx1MjI1Qn19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyMjVEXCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxzdGFja3JlbHtcXFxcdGlueVxcXFxtYXRocm17ZGVmfX17PX19XCIgKyBcIntcXFxcbWF0aHJlbHtcXFxcY2hhcmBcXHUyMjVEfX1cIik7XG5kZWZpbmVNYWNybyhcIlxcdTIyNUVcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXHN0YWNrcmVse1xcXFx0aW55XFxcXG1hdGhybXttfX17PX19XCIgKyBcIntcXFxcbWF0aHJlbHtcXFxcY2hhcmBcXHUyMjVFfX1cIik7XG5kZWZpbmVNYWNybyhcIlxcdTIyNUZcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXHN0YWNrcmVse1xcXFx0aW55P317PX19e1xcXFxtYXRocmVse1xcXFxjaGFyYFxcdTIyNUZ9fVwiKTsgLy8gTWlzYyBVbmljb2RlXG5cbmRlZmluZU1hY3JvKFwiXFx1MjdDMlwiLCBcIlxcXFxwZXJwXCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyMDNDXCIsIFwiXFxcXG1hdGhjbG9zZXshXFxcXG1rZXJuLTAuOG11IX1cIik7XG5kZWZpbmVNYWNybyhcIlxcdTIyMENcIiwgXCJcXFxcbm90bmlcIik7XG5kZWZpbmVNYWNybyhcIlxcdTIzMUNcIiwgXCJcXFxcdWxjb3JuZXJcIik7XG5kZWZpbmVNYWNybyhcIlxcdTIzMURcIiwgXCJcXFxcdXJjb3JuZXJcIik7XG5kZWZpbmVNYWNybyhcIlxcdTIzMUVcIiwgXCJcXFxcbGxjb3JuZXJcIik7XG5kZWZpbmVNYWNybyhcIlxcdTIzMUZcIiwgXCJcXFxcbHJjb3JuZXJcIik7XG5kZWZpbmVNYWNybyhcIlxcdTAwQTlcIiwgXCJcXFxcY29weXJpZ2h0XCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUwMEFFXCIsIFwiXFxcXHRleHRyZWdpc3RlcmVkXCIpO1xuZGVmaW5lTWFjcm8oXCJcXHVGRTBGXCIsIFwiXFxcXHRleHRyZWdpc3RlcmVkXCIpOyAvLyBUaGUgS2FUZVggZm9udHMgaGF2ZSBjb3JuZXJzIGF0IGNvZGVwb2ludHMgdGhhdCBkb24ndCBtYXRjaCBVbmljb2RlLlxuLy8gRm9yIE1hdGhNTCBwdXJwb3NlcywgdXNlIHRoZSBVbmljb2RlIGNvZGUgcG9pbnQuXG5cbmRlZmluZU1hY3JvKFwiXFxcXHVsY29ybmVyXCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxAdWxjb3JuZXJ9e1xcXFxtYXRob3B7XFxcXGNoYXJcXFwiMjMxY319XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdXJjb3JuZXJcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXEB1cmNvcm5lcn17XFxcXG1hdGhvcHtcXFxcY2hhclxcXCIyMzFkfX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxsbGNvcm5lclwiLCBcIlxcXFxodG1sQG1hdGhtbHtcXFxcQGxsY29ybmVyfXtcXFxcbWF0aG9we1xcXFxjaGFyXFxcIjIzMWV9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGxyY29ybmVyXCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxAbHJjb3JuZXJ9e1xcXFxtYXRob3B7XFxcXGNoYXJcXFwiMjMxZn19XCIpOyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBMYVRlWF8yzrVcbi8vIFxcdmRvdHN7XFx2Ym94e1xcYmFzZWxpbmVza2lwNFxccEAgIFxcbGluZXNraXBsaW1pdFxcekBcbi8vIFxca2VybjZcXHBAXFxoYm94ey59XFxoYm94ey59XFxoYm94ey59fX1cbi8vIFdlJ2xsIGNhbGwgXFx2YXJ2ZG90cywgd2hpY2ggZ2V0cyBhIGdseXBoIGZyb20gc3ltYm9scy5qcy5cbi8vIFRoZSB6ZXJvLXdpZHRoIHJ1bGUgZ2V0cyB1cyBhbiBlcXVpdmFsZW50IHRvIHRoZSB2ZXJ0aWNhbCA2cHQga2Vybi5cblxuZGVmaW5lTWFjcm8oXCJcXFxcdmRvdHNcIiwgXCJcXFxcbWF0aG9yZHtcXFxcdmFydmRvdHNcXFxccnVsZXswcHR9ezE1cHR9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFx1MjJlZVwiLCBcIlxcXFx2ZG90c1wiKTsgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gYW1zbWF0aC5zdHlcbi8vIGh0dHA6Ly9taXJyb3JzLmNvbmNlcnRwYXNzLmNvbS90ZXgtYXJjaGl2ZS9tYWNyb3MvbGF0ZXgvcmVxdWlyZWQvYW1zbWF0aC9hbXNtYXRoLnBkZlxuLy8gSXRhbGljIEdyZWVrIGNhcGl0YWwgbGV0dGVycy4gIEFNUyBkZWZpbmVzIHRoZXNlIHdpdGggXFxEZWNsYXJlTWF0aFN5bWJvbCxcbi8vIGJ1dCB0aGV5IGFyZSBlcXVpdmFsZW50IHRvIFxcbWF0aGl0e1xcTGV0dGVyfS5cblxuZGVmaW5lTWFjcm8oXCJcXFxcdmFyR2FtbWFcIiwgXCJcXFxcbWF0aGl0e1xcXFxHYW1tYX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx2YXJEZWx0YVwiLCBcIlxcXFxtYXRoaXR7XFxcXERlbHRhfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHZhclRoZXRhXCIsIFwiXFxcXG1hdGhpdHtcXFxcVGhldGF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdmFyTGFtYmRhXCIsIFwiXFxcXG1hdGhpdHtcXFxcTGFtYmRhfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHZhclhpXCIsIFwiXFxcXG1hdGhpdHtcXFxcWGl9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdmFyUGlcIiwgXCJcXFxcbWF0aGl0e1xcXFxQaX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx2YXJTaWdtYVwiLCBcIlxcXFxtYXRoaXR7XFxcXFNpZ21hfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHZhclVwc2lsb25cIiwgXCJcXFxcbWF0aGl0e1xcXFxVcHNpbG9ufVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHZhclBoaVwiLCBcIlxcXFxtYXRoaXR7XFxcXFBoaX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx2YXJQc2lcIiwgXCJcXFxcbWF0aGl0e1xcXFxQc2l9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdmFyT21lZ2FcIiwgXCJcXFxcbWF0aGl0e1xcXFxPbWVnYX1cIik7IC8vXFxuZXdjb21tYW5ke1xcc3Vic3RhY2t9WzFde1xcc3ViYXJyYXl7Y30jMVxcZW5kc3ViYXJyYXl9XG5cbmRlZmluZU1hY3JvKFwiXFxcXHN1YnN0YWNrXCIsIFwiXFxcXGJlZ2lue3N1YmFycmF5fXtjfSMxXFxcXGVuZHtzdWJhcnJheX1cIik7IC8vIFxccmVuZXdjb21tYW5ke1xcY29sb259e1xcbm9icmVha1xcbXNraXAybXVcXG1hdGhwdW5jdHt9XFxub25zY3JpcHRcbi8vIFxcbWtlcm4tXFx0aGlubXVza2lwezp9XFxtc2tpcDZtdXBsdXMxbXVcXHJlbGF4fVxuXG5kZWZpbmVNYWNybyhcIlxcXFxjb2xvblwiLCBcIlxcXFxub2JyZWFrXFxcXG1za2lwMm11XFxcXG1hdGhwdW5jdHt9XCIgKyBcIlxcXFxtYXRoY2hvaWNle1xcXFxta2Vybi0zbXV9e1xcXFxta2Vybi0zbXV9e317fXs6fVxcXFxtc2tpcDZtdVxcXFxyZWxheFwiKTsgLy8gXFxuZXdjb21tYW5ke1xcYm94ZWR9WzFde1xcZmJveHtcXG1AdGgkXFxkaXNwbGF5c3R5bGUjMSR9fVxuXG5kZWZpbmVNYWNybyhcIlxcXFxib3hlZFwiLCBcIlxcXFxmYm94eyRcXFxcZGlzcGxheXN0eWxleyMxfSR9XCIpOyAvLyBcXGRlZlxcaWZme1xcRE9UU0JcXDtcXExvbmdsZWZ0cmlnaHRhcnJvd1xcO31cbi8vIFxcZGVmXFxpbXBsaWVze1xcRE9UU0JcXDtcXExvbmdyaWdodGFycm93XFw7fVxuLy8gXFxkZWZcXGltcGxpZWRieXtcXERPVFNCXFw7XFxMb25nbGVmdGFycm93XFw7fVxuXG5kZWZpbmVNYWNybyhcIlxcXFxpZmZcIiwgXCJcXFxcRE9UU0JcXFxcO1xcXFxMb25nbGVmdHJpZ2h0YXJyb3dcXFxcO1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGltcGxpZXNcIiwgXCJcXFxcRE9UU0JcXFxcO1xcXFxMb25ncmlnaHRhcnJvd1xcXFw7XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcaW1wbGllZGJ5XCIsIFwiXFxcXERPVFNCXFxcXDtcXFxcTG9uZ2xlZnRhcnJvd1xcXFw7XCIpOyAvLyBBTVNNYXRoJ3MgYXV0b21hdGljIFxcZG90cywgYmFzZWQgb24gXFxtZG90c0BAIG1hY3JvLlxuXG5jb25zdCBkb3RzQnlUb2tlbiA9IHtcbiAgJywnOiAnXFxcXGRvdHNjJyxcbiAgJ1xcXFxub3QnOiAnXFxcXGRvdHNiJyxcbiAgLy8gXFxrZXliaW5AIGNoZWNrcyBmb3IgdGhlIGZvbGxvd2luZzpcbiAgJysnOiAnXFxcXGRvdHNiJyxcbiAgJz0nOiAnXFxcXGRvdHNiJyxcbiAgJzwnOiAnXFxcXGRvdHNiJyxcbiAgJz4nOiAnXFxcXGRvdHNiJyxcbiAgJy0nOiAnXFxcXGRvdHNiJyxcbiAgJyonOiAnXFxcXGRvdHNiJyxcbiAgJzonOiAnXFxcXGRvdHNiJyxcbiAgLy8gU3ltYm9scyB3aG9zZSBkZWZpbml0aW9uIHN0YXJ0cyB3aXRoIFxcRE9UU0I6XG4gICdcXFxcRE9UU0InOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFxjb3Byb2QnOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFxiaWd2ZWUnOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFxiaWd3ZWRnZSc6ICdcXFxcZG90c2InLFxuICAnXFxcXGJpZ3VwbHVzJzogJ1xcXFxkb3RzYicsXG4gICdcXFxcYmlnY2FwJzogJ1xcXFxkb3RzYicsXG4gICdcXFxcYmlnY3VwJzogJ1xcXFxkb3RzYicsXG4gICdcXFxccHJvZCc6ICdcXFxcZG90c2InLFxuICAnXFxcXHN1bSc6ICdcXFxcZG90c2InLFxuICAnXFxcXGJpZ290aW1lcyc6ICdcXFxcZG90c2InLFxuICAnXFxcXGJpZ29wbHVzJzogJ1xcXFxkb3RzYicsXG4gICdcXFxcYmlnb2RvdCc6ICdcXFxcZG90c2InLFxuICAnXFxcXGJpZ3NxY3VwJzogJ1xcXFxkb3RzYicsXG4gICdcXFxcQW5kJzogJ1xcXFxkb3RzYicsXG4gICdcXFxcbG9uZ3JpZ2h0YXJyb3cnOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFxMb25ncmlnaHRhcnJvdyc6ICdcXFxcZG90c2InLFxuICAnXFxcXGxvbmdsZWZ0YXJyb3cnOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFxMb25nbGVmdGFycm93JzogJ1xcXFxkb3RzYicsXG4gICdcXFxcbG9uZ2xlZnRyaWdodGFycm93JzogJ1xcXFxkb3RzYicsXG4gICdcXFxcTG9uZ2xlZnRyaWdodGFycm93JzogJ1xcXFxkb3RzYicsXG4gICdcXFxcbWFwc3RvJzogJ1xcXFxkb3RzYicsXG4gICdcXFxcbG9uZ21hcHN0byc6ICdcXFxcZG90c2InLFxuICAnXFxcXGhvb2tyaWdodGFycm93JzogJ1xcXFxkb3RzYicsXG4gICdcXFxcZG90ZXEnOiAnXFxcXGRvdHNiJyxcbiAgLy8gU3ltYm9scyB3aG9zZSBkZWZpbml0aW9uIHN0YXJ0cyB3aXRoIFxcbWF0aGJpbjpcbiAgJ1xcXFxtYXRoYmluJzogJ1xcXFxkb3RzYicsXG4gIC8vIFN5bWJvbHMgd2hvc2UgZGVmaW5pdGlvbiBzdGFydHMgd2l0aCBcXG1hdGhyZWw6XG4gICdcXFxcbWF0aHJlbCc6ICdcXFxcZG90c2InLFxuICAnXFxcXHJlbGJhcic6ICdcXFxcZG90c2InLFxuICAnXFxcXFJlbGJhcic6ICdcXFxcZG90c2InLFxuICAnXFxcXHhyaWdodGFycm93JzogJ1xcXFxkb3RzYicsXG4gICdcXFxceGxlZnRhcnJvdyc6ICdcXFxcZG90c2InLFxuICAvLyBTeW1ib2xzIHdob3NlIGRlZmluaXRpb24gc3RhcnRzIHdpdGggXFxET1RTSTpcbiAgJ1xcXFxET1RTSSc6ICdcXFxcZG90c2knLFxuICAnXFxcXGludCc6ICdcXFxcZG90c2knLFxuICAnXFxcXG9pbnQnOiAnXFxcXGRvdHNpJyxcbiAgJ1xcXFxpaW50JzogJ1xcXFxkb3RzaScsXG4gICdcXFxcaWlpbnQnOiAnXFxcXGRvdHNpJyxcbiAgJ1xcXFxpaWlpbnQnOiAnXFxcXGRvdHNpJyxcbiAgJ1xcXFxpZG90c2ludCc6ICdcXFxcZG90c2knLFxuICAvLyBTeW1ib2xzIHdob3NlIGRlZmluaXRpb24gc3RhcnRzIHdpdGggXFxET1RTWDpcbiAgJ1xcXFxET1RTWCc6ICdcXFxcZG90c3gnXG59O1xuZGVmaW5lTWFjcm8oXCJcXFxcZG90c1wiLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICAvLyBUT0RPOiBJZiB1c2VkIGluIHRleHQgbW9kZSwgc2hvdWxkIGV4cGFuZCB0byBcXHRleHRlbGxpcHNpcy5cbiAgLy8gSG93ZXZlciwgaW4gS2FUZVgsIFxcdGV4dGVsbGlwc2lzIGFuZCBcXGxkb3RzIGJlaGF2ZSB0aGUgc2FtZVxuICAvLyAoaW4gdGV4dCBtb2RlKSwgYW5kIGl0J3MgdW5saWtlbHkgd2UnZCBzZWUgYW55IG9mIHRoZSBtYXRoIGNvbW1hbmRzXG4gIC8vIHRoYXQgYWZmZWN0IHRoZSBiZWhhdmlvciBvZiBcXGRvdHMgd2hlbiBpbiB0ZXh0IG1vZGUuICBTbyBmaW5lIGZvciBub3dcbiAgLy8gKHVudGlsIHdlIHN1cHBvcnQgXFxpZm1tb2RlIC4uLiBcXGVsc2UgLi4uIFxcZmkpLlxuICBsZXQgdGhlZG90cyA9ICdcXFxcZG90c28nO1xuICBjb25zdCBuZXh0ID0gY29udGV4dC5leHBhbmRBZnRlckZ1dHVyZSgpLnRleHQ7XG5cbiAgaWYgKG5leHQgaW4gZG90c0J5VG9rZW4pIHtcbiAgICB0aGVkb3RzID0gZG90c0J5VG9rZW5bbmV4dF07XG4gIH0gZWxzZSBpZiAobmV4dC5zbGljZSgwLCA0KSA9PT0gJ1xcXFxub3QnKSB7XG4gICAgdGhlZG90cyA9ICdcXFxcZG90c2InO1xuICB9IGVsc2UgaWYgKG5leHQgaW4gc3JjX3N5bWJvbHMubWF0aCkge1xuICAgIGlmICh1dGlscy5jb250YWlucyhbJ2JpbicsICdyZWwnXSwgc3JjX3N5bWJvbHMubWF0aFtuZXh0XS5ncm91cCkpIHtcbiAgICAgIHRoZWRvdHMgPSAnXFxcXGRvdHNiJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhlZG90cztcbn0pO1xuY29uc3Qgc3BhY2VBZnRlckRvdHMgPSB7XG4gIC8vIFxccmlnaHRkZWxpbUAgY2hlY2tzIGZvciB0aGUgZm9sbG93aW5nOlxuICAnKSc6IHRydWUsXG4gICddJzogdHJ1ZSxcbiAgJ1xcXFxyYnJhY2snOiB0cnVlLFxuICAnXFxcXH0nOiB0cnVlLFxuICAnXFxcXHJicmFjZSc6IHRydWUsXG4gICdcXFxccmFuZ2xlJzogdHJ1ZSxcbiAgJ1xcXFxyY2VpbCc6IHRydWUsXG4gICdcXFxccmZsb29yJzogdHJ1ZSxcbiAgJ1xcXFxyZ3JvdXAnOiB0cnVlLFxuICAnXFxcXHJtb3VzdGFjaGUnOiB0cnVlLFxuICAnXFxcXHJpZ2h0JzogdHJ1ZSxcbiAgJ1xcXFxiaWdyJzogdHJ1ZSxcbiAgJ1xcXFxiaWdncic6IHRydWUsXG4gICdcXFxcQmlncic6IHRydWUsXG4gICdcXFxcQmlnZ3InOiB0cnVlLFxuICAvLyBcXGV4dHJhQCBhbHNvIHRlc3RzIGZvciB0aGUgZm9sbG93aW5nOlxuICAnJCc6IHRydWUsXG4gIC8vIFxcZXh0cmFwQCBjaGVja3MgZm9yIHRoZSBmb2xsb3dpbmc6XG4gICc7JzogdHJ1ZSxcbiAgJy4nOiB0cnVlLFxuICAnLCc6IHRydWVcbn07XG5kZWZpbmVNYWNybyhcIlxcXFxkb3Rzb1wiLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICBjb25zdCBuZXh0ID0gY29udGV4dC5mdXR1cmUoKS50ZXh0O1xuXG4gIGlmIChuZXh0IGluIHNwYWNlQWZ0ZXJEb3RzKSB7XG4gICAgcmV0dXJuIFwiXFxcXGxkb3RzXFxcXCxcIjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJcXFxcbGRvdHNcIjtcbiAgfVxufSk7XG5kZWZpbmVNYWNybyhcIlxcXFxkb3RzY1wiLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICBjb25zdCBuZXh0ID0gY29udGV4dC5mdXR1cmUoKS50ZXh0OyAvLyBcXGRvdHNjIHVzZXMgXFxleHRyYUAgYnV0IG5vdCBcXGV4dHJhcEAsIGluc3RlYWQgc3BlY2lhbGx5IGNoZWNraW5nIGZvclxuICAvLyAnOycgYW5kICcuJywgYnV0IGRvZXNuJ3QgY2hlY2sgZm9yICcsJy5cblxuICBpZiAobmV4dCBpbiBzcGFjZUFmdGVyRG90cyAmJiBuZXh0ICE9PSAnLCcpIHtcbiAgICByZXR1cm4gXCJcXFxcbGRvdHNcXFxcLFwiO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBcIlxcXFxsZG90c1wiO1xuICB9XG59KTtcbmRlZmluZU1hY3JvKFwiXFxcXGNkb3RzXCIsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gIGNvbnN0IG5leHQgPSBjb250ZXh0LmZ1dHVyZSgpLnRleHQ7XG5cbiAgaWYgKG5leHQgaW4gc3BhY2VBZnRlckRvdHMpIHtcbiAgICByZXR1cm4gXCJcXFxcQGNkb3RzXFxcXCxcIjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJcXFxcQGNkb3RzXCI7XG4gIH1cbn0pO1xuZGVmaW5lTWFjcm8oXCJcXFxcZG90c2JcIiwgXCJcXFxcY2RvdHNcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxkb3RzbVwiLCBcIlxcXFxjZG90c1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGRvdHNpXCIsIFwiXFxcXCFcXFxcY2RvdHNcIik7IC8vIGFtc21hdGggZG9lc24ndCBhY3R1YWxseSBkZWZpbmUgXFxkb3RzeCwgYnV0IFxcZG90cyBmb2xsb3dlZCBieSBhIG1hY3JvXG4vLyBzdGFydGluZyB3aXRoIFxcRE9UU1ggaW1wbGllcyBcXGRvdHNvLCBhbmQgdGhlbiBcXGV4dHJhQCBkZXRlY3RzIHRoaXMgY2FzZVxuLy8gYW5kIGZvcmNlcyB0aGUgYWRkZWQgYFxcLGAuXG5cbmRlZmluZU1hY3JvKFwiXFxcXGRvdHN4XCIsIFwiXFxcXGxkb3RzXFxcXCxcIik7IC8vIFxcbGV0XFxET1RTSVxccmVsYXhcbi8vIFxcbGV0XFxET1RTQlxccmVsYXhcbi8vIFxcbGV0XFxET1RTWFxccmVsYXhcblxuZGVmaW5lTWFjcm8oXCJcXFxcRE9UU0lcIiwgXCJcXFxccmVsYXhcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxET1RTQlwiLCBcIlxcXFxyZWxheFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXERPVFNYXCIsIFwiXFxcXHJlbGF4XCIpOyAvLyBTcGFjaW5nLCBiYXNlZCBvbiBhbXNtYXRoLnN0eSdzIG92ZXJyaWRlIG9mIExhVGVYIGRlZmF1bHRzXG4vLyBcXERlY2xhcmVSb2J1c3RDb21tYW5ke1xcdG1zcGFjZX1bM117JVxuLy8gICBcXGlmbW1vZGVcXG1za2lwIzEjMlxcZWxzZVxca2VybiMxIzNcXGZpXFxyZWxheH1cblxuZGVmaW5lTWFjcm8oXCJcXFxcdG1zcGFjZVwiLCBcIlxcXFxUZXh0T3JNYXRoe1xcXFxrZXJuIzEjM317XFxcXG1za2lwIzEjMn1cXFxccmVsYXhcIik7IC8vIFxccmVuZXdjb21tYW5ke1xcLH17XFx0bXNwYWNlK1xcdGhpbm11c2tpcHsuMTY2N2VtfX1cbi8vIFRPRE86IG1hdGggbW9kZSBzaG91bGQgdXNlIFxcdGhpbm11c2tpcFxuXG5kZWZpbmVNYWNybyhcIlxcXFwsXCIsIFwiXFxcXHRtc3BhY2UrezNtdX17LjE2NjdlbX1cIik7IC8vIFxcbGV0XFx0aGluc3BhY2VcXCxcblxuZGVmaW5lTWFjcm8oXCJcXFxcdGhpbnNwYWNlXCIsIFwiXFxcXCxcIik7IC8vIFxcZGVmXFw+e1xcbXNraXBcXG1lZG11c2tpcH1cbi8vIFxccmVuZXdjb21tYW5ke1xcOn17XFx0bXNwYWNlK1xcbWVkbXVza2lwey4yMjIyZW19fVxuLy8gVE9ETzogXFw+IGFuZCBtYXRoIG1vZGUgb2YgXFw6IHNob3VsZCB1c2UgXFxtZWRtdXNraXAgPSA0bXUgcGx1cyAybXUgbWludXMgNG11XG5cbmRlZmluZU1hY3JvKFwiXFxcXD5cIiwgXCJcXFxcbXNraXB7NG11fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXDpcIiwgXCJcXFxcdG1zcGFjZSt7NG11fXsuMjIyMmVtfVwiKTsgLy8gXFxsZXRcXG1lZHNwYWNlXFw6XG5cbmRlZmluZU1hY3JvKFwiXFxcXG1lZHNwYWNlXCIsIFwiXFxcXDpcIik7IC8vIFxccmVuZXdjb21tYW5ke1xcO317XFx0bXNwYWNlK1xcdGhpY2ttdXNraXB7LjI3NzdlbX19XG4vLyBUT0RPOiBtYXRoIG1vZGUgc2hvdWxkIHVzZSBcXHRoaWNrbXVza2lwID0gNW11IHBsdXMgNW11XG5cbmRlZmluZU1hY3JvKFwiXFxcXDtcIiwgXCJcXFxcdG1zcGFjZSt7NW11fXsuMjc3N2VtfVwiKTsgLy8gXFxsZXRcXHRoaWNrc3BhY2VcXDtcblxuZGVmaW5lTWFjcm8oXCJcXFxcdGhpY2tzcGFjZVwiLCBcIlxcXFw7XCIpOyAvLyBcXHJlbmV3Y29tbWFuZHtcXCF9e1xcdG1zcGFjZS1cXHRoaW5tdXNraXB7LjE2NjdlbX19XG4vLyBUT0RPOiBtYXRoIG1vZGUgc2hvdWxkIHVzZSBcXHRoaW5tdXNraXBcblxuZGVmaW5lTWFjcm8oXCJcXFxcIVwiLCBcIlxcXFx0bXNwYWNlLXszbXV9ey4xNjY3ZW19XCIpOyAvLyBcXGxldFxcbmVndGhpbnNwYWNlXFwhXG5cbmRlZmluZU1hY3JvKFwiXFxcXG5lZ3RoaW5zcGFjZVwiLCBcIlxcXFwhXCIpOyAvLyBcXG5ld2NvbW1hbmR7XFxuZWdtZWRzcGFjZX17XFx0bXNwYWNlLVxcbWVkbXVza2lwey4yMjIyZW19fVxuLy8gVE9ETzogbWF0aCBtb2RlIHNob3VsZCB1c2UgXFxtZWRtdXNraXBcblxuZGVmaW5lTWFjcm8oXCJcXFxcbmVnbWVkc3BhY2VcIiwgXCJcXFxcdG1zcGFjZS17NG11fXsuMjIyMmVtfVwiKTsgLy8gXFxuZXdjb21tYW5ke1xcbmVndGhpY2tzcGFjZX17XFx0bXNwYWNlLVxcdGhpY2ttdXNraXB7LjI3NzdlbX19XG4vLyBUT0RPOiBtYXRoIG1vZGUgc2hvdWxkIHVzZSBcXHRoaWNrbXVza2lwXG5cbmRlZmluZU1hY3JvKFwiXFxcXG5lZ3RoaWNrc3BhY2VcIiwgXCJcXFxcdG1zcGFjZS17NW11fXsuMjc3ZW19XCIpOyAvLyBcXGRlZlxcZW5zcGFjZXtcXGtlcm4uNWVtIH1cblxuZGVmaW5lTWFjcm8oXCJcXFxcZW5zcGFjZVwiLCBcIlxcXFxrZXJuLjVlbSBcIik7IC8vIFxcZGVmXFxlbnNraXB7XFxoc2tpcC41ZW1cXHJlbGF4fVxuXG5kZWZpbmVNYWNybyhcIlxcXFxlbnNraXBcIiwgXCJcXFxcaHNraXAuNWVtXFxcXHJlbGF4XCIpOyAvLyBcXGRlZlxccXVhZHtcXGhza2lwMWVtXFxyZWxheH1cblxuZGVmaW5lTWFjcm8oXCJcXFxccXVhZFwiLCBcIlxcXFxoc2tpcDFlbVxcXFxyZWxheFwiKTsgLy8gXFxkZWZcXHFxdWFke1xcaHNraXAyZW1cXHJlbGF4fVxuXG5kZWZpbmVNYWNybyhcIlxcXFxxcXVhZFwiLCBcIlxcXFxoc2tpcDJlbVxcXFxyZWxheFwiKTsgLy8gXFx0YWdAaW5AZGlzcGxheSBmb3JtIG9mIFxcdGFnXG5cbmRlZmluZU1hY3JvKFwiXFxcXHRhZ1wiLCBcIlxcXFxAaWZzdGFyXFxcXHRhZ0BsaXRlcmFsXFxcXHRhZ0BwYXJlblwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHRhZ0BwYXJlblwiLCBcIlxcXFx0YWdAbGl0ZXJhbHsoeyMxfSl9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdGFnQGxpdGVyYWxcIiwgY29udGV4dCA9PiB7XG4gIGlmIChjb250ZXh0Lm1hY3Jvcy5nZXQoXCJcXFxcZGZAdGFnXCIpKSB7XG4gICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiTXVsdGlwbGUgXFxcXHRhZ1wiKTtcbiAgfVxuXG4gIHJldHVybiBcIlxcXFxnZGVmXFxcXGRmQHRhZ3tcXFxcdGV4dHsjMX19XCI7XG59KTsgLy8gXFxyZW5ld2NvbW1hbmR7XFxibW9kfXtcXG5vbnNjcmlwdFxcbXNraXAtXFxtZWRtdXNraXBcXG1rZXJuNW11XFxtYXRoYmluXG4vLyAgIHtcXG9wZXJhdG9yQGZvbnQgbW9kfVxccGVuYWx0eTkwMFxuLy8gICBcXG1rZXJuNW11XFxub25zY3JpcHRcXG1za2lwLVxcbWVkbXVza2lwfVxuLy8gXFxuZXdjb21tYW5ke1xccG9kfVsxXXtcXGFsbG93YnJlYWtcbi8vICAgXFxpZkBkaXNwbGF5XFxta2VybjE4bXVcXGVsc2VcXG1rZXJuOG11XFxmaSgjMSl9XG4vLyBcXHJlbmV3Y29tbWFuZHtcXHBtb2R9WzFde1xccG9ke3tcXG9wZXJhdG9yQGZvbnQgbW9kfVxcbWtlcm42bXUjMX19XG4vLyBcXG5ld2NvbW1hbmR7XFxtb2R9WzFde1xcYWxsb3dicmVha1xcaWZAZGlzcGxheVxcbWtlcm4xOG11XG4vLyAgIFxcZWxzZVxcbWtlcm4xMm11XFxmaXtcXG9wZXJhdG9yQGZvbnQgbW9kfVxcLFxcLCMxfVxuLy8gVE9ETzogbWF0aCBtb2RlIHNob3VsZCB1c2UgXFxtZWRtdXNraXAgPSA0bXUgcGx1cyAybXUgbWludXMgNG11XG5cbmRlZmluZU1hY3JvKFwiXFxcXGJtb2RcIiwgXCJcXFxcbWF0aGNob2ljZXtcXFxcbXNraXAxbXV9e1xcXFxtc2tpcDFtdX17XFxcXG1za2lwNW11fXtcXFxcbXNraXA1bXV9XCIgKyBcIlxcXFxtYXRoYmlue1xcXFxybSBtb2R9XCIgKyBcIlxcXFxtYXRoY2hvaWNle1xcXFxtc2tpcDFtdX17XFxcXG1za2lwMW11fXtcXFxcbXNraXA1bXV9e1xcXFxtc2tpcDVtdX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxwb2RcIiwgXCJcXFxcYWxsb3dicmVha1wiICsgXCJcXFxcbWF0aGNob2ljZXtcXFxcbWtlcm4xOG11fXtcXFxcbWtlcm44bXV9e1xcXFxta2VybjhtdX17XFxcXG1rZXJuOG11fSgjMSlcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxwbW9kXCIsIFwiXFxcXHBvZHt7XFxcXHJtIG1vZH1cXFxcbWtlcm42bXUjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxtb2RcIiwgXCJcXFxcYWxsb3dicmVha1wiICsgXCJcXFxcbWF0aGNob2ljZXtcXFxcbWtlcm4xOG11fXtcXFxcbWtlcm4xMm11fXtcXFxcbWtlcm4xMm11fXtcXFxcbWtlcm4xMm11fVwiICsgXCJ7XFxcXHJtIG1vZH1cXFxcLFxcXFwsIzFcIik7IC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIExhVGVYIHNvdXJjZTJlXG4vLyBcXGV4cGFuZGFmdGVyXFxsZXRcXGV4cGFuZGFmdGVyXFxAbm9ybWFsY3Jcbi8vICAgICBcXGNzbmFtZVxcZXhwYW5kYWZ0ZXJcXEBnb2JibGVcXHN0cmluZ1xcXFwgXFxlbmRjc25hbWVcbi8vIFxcRGVjbGFyZVJvYnVzdENvbW1hbmRcXG5ld2xpbmV7XFxAbm9ybWFsY3JcXHJlbGF4fVxuXG5kZWZpbmVNYWNybyhcIlxcXFxuZXdsaW5lXCIsIFwiXFxcXFxcXFxcXFxccmVsYXhcIik7IC8vIFxcZGVmXFxUZVh7VFxca2Vybi0uMTY2N2VtXFxsb3dlci41ZXhcXGhib3h7RX1cXGtlcm4tLjEyNWVtWFxcQH1cbi8vIFRPRE86IERvZXNuJ3Qgbm9ybWFsbHkgd29yayBpbiBtYXRoIG1vZGUgYmVjYXVzZSBcXEAgZmFpbHMuICBLYVRlWCBkb2Vzbid0XG4vLyBzdXBwb3J0IFxcQCB5ZXQsIHNvIHRoYXQncyBvbWl0dGVkLCBhbmQgd2UgYWRkIFxcdGV4dCBzbyB0aGF0IHRoZSByZXN1bHRcbi8vIGRvZXNuJ3QgbG9vayBmdW5ueSBpbiBtYXRoIG1vZGUuXG5cbmRlZmluZU1hY3JvKFwiXFxcXFRlWFwiLCBcIlxcXFx0ZXh0cm17XFxcXGh0bWxAbWF0aG1se1wiICsgXCJUXFxcXGtlcm4tLjE2NjdlbVxcXFxyYWlzZWJveHstLjVleH17RX1cXFxca2Vybi0uMTI1ZW1YXCIgKyBcIn17VGVYfX1cIik7IC8vIFxcRGVjbGFyZVJvYnVzdENvbW1hbmR7XFxMYVRlWH17TFxca2Vybi0uMzZlbSVcbi8vICAgICAgICAge1xcc2JveFxcekAgVCVcbi8vICAgICAgICAgIFxcdmJveCB0b1xcaHRcXHpAe1xcaGJveHtcXGNoZWNrQG1hdGhmb250c1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxmb250c2l6ZVxcc2ZAc2l6ZVxcekBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcbWF0aEBmb250c2ZhbHNlXFxzZWxlY3Rmb250XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBfSVcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIFxcdnNzfSVcbi8vICAgICAgICAgfSVcbi8vICAgICAgICAgXFxrZXJuLS4xNWVtJVxuLy8gICAgICAgICBcXFRlWH1cbi8vIFRoaXMgY29kZSBhbGlnbnMgdGhlIHRvcCBvZiB0aGUgQSB3aXRoIHRoZSBUIChmcm9tIHRoZSBwZXJzcGVjdGl2ZSBvZiBUZVgnc1xuLy8gYm94ZXMsIHRob3VnaCB2aXN1YWxseSB0aGUgQSBhcHBlYXJzIHRvIGV4dGVuZCBhYm92ZSBzbGlnaHRseSkuXG4vLyBXZSBjb21wdXRlIHRoZSBjb3JyZXNwb25kaW5nIFxccmFpc2Vib3ggd2hlbiBBIGlzIHJlbmRlcmVkIGluIFxcbm9ybWFsc2l6ZVxuLy8gXFxzY3JpcHRzdHlsZSwgd2hpY2ggaGFzIGEgc2NhbGUgZmFjdG9yIG9mIDAuNyAoc2VlIE9wdGlvbnMuanMpLlxuXG5jb25zdCBsYXRleFJhaXNlQSA9IG1ha2VFbShmb250TWV0cmljc0RhdGFbXCJNYWluLVJlZ3VsYXJcIl1bXCJUXCIuY2hhckNvZGVBdCgwKV1bMV0gLSAwLjcgKiBmb250TWV0cmljc0RhdGFbXCJNYWluLVJlZ3VsYXJcIl1bXCJBXCIuY2hhckNvZGVBdCgwKV1bMV0pO1xuZGVmaW5lTWFjcm8oXCJcXFxcTGFUZVhcIiwgXCJcXFxcdGV4dHJte1xcXFxodG1sQG1hdGhtbHtcIiArIChcIkxcXFxca2Vybi0uMzZlbVxcXFxyYWlzZWJveHtcIiArIGxhdGV4UmFpc2VBICsgXCJ9e1xcXFxzY3JpcHRzdHlsZSBBfVwiKSArIFwiXFxcXGtlcm4tLjE1ZW1cXFxcVGVYfXtMYVRlWH19XCIpOyAvLyBOZXcgS2FUZVggbG9nbyBiYXNlZCBvbiB0d2Vha2luZyBMYVRlWCBsb2dvXG5cbmRlZmluZU1hY3JvKFwiXFxcXEthVGVYXCIsIFwiXFxcXHRleHRybXtcXFxcaHRtbEBtYXRobWx7XCIgKyAoXCJLXFxcXGtlcm4tLjE3ZW1cXFxccmFpc2Vib3h7XCIgKyBsYXRleFJhaXNlQSArIFwifXtcXFxcc2NyaXB0c3R5bGUgQX1cIikgKyBcIlxcXFxrZXJuLS4xNWVtXFxcXFRlWH17S2FUZVh9fVwiKTsgLy8gXFxEZWNsYXJlUm9idXN0Q29tbWFuZFxcaHNwYWNle1xcQGlmc3RhclxcQGhzcGFjZXJcXEBoc3BhY2V9XG4vLyBcXGRlZlxcQGhzcGFjZSMxe1xcaHNraXAgICMxXFxyZWxheH1cbi8vIFxcZGVmXFxAaHNwYWNlciMxe1xcdnJ1bGUgXFxAd2lkdGhcXHpAXFxub2JyZWFrXG4vLyAgICAgICAgICAgICAgICAgXFxoc2tpcCAjMVxcaHNraXAgXFx6QHNraXB9XG5cbmRlZmluZU1hY3JvKFwiXFxcXGhzcGFjZVwiLCBcIlxcXFxAaWZzdGFyXFxcXEBoc3BhY2VyXFxcXEBoc3BhY2VcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxAaHNwYWNlXCIsIFwiXFxcXGhza2lwICMxXFxcXHJlbGF4XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcQGhzcGFjZXJcIiwgXCJcXFxccnVsZXswcHR9ezBwdH1cXFxcaHNraXAgIzFcXFxccmVsYXhcIik7IC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIG1hdGh0b29scy5zdHlcbi8vXFxwcm92aWRlY29tbWFuZFxcb3JkaW5hcnljb2xvbns6fVxuXG5kZWZpbmVNYWNybyhcIlxcXFxvcmRpbmFyeWNvbG9uXCIsIFwiOlwiKTsgLy9cXGRlZlxcdmNlbnRjb2xvbntcXG1hdGhyZWx7XFxtYXRob3BcXG9yZGluYXJ5Y29sb259fVxuLy9UT0RPKGVkZW1haW5lKTogTm90IHlldCBjZW50ZXJlZC4gRml4IHZpYSBcXHJhaXNlYm94IG9yICM3MjZcblxuZGVmaW5lTWFjcm8oXCJcXFxcdmNlbnRjb2xvblwiLCBcIlxcXFxtYXRocmVse1xcXFxtYXRob3BcXFxcb3JkaW5hcnljb2xvbn1cIik7IC8vIFxccHJvdmlkZWNvbW1hbmQqXFxkYmxjb2xvbntcXHZjZW50Y29sb25cXG1hdGhyZWx7XFxta2Vybi0uOW11fVxcdmNlbnRjb2xvbn1cblxuZGVmaW5lTWFjcm8oXCJcXFxcZGJsY29sb25cIiwgXCJcXFxcaHRtbEBtYXRobWx7XCIgKyBcIlxcXFxtYXRocmVse1xcXFx2Y2VudGNvbG9uXFxcXG1hdGhyZWx7XFxcXG1rZXJuLS45bXV9XFxcXHZjZW50Y29sb259fVwiICsgXCJ7XFxcXG1hdGhvcHtcXFxcY2hhclxcXCIyMjM3fX1cIik7IC8vIFxccHJvdmlkZWNvbW1hbmQqXFxjb2xvbmVxcXtcXHZjZW50Y29sb25cXG1hdGhyZWx7XFxta2Vybi0xLjJtdX09fVxuXG5kZWZpbmVNYWNybyhcIlxcXFxjb2xvbmVxcVwiLCBcIlxcXFxodG1sQG1hdGhtbHtcIiArIFwiXFxcXG1hdGhyZWx7XFxcXHZjZW50Y29sb25cXFxcbWF0aHJlbHtcXFxcbWtlcm4tMS4ybXV9PX19XCIgKyBcIntcXFxcbWF0aG9we1xcXFxjaGFyXFxcIjIyNTR9fVwiKTsgLy8g4omUXG4vLyBcXHByb3ZpZGVjb21tYW5kKlxcQ29sb25lcXF7XFxkYmxjb2xvblxcbWF0aHJlbHtcXG1rZXJuLTEuMm11fT19XG5cbmRlZmluZU1hY3JvKFwiXFxcXENvbG9uZXFxXCIsIFwiXFxcXGh0bWxAbWF0aG1se1wiICsgXCJcXFxcbWF0aHJlbHtcXFxcZGJsY29sb25cXFxcbWF0aHJlbHtcXFxcbWtlcm4tMS4ybXV9PX19XCIgKyBcIntcXFxcbWF0aG9we1xcXFxjaGFyXFxcIjIyMzdcXFxcY2hhclxcXCIzZH19XCIpOyAvLyBcXHByb3ZpZGVjb21tYW5kKlxcY29sb25lcXtcXHZjZW50Y29sb25cXG1hdGhyZWx7XFxta2Vybi0xLjJtdX1cXG1hdGhyZWx7LX19XG5cbmRlZmluZU1hY3JvKFwiXFxcXGNvbG9uZXFcIiwgXCJcXFxcaHRtbEBtYXRobWx7XCIgKyBcIlxcXFxtYXRocmVse1xcXFx2Y2VudGNvbG9uXFxcXG1hdGhyZWx7XFxcXG1rZXJuLTEuMm11fVxcXFxtYXRocmVsey19fX1cIiArIFwie1xcXFxtYXRob3B7XFxcXGNoYXJcXFwiM2FcXFxcY2hhclxcXCIyMjEyfX1cIik7IC8vIFxccHJvdmlkZWNvbW1hbmQqXFxDb2xvbmVxe1xcZGJsY29sb25cXG1hdGhyZWx7XFxta2Vybi0xLjJtdX1cXG1hdGhyZWx7LX19XG5cbmRlZmluZU1hY3JvKFwiXFxcXENvbG9uZXFcIiwgXCJcXFxcaHRtbEBtYXRobWx7XCIgKyBcIlxcXFxtYXRocmVse1xcXFxkYmxjb2xvblxcXFxtYXRocmVse1xcXFxta2Vybi0xLjJtdX1cXFxcbWF0aHJlbHstfX19XCIgKyBcIntcXFxcbWF0aG9we1xcXFxjaGFyXFxcIjIyMzdcXFxcY2hhclxcXCIyMjEyfX1cIik7IC8vIFxccHJvdmlkZWNvbW1hbmQqXFxlcXFjb2xvbns9XFxtYXRocmVse1xcbWtlcm4tMS4ybXV9XFx2Y2VudGNvbG9ufVxuXG5kZWZpbmVNYWNybyhcIlxcXFxlcXFjb2xvblwiLCBcIlxcXFxodG1sQG1hdGhtbHtcIiArIFwiXFxcXG1hdGhyZWx7PVxcXFxtYXRocmVse1xcXFxta2Vybi0xLjJtdX1cXFxcdmNlbnRjb2xvbn19XCIgKyBcIntcXFxcbWF0aG9we1xcXFxjaGFyXFxcIjIyNTV9fVwiKTsgLy8g4omVXG4vLyBcXHByb3ZpZGVjb21tYW5kKlxcRXFxY29sb257PVxcbWF0aHJlbHtcXG1rZXJuLTEuMm11fVxcZGJsY29sb259XG5cbmRlZmluZU1hY3JvKFwiXFxcXEVxcWNvbG9uXCIsIFwiXFxcXGh0bWxAbWF0aG1se1wiICsgXCJcXFxcbWF0aHJlbHs9XFxcXG1hdGhyZWx7XFxcXG1rZXJuLTEuMm11fVxcXFxkYmxjb2xvbn19XCIgKyBcIntcXFxcbWF0aG9we1xcXFxjaGFyXFxcIjNkXFxcXGNoYXJcXFwiMjIzN319XCIpOyAvLyBcXHByb3ZpZGVjb21tYW5kKlxcZXFjb2xvbntcXG1hdGhyZWx7LX1cXG1hdGhyZWx7XFxta2Vybi0xLjJtdX1cXHZjZW50Y29sb259XG5cbmRlZmluZU1hY3JvKFwiXFxcXGVxY29sb25cIiwgXCJcXFxcaHRtbEBtYXRobWx7XCIgKyBcIlxcXFxtYXRocmVse1xcXFxtYXRocmVsey19XFxcXG1hdGhyZWx7XFxcXG1rZXJuLTEuMm11fVxcXFx2Y2VudGNvbG9ufX1cIiArIFwie1xcXFxtYXRob3B7XFxcXGNoYXJcXFwiMjIzOX19XCIpOyAvLyBcXHByb3ZpZGVjb21tYW5kKlxcRXFjb2xvbntcXG1hdGhyZWx7LX1cXG1hdGhyZWx7XFxta2Vybi0xLjJtdX1cXGRibGNvbG9ufVxuXG5kZWZpbmVNYWNybyhcIlxcXFxFcWNvbG9uXCIsIFwiXFxcXGh0bWxAbWF0aG1se1wiICsgXCJcXFxcbWF0aHJlbHtcXFxcbWF0aHJlbHstfVxcXFxtYXRocmVse1xcXFxta2Vybi0xLjJtdX1cXFxcZGJsY29sb259fVwiICsgXCJ7XFxcXG1hdGhvcHtcXFxcY2hhclxcXCIyMjEyXFxcXGNoYXJcXFwiMjIzN319XCIpOyAvLyBcXHByb3ZpZGVjb21tYW5kKlxcY29sb25hcHByb3h7XFx2Y2VudGNvbG9uXFxtYXRocmVse1xcbWtlcm4tMS4ybXV9XFxhcHByb3h9XG5cbmRlZmluZU1hY3JvKFwiXFxcXGNvbG9uYXBwcm94XCIsIFwiXFxcXGh0bWxAbWF0aG1se1wiICsgXCJcXFxcbWF0aHJlbHtcXFxcdmNlbnRjb2xvblxcXFxtYXRocmVse1xcXFxta2Vybi0xLjJtdX1cXFxcYXBwcm94fX1cIiArIFwie1xcXFxtYXRob3B7XFxcXGNoYXJcXFwiM2FcXFxcY2hhclxcXCIyMjQ4fX1cIik7IC8vIFxccHJvdmlkZWNvbW1hbmQqXFxDb2xvbmFwcHJveHtcXGRibGNvbG9uXFxtYXRocmVse1xcbWtlcm4tMS4ybXV9XFxhcHByb3h9XG5cbmRlZmluZU1hY3JvKFwiXFxcXENvbG9uYXBwcm94XCIsIFwiXFxcXGh0bWxAbWF0aG1se1wiICsgXCJcXFxcbWF0aHJlbHtcXFxcZGJsY29sb25cXFxcbWF0aHJlbHtcXFxcbWtlcm4tMS4ybXV9XFxcXGFwcHJveH19XCIgKyBcIntcXFxcbWF0aG9we1xcXFxjaGFyXFxcIjIyMzdcXFxcY2hhclxcXCIyMjQ4fX1cIik7IC8vIFxccHJvdmlkZWNvbW1hbmQqXFxjb2xvbnNpbXtcXHZjZW50Y29sb25cXG1hdGhyZWx7XFxta2Vybi0xLjJtdX1cXHNpbX1cblxuZGVmaW5lTWFjcm8oXCJcXFxcY29sb25zaW1cIiwgXCJcXFxcaHRtbEBtYXRobWx7XCIgKyBcIlxcXFxtYXRocmVse1xcXFx2Y2VudGNvbG9uXFxcXG1hdGhyZWx7XFxcXG1rZXJuLTEuMm11fVxcXFxzaW19fVwiICsgXCJ7XFxcXG1hdGhvcHtcXFxcY2hhclxcXCIzYVxcXFxjaGFyXFxcIjIyM2N9fVwiKTsgLy8gXFxwcm92aWRlY29tbWFuZCpcXENvbG9uc2lte1xcZGJsY29sb25cXG1hdGhyZWx7XFxta2Vybi0xLjJtdX1cXHNpbX1cblxuZGVmaW5lTWFjcm8oXCJcXFxcQ29sb25zaW1cIiwgXCJcXFxcaHRtbEBtYXRobWx7XCIgKyBcIlxcXFxtYXRocmVse1xcXFxkYmxjb2xvblxcXFxtYXRocmVse1xcXFxta2Vybi0xLjJtdX1cXFxcc2ltfX1cIiArIFwie1xcXFxtYXRob3B7XFxcXGNoYXJcXFwiMjIzN1xcXFxjaGFyXFxcIjIyM2N9fVwiKTsgLy8gU29tZSBVbmljb2RlIGNoYXJhY3RlcnMgYXJlIGltcGxlbWVudGVkIHdpdGggbWFjcm9zIHRvIG1hdGh0b29scyBmdW5jdGlvbnMuXG5cbmRlZmluZU1hY3JvKFwiXFx1MjIzN1wiLCBcIlxcXFxkYmxjb2xvblwiKTsgLy8gOjpcblxuZGVmaW5lTWFjcm8oXCJcXHUyMjM5XCIsIFwiXFxcXGVxY29sb25cIik7IC8vIC06XG5cbmRlZmluZU1hY3JvKFwiXFx1MjI1NFwiLCBcIlxcXFxjb2xvbmVxcVwiKTsgLy8gOj1cblxuZGVmaW5lTWFjcm8oXCJcXHUyMjU1XCIsIFwiXFxcXGVxcWNvbG9uXCIpOyAvLyA9OlxuXG5kZWZpbmVNYWNybyhcIlxcdTJBNzRcIiwgXCJcXFxcQ29sb25lcXFcIik7IC8vIDo6PVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gY29sb25lcXVhbHMuc3R5XG4vLyBBbHRlcm5hdGUgbmFtZXMgZm9yIG1hdGh0b29scydzIG1hY3JvczpcblxuZGVmaW5lTWFjcm8oXCJcXFxccmF0aW9cIiwgXCJcXFxcdmNlbnRjb2xvblwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGNvbG9uY29sb25cIiwgXCJcXFxcZGJsY29sb25cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxjb2xvbmVxdWFsc1wiLCBcIlxcXFxjb2xvbmVxcVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGNvbG9uY29sb25lcXVhbHNcIiwgXCJcXFxcQ29sb25lcXFcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxlcXVhbHNjb2xvblwiLCBcIlxcXFxlcXFjb2xvblwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGVxdWFsc2NvbG9uY29sb25cIiwgXCJcXFxcRXFxY29sb25cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxjb2xvbm1pbnVzXCIsIFwiXFxcXGNvbG9uZXFcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxjb2xvbmNvbG9ubWludXNcIiwgXCJcXFxcQ29sb25lcVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG1pbnVzY29sb25cIiwgXCJcXFxcZXFjb2xvblwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG1pbnVzY29sb25jb2xvblwiLCBcIlxcXFxFcWNvbG9uXCIpOyAvLyBcXGNvbG9uYXBwcm94IG5hbWUgaXMgc2FtZSBpbiBtYXRodG9vbHMgYW5kIGNvbG9uZXF1YWxzLlxuXG5kZWZpbmVNYWNybyhcIlxcXFxjb2xvbmNvbG9uYXBwcm94XCIsIFwiXFxcXENvbG9uYXBwcm94XCIpOyAvLyBcXGNvbG9uc2ltIG5hbWUgaXMgc2FtZSBpbiBtYXRodG9vbHMgYW5kIGNvbG9uZXF1YWxzLlxuXG5kZWZpbmVNYWNybyhcIlxcXFxjb2xvbmNvbG9uc2ltXCIsIFwiXFxcXENvbG9uc2ltXCIpOyAvLyBBZGRpdGlvbmFsIG1hY3JvcywgaW1wbGVtZW50ZWQgYnkgYW5hbG9neSB3aXRoIG1hdGh0b29scyBkZWZpbml0aW9uczpcblxuZGVmaW5lTWFjcm8oXCJcXFxcc2ltY29sb25cIiwgXCJcXFxcbWF0aHJlbHtcXFxcc2ltXFxcXG1hdGhyZWx7XFxcXG1rZXJuLTEuMm11fVxcXFx2Y2VudGNvbG9ufVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHNpbWNvbG9uY29sb25cIiwgXCJcXFxcbWF0aHJlbHtcXFxcc2ltXFxcXG1hdGhyZWx7XFxcXG1rZXJuLTEuMm11fVxcXFxkYmxjb2xvbn1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxhcHByb3hjb2xvblwiLCBcIlxcXFxtYXRocmVse1xcXFxhcHByb3hcXFxcbWF0aHJlbHtcXFxcbWtlcm4tMS4ybXV9XFxcXHZjZW50Y29sb259XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcYXBwcm94Y29sb25jb2xvblwiLCBcIlxcXFxtYXRocmVse1xcXFxhcHByb3hcXFxcbWF0aHJlbHtcXFxcbWtlcm4tMS4ybXV9XFxcXGRibGNvbG9ufVwiKTsgLy8gUHJlc2VudCBpbiBuZXd0eG1hdGgsIHB4Zm9udHMgYW5kIHR4Zm9udHNcblxuZGVmaW5lTWFjcm8oXCJcXFxcbm90bmlcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXG5vdFxcXFxuaX17XFxcXG1hdGhyZWx7XFxcXGNoYXJgXFx1MjIwQ319XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbGltc3VwXCIsIFwiXFxcXERPVFNCXFxcXG9wZXJhdG9ybmFtZSp7bGltXFxcXCxzdXB9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbGltaW5mXCIsIFwiXFxcXERPVFNCXFxcXG9wZXJhdG9ybmFtZSp7bGltXFxcXCxpbmZ9XCIpOyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBGcm9tIGFtc29wbi5zdHlcblxuZGVmaW5lTWFjcm8oXCJcXFxcaW5qbGltXCIsIFwiXFxcXERPVFNCXFxcXG9wZXJhdG9ybmFtZSp7aW5qXFxcXCxsaW19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccHJvamxpbVwiLCBcIlxcXFxET1RTQlxcXFxvcGVyYXRvcm5hbWUqe3Byb2pcXFxcLGxpbX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx2YXJsaW1zdXBcIiwgXCJcXFxcRE9UU0JcXFxcb3BlcmF0b3JuYW1lKntcXFxcb3ZlcmxpbmV7bGltfX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx2YXJsaW1pbmZcIiwgXCJcXFxcRE9UU0JcXFxcb3BlcmF0b3JuYW1lKntcXFxcdW5kZXJsaW5le2xpbX19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdmFyaW5qbGltXCIsIFwiXFxcXERPVFNCXFxcXG9wZXJhdG9ybmFtZSp7XFxcXHVuZGVycmlnaHRhcnJvd3tsaW19fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHZhcnByb2psaW1cIiwgXCJcXFxcRE9UU0JcXFxcb3BlcmF0b3JuYW1lKntcXFxcdW5kZXJsZWZ0YXJyb3d7bGltfX1cIik7IC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIE1hdGhNTCBhbHRlcm5hdGVzIGZvciBLYVRlWCBnbHlwaHMgaW4gdGhlIFVuaWNvZGUgcHJpdmF0ZSBhcmVhXG5cbmRlZmluZU1hY3JvKFwiXFxcXGd2ZXJ0bmVxcVwiLCBcIlxcXFxodG1sQG1hdGhtbHtcXFxcQGd2ZXJ0bmVxcX17XFx1MjI2OX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxsdmVydG5lcXFcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXEBsdmVydG5lcXF9e1xcdTIyNjh9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbmdlcXFcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXEBuZ2VxcX17XFx1MjI3MX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxuZ2Vxc2xhbnRcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXEBuZ2Vxc2xhbnR9e1xcdTIyNzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbmxlcXFcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXEBubGVxcX17XFx1MjI3MH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxubGVxc2xhbnRcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXEBubGVxc2xhbnR9e1xcdTIyNzB9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbnNob3J0bWlkXCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxAbnNob3J0bWlkfXviiKR9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbnNob3J0cGFyYWxsZWxcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXEBuc2hvcnRwYXJhbGxlbH174oimfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG5zdWJzZXRlcXFcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXEBuc3Vic2V0ZXFxfXtcXHUyMjg4fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG5zdXBzZXRlcXFcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXEBuc3Vwc2V0ZXFxfXtcXHUyMjg5fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHZhcnN1YnNldG5lcVwiLCBcIlxcXFxodG1sQG1hdGhtbHtcXFxcQHZhcnN1YnNldG5lcX174oqKfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHZhcnN1YnNldG5lcXFcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXEB2YXJzdWJzZXRuZXFxfXviq4t9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdmFyc3Vwc2V0bmVxXCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxAdmFyc3Vwc2V0bmVxfXviiot9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdmFyc3Vwc2V0bmVxcVwiLCBcIlxcXFxodG1sQG1hdGhtbHtcXFxcQHZhcnN1cHNldG5lcXF9e+KrjH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxpbWF0aFwiLCBcIlxcXFxodG1sQG1hdGhtbHtcXFxcQGltYXRofXtcXHUwMTMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGptYXRoXCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxAam1hdGh9e1xcdTAyMzd9XCIpOyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBzdG1hcnlyZCBhbmQgc2VtYW50aWNcbi8vIFRoZSBzdG1hcnlyZCBhbmQgc2VtYW50aWMgcGFja2FnZXMgcmVuZGVyIHRoZSBuZXh0IGZvdXIgaXRlbXMgYnkgY2FsbGluZyBhXG4vLyBnbHlwaC4gVGhvc2UgZ2x5cGhzIGRvIG5vdCBleGlzdCBpbiB0aGUgS2FUZVggZm9udHMuIEhlbmNlIHRoZSBtYWNyb3MuXG5cbmRlZmluZU1hY3JvKFwiXFxcXGxsYnJhY2tldFwiLCBcIlxcXFxodG1sQG1hdGhtbHtcIiArIFwiXFxcXG1hdGhvcGVue1tcXFxcbWtlcm4tMy4ybXVbfX1cIiArIFwie1xcXFxtYXRob3BlbntcXFxcY2hhcmBcXHUyN2U2fX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxycmJyYWNrZXRcIiwgXCJcXFxcaHRtbEBtYXRobWx7XCIgKyBcIlxcXFxtYXRoY2xvc2V7XVxcXFxta2Vybi0zLjJtdV19fVwiICsgXCJ7XFxcXG1hdGhjbG9zZXtcXFxcY2hhcmBcXHUyN2U3fX1cIik7XG5kZWZpbmVNYWNybyhcIlxcdTI3ZTZcIiwgXCJcXFxcbGxicmFja2V0XCIpOyAvLyBibGFja2JvYXJkIGJvbGQgW1xuXG5kZWZpbmVNYWNybyhcIlxcdTI3ZTdcIiwgXCJcXFxccnJicmFja2V0XCIpOyAvLyBibGFja2JvYXJkIGJvbGQgXVxuXG5kZWZpbmVNYWNybyhcIlxcXFxsQnJhY2VcIiwgXCJcXFxcaHRtbEBtYXRobWx7XCIgKyBcIlxcXFxtYXRob3BlbntcXFxce1xcXFxta2Vybi0zLjJtdVt9fVwiICsgXCJ7XFxcXG1hdGhvcGVue1xcXFxjaGFyYFxcdTI5ODN9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHJCcmFjZVwiLCBcIlxcXFxodG1sQG1hdGhtbHtcIiArIFwiXFxcXG1hdGhjbG9zZXtdXFxcXG1rZXJuLTMuMm11XFxcXH19fVwiICsgXCJ7XFxcXG1hdGhjbG9zZXtcXFxcY2hhcmBcXHUyOTg0fX1cIik7XG5kZWZpbmVNYWNybyhcIlxcdTI5ODNcIiwgXCJcXFxcbEJyYWNlXCIpOyAvLyBibGFja2JvYXJkIGJvbGQge1xuXG5kZWZpbmVNYWNybyhcIlxcdTI5ODRcIiwgXCJcXFxcckJyYWNlXCIpOyAvLyBibGFja2JvYXJkIGJvbGQgfVxuLy8gVE9ETzogQ3JlYXRlIHZhcmlhYmxlIHNpemVkIHZlcnNpb25zIG9mIHRoZSBsYXN0IHR3byBpdGVtcy4gSSBiZWxpZXZlIHRoYXRcbi8vIHdpbGwgcmVxdWlyZSBuZXcgZm9udCBnbHlwaHMuXG4vLyBUaGUgc3RtYXJ5cmQgZnVuY3Rpb24gYFxcbWludXNvYCBwcm92aWRlcyBhIFwiUGxpbXNvbGxcIiBzeW1ib2wgdGhhdFxuLy8gc3VwZXJpbXBvc2VzIHRoZSBjaGFyYWN0ZXJzIFxcY2lyYyBhbmQgXFxtYXRobWludXMuIFVzZWQgaW4gY2hlbWlzdHJ5LlxuXG5kZWZpbmVNYWNybyhcIlxcXFxtaW51c29cIiwgXCJcXFxcbWF0aGJpbntcXFxcaHRtbEBtYXRobWx7XCIgKyBcIntcXFxcbWF0aHJsYXB7XFxcXG1hdGhjaG9pY2V7XFxcXGtlcm57MC4xNDVlbX19e1xcXFxrZXJuezAuMTQ1ZW19fVwiICsgXCJ7XFxcXGtlcm57MC4xMDE1ZW19fXtcXFxca2VybnswLjA3MjVlbX19XFxcXGNpcmN9ey19fX1cIiArIFwie1xcXFxjaGFyYOKmtX19XCIpO1xuZGVmaW5lTWFjcm8oXCLiprVcIiwgXCJcXFxcbWludXNvXCIpOyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyB0ZXh2Yy5zdHlcbi8vIFRoZSB0ZXh2YyBwYWNrYWdlIGNvbnRhaW5zIG1hY3JvcyBhdmFpbGFibGUgaW4gbWVkaWF3aWtpIHBhZ2VzLlxuLy8gV2Ugb21pdCB0aGUgZnVuY3Rpb25zIGRlcHJlY2F0ZWQgYXRcbi8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hlbHA6RGlzcGxheWluZ19hX2Zvcm11bGEjRGVwcmVjYXRlZF9zeW50YXhcbi8vIFdlIGFsc28gb21pdCB0ZXh2YydzIFxcTywgd2hpY2ggY29uZmxpY3RzIHdpdGggXFx0ZXh0e1xcT31cblxuZGVmaW5lTWFjcm8oXCJcXFxcZGFyclwiLCBcIlxcXFxkb3duYXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxkQXJyXCIsIFwiXFxcXERvd25hcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXERhcnJcIiwgXCJcXFxcRG93bmFycm93XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbGFuZ1wiLCBcIlxcXFxsYW5nbGVcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxyYW5nXCIsIFwiXFxcXHJhbmdsZVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHVhcnJcIiwgXCJcXFxcdXBhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHVBcnJcIiwgXCJcXFxcVXBhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXFVhcnJcIiwgXCJcXFxcVXBhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXE5cIiwgXCJcXFxcbWF0aGJie059XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcUlwiLCBcIlxcXFxtYXRoYmJ7Un1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxaXCIsIFwiXFxcXG1hdGhiYntafVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGFsZWZcIiwgXCJcXFxcYWxlcGhcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxhbGVmc3ltXCIsIFwiXFxcXGFsZXBoXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcQWxwaGFcIiwgXCJcXFxcbWF0aHJte0F9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcQmV0YVwiLCBcIlxcXFxtYXRocm17Qn1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxidWxsXCIsIFwiXFxcXGJ1bGxldFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXENoaVwiLCBcIlxcXFxtYXRocm17WH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxjbHVic1wiLCBcIlxcXFxjbHVic3VpdFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGNudW1zXCIsIFwiXFxcXG1hdGhiYntDfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXENvbXBsZXhcIiwgXCJcXFxcbWF0aGJie0N9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcRGFnZ2VyXCIsIFwiXFxcXGRkYWdnZXJcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxkaWFtb25kc1wiLCBcIlxcXFxkaWFtb25kc3VpdFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGVtcHR5XCIsIFwiXFxcXGVtcHR5c2V0XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcRXBzaWxvblwiLCBcIlxcXFxtYXRocm17RX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxFdGFcIiwgXCJcXFxcbWF0aHJte0h9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZXhpc3RcIiwgXCJcXFxcZXhpc3RzXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcaGFyclwiLCBcIlxcXFxsZWZ0cmlnaHRhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGhBcnJcIiwgXCJcXFxcTGVmdHJpZ2h0YXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxIYXJyXCIsIFwiXFxcXExlZnRyaWdodGFycm93XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcaGVhcnRzXCIsIFwiXFxcXGhlYXJ0c3VpdFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGltYWdlXCIsIFwiXFxcXEltXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcaW5maW5cIiwgXCJcXFxcaW5mdHlcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxJb3RhXCIsIFwiXFxcXG1hdGhybXtJfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGlzaW5cIiwgXCJcXFxcaW5cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxLYXBwYVwiLCBcIlxcXFxtYXRocm17S31cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxsYXJyXCIsIFwiXFxcXGxlZnRhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGxBcnJcIiwgXCJcXFxcTGVmdGFycm93XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcTGFyclwiLCBcIlxcXFxMZWZ0YXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxscmFyclwiLCBcIlxcXFxsZWZ0cmlnaHRhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGxyQXJyXCIsIFwiXFxcXExlZnRyaWdodGFycm93XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcTHJhcnJcIiwgXCJcXFxcTGVmdHJpZ2h0YXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxNdVwiLCBcIlxcXFxtYXRocm17TX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxuYXRudW1zXCIsIFwiXFxcXG1hdGhiYntOfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXE51XCIsIFwiXFxcXG1hdGhybXtOfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXE9taWNyb25cIiwgXCJcXFxcbWF0aHJte099XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccGx1c21uXCIsIFwiXFxcXHBtXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccmFyclwiLCBcIlxcXFxyaWdodGFycm93XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcckFyclwiLCBcIlxcXFxSaWdodGFycm93XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcUmFyclwiLCBcIlxcXFxSaWdodGFycm93XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccmVhbFwiLCBcIlxcXFxSZVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHJlYWxzXCIsIFwiXFxcXG1hdGhiYntSfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXFJlYWxzXCIsIFwiXFxcXG1hdGhiYntSfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXFJob1wiLCBcIlxcXFxtYXRocm17UH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxzZG90XCIsIFwiXFxcXGNkb3RcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxzZWN0XCIsIFwiXFxcXFNcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxzcGFkZXNcIiwgXCJcXFxcc3BhZGVzdWl0XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcc3ViXCIsIFwiXFxcXHN1YnNldFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHN1YmVcIiwgXCJcXFxcc3Vic2V0ZXFcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxzdXBlXCIsIFwiXFxcXHN1cHNldGVxXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcVGF1XCIsIFwiXFxcXG1hdGhybXtUfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHRoZXRhc3ltXCIsIFwiXFxcXHZhcnRoZXRhXCIpOyAvLyBUT0RPOiBkZWZpbmVNYWNybyhcIlxcXFx2YXJjb3BwYVwiLCBcIlxcXFxcXG1ib3h7XFxcXGNvcHBhfVwiKTtcblxuZGVmaW5lTWFjcm8oXCJcXFxcd2VpZXJwXCIsIFwiXFxcXHdwXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcWmV0YVwiLCBcIlxcXFxtYXRocm17Wn1cIik7IC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIHN0YXRtYXRoLnN0eVxuLy8gaHR0cHM6Ly9jdGFuLm1hdGguaWxsaW5vaXMuZWR1L21hY3Jvcy9sYXRleC9jb250cmliL3N0YXRtYXRoL3N0YXRtYXRoLnBkZlxuXG5kZWZpbmVNYWNybyhcIlxcXFxhcmdtaW5cIiwgXCJcXFxcRE9UU0JcXFxcb3BlcmF0b3JuYW1lKnthcmdcXFxcLG1pbn1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxhcmdtYXhcIiwgXCJcXFxcRE9UU0JcXFxcb3BlcmF0b3JuYW1lKnthcmdcXFxcLG1heH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxwbGltXCIsIFwiXFxcXERPVFNCXFxcXG1hdGhvcHtcXFxcb3BlcmF0b3JuYW1le3BsaW19fVxcXFxsaW1pdHNcIik7IC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIGJyYWtldC5zdHlcbi8vIGh0dHA6Ly9jdGFuLm1hdGgud2FzaGluZ3Rvbi5lZHUvdGV4LWFyY2hpdmUvbWFjcm9zL2xhdGV4L2NvbnRyaWIvYnJha2V0L2JyYWtldC5wZGZcblxuZGVmaW5lTWFjcm8oXCJcXFxcYnJhXCIsIFwiXFxcXG1hdGhpbm5lcntcXFxcbGFuZ2xleyMxfXx9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxca2V0XCIsIFwiXFxcXG1hdGhpbm5lcnt8eyMxfVxcXFxyYW5nbGV9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcYnJha2V0XCIsIFwiXFxcXG1hdGhpbm5lcntcXFxcbGFuZ2xleyMxfVxcXFxyYW5nbGV9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcQnJhXCIsIFwiXFxcXGxlZnRcXFxcbGFuZ2xlIzFcXFxccmlnaHR8XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcS2V0XCIsIFwiXFxcXGxlZnR8IzFcXFxccmlnaHRcXFxccmFuZ2xlXCIpO1xuXG5jb25zdCBicmFrZXRIZWxwZXIgPSBvbmUgPT4gY29udGV4dCA9PiB7XG4gIGNvbnN0IGxlZnQgPSBjb250ZXh0LmNvbnN1bWVBcmcoKS50b2tlbnM7XG4gIGNvbnN0IG1pZGRsZSA9IGNvbnRleHQuY29uc3VtZUFyZygpLnRva2VucztcbiAgY29uc3QgbWlkZGxlRG91YmxlID0gY29udGV4dC5jb25zdW1lQXJnKCkudG9rZW5zO1xuICBjb25zdCByaWdodCA9IGNvbnRleHQuY29uc3VtZUFyZygpLnRva2VucztcbiAgY29uc3Qgb2xkTWlkZGxlID0gY29udGV4dC5tYWNyb3MuZ2V0KFwifFwiKTtcbiAgY29uc3Qgb2xkTWlkZGxlRG91YmxlID0gY29udGV4dC5tYWNyb3MuZ2V0KFwiXFxcXHxcIik7XG4gIGNvbnRleHQubWFjcm9zLmJlZ2luR3JvdXAoKTtcblxuICBjb25zdCBtaWRNYWNybyA9IGRvdWJsZSA9PiBjb250ZXh0ID0+IHtcbiAgICBpZiAob25lKSB7XG4gICAgICAvLyBPbmx5IG1vZGlmeSB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgfCBvciBcXHxcbiAgICAgIGNvbnRleHQubWFjcm9zLnNldChcInxcIiwgb2xkTWlkZGxlKTtcblxuICAgICAgaWYgKG1pZGRsZURvdWJsZS5sZW5ndGgpIHtcbiAgICAgICAgY29udGV4dC5tYWNyb3Muc2V0KFwiXFxcXHxcIiwgb2xkTWlkZGxlRG91YmxlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgZG91YmxlZCA9IGRvdWJsZTtcblxuICAgIGlmICghZG91YmxlICYmIG1pZGRsZURvdWJsZS5sZW5ndGgpIHtcbiAgICAgIC8vIE1pbWljIFxcQGlmbmV4dGNoYXJcbiAgICAgIGNvbnN0IG5leHRUb2tlbiA9IGNvbnRleHQuZnV0dXJlKCk7XG5cbiAgICAgIGlmIChuZXh0VG9rZW4udGV4dCA9PT0gXCJ8XCIpIHtcbiAgICAgICAgY29udGV4dC5wb3BUb2tlbigpO1xuICAgICAgICBkb3VibGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdG9rZW5zOiBkb3VibGVkID8gbWlkZGxlRG91YmxlIDogbWlkZGxlLFxuICAgICAgbnVtQXJnczogMFxuICAgIH07XG4gIH07XG5cbiAgY29udGV4dC5tYWNyb3Muc2V0KFwifFwiLCBtaWRNYWNybyhmYWxzZSkpO1xuXG4gIGlmIChtaWRkbGVEb3VibGUubGVuZ3RoKSB7XG4gICAgY29udGV4dC5tYWNyb3Muc2V0KFwiXFxcXHxcIiwgbWlkTWFjcm8odHJ1ZSkpO1xuICB9XG5cbiAgY29uc3QgYXJnID0gY29udGV4dC5jb25zdW1lQXJnKCkudG9rZW5zO1xuICBjb25zdCBleHBhbmRlZCA9IGNvbnRleHQuZXhwYW5kVG9rZW5zKFsuLi5yaWdodCwgLi4uYXJnLCAuLi5sZWZ0IC8vIHJldmVyc2VkXG4gIF0pO1xuICBjb250ZXh0Lm1hY3Jvcy5lbmRHcm91cCgpO1xuICByZXR1cm4ge1xuICAgIHRva2VuczogZXhwYW5kZWQucmV2ZXJzZSgpLFxuICAgIG51bUFyZ3M6IDBcbiAgfTtcbn07XG5cbmRlZmluZU1hY3JvKFwiXFxcXGJyYUBrZXRcIiwgYnJha2V0SGVscGVyKGZhbHNlKSk7XG5kZWZpbmVNYWNybyhcIlxcXFxicmFAc2V0XCIsIGJyYWtldEhlbHBlcih0cnVlKSk7XG5kZWZpbmVNYWNybyhcIlxcXFxCcmFrZXRcIiwgXCJcXFxcYnJhQGtldHtcXFxcbGVmdFxcXFxsYW5nbGV9XCIgKyBcIntcXFxcLFxcXFxtaWRkbGVcXFxcdmVydFxcXFwsfXtcXFxcLFxcXFxtaWRkbGVcXFxcdmVydFxcXFwsfXtcXFxccmlnaHRcXFxccmFuZ2xlfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXFNldFwiLCBcIlxcXFxicmFAc2V0e1xcXFxsZWZ0XFxcXHtcXFxcOn1cIiArIFwie1xcXFw7XFxcXG1pZGRsZVxcXFx2ZXJ0XFxcXDt9e1xcXFw7XFxcXG1pZGRsZVxcXFxWZXJ0XFxcXDt9e1xcXFw6XFxcXHJpZ2h0XFxcXH19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcc2V0XCIsIFwiXFxcXGJyYUBzZXR7XFxcXHtcXFxcLH17XFxcXG1pZH17fXtcXFxcLFxcXFx9fVwiKTsgLy8gaGFzIG5vIHN1cHBvcnQgZm9yIHNwZWNpYWwgfHwgb3IgXFx8XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBhY3R1YXJpYWxhbmdsZS5kdHhcblxuZGVmaW5lTWFjcm8oXCJcXFxcYW5nbG5cIiwgXCJ7XFxcXGFuZ2wgbn1cIik7IC8vIEN1c3RvbSBLaGFuIEFjYWRlbXkgY29sb3JzLCBzaG91bGQgYmUgbW92ZWQgdG8gYW4gb3B0aW9uYWwgcGFja2FnZVxuXG5kZWZpbmVNYWNybyhcIlxcXFxibHVlXCIsIFwiXFxcXHRleHRjb2xvcnsjIzY0OTVlZH17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcb3JhbmdlXCIsIFwiXFxcXHRleHRjb2xvcnsjI2ZmYTUwMH17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccGlua1wiLCBcIlxcXFx0ZXh0Y29sb3J7IyNmZjAwYWZ9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHJlZFwiLCBcIlxcXFx0ZXh0Y29sb3J7IyNkZjAwMzB9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGdyZWVuXCIsIFwiXFxcXHRleHRjb2xvcnsjIzI4YWU3Yn17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZ3JheVwiLCBcIlxcXFx0ZXh0Y29sb3J7Z3JheX17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccHVycGxlXCIsIFwiXFxcXHRleHRjb2xvcnsjIzlkMzhiZH17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcYmx1ZUFcIiwgXCJcXFxcdGV4dGNvbG9yeyMjY2NmYWZmfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxibHVlQlwiLCBcIlxcXFx0ZXh0Y29sb3J7IyM4MGY2ZmZ9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGJsdWVDXCIsIFwiXFxcXHRleHRjb2xvcnsjIzYzZDllYX17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcYmx1ZURcIiwgXCJcXFxcdGV4dGNvbG9yeyMjMTFhY2NkfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxibHVlRVwiLCBcIlxcXFx0ZXh0Y29sb3J7IyMwYzdmOTl9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHRlYWxBXCIsIFwiXFxcXHRleHRjb2xvcnsjIzk0ZmZmNX17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdGVhbEJcIiwgXCJcXFxcdGV4dGNvbG9yeyMjMjZlZGQ1fXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx0ZWFsQ1wiLCBcIlxcXFx0ZXh0Y29sb3J7IyMwMWQxYzF9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHRlYWxEXCIsIFwiXFxcXHRleHRjb2xvcnsjIzAxYTk5NX17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdGVhbEVcIiwgXCJcXFxcdGV4dGNvbG9yeyMjMjA4MTcwfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxncmVlbkFcIiwgXCJcXFxcdGV4dGNvbG9yeyMjYjZmZmIwfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxncmVlbkJcIiwgXCJcXFxcdGV4dGNvbG9yeyMjOGFmMjgxfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxncmVlbkNcIiwgXCJcXFxcdGV4dGNvbG9yeyMjNzRjZjcwfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxncmVlbkRcIiwgXCJcXFxcdGV4dGNvbG9yeyMjMWZhYjU0fXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxncmVlbkVcIiwgXCJcXFxcdGV4dGNvbG9yeyMjMGQ5MjNmfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxnb2xkQVwiLCBcIlxcXFx0ZXh0Y29sb3J7IyNmZmQwYTl9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGdvbGRCXCIsIFwiXFxcXHRleHRjb2xvcnsjI2ZmYmI3MX17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZ29sZENcIiwgXCJcXFxcdGV4dGNvbG9yeyMjZmY5YzM5fXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxnb2xkRFwiLCBcIlxcXFx0ZXh0Y29sb3J7IyNlMDdkMTB9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGdvbGRFXCIsIFwiXFxcXHRleHRjb2xvcnsjI2E3NWEwNX17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccmVkQVwiLCBcIlxcXFx0ZXh0Y29sb3J7IyNmY2E5YTl9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHJlZEJcIiwgXCJcXFxcdGV4dGNvbG9yeyMjZmY4NDgyfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxyZWRDXCIsIFwiXFxcXHRleHRjb2xvcnsjI2Y5Njg1ZH17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccmVkRFwiLCBcIlxcXFx0ZXh0Y29sb3J7IyNlODRkMzl9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHJlZEVcIiwgXCJcXFxcdGV4dGNvbG9yeyMjYmMyNjEyfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxtYXJvb25BXCIsIFwiXFxcXHRleHRjb2xvcnsjI2ZmYmRlMH17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbWFyb29uQlwiLCBcIlxcXFx0ZXh0Y29sb3J7IyNmZjkyYzZ9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG1hcm9vbkNcIiwgXCJcXFxcdGV4dGNvbG9yeyMjZWQ1ZmE2fXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxtYXJvb25EXCIsIFwiXFxcXHRleHRjb2xvcnsjI2NhMzM3Y317IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbWFyb29uRVwiLCBcIlxcXFx0ZXh0Y29sb3J7IyM5ZTAzNGV9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHB1cnBsZUFcIiwgXCJcXFxcdGV4dGNvbG9yeyMjZGRkN2ZmfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxwdXJwbGVCXCIsIFwiXFxcXHRleHRjb2xvcnsjI2M2YjlmY317IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccHVycGxlQ1wiLCBcIlxcXFx0ZXh0Y29sb3J7IyNhYTg3ZmZ9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHB1cnBsZURcIiwgXCJcXFxcdGV4dGNvbG9yeyMjNzg1NGFifXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxwdXJwbGVFXCIsIFwiXFxcXHRleHRjb2xvcnsjIzU0M2I3OH17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbWludEFcIiwgXCJcXFxcdGV4dGNvbG9yeyMjZjVmOWU4fXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxtaW50QlwiLCBcIlxcXFx0ZXh0Y29sb3J7IyNlZGYyZGZ9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG1pbnRDXCIsIFwiXFxcXHRleHRjb2xvcnsjI2UwZTVjY317IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZ3JheUFcIiwgXCJcXFxcdGV4dGNvbG9yeyMjZjZmN2Y3fXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxncmF5QlwiLCBcIlxcXFx0ZXh0Y29sb3J7IyNmMGYxZjJ9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGdyYXlDXCIsIFwiXFxcXHRleHRjb2xvcnsjI2UzZTVlNn17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZ3JheURcIiwgXCJcXFxcdGV4dGNvbG9yeyMjZDZkOGRhfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxncmF5RVwiLCBcIlxcXFx0ZXh0Y29sb3J7IyNiYWJlYzJ9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGdyYXlGXCIsIFwiXFxcXHRleHRjb2xvcnsjIzg4OGQ5M317IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZ3JheUdcIiwgXCJcXFxcdGV4dGNvbG9yeyMjNjI2NTY5fXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxncmF5SFwiLCBcIlxcXFx0ZXh0Y29sb3J7IyMzYjNlNDB9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGdyYXlJXCIsIFwiXFxcXHRleHRjb2xvcnsjIzIxMjQyY317IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxca2FCbHVlXCIsIFwiXFxcXHRleHRjb2xvcnsjIzMxNDQ1M317IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxca2FHcmVlblwiLCBcIlxcXFx0ZXh0Y29sb3J7IyM3MUIzMDd9eyMxfVwiKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9NYWNyb0V4cGFuZGVyLmpzXG4vKipcbiAqIFRoaXMgZmlsZSBjb250YWlucyB0aGUg4oCcZ3VsbGV04oCdIHdoZXJlIG1hY3JvcyBhcmUgZXhwYW5kZWRcbiAqIHVudGlsIG9ubHkgbm9uLW1hY3JvIHRva2VucyByZW1haW4uXG4gKi9cblxuXG5cblxuXG5cblxuLy8gTGlzdCBvZiBjb21tYW5kcyB0aGF0IGFjdCBsaWtlIG1hY3JvcyBidXQgYXJlbid0IGRlZmluZWQgYXMgYSBtYWNybyxcbi8vIGZ1bmN0aW9uLCBvciBzeW1ib2wuICBVc2VkIGluIGBpc0RlZmluZWRgLlxuY29uc3QgaW1wbGljaXRDb21tYW5kcyA9IHtcbiAgXCJeXCI6IHRydWUsXG4gIC8vIFBhcnNlci5qc1xuICBcIl9cIjogdHJ1ZSxcbiAgLy8gUGFyc2VyLmpzXG4gIFwiXFxcXGxpbWl0c1wiOiB0cnVlLFxuICAvLyBQYXJzZXIuanNcbiAgXCJcXFxcbm9saW1pdHNcIjogdHJ1ZSAvLyBQYXJzZXIuanNcblxufTtcbmNsYXNzIE1hY3JvRXhwYW5kZXIge1xuICBjb25zdHJ1Y3RvcihpbnB1dCwgc2V0dGluZ3MsIG1vZGUpIHtcbiAgICB0aGlzLnNldHRpbmdzID0gdm9pZCAwO1xuICAgIHRoaXMuZXhwYW5zaW9uQ291bnQgPSB2b2lkIDA7XG4gICAgdGhpcy5sZXhlciA9IHZvaWQgMDtcbiAgICB0aGlzLm1hY3JvcyA9IHZvaWQgMDtcbiAgICB0aGlzLnN0YWNrID0gdm9pZCAwO1xuICAgIHRoaXMubW9kZSA9IHZvaWQgMDtcbiAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgdGhpcy5leHBhbnNpb25Db3VudCA9IDA7XG4gICAgdGhpcy5mZWVkKGlucHV0KTsgLy8gTWFrZSBuZXcgZ2xvYmFsIG5hbWVzcGFjZVxuXG4gICAgdGhpcy5tYWNyb3MgPSBuZXcgTmFtZXNwYWNlKHNyY19tYWNyb3MsIHNldHRpbmdzLm1hY3Jvcyk7XG4gICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICB0aGlzLnN0YWNrID0gW107IC8vIGNvbnRhaW5zIHRva2VucyBpbiBSRVZFUlNFIG9yZGVyXG4gIH1cbiAgLyoqXG4gICAqIEZlZWQgYSBuZXcgaW5wdXQgc3RyaW5nIHRvIHRoZSBzYW1lIE1hY3JvRXhwYW5kZXJcbiAgICogKHdpdGggZXhpc3RpbmcgbWFjcm9zIGV0Yy4pLlxuICAgKi9cblxuXG4gIGZlZWQoaW5wdXQpIHtcbiAgICB0aGlzLmxleGVyID0gbmV3IExleGVyKGlucHV0LCB0aGlzLnNldHRpbmdzKTtcbiAgfVxuICAvKipcbiAgICogU3dpdGNoZXMgYmV0d2VlbiBcInRleHRcIiBhbmQgXCJtYXRoXCIgbW9kZXMuXG4gICAqL1xuXG5cbiAgc3dpdGNoTW9kZShuZXdNb2RlKSB7XG4gICAgdGhpcy5tb2RlID0gbmV3TW9kZTtcbiAgfVxuICAvKipcbiAgICogU3RhcnQgYSBuZXcgZ3JvdXAgbmVzdGluZyB3aXRoaW4gYWxsIG5hbWVzcGFjZXMuXG4gICAqL1xuXG5cbiAgYmVnaW5Hcm91cCgpIHtcbiAgICB0aGlzLm1hY3Jvcy5iZWdpbkdyb3VwKCk7XG4gIH1cbiAgLyoqXG4gICAqIEVuZCBjdXJyZW50IGdyb3VwIG5lc3Rpbmcgd2l0aGluIGFsbCBuYW1lc3BhY2VzLlxuICAgKi9cblxuXG4gIGVuZEdyb3VwKCkge1xuICAgIHRoaXMubWFjcm9zLmVuZEdyb3VwKCk7XG4gIH1cbiAgLyoqXG4gICAqIEVuZHMgYWxsIGN1cnJlbnRseSBuZXN0ZWQgZ3JvdXBzIChpZiBhbnkpLCByZXN0b3JpbmcgdmFsdWVzIGJlZm9yZSB0aGVcbiAgICogZ3JvdXBzIGJlZ2FuLiAgVXNlZnVsIGluIGNhc2Ugb2YgYW4gZXJyb3IgaW4gdGhlIG1pZGRsZSBvZiBwYXJzaW5nLlxuICAgKi9cblxuXG4gIGVuZEdyb3VwcygpIHtcbiAgICB0aGlzLm1hY3Jvcy5lbmRHcm91cHMoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdG9wbW9zdCB0b2tlbiBvbiB0aGUgc3RhY2ssIHdpdGhvdXQgZXhwYW5kaW5nIGl0LlxuICAgKiBTaW1pbGFyIGluIGJlaGF2aW9yIHRvIFRlWCdzIGBcXGZ1dHVyZWxldGAuXG4gICAqL1xuXG5cbiAgZnV0dXJlKCkge1xuICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5wdXNoVG9rZW4odGhpcy5sZXhlci5sZXgoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIGFuZCByZXR1cm4gdGhlIG5leHQgdW5leHBhbmRlZCB0b2tlbi5cbiAgICovXG5cblxuICBwb3BUb2tlbigpIHtcbiAgICB0aGlzLmZ1dHVyZSgpOyAvLyBlbnN1cmUgbm9uLWVtcHR5IHN0YWNrXG5cbiAgICByZXR1cm4gdGhpcy5zdGFjay5wb3AoKTtcbiAgfVxuICAvKipcbiAgICogQWRkIGEgZ2l2ZW4gdG9rZW4gdG8gdGhlIHRva2VuIHN0YWNrLiAgSW4gcGFydGljdWxhciwgdGhpcyBnZXQgYmUgdXNlZFxuICAgKiB0byBwdXQgYmFjayBhIHRva2VuIHJldHVybmVkIGZyb20gb25lIG9mIHRoZSBvdGhlciBtZXRob2RzLlxuICAgKi9cblxuXG4gIHB1c2hUb2tlbih0b2tlbikge1xuICAgIHRoaXMuc3RhY2sucHVzaCh0b2tlbik7XG4gIH1cbiAgLyoqXG4gICAqIEFwcGVuZCBhbiBhcnJheSBvZiB0b2tlbnMgdG8gdGhlIHRva2VuIHN0YWNrLlxuICAgKi9cblxuXG4gIHB1c2hUb2tlbnModG9rZW5zKSB7XG4gICAgdGhpcy5zdGFjay5wdXNoKC4uLnRva2Vucyk7XG4gIH1cbiAgLyoqXG4gICAqIEZpbmQgYW4gbWFjcm8gYXJndW1lbnQgd2l0aG91dCBleHBhbmRpbmcgdG9rZW5zIGFuZCBhcHBlbmQgdGhlIGFycmF5IG9mXG4gICAqIHRva2VucyB0byB0aGUgdG9rZW4gc3RhY2suIFVzZXMgVG9rZW4gYXMgYSBjb250YWluZXIgZm9yIHRoZSByZXN1bHQuXG4gICAqL1xuXG5cbiAgc2NhbkFyZ3VtZW50KGlzT3B0aW9uYWwpIHtcbiAgICBsZXQgc3RhcnQ7XG4gICAgbGV0IGVuZDtcbiAgICBsZXQgdG9rZW5zO1xuXG4gICAgaWYgKGlzT3B0aW9uYWwpIHtcbiAgICAgIHRoaXMuY29uc3VtZVNwYWNlcygpOyAvLyBcXEBpZm5leHRjaGFyIGdvYmJsZXMgYW55IHNwYWNlIGZvbGxvd2luZyBpdFxuXG4gICAgICBpZiAodGhpcy5mdXR1cmUoKS50ZXh0ICE9PSBcIltcIikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgc3RhcnQgPSB0aGlzLnBvcFRva2VuKCk7IC8vIGRvbid0IGluY2x1ZGUgWyBpbiB0b2tlbnNcblxuICAgICAgKHtcbiAgICAgICAgdG9rZW5zLFxuICAgICAgICBlbmRcbiAgICAgIH0gPSB0aGlzLmNvbnN1bWVBcmcoW1wiXVwiXSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAoe1xuICAgICAgICB0b2tlbnMsXG4gICAgICAgIHN0YXJ0LFxuICAgICAgICBlbmRcbiAgICAgIH0gPSB0aGlzLmNvbnN1bWVBcmcoKSk7XG4gICAgfSAvLyBpbmRpY2F0ZSB0aGUgZW5kIG9mIGFuIGFyZ3VtZW50XG5cblxuICAgIHRoaXMucHVzaFRva2VuKG5ldyBUb2tlbihcIkVPRlwiLCBlbmQubG9jKSk7XG4gICAgdGhpcy5wdXNoVG9rZW5zKHRva2Vucyk7XG4gICAgcmV0dXJuIHN0YXJ0LnJhbmdlKGVuZCwgXCJcIik7XG4gIH1cbiAgLyoqXG4gICAqIENvbnN1bWUgYWxsIGZvbGxvd2luZyBzcGFjZSB0b2tlbnMsIHdpdGhvdXQgZXhwYW5zaW9uLlxuICAgKi9cblxuXG4gIGNvbnN1bWVTcGFjZXMoKSB7XG4gICAgZm9yICg7Oykge1xuICAgICAgY29uc3QgdG9rZW4gPSB0aGlzLmZ1dHVyZSgpO1xuXG4gICAgICBpZiAodG9rZW4udGV4dCA9PT0gXCIgXCIpIHtcbiAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ29uc3VtZSBhbiBhcmd1bWVudCBmcm9tIHRoZSB0b2tlbiBzdHJlYW0sIGFuZCByZXR1cm4gdGhlIHJlc3VsdGluZyBhcnJheVxuICAgKiBvZiB0b2tlbnMgYW5kIHN0YXJ0L2VuZCB0b2tlbi5cbiAgICovXG5cblxuICBjb25zdW1lQXJnKGRlbGltcykge1xuICAgIC8vIFRoZSBhcmd1bWVudCBmb3IgYSBkZWxpbWl0ZWQgcGFyYW1ldGVyIGlzIHRoZSBzaG9ydGVzdCAocG9zc2libHlcbiAgICAvLyBlbXB0eSkgc2VxdWVuY2Ugb2YgdG9rZW5zIHdpdGggcHJvcGVybHkgbmVzdGVkIHsuLi59IGdyb3VwcyB0aGF0IGlzXG4gICAgLy8gZm9sbG93ZWQgLi4uIGJ5IHRoaXMgcGFydGljdWxhciBsaXN0IG9mIG5vbi1wYXJhbWV0ZXIgdG9rZW5zLlxuICAgIC8vIFRoZSBhcmd1bWVudCBmb3IgYW4gdW5kZWxpbWl0ZWQgcGFyYW1ldGVyIGlzIHRoZSBuZXh0IG5vbmJsYW5rXG4gICAgLy8gdG9rZW4sIHVubGVzcyB0aGF0IHRva2VuIGlzIOKAmHvigJksIHdoZW4gdGhlIGFyZ3VtZW50IHdpbGwgYmUgdGhlXG4gICAgLy8gZW50aXJlIHsuLi59IGdyb3VwIHRoYXQgZm9sbG93cy5cbiAgICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgICBjb25zdCBpc0RlbGltaXRlZCA9IGRlbGltcyAmJiBkZWxpbXMubGVuZ3RoID4gMDtcblxuICAgIGlmICghaXNEZWxpbWl0ZWQpIHtcbiAgICAgIC8vIElnbm9yZSBzcGFjZXMgYmV0d2VlbiBhcmd1bWVudHMuICBBcyB0aGUgVGVYYm9vayBzYXlzOlxuICAgICAgLy8gXCJBZnRlciB5b3UgaGF2ZSBzYWlkIOKAmFxcZGVmXFxyb3cjMSMyey4uLn3igJksIHlvdSBhcmUgYWxsb3dlZCB0b1xuICAgICAgLy8gIHB1dCBzcGFjZXMgYmV0d2VlbiB0aGUgYXJndW1lbnRzIChlLmcuLCDigJhcXHJvdyB4IG7igJkpLCBiZWNhdXNlXG4gICAgICAvLyAgVGVYIGRvZXNu4oCZdCB1c2Ugc2luZ2xlIHNwYWNlcyBhcyB1bmRlbGltaXRlZCBhcmd1bWVudHMuXCJcbiAgICAgIHRoaXMuY29uc3VtZVNwYWNlcygpO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5mdXR1cmUoKTtcbiAgICBsZXQgdG9rO1xuICAgIGxldCBkZXB0aCA9IDA7XG4gICAgbGV0IG1hdGNoID0gMDtcblxuICAgIGRvIHtcbiAgICAgIHRvayA9IHRoaXMucG9wVG9rZW4oKTtcbiAgICAgIHRva2Vucy5wdXNoKHRvayk7XG5cbiAgICAgIGlmICh0b2sudGV4dCA9PT0gXCJ7XCIpIHtcbiAgICAgICAgKytkZXB0aDtcbiAgICAgIH0gZWxzZSBpZiAodG9rLnRleHQgPT09IFwifVwiKSB7XG4gICAgICAgIC0tZGVwdGg7XG5cbiAgICAgICAgaWYgKGRlcHRoID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIkV4dHJhIH1cIiwgdG9rKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0b2sudGV4dCA9PT0gXCJFT0ZcIikge1xuICAgICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dCBpbiBhIG1hY3JvIGFyZ3VtZW50XCIgKyBcIiwgZXhwZWN0ZWQgJ1wiICsgKGRlbGltcyAmJiBpc0RlbGltaXRlZCA/IGRlbGltc1ttYXRjaF0gOiBcIn1cIikgKyBcIidcIiwgdG9rKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRlbGltcyAmJiBpc0RlbGltaXRlZCkge1xuICAgICAgICBpZiAoKGRlcHRoID09PSAwIHx8IGRlcHRoID09PSAxICYmIGRlbGltc1ttYXRjaF0gPT09IFwie1wiKSAmJiB0b2sudGV4dCA9PT0gZGVsaW1zW21hdGNoXSkge1xuICAgICAgICAgICsrbWF0Y2g7XG5cbiAgICAgICAgICBpZiAobWF0Y2ggPT09IGRlbGltcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIGRvbid0IGluY2x1ZGUgZGVsaW1zIGluIHRva2Vuc1xuICAgICAgICAgICAgdG9rZW5zLnNwbGljZSgtbWF0Y2gsIG1hdGNoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXRjaCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IHdoaWxlIChkZXB0aCAhPT0gMCB8fCBpc0RlbGltaXRlZCk7IC8vIElmIHRoZSBhcmd1bWVudCBmb3VuZCAuLi4gaGFzIHRoZSBmb3JtIOKAmHs8bmVzdGVkIHRva2Vucz594oCZLFxuICAgIC8vIC4uLiB0aGUgb3V0ZXJtb3N0IGJyYWNlcyBlbmNsb3NpbmcgdGhlIGFyZ3VtZW50IGFyZSByZW1vdmVkXG5cblxuICAgIGlmIChzdGFydC50ZXh0ID09PSBcIntcIiAmJiB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdLnRleHQgPT09IFwifVwiKSB7XG4gICAgICB0b2tlbnMucG9wKCk7XG4gICAgICB0b2tlbnMuc2hpZnQoKTtcbiAgICB9XG5cbiAgICB0b2tlbnMucmV2ZXJzZSgpOyAvLyB0byBmaXQgaW4gd2l0aCBzdGFjayBvcmRlclxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRva2VucyxcbiAgICAgIHN0YXJ0LFxuICAgICAgZW5kOiB0b2tcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBDb25zdW1lIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIChkZWxpbWl0ZWQpIGFyZ3VtZW50cyBmcm9tIHRoZSB0b2tlblxuICAgKiBzdHJlYW0gYW5kIHJldHVybiB0aGUgcmVzdWx0aW5nIGFycmF5IG9mIGFyZ3VtZW50cy5cbiAgICovXG5cblxuICBjb25zdW1lQXJncyhudW1BcmdzLCBkZWxpbWl0ZXJzKSB7XG4gICAgaWYgKGRlbGltaXRlcnMpIHtcbiAgICAgIGlmIChkZWxpbWl0ZXJzLmxlbmd0aCAhPT0gbnVtQXJncyArIDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiVGhlIGxlbmd0aCBvZiBkZWxpbWl0ZXJzIGRvZXNuJ3QgbWF0Y2ggdGhlIG51bWJlciBvZiBhcmdzIVwiKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGVsaW1zID0gZGVsaW1pdGVyc1swXTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWxpbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdG9rID0gdGhpcy5wb3BUb2tlbigpO1xuXG4gICAgICAgIGlmIChkZWxpbXNbaV0gIT09IHRvay50ZXh0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiVXNlIG9mIHRoZSBtYWNybyBkb2Vzbid0IG1hdGNoIGl0cyBkZWZpbml0aW9uXCIsIHRvayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBhcmdzID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUFyZ3M7IGkrKykge1xuICAgICAgYXJncy5wdXNoKHRoaXMuY29uc3VtZUFyZyhkZWxpbWl0ZXJzICYmIGRlbGltaXRlcnNbaSArIDFdKS50b2tlbnMpO1xuICAgIH1cblxuICAgIHJldHVybiBhcmdzO1xuICB9XG4gIC8qKlxuICAgKiBJbmNyZW1lbnQgYGV4cGFuc2lvbkNvdW50YCBieSB0aGUgc3BlY2lmaWVkIGFtb3VudC5cbiAgICogVGhyb3cgYW4gZXJyb3IgaWYgaXQgZXhjZWVkcyBgbWF4RXhwYW5kYC5cbiAgICovXG5cblxuICBjb3VudEV4cGFuc2lvbihhbW91bnQpIHtcbiAgICB0aGlzLmV4cGFuc2lvbkNvdW50ICs9IGFtb3VudDtcblxuICAgIGlmICh0aGlzLmV4cGFuc2lvbkNvdW50ID4gdGhpcy5zZXR0aW5ncy5tYXhFeHBhbmQpIHtcbiAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIlRvbyBtYW55IGV4cGFuc2lvbnM6IGluZmluaXRlIGxvb3Agb3IgXCIgKyBcIm5lZWQgdG8gaW5jcmVhc2UgbWF4RXhwYW5kIHNldHRpbmdcIik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBFeHBhbmQgdGhlIG5leHQgdG9rZW4gb25seSBvbmNlIGlmIHBvc3NpYmxlLlxuICAgKlxuICAgKiBJZiB0aGUgdG9rZW4gaXMgZXhwYW5kZWQsIHRoZSByZXN1bHRpbmcgdG9rZW5zIHdpbGwgYmUgcHVzaGVkIG9udG9cbiAgICogdGhlIHN0YWNrIGluIHJldmVyc2Ugb3JkZXIsIGFuZCB0aGUgbnVtYmVyIG9mIHN1Y2ggdG9rZW5zIHdpbGwgYmVcbiAgICogcmV0dXJuZWQuICBUaGlzIG51bWJlciBtaWdodCBiZSB6ZXJvIG9yIHBvc2l0aXZlLlxuICAgKlxuICAgKiBJZiBub3QsIHRoZSByZXR1cm4gdmFsdWUgaXMgYGZhbHNlYCwgYW5kIHRoZSBuZXh0IHRva2VuIHJlbWFpbnMgYXQgdGhlXG4gICAqIHRvcCBvZiB0aGUgc3RhY2suXG4gICAqXG4gICAqIEluIGVpdGhlciBjYXNlLCB0aGUgbmV4dCB0b2tlbiB3aWxsIGJlIG9uIHRoZSB0b3Agb2YgdGhlIHN0YWNrLFxuICAgKiBvciB0aGUgc3RhY2sgd2lsbCBiZSBlbXB0eSAoaW4gY2FzZSBvZiBlbXB0eSBleHBhbnNpb25cbiAgICogYW5kIG5vIG90aGVyIHRva2VucykuXG4gICAqXG4gICAqIFVzZWQgdG8gaW1wbGVtZW50IGBleHBhbmRBZnRlckZ1dHVyZWAgYW5kIGBleHBhbmROZXh0VG9rZW5gLlxuICAgKlxuICAgKiBJZiBleHBhbmRhYmxlT25seSwgb25seSBleHBhbmRhYmxlIHRva2VucyBhcmUgZXhwYW5kZWQgYW5kXG4gICAqIGFuIHVuZGVmaW5lZCBjb250cm9sIHNlcXVlbmNlIHJlc3VsdHMgaW4gYW4gZXJyb3IuXG4gICAqL1xuXG5cbiAgZXhwYW5kT25jZShleHBhbmRhYmxlT25seSkge1xuICAgIGNvbnN0IHRvcFRva2VuID0gdGhpcy5wb3BUb2tlbigpO1xuICAgIGNvbnN0IG5hbWUgPSB0b3BUb2tlbi50ZXh0O1xuICAgIGNvbnN0IGV4cGFuc2lvbiA9ICF0b3BUb2tlbi5ub2V4cGFuZCA/IHRoaXMuX2dldEV4cGFuc2lvbihuYW1lKSA6IG51bGw7XG5cbiAgICBpZiAoZXhwYW5zaW9uID09IG51bGwgfHwgZXhwYW5kYWJsZU9ubHkgJiYgZXhwYW5zaW9uLnVuZXhwYW5kYWJsZSkge1xuICAgICAgaWYgKGV4cGFuZGFibGVPbmx5ICYmIGV4cGFuc2lvbiA9PSBudWxsICYmIG5hbWVbMF0gPT09IFwiXFxcXFwiICYmICF0aGlzLmlzRGVmaW5lZChuYW1lKSkge1xuICAgICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJVbmRlZmluZWQgY29udHJvbCBzZXF1ZW5jZTogXCIgKyBuYW1lKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wdXNoVG9rZW4odG9wVG9rZW4pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuY291bnRFeHBhbnNpb24oMSk7XG4gICAgbGV0IHRva2VucyA9IGV4cGFuc2lvbi50b2tlbnM7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuY29uc3VtZUFyZ3MoZXhwYW5zaW9uLm51bUFyZ3MsIGV4cGFuc2lvbi5kZWxpbWl0ZXJzKTtcblxuICAgIGlmIChleHBhbnNpb24ubnVtQXJncykge1xuICAgICAgLy8gcGFzdGUgYXJndW1lbnRzIGluIHBsYWNlIG9mIHRoZSBwbGFjZWhvbGRlcnNcbiAgICAgIHRva2VucyA9IHRva2Vucy5zbGljZSgpOyAvLyBtYWtlIGEgc2hhbGxvdyBjb3B5XG5cbiAgICAgIGZvciAobGV0IGkgPSB0b2tlbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgbGV0IHRvayA9IHRva2Vuc1tpXTtcblxuICAgICAgICBpZiAodG9rLnRleHQgPT09IFwiI1wiKSB7XG4gICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIkluY29tcGxldGUgcGxhY2Vob2xkZXIgYXQgZW5kIG9mIG1hY3JvIGJvZHlcIiwgdG9rKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0b2sgPSB0b2tlbnNbLS1pXTsgLy8gbmV4dCB0b2tlbiBvbiBzdGFja1xuXG4gICAgICAgICAgaWYgKHRvay50ZXh0ID09PSBcIiNcIikge1xuICAgICAgICAgICAgLy8gIyMg4oaSICNcbiAgICAgICAgICAgIHRva2Vucy5zcGxpY2UoaSArIDEsIDEpOyAvLyBkcm9wIGZpcnN0ICNcbiAgICAgICAgICB9IGVsc2UgaWYgKC9eWzEtOV0kLy50ZXN0KHRvay50ZXh0KSkge1xuICAgICAgICAgICAgLy8gcmVwbGFjZSB0aGUgcGxhY2Vob2xkZXIgd2l0aCB0aGUgaW5kaWNhdGVkIGFyZ3VtZW50XG4gICAgICAgICAgICB0b2tlbnMuc3BsaWNlKGksIDIsIC4uLmFyZ3NbK3Rvay50ZXh0IC0gMV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJOb3QgYSB2YWxpZCBhcmd1bWVudCBudW1iZXJcIiwgdG9rKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIENvbmNhdGVuYXRlIGV4cGFuc2lvbiBvbnRvIHRvcCBvZiBzdGFjay5cblxuXG4gICAgdGhpcy5wdXNoVG9rZW5zKHRva2Vucyk7XG4gICAgcmV0dXJuIHRva2Vucy5sZW5ndGg7XG4gIH1cbiAgLyoqXG4gICAqIEV4cGFuZCB0aGUgbmV4dCB0b2tlbiBvbmx5IG9uY2UgKGlmIHBvc3NpYmxlKSwgYW5kIHJldHVybiB0aGUgcmVzdWx0aW5nXG4gICAqIHRvcCB0b2tlbiBvbiB0aGUgc3RhY2sgKHdpdGhvdXQgcmVtb3ZpbmcgYW55dGhpbmcgZnJvbSB0aGUgc3RhY2spLlxuICAgKiBTaW1pbGFyIGluIGJlaGF2aW9yIHRvIFRlWCdzIGBcXGV4cGFuZGFmdGVyXFxmdXR1cmVsZXRgLlxuICAgKiBFcXVpdmFsZW50IHRvIGV4cGFuZE9uY2UoKSBmb2xsb3dlZCBieSBmdXR1cmUoKS5cbiAgICovXG5cblxuICBleHBhbmRBZnRlckZ1dHVyZSgpIHtcbiAgICB0aGlzLmV4cGFuZE9uY2UoKTtcbiAgICByZXR1cm4gdGhpcy5mdXR1cmUoKTtcbiAgfVxuICAvKipcbiAgICogUmVjdXJzaXZlbHkgZXhwYW5kIGZpcnN0IHRva2VuLCB0aGVuIHJldHVybiBmaXJzdCBub24tZXhwYW5kYWJsZSB0b2tlbi5cbiAgICovXG5cblxuICBleHBhbmROZXh0VG9rZW4oKSB7XG4gICAgZm9yICg7Oykge1xuICAgICAgaWYgKHRoaXMuZXhwYW5kT25jZSgpID09PSBmYWxzZSkge1xuICAgICAgICAvLyBmdWxseSBleHBhbmRlZFxuICAgICAgICBjb25zdCB0b2tlbiA9IHRoaXMuc3RhY2sucG9wKCk7IC8vIHRoZSB0b2tlbiBhZnRlciBcXG5vZXhwYW5kIGlzIGludGVycHJldGVkIGFzIGlmIGl0cyBtZWFuaW5nXG4gICAgICAgIC8vIHdlcmUg4oCYXFxyZWxheOKAmVxuXG4gICAgICAgIGlmICh0b2tlbi50cmVhdEFzUmVsYXgpIHtcbiAgICAgICAgICB0b2tlbi50ZXh0ID0gXCJcXFxccmVsYXhcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgIH1cbiAgICB9IC8vIEZsb3cgdW5hYmxlIHRvIGZpZ3VyZSBvdXQgdGhhdCB0aGlzIHBhdGh3YXkgaXMgaW1wb3NzaWJsZS5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvNDgwOFxuXG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnJlYWNoYWJsZVxuICB9XG4gIC8qKlxuICAgKiBGdWxseSBleHBhbmQgdGhlIGdpdmVuIG1hY3JvIG5hbWUgYW5kIHJldHVybiB0aGUgcmVzdWx0aW5nIGxpc3Qgb2ZcbiAgICogdG9rZW5zLCBvciByZXR1cm4gYHVuZGVmaW5lZGAgaWYgbm8gc3VjaCBtYWNybyBpcyBkZWZpbmVkLlxuICAgKi9cblxuXG4gIGV4cGFuZE1hY3JvKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5tYWNyb3MuaGFzKG5hbWUpID8gdGhpcy5leHBhbmRUb2tlbnMoW25ldyBUb2tlbihuYW1lKV0pIDogdW5kZWZpbmVkO1xuICB9XG4gIC8qKlxuICAgKiBGdWxseSBleHBhbmQgdGhlIGdpdmVuIHRva2VuIHN0cmVhbSBhbmQgcmV0dXJuIHRoZSByZXN1bHRpbmcgbGlzdCBvZlxuICAgKiB0b2tlbnMuICBOb3RlIHRoYXQgdGhlIGlucHV0IHRva2VucyBhcmUgaW4gcmV2ZXJzZSBvcmRlciwgYnV0IHRoZVxuICAgKiBvdXRwdXQgdG9rZW5zIGFyZSBpbiBmb3J3YXJkIG9yZGVyLlxuICAgKi9cblxuXG4gIGV4cGFuZFRva2Vucyh0b2tlbnMpIHtcbiAgICBjb25zdCBvdXRwdXQgPSBbXTtcbiAgICBjb25zdCBvbGRTdGFja0xlbmd0aCA9IHRoaXMuc3RhY2subGVuZ3RoO1xuICAgIHRoaXMucHVzaFRva2Vucyh0b2tlbnMpO1xuXG4gICAgd2hpbGUgKHRoaXMuc3RhY2subGVuZ3RoID4gb2xkU3RhY2tMZW5ndGgpIHtcbiAgICAgIC8vIEV4cGFuZCBvbmx5IGV4cGFuZGFibGUgdG9rZW5zXG4gICAgICBpZiAodGhpcy5leHBhbmRPbmNlKHRydWUpID09PSBmYWxzZSkge1xuICAgICAgICAvLyBmdWxseSBleHBhbmRlZFxuICAgICAgICBjb25zdCB0b2tlbiA9IHRoaXMuc3RhY2sucG9wKCk7XG5cbiAgICAgICAgaWYgKHRva2VuLnRyZWF0QXNSZWxheCkge1xuICAgICAgICAgIC8vIHRoZSBleHBhbnNpb24gb2YgXFxub2V4cGFuZCBpcyB0aGUgdG9rZW4gaXRzZWxmXG4gICAgICAgICAgdG9rZW4ubm9leHBhbmQgPSBmYWxzZTtcbiAgICAgICAgICB0b2tlbi50cmVhdEFzUmVsYXggPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG91dHB1dC5wdXNoKHRva2VuKTtcbiAgICAgIH1cbiAgICB9IC8vIENvdW50IGFsbCBvZiB0aGVzZSB0b2tlbnMgYXMgYWRkaXRpb25hbCBleHBhbnNpb25zLCB0byBwcmV2ZW50XG4gICAgLy8gZXhwb25lbnRpYWwgYmxvd3VwIGZyb20gbGluZWFybHkgbWFueSBcXGVkZWYncy5cblxuXG4gICAgdGhpcy5jb3VudEV4cGFuc2lvbihvdXRwdXQubGVuZ3RoKTtcbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG4gIC8qKlxuICAgKiBGdWxseSBleHBhbmQgdGhlIGdpdmVuIG1hY3JvIG5hbWUgYW5kIHJldHVybiB0aGUgcmVzdWx0IGFzIGEgc3RyaW5nLFxuICAgKiBvciByZXR1cm4gYHVuZGVmaW5lZGAgaWYgbm8gc3VjaCBtYWNybyBpcyBkZWZpbmVkLlxuICAgKi9cblxuXG4gIGV4cGFuZE1hY3JvQXNUZXh0KG5hbWUpIHtcbiAgICBjb25zdCB0b2tlbnMgPSB0aGlzLmV4cGFuZE1hY3JvKG5hbWUpO1xuXG4gICAgaWYgKHRva2Vucykge1xuICAgICAgcmV0dXJuIHRva2Vucy5tYXAodG9rZW4gPT4gdG9rZW4udGV4dCkuam9pbihcIlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGV4cGFuZGVkIG1hY3JvIGFzIGEgcmV2ZXJzZWQgYXJyYXkgb2YgdG9rZW5zIGFuZCBhIG1hY3JvXG4gICAqIGFyZ3VtZW50IGNvdW50LiAgT3IgcmV0dXJucyBgbnVsbGAgaWYgbm8gc3VjaCBtYWNyby5cbiAgICovXG5cblxuICBfZ2V0RXhwYW5zaW9uKG5hbWUpIHtcbiAgICBjb25zdCBkZWZpbml0aW9uID0gdGhpcy5tYWNyb3MuZ2V0KG5hbWUpO1xuXG4gICAgaWYgKGRlZmluaXRpb24gPT0gbnVsbCkge1xuICAgICAgLy8gbWFpbmx5IGNoZWNraW5nIGZvciB1bmRlZmluZWQgaGVyZVxuICAgICAgcmV0dXJuIGRlZmluaXRpb247XG4gICAgfSAvLyBJZiBhIHNpbmdsZSBjaGFyYWN0ZXIgaGFzIGFuIGFzc29jaWF0ZWQgY2F0Y29kZSBvdGhlciB0aGFuIDEzXG4gICAgLy8gKGFjdGl2ZSBjaGFyYWN0ZXIpLCB0aGVuIGRvbid0IGV4cGFuZCBpdC5cblxuXG4gICAgaWYgKG5hbWUubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBjYXRjb2RlID0gdGhpcy5sZXhlci5jYXRjb2Rlc1tuYW1lXTtcblxuICAgICAgaWYgKGNhdGNvZGUgIT0gbnVsbCAmJiBjYXRjb2RlICE9PSAxMykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZXhwYW5zaW9uID0gdHlwZW9mIGRlZmluaXRpb24gPT09IFwiZnVuY3Rpb25cIiA/IGRlZmluaXRpb24odGhpcykgOiBkZWZpbml0aW9uO1xuXG4gICAgaWYgKHR5cGVvZiBleHBhbnNpb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGxldCBudW1BcmdzID0gMDtcblxuICAgICAgaWYgKGV4cGFuc2lvbi5pbmRleE9mKFwiI1wiKSAhPT0gLTEpIHtcbiAgICAgICAgY29uc3Qgc3RyaXBwZWQgPSBleHBhbnNpb24ucmVwbGFjZSgvIyMvZywgXCJcIik7XG5cbiAgICAgICAgd2hpbGUgKHN0cmlwcGVkLmluZGV4T2YoXCIjXCIgKyAobnVtQXJncyArIDEpKSAhPT0gLTEpIHtcbiAgICAgICAgICArK251bUFyZ3M7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgYm9keUxleGVyID0gbmV3IExleGVyKGV4cGFuc2lvbiwgdGhpcy5zZXR0aW5ncyk7XG4gICAgICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgICAgIGxldCB0b2sgPSBib2R5TGV4ZXIubGV4KCk7XG5cbiAgICAgIHdoaWxlICh0b2sudGV4dCAhPT0gXCJFT0ZcIikge1xuICAgICAgICB0b2tlbnMucHVzaCh0b2spO1xuICAgICAgICB0b2sgPSBib2R5TGV4ZXIubGV4KCk7XG4gICAgICB9XG5cbiAgICAgIHRva2Vucy5yZXZlcnNlKCk7IC8vIHRvIGZpdCBpbiB3aXRoIHN0YWNrIHVzaW5nIHB1c2ggYW5kIHBvcFxuXG4gICAgICBjb25zdCBleHBhbmRlZCA9IHtcbiAgICAgICAgdG9rZW5zLFxuICAgICAgICBudW1BcmdzXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGV4cGFuZGVkO1xuICAgIH1cblxuICAgIHJldHVybiBleHBhbnNpb247XG4gIH1cbiAgLyoqXG4gICAqIERldGVybWluZSB3aGV0aGVyIGEgY29tbWFuZCBpcyBjdXJyZW50bHkgXCJkZWZpbmVkXCIgKGhhcyBzb21lXG4gICAqIGZ1bmN0aW9uYWxpdHkpLCBtZWFuaW5nIHRoYXQgaXQncyBhIG1hY3JvIChpbiB0aGUgY3VycmVudCBncm91cCksXG4gICAqIGEgZnVuY3Rpb24sIGEgc3ltYm9sLCBvciBvbmUgb2YgdGhlIHNwZWNpYWwgY29tbWFuZHMgbGlzdGVkIGluXG4gICAqIGBpbXBsaWNpdENvbW1hbmRzYC5cbiAgICovXG5cblxuICBpc0RlZmluZWQobmFtZSkge1xuICAgIHJldHVybiB0aGlzLm1hY3Jvcy5oYXMobmFtZSkgfHwgc3JjX2Z1bmN0aW9ucy5oYXNPd25Qcm9wZXJ0eShuYW1lKSB8fCBzcmNfc3ltYm9scy5tYXRoLmhhc093blByb3BlcnR5KG5hbWUpIHx8IHNyY19zeW1ib2xzLnRleHQuaGFzT3duUHJvcGVydHkobmFtZSkgfHwgaW1wbGljaXRDb21tYW5kcy5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcbiAgfVxuICAvKipcbiAgICogRGV0ZXJtaW5lIHdoZXRoZXIgYSBjb21tYW5kIGlzIGV4cGFuZGFibGUuXG4gICAqL1xuXG5cbiAgaXNFeHBhbmRhYmxlKG5hbWUpIHtcbiAgICBjb25zdCBtYWNybyA9IHRoaXMubWFjcm9zLmdldChuYW1lKTtcbiAgICByZXR1cm4gbWFjcm8gIT0gbnVsbCA/IHR5cGVvZiBtYWNybyA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgbWFjcm8gPT09IFwiZnVuY3Rpb25cIiB8fCAhbWFjcm8udW5leHBhbmRhYmxlIDogc3JjX2Z1bmN0aW9ucy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiAhc3JjX2Z1bmN0aW9uc1tuYW1lXS5wcmltaXRpdmU7XG4gIH1cblxufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3VuaWNvZGVTdXBPclN1Yi5qc1xuLy8gSGVscGVycyBmb3IgUGFyc2VyLmpzIGhhbmRsaW5nIG9mIFVuaWNvZGUgKHN1YnxzdXBlcilzY3JpcHQgY2hhcmFjdGVycy5cbmNvbnN0IHVuaWNvZGVTdWJSZWdFeCA9IC9eW+KCiuKCi+KCjOKCjeKCjuKCgOKCgeKCguKCg+KChOKCheKChuKCh+KCiOKCieKCkOKCkeKCleG1ouKxvOKCluKCl+KCmOKCmeKCkuKCmuG1o+KCm+KCnOG1pOG1peKCk+G1puG1p+G1qOG1qeG1ql0vO1xuY29uc3QgdVN1YnNBbmRTdXBzID0gT2JqZWN0LmZyZWV6ZSh7XG4gICfigoonOiAnKycsXG4gICfigosnOiAnLScsXG4gICfigownOiAnPScsXG4gICfigo0nOiAnKCcsXG4gICfigo4nOiAnKScsXG4gICfigoAnOiAnMCcsXG4gICfigoEnOiAnMScsXG4gICfigoInOiAnMicsXG4gICfigoMnOiAnMycsXG4gICfigoQnOiAnNCcsXG4gICfigoUnOiAnNScsXG4gICfigoYnOiAnNicsXG4gICfigocnOiAnNycsXG4gICfigognOiAnOCcsXG4gICfigoknOiAnOScsXG4gICdcXHUyMDkwJzogJ2EnLFxuICAnXFx1MjA5MSc6ICdlJyxcbiAgJ1xcdTIwOTUnOiAnaCcsXG4gICdcXHUxRDYyJzogJ2knLFxuICAnXFx1MkM3Qyc6ICdqJyxcbiAgJ1xcdTIwOTYnOiAnaycsXG4gICdcXHUyMDk3JzogJ2wnLFxuICAnXFx1MjA5OCc6ICdtJyxcbiAgJ1xcdTIwOTknOiAnbicsXG4gICdcXHUyMDkyJzogJ28nLFxuICAnXFx1MjA5QSc6ICdwJyxcbiAgJ1xcdTFENjMnOiAncicsXG4gICdcXHUyMDlCJzogJ3MnLFxuICAnXFx1MjA5Qyc6ICd0JyxcbiAgJ1xcdTFENjQnOiAndScsXG4gICdcXHUxRDY1JzogJ3YnLFxuICAnXFx1MjA5Myc6ICd4JyxcbiAgJ1xcdTFENjYnOiAnzrInLFxuICAnXFx1MUQ2Nyc6ICfOsycsXG4gICdcXHUxRDY4JzogJ8+BJyxcbiAgJ1xcdTFENjknOiAnXFx1MDNkNScsXG4gICdcXHUxRDZBJzogJ8+HJyxcbiAgJ+KBuic6ICcrJyxcbiAgJ+KBuyc6ICctJyxcbiAgJ+KBvCc6ICc9JyxcbiAgJ+KBvSc6ICcoJyxcbiAgJ+KBvic6ICcpJyxcbiAgJ+KBsCc6ICcwJyxcbiAgJ8K5JzogJzEnLFxuICAnwrInOiAnMicsXG4gICfCsyc6ICczJyxcbiAgJ+KBtCc6ICc0JyxcbiAgJ+KBtSc6ICc1JyxcbiAgJ+KBtic6ICc2JyxcbiAgJ+KBtyc6ICc3JyxcbiAgJ+KBuCc6ICc4JyxcbiAgJ+KBuSc6ICc5JyxcbiAgJ1xcdTFEMkMnOiAnQScsXG4gICdcXHUxRDJFJzogJ0InLFxuICAnXFx1MUQzMCc6ICdEJyxcbiAgJ1xcdTFEMzEnOiAnRScsXG4gICdcXHUxRDMzJzogJ0cnLFxuICAnXFx1MUQzNCc6ICdIJyxcbiAgJ1xcdTFEMzUnOiAnSScsXG4gICdcXHUxRDM2JzogJ0onLFxuICAnXFx1MUQzNyc6ICdLJyxcbiAgJ1xcdTFEMzgnOiAnTCcsXG4gICdcXHUxRDM5JzogJ00nLFxuICAnXFx1MUQzQSc6ICdOJyxcbiAgJ1xcdTFEM0MnOiAnTycsXG4gICdcXHUxRDNFJzogJ1AnLFxuICAnXFx1MUQzRic6ICdSJyxcbiAgJ1xcdTFENDAnOiAnVCcsXG4gICdcXHUxRDQxJzogJ1UnLFxuICAnXFx1MkM3RCc6ICdWJyxcbiAgJ1xcdTFENDInOiAnVycsXG4gICdcXHUxRDQzJzogJ2EnLFxuICAnXFx1MUQ0Nyc6ICdiJyxcbiAgJ1xcdTFEOUMnOiAnYycsXG4gICdcXHUxRDQ4JzogJ2QnLFxuICAnXFx1MUQ0OSc6ICdlJyxcbiAgJ1xcdTFEQTAnOiAnZicsXG4gICdcXHUxRDREJzogJ2cnLFxuICAnXFx1MDJCMCc6ICdoJyxcbiAgJ1xcdTIwNzEnOiAnaScsXG4gICdcXHUwMkIyJzogJ2onLFxuICAnXFx1MUQ0Ric6ICdrJyxcbiAgJ1xcdTAyRTEnOiAnbCcsXG4gICdcXHUxRDUwJzogJ20nLFxuICAnXFx1MjA3Ric6ICduJyxcbiAgJ1xcdTFENTInOiAnbycsXG4gICdcXHUxRDU2JzogJ3AnLFxuICAnXFx1MDJCMyc6ICdyJyxcbiAgJ1xcdTAyRTInOiAncycsXG4gICdcXHUxRDU3JzogJ3QnLFxuICAnXFx1MUQ1OCc6ICd1JyxcbiAgJ1xcdTFENUInOiAndicsXG4gICdcXHUwMkI3JzogJ3cnLFxuICAnXFx1MDJFMyc6ICd4JyxcbiAgJ1xcdTAyQjgnOiAneScsXG4gICdcXHUxREJCJzogJ3onLFxuICAnXFx1MUQ1RCc6ICfOsicsXG4gICdcXHUxRDVFJzogJ86zJyxcbiAgJ1xcdTFENUYnOiAnzrQnLFxuICAnXFx1MUQ2MCc6ICdcXHUwM2Q1JyxcbiAgJ1xcdTFENjEnOiAnz4cnLFxuICAnXFx1MURCRic6ICfOuCdcbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL1BhcnNlci5qc1xuLyogZXNsaW50IG5vLWNvbnN0YW50LWNvbmRpdGlvbjowICovXG5cblxuXG5cblxuXG5cblxuXG5cbiAvLyBQcmUtZXZhbHVhdGUgYm90aCBtb2R1bGVzIGFzIHVuaWNvZGVTeW1ib2xzIHJlcXVpcmUgU3RyaW5nLm5vcm1hbGl6ZSgpXG5cbmNvbnN0IHVuaWNvZGVBY2NlbnRzID0ge1xuICBcIsyBXCI6IHtcbiAgICBcInRleHRcIjogXCJcXFxcJ1wiLFxuICAgIFwibWF0aFwiOiBcIlxcXFxhY3V0ZVwiXG4gIH0sXG4gIFwizIBcIjoge1xuICAgIFwidGV4dFwiOiBcIlxcXFxgXCIsXG4gICAgXCJtYXRoXCI6IFwiXFxcXGdyYXZlXCJcbiAgfSxcbiAgXCLMiFwiOiB7XG4gICAgXCJ0ZXh0XCI6IFwiXFxcXFxcXCJcIixcbiAgICBcIm1hdGhcIjogXCJcXFxcZGRvdFwiXG4gIH0sXG4gIFwizINcIjoge1xuICAgIFwidGV4dFwiOiBcIlxcXFx+XCIsXG4gICAgXCJtYXRoXCI6IFwiXFxcXHRpbGRlXCJcbiAgfSxcbiAgXCLMhFwiOiB7XG4gICAgXCJ0ZXh0XCI6IFwiXFxcXD1cIixcbiAgICBcIm1hdGhcIjogXCJcXFxcYmFyXCJcbiAgfSxcbiAgXCLMhlwiOiB7XG4gICAgXCJ0ZXh0XCI6IFwiXFxcXHVcIixcbiAgICBcIm1hdGhcIjogXCJcXFxcYnJldmVcIlxuICB9LFxuICBcIsyMXCI6IHtcbiAgICBcInRleHRcIjogXCJcXFxcdlwiLFxuICAgIFwibWF0aFwiOiBcIlxcXFxjaGVja1wiXG4gIH0sXG4gIFwizIJcIjoge1xuICAgIFwidGV4dFwiOiBcIlxcXFxeXCIsXG4gICAgXCJtYXRoXCI6IFwiXFxcXGhhdFwiXG4gIH0sXG4gIFwizIdcIjoge1xuICAgIFwidGV4dFwiOiBcIlxcXFwuXCIsXG4gICAgXCJtYXRoXCI6IFwiXFxcXGRvdFwiXG4gIH0sXG4gIFwizIpcIjoge1xuICAgIFwidGV4dFwiOiBcIlxcXFxyXCIsXG4gICAgXCJtYXRoXCI6IFwiXFxcXG1hdGhyaW5nXCJcbiAgfSxcbiAgXCLMi1wiOiB7XG4gICAgXCJ0ZXh0XCI6IFwiXFxcXEhcIlxuICB9LFxuICBcIsynXCI6IHtcbiAgICBcInRleHRcIjogXCJcXFxcY1wiXG4gIH1cbn07XG5jb25zdCB1bmljb2RlU3ltYm9scyA9IHtcbiAgXCLDoVwiOiBcImHMgVwiLFxuICBcIsOgXCI6IFwiYcyAXCIsXG4gIFwiw6RcIjogXCJhzIhcIixcbiAgXCLHn1wiOiBcImHMiMyEXCIsXG4gIFwiw6NcIjogXCJhzINcIixcbiAgXCLEgVwiOiBcImHMhFwiLFxuICBcIsSDXCI6IFwiYcyGXCIsXG4gIFwi4bqvXCI6IFwiYcyGzIFcIixcbiAgXCLhurFcIjogXCJhzIbMgFwiLFxuICBcIuG6tVwiOiBcImHMhsyDXCIsXG4gIFwix45cIjogXCJhzIxcIixcbiAgXCLDolwiOiBcImHMglwiLFxuICBcIuG6pVwiOiBcImHMgsyBXCIsXG4gIFwi4bqnXCI6IFwiYcyCzIBcIixcbiAgXCLhuqtcIjogXCJhzILMg1wiLFxuICBcIsinXCI6IFwiYcyHXCIsXG4gIFwix6FcIjogXCJhzIfMhFwiLFxuICBcIsOlXCI6IFwiYcyKXCIsXG4gIFwix7tcIjogXCJhzIrMgVwiLFxuICBcIuG4g1wiOiBcImLMh1wiLFxuICBcIsSHXCI6IFwiY8yBXCIsXG4gIFwi4biJXCI6IFwiY8ynzIFcIixcbiAgXCLEjVwiOiBcImPMjFwiLFxuICBcIsSJXCI6IFwiY8yCXCIsXG4gIFwixItcIjogXCJjzIdcIixcbiAgXCLDp1wiOiBcImPMp1wiLFxuICBcIsSPXCI6IFwiZMyMXCIsXG4gIFwi4biLXCI6IFwiZMyHXCIsXG4gIFwi4biRXCI6IFwiZMynXCIsXG4gIFwiw6lcIjogXCJlzIFcIixcbiAgXCLDqFwiOiBcImXMgFwiLFxuICBcIsOrXCI6IFwiZcyIXCIsXG4gIFwi4bq9XCI6IFwiZcyDXCIsXG4gIFwixJNcIjogXCJlzIRcIixcbiAgXCLhuJdcIjogXCJlzITMgVwiLFxuICBcIuG4lVwiOiBcImXMhMyAXCIsXG4gIFwixJVcIjogXCJlzIZcIixcbiAgXCLhuJ1cIjogXCJlzKfMhlwiLFxuICBcIsSbXCI6IFwiZcyMXCIsXG4gIFwiw6pcIjogXCJlzIJcIixcbiAgXCLhur9cIjogXCJlzILMgVwiLFxuICBcIuG7gVwiOiBcImXMgsyAXCIsXG4gIFwi4buFXCI6IFwiZcyCzINcIixcbiAgXCLEl1wiOiBcImXMh1wiLFxuICBcIsipXCI6IFwiZcynXCIsXG4gIFwi4bifXCI6IFwiZsyHXCIsXG4gIFwix7VcIjogXCJnzIFcIixcbiAgXCLhuKFcIjogXCJnzIRcIixcbiAgXCLEn1wiOiBcImfMhlwiLFxuICBcIsenXCI6IFwiZ8yMXCIsXG4gIFwixJ1cIjogXCJnzIJcIixcbiAgXCLEoVwiOiBcImfMh1wiLFxuICBcIsSjXCI6IFwiZ8ynXCIsXG4gIFwi4binXCI6IFwiaMyIXCIsXG4gIFwiyJ9cIjogXCJozIxcIixcbiAgXCLEpVwiOiBcImjMglwiLFxuICBcIuG4o1wiOiBcImjMh1wiLFxuICBcIuG4qVwiOiBcImjMp1wiLFxuICBcIsOtXCI6IFwiacyBXCIsXG4gIFwiw6xcIjogXCJpzIBcIixcbiAgXCLDr1wiOiBcImnMiFwiLFxuICBcIuG4r1wiOiBcImnMiMyBXCIsXG4gIFwixKlcIjogXCJpzINcIixcbiAgXCLEq1wiOiBcImnMhFwiLFxuICBcIsStXCI6IFwiacyGXCIsXG4gIFwix5BcIjogXCJpzIxcIixcbiAgXCLDrlwiOiBcImnMglwiLFxuICBcIsewXCI6IFwiasyMXCIsXG4gIFwixLVcIjogXCJqzIJcIixcbiAgXCLhuLFcIjogXCJrzIFcIixcbiAgXCLHqVwiOiBcImvMjFwiLFxuICBcIsS3XCI6IFwia8ynXCIsXG4gIFwixLpcIjogXCJszIFcIixcbiAgXCLEvlwiOiBcImzMjFwiLFxuICBcIsS8XCI6IFwibMynXCIsXG4gIFwi4bi/XCI6IFwibcyBXCIsXG4gIFwi4bmBXCI6IFwibcyHXCIsXG4gIFwixYRcIjogXCJuzIFcIixcbiAgXCLHuVwiOiBcIm7MgFwiLFxuICBcIsOxXCI6IFwibsyDXCIsXG4gIFwixYhcIjogXCJuzIxcIixcbiAgXCLhuYVcIjogXCJuzIdcIixcbiAgXCLFhlwiOiBcIm7Mp1wiLFxuICBcIsOzXCI6IFwib8yBXCIsXG4gIFwiw7JcIjogXCJvzIBcIixcbiAgXCLDtlwiOiBcIm/MiFwiLFxuICBcIsirXCI6IFwib8yIzIRcIixcbiAgXCLDtVwiOiBcIm/Mg1wiLFxuICBcIuG5jVwiOiBcIm/Mg8yBXCIsXG4gIFwi4bmPXCI6IFwib8yDzIhcIixcbiAgXCLIrVwiOiBcIm/Mg8yEXCIsXG4gIFwixY1cIjogXCJvzIRcIixcbiAgXCLhuZNcIjogXCJvzITMgVwiLFxuICBcIuG5kVwiOiBcIm/MhMyAXCIsXG4gIFwixY9cIjogXCJvzIZcIixcbiAgXCLHklwiOiBcIm/MjFwiLFxuICBcIsO0XCI6IFwib8yCXCIsXG4gIFwi4buRXCI6IFwib8yCzIFcIixcbiAgXCLhu5NcIjogXCJvzILMgFwiLFxuICBcIuG7l1wiOiBcIm/MgsyDXCIsXG4gIFwiyK9cIjogXCJvzIdcIixcbiAgXCLIsVwiOiBcIm/Mh8yEXCIsXG4gIFwixZFcIjogXCJvzItcIixcbiAgXCLhuZVcIjogXCJwzIFcIixcbiAgXCLhuZdcIjogXCJwzIdcIixcbiAgXCLFlVwiOiBcInLMgVwiLFxuICBcIsWZXCI6IFwicsyMXCIsXG4gIFwi4bmZXCI6IFwicsyHXCIsXG4gIFwixZdcIjogXCJyzKdcIixcbiAgXCLFm1wiOiBcInPMgVwiLFxuICBcIuG5pVwiOiBcInPMgcyHXCIsXG4gIFwixaFcIjogXCJzzIxcIixcbiAgXCLhuadcIjogXCJzzIzMh1wiLFxuICBcIsWdXCI6IFwic8yCXCIsXG4gIFwi4bmhXCI6IFwic8yHXCIsXG4gIFwixZ9cIjogXCJzzKdcIixcbiAgXCLhupdcIjogXCJ0zIhcIixcbiAgXCLFpVwiOiBcInTMjFwiLFxuICBcIuG5q1wiOiBcInTMh1wiLFxuICBcIsWjXCI6IFwidMynXCIsXG4gIFwiw7pcIjogXCJ1zIFcIixcbiAgXCLDuVwiOiBcInXMgFwiLFxuICBcIsO8XCI6IFwidcyIXCIsXG4gIFwix5hcIjogXCJ1zIjMgVwiLFxuICBcIsecXCI6IFwidcyIzIBcIixcbiAgXCLHllwiOiBcInXMiMyEXCIsXG4gIFwix5pcIjogXCJ1zIjMjFwiLFxuICBcIsWpXCI6IFwidcyDXCIsXG4gIFwi4bm5XCI6IFwidcyDzIFcIixcbiAgXCLFq1wiOiBcInXMhFwiLFxuICBcIuG5u1wiOiBcInXMhMyIXCIsXG4gIFwixa1cIjogXCJ1zIZcIixcbiAgXCLHlFwiOiBcInXMjFwiLFxuICBcIsO7XCI6IFwidcyCXCIsXG4gIFwixa9cIjogXCJ1zIpcIixcbiAgXCLFsVwiOiBcInXMi1wiLFxuICBcIuG5vVwiOiBcInbMg1wiLFxuICBcIuG6g1wiOiBcInfMgVwiLFxuICBcIuG6gVwiOiBcInfMgFwiLFxuICBcIuG6hVwiOiBcInfMiFwiLFxuICBcIsW1XCI6IFwid8yCXCIsXG4gIFwi4bqHXCI6IFwid8yHXCIsXG4gIFwi4bqYXCI6IFwid8yKXCIsXG4gIFwi4bqNXCI6IFwieMyIXCIsXG4gIFwi4bqLXCI6IFwieMyHXCIsXG4gIFwiw71cIjogXCJ5zIFcIixcbiAgXCLhu7NcIjogXCJ5zIBcIixcbiAgXCLDv1wiOiBcInnMiFwiLFxuICBcIuG7uVwiOiBcInnMg1wiLFxuICBcIsizXCI6IFwiecyEXCIsXG4gIFwixbdcIjogXCJ5zIJcIixcbiAgXCLhuo9cIjogXCJ5zIdcIixcbiAgXCLhuplcIjogXCJ5zIpcIixcbiAgXCLFulwiOiBcInrMgVwiLFxuICBcIsW+XCI6IFwiesyMXCIsXG4gIFwi4bqRXCI6IFwiesyCXCIsXG4gIFwixbxcIjogXCJ6zIdcIixcbiAgXCLDgVwiOiBcIkHMgVwiLFxuICBcIsOAXCI6IFwiQcyAXCIsXG4gIFwiw4RcIjogXCJBzIhcIixcbiAgXCLHnlwiOiBcIkHMiMyEXCIsXG4gIFwiw4NcIjogXCJBzINcIixcbiAgXCLEgFwiOiBcIkHMhFwiLFxuICBcIsSCXCI6IFwiQcyGXCIsXG4gIFwi4bquXCI6IFwiQcyGzIFcIixcbiAgXCLhurBcIjogXCJBzIbMgFwiLFxuICBcIuG6tFwiOiBcIkHMhsyDXCIsXG4gIFwix41cIjogXCJBzIxcIixcbiAgXCLDglwiOiBcIkHMglwiLFxuICBcIuG6pFwiOiBcIkHMgsyBXCIsXG4gIFwi4bqmXCI6IFwiQcyCzIBcIixcbiAgXCLhuqpcIjogXCJBzILMg1wiLFxuICBcIsimXCI6IFwiQcyHXCIsXG4gIFwix6BcIjogXCJBzIfMhFwiLFxuICBcIsOFXCI6IFwiQcyKXCIsXG4gIFwix7pcIjogXCJBzIrMgVwiLFxuICBcIuG4glwiOiBcIkLMh1wiLFxuICBcIsSGXCI6IFwiQ8yBXCIsXG4gIFwi4biIXCI6IFwiQ8ynzIFcIixcbiAgXCLEjFwiOiBcIkPMjFwiLFxuICBcIsSIXCI6IFwiQ8yCXCIsXG4gIFwixIpcIjogXCJDzIdcIixcbiAgXCLDh1wiOiBcIkPMp1wiLFxuICBcIsSOXCI6IFwiRMyMXCIsXG4gIFwi4biKXCI6IFwiRMyHXCIsXG4gIFwi4biQXCI6IFwiRMynXCIsXG4gIFwiw4lcIjogXCJFzIFcIixcbiAgXCLDiFwiOiBcIkXMgFwiLFxuICBcIsOLXCI6IFwiRcyIXCIsXG4gIFwi4bq8XCI6IFwiRcyDXCIsXG4gIFwixJJcIjogXCJFzIRcIixcbiAgXCLhuJZcIjogXCJFzITMgVwiLFxuICBcIuG4lFwiOiBcIkXMhMyAXCIsXG4gIFwixJRcIjogXCJFzIZcIixcbiAgXCLhuJxcIjogXCJFzKfMhlwiLFxuICBcIsSaXCI6IFwiRcyMXCIsXG4gIFwiw4pcIjogXCJFzIJcIixcbiAgXCLhur5cIjogXCJFzILMgVwiLFxuICBcIuG7gFwiOiBcIkXMgsyAXCIsXG4gIFwi4buEXCI6IFwiRcyCzINcIixcbiAgXCLEllwiOiBcIkXMh1wiLFxuICBcIsioXCI6IFwiRcynXCIsXG4gIFwi4bieXCI6IFwiRsyHXCIsXG4gIFwix7RcIjogXCJHzIFcIixcbiAgXCLhuKBcIjogXCJHzIRcIixcbiAgXCLEnlwiOiBcIkfMhlwiLFxuICBcIsemXCI6IFwiR8yMXCIsXG4gIFwixJxcIjogXCJHzIJcIixcbiAgXCLEoFwiOiBcIkfMh1wiLFxuICBcIsSiXCI6IFwiR8ynXCIsXG4gIFwi4bimXCI6IFwiSMyIXCIsXG4gIFwiyJ5cIjogXCJIzIxcIixcbiAgXCLEpFwiOiBcIkjMglwiLFxuICBcIuG4olwiOiBcIkjMh1wiLFxuICBcIuG4qFwiOiBcIkjMp1wiLFxuICBcIsONXCI6IFwiScyBXCIsXG4gIFwiw4xcIjogXCJJzIBcIixcbiAgXCLDj1wiOiBcIknMiFwiLFxuICBcIuG4rlwiOiBcIknMiMyBXCIsXG4gIFwixKhcIjogXCJJzINcIixcbiAgXCLEqlwiOiBcIknMhFwiLFxuICBcIsSsXCI6IFwiScyGXCIsXG4gIFwix49cIjogXCJJzIxcIixcbiAgXCLDjlwiOiBcIknMglwiLFxuICBcIsSwXCI6IFwiScyHXCIsXG4gIFwixLRcIjogXCJKzIJcIixcbiAgXCLhuLBcIjogXCJLzIFcIixcbiAgXCLHqFwiOiBcIkvMjFwiLFxuICBcIsS2XCI6IFwiS8ynXCIsXG4gIFwixLlcIjogXCJMzIFcIixcbiAgXCLEvVwiOiBcIkzMjFwiLFxuICBcIsS7XCI6IFwiTMynXCIsXG4gIFwi4bi+XCI6IFwiTcyBXCIsXG4gIFwi4bmAXCI6IFwiTcyHXCIsXG4gIFwixYNcIjogXCJOzIFcIixcbiAgXCLHuFwiOiBcIk7MgFwiLFxuICBcIsORXCI6IFwiTsyDXCIsXG4gIFwixYdcIjogXCJOzIxcIixcbiAgXCLhuYRcIjogXCJOzIdcIixcbiAgXCLFhVwiOiBcIk7Mp1wiLFxuICBcIsOTXCI6IFwiT8yBXCIsXG4gIFwiw5JcIjogXCJPzIBcIixcbiAgXCLDllwiOiBcIk/MiFwiLFxuICBcIsiqXCI6IFwiT8yIzIRcIixcbiAgXCLDlVwiOiBcIk/Mg1wiLFxuICBcIuG5jFwiOiBcIk/Mg8yBXCIsXG4gIFwi4bmOXCI6IFwiT8yDzIhcIixcbiAgXCLIrFwiOiBcIk/Mg8yEXCIsXG4gIFwixYxcIjogXCJPzIRcIixcbiAgXCLhuZJcIjogXCJPzITMgVwiLFxuICBcIuG5kFwiOiBcIk/MhMyAXCIsXG4gIFwixY5cIjogXCJPzIZcIixcbiAgXCLHkVwiOiBcIk/MjFwiLFxuICBcIsOUXCI6IFwiT8yCXCIsXG4gIFwi4buQXCI6IFwiT8yCzIFcIixcbiAgXCLhu5JcIjogXCJPzILMgFwiLFxuICBcIuG7llwiOiBcIk/MgsyDXCIsXG4gIFwiyK5cIjogXCJPzIdcIixcbiAgXCLIsFwiOiBcIk/Mh8yEXCIsXG4gIFwixZBcIjogXCJPzItcIixcbiAgXCLhuZRcIjogXCJQzIFcIixcbiAgXCLhuZZcIjogXCJQzIdcIixcbiAgXCLFlFwiOiBcIlLMgVwiLFxuICBcIsWYXCI6IFwiUsyMXCIsXG4gIFwi4bmYXCI6IFwiUsyHXCIsXG4gIFwixZZcIjogXCJSzKdcIixcbiAgXCLFmlwiOiBcIlPMgVwiLFxuICBcIuG5pFwiOiBcIlPMgcyHXCIsXG4gIFwixaBcIjogXCJTzIxcIixcbiAgXCLhuaZcIjogXCJTzIzMh1wiLFxuICBcIsWcXCI6IFwiU8yCXCIsXG4gIFwi4bmgXCI6IFwiU8yHXCIsXG4gIFwixZ5cIjogXCJTzKdcIixcbiAgXCLFpFwiOiBcIlTMjFwiLFxuICBcIuG5qlwiOiBcIlTMh1wiLFxuICBcIsWiXCI6IFwiVMynXCIsXG4gIFwiw5pcIjogXCJVzIFcIixcbiAgXCLDmVwiOiBcIlXMgFwiLFxuICBcIsOcXCI6IFwiVcyIXCIsXG4gIFwix5dcIjogXCJVzIjMgVwiLFxuICBcIsebXCI6IFwiVcyIzIBcIixcbiAgXCLHlVwiOiBcIlXMiMyEXCIsXG4gIFwix5lcIjogXCJVzIjMjFwiLFxuICBcIsWoXCI6IFwiVcyDXCIsXG4gIFwi4bm4XCI6IFwiVcyDzIFcIixcbiAgXCLFqlwiOiBcIlXMhFwiLFxuICBcIuG5ulwiOiBcIlXMhMyIXCIsXG4gIFwixaxcIjogXCJVzIZcIixcbiAgXCLHk1wiOiBcIlXMjFwiLFxuICBcIsObXCI6IFwiVcyCXCIsXG4gIFwixa5cIjogXCJVzIpcIixcbiAgXCLFsFwiOiBcIlXMi1wiLFxuICBcIuG5vFwiOiBcIlbMg1wiLFxuICBcIuG6glwiOiBcIlfMgVwiLFxuICBcIuG6gFwiOiBcIlfMgFwiLFxuICBcIuG6hFwiOiBcIlfMiFwiLFxuICBcIsW0XCI6IFwiV8yCXCIsXG4gIFwi4bqGXCI6IFwiV8yHXCIsXG4gIFwi4bqMXCI6IFwiWMyIXCIsXG4gIFwi4bqKXCI6IFwiWMyHXCIsXG4gIFwiw51cIjogXCJZzIFcIixcbiAgXCLhu7JcIjogXCJZzIBcIixcbiAgXCLFuFwiOiBcIlnMiFwiLFxuICBcIuG7uFwiOiBcIlnMg1wiLFxuICBcIsiyXCI6IFwiWcyEXCIsXG4gIFwixbZcIjogXCJZzIJcIixcbiAgXCLhuo5cIjogXCJZzIdcIixcbiAgXCLFuVwiOiBcIlrMgVwiLFxuICBcIsW9XCI6IFwiWsyMXCIsXG4gIFwi4bqQXCI6IFwiWsyCXCIsXG4gIFwixbtcIjogXCJazIdcIixcbiAgXCLOrFwiOiBcIs6xzIFcIixcbiAgXCLhvbBcIjogXCLOscyAXCIsXG4gIFwi4b6xXCI6IFwizrHMhFwiLFxuICBcIuG+sFwiOiBcIs6xzIZcIixcbiAgXCLOrVwiOiBcIs61zIFcIixcbiAgXCLhvbJcIjogXCLOtcyAXCIsXG4gIFwizq5cIjogXCLOt8yBXCIsXG4gIFwi4b20XCI6IFwizrfMgFwiLFxuICBcIs6vXCI6IFwizrnMgVwiLFxuICBcIuG9tlwiOiBcIs65zIBcIixcbiAgXCLPilwiOiBcIs65zIhcIixcbiAgXCLOkFwiOiBcIs65zIjMgVwiLFxuICBcIuG/klwiOiBcIs65zIjMgFwiLFxuICBcIuG/kVwiOiBcIs65zIRcIixcbiAgXCLhv5BcIjogXCLOucyGXCIsXG4gIFwiz4xcIjogXCLOv8yBXCIsXG4gIFwi4b24XCI6IFwizr/MgFwiLFxuICBcIs+NXCI6IFwiz4XMgVwiLFxuICBcIuG9ulwiOiBcIs+FzIBcIixcbiAgXCLPi1wiOiBcIs+FzIhcIixcbiAgXCLOsFwiOiBcIs+FzIjMgVwiLFxuICBcIuG/olwiOiBcIs+FzIjMgFwiLFxuICBcIuG/oVwiOiBcIs+FzIRcIixcbiAgXCLhv6BcIjogXCLPhcyGXCIsXG4gIFwiz45cIjogXCLPicyBXCIsXG4gIFwi4b28XCI6IFwiz4nMgFwiLFxuICBcIs6OXCI6IFwizqXMgVwiLFxuICBcIuG/qlwiOiBcIs6lzIBcIixcbiAgXCLOq1wiOiBcIs6lzIhcIixcbiAgXCLhv6lcIjogXCLOpcyEXCIsXG4gIFwi4b+oXCI6IFwizqXMhlwiLFxuICBcIs6PXCI6IFwizqnMgVwiLFxuICBcIuG/ulwiOiBcIs6pzIBcIlxufTtcblxuLyoqXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgdGhlIHBhcnNlciB1c2VkIHRvIHBhcnNlIG91dCBhIFRlWCBleHByZXNzaW9uIGZyb20gdGhlXG4gKiBpbnB1dC4gU2luY2UgVGVYIGlzbid0IGNvbnRleHQtZnJlZSwgc3RhbmRhcmQgcGFyc2VycyBkb24ndCB3b3JrIHBhcnRpY3VsYXJseVxuICogd2VsbC5cbiAqXG4gKiBUaGUgc3RyYXRlZ3kgb2YgdGhpcyBwYXJzZXIgaXMgYXMgc3VjaDpcbiAqXG4gKiBUaGUgbWFpbiBmdW5jdGlvbnMgKHRoZSBgLnBhcnNlLi4uYCBvbmVzKSB0YWtlIGEgcG9zaXRpb24gaW4gdGhlIGN1cnJlbnRcbiAqIHBhcnNlIHN0cmluZyB0byBwYXJzZSB0b2tlbnMgZnJvbS4gVGhlIGxleGVyIChmb3VuZCBpbiBMZXhlci5qcywgc3RvcmVkIGF0XG4gKiB0aGlzLmd1bGxldC5sZXhlcikgYWxzbyBzdXBwb3J0cyBwdWxsaW5nIG91dCB0b2tlbnMgYXQgYXJiaXRyYXJ5IHBsYWNlcy4gV2hlblxuICogaW5kaXZpZHVhbCB0b2tlbnMgYXJlIG5lZWRlZCBhdCBhIHBvc2l0aW9uLCB0aGUgbGV4ZXIgaXMgY2FsbGVkIHRvIHB1bGwgb3V0IGFcbiAqIHRva2VuLCB3aGljaCBpcyB0aGVuIHVzZWQuXG4gKlxuICogVGhlIHBhcnNlciBoYXMgYSBwcm9wZXJ0eSBjYWxsZWQgXCJtb2RlXCIgaW5kaWNhdGluZyB0aGUgbW9kZSB0aGF0XG4gKiB0aGUgcGFyc2VyIGlzIGN1cnJlbnRseSBpbi4gQ3VycmVudGx5IGl0IGhhcyB0byBiZSBvbmUgb2YgXCJtYXRoXCIgb3JcbiAqIFwidGV4dFwiLCB3aGljaCBkZW5vdGVzIHdoZXRoZXIgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQgaXMgYSBtYXRoLXlcbiAqIG9uZSBvciBhIHRleHQteSBvbmUgKGUuZy4gaW5zaWRlIFxcdGV4dCkuIEN1cnJlbnRseSwgdGhpcyBzZXJ2ZXMgdG9cbiAqIGxpbWl0IHRoZSBmdW5jdGlvbnMgd2hpY2ggY2FuIGJlIHVzZWQgaW4gdGV4dCBtb2RlLlxuICpcbiAqIFRoZSBtYWluIGZ1bmN0aW9ucyB0aGVuIHJldHVybiBhbiBvYmplY3Qgd2hpY2ggY29udGFpbnMgdGhlIHVzZWZ1bCBkYXRhIHRoYXRcbiAqIHdhcyBwYXJzZWQgYXQgaXRzIGdpdmVuIHBvaW50LCBhbmQgYSBuZXcgcG9zaXRpb24gYXQgdGhlIGVuZCBvZiB0aGUgcGFyc2VkXG4gKiBkYXRhLiBUaGUgbWFpbiBmdW5jdGlvbnMgY2FuIGNhbGwgZWFjaCBvdGhlciBhbmQgY29udGludWUgdGhlIHBhcnNpbmcgYnlcbiAqIHVzaW5nIHRoZSByZXR1cm5lZCBwb3NpdGlvbiBhcyBhIG5ldyBzdGFydGluZyBwb2ludC5cbiAqXG4gKiBUaGVyZSBhcmUgYWxzbyBleHRyYSBgLmhhbmRsZS4uLmAgZnVuY3Rpb25zLCB3aGljaCBwdWxsIG91dCBzb21lIHJldXNlZFxuICogZnVuY3Rpb25hbGl0eSBpbnRvIHNlbGYtY29udGFpbmVkIGZ1bmN0aW9ucy5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIHJldHVybiBQYXJzZU5vZGVzLlxuICovXG5jbGFzcyBQYXJzZXIge1xuICBjb25zdHJ1Y3RvcihpbnB1dCwgc2V0dGluZ3MpIHtcbiAgICB0aGlzLm1vZGUgPSB2b2lkIDA7XG4gICAgdGhpcy5ndWxsZXQgPSB2b2lkIDA7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHZvaWQgMDtcbiAgICB0aGlzLmxlZnRyaWdodERlcHRoID0gdm9pZCAwO1xuICAgIHRoaXMubmV4dFRva2VuID0gdm9pZCAwO1xuICAgIC8vIFN0YXJ0IGluIG1hdGggbW9kZVxuICAgIHRoaXMubW9kZSA9IFwibWF0aFwiOyAvLyBDcmVhdGUgYSBuZXcgbWFjcm8gZXhwYW5kZXIgKGd1bGxldCkgYW5kIChpbmRpcmVjdGx5IHZpYSB0aGF0KSBhbHNvIGFcbiAgICAvLyBuZXcgbGV4ZXIgKG1vdXRoKSBmb3IgdGhpcyBwYXJzZXIgKHN0b21hY2gsIGluIHRoZSBsYW5ndWFnZSBvZiBUZVgpXG5cbiAgICB0aGlzLmd1bGxldCA9IG5ldyBNYWNyb0V4cGFuZGVyKGlucHV0LCBzZXR0aW5ncywgdGhpcy5tb2RlKTsgLy8gU3RvcmUgdGhlIHNldHRpbmdzIGZvciB1c2UgaW4gcGFyc2luZ1xuXG4gICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzOyAvLyBDb3VudCBsZWZ0cmlnaHQgZGVwdGggKGZvciBcXG1pZGRsZSBlcnJvcnMpXG5cbiAgICB0aGlzLmxlZnRyaWdodERlcHRoID0gMDtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGEgcmVzdWx0IHRvIG1ha2Ugc3VyZSBpdCBoYXMgdGhlIHJpZ2h0IHR5cGUsIGFuZCB0aHJvd3MgYW5cbiAgICogYXBwcm9wcmlhdGUgZXJyb3Igb3RoZXJ3aXNlLlxuICAgKi9cblxuXG4gIGV4cGVjdCh0ZXh0LCBjb25zdW1lKSB7XG4gICAgaWYgKGNvbnN1bWUgPT09IHZvaWQgMCkge1xuICAgICAgY29uc3VtZSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZmV0Y2goKS50ZXh0ICE9PSB0ZXh0KSB7XG4gICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJFeHBlY3RlZCAnXCIgKyB0ZXh0ICsgXCInLCBnb3QgJ1wiICsgdGhpcy5mZXRjaCgpLnRleHQgKyBcIidcIiwgdGhpcy5mZXRjaCgpKTtcbiAgICB9XG5cbiAgICBpZiAoY29uc3VtZSkge1xuICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBEaXNjYXJkcyB0aGUgY3VycmVudCBsb29rYWhlYWQgdG9rZW4sIGNvbnNpZGVyaW5nIGl0IGNvbnN1bWVkLlxuICAgKi9cblxuXG4gIGNvbnN1bWUoKSB7XG4gICAgdGhpcy5uZXh0VG9rZW4gPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGN1cnJlbnQgbG9va2FoZWFkIHRva2VuLCBvciBpZiB0aGVyZSBpc24ndCBvbmUgKGF0IHRoZVxuICAgKiBiZWdpbm5pbmcsIG9yIGlmIHRoZSBwcmV2aW91cyBsb29rYWhlYWQgdG9rZW4gd2FzIGNvbnN1bWUoKWQpLFxuICAgKiBmZXRjaCB0aGUgbmV4dCB0b2tlbiBhcyB0aGUgbmV3IGxvb2thaGVhZCB0b2tlbiBhbmQgcmV0dXJuIGl0LlxuICAgKi9cblxuXG4gIGZldGNoKCkge1xuICAgIGlmICh0aGlzLm5leHRUb2tlbiA9PSBudWxsKSB7XG4gICAgICB0aGlzLm5leHRUb2tlbiA9IHRoaXMuZ3VsbGV0LmV4cGFuZE5leHRUb2tlbigpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLm5leHRUb2tlbjtcbiAgfVxuICAvKipcbiAgICogU3dpdGNoZXMgYmV0d2VlbiBcInRleHRcIiBhbmQgXCJtYXRoXCIgbW9kZXMuXG4gICAqL1xuXG5cbiAgc3dpdGNoTW9kZShuZXdNb2RlKSB7XG4gICAgdGhpcy5tb2RlID0gbmV3TW9kZTtcbiAgICB0aGlzLmd1bGxldC5zd2l0Y2hNb2RlKG5ld01vZGUpO1xuICB9XG4gIC8qKlxuICAgKiBNYWluIHBhcnNpbmcgZnVuY3Rpb24sIHdoaWNoIHBhcnNlcyBhbiBlbnRpcmUgaW5wdXQuXG4gICAqL1xuXG5cbiAgcGFyc2UoKSB7XG4gICAgaWYgKCF0aGlzLnNldHRpbmdzLmdsb2JhbEdyb3VwKSB7XG4gICAgICAvLyBDcmVhdGUgYSBncm91cCBuYW1lc3BhY2UgZm9yIHRoZSBtYXRoIGV4cHJlc3Npb24uXG4gICAgICAvLyAoTGFUZVggY3JlYXRlcyBhIG5ldyBncm91cCBmb3IgZXZlcnkgJC4uLiQsICQkLi4uJCQsIFxcWy4uLlxcXS4pXG4gICAgICB0aGlzLmd1bGxldC5iZWdpbkdyb3VwKCk7XG4gICAgfSAvLyBVc2Ugb2xkIFxcY29sb3IgYmVoYXZpb3IgKHNhbWUgYXMgTGFUZVgncyBcXHRleHRjb2xvcikgaWYgcmVxdWVzdGVkLlxuICAgIC8vIFdlIGRvIHRoaXMgd2l0aGluIHRoZSBncm91cCBmb3IgdGhlIG1hdGggZXhwcmVzc2lvbiwgc28gaXQgZG9lc24ndFxuICAgIC8vIHBvbGx1dGUgc2V0dGluZ3MubWFjcm9zLlxuXG5cbiAgICBpZiAodGhpcy5zZXR0aW5ncy5jb2xvcklzVGV4dENvbG9yKSB7XG4gICAgICB0aGlzLmd1bGxldC5tYWNyb3Muc2V0KFwiXFxcXGNvbG9yXCIsIFwiXFxcXHRleHRjb2xvclwiKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gVHJ5IHRvIHBhcnNlIHRoZSBpbnB1dFxuICAgICAgY29uc3QgcGFyc2UgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbihmYWxzZSk7IC8vIElmIHdlIHN1Y2NlZWRlZCwgbWFrZSBzdXJlIHRoZXJlJ3MgYW4gRU9GIGF0IHRoZSBlbmRcblxuICAgICAgdGhpcy5leHBlY3QoXCJFT0ZcIik7IC8vIEVuZCB0aGUgZ3JvdXAgbmFtZXNwYWNlIGZvciB0aGUgZXhwcmVzc2lvblxuXG4gICAgICBpZiAoIXRoaXMuc2V0dGluZ3MuZ2xvYmFsR3JvdXApIHtcbiAgICAgICAgdGhpcy5ndWxsZXQuZW5kR3JvdXAoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcnNlOyAvLyBDbG9zZSBhbnkgbGVmdG92ZXIgZ3JvdXBzIGluIGNhc2Ugb2YgYSBwYXJzZSBlcnJvci5cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5ndWxsZXQuZW5kR3JvdXBzKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBGdWxseSBwYXJzZSBhIHNlcGFyYXRlIHNlcXVlbmNlIG9mIHRva2VucyBhcyBhIHNlcGFyYXRlIGpvYi5cbiAgICogVG9rZW5zIHNob3VsZCBiZSBzcGVjaWZpZWQgaW4gcmV2ZXJzZSBvcmRlciwgYXMgaW4gYSBNYWNyb0RlZmluaXRpb24uXG4gICAqL1xuXG5cbiAgc3VicGFyc2UodG9rZW5zKSB7XG4gICAgLy8gU2F2ZSB0aGUgbmV4dCB0b2tlbiBmcm9tIHRoZSBjdXJyZW50IGpvYi5cbiAgICBjb25zdCBvbGRUb2tlbiA9IHRoaXMubmV4dFRva2VuO1xuICAgIHRoaXMuY29uc3VtZSgpOyAvLyBSdW4gdGhlIG5ldyBqb2IsIHRlcm1pbmF0aW5nIGl0IHdpdGggYW4gZXhjZXNzICd9J1xuXG4gICAgdGhpcy5ndWxsZXQucHVzaFRva2VuKG5ldyBUb2tlbihcIn1cIikpO1xuICAgIHRoaXMuZ3VsbGV0LnB1c2hUb2tlbnModG9rZW5zKTtcbiAgICBjb25zdCBwYXJzZSA9IHRoaXMucGFyc2VFeHByZXNzaW9uKGZhbHNlKTtcbiAgICB0aGlzLmV4cGVjdChcIn1cIik7IC8vIFJlc3RvcmUgdGhlIG5leHQgdG9rZW4gZnJvbSB0aGUgY3VycmVudCBqb2IuXG5cbiAgICB0aGlzLm5leHRUb2tlbiA9IG9sZFRva2VuO1xuICAgIHJldHVybiBwYXJzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXMgYW4gXCJleHByZXNzaW9uXCIsIHdoaWNoIGlzIGEgbGlzdCBvZiBhdG9tcy5cbiAgICpcbiAgICogYGJyZWFrT25JbmZpeGA6IFNob3VsZCB0aGUgcGFyc2luZyBzdG9wIHdoZW4gd2UgaGl0IGluZml4IG5vZGVzPyBUaGlzXG4gICAqICAgICAgICAgICAgICAgICBoYXBwZW5zIHdoZW4gZnVuY3Rpb25zIGhhdmUgaGlnaGVyIHByZWNlZGVuY2UgaGFuIGluZml4XG4gICAqICAgICAgICAgICAgICAgICBub2RlcyBpbiBpbXBsaWNpdCBwYXJzZXMuXG4gICAqXG4gICAqIGBicmVha09uVG9rZW5UZXh0YDogVGhlIHRleHQgb2YgdGhlIHRva2VuIHRoYXQgdGhlIGV4cHJlc3Npb24gc2hvdWxkIGVuZFxuICAgKiAgICAgICAgICAgICAgICAgICAgIHdpdGgsIG9yIGBudWxsYCBpZiBzb21ldGhpbmcgZWxzZSBzaG91bGQgZW5kIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb24uXG4gICAqL1xuICBwYXJzZUV4cHJlc3Npb24oYnJlYWtPbkluZml4LCBicmVha09uVG9rZW5UZXh0KSB7XG4gICAgY29uc3QgYm9keSA9IFtdOyAvLyBLZWVwIGFkZGluZyBhdG9tcyB0byB0aGUgYm9keSB1bnRpbCB3ZSBjYW4ndCBwYXJzZSBhbnkgbW9yZSBhdG9tcyAoZWl0aGVyXG4gICAgLy8gd2UgcmVhY2hlZCB0aGUgZW5kLCBhIH0sIG9yIGEgXFxyaWdodClcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAvLyBJZ25vcmUgc3BhY2VzIGluIG1hdGggbW9kZVxuICAgICAgaWYgKHRoaXMubW9kZSA9PT0gXCJtYXRoXCIpIHtcbiAgICAgICAgdGhpcy5jb25zdW1lU3BhY2VzKCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxleCA9IHRoaXMuZmV0Y2goKTtcblxuICAgICAgaWYgKFBhcnNlci5lbmRPZkV4cHJlc3Npb24uaW5kZXhPZihsZXgudGV4dCkgIT09IC0xKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoYnJlYWtPblRva2VuVGV4dCAmJiBsZXgudGV4dCA9PT0gYnJlYWtPblRva2VuVGV4dCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKGJyZWFrT25JbmZpeCAmJiBzcmNfZnVuY3Rpb25zW2xleC50ZXh0XSAmJiBzcmNfZnVuY3Rpb25zW2xleC50ZXh0XS5pbmZpeCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY29uc3QgYXRvbSA9IHRoaXMucGFyc2VBdG9tKGJyZWFrT25Ub2tlblRleHQpO1xuXG4gICAgICBpZiAoIWF0b20pIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKGF0b20udHlwZSA9PT0gXCJpbnRlcm5hbFwiKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBib2R5LnB1c2goYXRvbSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubW9kZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgIHRoaXMuZm9ybUxpZ2F0dXJlcyhib2R5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5oYW5kbGVJbmZpeE5vZGVzKGJvZHkpO1xuICB9XG4gIC8qKlxuICAgKiBSZXdyaXRlcyBpbmZpeCBvcGVyYXRvcnMgc3VjaCBhcyBcXG92ZXIgd2l0aCBjb3JyZXNwb25kaW5nIGNvbW1hbmRzIHN1Y2hcbiAgICogYXMgXFxmcmFjLlxuICAgKlxuICAgKiBUaGVyZSBjYW4gb25seSBiZSBvbmUgaW5maXggb3BlcmF0b3IgcGVyIGdyb3VwLiAgSWYgdGhlcmUncyBtb3JlIHRoYW4gb25lXG4gICAqIHRoZW4gdGhlIGV4cHJlc3Npb24gaXMgYW1iaWd1b3VzLiAgVGhpcyBjYW4gYmUgcmVzb2x2ZWQgYnkgYWRkaW5nIHt9LlxuICAgKi9cblxuXG4gIGhhbmRsZUluZml4Tm9kZXMoYm9keSkge1xuICAgIGxldCBvdmVySW5kZXggPSAtMTtcbiAgICBsZXQgZnVuY05hbWU7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJvZHkubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChib2R5W2ldLnR5cGUgPT09IFwiaW5maXhcIikge1xuICAgICAgICBpZiAob3ZlckluZGV4ICE9PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIm9ubHkgb25lIGluZml4IG9wZXJhdG9yIHBlciBncm91cFwiLCBib2R5W2ldLnRva2VuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG92ZXJJbmRleCA9IGk7XG4gICAgICAgIGZ1bmNOYW1lID0gYm9keVtpXS5yZXBsYWNlV2l0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3ZlckluZGV4ICE9PSAtMSAmJiBmdW5jTmFtZSkge1xuICAgICAgbGV0IG51bWVyTm9kZTtcbiAgICAgIGxldCBkZW5vbU5vZGU7XG4gICAgICBjb25zdCBudW1lckJvZHkgPSBib2R5LnNsaWNlKDAsIG92ZXJJbmRleCk7XG4gICAgICBjb25zdCBkZW5vbUJvZHkgPSBib2R5LnNsaWNlKG92ZXJJbmRleCArIDEpO1xuXG4gICAgICBpZiAobnVtZXJCb2R5Lmxlbmd0aCA9PT0gMSAmJiBudW1lckJvZHlbMF0udHlwZSA9PT0gXCJvcmRncm91cFwiKSB7XG4gICAgICAgIG51bWVyTm9kZSA9IG51bWVyQm9keVswXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG51bWVyTm9kZSA9IHtcbiAgICAgICAgICB0eXBlOiBcIm9yZGdyb3VwXCIsXG4gICAgICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgICAgIGJvZHk6IG51bWVyQm9keVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoZGVub21Cb2R5Lmxlbmd0aCA9PT0gMSAmJiBkZW5vbUJvZHlbMF0udHlwZSA9PT0gXCJvcmRncm91cFwiKSB7XG4gICAgICAgIGRlbm9tTm9kZSA9IGRlbm9tQm9keVswXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbm9tTm9kZSA9IHtcbiAgICAgICAgICB0eXBlOiBcIm9yZGdyb3VwXCIsXG4gICAgICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgICAgIGJvZHk6IGRlbm9tQm9keVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBsZXQgbm9kZTtcblxuICAgICAgaWYgKGZ1bmNOYW1lID09PSBcIlxcXFxcXFxcYWJvdmVmcmFjXCIpIHtcbiAgICAgICAgbm9kZSA9IHRoaXMuY2FsbEZ1bmN0aW9uKGZ1bmNOYW1lLCBbbnVtZXJOb2RlLCBib2R5W292ZXJJbmRleF0sIGRlbm9tTm9kZV0sIFtdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUgPSB0aGlzLmNhbGxGdW5jdGlvbihmdW5jTmFtZSwgW251bWVyTm9kZSwgZGVub21Ob2RlXSwgW10pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW25vZGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYm9keTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZSBhIHN1YnNjcmlwdCBvciBzdXBlcnNjcmlwdCB3aXRoIG5pY2UgZXJyb3JzLlxuICAgKi9cblxuXG4gIGhhbmRsZVN1cFN1YnNjcmlwdChuYW1lIC8vIEZvciBlcnJvciByZXBvcnRpbmcuXG4gICkge1xuICAgIGNvbnN0IHN5bWJvbFRva2VuID0gdGhpcy5mZXRjaCgpO1xuICAgIGNvbnN0IHN5bWJvbCA9IHN5bWJvbFRva2VuLnRleHQ7XG4gICAgdGhpcy5jb25zdW1lKCk7XG4gICAgdGhpcy5jb25zdW1lU3BhY2VzKCk7IC8vIGlnbm9yZSBzcGFjZXMgYmVmb3JlIHN1cC9zdWJzY3JpcHQgYXJndW1lbnRcblxuICAgIGNvbnN0IGdyb3VwID0gdGhpcy5wYXJzZUdyb3VwKG5hbWUpO1xuXG4gICAgaWYgKCFncm91cCkge1xuICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiRXhwZWN0ZWQgZ3JvdXAgYWZ0ZXIgJ1wiICsgc3ltYm9sICsgXCInXCIsIHN5bWJvbFRva2VuKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ3JvdXA7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSB0ZXh0dWFsIGlucHV0IG9mIGFuIHVuc3VwcG9ydGVkIGNvbW1hbmQgaW50byBhIHRleHQgbm9kZVxuICAgKiBjb250YWluZWQgd2l0aGluIGEgY29sb3Igbm9kZSB3aG9zZSBjb2xvciBpcyBkZXRlcm1pbmVkIGJ5IGVycm9yQ29sb3JcbiAgICovXG5cblxuICBmb3JtYXRVbnN1cHBvcnRlZENtZCh0ZXh0KSB7XG4gICAgY29uc3QgdGV4dG9yZEFycmF5ID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRleHRvcmRBcnJheS5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJ0ZXh0b3JkXCIsXG4gICAgICAgIG1vZGU6IFwidGV4dFwiLFxuICAgICAgICB0ZXh0OiB0ZXh0W2ldXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCB0ZXh0Tm9kZSA9IHtcbiAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgYm9keTogdGV4dG9yZEFycmF5XG4gICAgfTtcbiAgICBjb25zdCBjb2xvck5vZGUgPSB7XG4gICAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICBjb2xvcjogdGhpcy5zZXR0aW5ncy5lcnJvckNvbG9yLFxuICAgICAgYm9keTogW3RleHROb2RlXVxuICAgIH07XG4gICAgcmV0dXJuIGNvbG9yTm9kZTtcbiAgfVxuICAvKipcbiAgICogUGFyc2VzIGEgZ3JvdXAgd2l0aCBvcHRpb25hbCBzdXBlci9zdWJzY3JpcHRzLlxuICAgKi9cblxuXG4gIHBhcnNlQXRvbShicmVha09uVG9rZW5UZXh0KSB7XG4gICAgLy8gVGhlIGJvZHkgb2YgYW4gYXRvbSBpcyBhbiBpbXBsaWNpdCBncm91cCwgc28gdGhhdCB0aGluZ3MgbGlrZVxuICAgIC8vIFxcbGVmdCh4XFxyaWdodCleMiB3b3JrIGNvcnJlY3RseS5cbiAgICBjb25zdCBiYXNlID0gdGhpcy5wYXJzZUdyb3VwKFwiYXRvbVwiLCBicmVha09uVG9rZW5UZXh0KTsgLy8gSW4gdGV4dCBtb2RlLCB3ZSBkb24ndCBoYXZlIHN1cGVyc2NyaXB0cyBvciBzdWJzY3JpcHRzXG5cbiAgICBpZiAodGhpcy5tb2RlID09PSBcInRleHRcIikge1xuICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfSAvLyBOb3RlIHRoYXQgYmFzZSBtYXkgYmUgZW1wdHkgKGkuZS4gbnVsbCkgYXQgdGhpcyBwb2ludC5cblxuXG4gICAgbGV0IHN1cGVyc2NyaXB0O1xuICAgIGxldCBzdWJzY3JpcHQ7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgLy8gR3VhcmFudGVlZCBpbiBtYXRoIG1vZGUsIHNvIGVhdCBhbnkgc3BhY2VzIGZpcnN0LlxuICAgICAgdGhpcy5jb25zdW1lU3BhY2VzKCk7IC8vIExleCB0aGUgZmlyc3QgdG9rZW5cblxuICAgICAgY29uc3QgbGV4ID0gdGhpcy5mZXRjaCgpO1xuXG4gICAgICBpZiAobGV4LnRleHQgPT09IFwiXFxcXGxpbWl0c1wiIHx8IGxleC50ZXh0ID09PSBcIlxcXFxub2xpbWl0c1wiKSB7XG4gICAgICAgIC8vIFdlIGdvdCBhIGxpbWl0IGNvbnRyb2xcbiAgICAgICAgaWYgKGJhc2UgJiYgYmFzZS50eXBlID09PSBcIm9wXCIpIHtcbiAgICAgICAgICBjb25zdCBsaW1pdHMgPSBsZXgudGV4dCA9PT0gXCJcXFxcbGltaXRzXCI7XG4gICAgICAgICAgYmFzZS5saW1pdHMgPSBsaW1pdHM7XG4gICAgICAgICAgYmFzZS5hbHdheXNIYW5kbGVTdXBTdWIgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGJhc2UgJiYgYmFzZS50eXBlID09PSBcIm9wZXJhdG9ybmFtZVwiKSB7XG4gICAgICAgICAgaWYgKGJhc2UuYWx3YXlzSGFuZGxlU3VwU3ViKSB7XG4gICAgICAgICAgICBiYXNlLmxpbWl0cyA9IGxleC50ZXh0ID09PSBcIlxcXFxsaW1pdHNcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiTGltaXQgY29udHJvbHMgbXVzdCBmb2xsb3cgYSBtYXRoIG9wZXJhdG9yXCIsIGxleCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgIH0gZWxzZSBpZiAobGV4LnRleHQgPT09IFwiXlwiKSB7XG4gICAgICAgIC8vIFdlIGdvdCBhIHN1cGVyc2NyaXB0IHN0YXJ0XG4gICAgICAgIGlmIChzdXBlcnNjcmlwdCkge1xuICAgICAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIkRvdWJsZSBzdXBlcnNjcmlwdFwiLCBsZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3VwZXJzY3JpcHQgPSB0aGlzLmhhbmRsZVN1cFN1YnNjcmlwdChcInN1cGVyc2NyaXB0XCIpO1xuICAgICAgfSBlbHNlIGlmIChsZXgudGV4dCA9PT0gXCJfXCIpIHtcbiAgICAgICAgLy8gV2UgZ290IGEgc3Vic2NyaXB0IHN0YXJ0XG4gICAgICAgIGlmIChzdWJzY3JpcHQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJEb3VibGUgc3Vic2NyaXB0XCIsIGxleCk7XG4gICAgICAgIH1cblxuICAgICAgICBzdWJzY3JpcHQgPSB0aGlzLmhhbmRsZVN1cFN1YnNjcmlwdChcInN1YnNjcmlwdFwiKTtcbiAgICAgIH0gZWxzZSBpZiAobGV4LnRleHQgPT09IFwiJ1wiKSB7XG4gICAgICAgIC8vIFdlIGdvdCBhIHByaW1lXG4gICAgICAgIGlmIChzdXBlcnNjcmlwdCkge1xuICAgICAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIkRvdWJsZSBzdXBlcnNjcmlwdFwiLCBsZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcHJpbWUgPSB7XG4gICAgICAgICAgdHlwZTogXCJ0ZXh0b3JkXCIsXG4gICAgICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgICAgIHRleHQ6IFwiXFxcXHByaW1lXCJcbiAgICAgICAgfTsgLy8gTWFueSBwcmltZXMgY2FuIGJlIGdyb3VwZWQgdG9nZXRoZXIsIHNvIHdlIGhhbmRsZSB0aGlzIGhlcmVcblxuICAgICAgICBjb25zdCBwcmltZXMgPSBbcHJpbWVdO1xuICAgICAgICB0aGlzLmNvbnN1bWUoKTsgLy8gS2VlcCBsZXhpbmcgdG9rZW5zIHVudGlsIHdlIGdldCBzb21ldGhpbmcgdGhhdCdzIG5vdCBhIHByaW1lXG5cbiAgICAgICAgd2hpbGUgKHRoaXMuZmV0Y2goKS50ZXh0ID09PSBcIidcIikge1xuICAgICAgICAgIC8vIEZvciBlYWNoIG9uZSwgYWRkIGFub3RoZXIgcHJpbWUgdG8gdGhlIGxpc3RcbiAgICAgICAgICBwcmltZXMucHVzaChwcmltZSk7XG4gICAgICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICAgIH0gLy8gSWYgdGhlcmUncyBhIHN1cGVyc2NyaXB0IGZvbGxvd2luZyB0aGUgcHJpbWVzLCBjb21iaW5lIHRoYXRcbiAgICAgICAgLy8gc3VwZXJzY3JpcHQgaW4gd2l0aCB0aGUgcHJpbWVzLlxuXG5cbiAgICAgICAgaWYgKHRoaXMuZmV0Y2goKS50ZXh0ID09PSBcIl5cIikge1xuICAgICAgICAgIHByaW1lcy5wdXNoKHRoaXMuaGFuZGxlU3VwU3Vic2NyaXB0KFwic3VwZXJzY3JpcHRcIikpO1xuICAgICAgICB9IC8vIFB1dCBldmVyeXRoaW5nIGludG8gYW4gb3JkZ3JvdXAgYXMgdGhlIHN1cGVyc2NyaXB0XG5cblxuICAgICAgICBzdXBlcnNjcmlwdCA9IHtcbiAgICAgICAgICB0eXBlOiBcIm9yZGdyb3VwXCIsXG4gICAgICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgICAgIGJvZHk6IHByaW1lc1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICh1U3Vic0FuZFN1cHNbbGV4LnRleHRdKSB7XG4gICAgICAgIC8vIEEgVW5pY29kZSBzdWJzY3JpcHQgb3Igc3VwZXJzY3JpcHQgY2hhcmFjdGVyLlxuICAgICAgICAvLyBXZSB0cmVhdCB0aGVzZSBzaW1pbGFybHkgdG8gdGhlIHVuaWNvZGUtbWF0aCBwYWNrYWdlLlxuICAgICAgICAvLyBTbyB3ZSByZW5kZXIgYSBzdHJpbmcgb2YgVW5pY29kZSAoc3VifHN1cGVyKXNjcmlwdHMgdGhlXG4gICAgICAgIC8vIHNhbWUgYXMgYSAoc3VifHN1cGVyKXNjcmlwdCBvZiByZWd1bGFyIGNoYXJhY3RlcnMuXG4gICAgICAgIGNvbnN0IGlzU3ViID0gdW5pY29kZVN1YlJlZ0V4LnRlc3QobGV4LnRleHQpO1xuICAgICAgICBjb25zdCBzdWJzdXBUb2tlbnMgPSBbXTtcbiAgICAgICAgc3Vic3VwVG9rZW5zLnB1c2gobmV3IFRva2VuKHVTdWJzQW5kU3Vwc1tsZXgudGV4dF0pKTtcbiAgICAgICAgdGhpcy5jb25zdW1lKCk7IC8vIENvbnRpbnVlIGZldGNoaW5nIHRva2VucyB0byBmaWxsIG91dCB0aGUgc3RyaW5nLlxuXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgY29uc3QgdG9rZW4gPSB0aGlzLmZldGNoKCkudGV4dDtcblxuICAgICAgICAgIGlmICghdVN1YnNBbmRTdXBzW3Rva2VuXSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHVuaWNvZGVTdWJSZWdFeC50ZXN0KHRva2VuKSAhPT0gaXNTdWIpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN1YnN1cFRva2Vucy51bnNoaWZ0KG5ldyBUb2tlbih1U3Vic0FuZFN1cHNbdG9rZW5dKSk7XG4gICAgICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICAgIH0gLy8gTm93IGNyZWF0ZSBhIChzdWJ8c3VwZXIpc2NyaXB0LlxuXG5cbiAgICAgICAgY29uc3QgYm9keSA9IHRoaXMuc3VicGFyc2Uoc3Vic3VwVG9rZW5zKTtcblxuICAgICAgICBpZiAoaXNTdWIpIHtcbiAgICAgICAgICBzdWJzY3JpcHQgPSB7XG4gICAgICAgICAgICB0eXBlOiBcIm9yZGdyb3VwXCIsXG4gICAgICAgICAgICBtb2RlOiBcIm1hdGhcIixcbiAgICAgICAgICAgIGJvZHlcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN1cGVyc2NyaXB0ID0ge1xuICAgICAgICAgICAgdHlwZTogXCJvcmRncm91cFwiLFxuICAgICAgICAgICAgbW9kZTogXCJtYXRoXCIsXG4gICAgICAgICAgICBib2R5XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgaXQgd2Fzbid0IF4sIF8sIG9yICcsIHN0b3AgcGFyc2luZyBzdXBlci9zdWJzY3JpcHRzXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gLy8gQmFzZSBtdXN0IGJlIHNldCBpZiBzdXBlcnNjcmlwdCBvciBzdWJzY3JpcHQgYXJlIHNldCBwZXIgbG9naWMgYWJvdmUsXG4gICAgLy8gYnV0IG5lZWQgdG8gY2hlY2sgaGVyZSBmb3IgdHlwZSBjaGVjayB0byBwYXNzLlxuXG5cbiAgICBpZiAoc3VwZXJzY3JpcHQgfHwgc3Vic2NyaXB0KSB7XG4gICAgICAvLyBJZiB3ZSBnb3QgZWl0aGVyIGEgc3VwZXJzY3JpcHQgb3Igc3Vic2NyaXB0LCBjcmVhdGUgYSBzdXBzdWJcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwic3Vwc3ViXCIsXG4gICAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgICAgYmFzZTogYmFzZSxcbiAgICAgICAgc3VwOiBzdXBlcnNjcmlwdCxcbiAgICAgICAgc3ViOiBzdWJzY3JpcHRcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE90aGVyd2lzZSByZXR1cm4gdGhlIG9yaWdpbmFsIGJvZHlcbiAgICAgIHJldHVybiBiYXNlO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUGFyc2VzIGFuIGVudGlyZSBmdW5jdGlvbiwgaW5jbHVkaW5nIGl0cyBiYXNlIGFuZCBhbGwgb2YgaXRzIGFyZ3VtZW50cy5cbiAgICovXG5cblxuICBwYXJzZUZ1bmN0aW9uKGJyZWFrT25Ub2tlblRleHQsIG5hbWUgLy8gRm9yIGRldGVybWluaW5nIGl0cyBjb250ZXh0XG4gICkge1xuICAgIGNvbnN0IHRva2VuID0gdGhpcy5mZXRjaCgpO1xuICAgIGNvbnN0IGZ1bmMgPSB0b2tlbi50ZXh0O1xuICAgIGNvbnN0IGZ1bmNEYXRhID0gc3JjX2Z1bmN0aW9uc1tmdW5jXTtcblxuICAgIGlmICghZnVuY0RhdGEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuY29uc3VtZSgpOyAvLyBjb25zdW1lIGNvbW1hbmQgdG9rZW5cblxuICAgIGlmIChuYW1lICYmIG5hbWUgIT09IFwiYXRvbVwiICYmICFmdW5jRGF0YS5hbGxvd2VkSW5Bcmd1bWVudCkge1xuICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiR290IGZ1bmN0aW9uICdcIiArIGZ1bmMgKyBcIicgd2l0aCBubyBhcmd1bWVudHNcIiArIChuYW1lID8gXCIgYXMgXCIgKyBuYW1lIDogXCJcIiksIHRva2VuKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubW9kZSA9PT0gXCJ0ZXh0XCIgJiYgIWZ1bmNEYXRhLmFsbG93ZWRJblRleHQpIHtcbiAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIkNhbid0IHVzZSBmdW5jdGlvbiAnXCIgKyBmdW5jICsgXCInIGluIHRleHQgbW9kZVwiLCB0b2tlbik7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1vZGUgPT09IFwibWF0aFwiICYmIGZ1bmNEYXRhLmFsbG93ZWRJbk1hdGggPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJDYW4ndCB1c2UgZnVuY3Rpb24gJ1wiICsgZnVuYyArIFwiJyBpbiBtYXRoIG1vZGVcIiwgdG9rZW4pO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIGFyZ3MsXG4gICAgICBvcHRBcmdzXG4gICAgfSA9IHRoaXMucGFyc2VBcmd1bWVudHMoZnVuYywgZnVuY0RhdGEpO1xuICAgIHJldHVybiB0aGlzLmNhbGxGdW5jdGlvbihmdW5jLCBhcmdzLCBvcHRBcmdzLCB0b2tlbiwgYnJlYWtPblRva2VuVGV4dCk7XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgYSBmdW5jdGlvbiBoYW5kbGVyIHdpdGggYSBzdWl0YWJsZSBjb250ZXh0IGFuZCBhcmd1bWVudHMuXG4gICAqL1xuXG5cbiAgY2FsbEZ1bmN0aW9uKG5hbWUsIGFyZ3MsIG9wdEFyZ3MsIHRva2VuLCBicmVha09uVG9rZW5UZXh0KSB7XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgIGZ1bmNOYW1lOiBuYW1lLFxuICAgICAgcGFyc2VyOiB0aGlzLFxuICAgICAgdG9rZW4sXG4gICAgICBicmVha09uVG9rZW5UZXh0XG4gICAgfTtcbiAgICBjb25zdCBmdW5jID0gc3JjX2Z1bmN0aW9uc1tuYW1lXTtcblxuICAgIGlmIChmdW5jICYmIGZ1bmMuaGFuZGxlcikge1xuICAgICAgcmV0dXJuIGZ1bmMuaGFuZGxlcihjb250ZXh0LCBhcmdzLCBvcHRBcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiTm8gZnVuY3Rpb24gaGFuZGxlciBmb3IgXCIgKyBuYW1lKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlcyB0aGUgYXJndW1lbnRzIG9mIGEgZnVuY3Rpb24gb3IgZW52aXJvbm1lbnRcbiAgICovXG5cblxuICBwYXJzZUFyZ3VtZW50cyhmdW5jLCAvLyBTaG91bGQgbG9vayBsaWtlIFwiXFxuYW1lXCIgb3IgXCJcXGJlZ2lue25hbWV9XCIuXG4gIGZ1bmNEYXRhKSB7XG4gICAgY29uc3QgdG90YWxBcmdzID0gZnVuY0RhdGEubnVtQXJncyArIGZ1bmNEYXRhLm51bU9wdGlvbmFsQXJncztcblxuICAgIGlmICh0b3RhbEFyZ3MgPT09IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFyZ3M6IFtdLFxuICAgICAgICBvcHRBcmdzOiBbXVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBhcmdzID0gW107XG4gICAgY29uc3Qgb3B0QXJncyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbEFyZ3M7IGkrKykge1xuICAgICAgbGV0IGFyZ1R5cGUgPSBmdW5jRGF0YS5hcmdUeXBlcyAmJiBmdW5jRGF0YS5hcmdUeXBlc1tpXTtcbiAgICAgIGNvbnN0IGlzT3B0aW9uYWwgPSBpIDwgZnVuY0RhdGEubnVtT3B0aW9uYWxBcmdzO1xuXG4gICAgICBpZiAoZnVuY0RhdGEucHJpbWl0aXZlICYmIGFyZ1R5cGUgPT0gbnVsbCB8fCAvLyBcXHNxcnQgZXhwYW5kcyBpbnRvIHByaW1pdGl2ZSBpZiBvcHRpb25hbCBhcmd1bWVudCBkb2Vzbid0IGV4aXN0XG4gICAgICBmdW5jRGF0YS50eXBlID09PSBcInNxcnRcIiAmJiBpID09PSAxICYmIG9wdEFyZ3NbMF0gPT0gbnVsbCkge1xuICAgICAgICBhcmdUeXBlID0gXCJwcmltaXRpdmVcIjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYXJnID0gdGhpcy5wYXJzZUdyb3VwT2ZUeXBlKFwiYXJndW1lbnQgdG8gJ1wiICsgZnVuYyArIFwiJ1wiLCBhcmdUeXBlLCBpc09wdGlvbmFsKTtcblxuICAgICAgaWYgKGlzT3B0aW9uYWwpIHtcbiAgICAgICAgb3B0QXJncy5wdXNoKGFyZyk7XG4gICAgICB9IGVsc2UgaWYgKGFyZyAhPSBudWxsKSB7XG4gICAgICAgIGFyZ3MucHVzaChhcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc2hvdWxkIGJlIHVucmVhY2hhYmxlXG4gICAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIk51bGwgYXJndW1lbnQsIHBsZWFzZSByZXBvcnQgdGhpcyBhcyBhIGJ1Z1wiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgYXJncyxcbiAgICAgIG9wdEFyZ3NcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZXMgYSBncm91cCB3aGVuIHRoZSBtb2RlIGlzIGNoYW5naW5nLlxuICAgKi9cblxuXG4gIHBhcnNlR3JvdXBPZlR5cGUobmFtZSwgdHlwZSwgb3B0aW9uYWwpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgXCJjb2xvclwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUNvbG9yR3JvdXAob3B0aW9uYWwpO1xuXG4gICAgICBjYXNlIFwic2l6ZVwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVNpemVHcm91cChvcHRpb25hbCk7XG5cbiAgICAgIGNhc2UgXCJ1cmxcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VVcmxHcm91cChvcHRpb25hbCk7XG5cbiAgICAgIGNhc2UgXCJtYXRoXCI6XG4gICAgICBjYXNlIFwidGV4dFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUFyZ3VtZW50R3JvdXAob3B0aW9uYWwsIHR5cGUpO1xuXG4gICAgICBjYXNlIFwiaGJveFwiOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gaGJveCBhcmd1bWVudCB0eXBlIHdyYXBzIHRoZSBhcmd1bWVudCBpbiB0aGUgZXF1aXZhbGVudCBvZlxuICAgICAgICAgIC8vIFxcaGJveCwgd2hpY2ggaXMgbGlrZSBcXHRleHQgYnV0IHN3aXRjaGluZyB0byBcXHRleHRzdHlsZSBzaXplLlxuICAgICAgICAgIGNvbnN0IGdyb3VwID0gdGhpcy5wYXJzZUFyZ3VtZW50R3JvdXAob3B0aW9uYWwsIFwidGV4dFwiKTtcbiAgICAgICAgICByZXR1cm4gZ3JvdXAgIT0gbnVsbCA/IHtcbiAgICAgICAgICAgIHR5cGU6IFwic3R5bGluZ1wiLFxuICAgICAgICAgICAgbW9kZTogZ3JvdXAubW9kZSxcbiAgICAgICAgICAgIGJvZHk6IFtncm91cF0sXG4gICAgICAgICAgICBzdHlsZTogXCJ0ZXh0XCIgLy8gc2ltdWxhdGUgXFx0ZXh0c3R5bGVcblxuICAgICAgICAgIH0gOiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJyYXdcIjpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IHRva2VuID0gdGhpcy5wYXJzZVN0cmluZ0dyb3VwKFwicmF3XCIsIG9wdGlvbmFsKTtcbiAgICAgICAgICByZXR1cm4gdG9rZW4gIT0gbnVsbCA/IHtcbiAgICAgICAgICAgIHR5cGU6IFwicmF3XCIsXG4gICAgICAgICAgICBtb2RlOiBcInRleHRcIixcbiAgICAgICAgICAgIHN0cmluZzogdG9rZW4udGV4dFxuICAgICAgICAgIH0gOiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJwcmltaXRpdmVcIjpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChvcHRpb25hbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiQSBwcmltaXRpdmUgYXJndW1lbnQgY2Fubm90IGJlIG9wdGlvbmFsXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGdyb3VwID0gdGhpcy5wYXJzZUdyb3VwKG5hbWUpO1xuXG4gICAgICAgICAgaWYgKGdyb3VwID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIkV4cGVjdGVkIGdyb3VwIGFzIFwiICsgbmFtZSwgdGhpcy5mZXRjaCgpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZ3JvdXA7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIm9yaWdpbmFsXCI6XG4gICAgICBjYXNlIG51bGw6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VBcmd1bWVudEdyb3VwKG9wdGlvbmFsKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiVW5rbm93biBncm91cCB0eXBlIGFzIFwiICsgbmFtZSwgdGhpcy5mZXRjaCgpKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIERpc2NhcmQgYW55IHNwYWNlIHRva2VucywgZmV0Y2hpbmcgdGhlIG5leHQgbm9uLXNwYWNlIHRva2VuLlxuICAgKi9cblxuXG4gIGNvbnN1bWVTcGFjZXMoKSB7XG4gICAgd2hpbGUgKHRoaXMuZmV0Y2goKS50ZXh0ID09PSBcIiBcIikge1xuICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBQYXJzZXMgYSBncm91cCwgZXNzZW50aWFsbHkgcmV0dXJuaW5nIHRoZSBzdHJpbmcgZm9ybWVkIGJ5IHRoZVxuICAgKiBicmFjZS1lbmNsb3NlZCB0b2tlbnMgcGx1cyBzb21lIHBvc2l0aW9uIGluZm9ybWF0aW9uLlxuICAgKi9cblxuXG4gIHBhcnNlU3RyaW5nR3JvdXAobW9kZU5hbWUsIC8vIFVzZWQgdG8gZGVzY3JpYmUgdGhlIG1vZGUgaW4gZXJyb3IgbWVzc2FnZXMuXG4gIG9wdGlvbmFsKSB7XG4gICAgY29uc3QgYXJnVG9rZW4gPSB0aGlzLmd1bGxldC5zY2FuQXJndW1lbnQob3B0aW9uYWwpO1xuXG4gICAgaWYgKGFyZ1Rva2VuID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGxldCBzdHIgPSBcIlwiO1xuICAgIGxldCBuZXh0VG9rZW47XG5cbiAgICB3aGlsZSAoKG5leHRUb2tlbiA9IHRoaXMuZmV0Y2goKSkudGV4dCAhPT0gXCJFT0ZcIikge1xuICAgICAgc3RyICs9IG5leHRUb2tlbi50ZXh0O1xuICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgfVxuXG4gICAgdGhpcy5jb25zdW1lKCk7IC8vIGNvbnN1bWUgdGhlIGVuZCBvZiB0aGUgYXJndW1lbnRcblxuICAgIGFyZ1Rva2VuLnRleHQgPSBzdHI7XG4gICAgcmV0dXJuIGFyZ1Rva2VuO1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZXMgYSByZWdleC1kZWxpbWl0ZWQgZ3JvdXA6IHRoZSBsYXJnZXN0IHNlcXVlbmNlIG9mIHRva2Vuc1xuICAgKiB3aG9zZSBjb25jYXRlbmF0ZWQgc3RyaW5ncyBtYXRjaCBgcmVnZXhgLiBSZXR1cm5zIHRoZSBzdHJpbmdcbiAgICogZm9ybWVkIGJ5IHRoZSB0b2tlbnMgcGx1cyBzb21lIHBvc2l0aW9uIGluZm9ybWF0aW9uLlxuICAgKi9cblxuXG4gIHBhcnNlUmVnZXhHcm91cChyZWdleCwgbW9kZU5hbWUgLy8gVXNlZCB0byBkZXNjcmliZSB0aGUgbW9kZSBpbiBlcnJvciBtZXNzYWdlcy5cbiAgKSB7XG4gICAgY29uc3QgZmlyc3RUb2tlbiA9IHRoaXMuZmV0Y2goKTtcbiAgICBsZXQgbGFzdFRva2VuID0gZmlyc3RUb2tlbjtcbiAgICBsZXQgc3RyID0gXCJcIjtcbiAgICBsZXQgbmV4dFRva2VuO1xuXG4gICAgd2hpbGUgKChuZXh0VG9rZW4gPSB0aGlzLmZldGNoKCkpLnRleHQgIT09IFwiRU9GXCIgJiYgcmVnZXgudGVzdChzdHIgKyBuZXh0VG9rZW4udGV4dCkpIHtcbiAgICAgIGxhc3RUb2tlbiA9IG5leHRUb2tlbjtcbiAgICAgIHN0ciArPSBsYXN0VG9rZW4udGV4dDtcbiAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgIH1cblxuICAgIGlmIChzdHIgPT09IFwiXCIpIHtcbiAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIkludmFsaWQgXCIgKyBtb2RlTmFtZSArIFwiOiAnXCIgKyBmaXJzdFRva2VuLnRleHQgKyBcIidcIiwgZmlyc3RUb2tlbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpcnN0VG9rZW4ucmFuZ2UobGFzdFRva2VuLCBzdHIpO1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZXMgYSBjb2xvciBkZXNjcmlwdGlvbi5cbiAgICovXG5cblxuICBwYXJzZUNvbG9yR3JvdXAob3B0aW9uYWwpIHtcbiAgICBjb25zdCByZXMgPSB0aGlzLnBhcnNlU3RyaW5nR3JvdXAoXCJjb2xvclwiLCBvcHRpb25hbCk7XG5cbiAgICBpZiAocmVzID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IG1hdGNoID0gL14oI1thLWYwLTldezN9fCM/W2EtZjAtOV17Nn18W2Etel0rKSQvaS5leGVjKHJlcy50ZXh0KTtcblxuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIkludmFsaWQgY29sb3I6ICdcIiArIHJlcy50ZXh0ICsgXCInXCIsIHJlcyk7XG4gICAgfVxuXG4gICAgbGV0IGNvbG9yID0gbWF0Y2hbMF07XG5cbiAgICBpZiAoL15bMC05YS1mXXs2fSQvaS50ZXN0KGNvbG9yKSkge1xuICAgICAgLy8gV2UgYWxsb3cgYSA2LWRpZ2l0IEhUTUwgY29sb3Igc3BlYyB3aXRob3V0IGEgbGVhZGluZyBcIiNcIi5cbiAgICAgIC8vIFRoaXMgZm9sbG93cyB0aGUgeGNvbG9yIHBhY2thZ2UncyBIVE1MIGNvbG9yIG1vZGVsLlxuICAgICAgLy8gUHJlZGVmaW5lZCBjb2xvciBuYW1lcyBhcmUgYWxsIG1pc3NlZCBieSB0aGlzIFJlZ0V4IHBhdHRlcm4uXG4gICAgICBjb2xvciA9IFwiI1wiICsgY29sb3I7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiY29sb3ItdG9rZW5cIixcbiAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgIGNvbG9yXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUGFyc2VzIGEgc2l6ZSBzcGVjaWZpY2F0aW9uLCBjb25zaXN0aW5nIG9mIG1hZ25pdHVkZSBhbmQgdW5pdC5cbiAgICovXG5cblxuICBwYXJzZVNpemVHcm91cChvcHRpb25hbCkge1xuICAgIGxldCByZXM7XG4gICAgbGV0IGlzQmxhbmsgPSBmYWxzZTsgLy8gZG9uJ3QgZXhwYW5kIGJlZm9yZSBwYXJzZVN0cmluZ0dyb3VwXG5cbiAgICB0aGlzLmd1bGxldC5jb25zdW1lU3BhY2VzKCk7XG5cbiAgICBpZiAoIW9wdGlvbmFsICYmIHRoaXMuZ3VsbGV0LmZ1dHVyZSgpLnRleHQgIT09IFwie1wiKSB7XG4gICAgICByZXMgPSB0aGlzLnBhcnNlUmVnZXhHcm91cCgvXlstK10/ICooPzokfFxcZCt8XFxkK1xcLlxcZCp8XFwuXFxkKikgKlthLXpdezAsMn0gKiQvLCBcInNpemVcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcyA9IHRoaXMucGFyc2VTdHJpbmdHcm91cChcInNpemVcIiwgb3B0aW9uYWwpO1xuICAgIH1cblxuICAgIGlmICghcmVzKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbmFsICYmIHJlcy50ZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gQmVjYXVzZSB3ZSd2ZSB0ZXN0ZWQgZm9yIHdoYXQgaXMgIW9wdGlvbmFsLCB0aGlzIGJsb2NrIHdvbid0XG4gICAgICAvLyBhZmZlY3QgXFxrZXJuLCBcXGhzcGFjZSwgZXRjLiBJdCB3aWxsIGNhcHR1cmUgdGhlIG1hbmRhdG9yeSBhcmd1bWVudHNcbiAgICAgIC8vIHRvIFxcZ2VuZnJhYyBhbmQgXFxhYm92ZS5cbiAgICAgIHJlcy50ZXh0ID0gXCIwcHRcIjsgLy8gRW5hYmxlIFxcYWJvdmV7fVxuXG4gICAgICBpc0JsYW5rID0gdHJ1ZTsgLy8gVGhpcyBpcyBoZXJlIHNwZWNpZmljYWxseSBmb3IgXFxnZW5mcmFjXG4gICAgfVxuXG4gICAgY29uc3QgbWF0Y2ggPSAvKFstK10/KSAqKFxcZCsoPzpcXC5cXGQqKT98XFwuXFxkKykgKihbYS16XXsyfSkvLmV4ZWMocmVzLnRleHQpO1xuXG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiSW52YWxpZCBzaXplOiAnXCIgKyByZXMudGV4dCArIFwiJ1wiLCByZXMpO1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICBudW1iZXI6ICsobWF0Y2hbMV0gKyBtYXRjaFsyXSksXG4gICAgICAvLyBzaWduICsgbWFnbml0dWRlLCBjYXN0IHRvIG51bWJlclxuICAgICAgdW5pdDogbWF0Y2hbM11cbiAgICB9O1xuXG4gICAgaWYgKCF2YWxpZFVuaXQoZGF0YSkpIHtcbiAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIkludmFsaWQgdW5pdDogJ1wiICsgZGF0YS51bml0ICsgXCInXCIsIHJlcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwic2l6ZVwiLFxuICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgdmFsdWU6IGRhdGEsXG4gICAgICBpc0JsYW5rXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUGFyc2VzIGFuIFVSTCwgY2hlY2tpbmcgZXNjYXBlZCBsZXR0ZXJzIGFuZCBhbGxvd2VkIHByb3RvY29scyxcbiAgICogYW5kIHNldHRpbmcgdGhlIGNhdGNvZGUgb2YgJSBhcyBhbiBhY3RpdmUgY2hhcmFjdGVyIChhcyBpbiBcXGh5cGVycmVmKS5cbiAgICovXG5cblxuICBwYXJzZVVybEdyb3VwKG9wdGlvbmFsKSB7XG4gICAgdGhpcy5ndWxsZXQubGV4ZXIuc2V0Q2F0Y29kZShcIiVcIiwgMTMpOyAvLyBhY3RpdmUgY2hhcmFjdGVyXG5cbiAgICB0aGlzLmd1bGxldC5sZXhlci5zZXRDYXRjb2RlKFwiflwiLCAxMik7IC8vIG90aGVyIGNoYXJhY3RlclxuXG4gICAgY29uc3QgcmVzID0gdGhpcy5wYXJzZVN0cmluZ0dyb3VwKFwidXJsXCIsIG9wdGlvbmFsKTtcbiAgICB0aGlzLmd1bGxldC5sZXhlci5zZXRDYXRjb2RlKFwiJVwiLCAxNCk7IC8vIGNvbW1lbnQgY2hhcmFjdGVyXG5cbiAgICB0aGlzLmd1bGxldC5sZXhlci5zZXRDYXRjb2RlKFwiflwiLCAxMyk7IC8vIGFjdGl2ZSBjaGFyYWN0ZXJcblxuICAgIGlmIChyZXMgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSAvLyBoeXBlcnJlZiBwYWNrYWdlIGFsbG93cyBiYWNrc2xhc2hlcyBhbG9uZSBpbiBocmVmLCBidXQgZG9lc24ndFxuICAgIC8vIGdlbmVyYXRlIHZhbGlkIGxpbmtzIGluIHN1Y2ggY2FzZXM7IHdlIGludGVycHJldCB0aGlzIGFzXG4gICAgLy8gXCJ1bmRlZmluZWRcIiBiZWhhdmlvdXIsIGFuZCBrZWVwIHRoZW0gYXMtaXMuIFNvbWUgYnJvd3NlciB3aWxsXG4gICAgLy8gcmVwbGFjZSBiYWNrc2xhc2hlcyB3aXRoIGZvcndhcmQgc2xhc2hlcy5cblxuXG4gICAgY29uc3QgdXJsID0gcmVzLnRleHQucmVwbGFjZSgvXFxcXChbIyQlJn5fXnt9XSkvZywgJyQxJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwidXJsXCIsXG4gICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICB1cmxcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZXMgYW4gYXJndW1lbnQgd2l0aCB0aGUgbW9kZSBzcGVjaWZpZWQuXG4gICAqL1xuXG5cbiAgcGFyc2VBcmd1bWVudEdyb3VwKG9wdGlvbmFsLCBtb2RlKSB7XG4gICAgY29uc3QgYXJnVG9rZW4gPSB0aGlzLmd1bGxldC5zY2FuQXJndW1lbnQob3B0aW9uYWwpO1xuXG4gICAgaWYgKGFyZ1Rva2VuID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IG91dGVyTW9kZSA9IHRoaXMubW9kZTtcblxuICAgIGlmIChtb2RlKSB7XG4gICAgICAvLyBTd2l0Y2ggdG8gc3BlY2lmaWVkIG1vZGVcbiAgICAgIHRoaXMuc3dpdGNoTW9kZShtb2RlKTtcbiAgICB9XG5cbiAgICB0aGlzLmd1bGxldC5iZWdpbkdyb3VwKCk7XG4gICAgY29uc3QgZXhwcmVzc2lvbiA9IHRoaXMucGFyc2VFeHByZXNzaW9uKGZhbHNlLCBcIkVPRlwiKTsgLy8gVE9ETzogZmluZCBhbiBhbHRlcm5hdGl2ZSB3YXkgdG8gZGVub3RlIHRoZSBlbmRcblxuICAgIHRoaXMuZXhwZWN0KFwiRU9GXCIpOyAvLyBleHBlY3QgdGhlIGVuZCBvZiB0aGUgYXJndW1lbnRcblxuICAgIHRoaXMuZ3VsbGV0LmVuZEdyb3VwKCk7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgdHlwZTogXCJvcmRncm91cFwiLFxuICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgbG9jOiBhcmdUb2tlbi5sb2MsXG4gICAgICBib2R5OiBleHByZXNzaW9uXG4gICAgfTtcblxuICAgIGlmIChtb2RlKSB7XG4gICAgICAvLyBTd2l0Y2ggbW9kZSBiYWNrXG4gICAgICB0aGlzLnN3aXRjaE1vZGUob3V0ZXJNb2RlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZXMgYW4gb3JkaW5hcnkgZ3JvdXAsIHdoaWNoIGlzIGVpdGhlciBhIHNpbmdsZSBudWNsZXVzIChsaWtlIFwieFwiKVxuICAgKiBvciBhbiBleHByZXNzaW9uIGluIGJyYWNlcyAobGlrZSBcInt4K3l9XCIpIG9yIGFuIGltcGxpY2l0IGdyb3VwLCBhIGdyb3VwXG4gICAqIHRoYXQgc3RhcnRzIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uLCBhbmQgZW5kcyByaWdodCBiZWZvcmUgYSBoaWdoZXIgZXhwbGljaXRcbiAgICogZ3JvdXAgZW5kcywgb3IgYXQgRU9GLlxuICAgKi9cblxuXG4gIHBhcnNlR3JvdXAobmFtZSwgLy8gRm9yIGVycm9yIHJlcG9ydGluZy5cbiAgYnJlYWtPblRva2VuVGV4dCkge1xuICAgIGNvbnN0IGZpcnN0VG9rZW4gPSB0aGlzLmZldGNoKCk7XG4gICAgY29uc3QgdGV4dCA9IGZpcnN0VG9rZW4udGV4dDtcbiAgICBsZXQgcmVzdWx0OyAvLyBUcnkgdG8gcGFyc2UgYW4gb3BlbiBicmFjZSBvciBcXGJlZ2luZ3JvdXBcblxuICAgIGlmICh0ZXh0ID09PSBcIntcIiB8fCB0ZXh0ID09PSBcIlxcXFxiZWdpbmdyb3VwXCIpIHtcbiAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgY29uc3QgZ3JvdXBFbmQgPSB0ZXh0ID09PSBcIntcIiA/IFwifVwiIDogXCJcXFxcZW5kZ3JvdXBcIjtcbiAgICAgIHRoaXMuZ3VsbGV0LmJlZ2luR3JvdXAoKTsgLy8gSWYgd2UgZ2V0IGEgYnJhY2UsIHBhcnNlIGFuIGV4cHJlc3Npb25cblxuICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IHRoaXMucGFyc2VFeHByZXNzaW9uKGZhbHNlLCBncm91cEVuZCk7XG4gICAgICBjb25zdCBsYXN0VG9rZW4gPSB0aGlzLmZldGNoKCk7XG4gICAgICB0aGlzLmV4cGVjdChncm91cEVuZCk7IC8vIENoZWNrIHRoYXQgd2UgZ290IGEgbWF0Y2hpbmcgY2xvc2luZyBicmFjZVxuXG4gICAgICB0aGlzLmd1bGxldC5lbmRHcm91cCgpO1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICB0eXBlOiBcIm9yZGdyb3VwXCIsXG4gICAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgICAgbG9jOiBTb3VyY2VMb2NhdGlvbi5yYW5nZShmaXJzdFRva2VuLCBsYXN0VG9rZW4pLFxuICAgICAgICBib2R5OiBleHByZXNzaW9uLFxuICAgICAgICAvLyBBIGdyb3VwIGZvcm1lZCBieSBcXGJlZ2luZ3JvdXAuLi5cXGVuZGdyb3VwIGlzIGEgc2VtaS1zaW1wbGUgZ3JvdXBcbiAgICAgICAgLy8gd2hpY2ggZG9lc24ndCBhZmZlY3Qgc3BhY2luZyBpbiBtYXRoIG1vZGUsIGkuZS4sIGlzIHRyYW5zcGFyZW50LlxuICAgICAgICAvLyBodHRwczovL3RleC5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvMTkzMC93aGVuLXNob3VsZC1vbmUtXG4gICAgICAgIC8vIHVzZS1iZWdpbmdyb3VwLWluc3RlYWQtb2YtYmdyb3VwXG4gICAgICAgIHNlbWlzaW1wbGU6IHRleHQgPT09IFwiXFxcXGJlZ2luZ3JvdXBcIiB8fCB1bmRlZmluZWRcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZXJlIGV4aXN0cyBhIGZ1bmN0aW9uIHdpdGggdGhpcyBuYW1lLCBwYXJzZSB0aGUgZnVuY3Rpb24uXG4gICAgICAvLyBPdGhlcndpc2UsIGp1c3QgcmV0dXJuIGEgbnVjbGV1c1xuICAgICAgcmVzdWx0ID0gdGhpcy5wYXJzZUZ1bmN0aW9uKGJyZWFrT25Ub2tlblRleHQsIG5hbWUpIHx8IHRoaXMucGFyc2VTeW1ib2woKTtcblxuICAgICAgaWYgKHJlc3VsdCA9PSBudWxsICYmIHRleHRbMF0gPT09IFwiXFxcXFwiICYmICFpbXBsaWNpdENvbW1hbmRzLmhhc093blByb3BlcnR5KHRleHQpKSB7XG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnRocm93T25FcnJvcikge1xuICAgICAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIlVuZGVmaW5lZCBjb250cm9sIHNlcXVlbmNlOiBcIiArIHRleHQsIGZpcnN0VG9rZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gdGhpcy5mb3JtYXRVbnN1cHBvcnRlZENtZCh0ZXh0KTtcbiAgICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogRm9ybSBsaWdhdHVyZS1saWtlIGNvbWJpbmF0aW9ucyBvZiBjaGFyYWN0ZXJzIGZvciB0ZXh0IG1vZGUuXG4gICAqIFRoaXMgaW5jbHVkZXMgaW5wdXRzIGxpa2UgXCItLVwiLCBcIi0tLVwiLCBcImBgXCIgYW5kIFwiJydcIi5cbiAgICogVGhlIHJlc3VsdCB3aWxsIHNpbXBseSByZXBsYWNlIG11bHRpcGxlIHRleHRvcmQgbm9kZXMgd2l0aCBhIHNpbmdsZVxuICAgKiBjaGFyYWN0ZXIgaW4gZWFjaCB2YWx1ZSBieSBhIHNpbmdsZSB0ZXh0b3JkIG5vZGUgaGF2aW5nIG11bHRpcGxlXG4gICAqIGNoYXJhY3RlcnMgaW4gaXRzIHZhbHVlLiAgVGhlIHJlcHJlc2VudGF0aW9uIGlzIHN0aWxsIEFTQ0lJIHNvdXJjZS5cbiAgICogVGhlIGdyb3VwIHdpbGwgYmUgbW9kaWZpZWQgaW4gcGxhY2UuXG4gICAqL1xuXG5cbiAgZm9ybUxpZ2F0dXJlcyhncm91cCkge1xuICAgIGxldCBuID0gZ3JvdXAubGVuZ3RoIC0gMTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBjb25zdCBhID0gZ3JvdXBbaV07IC8vICRGbG93Rml4TWU6IE5vdCBldmVyeSBub2RlIHR5cGUgaGFzIGEgYHRleHRgIHByb3BlcnR5LlxuXG4gICAgICBjb25zdCB2ID0gYS50ZXh0O1xuXG4gICAgICBpZiAodiA9PT0gXCItXCIgJiYgZ3JvdXBbaSArIDFdLnRleHQgPT09IFwiLVwiKSB7XG4gICAgICAgIGlmIChpICsgMSA8IG4gJiYgZ3JvdXBbaSArIDJdLnRleHQgPT09IFwiLVwiKSB7XG4gICAgICAgICAgZ3JvdXAuc3BsaWNlKGksIDMsIHtcbiAgICAgICAgICAgIHR5cGU6IFwidGV4dG9yZFwiLFxuICAgICAgICAgICAgbW9kZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICBsb2M6IFNvdXJjZUxvY2F0aW9uLnJhbmdlKGEsIGdyb3VwW2kgKyAyXSksXG4gICAgICAgICAgICB0ZXh0OiBcIi0tLVwiXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbiAtPSAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdyb3VwLnNwbGljZShpLCAyLCB7XG4gICAgICAgICAgICB0eXBlOiBcInRleHRvcmRcIixcbiAgICAgICAgICAgIG1vZGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgbG9jOiBTb3VyY2VMb2NhdGlvbi5yYW5nZShhLCBncm91cFtpICsgMV0pLFxuICAgICAgICAgICAgdGV4dDogXCItLVwiXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbiAtPSAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICgodiA9PT0gXCInXCIgfHwgdiA9PT0gXCJgXCIpICYmIGdyb3VwW2kgKyAxXS50ZXh0ID09PSB2KSB7XG4gICAgICAgIGdyb3VwLnNwbGljZShpLCAyLCB7XG4gICAgICAgICAgdHlwZTogXCJ0ZXh0b3JkXCIsXG4gICAgICAgICAgbW9kZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgbG9jOiBTb3VyY2VMb2NhdGlvbi5yYW5nZShhLCBncm91cFtpICsgMV0pLFxuICAgICAgICAgIHRleHQ6IHYgKyB2XG4gICAgICAgIH0pO1xuICAgICAgICBuIC09IDE7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBQYXJzZSBhIHNpbmdsZSBzeW1ib2wgb3V0IG9mIHRoZSBzdHJpbmcuIEhlcmUsIHdlIGhhbmRsZSBzaW5nbGUgY2hhcmFjdGVyXG4gICAqIHN5bWJvbHMgYW5kIHNwZWNpYWwgZnVuY3Rpb25zIGxpa2UgXFx2ZXJiLlxuICAgKi9cblxuXG4gIHBhcnNlU3ltYm9sKCkge1xuICAgIGNvbnN0IG51Y2xldXMgPSB0aGlzLmZldGNoKCk7XG4gICAgbGV0IHRleHQgPSBudWNsZXVzLnRleHQ7XG5cbiAgICBpZiAoL15cXFxcdmVyYlteYS16QS1aXS8udGVzdCh0ZXh0KSkge1xuICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICBsZXQgYXJnID0gdGV4dC5zbGljZSg1KTtcbiAgICAgIGNvbnN0IHN0YXIgPSBhcmcuY2hhckF0KDApID09PSBcIipcIjtcblxuICAgICAgaWYgKHN0YXIpIHtcbiAgICAgICAgYXJnID0gYXJnLnNsaWNlKDEpO1xuICAgICAgfSAvLyBMZXhlcidzIHRva2VuUmVnZXggaXMgY29uc3RydWN0ZWQgdG8gYWx3YXlzIGhhdmUgbWF0Y2hpbmdcbiAgICAgIC8vIGZpcnN0L2xhc3QgY2hhcmFjdGVycy5cblxuXG4gICAgICBpZiAoYXJnLmxlbmd0aCA8IDIgfHwgYXJnLmNoYXJBdCgwKSAhPT0gYXJnLnNsaWNlKC0xKSkge1xuICAgICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJcXFxcdmVyYiBhc3NlcnRpb24gZmFpbGVkIC0tXFxuICAgICAgICAgICAgICAgICAgICBwbGVhc2UgcmVwb3J0IHdoYXQgaW5wdXQgY2F1c2VkIHRoaXMgYnVnXCIpO1xuICAgICAgfVxuXG4gICAgICBhcmcgPSBhcmcuc2xpY2UoMSwgLTEpOyAvLyByZW1vdmUgZmlyc3QgYW5kIGxhc3QgY2hhclxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInZlcmJcIixcbiAgICAgICAgbW9kZTogXCJ0ZXh0XCIsXG4gICAgICAgIGJvZHk6IGFyZyxcbiAgICAgICAgc3RhclxuICAgICAgfTtcbiAgICB9IC8vIEF0IHRoaXMgcG9pbnQsIHdlIHNob3VsZCBoYXZlIGEgc3ltYm9sLCBwb3NzaWJseSB3aXRoIGFjY2VudHMuXG4gICAgLy8gRmlyc3QgZXhwYW5kIGFueSBhY2NlbnRlZCBiYXNlIHN5bWJvbCBhY2NvcmRpbmcgdG8gdW5pY29kZVN5bWJvbHMuXG5cblxuICAgIGlmICh1bmljb2RlU3ltYm9scy5oYXNPd25Qcm9wZXJ0eSh0ZXh0WzBdKSAmJiAhc3JjX3N5bWJvbHNbdGhpcy5tb2RlXVt0ZXh0WzBdXSkge1xuICAgICAgLy8gVGhpcyBiZWhhdmlvciBpcyBub3Qgc3RyaWN0IChYZVRlWC1jb21wYXRpYmxlKSBpbiBtYXRoIG1vZGUuXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5zdHJpY3QgJiYgdGhpcy5tb2RlID09PSBcIm1hdGhcIikge1xuICAgICAgICB0aGlzLnNldHRpbmdzLnJlcG9ydE5vbnN0cmljdChcInVuaWNvZGVUZXh0SW5NYXRoTW9kZVwiLCBcIkFjY2VudGVkIFVuaWNvZGUgdGV4dCBjaGFyYWN0ZXIgXFxcIlwiICsgdGV4dFswXSArIFwiXFxcIiB1c2VkIGluIFwiICsgXCJtYXRoIG1vZGVcIiwgbnVjbGV1cyk7XG4gICAgICB9XG5cbiAgICAgIHRleHQgPSB1bmljb2RlU3ltYm9sc1t0ZXh0WzBdXSArIHRleHQuc2xpY2UoMSk7XG4gICAgfSAvLyBTdHJpcCBvZmYgYW55IGNvbWJpbmluZyBjaGFyYWN0ZXJzXG5cblxuICAgIGNvbnN0IG1hdGNoID0gY29tYmluaW5nRGlhY3JpdGljYWxNYXJrc0VuZFJlZ2V4LmV4ZWModGV4dCk7XG5cbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBtYXRjaC5pbmRleCk7XG5cbiAgICAgIGlmICh0ZXh0ID09PSAnaScpIHtcbiAgICAgICAgdGV4dCA9ICdcXHUwMTMxJzsgLy8gZG90bGVzcyBpLCBpbiBtYXRoIGFuZCB0ZXh0IG1vZGVcbiAgICAgIH0gZWxzZSBpZiAodGV4dCA9PT0gJ2onKSB7XG4gICAgICAgIHRleHQgPSAnXFx1MDIzNyc7IC8vIGRvdGxlc3MgaiwgaW4gbWF0aCBhbmQgdGV4dCBtb2RlXG4gICAgICB9XG4gICAgfSAvLyBSZWNvZ25pemUgYmFzZSBzeW1ib2xcblxuXG4gICAgbGV0IHN5bWJvbDtcblxuICAgIGlmIChzcmNfc3ltYm9sc1t0aGlzLm1vZGVdW3RleHRdKSB7XG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5zdHJpY3QgJiYgdGhpcy5tb2RlID09PSAnbWF0aCcgJiYgZXh0cmFMYXRpbi5pbmRleE9mKHRleHQpID49IDApIHtcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5yZXBvcnROb25zdHJpY3QoXCJ1bmljb2RlVGV4dEluTWF0aE1vZGVcIiwgXCJMYXRpbi0xL1VuaWNvZGUgdGV4dCBjaGFyYWN0ZXIgXFxcIlwiICsgdGV4dFswXSArIFwiXFxcIiB1c2VkIGluIFwiICsgXCJtYXRoIG1vZGVcIiwgbnVjbGV1cyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGdyb3VwID0gc3JjX3N5bWJvbHNbdGhpcy5tb2RlXVt0ZXh0XS5ncm91cDtcbiAgICAgIGNvbnN0IGxvYyA9IFNvdXJjZUxvY2F0aW9uLnJhbmdlKG51Y2xldXMpO1xuICAgICAgbGV0IHM7XG5cbiAgICAgIGlmIChBVE9NUy5oYXNPd25Qcm9wZXJ0eShncm91cCkpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgICBjb25zdCBmYW1pbHkgPSBncm91cDtcbiAgICAgICAgcyA9IHtcbiAgICAgICAgICB0eXBlOiBcImF0b21cIixcbiAgICAgICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICAgICAgZmFtaWx5LFxuICAgICAgICAgIGxvYyxcbiAgICAgICAgICB0ZXh0XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICAgIHMgPSB7XG4gICAgICAgICAgdHlwZTogZ3JvdXAsXG4gICAgICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgICAgIGxvYyxcbiAgICAgICAgICB0ZXh0XG4gICAgICAgIH07XG4gICAgICB9IC8vICRGbG93Rml4TWVcblxuXG4gICAgICBzeW1ib2wgPSBzO1xuICAgIH0gZWxzZSBpZiAodGV4dC5jaGFyQ29kZUF0KDApID49IDB4ODApIHtcbiAgICAgIC8vIG5vIHN5bWJvbCBmb3IgZS5nLiBeXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5zdHJpY3QpIHtcbiAgICAgICAgaWYgKCFzdXBwb3J0ZWRDb2RlcG9pbnQodGV4dC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgIHRoaXMuc2V0dGluZ3MucmVwb3J0Tm9uc3RyaWN0KFwidW5rbm93blN5bWJvbFwiLCBcIlVucmVjb2duaXplZCBVbmljb2RlIGNoYXJhY3RlciBcXFwiXCIgKyB0ZXh0WzBdICsgXCJcXFwiXCIgKyAoXCIgKFwiICsgdGV4dC5jaGFyQ29kZUF0KDApICsgXCIpXCIpLCBudWNsZXVzKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm1vZGUgPT09IFwibWF0aFwiKSB7XG4gICAgICAgICAgdGhpcy5zZXR0aW5ncy5yZXBvcnROb25zdHJpY3QoXCJ1bmljb2RlVGV4dEluTWF0aE1vZGVcIiwgXCJVbmljb2RlIHRleHQgY2hhcmFjdGVyIFxcXCJcIiArIHRleHRbMF0gKyBcIlxcXCIgdXNlZCBpbiBtYXRoIG1vZGVcIiwgbnVjbGV1cyk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gQWxsIG5vbm1hdGhlbWF0aWNhbCBVbmljb2RlIGNoYXJhY3RlcnMgYXJlIHJlbmRlcmVkIGFzIGlmIHRoZXlcbiAgICAgIC8vIGFyZSBpbiB0ZXh0IG1vZGUgKHdyYXBwZWQgaW4gXFx0ZXh0KSBiZWNhdXNlIHRoYXQncyB3aGF0IGl0XG4gICAgICAvLyB0YWtlcyB0byByZW5kZXIgdGhlbSBpbiBMYVRlWC4gIFNldHRpbmcgYG1vZGU6IHRoaXMubW9kZWAgaXNcbiAgICAgIC8vIGFub3RoZXIgbmF0dXJhbCBjaG9pY2UgKHRoZSB1c2VyIHJlcXVlc3RlZCBtYXRoIG1vZGUpLCBidXRcbiAgICAgIC8vIHRoaXMgbWFrZXMgaXQgbW9yZSBkaWZmaWN1bHQgZm9yIGdldENoYXJhY3Rlck1ldHJpY3MoKSB0b1xuICAgICAgLy8gZGlzdGluZ3Vpc2ggVW5pY29kZSBjaGFyYWN0ZXJzIHdpdGhvdXQgbWV0cmljcyBhbmQgdGhvc2UgZm9yXG4gICAgICAvLyB3aGljaCB3ZSB3YW50IHRvIHNpbXVsYXRlIHRoZSBsZXR0ZXIgTS5cblxuXG4gICAgICBzeW1ib2wgPSB7XG4gICAgICAgIHR5cGU6IFwidGV4dG9yZFwiLFxuICAgICAgICBtb2RlOiBcInRleHRcIixcbiAgICAgICAgbG9jOiBTb3VyY2VMb2NhdGlvbi5yYW5nZShudWNsZXVzKSxcbiAgICAgICAgdGV4dFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7IC8vIEVPRiwgXiwgXywgeywgfSwgZXRjLlxuICAgIH1cblxuICAgIHRoaXMuY29uc3VtZSgpOyAvLyBUcmFuc2Zvcm0gY29tYmluaW5nIGNoYXJhY3RlcnMgaW50byBhY2NlbnRzXG5cbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0Y2hbMF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYWNjZW50ID0gbWF0Y2hbMF1baV07XG5cbiAgICAgICAgaWYgKCF1bmljb2RlQWNjZW50c1thY2NlbnRdKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiVW5rbm93biBhY2NlbnQgJyBcIiArIGFjY2VudCArIFwiJ1wiLCBudWNsZXVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbW1hbmQgPSB1bmljb2RlQWNjZW50c1thY2NlbnRdW3RoaXMubW9kZV0gfHwgdW5pY29kZUFjY2VudHNbYWNjZW50XS50ZXh0O1xuXG4gICAgICAgIGlmICghY29tbWFuZCkge1xuICAgICAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIkFjY2VudCBcIiArIGFjY2VudCArIFwiIHVuc3VwcG9ydGVkIGluIFwiICsgdGhpcy5tb2RlICsgXCIgbW9kZVwiLCBudWNsZXVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN5bWJvbCA9IHtcbiAgICAgICAgICB0eXBlOiBcImFjY2VudFwiLFxuICAgICAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgICAgICBsb2M6IFNvdXJjZUxvY2F0aW9uLnJhbmdlKG51Y2xldXMpLFxuICAgICAgICAgIGxhYmVsOiBjb21tYW5kLFxuICAgICAgICAgIGlzU3RyZXRjaHk6IGZhbHNlLFxuICAgICAgICAgIGlzU2hpZnR5OiB0cnVlLFxuICAgICAgICAgIC8vICRGbG93Rml4TWVcbiAgICAgICAgICBiYXNlOiBzeW1ib2xcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IC8vICRGbG93Rml4TWVcblxuXG4gICAgcmV0dXJuIHN5bWJvbDtcbiAgfVxuXG59XG5QYXJzZXIuZW5kT2ZFeHByZXNzaW9uID0gW1wifVwiLCBcIlxcXFxlbmRncm91cFwiLCBcIlxcXFxlbmRcIiwgXCJcXFxccmlnaHRcIiwgXCImXCJdO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3BhcnNlVHJlZS5qc1xuLyoqXG4gKiBQcm92aWRlcyBhIHNpbmdsZSBmdW5jdGlvbiBmb3IgcGFyc2luZyBhbiBleHByZXNzaW9uIHVzaW5nIGEgUGFyc2VyXG4gKiBUT0RPKGVtaWx5KTogUmVtb3ZlIHRoaXNcbiAqL1xuXG5cblxuXG4vKipcbiAqIFBhcnNlcyBhbiBleHByZXNzaW9uIHVzaW5nIGEgUGFyc2VyLCB0aGVuIHJldHVybnMgdGhlIHBhcnNlZCByZXN1bHQuXG4gKi9cbmNvbnN0IHBhcnNlVHJlZSA9IGZ1bmN0aW9uICh0b1BhcnNlLCBzZXR0aW5ncykge1xuICBpZiAoISh0eXBlb2YgdG9QYXJzZSA9PT0gJ3N0cmluZycgfHwgdG9QYXJzZSBpbnN0YW5jZW9mIFN0cmluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdLYVRlWCBjYW4gb25seSBwYXJzZSBzdHJpbmcgdHlwZWQgZXhwcmVzc2lvbicpO1xuICB9XG5cbiAgY29uc3QgcGFyc2VyID0gbmV3IFBhcnNlcih0b1BhcnNlLCBzZXR0aW5ncyk7IC8vIEJsYW5rIG91dCBhbnkgXFxkZkB0YWcgdG8gYXZvaWQgc3B1cmlvdXMgXCJEdXBsaWNhdGUgXFx0YWdcIiBlcnJvcnNcblxuICBkZWxldGUgcGFyc2VyLmd1bGxldC5tYWNyb3MuY3VycmVudFtcIlxcXFxkZkB0YWdcIl07XG4gIGxldCB0cmVlID0gcGFyc2VyLnBhcnNlKCk7IC8vIFByZXZlbnQgYSBjb2xvciBkZWZpbml0aW9uIGZyb20gcGVyc2lzdGluZyBiZXR3ZWVuIGNhbGxzIHRvIGthdGV4LnJlbmRlcigpLlxuXG4gIGRlbGV0ZSBwYXJzZXIuZ3VsbGV0Lm1hY3Jvcy5jdXJyZW50W1wiXFxcXGN1cnJlbnRAY29sb3JcIl07XG4gIGRlbGV0ZSBwYXJzZXIuZ3VsbGV0Lm1hY3Jvcy5jdXJyZW50W1wiXFxcXGNvbG9yXCJdOyAvLyBJZiB0aGUgaW5wdXQgdXNlZCBcXHRhZywgaXQgd2lsbCBzZXQgdGhlIFxcZGZAdGFnIG1hY3JvIHRvIHRoZSB0YWcuXG4gIC8vIEluIHRoaXMgY2FzZSwgd2Ugc2VwYXJhdGVseSBwYXJzZSB0aGUgdGFnIGFuZCB3cmFwIHRoZSB0cmVlLlxuXG4gIGlmIChwYXJzZXIuZ3VsbGV0Lm1hY3Jvcy5nZXQoXCJcXFxcZGZAdGFnXCIpKSB7XG4gICAgaWYgKCFzZXR0aW5ncy5kaXNwbGF5TW9kZSkge1xuICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiXFxcXHRhZyB3b3JrcyBvbmx5IGluIGRpc3BsYXkgZXF1YXRpb25zXCIpO1xuICAgIH1cblxuICAgIHRyZWUgPSBbe1xuICAgICAgdHlwZTogXCJ0YWdcIixcbiAgICAgIG1vZGU6IFwidGV4dFwiLFxuICAgICAgYm9keTogdHJlZSxcbiAgICAgIHRhZzogcGFyc2VyLnN1YnBhcnNlKFtuZXcgVG9rZW4oXCJcXFxcZGZAdGFnXCIpXSlcbiAgICB9XTtcbiAgfVxuXG4gIHJldHVybiB0cmVlO1xufTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgc3JjX3BhcnNlVHJlZSA9IChwYXJzZVRyZWUpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4va2F0ZXguanNcbi8qIGVzbGludCBuby1jb25zb2xlOjAgKi9cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBtYWluIGVudHJ5IHBvaW50IGZvciBLYVRlWC4gSGVyZSwgd2UgZXhwb3NlIGZ1bmN0aW9ucyBmb3JcbiAqIHJlbmRlcmluZyBleHByZXNzaW9ucyBlaXRoZXIgdG8gRE9NIG5vZGVzIG9yIHRvIG1hcmt1cCBzdHJpbmdzLlxuICpcbiAqIFdlIGFsc28gZXhwb3NlIHRoZSBQYXJzZUVycm9yIGNsYXNzIHRvIGNoZWNrIGlmIGVycm9ycyB0aHJvd24gZnJvbSBLYVRlWCBhcmVcbiAqIGVycm9ycyBpbiB0aGUgZXhwcmVzc2lvbiwgb3IgZXJyb3JzIGluIGphdmFzY3JpcHQgaGFuZGxpbmcuXG4gKi9cblxuXG5cblxuXG5cblxuXG5cblxuXG4vKipcbiAqIFBhcnNlIGFuZCBidWlsZCBhbiBleHByZXNzaW9uLCBhbmQgcGxhY2UgdGhhdCBleHByZXNzaW9uIGluIHRoZSBET00gbm9kZVxuICogZ2l2ZW4uXG4gKi9cbmxldCByZW5kZXIgPSBmdW5jdGlvbiAoZXhwcmVzc2lvbiwgYmFzZU5vZGUsIG9wdGlvbnMpIHtcbiAgYmFzZU5vZGUudGV4dENvbnRlbnQgPSBcIlwiO1xuICBjb25zdCBub2RlID0gcmVuZGVyVG9Eb21UcmVlKGV4cHJlc3Npb24sIG9wdGlvbnMpLnRvTm9kZSgpO1xuICBiYXNlTm9kZS5hcHBlbmRDaGlsZChub2RlKTtcbn07IC8vIEthVGVYJ3Mgc3R5bGVzIGRvbid0IHdvcmsgcHJvcGVybHkgaW4gcXVpcmtzIG1vZGUuIFByaW50IG91dCBhbiBlcnJvciwgYW5kXG4vLyBkaXNhYmxlIHJlbmRlcmluZy5cblxuXG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIGlmIChkb2N1bWVudC5jb21wYXRNb2RlICE9PSBcIkNTUzFDb21wYXRcIikge1xuICAgIHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiICYmIGNvbnNvbGUud2FybihcIldhcm5pbmc6IEthVGVYIGRvZXNuJ3Qgd29yayBpbiBxdWlya3MgbW9kZS4gTWFrZSBzdXJlIHlvdXIgXCIgKyBcIndlYnNpdGUgaGFzIGEgc3VpdGFibGUgZG9jdHlwZS5cIik7XG5cbiAgICByZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJLYVRlWCBkb2Vzbid0IHdvcmsgaW4gcXVpcmtzIG1vZGUuXCIpO1xuICAgIH07XG4gIH1cbn1cbi8qKlxuICogUGFyc2UgYW5kIGJ1aWxkIGFuIGV4cHJlc3Npb24sIGFuZCByZXR1cm4gdGhlIG1hcmt1cCBmb3IgdGhhdC5cbiAqL1xuXG5cbmNvbnN0IHJlbmRlclRvU3RyaW5nID0gZnVuY3Rpb24gKGV4cHJlc3Npb24sIG9wdGlvbnMpIHtcbiAgY29uc3QgbWFya3VwID0gcmVuZGVyVG9Eb21UcmVlKGV4cHJlc3Npb24sIG9wdGlvbnMpLnRvTWFya3VwKCk7XG4gIHJldHVybiBtYXJrdXA7XG59O1xuLyoqXG4gKiBQYXJzZSBhbiBleHByZXNzaW9uIGFuZCByZXR1cm4gdGhlIHBhcnNlIHRyZWUuXG4gKi9cblxuXG5jb25zdCBnZW5lcmF0ZVBhcnNlVHJlZSA9IGZ1bmN0aW9uIChleHByZXNzaW9uLCBvcHRpb25zKSB7XG4gIGNvbnN0IHNldHRpbmdzID0gbmV3IFNldHRpbmdzKG9wdGlvbnMpO1xuICByZXR1cm4gc3JjX3BhcnNlVHJlZShleHByZXNzaW9uLCBzZXR0aW5ncyk7XG59O1xuLyoqXG4gKiBJZiB0aGUgZ2l2ZW4gZXJyb3IgaXMgYSBLYVRlWCBQYXJzZUVycm9yIGFuZCBvcHRpb25zLnRocm93T25FcnJvciBpcyBmYWxzZSxcbiAqIHJlbmRlcnMgdGhlIGludmFsaWQgTGFUZVggYXMgYSBzcGFuIHdpdGggaG92ZXIgdGl0bGUgZ2l2aW5nIHRoZSBLYVRlWFxuICogZXJyb3IgbWVzc2FnZS4gIE90aGVyd2lzZSwgc2ltcGx5IHRocm93cyB0aGUgZXJyb3IuXG4gKi9cblxuXG5jb25zdCByZW5kZXJFcnJvciA9IGZ1bmN0aW9uIChlcnJvciwgZXhwcmVzc2lvbiwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucy50aHJvd09uRXJyb3IgfHwgIShlcnJvciBpbnN0YW5jZW9mIHNyY19QYXJzZUVycm9yKSkge1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgY29uc3Qgbm9kZSA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcImthdGV4LWVycm9yXCJdLCBbbmV3IFN5bWJvbE5vZGUoZXhwcmVzc2lvbildKTtcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJ0aXRsZVwiLCBlcnJvci50b1N0cmluZygpKTtcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcImNvbG9yOlwiICsgb3B0aW9ucy5lcnJvckNvbG9yKTtcbiAgcmV0dXJuIG5vZGU7XG59O1xuLyoqXG4gKiBHZW5lcmF0ZXMgYW5kIHJldHVybnMgdGhlIGthdGV4IGJ1aWxkIHRyZWUuIFRoaXMgaXMgdXNlZCBmb3IgYWR2YW5jZWRcbiAqIHVzZSBjYXNlcyAobGlrZSByZW5kZXJpbmcgdG8gY3VzdG9tIG91dHB1dCkuXG4gKi9cblxuXG5jb25zdCByZW5kZXJUb0RvbVRyZWUgPSBmdW5jdGlvbiAoZXhwcmVzc2lvbiwgb3B0aW9ucykge1xuICBjb25zdCBzZXR0aW5ncyA9IG5ldyBTZXR0aW5ncyhvcHRpb25zKTtcblxuICB0cnkge1xuICAgIGNvbnN0IHRyZWUgPSBzcmNfcGFyc2VUcmVlKGV4cHJlc3Npb24sIHNldHRpbmdzKTtcbiAgICByZXR1cm4gYnVpbGRUcmVlKHRyZWUsIGV4cHJlc3Npb24sIHNldHRpbmdzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gcmVuZGVyRXJyb3IoZXJyb3IsIGV4cHJlc3Npb24sIHNldHRpbmdzKTtcbiAgfVxufTtcbi8qKlxuICogR2VuZXJhdGVzIGFuZCByZXR1cm5zIHRoZSBrYXRleCBidWlsZCB0cmVlLCB3aXRoIGp1c3QgSFRNTCAobm8gTWF0aE1MKS5cbiAqIFRoaXMgaXMgdXNlZCBmb3IgYWR2YW5jZWQgdXNlIGNhc2VzIChsaWtlIHJlbmRlcmluZyB0byBjdXN0b20gb3V0cHV0KS5cbiAqL1xuXG5cbmNvbnN0IHJlbmRlclRvSFRNTFRyZWUgPSBmdW5jdGlvbiAoZXhwcmVzc2lvbiwgb3B0aW9ucykge1xuICBjb25zdCBzZXR0aW5ncyA9IG5ldyBTZXR0aW5ncyhvcHRpb25zKTtcblxuICB0cnkge1xuICAgIGNvbnN0IHRyZWUgPSBzcmNfcGFyc2VUcmVlKGV4cHJlc3Npb24sIHNldHRpbmdzKTtcbiAgICByZXR1cm4gYnVpbGRIVE1MVHJlZSh0cmVlLCBleHByZXNzaW9uLCBzZXR0aW5ncyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHJlbmRlckVycm9yKGVycm9yLCBleHByZXNzaW9uLCBzZXR0aW5ncyk7XG4gIH1cbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGthdGV4ID0gKHtcbiAgLyoqXG4gICAqIEN1cnJlbnQgS2FUZVggdmVyc2lvblxuICAgKi9cbiAgdmVyc2lvbjogXCIwLjE2LjExXCIsXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGdpdmVuIExhVGVYIGludG8gYW4gSFRNTCtNYXRoTUwgY29tYmluYXRpb24sIGFuZCBhZGRzXG4gICAqIGl0IGFzIGEgY2hpbGQgdG8gdGhlIHNwZWNpZmllZCBET00gbm9kZS5cbiAgICovXG4gIHJlbmRlcixcblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgZ2l2ZW4gTGFUZVggaW50byBhbiBIVE1MK01hdGhNTCBjb21iaW5hdGlvbiBzdHJpbmcsXG4gICAqIGZvciBzZW5kaW5nIHRvIHRoZSBjbGllbnQuXG4gICAqL1xuICByZW5kZXJUb1N0cmluZyxcblxuICAvKipcbiAgICogS2FUZVggZXJyb3IsIHVzdWFsbHkgZHVyaW5nIHBhcnNpbmcuXG4gICAqL1xuICBQYXJzZUVycm9yOiBzcmNfUGFyc2VFcnJvcixcblxuICAvKipcbiAgICogVGhlIHNoZW1hIG9mIFNldHRpbmdzXG4gICAqL1xuICBTRVRUSU5HU19TQ0hFTUE6IFNFVFRJTkdTX1NDSEVNQSxcblxuICAvKipcbiAgICogUGFyc2VzIHRoZSBnaXZlbiBMYVRlWCBpbnRvIEthVGVYJ3MgaW50ZXJuYWwgcGFyc2UgdHJlZSBzdHJ1Y3R1cmUsXG4gICAqIHdpdGhvdXQgcmVuZGVyaW5nIHRvIEhUTUwgb3IgTWF0aE1MLlxuICAgKlxuICAgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBub3QgY3VycmVudGx5IHJlY29tbWVuZGVkIGZvciBwdWJsaWMgdXNlLlxuICAgKiBUaGUgaW50ZXJuYWwgdHJlZSByZXByZXNlbnRhdGlvbiBpcyB1bnN0YWJsZSBhbmQgaXMgdmVyeSBsaWtlbHlcbiAgICogdG8gY2hhbmdlLiBVc2UgYXQgeW91ciBvd24gcmlzay5cbiAgICovXG4gIF9fcGFyc2U6IGdlbmVyYXRlUGFyc2VUcmVlLFxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBnaXZlbiBMYVRlWCBpbnRvIGFuIEhUTUwrTWF0aE1MIGludGVybmFsIERPTSB0cmVlXG4gICAqIHJlcHJlc2VudGF0aW9uLCB3aXRob3V0IGZsYXR0ZW5pbmcgdGhhdCByZXByZXNlbnRhdGlvbiB0byBhIHN0cmluZy5cbiAgICpcbiAgICogTk9URTogVGhpcyBtZXRob2QgaXMgbm90IGN1cnJlbnRseSByZWNvbW1lbmRlZCBmb3IgcHVibGljIHVzZS5cbiAgICogVGhlIGludGVybmFsIHRyZWUgcmVwcmVzZW50YXRpb24gaXMgdW5zdGFibGUgYW5kIGlzIHZlcnkgbGlrZWx5XG4gICAqIHRvIGNoYW5nZS4gVXNlIGF0IHlvdXIgb3duIHJpc2suXG4gICAqL1xuICBfX3JlbmRlclRvRG9tVHJlZTogcmVuZGVyVG9Eb21UcmVlLFxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBnaXZlbiBMYVRlWCBpbnRvIGFuIEhUTUwgaW50ZXJuYWwgRE9NIHRyZWUgcmVwcmVzZW50YXRpb24sXG4gICAqIHdpdGhvdXQgTWF0aE1MIGFuZCB3aXRob3V0IGZsYXR0ZW5pbmcgdGhhdCByZXByZXNlbnRhdGlvbiB0byBhIHN0cmluZy5cbiAgICpcbiAgICogTk9URTogVGhpcyBtZXRob2QgaXMgbm90IGN1cnJlbnRseSByZWNvbW1lbmRlZCBmb3IgcHVibGljIHVzZS5cbiAgICogVGhlIGludGVybmFsIHRyZWUgcmVwcmVzZW50YXRpb24gaXMgdW5zdGFibGUgYW5kIGlzIHZlcnkgbGlrZWx5XG4gICAqIHRvIGNoYW5nZS4gVXNlIGF0IHlvdXIgb3duIHJpc2suXG4gICAqL1xuICBfX3JlbmRlclRvSFRNTFRyZWU6IHJlbmRlclRvSFRNTFRyZWUsXG5cbiAgLyoqXG4gICAqIGV4dGVuZHMgaW50ZXJuYWwgZm9udCBtZXRyaWNzIG9iamVjdCB3aXRoIGEgbmV3IG9iamVjdFxuICAgKiBlYWNoIGtleSBpbiB0aGUgbmV3IG9iamVjdCByZXByZXNlbnRzIGEgZm9udCBuYW1lXG4gICovXG4gIF9fc2V0Rm9udE1ldHJpY3M6IHNldEZvbnRNZXRyaWNzLFxuXG4gIC8qKlxuICAgKiBhZGRzIGEgbmV3IHN5bWJvbCB0byBidWlsdGluIHN5bWJvbHMgdGFibGVcbiAgICovXG4gIF9fZGVmaW5lU3ltYm9sOiBkZWZpbmVTeW1ib2wsXG5cbiAgLyoqXG4gICAqIGFkZHMgYSBuZXcgZnVuY3Rpb24gdG8gYnVpbHRpbiBmdW5jdGlvbiBsaXN0LFxuICAgKiB3aGljaCBkaXJlY3RseSBwcm9kdWNlIHBhcnNlIHRyZWUgZWxlbWVudHNcbiAgICogYW5kIGhhdmUgdGhlaXIgb3duIGh0bWwvbWF0aG1sIGJ1aWxkZXJzXG4gICAqL1xuICBfX2RlZmluZUZ1bmN0aW9uOiBkZWZpbmVGdW5jdGlvbixcblxuICAvKipcbiAgICogYWRkcyBhIG5ldyBtYWNybyB0byBidWlsdGluIG1hY3JvIGxpc3RcbiAgICovXG4gIF9fZGVmaW5lTWFjcm86IGRlZmluZU1hY3JvLFxuXG4gIC8qKlxuICAgKiBFeHBvc2UgdGhlIGRvbSB0cmVlIG5vZGUgdHlwZXMsIHdoaWNoIGNhbiBiZSB1c2VmdWwgZm9yIHR5cGUgY2hlY2tpbmcgbm9kZXMuXG4gICAqXG4gICAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG5vdCBjdXJyZW50bHkgcmVjb21tZW5kZWQgZm9yIHB1YmxpYyB1c2UuXG4gICAqIFRoZSBpbnRlcm5hbCB0cmVlIHJlcHJlc2VudGF0aW9uIGlzIHVuc3RhYmxlIGFuZCBpcyB2ZXJ5IGxpa2VseVxuICAgKiB0byBjaGFuZ2UuIFVzZSBhdCB5b3VyIG93biByaXNrLlxuICAgKi9cbiAgX19kb21UcmVlOiB7XG4gICAgU3BhbjogU3BhbixcbiAgICBBbmNob3I6IEFuY2hvcixcbiAgICBTeW1ib2xOb2RlOiBTeW1ib2xOb2RlLFxuICAgIFN2Z05vZGU6IFN2Z05vZGUsXG4gICAgUGF0aE5vZGU6IFBhdGhOb2RlLFxuICAgIExpbmVOb2RlOiBMaW5lTm9kZVxuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2thdGV4LndlYnBhY2suanNcbi8qKlxuICogVGhpcyBpcyB0aGUgd2VicGFjayBlbnRyeSBwb2ludCBmb3IgS2FUZVguIEFzIEVDTUFTY3JpcHQsIGZsb3dbMV0gYW5kIGplc3RbMl1cbiAqIGRvZXNuJ3Qgc3VwcG9ydCBDU1MgbW9kdWxlcyBuYXRpdmVseSwgYSBzZXBhcmF0ZSBlbnRyeSBwb2ludCBpcyB1c2VkIGFuZFxuICogaXQgaXMgbm90IGZsb3d0eXBlZC5cbiAqXG4gKiBbMV0gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vbGFtYmRhaGFuZHMvZDE5ZTBkYTk2Mjg1Yjc0OWYwZWZcbiAqIFsyXSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9qZXN0L2RvY3MvZW4vd2VicGFjay5odG1sXG4gKi9cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBrYXRleF93ZWJwYWNrID0gKGthdGV4KTtcbl9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXTtcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19leHBvcnRzX187XG4vKioqKioqLyB9KSgpXG47XG59KTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/katex/dist/katex.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/about_editor.js":
/*!****************************************!*\
  !*** ./src/components/about_editor.js ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _editorjs_editorjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @editorjs/editorjs */ \"(app-pages-browser)/./node_modules/@editorjs/editorjs/dist/editorjs.mjs\");\n/* harmony import */ var _editorjs_header__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @editorjs/header */ \"(app-pages-browser)/./node_modules/@editorjs/header/dist/header.mjs\");\n/* harmony import */ var _editorjs_list__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @editorjs/list */ \"(app-pages-browser)/./node_modules/@editorjs/list/dist/list.mjs\");\n/* harmony import */ var _editorjs_table__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @editorjs/table */ \"(app-pages-browser)/./node_modules/@editorjs/table/dist/table.mjs\");\n/* harmony import */ var _editorjs_paragraph__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @editorjs/paragraph */ \"(app-pages-browser)/./node_modules/@editorjs/paragraph/dist/paragraph.mjs\");\n/* harmony import */ var _editorjs_marker__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @editorjs/marker */ \"(app-pages-browser)/./node_modules/@editorjs/marker/dist/marker.mjs\");\n/* harmony import */ var _components_editor_template_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @/components/editor_template.js */ \"(app-pages-browser)/./src/components/editor_template.js\");\n/* harmony import */ var _alkhipce_editorjs_aitext__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @alkhipce/editorjs-aitext */ \"(app-pages-browser)/./node_modules/@alkhipce/editorjs-aitext/dist/aitext.mjs\");\n/* harmony import */ var _editorjs_delimiter__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @editorjs/delimiter */ \"(app-pages-browser)/./node_modules/@editorjs/delimiter/dist/delimiter.mjs\");\n/* harmony import */ var editorjs_change_case__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! editorjs-change-case */ \"(app-pages-browser)/./node_modules/editorjs-change-case/dist/bundle.js\");\n/* harmony import */ var editorjs_change_case__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(editorjs_change_case__WEBPACK_IMPORTED_MODULE_11__);\n/* harmony import */ var _editorjs_warning__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @editorjs/warning */ \"(app-pages-browser)/./node_modules/@editorjs/warning/dist/warning.mjs\");\n/* harmony import */ var editorjs_alert__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! editorjs-alert */ \"(app-pages-browser)/./node_modules/editorjs-alert/dist/bundle.js\");\n/* harmony import */ var editorjs_alert__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(editorjs_alert__WEBPACK_IMPORTED_MODULE_13__);\n/* harmony import */ var editorjs_inline_template__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! editorjs-inline-template */ \"(app-pages-browser)/./node_modules/editorjs-inline-template/dist/index.js\");\n/* harmony import */ var editorjs_inline_template__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(editorjs_inline_template__WEBPACK_IMPORTED_MODULE_14__);\n/* harmony import */ var _components_inlineAI__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../components/inlineAI */ \"(app-pages-browser)/./src/components/inlineAI.js\");\n/* harmony import */ var _editorjs_nested_list__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @editorjs/nested-list */ \"(app-pages-browser)/./node_modules/@editorjs/nested-list/dist/nested-list.mjs\");\n/* harmony import */ var _about_template__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./about_template */ \"(app-pages-browser)/./src/components/about_template.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// import NoticeTune from 'editorjs-notice';\nconst TOC = __webpack_require__(/*! @phigoro/editorjs-toc */ \"(app-pages-browser)/./node_modules/@phigoro/editorjs-toc/dist/bundle.js\");\nconst EJLaTex = __webpack_require__(/*! editorjs-latex */ \"(app-pages-browser)/./node_modules/editorjs-latex/src/index.js\");\n// const FontFamily = require('editorjs-inline-font-family-tool');\nconst LLM_END_POINT = \"http://localhost:8000/query\";\nconst Editor = /*#__PURE__*/ _s((0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(_c = _s((props, ref)=>{\n    _s();\n    const editorRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const editor = new _editorjs_editorjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"]({\n            // data: editor_template,\n            holder: \"editorjs\",\n            tools: {\n                paragraph: {\n                    class: _editorjs_paragraph__WEBPACK_IMPORTED_MODULE_6__[\"default\"],\n                    inlineToolbar: true,\n                    enableLineBreaks: true\n                },\n                header: {\n                    class: _editorjs_header__WEBPACK_IMPORTED_MODULE_3__[\"default\"],\n                    inlineToolbar: true\n                },\n                // list: {\n                //     class: List,\n                //     inlineToolbar: true\n                // }, \n                nested_list: {\n                    class: _editorjs_nested_list__WEBPACK_IMPORTED_MODULE_16__[\"default\"],\n                    inlineToolbar: true\n                },\n                table: {\n                    class: _editorjs_table__WEBPACK_IMPORTED_MODULE_5__[\"default\"],\n                    inlineToolbar: true\n                },\n                aiText: {\n                    // if you do not use TypeScript you need to remove \"as unknown as ToolConstructable\" construction\n                    // type ToolConstructable imported from @editorjs/editorjs package\n                    class: _alkhipce_editorjs_aitext__WEBPACK_IMPORTED_MODULE_9__[\"default\"],\n                    config: {\n                        callback: (text)=>{\n                            const myResponse = generateResponse(text);\n                            return Promise.resolve(myResponse);\n                        }\n                    }\n                },\n                Marker: {\n                    class: _editorjs_marker__WEBPACK_IMPORTED_MODULE_7__[\"default\"]\n                },\n                toc: {\n                    class: TOC\n                },\n                delimiter: {\n                    class: _editorjs_delimiter__WEBPACK_IMPORTED_MODULE_10__[\"default\"]\n                },\n                // noticeTune: NoticeTune,\n                ChangeCase: {\n                    class: (editorjs_change_case__WEBPACK_IMPORTED_MODULE_11___default()),\n                    config: {\n                        showLocaleOption: false\n                    }\n                },\n                inlineAI: {\n                    class: _components_inlineAI__WEBPACK_IMPORTED_MODULE_15__[\"default\"]\n                },\n                alert: {\n                    class: (editorjs_alert__WEBPACK_IMPORTED_MODULE_13___default()),\n                    inlineToolbar: true,\n                    config: {\n                        alertTypes: [\n                            \"primary\",\n                            \"secondary\",\n                            \"info\",\n                            \"success\",\n                            \"warning\",\n                            \"danger\",\n                            \"light\",\n                            \"dark\"\n                        ],\n                        defaultType: \"primary\",\n                        messagePlaceHolder: \"Enter a message\"\n                    }\n                }\n            },\n            data: _about_template__WEBPACK_IMPORTED_MODULE_17__[\"default\"],\n            readOnly: true,\n            // tunes: ['noticeTune'],\n            autofocus: true,\n            onReady: ()=>{\n                console.log(\"Editor.js is ready to use\");\n                editorRef.current = editor;\n                if (props.onLoad) {\n                    props.onLoad(editor);\n                }\n            },\n            placeholder: \"Let`s write an AI-Generated SAP!\"\n        });\n        return ()=>{\n            if (editorRef.current) {\n                editorRef.current.destroy();\n                editorRef.current = null;\n            }\n        };\n    }, [\n        props.initialData\n    ]);\n    const generateResponse = async (text)=>{\n        const response = await fetch(LLM_END_POINT, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            // prompt engineering can be done here to add context for the AI model. append other parts of the document to the text\n            body: JSON.stringify({\n                query: text,\n                priority: 1\n            })\n        });\n        const data = await response.json();\n        console.log(data);\n        return data.response.content;\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        id: \"editorjs\",\n        ref: editorRef\n    }, void 0, false, {\n        fileName: \"/home/sasan_esfahani@am.edwards.lcl/nlp-solutions/thv_buddy/src/components/about_editor.js\",\n        lineNumber: 138,\n        columnNumber: 12\n    }, undefined);\n}, \"FXGU5sRik9TpAO5B+Yli91RwFDk=\")), \"FXGU5sRik9TpAO5B+Yli91RwFDk=\");\n_c1 = Editor;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Editor);\nvar _c, _c1;\n$RefreshReg$(_c, \"Editor$forwardRef\");\n$RefreshReg$(_c1, \"Editor\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2Fib3V0X2VkaXRvci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ2tGO0FBQ2pCO0FBQzNCO0FBQ0o7QUFDRTtBQUNRO0FBQ047QUFDd0I7QUFDZjtBQUNIO0FBQ0U7QUFDTjtBQUNMO0FBQ3VCO0FBQ1o7QUFDQztBQUNEO0FBRzlDLDRDQUE0QztBQUc1QyxNQUFNc0IsTUFBTUMsbUJBQU9BLENBQUM7QUFDcEIsTUFBTUMsVUFBVUQsbUJBQU9BLENBQUM7QUFDeEIsa0VBQWtFO0FBQ2xFLE1BQU1FLGdCQUFnQjtBQUN0QixNQUFNQyx1QkFBU3RCLEdBQUFBLGlEQUFVQSxTQUFDLENBQUN1QixPQUFPQzs7SUFDOUIsTUFBTUMsWUFBWTNCLDZDQUFNQSxDQUFDO0lBRXpCRCxnREFBU0EsQ0FBQztRQUVOLE1BQU02QixTQUFTLElBQUl6QiwwREFBUUEsQ0FBQztZQUN4Qix5QkFBeUI7WUFDekIwQixRQUFRO1lBQ1JDLE9BQU87Z0JBQ0hDLFdBQVc7b0JBQ1BDLE9BQU94QiwyREFBU0E7b0JBQ2hCeUIsZUFBZTtvQkFDZkMsa0JBQWtCO2dCQUN0QjtnQkFDQUMsUUFBUTtvQkFDSkgsT0FBTzNCLHdEQUFNQTtvQkFDYjRCLGVBQWU7Z0JBQ25CO2dCQUNBLFVBQVU7Z0JBQ1YsbUJBQW1CO2dCQUNuQiwwQkFBMEI7Z0JBQzFCLE1BQU07Z0JBQ05HLGFBQWE7b0JBQ1RKLE9BQU9kLDhEQUFVQTtvQkFDakJlLGVBQWU7Z0JBQ25CO2dCQUNBSSxPQUFPO29CQUNITCxPQUFPekIsdURBQUtBO29CQUNaMEIsZUFBZTtnQkFDbkI7Z0JBQ0FLLFFBQVE7b0JBQ0osaUdBQWlHO29CQUNqRyxrRUFBa0U7b0JBQ2xFTixPQUFPckIsaUVBQU1BO29CQUNiNEIsUUFBUTt3QkFDTkMsVUFBVSxDQUFDQzs0QkFDVCxNQUFNQyxhQUFhQyxpQkFBaUJGOzRCQUNwQyxPQUFPRyxRQUFRQyxPQUFPLENBQUNIO3dCQUN6QjtvQkFDRjtnQkFDRjtnQkFDRmpDLFFBQVE7b0JBQ0p1QixPQUFPdkIsd0RBQU1BO2dCQUVqQjtnQkFDQXFDLEtBQUs7b0JBQ0RkLE9BQU9aO2dCQUNYO2dCQUNBMkIsV0FBVztvQkFDUGYsT0FBT3BCLDREQUFTQTtnQkFDcEI7Z0JBQ0EsMEJBQTBCO2dCQUMxQkMsWUFBWTtvQkFDUm1CLE9BQU9uQiw4REFBVUE7b0JBQ2pCMEIsUUFBUTt3QkFDSlMsa0JBQWtCO29CQUN0QjtnQkFDSjtnQkFDQS9CLFVBQVU7b0JBQ05lLE9BQU9mLDZEQUFRQTtnQkFDbkI7Z0JBQ0FnQyxPQUFPO29CQUNIakIsT0FBT2pCLHdEQUFLQTtvQkFDWmtCLGVBQWU7b0JBQ2ZNLFFBQVE7d0JBQ0pXLFlBQVk7NEJBQUM7NEJBQVc7NEJBQWE7NEJBQVE7NEJBQVc7NEJBQVc7NEJBQVU7NEJBQVM7eUJBQU87d0JBQzdGQyxhQUFhO3dCQUNiQyxvQkFBb0I7b0JBRXhCO2dCQUNKO1lBQ0o7WUFDQUMsTUFBTWxDLHdEQUFjQTtZQUNwQm1DLFVBQVU7WUFDVix5QkFBeUI7WUFDekJDLFdBQVc7WUFDWEMsU0FBUztnQkFDTEMsUUFBUUMsR0FBRyxDQUFDO2dCQUNaL0IsVUFBVWdDLE9BQU8sR0FBRy9CO2dCQUNwQixJQUFHSCxNQUFNbUMsTUFBTSxFQUFDO29CQUNabkMsTUFBTW1DLE1BQU0sQ0FBQ2hDO2dCQUNqQjtZQUNKO1lBQ0FpQyxhQUFhO1FBQ2pCO1FBRUEsT0FBTztZQUNILElBQUlsQyxVQUFVZ0MsT0FBTyxFQUFFO2dCQUNuQmhDLFVBQVVnQyxPQUFPLENBQUNHLE9BQU87Z0JBQ3pCbkMsVUFBVWdDLE9BQU8sR0FBRztZQUN4QjtRQUVKO0lBQ0osR0FBRztRQUFDbEMsTUFBTXNDLFdBQVc7S0FBQztJQUV0QixNQUFNcEIsbUJBQW1CLE9BQU9GO1FBQzVCLE1BQU11QixXQUFXLE1BQU1DLE1BQU0xQyxlQUFlO1lBQ3hDMkMsUUFBUTtZQUNSQyxTQUFTO2dCQUNMLGdCQUFnQjtZQUNwQjtZQUNBLHNIQUFzSDtZQUN0SEMsTUFBTUMsS0FBS0MsU0FBUyxDQUFDO2dCQUFFQyxPQUFPOUI7Z0JBQU0rQixVQUFVO1lBQUM7UUFDbkQ7UUFFQSxNQUFNbkIsT0FBTyxNQUFNVyxTQUFTUyxJQUFJO1FBQ2hDaEIsUUFBUUMsR0FBRyxDQUFDTDtRQUNaLE9BQU9BLEtBQUtXLFFBQVEsQ0FBQ1UsT0FBTztJQUNoQztJQUVBLHFCQUFPLDhEQUFDQztRQUFJQyxJQUFHO1FBQVdsRCxLQUFLQzs7Ozs7O0FBQ25DOztBQUVBLCtEQUFlSCxNQUFNQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL2Fib3V0X2VkaXRvci5qcz9kOTMwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VJbXBlcmF0aXZlSGFuZGxlLCBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IEVkaXRvckpzLCB7IFRvb2xDb25zdHJ1Y3RhYmxlIH0gZnJvbSAnQGVkaXRvcmpzL2VkaXRvcmpzJztcbmltcG9ydCBIZWFkZXIgZnJvbSAnQGVkaXRvcmpzL2hlYWRlcic7XG5pbXBvcnQgTGlzdCBmcm9tICdAZWRpdG9yanMvbGlzdCc7XG5pbXBvcnQgVGFibGUgZnJvbSAnQGVkaXRvcmpzL3RhYmxlJztcbmltcG9ydCBQYXJhZ3JhcGggZnJvbSAnQGVkaXRvcmpzL3BhcmFncmFwaCc7XG5pbXBvcnQgTWFya2VyIGZyb20gJ0BlZGl0b3Jqcy9tYXJrZXInO1xuaW1wb3J0IGVkaXRvcl90ZW1wbGF0ZSBmcm9tICdAL2NvbXBvbmVudHMvZWRpdG9yX3RlbXBsYXRlLmpzJztcbmltcG9ydCBBSVRleHQgZnJvbSAnQGFsa2hpcGNlL2VkaXRvcmpzLWFpdGV4dCc7XG5pbXBvcnQgRGVsaW1pdGVyIGZyb20gJ0BlZGl0b3Jqcy9kZWxpbWl0ZXInO1xuaW1wb3J0IENoYW5nZUNhc2UgZnJvbSAnZWRpdG9yanMtY2hhbmdlLWNhc2UnO1xuaW1wb3J0IFdhcm5pbmcgZnJvbSAnQGVkaXRvcmpzL3dhcm5pbmcnO1xuaW1wb3J0IEFsZXJ0IGZyb20gJ2VkaXRvcmpzLWFsZXJ0JztcbmltcG9ydCBUZW1wbGF0ZUlubGluZVRvb2wgZnJvbSAnZWRpdG9yanMtaW5saW5lLXRlbXBsYXRlJztcbmltcG9ydCBpbmxpbmVBSSBmcm9tICcuLi9jb21wb25lbnRzL2lubGluZUFJJztcbmltcG9ydCBOZXN0ZWRMaXN0IGZyb20gJ0BlZGl0b3Jqcy9uZXN0ZWQtbGlzdCc7XG5pbXBvcnQgYWJvdXRfdGVtcGxhdGUgZnJvbSAnLi9hYm91dF90ZW1wbGF0ZSc7XG5cblxuLy8gaW1wb3J0IE5vdGljZVR1bmUgZnJvbSAnZWRpdG9yanMtbm90aWNlJztcblxuXG5jb25zdCBUT0MgPSByZXF1aXJlKCdAcGhpZ29yby9lZGl0b3Jqcy10b2MnKTtcbmNvbnN0IEVKTGFUZXggPSByZXF1aXJlKCdlZGl0b3Jqcy1sYXRleCcpO1xuLy8gY29uc3QgRm9udEZhbWlseSA9IHJlcXVpcmUoJ2VkaXRvcmpzLWlubGluZS1mb250LWZhbWlseS10b29sJyk7XG5jb25zdCBMTE1fRU5EX1BPSU5UID0gXCJodHRwOi8vbG9jYWxob3N0OjgwMDAvcXVlcnlcIlxuY29uc3QgRWRpdG9yID0gZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4ge1xuICAgIGNvbnN0IGVkaXRvclJlZiA9IHVzZVJlZihudWxsKTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG5cbiAgICAgICAgY29uc3QgZWRpdG9yID0gbmV3IEVkaXRvckpzKHtcbiAgICAgICAgICAgIC8vIGRhdGE6IGVkaXRvcl90ZW1wbGF0ZSxcbiAgICAgICAgICAgIGhvbGRlcjogJ2VkaXRvcmpzJyxcbiAgICAgICAgICAgIHRvb2xzOiB7XG4gICAgICAgICAgICAgICAgcGFyYWdyYXBoOiB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzOiBQYXJhZ3JhcGgsXG4gICAgICAgICAgICAgICAgICAgIGlubGluZVRvb2xiYXI6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGVuYWJsZUxpbmVCcmVha3M6IHRydWVcbiAgICAgICAgICAgICAgICB9LCBcbiAgICAgICAgICAgICAgICBoZWFkZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M6IEhlYWRlcixcbiAgICAgICAgICAgICAgICAgICAgaW5saW5lVG9vbGJhcjogdHJ1ZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gbGlzdDoge1xuICAgICAgICAgICAgICAgIC8vICAgICBjbGFzczogTGlzdCxcbiAgICAgICAgICAgICAgICAvLyAgICAgaW5saW5lVG9vbGJhcjogdHJ1ZVxuICAgICAgICAgICAgICAgIC8vIH0sIFxuICAgICAgICAgICAgICAgIG5lc3RlZF9saXN0OiB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzOiBOZXN0ZWRMaXN0LFxuICAgICAgICAgICAgICAgICAgICBpbmxpbmVUb29sYmFyOiB0cnVlXG4gICAgICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAgICAgdGFibGU6IHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M6IFRhYmxlLFxuICAgICAgICAgICAgICAgICAgICBpbmxpbmVUb29sYmFyOiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhaVRleHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgeW91IGRvIG5vdCB1c2UgVHlwZVNjcmlwdCB5b3UgbmVlZCB0byByZW1vdmUgXCJhcyB1bmtub3duIGFzIFRvb2xDb25zdHJ1Y3RhYmxlXCIgY29uc3RydWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIC8vIHR5cGUgVG9vbENvbnN0cnVjdGFibGUgaW1wb3J0ZWQgZnJvbSBAZWRpdG9yanMvZWRpdG9yanMgcGFja2FnZVxuICAgICAgICAgICAgICAgICAgICBjbGFzczogQUlUZXh0LCBcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6ICh0ZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBteVJlc3BvbnNlID0gZ2VuZXJhdGVSZXNwb25zZSh0ZXh0KTsgXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG15UmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgTWFya2VyOiB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzOiBNYXJrZXJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXQgXG4gICAgICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAgICAgdG9jOiB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzOiBUT0NcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGRlbGltaXRlcjoge1xuICAgICAgICAgICAgICAgICAgICBjbGFzczogRGVsaW1pdGVyXG4gICAgICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAgICAgLy8gbm90aWNlVHVuZTogTm90aWNlVHVuZSxcbiAgICAgICAgICAgICAgICBDaGFuZ2VDYXNlOiB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzOiBDaGFuZ2VDYXNlLFxuICAgICAgICAgICAgICAgICAgICBjb25maWc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3dMb2NhbGVPcHRpb246IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlubGluZUFJOiB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzOiBpbmxpbmVBSSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGFsZXJ0OiB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzOiBBbGVydCwgXG4gICAgICAgICAgICAgICAgICAgIGlubGluZVRvb2xiYXI6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxlcnRUeXBlczogWydwcmltYXJ5JywgJ3NlY29uZGFyeScsICdpbmZvJywgJ3N1Y2Nlc3MnLCAnd2FybmluZycsICdkYW5nZXInLCAnbGlnaHQnLCAnZGFyayddLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFR5cGU6ICdwcmltYXJ5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VQbGFjZUhvbGRlcjogJ0VudGVyIGEgbWVzc2FnZSdcblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRhdGE6IGFib3V0X3RlbXBsYXRlLFxuICAgICAgICAgICAgcmVhZE9ubHk6IHRydWUsXG4gICAgICAgICAgICAvLyB0dW5lczogWydub3RpY2VUdW5lJ10sXG4gICAgICAgICAgICBhdXRvZm9jdXM6IHRydWUsXG4gICAgICAgICAgICBvblJlYWR5OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0VkaXRvci5qcyBpcyByZWFkeSB0byB1c2UnKTtcbiAgICAgICAgICAgICAgICBlZGl0b3JSZWYuY3VycmVudCA9IGVkaXRvcjtcbiAgICAgICAgICAgICAgICBpZihwcm9wcy5vbkxvYWQpe1xuICAgICAgICAgICAgICAgICAgICBwcm9wcy5vbkxvYWQoZWRpdG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGxhY2Vob2xkZXI6ICdMZXRgcyB3cml0ZSBhbiBBSS1HZW5lcmF0ZWQgU0FQISdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGlmIChlZGl0b3JSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIGVkaXRvclJlZi5jdXJyZW50LmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICBlZGl0b3JSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgfTtcbiAgICB9LCBbcHJvcHMuaW5pdGlhbERhdGFdKTtcblxuICAgIGNvbnN0IGdlbmVyYXRlUmVzcG9uc2UgPSBhc3luYyAodGV4dCkgPT4ge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKExMTV9FTkRfUE9JTlQsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBwcm9tcHQgZW5naW5lZXJpbmcgY2FuIGJlIGRvbmUgaGVyZSB0byBhZGQgY29udGV4dCBmb3IgdGhlIEFJIG1vZGVsLiBhcHBlbmQgb3RoZXIgcGFydHMgb2YgdGhlIGRvY3VtZW50IHRvIHRoZSB0ZXh0XG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHF1ZXJ5OiB0ZXh0LCBwcmlvcml0eTogMX0pXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGRhdGEpO1xuICAgICAgICByZXR1cm4gZGF0YS5yZXNwb25zZS5jb250ZW50O1xuICAgIH1cblxuICAgIHJldHVybiA8ZGl2IGlkPVwiZWRpdG9yanNcIiByZWY9e2VkaXRvclJlZn0+PC9kaXY+O1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IEVkaXRvcjsiXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VJbXBlcmF0aXZlSGFuZGxlIiwiZm9yd2FyZFJlZiIsIkVkaXRvckpzIiwiVG9vbENvbnN0cnVjdGFibGUiLCJIZWFkZXIiLCJMaXN0IiwiVGFibGUiLCJQYXJhZ3JhcGgiLCJNYXJrZXIiLCJlZGl0b3JfdGVtcGxhdGUiLCJBSVRleHQiLCJEZWxpbWl0ZXIiLCJDaGFuZ2VDYXNlIiwiV2FybmluZyIsIkFsZXJ0IiwiVGVtcGxhdGVJbmxpbmVUb29sIiwiaW5saW5lQUkiLCJOZXN0ZWRMaXN0IiwiYWJvdXRfdGVtcGxhdGUiLCJUT0MiLCJyZXF1aXJlIiwiRUpMYVRleCIsIkxMTV9FTkRfUE9JTlQiLCJFZGl0b3IiLCJwcm9wcyIsInJlZiIsImVkaXRvclJlZiIsImVkaXRvciIsImhvbGRlciIsInRvb2xzIiwicGFyYWdyYXBoIiwiY2xhc3MiLCJpbmxpbmVUb29sYmFyIiwiZW5hYmxlTGluZUJyZWFrcyIsImhlYWRlciIsIm5lc3RlZF9saXN0IiwidGFibGUiLCJhaVRleHQiLCJjb25maWciLCJjYWxsYmFjayIsInRleHQiLCJteVJlc3BvbnNlIiwiZ2VuZXJhdGVSZXNwb25zZSIsIlByb21pc2UiLCJyZXNvbHZlIiwidG9jIiwiZGVsaW1pdGVyIiwic2hvd0xvY2FsZU9wdGlvbiIsImFsZXJ0IiwiYWxlcnRUeXBlcyIsImRlZmF1bHRUeXBlIiwibWVzc2FnZVBsYWNlSG9sZGVyIiwiZGF0YSIsInJlYWRPbmx5IiwiYXV0b2ZvY3VzIiwib25SZWFkeSIsImNvbnNvbGUiLCJsb2ciLCJjdXJyZW50Iiwib25Mb2FkIiwicGxhY2Vob2xkZXIiLCJkZXN0cm95IiwiaW5pdGlhbERhdGEiLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwicXVlcnkiLCJwcmlvcml0eSIsImpzb24iLCJjb250ZW50IiwiZGl2IiwiaWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/about_editor.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/editor_template.js":
/*!*******************************************!*\
  !*** ./src/components/editor_template.js ***!
  \*******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\nconst editor_template = {\n    \"time\": 1722872448451,\n    \"blocks\": [\n        {\n            \"id\": \"BuVv3c0Fl0\",\n            \"type\": \"header\",\n            \"data\": {\n                \"text\": \"5 Study Endpoints\",\n                \"level\": 3\n            }\n        },\n        {\n            \"id\": \"mFyfYqwBVQ\",\n            \"type\": \"header\",\n            \"data\": {\n                \"text\": \"5.1 Primary Endpoint\",\n                \"level\": 3\n            }\n        },\n        {\n            \"id\": \"eVqfgosVzt\",\n            \"type\": \"paragraph\",\n            \"data\": {\n                \"text\": \"The primary endpoint is a non-hierarchical composite of death and stroke at 1 year.&nbsp;\"\n            }\n        },\n        {\n            \"id\": \"GXnFgw88bj\",\n            \"type\": \"header\",\n            \"data\": {\n                \"text\": \"5.2 Secondary Endpoints&nbsp;\",\n                \"level\": 3\n            }\n        },\n        {\n            \"id\": \"Pr0H8vVfgz\",\n            \"type\": \"paragraph\",\n            \"data\": {\n                \"text\": \"The following secondary endpoints will be evaluated for labeling purposes:&nbsp;\"\n            }\n        },\n        {\n            \"id\": \"3hDMw_3r_t\",\n            \"type\": \"nested_list\",\n            \"data\": {\n                \"style\": \"unordered\",\n                \"items\": [\n                    {\n                        \"content\": \"Favorable outcomes per VARC-3 at 1 year: Composite of 1) alive 2) Kansas City Cardiomyopathy Questionnaire (KCCQ) score  60, and 3) KCCQ score decrease 10 points from baseline\",\n                        \"items\": []\n                    },\n                    {\n                        \"content\": \"Paravalvular leak (PVL) at 30 days\",\n                        \"items\": []\n                    },\n                    {\n                        \"content\": \"New permanent pacemaker implantation (PPMI) at 30 days\",\n                        \"items\": []\n                    }\n                ]\n            }\n        },\n        {\n            \"id\": \"Y_IFhSko2I\",\n            \"type\": \"header\",\n            \"data\": {\n                \"text\": \"5.3 Additional Outcomes\",\n                \"level\": 3\n            }\n        },\n        {\n            \"id\": \"jqot7K5y0X\",\n            \"type\": \"paragraph\",\n            \"data\": {\n                \"text\": \"The following outcomes will be summarized for the historical control and the SAPIEN X4 cohorts&nbsp;at 30 days and 1 year:\"\n            }\n        },\n        {\n            \"id\": \"zp8uYvumcj\",\n            \"type\": \"nested_list\",\n            \"data\": {\n                \"style\": \"unordered\",\n                \"items\": [\n                    {\n                        \"content\": \"Death \",\n                        \"items\": []\n                    },\n                    {\n                        \"content\": \"Stroke\",\n                        \"items\": []\n                    },\n                    {\n                        \"content\": \" Aortic valve reintervention \",\n                        \"items\": []\n                    },\n                    {\n                        \"content\": \"Rehospitalization (procedure-related or valve-related)\",\n                        \"items\": []\n                    },\n                    {\n                        \"content\": \"New York Heart Association (NYHA) functional class\",\n                        \"items\": []\n                    },\n                    {\n                        \"content\": \"KCCQ score\",\n                        \"items\": []\n                    },\n                    {\n                        \"content\": \"Aortic valve mean gradient\",\n                        \"items\": []\n                    }\n                ]\n            }\n        },\n        {\n            \"id\": \"guVSFxgzj9\",\n            \"type\": \"paragraph\",\n            \"data\": {\n                \"text\": \"The following outcomes will be assessed in the SAPIEN X4 cohort:\"\n            }\n        },\n        {\n            \"id\": \"nopYT3Y29G\",\n            \"type\": \"nested_list\",\n            \"data\": {\n                \"style\": \"unordered\",\n                \"items\": [\n                    {\n                        \"content\": \"Commissural alignment as assessed by Computed Tomography (CT) core lab\",\n                        \"items\": []\n                    },\n                    {\n                        \"content\": \" Valve placement relative to coronary arteries as assessed by CT core lab\",\n                        \"items\": []\n                    }\n                ]\n            }\n        }\n    ],\n    \"version\": \"2.30.0\"\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (editor_template);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2VkaXRvcl90ZW1wbGF0ZS5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsTUFBTUEsa0JBQWtCO0lBQ3RCLFFBQVE7SUFDUixVQUFVO1FBQ1I7WUFDRSxNQUFNO1lBQ04sUUFBUTtZQUNSLFFBQVE7Z0JBQ04sUUFBUTtnQkFDUixTQUFTO1lBQ1g7UUFDRjtRQUNBO1lBQ0UsTUFBTTtZQUNOLFFBQVE7WUFDUixRQUFRO2dCQUNOLFFBQVE7Z0JBQ1IsU0FBUztZQUNYO1FBQ0Y7UUFDQTtZQUNFLE1BQU07WUFDTixRQUFRO1lBQ1IsUUFBUTtnQkFDTixRQUFRO1lBQ1Y7UUFDRjtRQUNBO1lBQ0UsTUFBTTtZQUNOLFFBQVE7WUFDUixRQUFRO2dCQUNOLFFBQVE7Z0JBQ1IsU0FBUztZQUNYO1FBQ0Y7UUFDQTtZQUNFLE1BQU07WUFDTixRQUFRO1lBQ1IsUUFBUTtnQkFDTixRQUFRO1lBQ1Y7UUFDRjtRQUNBO1lBQ0UsTUFBTTtZQUNOLFFBQVE7WUFDUixRQUFRO2dCQUNOLFNBQVM7Z0JBQ1QsU0FBUztvQkFDUDt3QkFDRSxXQUFXO3dCQUNYLFNBQVMsRUFBRTtvQkFDYjtvQkFDQTt3QkFDRSxXQUFXO3dCQUNYLFNBQVMsRUFBRTtvQkFDYjtvQkFDQTt3QkFDRSxXQUFXO3dCQUNYLFNBQVMsRUFBRTtvQkFDYjtpQkFDRDtZQUNIO1FBQ0Y7UUFDQTtZQUNFLE1BQU07WUFDTixRQUFRO1lBQ1IsUUFBUTtnQkFDTixRQUFRO2dCQUNSLFNBQVM7WUFDWDtRQUNGO1FBQ0E7WUFDRSxNQUFNO1lBQ04sUUFBUTtZQUNSLFFBQVE7Z0JBQ04sUUFBUTtZQUNWO1FBQ0Y7UUFDQTtZQUNFLE1BQU07WUFDTixRQUFRO1lBQ1IsUUFBUTtnQkFDTixTQUFTO2dCQUNULFNBQVM7b0JBQ1A7d0JBQ0UsV0FBVzt3QkFDWCxTQUFTLEVBQUU7b0JBQ2I7b0JBQ0E7d0JBQ0UsV0FBVzt3QkFDWCxTQUFTLEVBQUU7b0JBQ2I7b0JBQ0E7d0JBQ0UsV0FBVzt3QkFDWCxTQUFTLEVBQUU7b0JBQ2I7b0JBQ0E7d0JBQ0UsV0FBVzt3QkFDWCxTQUFTLEVBQUU7b0JBQ2I7b0JBQ0E7d0JBQ0UsV0FBVzt3QkFDWCxTQUFTLEVBQUU7b0JBQ2I7b0JBQ0E7d0JBQ0UsV0FBVzt3QkFDWCxTQUFTLEVBQUU7b0JBQ2I7b0JBQ0E7d0JBQ0UsV0FBVzt3QkFDWCxTQUFTLEVBQUU7b0JBQ2I7aUJBQ0Q7WUFDSDtRQUNGO1FBQ0E7WUFDRSxNQUFNO1lBQ04sUUFBUTtZQUNSLFFBQVE7Z0JBQ04sUUFBUTtZQUNWO1FBQ0Y7UUFDQTtZQUNFLE1BQU07WUFDTixRQUFRO1lBQ1IsUUFBUTtnQkFDTixTQUFTO2dCQUNULFNBQVM7b0JBQ1A7d0JBQ0UsV0FBVzt3QkFDWCxTQUFTLEVBQUU7b0JBQ2I7b0JBQ0E7d0JBQ0UsV0FBVzt3QkFDWCxTQUFTLEVBQUU7b0JBQ2I7aUJBQ0Q7WUFDSDtRQUNGO0tBQ0Q7SUFDRCxXQUFXO0FBQ2I7QUFFQSwrREFBZUEsZUFBZUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9lZGl0b3JfdGVtcGxhdGUuanM/MjAxZSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBlZGl0b3JfdGVtcGxhdGUgPSB7XG4gIFwidGltZVwiOiAxNzIyODcyNDQ4NDUxLFxuICBcImJsb2Nrc1wiOiBbXG4gICAge1xuICAgICAgXCJpZFwiOiBcIkJ1VnYzYzBGbDBcIixcbiAgICAgIFwidHlwZVwiOiBcImhlYWRlclwiLFxuICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgXCJ0ZXh0XCI6IFwiNSBTdHVkeSBFbmRwb2ludHNcIixcbiAgICAgICAgXCJsZXZlbFwiOiAzXG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBcImlkXCI6IFwibUZ5Zllxd0JWUVwiLFxuICAgICAgXCJ0eXBlXCI6IFwiaGVhZGVyXCIsXG4gICAgICBcImRhdGFcIjoge1xuICAgICAgICBcInRleHRcIjogXCI1LjEgUHJpbWFyeSBFbmRwb2ludFwiLFxuICAgICAgICBcImxldmVsXCI6IDNcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIFwiaWRcIjogXCJlVnFmZ29zVnp0XCIsXG4gICAgICBcInR5cGVcIjogXCJwYXJhZ3JhcGhcIixcbiAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgIFwidGV4dFwiOiBcIlRoZSBwcmltYXJ5IGVuZHBvaW50IGlzIGEgbm9uLWhpZXJhcmNoaWNhbCBjb21wb3NpdGUgb2YgZGVhdGggYW5kIHN0cm9rZSBhdCAxIHllYXIuJm5ic3A7XCJcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIFwiaWRcIjogXCJHWG5GZ3c4OGJqXCIsXG4gICAgICBcInR5cGVcIjogXCJoZWFkZXJcIixcbiAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgIFwidGV4dFwiOiBcIjUuMiBTZWNvbmRhcnkgRW5kcG9pbnRzJm5ic3A7XCIsXG4gICAgICAgIFwibGV2ZWxcIjogM1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgXCJpZFwiOiBcIlByMEg4dlZmZ3pcIixcbiAgICAgIFwidHlwZVwiOiBcInBhcmFncmFwaFwiLFxuICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgXCJ0ZXh0XCI6IFwiVGhlIGZvbGxvd2luZyBzZWNvbmRhcnkgZW5kcG9pbnRzIHdpbGwgYmUgZXZhbHVhdGVkIGZvciBsYWJlbGluZyBwdXJwb3NlczombmJzcDtcIlxuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgXCJpZFwiOiBcIjNoRE13XzNyX3RcIixcbiAgICAgIFwidHlwZVwiOiBcIm5lc3RlZF9saXN0XCIsXG4gICAgICBcImRhdGFcIjoge1xuICAgICAgICBcInN0eWxlXCI6IFwidW5vcmRlcmVkXCIsXG4gICAgICAgIFwiaXRlbXNcIjogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIFwiY29udGVudFwiOiBcIkZhdm9yYWJsZSBvdXRjb21lcyBwZXIgVkFSQy0zIGF0IDEgeWVhcjogQ29tcG9zaXRlIG9mIDEpIGFsaXZlIDIpIEthbnNhcyBDaXR5IENhcmRpb215b3BhdGh5IFF1ZXN0aW9ubmFpcmUgKEtDQ1EpIHNjb3JlIOKJpSA2MCwgYW5kIDMpIEtDQ1Egc2NvcmUgZGVjcmVhc2Ug4omkMTAgcG9pbnRzIGZyb20gYmFzZWxpbmVcIixcbiAgICAgICAgICAgIFwiaXRlbXNcIjogW11cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIFwiY29udGVudFwiOiBcIlBhcmF2YWx2dWxhciBsZWFrIChQVkwpIGF0IDMwIGRheXNcIixcbiAgICAgICAgICAgIFwiaXRlbXNcIjogW11cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIFwiY29udGVudFwiOiBcIk5ldyBwZXJtYW5lbnQgcGFjZW1ha2VyIGltcGxhbnRhdGlvbiAoUFBNSSkgYXQgMzAgZGF5c1wiLFxuICAgICAgICAgICAgXCJpdGVtc1wiOiBbXVxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgXCJpZFwiOiBcIllfSUZoU2tvMklcIixcbiAgICAgIFwidHlwZVwiOiBcImhlYWRlclwiLFxuICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgXCJ0ZXh0XCI6IFwiNS4zIEFkZGl0aW9uYWwgT3V0Y29tZXNcIixcbiAgICAgICAgXCJsZXZlbFwiOiAzXG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBcImlkXCI6IFwianFvdDdLNXkwWFwiLFxuICAgICAgXCJ0eXBlXCI6IFwicGFyYWdyYXBoXCIsXG4gICAgICBcImRhdGFcIjoge1xuICAgICAgICBcInRleHRcIjogXCJUaGUgZm9sbG93aW5nIG91dGNvbWVzIHdpbGwgYmUgc3VtbWFyaXplZCBmb3IgdGhlIGhpc3RvcmljYWwgY29udHJvbCBhbmQgdGhlIFNBUElFTiBYNCBjb2hvcnRzJm5ic3A7YXQgMzAgZGF5cyBhbmQgMSB5ZWFyOlwiXG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBcImlkXCI6IFwienA4dVl2dW1jalwiLFxuICAgICAgXCJ0eXBlXCI6IFwibmVzdGVkX2xpc3RcIixcbiAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgIFwic3R5bGVcIjogXCJ1bm9yZGVyZWRcIixcbiAgICAgICAgXCJpdGVtc1wiOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgXCJjb250ZW50XCI6IFwiRGVhdGggXCIsXG4gICAgICAgICAgICBcIml0ZW1zXCI6IFtdXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBcImNvbnRlbnRcIjogXCJTdHJva2VcIixcbiAgICAgICAgICAgIFwiaXRlbXNcIjogW11cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIFwiY29udGVudFwiOiBcIiBBb3J0aWMgdmFsdmUgcmVpbnRlcnZlbnRpb24gXCIsXG4gICAgICAgICAgICBcIml0ZW1zXCI6IFtdXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBcImNvbnRlbnRcIjogXCJSZWhvc3BpdGFsaXphdGlvbiAocHJvY2VkdXJlLXJlbGF0ZWQgb3IgdmFsdmUtcmVsYXRlZClcIixcbiAgICAgICAgICAgIFwiaXRlbXNcIjogW11cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIFwiY29udGVudFwiOiBcIk5ldyBZb3JrIEhlYXJ0IEFzc29jaWF0aW9uIChOWUhBKSBmdW5jdGlvbmFsIGNsYXNzXCIsXG4gICAgICAgICAgICBcIml0ZW1zXCI6IFtdXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBcImNvbnRlbnRcIjogXCJLQ0NRIHNjb3JlXCIsXG4gICAgICAgICAgICBcIml0ZW1zXCI6IFtdXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBcImNvbnRlbnRcIjogXCJBb3J0aWMgdmFsdmUgbWVhbiBncmFkaWVudFwiLFxuICAgICAgICAgICAgXCJpdGVtc1wiOiBbXVxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgXCJpZFwiOiBcImd1VlNGeGd6ajlcIixcbiAgICAgIFwidHlwZVwiOiBcInBhcmFncmFwaFwiLFxuICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgXCJ0ZXh0XCI6IFwiVGhlIGZvbGxvd2luZyBvdXRjb21lcyB3aWxsIGJlIGFzc2Vzc2VkIGluIHRoZSBTQVBJRU4gWDQgY29ob3J0OlwiXG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBcImlkXCI6IFwibm9wWVQzWTI5R1wiLFxuICAgICAgXCJ0eXBlXCI6IFwibmVzdGVkX2xpc3RcIixcbiAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgIFwic3R5bGVcIjogXCJ1bm9yZGVyZWRcIixcbiAgICAgICAgXCJpdGVtc1wiOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgXCJjb250ZW50XCI6IFwiQ29tbWlzc3VyYWwgYWxpZ25tZW50IGFzIGFzc2Vzc2VkIGJ5IENvbXB1dGVkIFRvbW9ncmFwaHkgKENUKSBjb3JlIGxhYlwiLFxuICAgICAgICAgICAgXCJpdGVtc1wiOiBbXVxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgXCJjb250ZW50XCI6IFwiIFZhbHZlIHBsYWNlbWVudCByZWxhdGl2ZSB0byBjb3JvbmFyeSBhcnRlcmllcyBhcyBhc3Nlc3NlZCBieSBDVCBjb3JlIGxhYlwiLFxuICAgICAgICAgICAgXCJpdGVtc1wiOiBbXVxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfVxuICAgIH1cbiAgXSxcbiAgXCJ2ZXJzaW9uXCI6IFwiMi4zMC4wXCJcbn1cblxuZXhwb3J0IGRlZmF1bHQgZWRpdG9yX3RlbXBsYXRlOyJdLCJuYW1lcyI6WyJlZGl0b3JfdGVtcGxhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/editor_template.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/inlineAI.js":
/*!************************************!*\
  !*** ./src/components/inlineAI.js ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ inlineAI; }\n/* harmony export */ });\nconst LLM_END_POINT = \"http://localhost:8000/query\";\nclass inlineAI {\n    render() {\n        this.button = document.createElement(\"button\");\n        this.button.type = \"button\";\n        this.button.innerHTML = '\\n      <svg class=\"icon\" height=\"24\" viewBox=\"0 0 24 24\" width=\"24\">\\n      <style> \\n      .icon:hover { background: #eff2f5;}\\n      </style>\\n        <path class=\"fill\" d=\"m19 9 1.25-2.75L23 5l-2.75-1.25L19 1l-1.25 2.75L15 5l2.75 1.25zm-7.5.5L9 4 6.5 9.5 1 12l5.5 2.5L9 20l2.5-5.5L17 12zM19 15l-1.25 2.75L15 19l2.75 1.25L19 23l1.25-2.75L23 19l-2.75-1.25z\"/>\\n      </svg>\\n    ';\n        return this.button;\n    }\n    surround(range) {\n        this.selected_text = range.cloneContents();\n        this.range = range;\n    }\n    highlightSelectedText(selection) {\n        // const selection = window.getSelection();\n        if (selection.rangeCount > 0) {\n            const range = selection.getRangeAt(0);\n            const mark = document.createElement(\"mark\");\n            mark.className = \"cdx-marker\";\n            const contents = range.extractContents();\n            mark.appendChild(contents);\n            range.insertNode(mark);\n        }\n    }\n    renderActions() {\n        // this.highlightSelectedText();\n        const actionContainer = document.createElement(\"div\");\n        actionContainer.style = \"max-width: 100%; overflow-x: hidden; height: auto; background-color: #f8f9fa; display: flex; flex-direction: column; align-items: left; padding: 10px 10px 10px 10px; box-sizing: border-box; \";\n        const textBox = document.createElement(\"input\");\n        textBox.type = \"text\";\n        textBox.placeholder = \"Query here...\";\n        textBox.style = \"flex-grow: 1; margin-right: 10px; height: 40px; padding: 0 10px; box-sizing: border-box; padding: 10px 10px 10px 10px; display: block; font-size: 10px !important;\";\n        // let selection = window.getSelection();\n        textBox.addEventListener(\"click\", ()=>{\n            const selectedText = this.range.extractContents();\n            // Create MARK element\n            const mark = document.createElement(\"MARK\");\n            // Append to the MARK element selected TextNode\n            mark.appendChild(selectedText);\n            // Insert new element\n            this.range.insertNode(mark);\n            this.highlighted = mark;\n        });\n        const submitButton = document.createElement(\"button\");\n        submitButton.innerHTML = \"Submit\";\n        submitButton.style = \"width: 80px; height: 40px; border-radius: 20px; background-color: #007bff; color: white; border: none; cursor: pointer; box-sizing: border-box; margin-top: 10px;\";\n        const loadingSpinner = document.createElement(\"div\");\n        loadingSpinner.style = \"display: none; border: 4px solid #f3f3f3; border-top: 4px solid #3498db; border-radius: 50%; width: 30px; height: 30px; animation: spin 2s linear infinite; margin-top: 10px;\";\n        loadingSpinner.setAttribute(\"id\", \"loading-spinner\");\n        const style = document.createElement(\"style\");\n        style.textContent = \"\\n            @keyframes spin {\\n                0% { transform: rotate(0deg); }\\n                100% { transform: rotate(360deg); }\\n            }\\n        \";\n        document.head.appendChild(style);\n        submitButton.onclick = async ()=>{\n            // make the drop down window to be a spinning wheeel \n            loadingSpinner.style.display = \"block\";\n            submitButton.style.display = \"none\";\n            console.log(this.selected_text.textContent, typeof this.selected_text.textContent);\n            let response = await this.generateResponse(textBox.value + \": \" + this.selected_text.textContent);\n            loadingSpinner.style.display = \"none\";\n            textBox.style.display = \"none\";\n            const responseDev = document.createElement(\"div\");\n            responseDev.textContent = response;\n            responseDev.style.marginTop = \"10px\";\n            responseDev.style.fontSize = \"10px\";\n            actionContainer.appendChild(responseDev);\n            const acceptButton = document.createElement(\"button\");\n            acceptButton.innerHTML = \"Accept\";\n            acceptButton.style = \"width: 80px; height: 40px; border-radius: 20px; background-color: #007bff; color: white; border: none; cursor: pointer; box-sizing: border-box; margin-top: 10px;\";\n            const declineButton = document.createElement(\"button\");\n            declineButton.innerHTML = \"Decline\";\n            declineButton.style = \"width: 80px; height: 40px; border-radius: 20px; background-color: #007bff; color: white; border: none; cursor: pointer; box-sizing: border-box; margin-top: 10px;\";\n            // const retryButton = document.createElement('button');\n            // retryButton.innerHTML = \"Retry\";\n            // retryButton.style = \"width: 80px; height: 40px; border-radius: 20px; background-color: #007bff; color: white; border: none; cursor: pointer; box-sizing: border-box; margin-top: 10px;\";\n            actionContainer.appendChild(acceptButton);\n            actionContainer.appendChild(declineButton);\n            // actionContainer.appendChild(retryButton);\n            declineButton.addEventListener(\"click\", ()=>{\n                // Show the input text box and the submit button\n                textBox.style.display = \"block\";\n                submitButton.style.display = \"block\";\n                // remove the response and the buttons\n                responseDev.remove();\n                acceptButton.remove();\n                declineButton.remove();\n            });\n            acceptButton.addEventListener(\"click\", ()=>{\n                // Replace the selected text \n                this.accept = true;\n                this.range.deleteContents();\n                this.range.insertNode(document.createTextNode(response));\n            // this.api.inlineToolbar.close();\n            });\n        };\n        actionContainer.appendChild(textBox);\n        actionContainer.appendChild(submitButton);\n        actionContainer.appendChild(loadingSpinner);\n        return actionContainer;\n    }\n    // removeHighlight() {\n    //     if (this.highlightedElement) {\n    //         const parent = this.highlightedElement.parentNode;\n    //         while (this.highlightedElement.firstChild) {\n    //             parent.insertBefore(this.highlightedElement.firstChild, this.highlightedElement);\n    //         }\n    //         parent.removeChild(this.highlightedElement);\n    //         this.highlightedElement = null; // Clear the reference\n    //     }\n    // }\n    static get isInline() {\n        return true;\n    }\n    clear() {\n        if (this.range && !this.accept) {\n            this.range.deleteContents();\n            this.range.insertNode(this.selected_text);\n        }\n    }\n    constructor({ config, api }){\n        this.generateResponse = async (text)=>{\n            const response = await fetch(LLM_END_POINT, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    query: text,\n                    priority: 1\n                })\n            });\n            const data = await response.json();\n            console.log(data);\n            return data.response.content;\n        };\n        this.api = api;\n        this.button = null;\n        this.selected_text = null;\n        this.range = null;\n        this.highlighted = null;\n        this.accept = false;\n    }\n}\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2lubGluZUFJLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxNQUFNQSxnQkFBZ0I7QUFFUCxNQUFNQztJQXdCakJDLFNBQVM7UUFDTCxJQUFJLENBQUNDLE1BQU0sR0FBR0MsU0FBU0MsYUFBYSxDQUFDO1FBQ3JDLElBQUksQ0FBQ0YsTUFBTSxDQUFDRyxJQUFJLEdBQUc7UUFDbkIsSUFBSSxDQUFDSCxNQUFNLENBQUNJLFNBQVMsR0FBSTtRQVF6QixPQUFPLElBQUksQ0FBQ0osTUFBTTtJQUN0QjtJQUVBSyxTQUFTQyxLQUFLLEVBQUM7UUFFWCxJQUFJLENBQUNDLGFBQWEsR0FBR0QsTUFBTUUsYUFBYTtRQUN4QyxJQUFJLENBQUNGLEtBQUssR0FBR0E7SUFJakI7SUFFQUcsc0JBQXNCQyxTQUFTLEVBQUU7UUFDN0IsMkNBQTJDO1FBQzNDLElBQUlBLFVBQVVDLFVBQVUsR0FBRyxHQUFHO1lBQzFCLE1BQU1MLFFBQVFJLFVBQVVFLFVBQVUsQ0FBQztZQUNuQyxNQUFNQyxPQUFPWixTQUFTQyxhQUFhLENBQUM7WUFDcENXLEtBQUtDLFNBQVMsR0FBRztZQUNqQixNQUFNQyxXQUFXVCxNQUFNVSxlQUFlO1lBRXRDSCxLQUFLSSxXQUFXLENBQUNGO1lBRWpCVCxNQUFNWSxVQUFVLENBQUNMO1FBR3JCO0lBQ0o7SUFFQU0sZ0JBQWdCO1FBQ1osZ0NBQWdDO1FBQ2hDLE1BQU1DLGtCQUFrQm5CLFNBQVNDLGFBQWEsQ0FBQztRQUMvQ2tCLGdCQUFnQkMsS0FBSyxHQUFHO1FBRXhCLE1BQU1DLFVBQVVyQixTQUFTQyxhQUFhLENBQUM7UUFDdkNvQixRQUFRbkIsSUFBSSxHQUFHO1FBQ2ZtQixRQUFRQyxXQUFXLEdBQUc7UUFDdEJELFFBQVFELEtBQUssR0FBRztRQUNoQix5Q0FBeUM7UUFFekNDLFFBQVFFLGdCQUFnQixDQUFDLFNBQVM7WUFDOUIsTUFBTUMsZUFBZSxJQUFJLENBQUNuQixLQUFLLENBQUNV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QUNaLHVEQUF1RDtJQUN2RCxpRUFBaUU7SUFDakUsUUFBUTtJQUNSLElBQUk7SUFFSixXQUFXNEIsV0FBVTtRQUNqQixPQUFPO0lBQ1g7SUFFQUMsUUFBUTtRQUNKLElBQUksSUFBSSxDQUFDM0MsS0FBSyxJQUFJLENBQUMsSUFBSSxDQUFDdUMsTUFBTSxFQUFFO1lBQzVCLElBQUksQ0FBQ3ZDLEtBQUssQ0FBQ3dDLGNBQWM7WUFDekIsSUFBSSxDQUFDeEMsS0FBSyxDQUFDWSxVQUFVLENBQUMsSUFBSSxDQUFDWCxhQUFhO1FBQzVDO0lBQ0o7SUE5TEEyQyxZQUFZLEVBQUNDLE1BQU0sRUFBRUMsR0FBRyxFQUFDLENBQUU7YUFTM0JmLG1CQUFtQixPQUFPZ0I7WUFDdEIsTUFBTWpCLFdBQVcsTUFBTWtCLE1BQU16RCxlQUFlO2dCQUN4QzBELFFBQVE7Z0JBQ1JDLFNBQVM7b0JBQ0wsZ0JBQWdCO2dCQUNwQjtnQkFDQUMsTUFBTUMsS0FBS0MsU0FBUyxDQUFDO29CQUFFQyxPQUFPUDtvQkFBTVEsVUFBVTtnQkFBQztZQUNuRDtZQUVBLE1BQU1DLE9BQU8sTUFBTTFCLFNBQVMyQixJQUFJO1lBQ2hDN0IsUUFBUUMsR0FBRyxDQUFDMkI7WUFDWixPQUFPQSxLQUFLMUIsUUFBUSxDQUFDNEIsT0FBTztRQUNoQztRQXBCSSxJQUFJLENBQUNaLEdBQUcsR0FBR0E7UUFDWCxJQUFJLENBQUNwRCxNQUFNLEdBQUc7UUFDZCxJQUFJLENBQUNPLGFBQWEsR0FBRztRQUNyQixJQUFJLENBQUNELEtBQUssR0FBRztRQUNiLElBQUksQ0FBQ29CLFdBQVcsR0FBRztRQUNuQixJQUFJLENBQUNtQixNQUFNLEdBQUc7SUFDbEI7QUF5TEo7QUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9pbmxpbmVBSS5qcz8zYjJkIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IExMTV9FTkRfUE9JTlQgPSBcImh0dHA6Ly9sb2NhbGhvc3Q6ODAwMC9xdWVyeVwiXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIGlubGluZUFJIHtcbiAgICBjb25zdHJ1Y3Rvcih7Y29uZmlnLCBhcGl9KSB7XG4gICAgICAgIHRoaXMuYXBpID0gYXBpO1xuICAgICAgICB0aGlzLmJ1dHRvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRfdGV4dCA9IG51bGw7IFxuICAgICAgICB0aGlzLnJhbmdlID0gbnVsbDsgXG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWQgPSBudWxsOyBcbiAgICAgICAgdGhpcy5hY2NlcHQgPSBmYWxzZTsgXG4gICAgfVxuXG4gICAgZ2VuZXJhdGVSZXNwb25zZSA9IGFzeW5jICh0ZXh0KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goTExNX0VORF9QT0lOVCwge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgcXVlcnk6IHRleHQsIHByaW9yaXR5OiAxfSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgY29uc29sZS5sb2coZGF0YSk7XG4gICAgICAgIHJldHVybiBkYXRhLnJlc3BvbnNlLmNvbnRlbnQ7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICB0aGlzLmJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICB0aGlzLmJ1dHRvbi50eXBlID0gJ2J1dHRvbic7XG4gICAgICAgIHRoaXMuYnV0dG9uLmlubmVySFRNTCA9IGBcbiAgICAgIDxzdmcgY2xhc3M9XCJpY29uXCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgd2lkdGg9XCIyNFwiPlxuICAgICAgPHN0eWxlPiBcbiAgICAgIC5pY29uOmhvdmVyIHsgYmFja2dyb3VuZDogI2VmZjJmNTt9XG4gICAgICA8L3N0eWxlPlxuICAgICAgICA8cGF0aCBjbGFzcz1cImZpbGxcIiBkPVwibTE5IDkgMS4yNS0yLjc1TDIzIDVsLTIuNzUtMS4yNUwxOSAxbC0xLjI1IDIuNzVMMTUgNWwyLjc1IDEuMjV6bS03LjUuNUw5IDQgNi41IDkuNSAxIDEybDUuNSAyLjVMOSAyMGwyLjUtNS41TDE3IDEyek0xOSAxNWwtMS4yNSAyLjc1TDE1IDE5bDIuNzUgMS4yNUwxOSAyM2wxLjI1LTIuNzVMMjMgMTlsLTIuNzUtMS4yNXpcIi8+XG4gICAgICA8L3N2Zz5cbiAgICBgO1xuICAgICAgICByZXR1cm4gdGhpcy5idXR0b247XG4gICAgfVxuXG4gICAgc3Vycm91bmQocmFuZ2Upe1xuXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRfdGV4dCA9IHJhbmdlLmNsb25lQ29udGVudHMoKTtcbiAgICAgICAgdGhpcy5yYW5nZSA9IHJhbmdlO1xuXG5cblxuICAgIH1cblxuICAgIGhpZ2hsaWdodFNlbGVjdGVkVGV4dChzZWxlY3Rpb24pIHtcbiAgICAgICAgLy8gY29uc3Qgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgICAgICBpZiAoc2VsZWN0aW9uLnJhbmdlQ291bnQgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCByYW5nZSA9IHNlbGVjdGlvbi5nZXRSYW5nZUF0KDApO1xuICAgICAgICAgICAgY29uc3QgbWFyayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ21hcmsnKTtcbiAgICAgICAgICAgIG1hcmsuY2xhc3NOYW1lID0gJ2NkeC1tYXJrZXInO1xuICAgICAgICAgICAgY29uc3QgY29udGVudHMgPSByYW5nZS5leHRyYWN0Q29udGVudHMoKTtcblxuICAgICAgICAgICAgbWFyay5hcHBlbmRDaGlsZChjb250ZW50cyk7XG5cbiAgICAgICAgICAgIHJhbmdlLmluc2VydE5vZGUobWFyayk7XG5cblxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVuZGVyQWN0aW9ucygpIHtcbiAgICAgICAgLy8gdGhpcy5oaWdobGlnaHRTZWxlY3RlZFRleHQoKTtcbiAgICAgICAgY29uc3QgYWN0aW9uQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGFjdGlvbkNvbnRhaW5lci5zdHlsZSA9IFwibWF4LXdpZHRoOiAxMDAlOyBvdmVyZmxvdy14OiBoaWRkZW47IGhlaWdodDogYXV0bzsgYmFja2dyb3VuZC1jb2xvcjogI2Y4ZjlmYTsgZGlzcGxheTogZmxleDsgZmxleC1kaXJlY3Rpb246IGNvbHVtbjsgYWxpZ24taXRlbXM6IGxlZnQ7IHBhZGRpbmc6IDEwcHggMTBweCAxMHB4IDEwcHg7IGJveC1zaXppbmc6IGJvcmRlci1ib3g7IFwiO1xuXG4gICAgICAgIGNvbnN0IHRleHRCb3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICB0ZXh0Qm94LnR5cGUgPSAndGV4dCc7XG4gICAgICAgIHRleHRCb3gucGxhY2Vob2xkZXIgPSAnUXVlcnkgaGVyZS4uLic7XG4gICAgICAgIHRleHRCb3guc3R5bGUgPSBcImZsZXgtZ3JvdzogMTsgbWFyZ2luLXJpZ2h0OiAxMHB4OyBoZWlnaHQ6IDQwcHg7IHBhZGRpbmc6IDAgMTBweDsgYm94LXNpemluZzogYm9yZGVyLWJveDsgcGFkZGluZzogMTBweCAxMHB4IDEwcHggMTBweDsgZGlzcGxheTogYmxvY2s7IGZvbnQtc2l6ZTogMTBweCAhaW1wb3J0YW50O1wiO1xuICAgICAgICAvLyBsZXQgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuXG4gICAgICAgIHRleHRCb3guYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZFRleHQgPSB0aGlzLnJhbmdlLmV4dHJhY3RDb250ZW50cygpO1xuXG4gICAgICAgICAgICAvLyBDcmVhdGUgTUFSSyBlbGVtZW50XG4gICAgICAgICAgICBjb25zdCBtYXJrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnTUFSSycpO1xuICAgIFxuICAgICAgICAgICAgLy8gQXBwZW5kIHRvIHRoZSBNQVJLIGVsZW1lbnQgc2VsZWN0ZWQgVGV4dE5vZGVcbiAgICAgICAgICAgIG1hcmsuYXBwZW5kQ2hpbGQoc2VsZWN0ZWRUZXh0KTtcbiAgICBcbiAgICAgICAgICAgIC8vIEluc2VydCBuZXcgZWxlbWVudFxuICAgICAgICAgICAgdGhpcy5yYW5nZS5pbnNlcnROb2RlKG1hcmspO1xuXG4gICAgICAgICAgICB0aGlzLmhpZ2hsaWdodGVkID0gbWFyaztcblxuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHN1Ym1pdEJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICBzdWJtaXRCdXR0b24uaW5uZXJIVE1MID0gJ1N1Ym1pdCc7XG4gICAgICAgIHN1Ym1pdEJ1dHRvbi5zdHlsZSA9IFwid2lkdGg6IDgwcHg7IGhlaWdodDogNDBweDsgYm9yZGVyLXJhZGl1czogMjBweDsgYmFja2dyb3VuZC1jb2xvcjogIzAwN2JmZjsgY29sb3I6IHdoaXRlOyBib3JkZXI6IG5vbmU7IGN1cnNvcjogcG9pbnRlcjsgYm94LXNpemluZzogYm9yZGVyLWJveDsgbWFyZ2luLXRvcDogMTBweDtcIjtcblxuICAgICAgICBjb25zdCBsb2FkaW5nU3Bpbm5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBsb2FkaW5nU3Bpbm5lci5zdHlsZSA9IFwiZGlzcGxheTogbm9uZTsgYm9yZGVyOiA0cHggc29saWQgI2YzZjNmMzsgYm9yZGVyLXRvcDogNHB4IHNvbGlkICMzNDk4ZGI7IGJvcmRlci1yYWRpdXM6IDUwJTsgd2lkdGg6IDMwcHg7IGhlaWdodDogMzBweDsgYW5pbWF0aW9uOiBzcGluIDJzIGxpbmVhciBpbmZpbml0ZTsgbWFyZ2luLXRvcDogMTBweDtcIjtcbiAgICAgICAgbG9hZGluZ1NwaW5uZXIuc2V0QXR0cmlidXRlKCdpZCcsICdsb2FkaW5nLXNwaW5uZXInKTtcblxuXG4gICAgICAgIGNvbnN0IHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgc3R5bGUudGV4dENvbnRlbnQgPSBgXG4gICAgICAgICAgICBAa2V5ZnJhbWVzIHNwaW4ge1xuICAgICAgICAgICAgICAgIDAlIHsgdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7IH1cbiAgICAgICAgICAgICAgICAxMDAlIHsgdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICBgO1xuXG4gICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXG4gICAgICAgIHN1Ym1pdEJ1dHRvbi5vbmNsaWNrID0gYXN5bmMgKCkgPT4ge1xuXG4gICAgICAgICAgICAvLyBtYWtlIHRoZSBkcm9wIGRvd24gd2luZG93IHRvIGJlIGEgc3Bpbm5pbmcgd2hlZWVsIFxuICAgICAgICAgICAgbG9hZGluZ1NwaW5uZXIuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgICBzdWJtaXRCdXR0b24uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMuc2VsZWN0ZWRfdGV4dC50ZXh0Q29udGVudCwgdHlwZW9mKHRoaXMuc2VsZWN0ZWRfdGV4dC50ZXh0Q29udGVudCkpO1xuICAgICAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5nZW5lcmF0ZVJlc3BvbnNlKHRleHRCb3gudmFsdWUgKyBcIjogXCIgKyB0aGlzLnNlbGVjdGVkX3RleHQudGV4dENvbnRlbnQpO1xuICAgICAgICAgICAgbG9hZGluZ1NwaW5uZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuICAgICAgICAgICAgdGV4dEJveC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZURldiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgcmVzcG9uc2VEZXYudGV4dENvbnRlbnQgPSByZXNwb25zZTtcbiAgICAgICAgICAgIHJlc3BvbnNlRGV2LnN0eWxlLm1hcmdpblRvcCA9ICcxMHB4JztcbiAgICAgICAgICAgIHJlc3BvbnNlRGV2LnN0eWxlLmZvbnRTaXplID0gJzEwcHgnO1xuICAgICAgICAgICAgYWN0aW9uQ29udGFpbmVyLmFwcGVuZENoaWxkKHJlc3BvbnNlRGV2KTtcblxuICAgICAgICAgICAgY29uc3QgYWNjZXB0QnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgICAgICBhY2NlcHRCdXR0b24uaW5uZXJIVE1MID0gJ0FjY2VwdCc7XG4gICAgICAgICAgICBhY2NlcHRCdXR0b24uc3R5bGUgPSBcIndpZHRoOiA4MHB4OyBoZWlnaHQ6IDQwcHg7IGJvcmRlci1yYWRpdXM6IDIwcHg7IGJhY2tncm91bmQtY29sb3I6ICMwMDdiZmY7IGNvbG9yOiB3aGl0ZTsgYm9yZGVyOiBub25lOyBjdXJzb3I6IHBvaW50ZXI7IGJveC1zaXppbmc6IGJvcmRlci1ib3g7IG1hcmdpbi10b3A6IDEwcHg7XCI7XG5cbiAgICAgICAgICAgIGNvbnN0IGRlY2xpbmVCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgICAgIGRlY2xpbmVCdXR0b24uaW5uZXJIVE1MID0gJ0RlY2xpbmUnO1xuICAgICAgICAgICAgZGVjbGluZUJ1dHRvbi5zdHlsZSA9IFwid2lkdGg6IDgwcHg7IGhlaWdodDogNDBweDsgYm9yZGVyLXJhZGl1czogMjBweDsgYmFja2dyb3VuZC1jb2xvcjogIzAwN2JmZjsgY29sb3I6IHdoaXRlOyBib3JkZXI6IG5vbmU7IGN1cnNvcjogcG9pbnRlcjsgYm94LXNpemluZzogYm9yZGVyLWJveDsgbWFyZ2luLXRvcDogMTBweDtcIjtcblxuICAgICAgICAgICAgLy8gY29uc3QgcmV0cnlCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgICAgIC8vIHJldHJ5QnV0dG9uLmlubmVySFRNTCA9IFwiUmV0cnlcIjtcbiAgICAgICAgICAgIC8vIHJldHJ5QnV0dG9uLnN0eWxlID0gXCJ3aWR0aDogODBweDsgaGVpZ2h0OiA0MHB4OyBib3JkZXItcmFkaXVzOiAyMHB4OyBiYWNrZ3JvdW5kLWNvbG9yOiAjMDA3YmZmOyBjb2xvcjogd2hpdGU7IGJvcmRlcjogbm9uZTsgY3Vyc29yOiBwb2ludGVyOyBib3gtc2l6aW5nOiBib3JkZXItYm94OyBtYXJnaW4tdG9wOiAxMHB4O1wiO1xuXG4gICAgICAgICAgICBhY3Rpb25Db250YWluZXIuYXBwZW5kQ2hpbGQoYWNjZXB0QnV0dG9uKTtcbiAgICAgICAgICAgIGFjdGlvbkNvbnRhaW5lci5hcHBlbmRDaGlsZChkZWNsaW5lQnV0dG9uKTtcbiAgICAgICAgICAgIC8vIGFjdGlvbkNvbnRhaW5lci5hcHBlbmRDaGlsZChyZXRyeUJ1dHRvbik7XG5cblxuICAgICAgICAgICAgZGVjbGluZUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBTaG93IHRoZSBpbnB1dCB0ZXh0IGJveCBhbmQgdGhlIHN1Ym1pdCBidXR0b25cbiAgICAgICAgICAgICAgICB0ZXh0Qm94LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgICAgIHN1Ym1pdEJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgcmVzcG9uc2UgYW5kIHRoZSBidXR0b25zXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VEZXYucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgYWNjZXB0QnV0dG9uLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIGRlY2xpbmVCdXR0b24ucmVtb3ZlKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYWNjZXB0QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFJlcGxhY2UgdGhlIHNlbGVjdGVkIHRleHQgXG4gICAgICAgICAgICAgICAgdGhpcy5hY2NlcHQgPSB0cnVlOyBcbiAgICAgICAgICAgICAgICB0aGlzLnJhbmdlLmRlbGV0ZUNvbnRlbnRzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yYW5nZS5pbnNlcnROb2RlKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHJlc3BvbnNlKSk7XG4gICAgICAgICAgICAgICAgLy8gdGhpcy5hcGkuaW5saW5lVG9vbGJhci5jbG9zZSgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfTtcblxuICAgICAgICBhY3Rpb25Db250YWluZXIuYXBwZW5kQ2hpbGQodGV4dEJveCk7XG4gICAgICAgIGFjdGlvbkNvbnRhaW5lci5hcHBlbmRDaGlsZChzdWJtaXRCdXR0b24pO1xuICAgICAgICBhY3Rpb25Db250YWluZXIuYXBwZW5kQ2hpbGQobG9hZGluZ1NwaW5uZXIpO1xuXG4gICAgICAgIHJldHVybiBhY3Rpb25Db250YWluZXI7XG4gICAgfVxuICAgIC8vIHJlbW92ZUhpZ2hsaWdodCgpIHtcbiAgICAvLyAgICAgaWYgKHRoaXMuaGlnaGxpZ2h0ZWRFbGVtZW50KSB7XG4gICAgLy8gICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmhpZ2hsaWdodGVkRWxlbWVudC5wYXJlbnROb2RlO1xuICAgIC8vICAgICAgICAgd2hpbGUgKHRoaXMuaGlnaGxpZ2h0ZWRFbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAvLyAgICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKHRoaXMuaGlnaGxpZ2h0ZWRFbGVtZW50LmZpcnN0Q2hpbGQsIHRoaXMuaGlnaGxpZ2h0ZWRFbGVtZW50KTtcbiAgICAvLyAgICAgICAgIH1cbiAgICAvLyAgICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZCh0aGlzLmhpZ2hsaWdodGVkRWxlbWVudCk7XG4gICAgLy8gICAgICAgICB0aGlzLmhpZ2hsaWdodGVkRWxlbWVudCA9IG51bGw7IC8vIENsZWFyIHRoZSByZWZlcmVuY2VcbiAgICAvLyAgICAgfVxuICAgIC8vIH1cblxuICAgIHN0YXRpYyBnZXQgaXNJbmxpbmUoKXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIGlmICh0aGlzLnJhbmdlICYmICF0aGlzLmFjY2VwdCkge1xuICAgICAgICAgICAgdGhpcy5yYW5nZS5kZWxldGVDb250ZW50cygpO1xuICAgICAgICAgICAgdGhpcy5yYW5nZS5pbnNlcnROb2RlKHRoaXMuc2VsZWN0ZWRfdGV4dCk7XG4gICAgICAgIH1cbiAgICB9XG5cbn0iXSwibmFtZXMiOlsiTExNX0VORF9QT0lOVCIsImlubGluZUFJIiwicmVuZGVyIiwiYnV0dG9uIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwidHlwZSIsImlubmVySFRNTCIsInN1cnJvdW5kIiwicmFuZ2UiLCJzZWxlY3RlZF90ZXh0IiwiY2xvbmVDb250ZW50cyIsImhpZ2hsaWdodFNlbGVjdGVkVGV4dCIsInNlbGVjdGlvbiIsInJhbmdlQ291bnQiLCJnZXRSYW5nZUF0IiwibWFyayIsImNsYXNzTmFtZSIsImNvbnRlbnRzIiwiZXh0cmFjdENvbnRlbnRzIiwiYXBwZW5kQ2hpbGQiLCJpbnNlcnROb2RlIiwicmVuZGVyQWN0aW9ucyIsImFjdGlvbkNvbnRhaW5lciIsInN0eWxlIiwidGV4dEJveCIsInBsYWNlaG9sZGVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsInNlbGVjdGVkVGV4dCIsImhpZ2hsaWdodGVkIiwic3VibWl0QnV0dG9uIiwibG9hZGluZ1NwaW5uZXIiLCJzZXRBdHRyaWJ1dGUiLCJ0ZXh0Q29udGVudCIsImhlYWQiLCJvbmNsaWNrIiwiZGlzcGxheSIsImNvbnNvbGUiLCJsb2ciLCJyZXNwb25zZSIsImdlbmVyYXRlUmVzcG9uc2UiLCJ2YWx1ZSIsInJlc3BvbnNlRGV2IiwibWFyZ2luVG9wIiwiZm9udFNpemUiLCJhY2NlcHRCdXR0b24iLCJkZWNsaW5lQnV0dG9uIiwicmVtb3ZlIiwiYWNjZXB0IiwiZGVsZXRlQ29udGVudHMiLCJjcmVhdGVUZXh0Tm9kZSIsImlzSW5saW5lIiwiY2xlYXIiLCJjb25zdHJ1Y3RvciIsImNvbmZpZyIsImFwaSIsInRleHQiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsInF1ZXJ5IiwicHJpb3JpdHkiLCJkYXRhIiwianNvbiIsImNvbnRlbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/inlineAI.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@alkhipce/editorjs-aitext/dist/aitext.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@alkhipce/editorjs-aitext/dist/aitext.mjs ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ u; }\n/* harmony export */ });\n(function() {\r\n  try {\r\n    if (typeof document < \"u\") {\r\n      var s = document.createElement(\"style\");\r\n      s.appendChild(document.createTextNode(\".ce-paragraph{line-height:1.6em;outline:none}.ce-paragraph[data-placeholder]:empty:before{content:attr(data-placeholder);color:#707684;font-weight:400;opacity:0}.codex-editor--empty .ce-block:first-child .ce-paragraph[data-placeholder]:empty:before{opacity:1}.codex-editor--toolbox-opened .ce-block:first-child .ce-paragraph[data-placeholder]:empty:before,.codex-editor--empty .ce-block:first-child .ce-paragraph[data-placeholder]:empty:focus:before{opacity:0}.ce-paragraph p:first-of-type{margin-top:0}.ce-paragraph p:last-of-type{margin-bottom:0}\")), document.head.appendChild(s);\r\n    }\r\n  } catch (e) {\r\n    console.error(\"vite-plugin-css-injected-by-js\", e);\r\n  }\r\n})();\r\nconst h = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M8 9V7.2C8 7.08954 8.08954 7 8.2 7L12 7M16 9V7.2C16 7.08954 15.9105 7 15.8 7L12 7M12 7L12 17M12 17H10M12 17H14\"/></svg>';\r\n/**\r\n * Base Paragraph Block for the Editor.js.\r\n * Represents a regular text block\r\n *\r\n * @author CodeX (team@codex.so)\r\n * @copyright CodeX 2018\r\n * @license The MIT License (MIT)\r\n */\r\nclass c {\r\n  /**\r\n   * Default placeholder for Paragraph Tool\r\n   *\r\n   * @returns {string}\r\n   * @class\r\n   */\r\n  static get DEFAULT_PLACEHOLDER() {\r\n    return \"\";\r\n  }\r\n  /**\r\n   * Render plugin`s main Element and fill it with saved data\r\n   *\r\n   * @param {object} params - constructor params\r\n   * @param {ParagraphData} params.data - previously saved data\r\n   * @param {ParagraphConfig} params.config - user config for Tool\r\n   * @param {object} params.api - editor.js api\r\n   * @param {boolean} readOnly - read only mode flag\r\n   */\r\n  constructor({ data: e, config: t, api: i, readOnly: a }) {\r\n    this.api = i, this.readOnly = a, this._CSS = {\r\n      block: this.api.styles.block,\r\n      wrapper: \"ce-paragraph\"\r\n    }, this.readOnly || (this.onKeyUp = this.onKeyUp.bind(this)), this._placeholder = t.placeholder ? t.placeholder : c.DEFAULT_PLACEHOLDER, this._data = {}, this._element = null, this._preserveBlank = t.preserveBlank !== void 0 ? t.preserveBlank : !1, this.data = e;\r\n  }\r\n  /**\r\n   * Check if text content is empty and set empty string to inner html.\r\n   * We need this because some browsers (e.g. Safari) insert <br> into empty contenteditanle elements\r\n   *\r\n   * @param {KeyboardEvent} e - key up event\r\n   */\r\n  onKeyUp(e) {\r\n    if (e.code !== \"Backspace\" && e.code !== \"Delete\")\r\n      return;\r\n    const { textContent: t } = this._element;\r\n    t === \"\" && (this._element.innerHTML = \"\");\r\n  }\r\n  /**\r\n   * Create Tool's view\r\n   *\r\n   * @returns {HTMLElement}\r\n   * @private\r\n   */\r\n  drawView() {\r\n    const e = document.createElement(\"DIV\");\r\n    return e.classList.add(this._CSS.wrapper, this._CSS.block), e.contentEditable = !1, e.dataset.placeholder = this.api.i18n.t(this._placeholder), this._data.text && (e.innerHTML = this._data.text), this.readOnly || (e.contentEditable = !0, e.addEventListener(\"keyup\", this.onKeyUp)), e;\r\n  }\r\n  /**\r\n   * Return Tool's view\r\n   *\r\n   * @returns {HTMLDivElement}\r\n   */\r\n  render() {\r\n    return this._element = this.drawView(), this._element;\r\n  }\r\n  /**\r\n   * Method that specified how to merge two Text blocks.\r\n   * Called by Editor.js by backspace at the beginning of the Block\r\n   *\r\n   * @param {ParagraphData} data\r\n   * @public\r\n   */\r\n  merge(e) {\r\n    const t = {\r\n      text: this.data.text + e.text\r\n    };\r\n    this.data = t;\r\n  }\r\n  /**\r\n   * Validate Paragraph block data:\r\n   * - check for emptiness\r\n   *\r\n   * @param {ParagraphData} savedData  data received after saving\r\n   * @returns {boolean} false if saved data is not correct, otherwise true\r\n   * @public\r\n   */\r\n  validate(e) {\r\n    return !(e.text.trim() === \"\" && !this._preserveBlank);\r\n  }\r\n  /**\r\n   * Extract Tool's data from the view\r\n   *\r\n   * @param {HTMLDivElement} toolsContent - Paragraph tools rendered view\r\n   * @returns {ParagraphData} - saved data\r\n   * @public\r\n   */\r\n  save(e) {\r\n    return {\r\n      text: e.innerHTML\r\n    };\r\n  }\r\n  /**\r\n   * On paste callback fired from Editor.\r\n   *\r\n   * @param {PasteEvent} event - event with pasted data\r\n   */\r\n  onPaste(e) {\r\n    const t = {\r\n      text: e.detail.data.innerHTML\r\n    };\r\n    this.data = t;\r\n  }\r\n  /**\r\n   * Enable Conversion Toolbar. Paragraph can be converted to/from other tools\r\n   */\r\n  static get conversionConfig() {\r\n    return {\r\n      export: \"text\",\r\n      // to convert Paragraph to other block, use 'text' property of saved data\r\n      import: \"text\"\r\n      // to covert other block's exported string to Paragraph, fill 'text' property of tool data\r\n    };\r\n  }\r\n  /**\r\n   * Sanitizer rules\r\n   */\r\n  static get sanitize() {\r\n    return {\r\n      text: {\r\n        br: !0\r\n      }\r\n    };\r\n  }\r\n  /**\r\n   * Returns true to notify the core that read-only mode is supported\r\n   *\r\n   * @returns {boolean}\r\n   */\r\n  static get isReadOnlySupported() {\r\n    return !0;\r\n  }\r\n  /**\r\n   * Get current Tools`s data\r\n   *\r\n   * @returns {ParagraphData} Current data\r\n   * @private\r\n   */\r\n  get data() {\r\n    if (this._element !== null) {\r\n      const e = this._element.innerHTML;\r\n      this._data.text = e;\r\n    }\r\n    return this._data;\r\n  }\r\n  /**\r\n   * Store data in plugin:\r\n   * - at the this._data property\r\n   * - at the HTML\r\n   *\r\n   * @param {ParagraphData} data  data to set\r\n   * @private\r\n   */\r\n  set data(e) {\r\n    this._data = e || {}, this._element !== null && this.hydrate();\r\n  }\r\n  /**\r\n   * Fill tool's view with data\r\n   */\r\n  hydrate() {\r\n    window.requestAnimationFrame(() => {\r\n      this._element.innerHTML = this._data.text || \"\";\r\n    });\r\n  }\r\n  /**\r\n   * Used by Editor paste handling API.\r\n   * Provides configuration to handle P tags.\r\n   *\r\n   * @returns {{tags: string[]}}\r\n   */\r\n  static get pasteConfig() {\r\n    return {\r\n      tags: [\"P\"]\r\n    };\r\n  }\r\n  /**\r\n   * Icon and title for displaying at the Toolbox\r\n   *\r\n   * @returns {{icon: string, title: string}}\r\n   */\r\n  static get toolbox() {\r\n    return {\r\n      icon: h,\r\n      title: \"Text\"\r\n    };\r\n  }\r\n}\r\nfunction p(s, e = 2e3) {\r\n  let t;\r\n  return (...i) => {\r\n    clearTimeout(t), t = setTimeout(() => {\r\n      s.apply(null, i);\r\n    }, e);\r\n  };\r\n}\r\nclass u extends c {\r\n  constructor({ api: e, block: t, config: i, data: a }) {\r\n    if (super({\r\n      api: e,\r\n      block: t,\r\n      config: i,\r\n      data: a\r\n    }), this.readOnly = !1, this.onInput = p((n) => {\r\n      var r;\r\n      console.log(n.target.innerHTML), !((r = this._element) != null && r.querySelector(\"#ai-suggestions\") || n.inputType === \"deleteContentBackward\" || n.inputType === \"deleteContentForward\" || n.inputType === \"insertParagraph\" || n.inputType === \"insertFromPaste\" || n.inputType === \"insertFromDrop\" || !n.target.innerHTML) && this.getAICompletion(n.target.innerHTML);\r\n    }), !i.callback)\r\n      throw new Error(\"Callback function is required!\");\r\n    this.callback = i.callback;\r\n  }\r\n  static get toolbox() {\r\n    return {\r\n      title: \"AI TEXT\",\r\n      icon: `<svg width=\"800px\" height=\"800px\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\r\n      <path d=\"M8 4V20M17 12V20M6 20H10M15 20H19M13 7V4H3V7M21 14V12H13V14\" stroke=\"#000000\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\r\n      </svg>`\r\n    };\r\n  }\r\n  getAICompletion(e) {\r\n    var i, a;\r\n    if (!e)\r\n      return;\r\n    const t = document.createElement(\"div\");\r\n    t.innerHTML = `<svg width=\"800px\" height=\"800px\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\r\n    <path d=\"M12 2.99988V5.99988M12 20.9999V17.9999M4.20577 16.4999L6.80385 14.9999M21 11.9999H18M16.5 19.7941L15 17.196M3 11.9999H6M7.5 4.20565L9 6.80373M7.5 19.7941L9 17.196M19.7942 16.4999L17.1962 14.9999M4.20577 7.49988L6.80385 8.99988\" stroke=\"#000000\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\r\n    </svg>`, t.id = \"ai-suggestions-loader\", t.style.display = \"inline-flex\", t.style.alignItems = \"center\", t.style.width = \"24px\", t.style.height = \"24px\", t.style.paddingLeft = \"4px\", t.style.color = \"lightgray\", t.style.position = \"absolute\", t.animate(\r\n      [\r\n        {\r\n          transform: \"rotate(0deg)\"\r\n        },\r\n        {\r\n          transform: \"rotate(360deg)\"\r\n        }\r\n      ],\r\n      {\r\n        duration: 2e3,\r\n        iterations: 1 / 0\r\n      }\r\n    ), (i = this._element) == null || i.appendChild(t), (a = this.callback) == null || a.call(this, e).then((n) => {\r\n      var o, l, d;\r\n      console.log(n);\r\n      const r = document.createElement(\"span\");\r\n      r.innerHTML = \"\", r.id = \"ai-suggestions\", r.style.color = \"lightgray\", r.innerHTML = n, (o = this._element) == null || o.appendChild(r), (d = (l = this._element) == null ? void 0 : l.querySelector(\"#ai-suggestions-loader\")) == null || d.remove();\r\n    }).catch((n) => {\r\n      throw new Error(n);\r\n    });\r\n  }\r\n  onKeyUp(e) {\r\n    var i, a, n, r;\r\n    if (e.code === \"Escape\" || e.code === \"Backspace\") {\r\n      (a = (i = this._element) == null ? void 0 : i.querySelector(\"#ai-suggestions\")) == null || a.remove();\r\n      return;\r\n    }\r\n    if (e.code === \"AltLeft\" || e.code === \"AltRight\") {\r\n      const o = (n = this._element) == null ? void 0 : n.querySelector(\"#ai-suggestions\"), l = o == null ? void 0 : o.textContent;\r\n      if (!l)\r\n        return;\r\n      const d = document.createTextNode(\r\n        l\r\n      );\r\n      (r = this._element) == null || r.appendChild(d), o.remove();\r\n      return;\r\n    }\r\n    if (e.code !== \"Backspace\" && e.code !== \"Delete\" || !this._element)\r\n      return;\r\n    const { textContent: t } = this._element;\r\n    t === \"\" && (this._element.innerHTML = \"\");\r\n  }\r\n  drawView() {\r\n    const e = document.createElement(\"DIV\");\r\n    return e.classList.add(this._CSS.wrapper, this._CSS.block), e.contentEditable = \"false\", e.dataset.placeholder = this.api.i18n.t(this._placeholder), this._data.text && (e.innerHTML = this._data.text), this.readOnly || (e.contentEditable = \"true\", e.addEventListener(\"keyup\", this.onKeyUp), e.addEventListener(\"input\", this.onInput)), e;\r\n  }\r\n  _placeholder(e) {\r\n    throw new Error(\"Method not implemented.\");\r\n  }\r\n}\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYWxraGlwY2UvZWRpdG9yanMtYWl0ZXh0L2Rpc3QvYWl0ZXh0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsa0JBQWtCLGFBQWEsNkNBQTZDLCtCQUErQixjQUFjLGdCQUFnQixVQUFVLHdGQUF3RixVQUFVLCtMQUErTCxVQUFVLDhCQUE4QixhQUFhLDZCQUE2QixnQkFBZ0I7QUFDamxCO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLGVBQWU7QUFDNUIsYUFBYSxpQkFBaUI7QUFDOUIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBLGdCQUFnQix5Q0FBeUM7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsS0FBSyx1SkFBdUo7QUFDNUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0IsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzQ0FBc0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGFsa2hpcGNlL2VkaXRvcmpzLWFpdGV4dC9kaXN0L2FpdGV4dC5tanM/NGNiOCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKSB7XHJcbiAgdHJ5IHtcclxuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPCBcInVcIikge1xyXG4gICAgICB2YXIgcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcclxuICAgICAgcy5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIi5jZS1wYXJhZ3JhcGh7bGluZS1oZWlnaHQ6MS42ZW07b3V0bGluZTpub25lfS5jZS1wYXJhZ3JhcGhbZGF0YS1wbGFjZWhvbGRlcl06ZW1wdHk6YmVmb3Jle2NvbnRlbnQ6YXR0cihkYXRhLXBsYWNlaG9sZGVyKTtjb2xvcjojNzA3Njg0O2ZvbnQtd2VpZ2h0OjQwMDtvcGFjaXR5OjB9LmNvZGV4LWVkaXRvci0tZW1wdHkgLmNlLWJsb2NrOmZpcnN0LWNoaWxkIC5jZS1wYXJhZ3JhcGhbZGF0YS1wbGFjZWhvbGRlcl06ZW1wdHk6YmVmb3Jle29wYWNpdHk6MX0uY29kZXgtZWRpdG9yLS10b29sYm94LW9wZW5lZCAuY2UtYmxvY2s6Zmlyc3QtY2hpbGQgLmNlLXBhcmFncmFwaFtkYXRhLXBsYWNlaG9sZGVyXTplbXB0eTpiZWZvcmUsLmNvZGV4LWVkaXRvci0tZW1wdHkgLmNlLWJsb2NrOmZpcnN0LWNoaWxkIC5jZS1wYXJhZ3JhcGhbZGF0YS1wbGFjZWhvbGRlcl06ZW1wdHk6Zm9jdXM6YmVmb3Jle29wYWNpdHk6MH0uY2UtcGFyYWdyYXBoIHA6Zmlyc3Qtb2YtdHlwZXttYXJnaW4tdG9wOjB9LmNlLXBhcmFncmFwaCBwOmxhc3Qtb2YtdHlwZXttYXJnaW4tYm90dG9tOjB9XCIpKSwgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzKTtcclxuICAgIH1cclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwidml0ZS1wbHVnaW4tY3NzLWluamVjdGVkLWJ5LWpzXCIsIGUpO1xyXG4gIH1cclxufSkoKTtcclxuY29uc3QgaCA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNOCA5VjcuMkM4IDcuMDg5NTQgOC4wODk1NCA3IDguMiA3TDEyIDdNMTYgOVY3LjJDMTYgNy4wODk1NCAxNS45MTA1IDcgMTUuOCA3TDEyIDdNMTIgN0wxMiAxN00xMiAxN0gxME0xMiAxN0gxNFwiLz48L3N2Zz4nO1xyXG4vKipcclxuICogQmFzZSBQYXJhZ3JhcGggQmxvY2sgZm9yIHRoZSBFZGl0b3IuanMuXHJcbiAqIFJlcHJlc2VudHMgYSByZWd1bGFyIHRleHQgYmxvY2tcclxuICpcclxuICogQGF1dGhvciBDb2RlWCAodGVhbUBjb2RleC5zbylcclxuICogQGNvcHlyaWdodCBDb2RlWCAyMDE4XHJcbiAqIEBsaWNlbnNlIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxyXG4gKi9cclxuY2xhc3MgYyB7XHJcbiAgLyoqXHJcbiAgICogRGVmYXVsdCBwbGFjZWhvbGRlciBmb3IgUGFyYWdyYXBoIFRvb2xcclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICogQGNsYXNzXHJcbiAgICovXHJcbiAgc3RhdGljIGdldCBERUZBVUxUX1BMQUNFSE9MREVSKCkge1xyXG4gICAgcmV0dXJuIFwiXCI7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFJlbmRlciBwbHVnaW5gcyBtYWluIEVsZW1lbnQgYW5kIGZpbGwgaXQgd2l0aCBzYXZlZCBkYXRhXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gY29uc3RydWN0b3IgcGFyYW1zXHJcbiAgICogQHBhcmFtIHtQYXJhZ3JhcGhEYXRhfSBwYXJhbXMuZGF0YSAtIHByZXZpb3VzbHkgc2F2ZWQgZGF0YVxyXG4gICAqIEBwYXJhbSB7UGFyYWdyYXBoQ29uZmlnfSBwYXJhbXMuY29uZmlnIC0gdXNlciBjb25maWcgZm9yIFRvb2xcclxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zLmFwaSAtIGVkaXRvci5qcyBhcGlcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlYWRPbmx5IC0gcmVhZCBvbmx5IG1vZGUgZmxhZ1xyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKHsgZGF0YTogZSwgY29uZmlnOiB0LCBhcGk6IGksIHJlYWRPbmx5OiBhIH0pIHtcclxuICAgIHRoaXMuYXBpID0gaSwgdGhpcy5yZWFkT25seSA9IGEsIHRoaXMuX0NTUyA9IHtcclxuICAgICAgYmxvY2s6IHRoaXMuYXBpLnN0eWxlcy5ibG9jayxcclxuICAgICAgd3JhcHBlcjogXCJjZS1wYXJhZ3JhcGhcIlxyXG4gICAgfSwgdGhpcy5yZWFkT25seSB8fCAodGhpcy5vbktleVVwID0gdGhpcy5vbktleVVwLmJpbmQodGhpcykpLCB0aGlzLl9wbGFjZWhvbGRlciA9IHQucGxhY2Vob2xkZXIgPyB0LnBsYWNlaG9sZGVyIDogYy5ERUZBVUxUX1BMQUNFSE9MREVSLCB0aGlzLl9kYXRhID0ge30sIHRoaXMuX2VsZW1lbnQgPSBudWxsLCB0aGlzLl9wcmVzZXJ2ZUJsYW5rID0gdC5wcmVzZXJ2ZUJsYW5rICE9PSB2b2lkIDAgPyB0LnByZXNlcnZlQmxhbmsgOiAhMSwgdGhpcy5kYXRhID0gZTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgdGV4dCBjb250ZW50IGlzIGVtcHR5IGFuZCBzZXQgZW1wdHkgc3RyaW5nIHRvIGlubmVyIGh0bWwuXHJcbiAgICogV2UgbmVlZCB0aGlzIGJlY2F1c2Ugc29tZSBicm93c2VycyAoZS5nLiBTYWZhcmkpIGluc2VydCA8YnI+IGludG8gZW1wdHkgY29udGVudGVkaXRhbmxlIGVsZW1lbnRzXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGUgLSBrZXkgdXAgZXZlbnRcclxuICAgKi9cclxuICBvbktleVVwKGUpIHtcclxuICAgIGlmIChlLmNvZGUgIT09IFwiQmFja3NwYWNlXCIgJiYgZS5jb2RlICE9PSBcIkRlbGV0ZVwiKVxyXG4gICAgICByZXR1cm47XHJcbiAgICBjb25zdCB7IHRleHRDb250ZW50OiB0IH0gPSB0aGlzLl9lbGVtZW50O1xyXG4gICAgdCA9PT0gXCJcIiAmJiAodGhpcy5fZWxlbWVudC5pbm5lckhUTUwgPSBcIlwiKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIFRvb2wncyB2aWV3XHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBkcmF3VmlldygpIHtcclxuICAgIGNvbnN0IGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiRElWXCIpO1xyXG4gICAgcmV0dXJuIGUuY2xhc3NMaXN0LmFkZCh0aGlzLl9DU1Mud3JhcHBlciwgdGhpcy5fQ1NTLmJsb2NrKSwgZS5jb250ZW50RWRpdGFibGUgPSAhMSwgZS5kYXRhc2V0LnBsYWNlaG9sZGVyID0gdGhpcy5hcGkuaTE4bi50KHRoaXMuX3BsYWNlaG9sZGVyKSwgdGhpcy5fZGF0YS50ZXh0ICYmIChlLmlubmVySFRNTCA9IHRoaXMuX2RhdGEudGV4dCksIHRoaXMucmVhZE9ubHkgfHwgKGUuY29udGVudEVkaXRhYmxlID0gITAsIGUuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIHRoaXMub25LZXlVcCkpLCBlO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBSZXR1cm4gVG9vbCdzIHZpZXdcclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtIVE1MRGl2RWxlbWVudH1cclxuICAgKi9cclxuICByZW5kZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZWxlbWVudCA9IHRoaXMuZHJhd1ZpZXcoKSwgdGhpcy5fZWxlbWVudDtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogTWV0aG9kIHRoYXQgc3BlY2lmaWVkIGhvdyB0byBtZXJnZSB0d28gVGV4dCBibG9ja3MuXHJcbiAgICogQ2FsbGVkIGJ5IEVkaXRvci5qcyBieSBiYWNrc3BhY2UgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgQmxvY2tcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UGFyYWdyYXBoRGF0YX0gZGF0YVxyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICBtZXJnZShlKSB7XHJcbiAgICBjb25zdCB0ID0ge1xyXG4gICAgICB0ZXh0OiB0aGlzLmRhdGEudGV4dCArIGUudGV4dFxyXG4gICAgfTtcclxuICAgIHRoaXMuZGF0YSA9IHQ7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFZhbGlkYXRlIFBhcmFncmFwaCBibG9jayBkYXRhOlxyXG4gICAqIC0gY2hlY2sgZm9yIGVtcHRpbmVzc1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHtQYXJhZ3JhcGhEYXRhfSBzYXZlZERhdGEg4oCUIGRhdGEgcmVjZWl2ZWQgYWZ0ZXIgc2F2aW5nXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59IGZhbHNlIGlmIHNhdmVkIGRhdGEgaXMgbm90IGNvcnJlY3QsIG90aGVyd2lzZSB0cnVlXHJcbiAgICogQHB1YmxpY1xyXG4gICAqL1xyXG4gIHZhbGlkYXRlKGUpIHtcclxuICAgIHJldHVybiAhKGUudGV4dC50cmltKCkgPT09IFwiXCIgJiYgIXRoaXMuX3ByZXNlcnZlQmxhbmspO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBFeHRyYWN0IFRvb2wncyBkYXRhIGZyb20gdGhlIHZpZXdcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7SFRNTERpdkVsZW1lbnR9IHRvb2xzQ29udGVudCAtIFBhcmFncmFwaCB0b29scyByZW5kZXJlZCB2aWV3XHJcbiAgICogQHJldHVybnMge1BhcmFncmFwaERhdGF9IC0gc2F2ZWQgZGF0YVxyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICBzYXZlKGUpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHRleHQ6IGUuaW5uZXJIVE1MXHJcbiAgICB9O1xyXG4gIH1cclxuICAvKipcclxuICAgKiBPbiBwYXN0ZSBjYWxsYmFjayBmaXJlZCBmcm9tIEVkaXRvci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UGFzdGVFdmVudH0gZXZlbnQgLSBldmVudCB3aXRoIHBhc3RlZCBkYXRhXHJcbiAgICovXHJcbiAgb25QYXN0ZShlKSB7XHJcbiAgICBjb25zdCB0ID0ge1xyXG4gICAgICB0ZXh0OiBlLmRldGFpbC5kYXRhLmlubmVySFRNTFxyXG4gICAgfTtcclxuICAgIHRoaXMuZGF0YSA9IHQ7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEVuYWJsZSBDb252ZXJzaW9uIFRvb2xiYXIuIFBhcmFncmFwaCBjYW4gYmUgY29udmVydGVkIHRvL2Zyb20gb3RoZXIgdG9vbHNcclxuICAgKi9cclxuICBzdGF0aWMgZ2V0IGNvbnZlcnNpb25Db25maWcoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBleHBvcnQ6IFwidGV4dFwiLFxyXG4gICAgICAvLyB0byBjb252ZXJ0IFBhcmFncmFwaCB0byBvdGhlciBibG9jaywgdXNlICd0ZXh0JyBwcm9wZXJ0eSBvZiBzYXZlZCBkYXRhXHJcbiAgICAgIGltcG9ydDogXCJ0ZXh0XCJcclxuICAgICAgLy8gdG8gY292ZXJ0IG90aGVyIGJsb2NrJ3MgZXhwb3J0ZWQgc3RyaW5nIHRvIFBhcmFncmFwaCwgZmlsbCAndGV4dCcgcHJvcGVydHkgb2YgdG9vbCBkYXRhXHJcbiAgICB9O1xyXG4gIH1cclxuICAvKipcclxuICAgKiBTYW5pdGl6ZXIgcnVsZXNcclxuICAgKi9cclxuICBzdGF0aWMgZ2V0IHNhbml0aXplKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdGV4dDoge1xyXG4gICAgICAgIGJyOiAhMFxyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRydWUgdG8gbm90aWZ5IHRoZSBjb3JlIHRoYXQgcmVhZC1vbmx5IG1vZGUgaXMgc3VwcG9ydGVkXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgKi9cclxuICBzdGF0aWMgZ2V0IGlzUmVhZE9ubHlTdXBwb3J0ZWQoKSB7XHJcbiAgICByZXR1cm4gITA7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEdldCBjdXJyZW50IFRvb2xzYHMgZGF0YVxyXG4gICAqXHJcbiAgICogQHJldHVybnMge1BhcmFncmFwaERhdGF9IEN1cnJlbnQgZGF0YVxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgZ2V0IGRhdGEoKSB7XHJcbiAgICBpZiAodGhpcy5fZWxlbWVudCAhPT0gbnVsbCkge1xyXG4gICAgICBjb25zdCBlID0gdGhpcy5fZWxlbWVudC5pbm5lckhUTUw7XHJcbiAgICAgIHRoaXMuX2RhdGEudGV4dCA9IGU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5fZGF0YTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogU3RvcmUgZGF0YSBpbiBwbHVnaW46XHJcbiAgICogLSBhdCB0aGUgdGhpcy5fZGF0YSBwcm9wZXJ0eVxyXG4gICAqIC0gYXQgdGhlIEhUTUxcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UGFyYWdyYXBoRGF0YX0gZGF0YSDigJQgZGF0YSB0byBzZXRcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIHNldCBkYXRhKGUpIHtcclxuICAgIHRoaXMuX2RhdGEgPSBlIHx8IHt9LCB0aGlzLl9lbGVtZW50ICE9PSBudWxsICYmIHRoaXMuaHlkcmF0ZSgpO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBGaWxsIHRvb2wncyB2aWV3IHdpdGggZGF0YVxyXG4gICAqL1xyXG4gIGh5ZHJhdGUoKSB7XHJcbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgdGhpcy5fZWxlbWVudC5pbm5lckhUTUwgPSB0aGlzLl9kYXRhLnRleHQgfHwgXCJcIjtcclxuICAgIH0pO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBVc2VkIGJ5IEVkaXRvciBwYXN0ZSBoYW5kbGluZyBBUEkuXHJcbiAgICogUHJvdmlkZXMgY29uZmlndXJhdGlvbiB0byBoYW5kbGUgUCB0YWdzLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge3t0YWdzOiBzdHJpbmdbXX19XHJcbiAgICovXHJcbiAgc3RhdGljIGdldCBwYXN0ZUNvbmZpZygpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHRhZ3M6IFtcIlBcIl1cclxuICAgIH07XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEljb24gYW5kIHRpdGxlIGZvciBkaXNwbGF5aW5nIGF0IHRoZSBUb29sYm94XHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7e2ljb246IHN0cmluZywgdGl0bGU6IHN0cmluZ319XHJcbiAgICovXHJcbiAgc3RhdGljIGdldCB0b29sYm94KCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgaWNvbjogaCxcclxuICAgICAgdGl0bGU6IFwiVGV4dFwiXHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBwKHMsIGUgPSAyZTMpIHtcclxuICBsZXQgdDtcclxuICByZXR1cm4gKC4uLmkpID0+IHtcclxuICAgIGNsZWFyVGltZW91dCh0KSwgdCA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICBzLmFwcGx5KG51bGwsIGkpO1xyXG4gICAgfSwgZSk7XHJcbiAgfTtcclxufVxyXG5jbGFzcyB1IGV4dGVuZHMgYyB7XHJcbiAgY29uc3RydWN0b3IoeyBhcGk6IGUsIGJsb2NrOiB0LCBjb25maWc6IGksIGRhdGE6IGEgfSkge1xyXG4gICAgaWYgKHN1cGVyKHtcclxuICAgICAgYXBpOiBlLFxyXG4gICAgICBibG9jazogdCxcclxuICAgICAgY29uZmlnOiBpLFxyXG4gICAgICBkYXRhOiBhXHJcbiAgICB9KSwgdGhpcy5yZWFkT25seSA9ICExLCB0aGlzLm9uSW5wdXQgPSBwKChuKSA9PiB7XHJcbiAgICAgIHZhciByO1xyXG4gICAgICBjb25zb2xlLmxvZyhuLnRhcmdldC5pbm5lckhUTUwpLCAhKChyID0gdGhpcy5fZWxlbWVudCkgIT0gbnVsbCAmJiByLnF1ZXJ5U2VsZWN0b3IoXCIjYWktc3VnZ2VzdGlvbnNcIikgfHwgbi5pbnB1dFR5cGUgPT09IFwiZGVsZXRlQ29udGVudEJhY2t3YXJkXCIgfHwgbi5pbnB1dFR5cGUgPT09IFwiZGVsZXRlQ29udGVudEZvcndhcmRcIiB8fCBuLmlucHV0VHlwZSA9PT0gXCJpbnNlcnRQYXJhZ3JhcGhcIiB8fCBuLmlucHV0VHlwZSA9PT0gXCJpbnNlcnRGcm9tUGFzdGVcIiB8fCBuLmlucHV0VHlwZSA9PT0gXCJpbnNlcnRGcm9tRHJvcFwiIHx8ICFuLnRhcmdldC5pbm5lckhUTUwpICYmIHRoaXMuZ2V0QUlDb21wbGV0aW9uKG4udGFyZ2V0LmlubmVySFRNTCk7XHJcbiAgICB9KSwgIWkuY2FsbGJhY2spXHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbGxiYWNrIGZ1bmN0aW9uIGlzIHJlcXVpcmVkIVwiKTtcclxuICAgIHRoaXMuY2FsbGJhY2sgPSBpLmNhbGxiYWNrO1xyXG4gIH1cclxuICBzdGF0aWMgZ2V0IHRvb2xib3goKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0aXRsZTogXCJBSSBURVhUXCIsXHJcbiAgICAgIGljb246IGA8c3ZnIHdpZHRoPVwiODAwcHhcIiBoZWlnaHQ9XCI4MDBweFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBmaWxsPVwibm9uZVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj5cclxuICAgICAgPHBhdGggZD1cIk04IDRWMjBNMTcgMTJWMjBNNiAyMEgxME0xNSAyMEgxOU0xMyA3VjRIM1Y3TTIxIDE0VjEySDEzVjE0XCIgc3Ryb2tlPVwiIzAwMDAwMFwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIi8+XHJcbiAgICAgIDwvc3ZnPmBcclxuICAgIH07XHJcbiAgfVxyXG4gIGdldEFJQ29tcGxldGlvbihlKSB7XHJcbiAgICB2YXIgaSwgYTtcclxuICAgIGlmICghZSlcclxuICAgICAgcmV0dXJuO1xyXG4gICAgY29uc3QgdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICB0LmlubmVySFRNTCA9IGA8c3ZnIHdpZHRoPVwiODAwcHhcIiBoZWlnaHQ9XCI4MDBweFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBmaWxsPVwibm9uZVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj5cclxuICAgIDxwYXRoIGQ9XCJNMTIgMi45OTk4OFY1Ljk5OTg4TTEyIDIwLjk5OTlWMTcuOTk5OU00LjIwNTc3IDE2LjQ5OTlMNi44MDM4NSAxNC45OTk5TTIxIDExLjk5OTlIMThNMTYuNSAxOS43OTQxTDE1IDE3LjE5Nk0zIDExLjk5OTlINk03LjUgNC4yMDU2NUw5IDYuODAzNzNNNy41IDE5Ljc5NDFMOSAxNy4xOTZNMTkuNzk0MiAxNi40OTk5TDE3LjE5NjIgMTQuOTk5OU00LjIwNTc3IDcuNDk5ODhMNi44MDM4NSA4Ljk5OTg4XCIgc3Ryb2tlPVwiIzAwMDAwMFwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIi8+XHJcbiAgICA8L3N2Zz5gLCB0LmlkID0gXCJhaS1zdWdnZXN0aW9ucy1sb2FkZXJcIiwgdC5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtZmxleFwiLCB0LnN0eWxlLmFsaWduSXRlbXMgPSBcImNlbnRlclwiLCB0LnN0eWxlLndpZHRoID0gXCIyNHB4XCIsIHQuc3R5bGUuaGVpZ2h0ID0gXCIyNHB4XCIsIHQuc3R5bGUucGFkZGluZ0xlZnQgPSBcIjRweFwiLCB0LnN0eWxlLmNvbG9yID0gXCJsaWdodGdyYXlcIiwgdC5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIiwgdC5hbmltYXRlKFxyXG4gICAgICBbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgdHJhbnNmb3JtOiBcInJvdGF0ZSgwZGVnKVwiXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICB0cmFuc2Zvcm06IFwicm90YXRlKDM2MGRlZylcIlxyXG4gICAgICAgIH1cclxuICAgICAgXSxcclxuICAgICAge1xyXG4gICAgICAgIGR1cmF0aW9uOiAyZTMsXHJcbiAgICAgICAgaXRlcmF0aW9uczogMSAvIDBcclxuICAgICAgfVxyXG4gICAgKSwgKGkgPSB0aGlzLl9lbGVtZW50KSA9PSBudWxsIHx8IGkuYXBwZW5kQ2hpbGQodCksIChhID0gdGhpcy5jYWxsYmFjaykgPT0gbnVsbCB8fCBhLmNhbGwodGhpcywgZSkudGhlbigobikgPT4ge1xyXG4gICAgICB2YXIgbywgbCwgZDtcclxuICAgICAgY29uc29sZS5sb2cobik7XHJcbiAgICAgIGNvbnN0IHIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcclxuICAgICAgci5pbm5lckhUTUwgPSBcIlwiLCByLmlkID0gXCJhaS1zdWdnZXN0aW9uc1wiLCByLnN0eWxlLmNvbG9yID0gXCJsaWdodGdyYXlcIiwgci5pbm5lckhUTUwgPSBuLCAobyA9IHRoaXMuX2VsZW1lbnQpID09IG51bGwgfHwgby5hcHBlbmRDaGlsZChyKSwgKGQgPSAobCA9IHRoaXMuX2VsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBsLnF1ZXJ5U2VsZWN0b3IoXCIjYWktc3VnZ2VzdGlvbnMtbG9hZGVyXCIpKSA9PSBudWxsIHx8IGQucmVtb3ZlKCk7XHJcbiAgICB9KS5jYXRjaCgobikgPT4ge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3Iobik7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgb25LZXlVcChlKSB7XHJcbiAgICB2YXIgaSwgYSwgbiwgcjtcclxuICAgIGlmIChlLmNvZGUgPT09IFwiRXNjYXBlXCIgfHwgZS5jb2RlID09PSBcIkJhY2tzcGFjZVwiKSB7XHJcbiAgICAgIChhID0gKGkgPSB0aGlzLl9lbGVtZW50KSA9PSBudWxsID8gdm9pZCAwIDogaS5xdWVyeVNlbGVjdG9yKFwiI2FpLXN1Z2dlc3Rpb25zXCIpKSA9PSBudWxsIHx8IGEucmVtb3ZlKCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChlLmNvZGUgPT09IFwiQWx0TGVmdFwiIHx8IGUuY29kZSA9PT0gXCJBbHRSaWdodFwiKSB7XHJcbiAgICAgIGNvbnN0IG8gPSAobiA9IHRoaXMuX2VsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBuLnF1ZXJ5U2VsZWN0b3IoXCIjYWktc3VnZ2VzdGlvbnNcIiksIGwgPSBvID09IG51bGwgPyB2b2lkIDAgOiBvLnRleHRDb250ZW50O1xyXG4gICAgICBpZiAoIWwpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICBjb25zdCBkID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXHJcbiAgICAgICAgbFxyXG4gICAgICApO1xyXG4gICAgICAociA9IHRoaXMuX2VsZW1lbnQpID09IG51bGwgfHwgci5hcHBlbmRDaGlsZChkKSwgby5yZW1vdmUoKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKGUuY29kZSAhPT0gXCJCYWNrc3BhY2VcIiAmJiBlLmNvZGUgIT09IFwiRGVsZXRlXCIgfHwgIXRoaXMuX2VsZW1lbnQpXHJcbiAgICAgIHJldHVybjtcclxuICAgIGNvbnN0IHsgdGV4dENvbnRlbnQ6IHQgfSA9IHRoaXMuX2VsZW1lbnQ7XHJcbiAgICB0ID09PSBcIlwiICYmICh0aGlzLl9lbGVtZW50LmlubmVySFRNTCA9IFwiXCIpO1xyXG4gIH1cclxuICBkcmF3VmlldygpIHtcclxuICAgIGNvbnN0IGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiRElWXCIpO1xyXG4gICAgcmV0dXJuIGUuY2xhc3NMaXN0LmFkZCh0aGlzLl9DU1Mud3JhcHBlciwgdGhpcy5fQ1NTLmJsb2NrKSwgZS5jb250ZW50RWRpdGFibGUgPSBcImZhbHNlXCIsIGUuZGF0YXNldC5wbGFjZWhvbGRlciA9IHRoaXMuYXBpLmkxOG4udCh0aGlzLl9wbGFjZWhvbGRlciksIHRoaXMuX2RhdGEudGV4dCAmJiAoZS5pbm5lckhUTUwgPSB0aGlzLl9kYXRhLnRleHQpLCB0aGlzLnJlYWRPbmx5IHx8IChlLmNvbnRlbnRFZGl0YWJsZSA9IFwidHJ1ZVwiLCBlLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCB0aGlzLm9uS2V5VXApLCBlLmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCB0aGlzLm9uSW5wdXQpKSwgZTtcclxuICB9XHJcbiAgX3BsYWNlaG9sZGVyKGUpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xyXG4gIH1cclxufVxyXG5leHBvcnQge1xyXG4gIHUgYXMgZGVmYXVsdFxyXG59O1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@alkhipce/editorjs-aitext/dist/aitext.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@editorjs/delimiter/dist/delimiter.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@editorjs/delimiter/dist/delimiter.mjs ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ o; }\n/* harmony export */ });\n(function(){\"use strict\";try{if(typeof document<\"u\"){var e=document.createElement(\"style\");e.appendChild(document.createTextNode('.ce-delimiter{line-height:1.6em;width:100%;text-align:center}.ce-delimiter:before{display:inline-block;content:\"***\";font-size:30px;line-height:65px;height:30px;letter-spacing:.2em}')),document.head.appendChild(e)}}catch(t){console.error(\"vite-plugin-css-injected-by-js\",t)}})();\nconst r = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><line x1=\"6\" x2=\"10\" y1=\"12\" y2=\"12\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\"/><line x1=\"14\" x2=\"18\" y1=\"12\" y2=\"12\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\"/></svg>';\n/**\n * Delimiter Block for the Editor.js.\n *\n * @author CodeX (team@ifmo.su)\n * @copyright CodeX 2018\n * @license The MIT License (MIT)\n * @version 2.0.0\n */\nclass o {\n  /**\n   * Notify core that read-only mode is supported\n   * @return {boolean}\n   */\n  static get isReadOnlySupported() {\n    return !0;\n  }\n  /**\n   * Allow Tool to have no content\n   * @return {boolean}\n   */\n  static get contentless() {\n    return !0;\n  }\n  /**\n   * Render plugin`s main Element and fill it with saved data\n   *\n   * @param {{data: DelimiterData, config: object, api: object}}\n   *   data  previously saved data\n   *   config - user config for Tool\n   *   api - Editor.js API\n   */\n  constructor({ data: t, config: s, api: e }) {\n    this.api = e, this._CSS = {\n      block: this.api.styles.block,\n      wrapper: \"ce-delimiter\"\n    }, this._data = {}, this._element = this.drawView(), this.data = t;\n  }\n  /**\n   * Create Tool's view\n   * @return {HTMLElement}\n   * @private\n   */\n  drawView() {\n    let t = document.createElement(\"DIV\");\n    return t.classList.add(this._CSS.wrapper, this._CSS.block), t;\n  }\n  /**\n   * Return Tool's view\n   * @returns {HTMLDivElement}\n   * @public\n   */\n  render() {\n    return this._element;\n  }\n  /**\n   * Extract Tool's data from the view\n   * @param {HTMLDivElement} toolsContent - Paragraph tools rendered view\n   * @returns {DelimiterData} - saved data\n   * @public\n   */\n  save(t) {\n    return {};\n  }\n  /**\n   * Get Tool toolbox settings\n   * icon - Tool icon's SVG\n   * title - title to show in toolbox\n   *\n   * @return {{icon: string, title: string}}\n   */\n  static get toolbox() {\n    return {\n      icon: r,\n      title: \"Delimiter\"\n    };\n  }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZWRpdG9yanMvZGVsaW1pdGVyL2Rpc3QvZGVsaW1pdGVyLm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsWUFBWSxhQUFhLElBQUksd0JBQXdCLHNDQUFzQyxxREFBcUQsa0JBQWtCLFdBQVcsa0JBQWtCLHFCQUFxQixxQkFBcUIsY0FBYyxlQUFlLGlCQUFpQixZQUFZLG9CQUFvQixrQ0FBa0MsU0FBUyxtREFBbUQ7QUFDclo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0QkFBNEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsS0FBSyxpQkFBaUI7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QixlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AZWRpdG9yanMvZGVsaW1pdGVyL2Rpc3QvZGVsaW1pdGVyLm1qcz84OTY4Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO3RyeXtpZih0eXBlb2YgZG9jdW1lbnQ8XCJ1XCIpe3ZhciBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcuY2UtZGVsaW1pdGVye2xpbmUtaGVpZ2h0OjEuNmVtO3dpZHRoOjEwMCU7dGV4dC1hbGlnbjpjZW50ZXJ9LmNlLWRlbGltaXRlcjpiZWZvcmV7ZGlzcGxheTppbmxpbmUtYmxvY2s7Y29udGVudDpcIioqKlwiO2ZvbnQtc2l6ZTozMHB4O2xpbmUtaGVpZ2h0OjY1cHg7aGVpZ2h0OjMwcHg7bGV0dGVyLXNwYWNpbmc6LjJlbX0nKSksZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChlKX19Y2F0Y2godCl7Y29uc29sZS5lcnJvcihcInZpdGUtcGx1Z2luLWNzcy1pbmplY3RlZC1ieS1qc1wiLHQpfX0pKCk7XG5jb25zdCByID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxsaW5lIHgxPVwiNlwiIHgyPVwiMTBcIiB5MT1cIjEyXCIgeTI9XCIxMlwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIvPjxsaW5lIHgxPVwiMTRcIiB4Mj1cIjE4XCIgeTE9XCIxMlwiIHkyPVwiMTJcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiLz48L3N2Zz4nO1xuLyoqXG4gKiBEZWxpbWl0ZXIgQmxvY2sgZm9yIHRoZSBFZGl0b3IuanMuXG4gKlxuICogQGF1dGhvciBDb2RlWCAodGVhbUBpZm1vLnN1KVxuICogQGNvcHlyaWdodCBDb2RlWCAyMDE4XG4gKiBAbGljZW5zZSBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIEB2ZXJzaW9uIDIuMC4wXG4gKi9cbmNsYXNzIG8ge1xuICAvKipcbiAgICogTm90aWZ5IGNvcmUgdGhhdCByZWFkLW9ubHkgbW9kZSBpcyBzdXBwb3J0ZWRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBnZXQgaXNSZWFkT25seVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gITA7XG4gIH1cbiAgLyoqXG4gICAqIEFsbG93IFRvb2wgdG8gaGF2ZSBubyBjb250ZW50XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgZ2V0IGNvbnRlbnRsZXNzKCkge1xuICAgIHJldHVybiAhMDtcbiAgfVxuICAvKipcbiAgICogUmVuZGVyIHBsdWdpbmBzIG1haW4gRWxlbWVudCBhbmQgZmlsbCBpdCB3aXRoIHNhdmVkIGRhdGFcbiAgICpcbiAgICogQHBhcmFtIHt7ZGF0YTogRGVsaW1pdGVyRGF0YSwgY29uZmlnOiBvYmplY3QsIGFwaTogb2JqZWN0fX1cbiAgICogICBkYXRhIOKAlCBwcmV2aW91c2x5IHNhdmVkIGRhdGFcbiAgICogICBjb25maWcgLSB1c2VyIGNvbmZpZyBmb3IgVG9vbFxuICAgKiAgIGFwaSAtIEVkaXRvci5qcyBBUElcbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgZGF0YTogdCwgY29uZmlnOiBzLCBhcGk6IGUgfSkge1xuICAgIHRoaXMuYXBpID0gZSwgdGhpcy5fQ1NTID0ge1xuICAgICAgYmxvY2s6IHRoaXMuYXBpLnN0eWxlcy5ibG9jayxcbiAgICAgIHdyYXBwZXI6IFwiY2UtZGVsaW1pdGVyXCJcbiAgICB9LCB0aGlzLl9kYXRhID0ge30sIHRoaXMuX2VsZW1lbnQgPSB0aGlzLmRyYXdWaWV3KCksIHRoaXMuZGF0YSA9IHQ7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBUb29sJ3Mgdmlld1xuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRyYXdWaWV3KCkge1xuICAgIGxldCB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkRJVlwiKTtcbiAgICByZXR1cm4gdC5jbGFzc0xpc3QuYWRkKHRoaXMuX0NTUy53cmFwcGVyLCB0aGlzLl9DU1MuYmxvY2spLCB0O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gVG9vbCdzIHZpZXdcbiAgICogQHJldHVybnMge0hUTUxEaXZFbGVtZW50fVxuICAgKiBAcHVibGljXG4gICAqL1xuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQ7XG4gIH1cbiAgLyoqXG4gICAqIEV4dHJhY3QgVG9vbCdzIGRhdGEgZnJvbSB0aGUgdmlld1xuICAgKiBAcGFyYW0ge0hUTUxEaXZFbGVtZW50fSB0b29sc0NvbnRlbnQgLSBQYXJhZ3JhcGggdG9vbHMgcmVuZGVyZWQgdmlld1xuICAgKiBAcmV0dXJucyB7RGVsaW1pdGVyRGF0YX0gLSBzYXZlZCBkYXRhXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHNhdmUodCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICAvKipcbiAgICogR2V0IFRvb2wgdG9vbGJveCBzZXR0aW5nc1xuICAgKiBpY29uIC0gVG9vbCBpY29uJ3MgU1ZHXG4gICAqIHRpdGxlIC0gdGl0bGUgdG8gc2hvdyBpbiB0b29sYm94XG4gICAqXG4gICAqIEByZXR1cm4ge3tpY29uOiBzdHJpbmcsIHRpdGxlOiBzdHJpbmd9fVxuICAgKi9cbiAgc3RhdGljIGdldCB0b29sYm94KCkge1xuICAgIHJldHVybiB7XG4gICAgICBpY29uOiByLFxuICAgICAgdGl0bGU6IFwiRGVsaW1pdGVyXCJcbiAgICB9O1xuICB9XG59XG5leHBvcnQge1xuICBvIGFzIGRlZmF1bHRcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@editorjs/delimiter/dist/delimiter.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@editorjs/editorjs/dist/editorjs.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@editorjs/editorjs/dist/editorjs.mjs ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Bs; }\n/* harmony export */ });\n(function(){\"use strict\";try{if(typeof document<\"u\"){var e=document.createElement(\"style\");e.appendChild(document.createTextNode(\".ce-hint--align-start{text-align:left}.ce-hint--align-center{text-align:center}.ce-hint__description{opacity:.6;margin-top:3px}\")),document.head.appendChild(e)}}catch(t){console.error(\"vite-plugin-css-injected-by-js\",t)}})();\nvar ko = typeof globalThis < \"u\" ? globalThis : typeof window < \"u\" ? window : typeof global < \"u\" ? global : typeof self < \"u\" ? self : {};\nfunction Re(n) {\n  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, \"default\") ? n.default : n;\n}\nfunction ze() {\n}\nObject.assign(ze, {\n  default: ze,\n  register: ze,\n  revert: function() {\n  },\n  __esModule: !0\n});\nElement.prototype.matches || (Element.prototype.matches = Element.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector || Element.prototype.webkitMatchesSelector || function(n) {\n  const e = (this.document || this.ownerDocument).querySelectorAll(n);\n  let t = e.length;\n  for (; --t >= 0 && e.item(t) !== this; )\n    ;\n  return t > -1;\n});\nElement.prototype.closest || (Element.prototype.closest = function(n) {\n  let e = this;\n  if (!document.documentElement.contains(e))\n    return null;\n  do {\n    if (e.matches(n))\n      return e;\n    e = e.parentElement || e.parentNode;\n  } while (e !== null);\n  return null;\n});\nElement.prototype.prepend || (Element.prototype.prepend = function(e) {\n  const t = document.createDocumentFragment();\n  Array.isArray(e) || (e = [e]), e.forEach((o) => {\n    const i = o instanceof Node;\n    t.appendChild(i ? o : document.createTextNode(o));\n  }), this.insertBefore(t, this.firstChild);\n});\nElement.prototype.scrollIntoViewIfNeeded || (Element.prototype.scrollIntoViewIfNeeded = function(n) {\n  n = arguments.length === 0 ? !0 : !!n;\n  const e = this.parentNode, t = window.getComputedStyle(e, null), o = parseInt(t.getPropertyValue(\"border-top-width\")), i = parseInt(t.getPropertyValue(\"border-left-width\")), s = this.offsetTop - e.offsetTop < e.scrollTop, r = this.offsetTop - e.offsetTop + this.clientHeight - o > e.scrollTop + e.clientHeight, l = this.offsetLeft - e.offsetLeft < e.scrollLeft, a = this.offsetLeft - e.offsetLeft + this.clientWidth - i > e.scrollLeft + e.clientWidth, c = s && !r;\n  (s || r) && n && (e.scrollTop = this.offsetTop - e.offsetTop - e.clientHeight / 2 - o + this.clientHeight / 2), (l || a) && n && (e.scrollLeft = this.offsetLeft - e.offsetLeft - e.clientWidth / 2 - i + this.clientWidth / 2), (s || r || l || a) && !n && this.scrollIntoView(c);\n});\nwindow.requestIdleCallback = window.requestIdleCallback || function(n) {\n  const e = Date.now();\n  return setTimeout(function() {\n    n({\n      didTimeout: !1,\n      timeRemaining: function() {\n        return Math.max(0, 50 - (Date.now() - e));\n      }\n    });\n  }, 1);\n};\nwindow.cancelIdleCallback = window.cancelIdleCallback || function(n) {\n  clearTimeout(n);\n};\nlet vo = (n = 21) => crypto.getRandomValues(new Uint8Array(n)).reduce((e, t) => (t &= 63, t < 36 ? e += t.toString(36) : t < 62 ? e += (t - 26).toString(36).toUpperCase() : t > 62 ? e += \"-\" : e += \"_\", e), \"\");\nvar St = /* @__PURE__ */ ((n) => (n.VERBOSE = \"VERBOSE\", n.INFO = \"INFO\", n.WARN = \"WARN\", n.ERROR = \"ERROR\", n))(St || {});\nconst w = {\n  BACKSPACE: 8,\n  TAB: 9,\n  ENTER: 13,\n  SHIFT: 16,\n  CTRL: 17,\n  ALT: 18,\n  ESC: 27,\n  SPACE: 32,\n  LEFT: 37,\n  UP: 38,\n  DOWN: 40,\n  RIGHT: 39,\n  DELETE: 46,\n  META: 91,\n  SLASH: 191\n}, wo = {\n  LEFT: 0,\n  WHEEL: 1,\n  RIGHT: 2,\n  BACKWARD: 3,\n  FORWARD: 4\n};\nfunction Ee(n, e, t = \"log\", o, i = \"color: inherit\") {\n  if (!(\"console\" in window) || !window.console[t])\n    return;\n  const s = [\"info\", \"log\", \"warn\", \"error\"].includes(t), r = [];\n  switch (Ee.logLevel) {\n    case \"ERROR\":\n      if (t !== \"error\")\n        return;\n      break;\n    case \"WARN\":\n      if (![\"error\", \"warn\"].includes(t))\n        return;\n      break;\n    case \"INFO\":\n      if (!s || n)\n        return;\n      break;\n  }\n  o && r.push(o);\n  const l = \"Editor.js 2.30.0\", a = `line-height: 1em;\n            color: #006FEA;\n            display: inline-block;\n            font-size: 11px;\n            line-height: 1em;\n            background-color: #fff;\n            padding: 4px 9px;\n            border-radius: 30px;\n            border: 1px solid rgba(56, 138, 229, 0.16);\n            margin: 4px 5px 4px 0;`;\n  n && (s ? (r.unshift(a, i), e = `%c${l}%c ${e}`) : e = `( ${l} )${e}`);\n  try {\n    s ? o ? console[t](`${e} %o`, ...r) : console[t](e, ...r) : console[t](e);\n  } catch {\n  }\n}\nEe.logLevel = \"VERBOSE\";\nfunction xo(n) {\n  Ee.logLevel = n;\n}\nconst I = Ee.bind(window, !1), K = Ee.bind(window, !0);\nfunction ne(n) {\n  return Object.prototype.toString.call(n).match(/\\s([a-zA-Z]+)/)[1].toLowerCase();\n}\nfunction O(n) {\n  return ne(n) === \"function\" || ne(n) === \"asyncfunction\";\n}\nfunction R(n) {\n  return ne(n) === \"object\";\n}\nfunction Q(n) {\n  return ne(n) === \"string\";\n}\nfunction yo(n) {\n  return ne(n) === \"boolean\";\n}\nfunction mt(n) {\n  return ne(n) === \"number\";\n}\nfunction bt(n) {\n  return ne(n) === \"undefined\";\n}\nfunction X(n) {\n  return n ? Object.keys(n).length === 0 && n.constructor === Object : !0;\n}\nfunction It(n) {\n  return n > 47 && n < 58 || // number keys\n  n === 32 || n === 13 || // Space bar & return key(s)\n  n === 229 || // processing key input for certain languages  Chinese, Japanese, etc.\n  n > 64 && n < 91 || // letter keys\n  n > 95 && n < 112 || // Numpad keys\n  n > 185 && n < 193 || // ;=,-./` (in order)\n  n > 218 && n < 223;\n}\nasync function Eo(n, e = () => {\n}, t = () => {\n}) {\n  async function o(i, s, r) {\n    try {\n      await i.function(i.data), await s(bt(i.data) ? {} : i.data);\n    } catch {\n      r(bt(i.data) ? {} : i.data);\n    }\n  }\n  return n.reduce(async (i, s) => (await i, o(s, e, t)), Promise.resolve());\n}\nfunction Mt(n) {\n  return Array.prototype.slice.call(n);\n}\nfunction Ae(n, e) {\n  return function() {\n    const t = this, o = arguments;\n    window.setTimeout(() => n.apply(t, o), e);\n  };\n}\nfunction Bo(n) {\n  return n.name.split(\".\").pop();\n}\nfunction To(n) {\n  return /^[-\\w]+\\/([-+\\w]+|\\*)$/.test(n);\n}\nfunction kt(n, e, t) {\n  let o;\n  return (...i) => {\n    const s = this, r = () => {\n      o = null, t || n.apply(s, i);\n    }, l = t && !o;\n    window.clearTimeout(o), o = window.setTimeout(r, e), l && n.apply(s, i);\n  };\n}\nfunction Ve(n, e, t = void 0) {\n  let o, i, s, r = null, l = 0;\n  t || (t = {});\n  const a = function() {\n    l = t.leading === !1 ? 0 : Date.now(), r = null, s = n.apply(o, i), r || (o = i = null);\n  };\n  return function() {\n    const c = Date.now();\n    !l && t.leading === !1 && (l = c);\n    const u = e - (c - l);\n    return o = this, i = arguments, u <= 0 || u > e ? (r && (clearTimeout(r), r = null), l = c, s = n.apply(o, i), r || (o = i = null)) : !r && t.trailing !== !1 && (r = setTimeout(a, u)), s;\n  };\n}\nfunction Co() {\n  const n = {\n    win: !1,\n    mac: !1,\n    x11: !1,\n    linux: !1\n  }, e = Object.keys(n).find((t) => window.navigator.appVersion.toLowerCase().indexOf(t) !== -1);\n  return e && (n[e] = !0), n;\n}\nfunction Oe(n) {\n  return n[0].toUpperCase() + n.slice(1);\n}\nfunction qe(n, ...e) {\n  if (!e.length)\n    return n;\n  const t = e.shift();\n  if (R(n) && R(t))\n    for (const o in t)\n      R(t[o]) ? (n[o] || Object.assign(n, { [o]: {} }), qe(n[o], t[o])) : Object.assign(n, { [o]: t[o] });\n  return qe(n, ...e);\n}\nfunction et(n) {\n  const e = Co();\n  return n = n.replace(/shift/gi, \"\").replace(/backspace/gi, \"\").replace(/enter/gi, \"\").replace(/up/gi, \"\").replace(/left/gi, \"\").replace(/down/gi, \"\").replace(/right/gi, \"\").replace(/escape/gi, \"\").replace(/insert/gi, \"Ins\").replace(/delete/gi, \"\").replace(/\\+/gi, \" + \"), e.mac ? n = n.replace(/ctrl|cmd/gi, \"\").replace(/alt/gi, \"\") : n = n.replace(/cmd/gi, \"Ctrl\").replace(/windows/gi, \"WIN\"), n;\n}\nfunction So(n) {\n  try {\n    return new URL(n).href;\n  } catch {\n  }\n  return n.substring(0, 2) === \"//\" ? window.location.protocol + n : window.location.origin + n;\n}\nfunction Io() {\n  return vo(10);\n}\nfunction Mo(n) {\n  window.open(n, \"_blank\");\n}\nfunction Ao(n = \"\") {\n  return `${n}${Math.floor(Math.random() * 1e8).toString(16)}`;\n}\nfunction Ze(n, e, t) {\n  const o = `${e} is deprecated and will be removed in the next major release. Please use the ${t} instead.`;\n  n && K(o, \"warn\");\n}\nfunction he(n, e, t) {\n  const o = t.value ? \"value\" : \"get\", i = t[o], s = `#${e}Cache`;\n  if (t[o] = function(...r) {\n    return this[s] === void 0 && (this[s] = i.apply(this, ...r)), this[s];\n  }, o === \"get\" && t.set) {\n    const r = t.set;\n    t.set = function(l) {\n      delete n[s], r.apply(this, l);\n    };\n  }\n  return t;\n}\nconst At = 650;\nfunction ue() {\n  return window.matchMedia(`(max-width: ${At}px)`).matches;\n}\nconst Ge = typeof window < \"u\" && window.navigator && window.navigator.platform && (/iP(ad|hone|od)/.test(window.navigator.platform) || window.navigator.platform === \"MacIntel\" && window.navigator.maxTouchPoints > 1);\nfunction Oo(n, e) {\n  const t = Array.isArray(n) || R(n), o = Array.isArray(e) || R(e);\n  return t || o ? JSON.stringify(n) === JSON.stringify(e) : n === e;\n}\nclass d {\n  /**\n   * Check if passed tag has no closed tag\n   *\n   * @param {HTMLElement} tag - element to check\n   * @returns {boolean}\n   */\n  static isSingleTag(e) {\n    return e.tagName && [\n      \"AREA\",\n      \"BASE\",\n      \"BR\",\n      \"COL\",\n      \"COMMAND\",\n      \"EMBED\",\n      \"HR\",\n      \"IMG\",\n      \"INPUT\",\n      \"KEYGEN\",\n      \"LINK\",\n      \"META\",\n      \"PARAM\",\n      \"SOURCE\",\n      \"TRACK\",\n      \"WBR\"\n    ].includes(e.tagName);\n  }\n  /**\n   * Check if element is BR or WBR\n   *\n   * @param {HTMLElement} element - element to check\n   * @returns {boolean}\n   */\n  static isLineBreakTag(e) {\n    return e && e.tagName && [\n      \"BR\",\n      \"WBR\"\n    ].includes(e.tagName);\n  }\n  /**\n   * Helper for making Elements with class name and attributes\n   *\n   * @param  {string} tagName - new Element tag name\n   * @param  {string[]|string} [classNames] - list or name of CSS class name(s)\n   * @param  {object} [attributes] - any attributes\n   * @returns {HTMLElement}\n   */\n  static make(e, t = null, o = {}) {\n    const i = document.createElement(e);\n    if (Array.isArray(t)) {\n      const s = t.filter((r) => r !== void 0);\n      i.classList.add(...s);\n    } else\n      t && i.classList.add(t);\n    for (const s in o)\n      Object.prototype.hasOwnProperty.call(o, s) && (i[s] = o[s]);\n    return i;\n  }\n  /**\n   * Creates Text Node with the passed content\n   *\n   * @param {string} content - text content\n   * @returns {Text}\n   */\n  static text(e) {\n    return document.createTextNode(e);\n  }\n  /**\n   * Append one or several elements to the parent\n   *\n   * @param  {Element|DocumentFragment} parent - where to append\n   * @param  {Element|Element[]|DocumentFragment|Text|Text[]} elements - element or elements list\n   */\n  static append(e, t) {\n    Array.isArray(t) ? t.forEach((o) => e.appendChild(o)) : e.appendChild(t);\n  }\n  /**\n   * Append element or a couple to the beginning of the parent elements\n   *\n   * @param {Element} parent - where to append\n   * @param {Element|Element[]} elements - element or elements list\n   */\n  static prepend(e, t) {\n    Array.isArray(t) ? (t = t.reverse(), t.forEach((o) => e.prepend(o))) : e.prepend(t);\n  }\n  /**\n   * Swap two elements in parent\n   *\n   * @param {HTMLElement} el1 - from\n   * @param {HTMLElement} el2 - to\n   * @deprecated\n   */\n  static swap(e, t) {\n    const o = document.createElement(\"div\"), i = e.parentNode;\n    i.insertBefore(o, e), i.insertBefore(e, t), i.insertBefore(t, o), i.removeChild(o);\n  }\n  /**\n   * Selector Decorator\n   *\n   * Returns first match\n   *\n   * @param {Element} el - element we searching inside. Default - DOM Document\n   * @param {string} selector - searching string\n   * @returns {Element}\n   */\n  static find(e = document, t) {\n    return e.querySelector(t);\n  }\n  /**\n   * Get Element by Id\n   *\n   * @param {string} id - id to find\n   * @returns {HTMLElement | null}\n   */\n  static get(e) {\n    return document.getElementById(e);\n  }\n  /**\n   * Selector Decorator.\n   *\n   * Returns all matches\n   *\n   * @param {Element|Document} el - element we searching inside. Default - DOM Document\n   * @param {string} selector - searching string\n   * @returns {NodeList}\n   */\n  static findAll(e = document, t) {\n    return e.querySelectorAll(t);\n  }\n  /**\n   * Returns CSS selector for all text inputs\n   */\n  static get allInputsSelector() {\n    return \"[contenteditable=true], textarea, input:not([type]), \" + [\"text\", \"password\", \"email\", \"number\", \"search\", \"tel\", \"url\"].map((t) => `input[type=\"${t}\"]`).join(\", \");\n  }\n  /**\n   * Find all contenteditable, textarea and editable input elements passed holder contains\n   *\n   * @param holder - element where to find inputs\n   */\n  static findAllInputs(e) {\n    return Mt(e.querySelectorAll(d.allInputsSelector)).reduce((t, o) => d.isNativeInput(o) || d.containsOnlyInlineElements(o) ? [...t, o] : [...t, ...d.getDeepestBlockElements(o)], []);\n  }\n  /**\n   * Search for deepest node which is Leaf.\n   * Leaf is the vertex that doesn't have any child nodes\n   *\n   * @description Method recursively goes throw the all Node until it finds the Leaf\n   * @param {Node} node - root Node. From this vertex we start Deep-first search\n   *                      {@link https://en.wikipedia.org/wiki/Depth-first_search}\n   * @param {boolean} [atLast] - find last text node\n   * @returns - it can be text Node or Element Node, so that caret will able to work with it\n   *            Can return null if node is Document or DocumentFragment, or node is not attached to the DOM\n   */\n  static getDeepestNode(e, t = !1) {\n    const o = t ? \"lastChild\" : \"firstChild\", i = t ? \"previousSibling\" : \"nextSibling\";\n    if (e && e.nodeType === Node.ELEMENT_NODE && e[o]) {\n      let s = e[o];\n      if (d.isSingleTag(s) && !d.isNativeInput(s) && !d.isLineBreakTag(s))\n        if (s[i])\n          s = s[i];\n        else if (s.parentNode[i])\n          s = s.parentNode[i];\n        else\n          return s.parentNode;\n      return this.getDeepestNode(s, t);\n    }\n    return e;\n  }\n  /**\n   * Check if object is DOM node\n   *\n   * @param {*} node - object to check\n   * @returns {boolean}\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static isElement(e) {\n    return mt(e) ? !1 : e && e.nodeType && e.nodeType === Node.ELEMENT_NODE;\n  }\n  /**\n   * Check if object is DocumentFragment node\n   *\n   * @param {object} node - object to check\n   * @returns {boolean}\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static isFragment(e) {\n    return mt(e) ? !1 : e && e.nodeType && e.nodeType === Node.DOCUMENT_FRAGMENT_NODE;\n  }\n  /**\n   * Check if passed element is contenteditable\n   *\n   * @param {HTMLElement} element - html element to check\n   * @returns {boolean}\n   */\n  static isContentEditable(e) {\n    return e.contentEditable === \"true\";\n  }\n  /**\n   * Checks target if it is native input\n   *\n   * @param {*} target - HTML element or string\n   * @returns {boolean}\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static isNativeInput(e) {\n    const t = [\n      \"INPUT\",\n      \"TEXTAREA\"\n    ];\n    return e && e.tagName ? t.includes(e.tagName) : !1;\n  }\n  /**\n   * Checks if we can set caret\n   *\n   * @param {HTMLElement} target - target to check\n   * @returns {boolean}\n   */\n  static canSetCaret(e) {\n    let t = !0;\n    if (d.isNativeInput(e))\n      switch (e.type) {\n        case \"file\":\n        case \"checkbox\":\n        case \"radio\":\n        case \"hidden\":\n        case \"submit\":\n        case \"button\":\n        case \"image\":\n        case \"reset\":\n          t = !1;\n          break;\n      }\n    else\n      t = d.isContentEditable(e);\n    return t;\n  }\n  /**\n   * Checks node if it is empty\n   *\n   * @description Method checks simple Node without any childs for emptiness\n   * If you have Node with 2 or more children id depth, you better use {@link Dom#isEmpty} method\n   * @param {Node} node - node to check\n   * @param {string} [ignoreChars] - char or substring to treat as empty\n   * @returns {boolean} true if it is empty\n   */\n  static isNodeEmpty(e, t) {\n    let o;\n    return this.isSingleTag(e) && !this.isLineBreakTag(e) ? !1 : (this.isElement(e) && this.isNativeInput(e) ? o = e.value : o = e.textContent.replace(\"\", \"\"), t && (o = o.replace(new RegExp(t, \"g\"), \"\")), o.trim().length === 0);\n  }\n  /**\n   * checks node if it is doesn't have any child nodes\n   *\n   * @param {Node} node - node to check\n   * @returns {boolean}\n   */\n  static isLeaf(e) {\n    return e ? e.childNodes.length === 0 : !1;\n  }\n  /**\n   * breadth-first search (BFS)\n   * {@link https://en.wikipedia.org/wiki/Breadth-first_search}\n   *\n   * @description Pushes to stack all DOM leafs and checks for emptiness\n   * @param {Node} node - node to check\n   * @param {string} [ignoreChars] - char or substring to treat as empty\n   * @returns {boolean}\n   */\n  static isEmpty(e, t) {\n    e.normalize();\n    const o = [e];\n    for (; o.length > 0; )\n      if (e = o.shift(), !!e) {\n        if (this.isLeaf(e) && !this.isNodeEmpty(e, t))\n          return !1;\n        e.childNodes && o.push(...Array.from(e.childNodes));\n      }\n    return !0;\n  }\n  /**\n   * Check if string contains html elements\n   *\n   * @param {string} str - string to check\n   * @returns {boolean}\n   */\n  static isHTMLString(e) {\n    const t = d.make(\"div\");\n    return t.innerHTML = e, t.childElementCount > 0;\n  }\n  /**\n   * Return length of node`s text content\n   *\n   * @param {Node} node - node with content\n   * @returns {number}\n   */\n  static getContentLength(e) {\n    return d.isNativeInput(e) ? e.value.length : e.nodeType === Node.TEXT_NODE ? e.length : e.textContent.length;\n  }\n  /**\n   * Return array of names of block html elements\n   *\n   * @returns {string[]}\n   */\n  static get blockElements() {\n    return [\n      \"address\",\n      \"article\",\n      \"aside\",\n      \"blockquote\",\n      \"canvas\",\n      \"div\",\n      \"dl\",\n      \"dt\",\n      \"fieldset\",\n      \"figcaption\",\n      \"figure\",\n      \"footer\",\n      \"form\",\n      \"h1\",\n      \"h2\",\n      \"h3\",\n      \"h4\",\n      \"h5\",\n      \"h6\",\n      \"header\",\n      \"hgroup\",\n      \"hr\",\n      \"li\",\n      \"main\",\n      \"nav\",\n      \"noscript\",\n      \"ol\",\n      \"output\",\n      \"p\",\n      \"pre\",\n      \"ruby\",\n      \"section\",\n      \"table\",\n      \"tbody\",\n      \"thead\",\n      \"tr\",\n      \"tfoot\",\n      \"ul\",\n      \"video\"\n    ];\n  }\n  /**\n   * Check if passed content includes only inline elements\n   *\n   * @param {string|HTMLElement} data - element or html string\n   * @returns {boolean}\n   */\n  static containsOnlyInlineElements(e) {\n    let t;\n    Q(e) ? (t = document.createElement(\"div\"), t.innerHTML = e) : t = e;\n    const o = (i) => !d.blockElements.includes(i.tagName.toLowerCase()) && Array.from(i.children).every(o);\n    return Array.from(t.children).every(o);\n  }\n  /**\n   * Find and return all block elements in the passed parent (including subtree)\n   *\n   * @param {HTMLElement} parent - root element\n   * @returns {HTMLElement[]}\n   */\n  static getDeepestBlockElements(e) {\n    return d.containsOnlyInlineElements(e) ? [e] : Array.from(e.children).reduce((t, o) => [...t, ...d.getDeepestBlockElements(o)], []);\n  }\n  /**\n   * Helper for get holder from {string} or return HTMLElement\n   *\n   * @param {string | HTMLElement} element - holder's id or holder's HTML Element\n   * @returns {HTMLElement}\n   */\n  static getHolder(e) {\n    return Q(e) ? document.getElementById(e) : e;\n  }\n  /**\n   * Returns true if element is anchor (is A tag)\n   *\n   * @param {Element} element - element to check\n   * @returns {boolean}\n   */\n  static isAnchor(e) {\n    return e.tagName.toLowerCase() === \"a\";\n  }\n  /**\n   * Return element's offset related to the document\n   *\n   * @todo handle case when editor initialized in scrollable popup\n   * @param el - element to compute offset\n   */\n  static offset(e) {\n    const t = e.getBoundingClientRect(), o = window.pageXOffset || document.documentElement.scrollLeft, i = window.pageYOffset || document.documentElement.scrollTop, s = t.top + i, r = t.left + o;\n    return {\n      top: s,\n      left: r,\n      bottom: s + t.height,\n      right: r + t.width\n    };\n  }\n}\nfunction Lo(n) {\n  return !/[^\\t\\n\\r ]/.test(n);\n}\nfunction _o(n) {\n  const e = window.getComputedStyle(n), t = parseFloat(e.fontSize), o = parseFloat(e.lineHeight) || t * 1.2, i = parseFloat(e.paddingTop), s = parseFloat(e.borderTopWidth), r = parseFloat(e.marginTop), l = t * 0.8, a = (o - t) / 2;\n  return r + s + i + a + l;\n}\nfunction Ot(n) {\n  n.dataset.empty = d.isEmpty(n) ? \"true\" : \"false\";\n}\nconst No = {\n  blockTunes: {\n    toggler: {\n      \"Click to tune\": \"\",\n      \"or drag to move\": \"\"\n    }\n  },\n  inlineToolbar: {\n    converter: {\n      \"Convert to\": \"\"\n    }\n  },\n  toolbar: {\n    toolbox: {\n      Add: \"\"\n    }\n  },\n  popover: {\n    Filter: \"\",\n    \"Nothing found\": \"\",\n    \"Convert to\": \"\"\n  }\n}, Po = {\n  Text: \"\",\n  Link: \"\",\n  Bold: \"\",\n  Italic: \"\"\n}, Do = {\n  link: {\n    \"Add a link\": \"\"\n  },\n  stub: {\n    \"The block can not be displayed correctly.\": \"\"\n  }\n}, Ro = {\n  delete: {\n    Delete: \"\",\n    \"Click to delete\": \"\"\n  },\n  moveUp: {\n    \"Move up\": \"\"\n  },\n  moveDown: {\n    \"Move down\": \"\"\n  }\n}, Lt = {\n  ui: No,\n  toolNames: Po,\n  tools: Do,\n  blockTunes: Ro\n}, _t = class le {\n  /**\n   * Type-safe translation for internal UI texts:\n   * Perform translation of the string by namespace and a key\n   *\n   * @example I18n.ui(I18nInternalNS.ui.blockTunes.toggler, 'Click to tune')\n   * @param internalNamespace - path to translated string in dictionary\n   * @param dictKey - dictionary key. Better to use default locale original text\n   */\n  static ui(e, t) {\n    return le._t(e, t);\n  }\n  /**\n   * Translate for external strings that is not presented in default dictionary.\n   * For example, for user-specified tool names\n   *\n   * @param namespace - path to translated string in dictionary\n   * @param dictKey - dictionary key. Better to use default locale original text\n   */\n  static t(e, t) {\n    return le._t(e, t);\n  }\n  /**\n   * Adjust module for using external dictionary\n   *\n   * @param dictionary - new messages list to override default\n   */\n  static setDictionary(e) {\n    le.currentDictionary = e;\n  }\n  /**\n   * Perform translation both for internal and external namespaces\n   * If there is no translation found, returns passed key as a translated message\n   *\n   * @param namespace - path to translated string in dictionary\n   * @param dictKey - dictionary key. Better to use default locale original text\n   */\n  static _t(e, t) {\n    const o = le.getNamespace(e);\n    return !o || !o[t] ? t : o[t];\n  }\n  /**\n   * Find messages section by namespace path\n   *\n   * @param namespace - path to section\n   */\n  static getNamespace(e) {\n    return e.split(\".\").reduce((o, i) => !o || !Object.keys(o).length ? {} : o[i], le.currentDictionary);\n  }\n};\n_t.currentDictionary = Lt;\nlet W = _t;\nclass Nt extends Error {\n}\nclass Be {\n  constructor() {\n    this.subscribers = {};\n  }\n  /**\n   * Subscribe any event on callback\n   *\n   * @param eventName - event name\n   * @param callback - subscriber\n   */\n  on(e, t) {\n    e in this.subscribers || (this.subscribers[e] = []), this.subscribers[e].push(t);\n  }\n  /**\n   * Subscribe any event on callback. Callback will be called once and be removed from subscribers array after call.\n   *\n   * @param eventName - event name\n   * @param callback - subscriber\n   */\n  once(e, t) {\n    e in this.subscribers || (this.subscribers[e] = []);\n    const o = (i) => {\n      const s = t(i), r = this.subscribers[e].indexOf(o);\n      return r !== -1 && this.subscribers[e].splice(r, 1), s;\n    };\n    this.subscribers[e].push(o);\n  }\n  /**\n   * Emit callbacks with passed data\n   *\n   * @param eventName - event name\n   * @param data - subscribers get this data when they were fired\n   */\n  emit(e, t) {\n    X(this.subscribers) || !this.subscribers[e] || this.subscribers[e].reduce((o, i) => {\n      const s = i(o);\n      return s !== void 0 ? s : o;\n    }, t);\n  }\n  /**\n   * Unsubscribe callback from event\n   *\n   * @param eventName - event name\n   * @param callback - event handler\n   */\n  off(e, t) {\n    if (this.subscribers[e] === void 0) {\n      console.warn(`EventDispatcher .off(): there is no subscribers for event \"${e.toString()}\". Probably, .off() called before .on()`);\n      return;\n    }\n    for (let o = 0; o < this.subscribers[e].length; o++)\n      if (this.subscribers[e][o] === t) {\n        delete this.subscribers[e][o];\n        break;\n      }\n  }\n  /**\n   * Destroyer\n   * clears subscribers list\n   */\n  destroy() {\n    this.subscribers = {};\n  }\n}\nfunction G(n) {\n  Object.setPrototypeOf(this, {\n    /**\n     * Block id\n     *\n     * @returns {string}\n     */\n    get id() {\n      return n.id;\n    },\n    /**\n     * Tool name\n     *\n     * @returns {string}\n     */\n    get name() {\n      return n.name;\n    },\n    /**\n     * Tool config passed on Editor's initialization\n     *\n     * @returns {ToolConfig}\n     */\n    get config() {\n      return n.config;\n    },\n    /**\n     * .ce-block element, that wraps plugin contents\n     *\n     * @returns {HTMLElement}\n     */\n    get holder() {\n      return n.holder;\n    },\n    /**\n     * True if Block content is empty\n     *\n     * @returns {boolean}\n     */\n    get isEmpty() {\n      return n.isEmpty;\n    },\n    /**\n     * True if Block is selected with Cross-Block selection\n     *\n     * @returns {boolean}\n     */\n    get selected() {\n      return n.selected;\n    },\n    /**\n     * Set Block's stretch state\n     *\n     * @param {boolean} state  state to set\n     */\n    set stretched(t) {\n      n.stretched = t;\n    },\n    /**\n     * True if Block is stretched\n     *\n     * @returns {boolean}\n     */\n    get stretched() {\n      return n.stretched;\n    },\n    /**\n     * True if Block has inputs to be focused\n     */\n    get focusable() {\n      return n.focusable;\n    },\n    /**\n     * Call Tool method with errors handler under-the-hood\n     *\n     * @param {string} methodName - method to call\n     * @param {object} param - object with parameters\n     * @returns {unknown}\n     */\n    call(t, o) {\n      return n.call(t, o);\n    },\n    /**\n     * Save Block content\n     *\n     * @returns {Promise<void|SavedData>}\n     */\n    save() {\n      return n.save();\n    },\n    /**\n     * Validate Block data\n     *\n     * @param {BlockToolData} data - data to validate\n     * @returns {Promise<boolean>}\n     */\n    validate(t) {\n      return n.validate(t);\n    },\n    /**\n     * Allows to say Editor that Block was changed. Used to manually trigger Editor's 'onChange' callback\n     * Can be useful for block changes invisible for editor core.\n     */\n    dispatchChange() {\n      n.dispatchChange();\n    },\n    /**\n     * Tool could specify several entries to be displayed at the Toolbox (for example, \"Heading 1\", \"Heading 2\", \"Heading 3\")\n     * This method returns the entry that is related to the Block (depended on the Block data)\n     */\n    getActiveToolboxEntry() {\n      return n.getActiveToolboxEntry();\n    }\n  });\n}\nclass Te {\n  constructor() {\n    this.allListeners = [];\n  }\n  /**\n   * Assigns event listener on element and returns unique identifier\n   *\n   * @param {EventTarget} element - DOM element that needs to be listened\n   * @param {string} eventType - event type\n   * @param {Function} handler - method that will be fired on event\n   * @param {boolean|AddEventListenerOptions} options - useCapture or {capture, passive, once}\n   */\n  on(e, t, o, i = !1) {\n    const s = Ao(\"l\"), r = {\n      id: s,\n      element: e,\n      eventType: t,\n      handler: o,\n      options: i\n    };\n    if (!this.findOne(e, t, o))\n      return this.allListeners.push(r), e.addEventListener(t, o, i), s;\n  }\n  /**\n   * Removes event listener from element\n   *\n   * @param {EventTarget} element - DOM element that we removing listener\n   * @param {string} eventType - event type\n   * @param {Function} handler - remove handler, if element listens several handlers on the same event type\n   * @param {boolean|AddEventListenerOptions} options - useCapture or {capture, passive, once}\n   */\n  off(e, t, o, i) {\n    const s = this.findAll(e, t, o);\n    s.forEach((r, l) => {\n      const a = this.allListeners.indexOf(s[l]);\n      a > -1 && (this.allListeners.splice(a, 1), r.element.removeEventListener(r.eventType, r.handler, r.options));\n    });\n  }\n  /**\n   * Removes listener by id\n   *\n   * @param {string} id - listener identifier\n   */\n  offById(e) {\n    const t = this.findById(e);\n    t && t.element.removeEventListener(t.eventType, t.handler, t.options);\n  }\n  /**\n   * Finds and returns first listener by passed params\n   *\n   * @param {EventTarget} element - event target\n   * @param {string} [eventType] - event type\n   * @param {Function} [handler] - event handler\n   * @returns {ListenerData|null}\n   */\n  findOne(e, t, o) {\n    const i = this.findAll(e, t, o);\n    return i.length > 0 ? i[0] : null;\n  }\n  /**\n   * Return all stored listeners by passed params\n   *\n   * @param {EventTarget} element - event target\n   * @param {string} eventType - event type\n   * @param {Function} handler - event handler\n   * @returns {ListenerData[]}\n   */\n  findAll(e, t, o) {\n    let i;\n    const s = e ? this.findByEventTarget(e) : [];\n    return e && t && o ? i = s.filter((r) => r.eventType === t && r.handler === o) : e && t ? i = s.filter((r) => r.eventType === t) : i = s, i;\n  }\n  /**\n   * Removes all listeners\n   */\n  removeAll() {\n    this.allListeners.map((e) => {\n      e.element.removeEventListener(e.eventType, e.handler, e.options);\n    }), this.allListeners = [];\n  }\n  /**\n   * Module cleanup on destruction\n   */\n  destroy() {\n    this.removeAll();\n  }\n  /**\n   * Search method: looks for listener by passed element\n   *\n   * @param {EventTarget} element - searching element\n   * @returns {Array} listeners that found on element\n   */\n  findByEventTarget(e) {\n    return this.allListeners.filter((t) => {\n      if (t.element === e)\n        return t;\n    });\n  }\n  /**\n   * Search method: looks for listener by passed event type\n   *\n   * @param {string} eventType - event type\n   * @returns {ListenerData[]} listeners that found on element\n   */\n  findByType(e) {\n    return this.allListeners.filter((t) => {\n      if (t.eventType === e)\n        return t;\n    });\n  }\n  /**\n   * Search method: looks for listener by passed handler\n   *\n   * @param {Function} handler - event handler\n   * @returns {ListenerData[]} listeners that found on element\n   */\n  findByHandler(e) {\n    return this.allListeners.filter((t) => {\n      if (t.handler === e)\n        return t;\n    });\n  }\n  /**\n   * Returns listener data found by id\n   *\n   * @param {string} id - listener identifier\n   * @returns {ListenerData}\n   */\n  findById(e) {\n    return this.allListeners.find((t) => t.id === e);\n  }\n}\nclass y {\n  /**\n   * @class\n   * @param options - Module options\n   * @param options.config - Module config\n   * @param options.eventsDispatcher - Common event bus\n   */\n  constructor({ config: e, eventsDispatcher: t }) {\n    if (this.nodes = {}, this.listeners = new Te(), this.readOnlyMutableListeners = {\n      /**\n       * Assigns event listener on DOM element and pushes into special array that might be removed\n       *\n       * @param {EventTarget} element - DOM Element\n       * @param {string} eventType - Event name\n       * @param {Function} handler - Event handler\n       * @param {boolean|AddEventListenerOptions} options - Listening options\n       */\n      on: (o, i, s, r = !1) => {\n        this.mutableListenerIds.push(\n          this.listeners.on(o, i, s, r)\n        );\n      },\n      /**\n       * Clears all mutable listeners\n       */\n      clearAll: () => {\n        for (const o of this.mutableListenerIds)\n          this.listeners.offById(o);\n        this.mutableListenerIds = [];\n      }\n    }, this.mutableListenerIds = [], new.target === y)\n      throw new TypeError(\"Constructors for abstract class Module are not allowed.\");\n    this.config = e, this.eventsDispatcher = t;\n  }\n  /**\n   * Editor modules setter\n   *\n   * @param {EditorModules} Editor - Editor's Modules\n   */\n  set state(e) {\n    this.Editor = e;\n  }\n  /**\n   * Remove memorized nodes\n   */\n  removeAllNodes() {\n    for (const e in this.nodes) {\n      const t = this.nodes[e];\n      t instanceof HTMLElement && t.remove();\n    }\n  }\n  /**\n   * Returns true if current direction is RTL (Right-To-Left)\n   */\n  get isRtl() {\n    return this.config.i18n.direction === \"rtl\";\n  }\n}\nclass b {\n  constructor() {\n    this.instance = null, this.selection = null, this.savedSelectionRange = null, this.isFakeBackgroundEnabled = !1, this.commandBackground = \"backColor\", this.commandRemoveFormat = \"removeFormat\";\n  }\n  /**\n   * Editor styles\n   *\n   * @returns {{editorWrapper: string, editorZone: string}}\n   */\n  static get CSS() {\n    return {\n      editorWrapper: \"codex-editor\",\n      editorZone: \"codex-editor__redactor\"\n    };\n  }\n  /**\n   * Returns selected anchor\n   * {@link https://developer.mozilla.org/ru/docs/Web/API/Selection/anchorNode}\n   *\n   * @returns {Node|null}\n   */\n  static get anchorNode() {\n    const e = window.getSelection();\n    return e ? e.anchorNode : null;\n  }\n  /**\n   * Returns selected anchor element\n   *\n   * @returns {Element|null}\n   */\n  static get anchorElement() {\n    const e = window.getSelection();\n    if (!e)\n      return null;\n    const t = e.anchorNode;\n    return t ? d.isElement(t) ? t : t.parentElement : null;\n  }\n  /**\n   * Returns selection offset according to the anchor node\n   * {@link https://developer.mozilla.org/ru/docs/Web/API/Selection/anchorOffset}\n   *\n   * @returns {number|null}\n   */\n  static get anchorOffset() {\n    const e = window.getSelection();\n    return e ? e.anchorOffset : null;\n  }\n  /**\n   * Is current selection range collapsed\n   *\n   * @returns {boolean|null}\n   */\n  static get isCollapsed() {\n    const e = window.getSelection();\n    return e ? e.isCollapsed : null;\n  }\n  /**\n   * Check current selection if it is at Editor's zone\n   *\n   * @returns {boolean}\n   */\n  static get isAtEditor() {\n    return this.isSelectionAtEditor(b.get());\n  }\n  /**\n   * Check if passed selection is at Editor's zone\n   *\n   * @param selection - Selection object to check\n   */\n  static isSelectionAtEditor(e) {\n    if (!e)\n      return !1;\n    let t = e.anchorNode || e.focusNode;\n    t && t.nodeType === Node.TEXT_NODE && (t = t.parentNode);\n    let o = null;\n    return t && t instanceof Element && (o = t.closest(`.${b.CSS.editorZone}`)), o ? o.nodeType === Node.ELEMENT_NODE : !1;\n  }\n  /**\n   * Check if passed range at Editor zone\n   *\n   * @param range - range to check\n   */\n  static isRangeAtEditor(e) {\n    if (!e)\n      return;\n    let t = e.startContainer;\n    t && t.nodeType === Node.TEXT_NODE && (t = t.parentNode);\n    let o = null;\n    return t && t instanceof Element && (o = t.closest(`.${b.CSS.editorZone}`)), o ? o.nodeType === Node.ELEMENT_NODE : !1;\n  }\n  /**\n   * Methods return boolean that true if selection exists on the page\n   */\n  static get isSelectionExists() {\n    return !!b.get().anchorNode;\n  }\n  /**\n   * Return first range\n   *\n   * @returns {Range|null}\n   */\n  static get range() {\n    return this.getRangeFromSelection(this.get());\n  }\n  /**\n   * Returns range from passed Selection object\n   *\n   * @param selection - Selection object to get Range from\n   */\n  static getRangeFromSelection(e) {\n    return e && e.rangeCount ? e.getRangeAt(0) : null;\n  }\n  /**\n   * Calculates position and size of selected text\n   *\n   * @returns {DOMRect | ClientRect}\n   */\n  static get rect() {\n    let e = document.selection, t, o = {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0\n    };\n    if (e && e.type !== \"Control\")\n      return e = e, t = e.createRange(), o.x = t.boundingLeft, o.y = t.boundingTop, o.width = t.boundingWidth, o.height = t.boundingHeight, o;\n    if (!window.getSelection)\n      return I(\"Method window.getSelection is not supported\", \"warn\"), o;\n    if (e = window.getSelection(), e.rangeCount === null || isNaN(e.rangeCount))\n      return I(\"Method SelectionUtils.rangeCount is not supported\", \"warn\"), o;\n    if (e.rangeCount === 0)\n      return o;\n    if (t = e.getRangeAt(0).cloneRange(), t.getBoundingClientRect && (o = t.getBoundingClientRect()), o.x === 0 && o.y === 0) {\n      const i = document.createElement(\"span\");\n      if (i.getBoundingClientRect) {\n        i.appendChild(document.createTextNode(\"\")), t.insertNode(i), o = i.getBoundingClientRect();\n        const s = i.parentNode;\n        s.removeChild(i), s.normalize();\n      }\n    }\n    return o;\n  }\n  /**\n   * Returns selected text as String\n   *\n   * @returns {string}\n   */\n  static get text() {\n    return window.getSelection ? window.getSelection().toString() : \"\";\n  }\n  /**\n   * Returns window SelectionUtils\n   * {@link https://developer.mozilla.org/ru/docs/Web/API/Window/getSelection}\n   *\n   * @returns {Selection}\n   */\n  static get() {\n    return window.getSelection();\n  }\n  /**\n   * Set focus to contenteditable or native input element\n   *\n   * @param element - element where to set focus\n   * @param offset - offset of cursor\n   */\n  static setCursor(e, t = 0) {\n    const o = document.createRange(), i = window.getSelection();\n    return d.isNativeInput(e) ? d.canSetCaret(e) ? (e.focus(), e.selectionStart = e.selectionEnd = t, e.getBoundingClientRect()) : void 0 : (o.setStart(e, t), o.setEnd(e, t), i.removeAllRanges(), i.addRange(o), o.getBoundingClientRect());\n  }\n  /**\n   * Check if current range exists and belongs to container\n   *\n   * @param container - where range should be\n   */\n  static isRangeInsideContainer(e) {\n    const t = b.range;\n    return t === null ? !1 : e.contains(t.startContainer);\n  }\n  /**\n   * Adds fake cursor to the current range\n   */\n  static addFakeCursor() {\n    const e = b.range;\n    if (e === null)\n      return;\n    const t = d.make(\"span\", \"codex-editor__fake-cursor\");\n    t.dataset.mutationFree = \"true\", e.collapse(), e.insertNode(t);\n  }\n  /**\n   * Check if passed element contains a fake cursor\n   *\n   * @param el - where to check\n   */\n  static isFakeCursorInsideContainer(e) {\n    return d.find(e, \".codex-editor__fake-cursor\") !== null;\n  }\n  /**\n   * Removes fake cursor from a container\n   *\n   * @param container - container to look for\n   */\n  static removeFakeCursor(e = document.body) {\n    const t = d.find(e, \".codex-editor__fake-cursor\");\n    t && t.remove();\n  }\n  /**\n   * Removes fake background\n   */\n  removeFakeBackground() {\n    this.isFakeBackgroundEnabled && (this.isFakeBackgroundEnabled = !1, document.execCommand(this.commandRemoveFormat));\n  }\n  /**\n   * Sets fake background\n   */\n  setFakeBackground() {\n    document.execCommand(this.commandBackground, !1, \"#a8d6ff\"), this.isFakeBackgroundEnabled = !0;\n  }\n  /**\n   * Save SelectionUtils's range\n   */\n  save() {\n    this.savedSelectionRange = b.range;\n  }\n  /**\n   * Restore saved SelectionUtils's range\n   */\n  restore() {\n    if (!this.savedSelectionRange)\n      return;\n    const e = window.getSelection();\n    e.removeAllRanges(), e.addRange(this.savedSelectionRange);\n  }\n  /**\n   * Clears saved selection\n   */\n  clearSaved() {\n    this.savedSelectionRange = null;\n  }\n  /**\n   * Collapse current selection\n   */\n  collapseToEnd() {\n    const e = window.getSelection(), t = document.createRange();\n    t.selectNodeContents(e.focusNode), t.collapse(!1), e.removeAllRanges(), e.addRange(t);\n  }\n  /**\n   * Looks ahead to find passed tag from current selection\n   *\n   * @param  {string} tagName       - tag to found\n   * @param  {string} [className]   - tag's class name\n   * @param  {number} [searchDepth] - count of tags that can be included. For better performance.\n   * @returns {HTMLElement|null}\n   */\n  findParentTag(e, t, o = 10) {\n    const i = window.getSelection();\n    let s = null;\n    return !i || !i.anchorNode || !i.focusNode ? null : ([\n      /** the Node in which the selection begins */\n      i.anchorNode,\n      /** the Node in which the selection ends */\n      i.focusNode\n    ].forEach((l) => {\n      let a = o;\n      for (; a > 0 && l.parentNode && !(l.tagName === e && (s = l, t && l.classList && !l.classList.contains(t) && (s = null), s)); )\n        l = l.parentNode, a--;\n    }), s);\n  }\n  /**\n   * Expands selection range to the passed parent node\n   *\n   * @param {HTMLElement} element - element which contents should be selected\n   */\n  expandToTag(e) {\n    const t = window.getSelection();\n    t.removeAllRanges();\n    const o = document.createRange();\n    o.selectNodeContents(e), t.addRange(o);\n  }\n}\nfunction Fo(n, e) {\n  const { type: t, target: o, addedNodes: i, removedNodes: s } = n;\n  return n.type === \"attributes\" && n.attributeName === \"data-empty\" ? !1 : !!(e.contains(o) || t === \"childList\" && (Array.from(i).some((a) => a === e) || Array.from(s).some((a) => a === e)));\n}\nconst Je = \"redactor dom changed\", Pt = \"block changed\", Dt = \"fake cursor is about to be toggled\", Rt = \"fake cursor have been set\", xe = \"editor mobile layout toggled\";\nfunction Ft(n, e) {\n  if (!n.conversionConfig)\n    return !1;\n  const t = n.conversionConfig[e];\n  return O(t) || Q(t);\n}\nfunction Le(n, e) {\n  return Ft(n.tool, e);\n}\nfunction Ht(n, e) {\n  return Object.entries(n).some(([t, o]) => e[t] && Oo(e[t], o));\n}\nasync function zt(n, e) {\n  const o = (await n.save()).data;\n  return e.reduce((i, s) => {\n    if (!Ft(s, \"import\"))\n      return i;\n    const r = s.toolbox.filter((l) => {\n      if (X(l) || !l.icon)\n        return !1;\n      if (l.data !== void 0) {\n        if (Ht(l.data, o))\n          return !1;\n      } else if (s.name === n.name)\n        return !1;\n      return !0;\n    });\n    return i.push({\n      ...s,\n      toolbox: r\n    }), i;\n  }, []);\n}\nfunction vt(n, e) {\n  return n.mergeable ? n.name === e.name ? !0 : Le(e, \"export\") && Le(n, \"import\") : !1;\n}\nfunction Ho(n, e) {\n  const t = e == null ? void 0 : e.export;\n  return O(t) ? t(n) : Q(t) ? n[t] : (t !== void 0 && I(\"Conversion export property must be a string or function. String means key of saved data object to export. Function should export processed string to export.\"), \"\");\n}\nfunction wt(n, e) {\n  const t = e == null ? void 0 : e.import;\n  return O(t) ? t(n) : Q(t) ? {\n    [t]: n\n  } : (t !== void 0 && I(\"Conversion import property must be a string or function. String means key of tool data to import. Function accepts a imported string and return composed tool data.\"), {});\n}\nconst Ut = class ke {\n  /**\n   * @param {HTMLElement[]} nodeList  the list of iterable HTML-items\n   * @param {string} focusedCssClass - user-provided CSS-class that will be set in flipping process\n   */\n  constructor(e, t) {\n    this.cursor = -1, this.items = [], this.items = e || [], this.focusedCssClass = t;\n  }\n  /**\n   * Returns Focused button Node\n   *\n   * @returns {HTMLElement}\n   */\n  get currentItem() {\n    return this.cursor === -1 ? null : this.items[this.cursor];\n  }\n  /**\n   * Sets cursor to specified position\n   *\n   * @param cursorPosition - new cursor position\n   */\n  setCursor(e) {\n    e < this.items.length && e >= -1 && (this.dropCursor(), this.cursor = e, this.items[this.cursor].classList.add(this.focusedCssClass));\n  }\n  /**\n   * Sets items. Can be used when iterable items changed dynamically\n   *\n   * @param {HTMLElement[]} nodeList - nodes to iterate\n   */\n  setItems(e) {\n    this.items = e;\n  }\n  /**\n   * Sets cursor next to the current\n   */\n  next() {\n    this.cursor = this.leafNodesAndReturnIndex(ke.directions.RIGHT);\n  }\n  /**\n   * Sets cursor before current\n   */\n  previous() {\n    this.cursor = this.leafNodesAndReturnIndex(ke.directions.LEFT);\n  }\n  /**\n   * Sets cursor to the default position and removes CSS-class from previously focused item\n   */\n  dropCursor() {\n    this.cursor !== -1 && (this.items[this.cursor].classList.remove(this.focusedCssClass), this.cursor = -1);\n  }\n  /**\n   * Leafs nodes inside the target list from active element\n   *\n   * @param {string} direction - leaf direction. Can be 'left' or 'right'\n   * @returns {number} index of focused node\n   */\n  leafNodesAndReturnIndex(e) {\n    if (this.items.length === 0)\n      return this.cursor;\n    let t = this.cursor;\n    return t === -1 ? t = e === ke.directions.RIGHT ? -1 : 0 : this.items[t].classList.remove(this.focusedCssClass), e === ke.directions.RIGHT ? t = (t + 1) % this.items.length : t = (this.items.length + t - 1) % this.items.length, d.canSetCaret(this.items[t]) && Ae(() => b.setCursor(this.items[t]), 50)(), this.items[t].classList.add(this.focusedCssClass), t;\n  }\n};\nUt.directions = {\n  RIGHT: \"right\",\n  LEFT: \"left\"\n};\nlet ge = Ut;\nclass re {\n  /**\n   * @param options - different constructing settings\n   */\n  constructor(e) {\n    this.iterator = null, this.activated = !1, this.flipCallbacks = [], this.onKeyDown = (t) => {\n      if (this.isEventReadyForHandling(t))\n        switch (re.usedKeys.includes(t.keyCode) && t.preventDefault(), t.keyCode) {\n          case w.TAB:\n            this.handleTabPress(t);\n            break;\n          case w.LEFT:\n          case w.UP:\n            this.flipLeft();\n            break;\n          case w.RIGHT:\n          case w.DOWN:\n            this.flipRight();\n            break;\n          case w.ENTER:\n            this.handleEnterPress(t);\n            break;\n        }\n    }, this.iterator = new ge(e.items, e.focusedItemClass), this.activateCallback = e.activateCallback, this.allowedKeys = e.allowedKeys || re.usedKeys;\n  }\n  /**\n   * True if flipper is currently activated\n   */\n  get isActivated() {\n    return this.activated;\n  }\n  /**\n   * Array of keys (codes) that is handled by Flipper\n   * Used to:\n   *  - preventDefault only for this keys, not all keydowns (@see constructor)\n   *  - to skip external behaviours only for these keys, when filler is activated (@see BlockEvents@arrowRightAndDown)\n   */\n  static get usedKeys() {\n    return [\n      w.TAB,\n      w.LEFT,\n      w.RIGHT,\n      w.ENTER,\n      w.UP,\n      w.DOWN\n    ];\n  }\n  /**\n   * Active tab/arrows handling by flipper\n   *\n   * @param items - Some modules (like, InlineToolbar, BlockSettings) might refresh buttons dynamically\n   * @param cursorPosition - index of the item that should be focused once flipper is activated\n   */\n  activate(e, t) {\n    this.activated = !0, e && this.iterator.setItems(e), t !== void 0 && this.iterator.setCursor(t), document.addEventListener(\"keydown\", this.onKeyDown, !0);\n  }\n  /**\n   * Disable tab/arrows handling by flipper\n   */\n  deactivate() {\n    this.activated = !1, this.dropCursor(), document.removeEventListener(\"keydown\", this.onKeyDown);\n  }\n  /**\n   * Focus first item\n   */\n  focusFirst() {\n    this.dropCursor(), this.flipRight();\n  }\n  /**\n   * Focuses previous flipper iterator item\n   */\n  flipLeft() {\n    this.iterator.previous(), this.flipCallback();\n  }\n  /**\n   * Focuses next flipper iterator item\n   */\n  flipRight() {\n    this.iterator.next(), this.flipCallback();\n  }\n  /**\n   * Return true if some button is focused\n   */\n  hasFocus() {\n    return !!this.iterator.currentItem;\n  }\n  /**\n   * Registeres function that should be executed on each navigation action\n   *\n   * @param cb - function to execute\n   */\n  onFlip(e) {\n    this.flipCallbacks.push(e);\n  }\n  /**\n   * Unregisteres function that is executed on each navigation action\n   *\n   * @param cb - function to stop executing\n   */\n  removeOnFlip(e) {\n    this.flipCallbacks = this.flipCallbacks.filter((t) => t !== e);\n  }\n  /**\n   * Drops flipper's iterator cursor\n   *\n   * @see DomIterator#dropCursor\n   */\n  dropCursor() {\n    this.iterator.dropCursor();\n  }\n  /**\n   * This function is fired before handling flipper keycodes\n   * The result of this function defines if it is need to be handled or not\n   *\n   * @param {KeyboardEvent} event - keydown keyboard event\n   * @returns {boolean}\n   */\n  isEventReadyForHandling(e) {\n    return this.activated && this.allowedKeys.includes(e.keyCode);\n  }\n  /**\n   * When flipper is activated tab press will leaf the items\n   *\n   * @param {KeyboardEvent} event - tab keydown event\n   */\n  handleTabPress(e) {\n    switch (e.shiftKey ? ge.directions.LEFT : ge.directions.RIGHT) {\n      case ge.directions.RIGHT:\n        this.flipRight();\n        break;\n      case ge.directions.LEFT:\n        this.flipLeft();\n        break;\n    }\n  }\n  /**\n   * Enter press will click current item if flipper is activated\n   *\n   * @param {KeyboardEvent} event - enter keydown event\n   */\n  handleEnterPress(e) {\n    this.activated && (this.iterator.currentItem && (e.stopPropagation(), e.preventDefault(), this.iterator.currentItem.click()), O(this.activateCallback) && this.activateCallback(this.iterator.currentItem));\n  }\n  /**\n   * Fired after flipping in any direction\n   */\n  flipCallback() {\n    this.iterator.currentItem && this.iterator.currentItem.scrollIntoViewIfNeeded(), this.flipCallbacks.forEach((e) => e());\n  }\n}\nconst zo = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M9 12L9 7.1C9 7.04477 9.04477 7 9.1 7H10.4C11.5 7 14 7.1 14 9.5C14 9.5 14 12 11 12M9 12V16.8C9 16.9105 9.08954 17 9.2 17H12.5C14 17 15 16 15 14.5C15 11.7046 11 12 11 12M9 12H11\"/></svg>', Uo = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M7 10L11.8586 14.8586C11.9367 14.9367 12.0633 14.9367 12.1414 14.8586L17 10\"/></svg>', jo = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M14.5 17.5L9.64142 12.6414C9.56331 12.5633 9.56331 12.4367 9.64142 12.3586L14.5 7.5\"/></svg>', $o = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M9.58284 17.5L14.4414 12.6414C14.5195 12.5633 14.5195 12.4367 14.4414 12.3586L9.58284 7.5\"/></svg>', Yo = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M7 15L11.8586 10.1414C11.9367 10.0633 12.0633 10.0633 12.1414 10.1414L17 15\"/></svg>', Wo = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M8 8L12 12M12 12L16 16M12 12L16 8M12 12L8 16\"/></svg>', Ko = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><circle cx=\"12\" cy=\"12\" r=\"4\" stroke=\"currentColor\" stroke-width=\"2\"/></svg>', Xo = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M13.34 10C12.4223 12.7337 11 17 11 17\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M14.21 7H14.2\"/></svg>', xt = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M7.69998 12.6L7.67896 12.62C6.53993 13.7048 6.52012 15.5155 7.63516 16.625V16.625C8.72293 17.7073 10.4799 17.7102 11.5712 16.6314L13.0263 15.193C14.0703 14.1609 14.2141 12.525 13.3662 11.3266L13.22 11.12\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M16.22 11.12L16.3564 10.9805C17.2895 10.0265 17.3478 8.5207 16.4914 7.49733V7.49733C15.5691 6.39509 13.9269 6.25143 12.8271 7.17675L11.3901 8.38588C10.0935 9.47674 9.95706 11.4241 11.0888 12.6852L11.12 12.72\"/></svg>', Vo = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2.6\" d=\"M9.40999 7.29999H9.4\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2.6\" d=\"M14.6 7.29999H14.59\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2.6\" d=\"M9.30999 12H9.3\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2.6\" d=\"M14.6 12H14.59\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2.6\" d=\"M9.40999 16.7H9.4\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2.6\" d=\"M14.6 16.7H14.59\"/></svg>', qo = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M12 7V12M12 17V12M17 12H12M12 12H7\"/></svg>', jt = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M11.5 17.5L5 11M5 11V15.5M5 11H9.5\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M12.5 6.5L19 13M19 13V8.5M19 13H14.5\"/></svg>', Zo = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><circle cx=\"10.5\" cy=\"10.5\" r=\"5.5\" stroke=\"currentColor\" stroke-width=\"2\"/><line x1=\"15.4142\" x2=\"19\" y1=\"15\" y2=\"18.5858\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\"/></svg>', Go = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M15.7795 11.5C15.7795 11.5 16.053 11.1962 16.5497 10.6722C17.4442 9.72856 17.4701 8.2475 16.5781 7.30145V7.30145C15.6482 6.31522 14.0873 6.29227 13.1288 7.25073L11.8796 8.49999\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M8.24517 12.3883C8.24517 12.3883 7.97171 12.6922 7.47504 13.2161C6.58051 14.1598 6.55467 15.6408 7.44666 16.5869V16.5869C8.37653 17.5731 9.93744 17.5961 10.8959 16.6376L12.1452 15.3883\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M17.7802 15.1032L16.597 14.9422C16.0109 14.8624 15.4841 15.3059 15.4627 15.8969L15.4199 17.0818\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M6.39064 9.03238L7.58432 9.06668C8.17551 9.08366 8.6522 8.58665 8.61056 7.99669L8.5271 6.81397\"/><line x1=\"12.1142\" x2=\"11.7\" y1=\"12.2\" y2=\"11.7858\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\"/></svg>', Jo = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><rect width=\"14\" height=\"14\" x=\"5\" y=\"5\" stroke=\"currentColor\" stroke-width=\"2\" rx=\"4\"/><line x1=\"12\" x2=\"12\" y1=\"9\" y2=\"12\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M12 15.02V15.01\"/></svg>';\nvar $t = { exports: {} };\n/*!\n * CodeX.Tooltips\n * \n * @version 1.0.5\n * \n * @licence MIT\n * @author CodeX <https://codex.so>\n * \n * \n */\n(function(n, e) {\n  (function(t, o) {\n    n.exports = o();\n  })(window, function() {\n    return function(t) {\n      var o = {};\n      function i(s) {\n        if (o[s])\n          return o[s].exports;\n        var r = o[s] = { i: s, l: !1, exports: {} };\n        return t[s].call(r.exports, r, r.exports, i), r.l = !0, r.exports;\n      }\n      return i.m = t, i.c = o, i.d = function(s, r, l) {\n        i.o(s, r) || Object.defineProperty(s, r, { enumerable: !0, get: l });\n      }, i.r = function(s) {\n        typeof Symbol < \"u\" && Symbol.toStringTag && Object.defineProperty(s, Symbol.toStringTag, { value: \"Module\" }), Object.defineProperty(s, \"__esModule\", { value: !0 });\n      }, i.t = function(s, r) {\n        if (1 & r && (s = i(s)), 8 & r || 4 & r && typeof s == \"object\" && s && s.__esModule)\n          return s;\n        var l = /* @__PURE__ */ Object.create(null);\n        if (i.r(l), Object.defineProperty(l, \"default\", { enumerable: !0, value: s }), 2 & r && typeof s != \"string\")\n          for (var a in s)\n            i.d(l, a, (function(c) {\n              return s[c];\n            }).bind(null, a));\n        return l;\n      }, i.n = function(s) {\n        var r = s && s.__esModule ? function() {\n          return s.default;\n        } : function() {\n          return s;\n        };\n        return i.d(r, \"a\", r), r;\n      }, i.o = function(s, r) {\n        return Object.prototype.hasOwnProperty.call(s, r);\n      }, i.p = \"\", i(i.s = 0);\n    }([function(t, o, i) {\n      t.exports = i(1);\n    }, function(t, o, i) {\n      i.r(o), i.d(o, \"default\", function() {\n        return s;\n      });\n      class s {\n        constructor() {\n          this.nodes = { wrapper: null, content: null }, this.showed = !1, this.offsetTop = 10, this.offsetLeft = 10, this.offsetRight = 10, this.hidingDelay = 0, this.handleWindowScroll = () => {\n            this.showed && this.hide(!0);\n          }, this.loadStyles(), this.prepare(), window.addEventListener(\"scroll\", this.handleWindowScroll, { passive: !0 });\n        }\n        get CSS() {\n          return { tooltip: \"ct\", tooltipContent: \"ct__content\", tooltipShown: \"ct--shown\", placement: { left: \"ct--left\", bottom: \"ct--bottom\", right: \"ct--right\", top: \"ct--top\" } };\n        }\n        show(l, a, c) {\n          this.nodes.wrapper || this.prepare(), this.hidingTimeout && clearTimeout(this.hidingTimeout);\n          const u = Object.assign({ placement: \"bottom\", marginTop: 0, marginLeft: 0, marginRight: 0, marginBottom: 0, delay: 70, hidingDelay: 0 }, c);\n          if (u.hidingDelay && (this.hidingDelay = u.hidingDelay), this.nodes.content.innerHTML = \"\", typeof a == \"string\")\n            this.nodes.content.appendChild(document.createTextNode(a));\n          else {\n            if (!(a instanceof Node))\n              throw Error(\"[CodeX Tooltip] Wrong type of content passed. It should be an instance of Node or String. But \" + typeof a + \" given.\");\n            this.nodes.content.appendChild(a);\n          }\n          switch (this.nodes.wrapper.classList.remove(...Object.values(this.CSS.placement)), u.placement) {\n            case \"top\":\n              this.placeTop(l, u);\n              break;\n            case \"left\":\n              this.placeLeft(l, u);\n              break;\n            case \"right\":\n              this.placeRight(l, u);\n              break;\n            case \"bottom\":\n            default:\n              this.placeBottom(l, u);\n          }\n          u && u.delay ? this.showingTimeout = setTimeout(() => {\n            this.nodes.wrapper.classList.add(this.CSS.tooltipShown), this.showed = !0;\n          }, u.delay) : (this.nodes.wrapper.classList.add(this.CSS.tooltipShown), this.showed = !0);\n        }\n        hide(l = !1) {\n          if (this.hidingDelay && !l)\n            return this.hidingTimeout && clearTimeout(this.hidingTimeout), void (this.hidingTimeout = setTimeout(() => {\n              this.hide(!0);\n            }, this.hidingDelay));\n          this.nodes.wrapper.classList.remove(this.CSS.tooltipShown), this.showed = !1, this.showingTimeout && clearTimeout(this.showingTimeout);\n        }\n        onHover(l, a, c) {\n          l.addEventListener(\"mouseenter\", () => {\n            this.show(l, a, c);\n          }), l.addEventListener(\"mouseleave\", () => {\n            this.hide();\n          });\n        }\n        destroy() {\n          this.nodes.wrapper.remove(), window.removeEventListener(\"scroll\", this.handleWindowScroll);\n        }\n        prepare() {\n          this.nodes.wrapper = this.make(\"div\", this.CSS.tooltip), this.nodes.content = this.make(\"div\", this.CSS.tooltipContent), this.append(this.nodes.wrapper, this.nodes.content), this.append(document.body, this.nodes.wrapper);\n        }\n        loadStyles() {\n          const l = \"codex-tooltips-style\";\n          if (document.getElementById(l))\n            return;\n          const a = i(2), c = this.make(\"style\", null, { textContent: a.toString(), id: l });\n          this.prepend(document.head, c);\n        }\n        placeBottom(l, a) {\n          const c = l.getBoundingClientRect(), u = c.left + l.clientWidth / 2 - this.nodes.wrapper.offsetWidth / 2, h = c.bottom + window.pageYOffset + this.offsetTop + a.marginTop;\n          this.applyPlacement(\"bottom\", u, h);\n        }\n        placeTop(l, a) {\n          const c = l.getBoundingClientRect(), u = c.left + l.clientWidth / 2 - this.nodes.wrapper.offsetWidth / 2, h = c.top + window.pageYOffset - this.nodes.wrapper.clientHeight - this.offsetTop;\n          this.applyPlacement(\"top\", u, h);\n        }\n        placeLeft(l, a) {\n          const c = l.getBoundingClientRect(), u = c.left - this.nodes.wrapper.offsetWidth - this.offsetLeft - a.marginLeft, h = c.top + window.pageYOffset + l.clientHeight / 2 - this.nodes.wrapper.offsetHeight / 2;\n          this.applyPlacement(\"left\", u, h);\n        }\n        placeRight(l, a) {\n          const c = l.getBoundingClientRect(), u = c.right + this.offsetRight + a.marginRight, h = c.top + window.pageYOffset + l.clientHeight / 2 - this.nodes.wrapper.offsetHeight / 2;\n          this.applyPlacement(\"right\", u, h);\n        }\n        applyPlacement(l, a, c) {\n          this.nodes.wrapper.classList.add(this.CSS.placement[l]), this.nodes.wrapper.style.left = a + \"px\", this.nodes.wrapper.style.top = c + \"px\";\n        }\n        make(l, a = null, c = {}) {\n          const u = document.createElement(l);\n          Array.isArray(a) ? u.classList.add(...a) : a && u.classList.add(a);\n          for (const h in c)\n            c.hasOwnProperty(h) && (u[h] = c[h]);\n          return u;\n        }\n        append(l, a) {\n          Array.isArray(a) ? a.forEach((c) => l.appendChild(c)) : l.appendChild(a);\n        }\n        prepend(l, a) {\n          Array.isArray(a) ? (a = a.reverse()).forEach((c) => l.prepend(c)) : l.prepend(a);\n        }\n      }\n    }, function(t, o) {\n      t.exports = `.ct{z-index:999;opacity:0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;pointer-events:none;-webkit-transition:opacity 50ms ease-in,-webkit-transform 70ms cubic-bezier(.215,.61,.355,1);transition:opacity 50ms ease-in,-webkit-transform 70ms cubic-bezier(.215,.61,.355,1);transition:opacity 50ms ease-in,transform 70ms cubic-bezier(.215,.61,.355,1);transition:opacity 50ms ease-in,transform 70ms cubic-bezier(.215,.61,.355,1),-webkit-transform 70ms cubic-bezier(.215,.61,.355,1);will-change:opacity,top,left;-webkit-box-shadow:0 8px 12px 0 rgba(29,32,43,.17),0 4px 5px -3px rgba(5,6,12,.49);box-shadow:0 8px 12px 0 rgba(29,32,43,.17),0 4px 5px -3px rgba(5,6,12,.49);border-radius:9px}.ct,.ct:before{position:absolute;top:0;left:0}.ct:before{content:\"\";bottom:0;right:0;background-color:#1d202b;z-index:-1;border-radius:4px}@supports(-webkit-mask-box-image:url(\"\")){.ct:before{border-radius:0;-webkit-mask-box-image:url('data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\"><path d=\"M10.71 0h2.58c3.02 0 4.64.42 6.1 1.2a8.18 8.18 0 013.4 3.4C23.6 6.07 24 7.7 24 10.71v2.58c0 3.02-.42 4.64-1.2 6.1a8.18 8.18 0 01-3.4 3.4c-1.47.8-3.1 1.21-6.11 1.21H10.7c-3.02 0-4.64-.42-6.1-1.2a8.18 8.18 0 01-3.4-3.4C.4 17.93 0 16.3 0 13.29V10.7c0-3.02.42-4.64 1.2-6.1a8.18 8.18 0 013.4-3.4C6.07.4 7.7 0 10.71 0z\"/></svg>') 48% 41% 37.9% 53.3%}}@media (--mobile){.ct{display:none}}.ct__content{padding:6px 10px;color:#cdd1e0;font-size:12px;text-align:center;letter-spacing:.02em;line-height:1em}.ct:after{content:\"\";width:8px;height:8px;position:absolute;background-color:#1d202b;z-index:-1}.ct--bottom{-webkit-transform:translateY(5px);transform:translateY(5px)}.ct--bottom:after{top:-3px;left:50%;-webkit-transform:translateX(-50%) rotate(-45deg);transform:translateX(-50%) rotate(-45deg)}.ct--top{-webkit-transform:translateY(-5px);transform:translateY(-5px)}.ct--top:after{top:auto;bottom:-3px;left:50%;-webkit-transform:translateX(-50%) rotate(-45deg);transform:translateX(-50%) rotate(-45deg)}.ct--left{-webkit-transform:translateX(-5px);transform:translateX(-5px)}.ct--left:after{top:50%;left:auto;right:0;-webkit-transform:translate(41.6%,-50%) rotate(-45deg);transform:translate(41.6%,-50%) rotate(-45deg)}.ct--right{-webkit-transform:translateX(5px);transform:translateX(5px)}.ct--right:after{top:50%;left:0;-webkit-transform:translate(-41.6%,-50%) rotate(-45deg);transform:translate(-41.6%,-50%) rotate(-45deg)}.ct--shown{opacity:1;-webkit-transform:none;transform:none}`;\n    }]).default;\n  });\n})($t);\nvar Qo = $t.exports;\nconst ei = /* @__PURE__ */ Re(Qo);\nlet z = null;\nfunction tt() {\n  z || (z = new ei());\n}\nfunction ti(n, e, t) {\n  tt(), z == null || z.show(n, e, t);\n}\nfunction _e(n = !1) {\n  tt(), z == null || z.hide(n);\n}\nfunction Ne(n, e, t) {\n  tt(), z == null || z.onHover(n, e, t);\n}\nfunction oi() {\n  z == null || z.destroy(), z = null;\n}\nconst ii = \"__\", si = \"--\";\nfunction te(n) {\n  return (e, t) => [[n, e].filter((i) => !!i).join(ii), t].filter((i) => !!i).join(si);\n}\nconst me = te(\"ce-hint\"), be = {\n  root: me(),\n  alignedStart: me(null, \"align-left\"),\n  alignedCenter: me(null, \"align-center\"),\n  title: me(\"title\"),\n  description: me(\"description\")\n};\nclass ni {\n  /**\n   * Constructs the hint content instance\n   *\n   * @param params - hint content parameters\n   */\n  constructor(e) {\n    this.nodes = {\n      root: d.make(\"div\", [be.root, e.alignment === \"center\" ? be.alignedCenter : be.alignedStart]),\n      title: d.make(\"div\", be.title, { textContent: e.title })\n    }, this.nodes.root.appendChild(this.nodes.title), e.description !== void 0 && (this.nodes.description = d.make(\"div\", be.description, { textContent: e.description }), this.nodes.root.appendChild(this.nodes.description));\n  }\n  /**\n   * Returns the root element of the hint content\n   */\n  getElement() {\n    return this.nodes.root;\n  }\n}\nclass ot {\n  /**\n   * Constructs the instance\n   *\n   * @param params - instance parameters\n   */\n  constructor(e) {\n    this.params = e;\n  }\n  /**\n   * Item name if exists\n   */\n  get name() {\n    if (this.params !== void 0 && \"name\" in this.params)\n      return this.params.name;\n  }\n  /**\n   * Destroys the instance\n   */\n  destroy() {\n    _e();\n  }\n  /**\n   * Called when children popover is opened (if exists)\n   */\n  onChildrenOpen() {\n    var e;\n    this.params !== void 0 && \"children\" in this.params && typeof ((e = this.params.children) == null ? void 0 : e.onOpen) == \"function\" && this.params.children.onOpen();\n  }\n  /**\n   * Called when children popover is closed (if exists)\n   */\n  onChildrenClose() {\n    var e;\n    this.params !== void 0 && \"children\" in this.params && typeof ((e = this.params.children) == null ? void 0 : e.onClose) == \"function\" && this.params.children.onClose();\n  }\n  /**\n   * Called on popover item click\n   */\n  handleClick() {\n    var e, t;\n    this.params !== void 0 && \"onActivate\" in this.params && ((t = (e = this.params).onActivate) == null || t.call(e, this.params));\n  }\n  /**\n   * Adds hint to the item element if hint data is provided\n   *\n   * @param itemElement - popover item root element to add hint to\n   * @param hintData - hint data\n   */\n  addHint(e, t) {\n    const o = new ni(t);\n    Ne(e, o.getElement(), {\n      placement: t.position,\n      hidingDelay: 100\n    });\n  }\n  /**\n   * Returns item children that are represented as popover items\n   */\n  get children() {\n    var e;\n    return this.params !== void 0 && \"children\" in this.params && ((e = this.params.children) == null ? void 0 : e.items) !== void 0 ? this.params.children.items : [];\n  }\n  /**\n   * Returns true if item has any type of children\n   */\n  get hasChildren() {\n    return this.children.length > 0;\n  }\n  /**\n   * Returns true if item children should be open instantly after popover is opened and not on item click/hover\n   */\n  get isChildrenOpen() {\n    var e;\n    return this.params !== void 0 && \"children\" in this.params && ((e = this.params.children) == null ? void 0 : e.isOpen) === !0;\n  }\n  /**\n   * True if item children items should be navigatable via keyboard\n   */\n  get isChildrenFlippable() {\n    var e;\n    return !(this.params === void 0 || !(\"children\" in this.params) || ((e = this.params.children) == null ? void 0 : e.isFlippable) === !1);\n  }\n  /**\n   * Returns true if item has children that should be searchable\n   */\n  get isChildrenSearchable() {\n    var e;\n    return this.params !== void 0 && \"children\" in this.params && ((e = this.params.children) == null ? void 0 : e.searchable) === !0;\n  }\n  /**\n   * True if popover should close once item is activated\n   */\n  get closeOnActivate() {\n    return this.params !== void 0 && \"closeOnActivate\" in this.params && this.params.closeOnActivate;\n  }\n  /**\n   * True if item is active\n   */\n  get isActive() {\n    return this.params === void 0 || !(\"isActive\" in this.params) ? !1 : typeof this.params.isActive == \"function\" ? this.params.isActive() : this.params.isActive === !0;\n  }\n}\nconst Y = te(\"ce-popover-item\"), L = {\n  container: Y(),\n  active: Y(null, \"active\"),\n  disabled: Y(null, \"disabled\"),\n  focused: Y(null, \"focused\"),\n  hidden: Y(null, \"hidden\"),\n  confirmationState: Y(null, \"confirmation\"),\n  noHover: Y(null, \"no-hover\"),\n  noFocus: Y(null, \"no-focus\"),\n  title: Y(\"title\"),\n  secondaryTitle: Y(\"secondary-title\"),\n  icon: Y(\"icon\"),\n  iconTool: Y(\"icon\", \"tool\"),\n  iconChevronRight: Y(\"icon\", \"chevron-right\"),\n  wobbleAnimation: te(\"wobble\")()\n};\nclass se extends ot {\n  /**\n   * Constructs popover item instance\n   *\n   * @param params - popover item construction params\n   * @param renderParams - popover item render params.\n   * The parameters that are not set by user via popover api but rather depend on technical implementation\n   */\n  constructor(e, t) {\n    super(e), this.params = e, this.nodes = {\n      root: null,\n      icon: null\n    }, this.confirmationState = null, this.removeSpecialFocusBehavior = () => {\n      var o;\n      (o = this.nodes.root) == null || o.classList.remove(L.noFocus);\n    }, this.removeSpecialHoverBehavior = () => {\n      var o;\n      (o = this.nodes.root) == null || o.classList.remove(L.noHover);\n    }, this.onErrorAnimationEnd = () => {\n      var o, i;\n      (o = this.nodes.icon) == null || o.classList.remove(L.wobbleAnimation), (i = this.nodes.icon) == null || i.removeEventListener(\"animationend\", this.onErrorAnimationEnd);\n    }, this.nodes.root = this.make(e, t);\n  }\n  /**\n   * True if item is disabled and hence not clickable\n   */\n  get isDisabled() {\n    return this.params.isDisabled === !0;\n  }\n  /**\n   * Exposes popover item toggle parameter\n   */\n  get toggle() {\n    return this.params.toggle;\n  }\n  /**\n   * Item title\n   */\n  get title() {\n    return this.params.title;\n  }\n  /**\n   * True if confirmation state is enabled for popover item\n   */\n  get isConfirmationStateEnabled() {\n    return this.confirmationState !== null;\n  }\n  /**\n   * True if item is focused in keyboard navigation process\n   */\n  get isFocused() {\n    return this.nodes.root === null ? !1 : this.nodes.root.classList.contains(L.focused);\n  }\n  /**\n   * Returns popover item root element\n   */\n  getElement() {\n    return this.nodes.root;\n  }\n  /**\n   * Called on popover item click\n   */\n  handleClick() {\n    if (this.isConfirmationStateEnabled && this.confirmationState !== null) {\n      this.activateOrEnableConfirmationMode(this.confirmationState);\n      return;\n    }\n    this.activateOrEnableConfirmationMode(this.params);\n  }\n  /**\n   * Toggles item active state\n   *\n   * @param isActive - true if item should strictly should become active\n   */\n  toggleActive(e) {\n    var t;\n    (t = this.nodes.root) == null || t.classList.toggle(L.active, e);\n  }\n  /**\n   * Toggles item hidden state\n   *\n   * @param isHidden - true if item should be hidden\n   */\n  toggleHidden(e) {\n    var t;\n    (t = this.nodes.root) == null || t.classList.toggle(L.hidden, e);\n  }\n  /**\n   * Resets popover item to its original state\n   */\n  reset() {\n    this.isConfirmationStateEnabled && this.disableConfirmationMode();\n  }\n  /**\n   * Method called once item becomes focused during keyboard navigation\n   */\n  onFocus() {\n    this.disableSpecialHoverAndFocusBehavior();\n  }\n  /**\n   * Constructs HTML element corresponding to popover item params\n   *\n   * @param params - item construction params\n   * @param renderParams - popover item render params\n   */\n  make(e, t) {\n    var s, r;\n    const o = (t == null ? void 0 : t.wrapperTag) || \"div\", i = d.make(o, L.container);\n    return e.name && (i.dataset.itemName = e.name), this.nodes.icon = d.make(\"div\", [L.icon, L.iconTool], {\n      innerHTML: e.icon || Ko\n    }), i.appendChild(this.nodes.icon), e.title !== void 0 && i.appendChild(d.make(\"div\", L.title, {\n      innerHTML: e.title || \"\"\n    })), e.secondaryLabel && i.appendChild(d.make(\"div\", L.secondaryTitle, {\n      textContent: e.secondaryLabel\n    })), this.hasChildren && i.appendChild(d.make(\"div\", [L.icon, L.iconChevronRight], {\n      innerHTML: $o\n    })), this.isActive && i.classList.add(L.active), e.isDisabled && i.classList.add(L.disabled), e.hint !== void 0 && ((s = t == null ? void 0 : t.hint) == null ? void 0 : s.enabled) !== !1 && this.addHint(i, {\n      ...e.hint,\n      position: ((r = t == null ? void 0 : t.hint) == null ? void 0 : r.position) || \"right\"\n    }), i;\n  }\n  /**\n   * Activates confirmation mode for the item.\n   *\n   * @param newState - new popover item params that should be applied\n   */\n  enableConfirmationMode(e) {\n    if (this.nodes.root === null)\n      return;\n    const t = {\n      ...this.params,\n      ...e,\n      confirmation: \"confirmation\" in e ? e.confirmation : void 0\n    }, o = this.make(t);\n    this.nodes.root.innerHTML = o.innerHTML, this.nodes.root.classList.add(L.confirmationState), this.confirmationState = e, this.enableSpecialHoverAndFocusBehavior();\n  }\n  /**\n   * Returns item to its original state\n   */\n  disableConfirmationMode() {\n    if (this.nodes.root === null)\n      return;\n    const e = this.make(this.params);\n    this.nodes.root.innerHTML = e.innerHTML, this.nodes.root.classList.remove(L.confirmationState), this.confirmationState = null, this.disableSpecialHoverAndFocusBehavior();\n  }\n  /**\n   * Enables special focus and hover behavior for item in confirmation state.\n   * This is needed to prevent item from being highlighted as hovered/focused just after click.\n   */\n  enableSpecialHoverAndFocusBehavior() {\n    var e, t, o;\n    (e = this.nodes.root) == null || e.classList.add(L.noHover), (t = this.nodes.root) == null || t.classList.add(L.noFocus), (o = this.nodes.root) == null || o.addEventListener(\"mouseleave\", this.removeSpecialHoverBehavior, { once: !0 });\n  }\n  /**\n   * Disables special focus and hover behavior\n   */\n  disableSpecialHoverAndFocusBehavior() {\n    var e;\n    this.removeSpecialFocusBehavior(), this.removeSpecialHoverBehavior(), (e = this.nodes.root) == null || e.removeEventListener(\"mouseleave\", this.removeSpecialHoverBehavior);\n  }\n  /**\n   * Executes item's onActivate callback if the item has no confirmation configured\n   *\n   * @param item - item to activate or bring to confirmation mode\n   */\n  activateOrEnableConfirmationMode(e) {\n    var t;\n    if (!(\"confirmation\" in e) || e.confirmation === void 0)\n      try {\n        (t = e.onActivate) == null || t.call(e, e), this.disableConfirmationMode();\n      } catch {\n        this.animateError();\n      }\n    else\n      this.enableConfirmationMode(e.confirmation);\n  }\n  /**\n   * Animates item which symbolizes that error occured while executing 'onActivate()' callback\n   */\n  animateError() {\n    var e, t, o;\n    (e = this.nodes.icon) != null && e.classList.contains(L.wobbleAnimation) || ((t = this.nodes.icon) == null || t.classList.add(L.wobbleAnimation), (o = this.nodes.icon) == null || o.addEventListener(\"animationend\", this.onErrorAnimationEnd));\n  }\n}\nconst Ue = te(\"ce-popover-item-separator\"), je = {\n  container: Ue(),\n  line: Ue(\"line\"),\n  hidden: Ue(null, \"hidden\")\n};\nclass Yt extends ot {\n  /**\n   * Constructs the instance\n   */\n  constructor() {\n    super(), this.nodes = {\n      root: d.make(\"div\", je.container),\n      line: d.make(\"div\", je.line)\n    }, this.nodes.root.appendChild(this.nodes.line);\n  }\n  /**\n   * Returns popover separator root element\n   */\n  getElement() {\n    return this.nodes.root;\n  }\n  /**\n   * Toggles item hidden state\n   *\n   * @param isHidden - true if item should be hidden\n   */\n  toggleHidden(e) {\n    var t;\n    (t = this.nodes.root) == null || t.classList.toggle(je.hidden, e);\n  }\n}\nvar A = /* @__PURE__ */ ((n) => (n.Default = \"default\", n.Separator = \"separator\", n.Html = \"html\", n))(A || {}), Z = /* @__PURE__ */ ((n) => (n.Closed = \"closed\", n.ClosedOnActivate = \"closed-on-activate\", n))(Z || {});\nconst H = te(\"ce-popover\"), N = {\n  popover: H(),\n  popoverContainer: H(\"container\"),\n  popoverOpenTop: H(null, \"open-top\"),\n  popoverOpenLeft: H(null, \"open-left\"),\n  popoverOpened: H(null, \"opened\"),\n  search: H(\"search\"),\n  nothingFoundMessage: H(\"nothing-found-message\"),\n  nothingFoundMessageDisplayed: H(\"nothing-found-message\", \"displayed\"),\n  items: H(\"items\"),\n  overlay: H(\"overlay\"),\n  overlayHidden: H(\"overlay\", \"hidden\"),\n  popoverNested: H(null, \"nested\"),\n  getPopoverNestedClass: (n) => H(null, `nested-level-${n.toString()}`),\n  popoverInline: H(null, \"inline\"),\n  popoverHeader: H(\"header\")\n};\nvar ce = /* @__PURE__ */ ((n) => (n.NestingLevel = \"--nesting-level\", n.PopoverHeight = \"--popover-height\", n.InlinePopoverWidth = \"--inline-popover-width\", n.TriggerItemLeft = \"--trigger-item-left\", n.TriggerItemTop = \"--trigger-item-top\", n))(ce || {});\nconst yt = te(\"ce-popover-item-html\"), Et = {\n  root: yt(),\n  hidden: yt(null, \"hidden\")\n};\nclass ye extends ot {\n  /**\n   * Constructs the instance\n   *\n   * @param params  instance parameters\n   * @param renderParams  popover item render params.\n   * The parameters that are not set by user via popover api but rather depend on technical implementation\n   */\n  constructor(e, t) {\n    var o, i;\n    super(e), this.nodes = {\n      root: d.make(\"div\", Et.root)\n    }, this.nodes.root.appendChild(e.element), e.name && (this.nodes.root.dataset.itemName = e.name), e.hint !== void 0 && ((o = t == null ? void 0 : t.hint) == null ? void 0 : o.enabled) !== !1 && this.addHint(this.nodes.root, {\n      ...e.hint,\n      position: ((i = t == null ? void 0 : t.hint) == null ? void 0 : i.position) || \"right\"\n    });\n  }\n  /**\n   * Returns popover item root element\n   */\n  getElement() {\n    return this.nodes.root;\n  }\n  /**\n   * Toggles item hidden state\n   *\n   * @param isHidden - true if item should be hidden\n   */\n  toggleHidden(e) {\n    var t;\n    (t = this.nodes.root) == null || t.classList.toggle(Et.hidden, e);\n  }\n  /**\n   * Returns list of buttons and inputs inside custom content\n   */\n  getControls() {\n    const e = this.nodes.root.querySelectorAll(\n      `button, ${d.allInputsSelector}`\n    );\n    return Array.from(e);\n  }\n}\nclass Wt extends Be {\n  /**\n   * Constructs the instance\n   *\n   * @param params - popover construction params\n   * @param itemsRenderParams - popover item render params.\n   * The parameters that are not set by user via popover api but rather depend on technical implementation\n   */\n  constructor(e, t = {}) {\n    super(), this.params = e, this.itemsRenderParams = t, this.listeners = new Te(), this.messages = {\n      nothingFound: \"Nothing found\",\n      search: \"Search\"\n    }, this.items = this.buildItems(e.items), e.messages && (this.messages = {\n      ...this.messages,\n      ...e.messages\n    }), this.nodes = {}, this.nodes.popoverContainer = d.make(\"div\", [N.popoverContainer]), this.nodes.nothingFoundMessage = d.make(\"div\", [N.nothingFoundMessage], {\n      textContent: this.messages.nothingFound\n    }), this.nodes.popoverContainer.appendChild(this.nodes.nothingFoundMessage), this.nodes.items = d.make(\"div\", [N.items]), this.items.forEach((o) => {\n      const i = o.getElement();\n      i !== null && this.nodes.items.appendChild(i);\n    }), this.nodes.popoverContainer.appendChild(this.nodes.items), this.listeners.on(this.nodes.popoverContainer, \"click\", (o) => this.handleClick(o)), this.nodes.popover = d.make(\"div\", [\n      N.popover,\n      this.params.class\n    ]), this.nodes.popover.appendChild(this.nodes.popoverContainer);\n  }\n  /**\n   * List of default popover items that are searchable and may have confirmation state\n   */\n  get itemsDefault() {\n    return this.items.filter((e) => e instanceof se);\n  }\n  /**\n   * Returns HTML element corresponding to the popover\n   */\n  getElement() {\n    return this.nodes.popover;\n  }\n  /**\n   * Open popover\n   */\n  show() {\n    this.nodes.popover.classList.add(N.popoverOpened), this.search !== void 0 && this.search.focus();\n  }\n  /**\n   * Closes popover\n   */\n  hide() {\n    this.nodes.popover.classList.remove(N.popoverOpened), this.nodes.popover.classList.remove(N.popoverOpenTop), this.itemsDefault.forEach((e) => e.reset()), this.search !== void 0 && this.search.clear(), this.emit(Z.Closed);\n  }\n  /**\n   * Clears memory\n   */\n  destroy() {\n    var e;\n    this.items.forEach((t) => t.destroy()), this.nodes.popover.remove(), this.listeners.removeAll(), (e = this.search) == null || e.destroy();\n  }\n  /**\n   * Looks for the item by name and imitates click on it\n   *\n   * @param name - name of the item to activate\n   */\n  activateItemByName(e) {\n    const t = this.items.find((o) => o.name === e);\n    this.handleItemClick(t);\n  }\n  /**\n   * Factory method for creating popover items\n   *\n   * @param items - list of items params\n   */\n  buildItems(e) {\n    return e.map((t) => {\n      switch (t.type) {\n        case A.Separator:\n          return new Yt();\n        case A.Html:\n          return new ye(t, this.itemsRenderParams[A.Html]);\n        default:\n          return new se(t, this.itemsRenderParams[A.Default]);\n      }\n    });\n  }\n  /**\n   * Retrieves popover item that is the target of the specified event\n   *\n   * @param event - event to retrieve popover item from\n   */\n  getTargetItem(e) {\n    return this.items.filter((t) => t instanceof se || t instanceof ye).find((t) => {\n      const o = t.getElement();\n      return o === null ? !1 : e.composedPath().includes(o);\n    });\n  }\n  /**\n   * Handles popover item click\n   *\n   * @param item - item to handle click of\n   */\n  handleItemClick(e) {\n    if (!(\"isDisabled\" in e && e.isDisabled)) {\n      if (e.hasChildren) {\n        this.showNestedItems(e), \"handleClick\" in e && typeof e.handleClick == \"function\" && e.handleClick();\n        return;\n      }\n      this.itemsDefault.filter((t) => t !== e).forEach((t) => t.reset()), \"handleClick\" in e && typeof e.handleClick == \"function\" && e.handleClick(), this.toggleItemActivenessIfNeeded(e), e.closeOnActivate && (this.hide(), this.emit(Z.ClosedOnActivate));\n    }\n  }\n  /**\n   * Handles clicks inside popover\n   *\n   * @param event - item to handle click of\n   */\n  handleClick(e) {\n    const t = this.getTargetItem(e);\n    t !== void 0 && this.handleItemClick(t);\n  }\n  /**\n   * - Toggles item active state, if clicked popover item has property 'toggle' set to true.\n   *\n   * - Performs radiobutton-like behavior if the item has property 'toggle' set to string key.\n   * (All the other items with the same key get inactive, and the item gets active)\n   *\n   * @param clickedItem - popover item that was clicked\n   */\n  toggleItemActivenessIfNeeded(e) {\n    if (e instanceof se && (e.toggle === !0 && e.toggleActive(), typeof e.toggle == \"string\")) {\n      const t = this.itemsDefault.filter((o) => o.toggle === e.toggle);\n      if (t.length === 1) {\n        e.toggleActive();\n        return;\n      }\n      t.forEach((o) => {\n        o.toggleActive(o === e);\n      });\n    }\n  }\n}\nvar Pe = /* @__PURE__ */ ((n) => (n.Search = \"search\", n))(Pe || {});\nconst $e = te(\"cdx-search-field\"), Ye = {\n  wrapper: $e(),\n  icon: $e(\"icon\"),\n  input: $e(\"input\")\n};\nclass ri extends Be {\n  /**\n   * @param options - available config\n   * @param options.items - searchable items list\n   * @param options.placeholder - input placeholder\n   */\n  constructor({ items: e, placeholder: t }) {\n    super(), this.listeners = new Te(), this.items = e, this.wrapper = d.make(\"div\", Ye.wrapper);\n    const o = d.make(\"div\", Ye.icon, {\n      innerHTML: Zo\n    });\n    this.input = d.make(\"input\", Ye.input, {\n      placeholder: t,\n      /**\n       * Used to prevent focusing on the input by Tab key\n       * (Popover in the Toolbar lays below the blocks,\n       * so Tab in the last block will focus this hidden input if this property is not set)\n       */\n      tabIndex: -1\n    }), this.wrapper.appendChild(o), this.wrapper.appendChild(this.input), this.listeners.on(this.input, \"input\", () => {\n      this.searchQuery = this.input.value, this.emit(Pe.Search, {\n        query: this.searchQuery,\n        items: this.foundItems\n      });\n    });\n  }\n  /**\n   * Returns search field element\n   */\n  getElement() {\n    return this.wrapper;\n  }\n  /**\n   * Sets focus to the input\n   */\n  focus() {\n    this.input.focus();\n  }\n  /**\n   * Clears search query and results\n   */\n  clear() {\n    this.input.value = \"\", this.searchQuery = \"\", this.emit(Pe.Search, {\n      query: \"\",\n      items: this.foundItems\n    });\n  }\n  /**\n   * Clears memory\n   */\n  destroy() {\n    this.listeners.removeAll();\n  }\n  /**\n   * Returns list of found items for the current search query\n   */\n  get foundItems() {\n    return this.items.filter((e) => this.checkItem(e));\n  }\n  /**\n   * Contains logic for checking whether passed item conforms the search query\n   *\n   * @param item - item to be checked\n   */\n  checkItem(e) {\n    var i, s;\n    const t = ((i = e.title) == null ? void 0 : i.toLowerCase()) || \"\", o = (s = this.searchQuery) == null ? void 0 : s.toLowerCase();\n    return o !== void 0 ? t.includes(o) : !1;\n  }\n}\nvar li = Object.defineProperty, ai = Object.getOwnPropertyDescriptor, ci = (n, e, t, o) => {\n  for (var i = o > 1 ? void 0 : o ? ai(e, t) : e, s = n.length - 1, r; s >= 0; s--)\n    (r = n[s]) && (i = (o ? r(e, t, i) : r(i)) || i);\n  return o && i && li(e, t, i), i;\n};\nconst Kt = class Xt extends Wt {\n  /**\n   * Construct the instance\n   *\n   * @param params - popover params\n   * @param itemsRenderParams popover item render params.\n   * The parameters that are not set by user via popover api but rather depend on technical implementation\n   */\n  constructor(e, t) {\n    super(e, t), this.nestingLevel = 0, this.nestedPopoverTriggerItem = null, this.previouslyHoveredItem = null, this.scopeElement = document.body, this.hide = () => {\n      var o;\n      super.hide(), this.destroyNestedPopoverIfExists(), (o = this.flipper) == null || o.deactivate(), this.previouslyHoveredItem = null;\n    }, this.onFlip = () => {\n      const o = this.itemsDefault.find((i) => i.isFocused);\n      o == null || o.onFocus();\n    }, this.onSearch = (o) => {\n      var l;\n      const i = o.query === \"\", s = o.items.length === 0;\n      this.items.forEach((a) => {\n        let c = !1;\n        a instanceof se ? c = !o.items.includes(a) : (a instanceof Yt || a instanceof ye) && (c = s || !i), a.toggleHidden(c);\n      }), this.toggleNothingFoundMessage(s);\n      const r = o.query === \"\" ? this.flippableElements : o.items.map((a) => a.getElement());\n      (l = this.flipper) != null && l.isActivated && (this.flipper.deactivate(), this.flipper.activate(r));\n    }, e.nestingLevel !== void 0 && (this.nestingLevel = e.nestingLevel), this.nestingLevel > 0 && this.nodes.popover.classList.add(N.popoverNested), e.scopeElement !== void 0 && (this.scopeElement = e.scopeElement), this.nodes.popoverContainer !== null && this.listeners.on(this.nodes.popoverContainer, \"mouseover\", (o) => this.handleHover(o)), e.searchable && this.addSearch(), e.flippable !== !1 && (this.flipper = new re({\n      items: this.flippableElements,\n      focusedItemClass: L.focused,\n      allowedKeys: [\n        w.TAB,\n        w.UP,\n        w.DOWN,\n        w.ENTER\n      ]\n    }), this.flipper.onFlip(this.onFlip));\n  }\n  /**\n   * Returns true if some item inside popover is focused\n   */\n  hasFocus() {\n    return this.flipper === void 0 ? !1 : this.flipper.hasFocus();\n  }\n  /**\n   * Scroll position inside items container of the popover\n   */\n  get scrollTop() {\n    return this.nodes.items === null ? 0 : this.nodes.items.scrollTop;\n  }\n  /**\n   * Returns visible element offset top\n   */\n  get offsetTop() {\n    return this.nodes.popoverContainer === null ? 0 : this.nodes.popoverContainer.offsetTop;\n  }\n  /**\n   * Open popover\n   */\n  show() {\n    var e;\n    this.nodes.popover.style.setProperty(ce.PopoverHeight, this.size.height + \"px\"), this.shouldOpenBottom || this.nodes.popover.classList.add(N.popoverOpenTop), this.shouldOpenRight || this.nodes.popover.classList.add(N.popoverOpenLeft), super.show(), (e = this.flipper) == null || e.activate(this.flippableElements);\n  }\n  /**\n   * Clears memory\n   */\n  destroy() {\n    this.hide(), super.destroy();\n  }\n  /**\n   * Handles displaying nested items for the item.\n   *\n   * @param item  item to show nested popover for\n   */\n  showNestedItems(e) {\n    this.nestedPopover !== null && this.nestedPopover !== void 0 || (this.nestedPopoverTriggerItem = e, this.showNestedPopoverForItem(e));\n  }\n  /**\n   * Handles hover events inside popover items container\n   *\n   * @param event - hover event data\n   */\n  handleHover(e) {\n    const t = this.getTargetItem(e);\n    t !== void 0 && this.previouslyHoveredItem !== t && (this.destroyNestedPopoverIfExists(), this.previouslyHoveredItem = t, t.hasChildren && this.showNestedPopoverForItem(t));\n  }\n  /**\n   * Sets CSS variable with position of item near which nested popover should be displayed.\n   * Is used for correct positioning of the nested popover\n   *\n   * @param nestedPopoverEl - nested popover element\n   * @param item  item near which nested popover should be displayed\n   */\n  setTriggerItemPosition(e, t) {\n    const o = t.getElement(), i = (o ? o.offsetTop : 0) - this.scrollTop, s = this.offsetTop + i;\n    e.style.setProperty(ce.TriggerItemTop, s + \"px\");\n  }\n  /**\n   * Destroys existing nested popover\n   */\n  destroyNestedPopoverIfExists() {\n    var e, t;\n    this.nestedPopover === void 0 || this.nestedPopover === null || (this.nestedPopover.off(Z.ClosedOnActivate, this.hide), this.nestedPopover.hide(), this.nestedPopover.destroy(), this.nestedPopover.getElement().remove(), this.nestedPopover = null, (e = this.flipper) == null || e.activate(this.flippableElements), (t = this.nestedPopoverTriggerItem) == null || t.onChildrenClose());\n  }\n  /**\n   * Creates and displays nested popover for specified item.\n   * Is used only on desktop\n   *\n   * @param item - item to display nested popover by\n   */\n  showNestedPopoverForItem(e) {\n    var o;\n    this.nestedPopover = new Xt({\n      searchable: e.isChildrenSearchable,\n      items: e.children,\n      nestingLevel: this.nestingLevel + 1,\n      flippable: e.isChildrenFlippable\n    }), e.onChildrenOpen(), this.nestedPopover.on(Z.ClosedOnActivate, this.hide);\n    const t = this.nestedPopover.getElement();\n    return this.nodes.popover.appendChild(t), this.setTriggerItemPosition(t, e), t.style.setProperty(ce.NestingLevel, this.nestedPopover.nestingLevel.toString()), this.nestedPopover.show(), (o = this.flipper) == null || o.deactivate(), this.nestedPopover;\n  }\n  /**\n   * Checks if popover should be opened bottom.\n   * It should happen when there is enough space below or not enough space above\n   */\n  get shouldOpenBottom() {\n    if (this.nodes.popover === void 0 || this.nodes.popover === null)\n      return !1;\n    const e = this.nodes.popoverContainer.getBoundingClientRect(), t = this.scopeElement.getBoundingClientRect(), o = this.size.height, i = e.top + o, s = e.top - o, r = Math.min(window.innerHeight, t.bottom);\n    return s < t.top || i <= r;\n  }\n  /**\n   * Checks if popover should be opened left.\n   * It should happen when there is enough space in the right or not enough space in the left\n   */\n  get shouldOpenRight() {\n    if (this.nodes.popover === void 0 || this.nodes.popover === null)\n      return !1;\n    const e = this.nodes.popover.getBoundingClientRect(), t = this.scopeElement.getBoundingClientRect(), o = this.size.width, i = e.right + o, s = e.left - o, r = Math.min(window.innerWidth, t.right);\n    return s < t.left || i <= r;\n  }\n  get size() {\n    var i;\n    const e = {\n      height: 0,\n      width: 0\n    };\n    if (this.nodes.popover === null)\n      return e;\n    const t = this.nodes.popover.cloneNode(!0);\n    t.style.visibility = \"hidden\", t.style.position = \"absolute\", t.style.top = \"-1000px\", t.classList.add(N.popoverOpened), (i = t.querySelector(\".\" + N.popoverNested)) == null || i.remove(), document.body.appendChild(t);\n    const o = t.querySelector(\".\" + N.popoverContainer);\n    return e.height = o.offsetHeight, e.width = o.offsetWidth, t.remove(), e;\n  }\n  /**\n   * Returns list of elements available for keyboard navigation.\n   */\n  get flippableElements() {\n    return this.items.map((t) => {\n      if (t instanceof se)\n        return t.getElement();\n      if (t instanceof ye)\n        return t.getControls();\n    }).flat().filter((t) => t != null);\n  }\n  /**\n   * Adds search to the popover\n   */\n  addSearch() {\n    this.search = new ri({\n      items: this.itemsDefault,\n      placeholder: this.messages.search\n    }), this.search.on(Pe.Search, this.onSearch);\n    const e = this.search.getElement();\n    e.classList.add(N.search), this.nodes.popoverContainer.insertBefore(e, this.nodes.popoverContainer.firstChild);\n  }\n  /**\n   * Toggles nothing found message visibility\n   *\n   * @param isDisplayed - true if the message should be displayed\n   */\n  toggleNothingFoundMessage(e) {\n    this.nodes.nothingFoundMessage.classList.toggle(N.nothingFoundMessageDisplayed, e);\n  }\n};\nci([\n  he\n], Kt.prototype, \"size\", 1);\nlet it = Kt;\nclass di extends it {\n  /**\n   * Constructs the instance\n   *\n   * @param params - instance parameters\n   */\n  constructor(e) {\n    const t = !ue();\n    super(\n      {\n        ...e,\n        class: N.popoverInline\n      },\n      {\n        [A.Default]: {\n          /**\n           * We use button instead of div here to fix bug associated with focus loss (which leads to selection change) on click in safari\n           *\n           * @todo figure out better way to solve the issue\n           */\n          wrapperTag: \"button\",\n          hint: {\n            position: \"top\",\n            alignment: \"center\",\n            enabled: t\n          }\n        },\n        [A.Html]: {\n          hint: {\n            position: \"top\",\n            alignment: \"center\",\n            enabled: t\n          }\n        }\n      }\n    ), this.items.forEach((o) => {\n      !(o instanceof se) && !(o instanceof ye) || o.hasChildren && o.isChildrenOpen && this.showNestedItems(o);\n    });\n  }\n  /**\n   * Returns visible element offset top\n   */\n  get offsetLeft() {\n    return this.nodes.popoverContainer === null ? 0 : this.nodes.popoverContainer.offsetLeft;\n  }\n  /**\n   * Open popover\n   */\n  show() {\n    this.nestingLevel === 0 && this.nodes.popover.style.setProperty(\n      ce.InlinePopoverWidth,\n      this.size.width + \"px\"\n    ), super.show();\n  }\n  /**\n   * Disable hover event handling.\n   * Overrides parent's class behavior\n   */\n  handleHover() {\n  }\n  /**\n   * Sets CSS variable with position of item near which nested popover should be displayed.\n   * Is used to position nested popover right below clicked item\n   *\n   * @param nestedPopoverEl - nested popover element\n   * @param item  item near which nested popover should be displayed\n   */\n  setTriggerItemPosition(e, t) {\n    const o = t.getElement(), i = o ? o.offsetLeft : 0, s = this.offsetLeft + i;\n    e.style.setProperty(\n      ce.TriggerItemLeft,\n      s + \"px\"\n    );\n  }\n  /**\n   * Handles displaying nested items for the item.\n   * Overriding in order to add toggling behaviour\n   *\n   * @param item  item to toggle nested popover for\n   */\n  showNestedItems(e) {\n    if (this.nestedPopoverTriggerItem === e) {\n      this.nestedPopoverTriggerItem = null, this.destroyNestedPopoverIfExists();\n      return;\n    }\n    super.showNestedItems(e);\n  }\n  /**\n   * Creates and displays nested popover for specified item.\n   * Is used only on desktop\n   *\n   * @param item - item to display nested popover by\n   */\n  showNestedPopoverForItem(e) {\n    const t = super.showNestedPopoverForItem(e);\n    return t.getElement().classList.add(N.getPopoverNestedClass(t.nestingLevel)), t;\n  }\n  /**\n   * Overrides default item click handling.\n   * Helps to close nested popover once other item is clicked.\n   *\n   * @param item - clicked item\n   */\n  handleItemClick(e) {\n    var t;\n    e !== this.nestedPopoverTriggerItem && ((t = this.nestedPopoverTriggerItem) == null || t.handleClick(), super.destroyNestedPopoverIfExists()), super.handleItemClick(e);\n  }\n}\nconst Vt = class ve {\n  constructor() {\n    this.scrollPosition = null;\n  }\n  /**\n   * Locks body element scroll\n   */\n  lock() {\n    Ge ? this.lockHard() : document.body.classList.add(ve.CSS.scrollLocked);\n  }\n  /**\n   * Unlocks body element scroll\n   */\n  unlock() {\n    Ge ? this.unlockHard() : document.body.classList.remove(ve.CSS.scrollLocked);\n  }\n  /**\n   * Locks scroll in a hard way (via setting fixed position to body element)\n   */\n  lockHard() {\n    this.scrollPosition = window.pageYOffset, document.documentElement.style.setProperty(\n      \"--window-scroll-offset\",\n      `${this.scrollPosition}px`\n    ), document.body.classList.add(ve.CSS.scrollLockedHard);\n  }\n  /**\n   * Unlocks hard scroll lock\n   */\n  unlockHard() {\n    document.body.classList.remove(ve.CSS.scrollLockedHard), this.scrollPosition !== null && window.scrollTo(0, this.scrollPosition), this.scrollPosition = null;\n  }\n};\nVt.CSS = {\n  scrollLocked: \"ce-scroll-locked\",\n  scrollLockedHard: \"ce-scroll-locked--hard\"\n};\nlet hi = Vt;\nconst We = te(\"ce-popover-header\"), Ke = {\n  root: We(),\n  text: We(\"text\"),\n  backButton: We(\"back-button\")\n};\nclass ui {\n  /**\n   * Constructs the instance\n   *\n   * @param params - popover header params\n   */\n  constructor({ text: e, onBackButtonClick: t }) {\n    this.listeners = new Te(), this.text = e, this.onBackButtonClick = t, this.nodes = {\n      root: d.make(\"div\", [Ke.root]),\n      backButton: d.make(\"button\", [Ke.backButton]),\n      text: d.make(\"div\", [Ke.text])\n    }, this.nodes.backButton.innerHTML = jo, this.nodes.root.appendChild(this.nodes.backButton), this.listeners.on(this.nodes.backButton, \"click\", this.onBackButtonClick), this.nodes.text.innerText = this.text, this.nodes.root.appendChild(this.nodes.text);\n  }\n  /**\n   * Returns popover header root html element\n   */\n  getElement() {\n    return this.nodes.root;\n  }\n  /**\n   * Destroys the instance\n   */\n  destroy() {\n    this.nodes.root.remove(), this.listeners.destroy();\n  }\n}\nclass pi {\n  constructor() {\n    this.history = [];\n  }\n  /**\n   * Push new popover state\n   *\n   * @param state - new state\n   */\n  push(e) {\n    this.history.push(e);\n  }\n  /**\n   * Pop last popover state\n   */\n  pop() {\n    return this.history.pop();\n  }\n  /**\n   * Title retrieved from the current state\n   */\n  get currentTitle() {\n    return this.history.length === 0 ? \"\" : this.history[this.history.length - 1].title;\n  }\n  /**\n   * Items list retrieved from the current state\n   */\n  get currentItems() {\n    return this.history.length === 0 ? [] : this.history[this.history.length - 1].items;\n  }\n  /**\n   * Returns history to initial popover state\n   */\n  reset() {\n    for (; this.history.length > 1; )\n      this.pop();\n  }\n}\nclass qt extends Wt {\n  /**\n   * Construct the instance\n   *\n   * @param params - popover params\n   */\n  constructor(e) {\n    super(e, {\n      [A.Default]: {\n        hint: {\n          enabled: !1\n        }\n      },\n      [A.Html]: {\n        hint: {\n          enabled: !1\n        }\n      }\n    }), this.scrollLocker = new hi(), this.history = new pi(), this.isHidden = !0, this.nodes.overlay = d.make(\"div\", [N.overlay, N.overlayHidden]), this.nodes.popover.insertBefore(this.nodes.overlay, this.nodes.popover.firstChild), this.listeners.on(this.nodes.overlay, \"click\", () => {\n      this.hide();\n    }), this.history.push({ items: e.items });\n  }\n  /**\n   * Open popover\n   */\n  show() {\n    this.nodes.overlay.classList.remove(N.overlayHidden), super.show(), this.scrollLocker.lock(), this.isHidden = !1;\n  }\n  /**\n   * Closes popover\n   */\n  hide() {\n    this.isHidden || (super.hide(), this.nodes.overlay.classList.add(N.overlayHidden), this.scrollLocker.unlock(), this.history.reset(), this.isHidden = !0);\n  }\n  /**\n   * Clears memory\n   */\n  destroy() {\n    super.destroy(), this.scrollLocker.unlock();\n  }\n  /**\n   * Handles displaying nested items for the item\n   *\n   * @param item item to show nested popover for\n   */\n  showNestedItems(e) {\n    this.updateItemsAndHeader(e.children, e.title), this.history.push({\n      title: e.title,\n      items: e.children\n    });\n  }\n  /**\n   * Removes rendered popover items and header and displays new ones\n   *\n   * @param items - new popover items\n   * @param title - new popover header text\n   */\n  updateItemsAndHeader(e, t) {\n    if (this.header !== null && this.header !== void 0 && (this.header.destroy(), this.header = null), t !== void 0) {\n      this.header = new ui({\n        text: t,\n        onBackButtonClick: () => {\n          this.history.pop(), this.updateItemsAndHeader(this.history.currentItems, this.history.currentTitle);\n        }\n      });\n      const o = this.header.getElement();\n      o !== null && this.nodes.popoverContainer.insertBefore(o, this.nodes.popoverContainer.firstChild);\n    }\n    this.items.forEach((o) => {\n      var i;\n      return (i = o.getElement()) == null ? void 0 : i.remove();\n    }), this.items = this.buildItems(e), this.items.forEach((o) => {\n      var s;\n      const i = o.getElement();\n      i !== null && ((s = this.nodes.items) == null || s.appendChild(i));\n    });\n  }\n}\nvar J = /* @__PURE__ */ ((n) => (n.APPEND_CALLBACK = \"appendCallback\", n.RENDERED = \"rendered\", n.MOVED = \"moved\", n.UPDATED = \"updated\", n.REMOVED = \"removed\", n.ON_PASTE = \"onPaste\", n))(J || {});\nclass D extends Be {\n  /**\n   * @param options - block constructor options\n   * @param [options.id] - block's id. Will be generated if omitted.\n   * @param options.data - Tool's initial data\n   * @param options.tool  block's tool\n   * @param options.api - Editor API module for pass it to the Block Tunes\n   * @param options.readOnly - Read-Only flag\n   * @param [eventBus] - Editor common event bus. Allows to subscribe on some Editor events. Could be omitted when \"virtual\" Block is created. See BlocksAPI@composeBlockData.\n   */\n  constructor({\n    id: e = Io(),\n    data: t,\n    tool: o,\n    readOnly: i,\n    tunesData: s\n  }, r) {\n    super(), this.cachedInputs = [], this.toolRenderedElement = null, this.tunesInstances = /* @__PURE__ */ new Map(), this.defaultTunesInstances = /* @__PURE__ */ new Map(), this.unavailableTunesData = {}, this.inputIndex = 0, this.editorEventBus = null, this.handleFocus = () => {\n      this.dropInputsCache(), this.updateCurrentInput();\n    }, this.didMutated = (l = void 0) => {\n      const a = l === void 0, c = l instanceof InputEvent;\n      !a && !c && this.detectToolRootChange(l);\n      let u;\n      a || c ? u = !0 : u = !(l.length > 0 && l.every((p) => {\n        const { addedNodes: g, removedNodes: f, target: k } = p;\n        return [\n          ...Array.from(g),\n          ...Array.from(f),\n          k\n        ].some((S) => (d.isElement(S) || (S = S.parentElement), S && S.closest('[data-mutation-free=\"true\"]') !== null));\n      })), u && (this.dropInputsCache(), this.updateCurrentInput(), this.toggleInputsEmptyMark(), this.call(\n        \"updated\"\n        /* UPDATED */\n      ), this.emit(\"didMutated\", this));\n    }, this.name = o.name, this.id = e, this.settings = o.settings, this.config = o.settings.config || {}, this.editorEventBus = r || null, this.blockAPI = new G(this), this.tool = o, this.toolInstance = o.create(t, this.blockAPI, i), this.tunes = o.tunes, this.composeTunes(s), this.holder = this.compose(), window.requestIdleCallback(() => {\n      this.watchBlockMutations(), this.addInputEvents(), this.toggleInputsEmptyMark();\n    });\n  }\n  /**\n   * CSS classes for the Block\n   *\n   * @returns {{wrapper: string, content: string}}\n   */\n  static get CSS() {\n    return {\n      wrapper: \"ce-block\",\n      wrapperStretched: \"ce-block--stretched\",\n      content: \"ce-block__content\",\n      selected: \"ce-block--selected\",\n      dropTarget: \"ce-block--drop-target\"\n    };\n  }\n  /**\n   * Find and return all editable elements (contenteditable and native inputs) in the Tool HTML\n   */\n  get inputs() {\n    if (this.cachedInputs.length !== 0)\n      return this.cachedInputs;\n    const e = d.findAllInputs(this.holder);\n    return this.inputIndex > e.length - 1 && (this.inputIndex = e.length - 1), this.cachedInputs = e, e;\n  }\n  /**\n   * Return current Tool`s input\n   * If Block doesn't contain inputs, return undefined\n   */\n  get currentInput() {\n    return this.inputs[this.inputIndex];\n  }\n  /**\n   * Set input index to the passed element\n   *\n   * @param element - HTML Element to set as current input\n   */\n  set currentInput(e) {\n    const t = this.inputs.findIndex((o) => o === e || o.contains(e));\n    t !== -1 && (this.inputIndex = t);\n  }\n  /**\n   * Return first Tool`s input\n   * If Block doesn't contain inputs, return undefined\n   */\n  get firstInput() {\n    return this.inputs[0];\n  }\n  /**\n   * Return first Tool`s input\n   * If Block doesn't contain inputs, return undefined\n   */\n  get lastInput() {\n    const e = this.inputs;\n    return e[e.length - 1];\n  }\n  /**\n   * Return next Tool`s input or undefined if it doesn't exist\n   * If Block doesn't contain inputs, return undefined\n   */\n  get nextInput() {\n    return this.inputs[this.inputIndex + 1];\n  }\n  /**\n   * Return previous Tool`s input or undefined if it doesn't exist\n   * If Block doesn't contain inputs, return undefined\n   */\n  get previousInput() {\n    return this.inputs[this.inputIndex - 1];\n  }\n  /**\n   * Get Block's JSON data\n   *\n   * @returns {object}\n   */\n  get data() {\n    return this.save().then((e) => e && !X(e.data) ? e.data : {});\n  }\n  /**\n   * Returns tool's sanitizer config\n   *\n   * @returns {object}\n   */\n  get sanitize() {\n    return this.tool.sanitizeConfig;\n  }\n  /**\n   * is block mergeable\n   * We plugin have merge function then we call it mergeable\n   *\n   * @returns {boolean}\n   */\n  get mergeable() {\n    return O(this.toolInstance.merge);\n  }\n  /**\n   * If Block contains inputs, it is focusable\n   */\n  get focusable() {\n    return this.inputs.length !== 0;\n  }\n  /**\n   * Check block for emptiness\n   *\n   * @returns {boolean}\n   */\n  get isEmpty() {\n    const e = d.isEmpty(this.pluginsContent, \"/\"), t = !this.hasMedia;\n    return e && t;\n  }\n  /**\n   * Check if block has a media content such as images, iframe and other\n   *\n   * @returns {boolean}\n   */\n  get hasMedia() {\n    const e = [\n      \"img\",\n      \"iframe\",\n      \"video\",\n      \"audio\",\n      \"source\",\n      \"input\",\n      \"textarea\",\n      \"twitterwidget\"\n    ];\n    return !!this.holder.querySelector(e.join(\",\"));\n  }\n  /**\n   * Set selected state\n   * We don't need to mark Block as Selected when it is empty\n   *\n   * @param {boolean} state - 'true' to select, 'false' to remove selection\n   */\n  set selected(e) {\n    var i, s;\n    this.holder.classList.toggle(D.CSS.selected, e);\n    const t = e === !0 && b.isRangeInsideContainer(this.holder), o = e === !1 && b.isFakeCursorInsideContainer(this.holder);\n    (t || o) && ((i = this.editorEventBus) == null || i.emit(Dt, { state: e }), t ? b.addFakeCursor() : b.removeFakeCursor(this.holder), (s = this.editorEventBus) == null || s.emit(Rt, { state: e }));\n  }\n  /**\n   * Returns True if it is Selected\n   *\n   * @returns {boolean}\n   */\n  get selected() {\n    return this.holder.classList.contains(D.CSS.selected);\n  }\n  /**\n   * Set stretched state\n   *\n   * @param {boolean} state - 'true' to enable, 'false' to disable stretched state\n   */\n  set stretched(e) {\n    this.holder.classList.toggle(D.CSS.wrapperStretched, e);\n  }\n  /**\n   * Return Block's stretched state\n   *\n   * @returns {boolean}\n   */\n  get stretched() {\n    return this.holder.classList.contains(D.CSS.wrapperStretched);\n  }\n  /**\n   * Toggle drop target state\n   *\n   * @param {boolean} state - 'true' if block is drop target, false otherwise\n   */\n  set dropTarget(e) {\n    this.holder.classList.toggle(D.CSS.dropTarget, e);\n  }\n  /**\n   * Returns Plugins content\n   *\n   * @returns {HTMLElement}\n   */\n  get pluginsContent() {\n    return this.toolRenderedElement;\n  }\n  /**\n   * Calls Tool's method\n   *\n   * Method checks tool property {MethodName}. Fires method with passes params If it is instance of Function\n   *\n   * @param {string} methodName - method to call\n   * @param {object} params - method argument\n   */\n  call(e, t) {\n    if (O(this.toolInstance[e])) {\n      e === \"appendCallback\" && I(\n        \"`appendCallback` hook is deprecated and will be removed in the next major release. Use `rendered` hook instead\",\n        \"warn\"\n      );\n      try {\n        this.toolInstance[e].call(this.toolInstance, t);\n      } catch (o) {\n        I(`Error during '${e}' call: ${o.message}`, \"error\");\n      }\n    }\n  }\n  /**\n   * Call plugins merge method\n   *\n   * @param {BlockToolData} data - data to merge\n   */\n  async mergeWith(e) {\n    await this.toolInstance.merge(e);\n  }\n  /**\n   * Extracts data from Block\n   * Groups Tool's save processing time\n   *\n   * @returns {object}\n   */\n  async save() {\n    const e = await this.toolInstance.save(this.pluginsContent), t = this.unavailableTunesData;\n    [\n      ...this.tunesInstances.entries(),\n      ...this.defaultTunesInstances.entries()\n    ].forEach(([s, r]) => {\n      if (O(r.save))\n        try {\n          t[s] = r.save();\n        } catch (l) {\n          I(`Tune ${r.constructor.name} save method throws an Error %o`, \"warn\", l);\n        }\n    });\n    const o = window.performance.now();\n    let i;\n    return Promise.resolve(e).then((s) => (i = window.performance.now(), {\n      id: this.id,\n      tool: this.name,\n      data: s,\n      tunes: t,\n      time: i - o\n    })).catch((s) => {\n      I(`Saving process for ${this.name} tool failed due to the ${s}`, \"log\", \"red\");\n    });\n  }\n  /**\n   * Uses Tool's validation method to check the correctness of output data\n   * Tool's validation method is optional\n   *\n   * @description Method returns true|false whether data passed the validation or not\n   * @param {BlockToolData} data - data to validate\n   * @returns {Promise<boolean>} valid\n   */\n  async validate(e) {\n    let t = !0;\n    return this.toolInstance.validate instanceof Function && (t = await this.toolInstance.validate(e)), t;\n  }\n  /**\n   * Returns data to render in Block Tunes menu.\n   * Splits block tunes into 2 groups: block specific tunes and common tunes\n   */\n  getTunes() {\n    const e = [], t = [], o = typeof this.toolInstance.renderSettings == \"function\" ? this.toolInstance.renderSettings() : [];\n    return d.isElement(o) ? e.push({\n      type: A.Html,\n      element: o\n    }) : Array.isArray(o) ? e.push(...o) : e.push(o), [\n      ...this.tunesInstances.values(),\n      ...this.defaultTunesInstances.values()\n    ].map((s) => s.render()).forEach((s) => {\n      d.isElement(s) ? t.push({\n        type: A.Html,\n        element: s\n      }) : Array.isArray(s) ? t.push(...s) : t.push(s);\n    }), {\n      toolTunes: e,\n      commonTunes: t\n    };\n  }\n  /**\n   * Update current input index with selection anchor node\n   */\n  updateCurrentInput() {\n    this.currentInput = d.isNativeInput(document.activeElement) || !b.anchorNode ? document.activeElement : b.anchorNode;\n  }\n  /**\n   * Allows to say Editor that Block was changed. Used to manually trigger Editor's 'onChange' callback\n   * Can be useful for block changes invisible for editor core.\n   */\n  dispatchChange() {\n    this.didMutated();\n  }\n  /**\n   * Call Tool instance destroy method\n   */\n  destroy() {\n    this.unwatchBlockMutations(), this.removeInputEvents(), super.destroy(), O(this.toolInstance.destroy) && this.toolInstance.destroy();\n  }\n  /**\n   * Tool could specify several entries to be displayed at the Toolbox (for example, \"Heading 1\", \"Heading 2\", \"Heading 3\")\n   * This method returns the entry that is related to the Block (depended on the Block data)\n   */\n  async getActiveToolboxEntry() {\n    const e = this.tool.toolbox;\n    if (e.length === 1)\n      return Promise.resolve(this.tool.toolbox[0]);\n    const t = await this.data, o = e;\n    return o == null ? void 0 : o.find((i) => Ht(i.data, t));\n  }\n  /**\n   * Exports Block data as string using conversion config\n   */\n  async exportDataAsString() {\n    const e = await this.data;\n    return Ho(e, this.tool.conversionConfig);\n  }\n  /**\n   * Make default Block wrappers and put Tool`s content there\n   *\n   * @returns {HTMLDivElement}\n   */\n  compose() {\n    const e = d.make(\"div\", D.CSS.wrapper), t = d.make(\"div\", D.CSS.content), o = this.toolInstance.render();\n    e.dataset.id = this.id, this.toolRenderedElement = o, t.appendChild(this.toolRenderedElement);\n    let i = t;\n    return [...this.tunesInstances.values(), ...this.defaultTunesInstances.values()].forEach((s) => {\n      if (O(s.wrap))\n        try {\n          i = s.wrap(i);\n        } catch (r) {\n          I(`Tune ${s.constructor.name} wrap method throws an Error %o`, \"warn\", r);\n        }\n    }), e.appendChild(i), e;\n  }\n  /**\n   * Instantiate Block Tunes\n   *\n   * @param tunesData - current Block tunes data\n   * @private\n   */\n  composeTunes(e) {\n    Array.from(this.tunes.values()).forEach((t) => {\n      (t.isInternal ? this.defaultTunesInstances : this.tunesInstances).set(t.name, t.create(e[t.name], this.blockAPI));\n    }), Object.entries(e).forEach(([t, o]) => {\n      this.tunesInstances.has(t) || (this.unavailableTunesData[t] = o);\n    });\n  }\n  /**\n   * Adds focus event listeners to all inputs and contenteditable\n   */\n  addInputEvents() {\n    this.inputs.forEach((e) => {\n      e.addEventListener(\"focus\", this.handleFocus), d.isNativeInput(e) && e.addEventListener(\"input\", this.didMutated);\n    });\n  }\n  /**\n   * removes focus event listeners from all inputs and contenteditable\n   */\n  removeInputEvents() {\n    this.inputs.forEach((e) => {\n      e.removeEventListener(\"focus\", this.handleFocus), d.isNativeInput(e) && e.removeEventListener(\"input\", this.didMutated);\n    });\n  }\n  /**\n   * Listen common editor Dom Changed event and detect mutations related to the  Block\n   */\n  watchBlockMutations() {\n    var e;\n    this.redactorDomChangedCallback = (t) => {\n      const { mutations: o } = t;\n      o.some((s) => Fo(s, this.toolRenderedElement)) && this.didMutated(o);\n    }, (e = this.editorEventBus) == null || e.on(Je, this.redactorDomChangedCallback);\n  }\n  /**\n   * Remove redactor dom change event listener\n   */\n  unwatchBlockMutations() {\n    var e;\n    (e = this.editorEventBus) == null || e.off(Je, this.redactorDomChangedCallback);\n  }\n  /**\n   * Sometimes Tool can replace own main element, for example H2 -> H4 or UL -> OL\n   * We need to detect such changes and update a link to tools main element with the new one\n   *\n   * @param mutations - records of block content mutations\n   */\n  detectToolRootChange(e) {\n    e.forEach((t) => {\n      if (Array.from(t.removedNodes).includes(this.toolRenderedElement)) {\n        const i = t.addedNodes[t.addedNodes.length - 1];\n        this.toolRenderedElement = i;\n      }\n    });\n  }\n  /**\n   * Clears inputs cached value\n   */\n  dropInputsCache() {\n    this.cachedInputs = [];\n  }\n  /**\n   * Mark inputs with 'data-empty' attribute with the empty state\n   */\n  toggleInputsEmptyMark() {\n    this.inputs.forEach(Ot);\n  }\n}\nclass fi extends y {\n  constructor() {\n    super(...arguments), this.insert = (e = this.config.defaultBlock, t = {}, o = {}, i, s, r, l) => {\n      const a = this.Editor.BlockManager.insert({\n        id: l,\n        tool: e,\n        data: t,\n        index: i,\n        needToFocus: s,\n        replace: r\n      });\n      return new G(a);\n    }, this.composeBlockData = async (e) => {\n      const t = this.Editor.Tools.blockTools.get(e);\n      return new D({\n        tool: t,\n        api: this.Editor.API,\n        readOnly: !0,\n        data: {},\n        tunesData: {}\n      }).data;\n    }, this.update = async (e, t, o) => {\n      const { BlockManager: i } = this.Editor, s = i.getBlockById(e);\n      if (s === void 0)\n        throw new Error(`Block with id \"${e}\" not found`);\n      const r = await i.update(s, t, o);\n      return new G(r);\n    }, this.convert = async (e, t, o) => {\n      var h, p;\n      const { BlockManager: i, Tools: s } = this.Editor, r = i.getBlockById(e);\n      if (!r)\n        throw new Error(`Block with id \"${e}\" not found`);\n      const l = s.blockTools.get(r.name), a = s.blockTools.get(t);\n      if (!a)\n        throw new Error(`Block Tool with type \"${t}\" not found`);\n      const c = ((h = l == null ? void 0 : l.conversionConfig) == null ? void 0 : h.export) !== void 0, u = ((p = a.conversionConfig) == null ? void 0 : p.import) !== void 0;\n      if (c && u) {\n        const g = await i.convert(r, t, o);\n        return new G(g);\n      } else {\n        const g = [\n          c ? !1 : Oe(r.name),\n          u ? !1 : Oe(t)\n        ].filter(Boolean).join(\" and \");\n        throw new Error(`Conversion from \"${r.name}\" to \"${t}\" is not possible. ${g} tool(s) should provide a \"conversionConfig\"`);\n      }\n    }, this.insertMany = (e, t = this.Editor.BlockManager.blocks.length - 1) => {\n      this.validateIndex(t);\n      const o = e.map(({ id: i, type: s, data: r }) => this.Editor.BlockManager.composeBlock({\n        id: i,\n        tool: s || this.config.defaultBlock,\n        data: r\n      }));\n      return this.Editor.BlockManager.insertMany(o, t), o.map((i) => new G(i));\n    };\n  }\n  /**\n   * Available methods\n   *\n   * @returns {Blocks}\n   */\n  get methods() {\n    return {\n      clear: () => this.clear(),\n      render: (e) => this.render(e),\n      renderFromHTML: (e) => this.renderFromHTML(e),\n      delete: (e) => this.delete(e),\n      swap: (e, t) => this.swap(e, t),\n      move: (e, t) => this.move(e, t),\n      getBlockByIndex: (e) => this.getBlockByIndex(e),\n      getById: (e) => this.getById(e),\n      getCurrentBlockIndex: () => this.getCurrentBlockIndex(),\n      getBlockIndex: (e) => this.getBlockIndex(e),\n      getBlocksCount: () => this.getBlocksCount(),\n      getBlockByElement: (e) => this.getBlockByElement(e),\n      stretchBlock: (e, t = !0) => this.stretchBlock(e, t),\n      insertNewBlock: () => this.insertNewBlock(),\n      insert: this.insert,\n      insertMany: this.insertMany,\n      update: this.update,\n      composeBlockData: this.composeBlockData,\n      convert: this.convert\n    };\n  }\n  /**\n   * Returns Blocks count\n   *\n   * @returns {number}\n   */\n  getBlocksCount() {\n    return this.Editor.BlockManager.blocks.length;\n  }\n  /**\n   * Returns current block index\n   *\n   * @returns {number}\n   */\n  getCurrentBlockIndex() {\n    return this.Editor.BlockManager.currentBlockIndex;\n  }\n  /**\n   * Returns the index of Block by id;\n   *\n   * @param id - block id\n   */\n  getBlockIndex(e) {\n    const t = this.Editor.BlockManager.getBlockById(e);\n    if (!t) {\n      K(\"There is no block with id `\" + e + \"`\", \"warn\");\n      return;\n    }\n    return this.Editor.BlockManager.getBlockIndex(t);\n  }\n  /**\n   * Returns BlockAPI object by Block index\n   *\n   * @param {number} index - index to get\n   */\n  getBlockByIndex(e) {\n    const t = this.Editor.BlockManager.getBlockByIndex(e);\n    if (t === void 0) {\n      K(\"There is no block at index `\" + e + \"`\", \"warn\");\n      return;\n    }\n    return new G(t);\n  }\n  /**\n   * Returns BlockAPI object by Block id\n   *\n   * @param id - id of block to get\n   */\n  getById(e) {\n    const t = this.Editor.BlockManager.getBlockById(e);\n    return t === void 0 ? (K(\"There is no block with id `\" + e + \"`\", \"warn\"), null) : new G(t);\n  }\n  /**\n   * Get Block API object by any child html element\n   *\n   * @param element - html element to get Block by\n   */\n  getBlockByElement(e) {\n    const t = this.Editor.BlockManager.getBlock(e);\n    if (t === void 0) {\n      K(\"There is no block corresponding to element `\" + e + \"`\", \"warn\");\n      return;\n    }\n    return new G(t);\n  }\n  /**\n   * Call Block Manager method that swap Blocks\n   *\n   * @param {number} fromIndex - position of first Block\n   * @param {number} toIndex - position of second Block\n   * @deprecated  use 'move' instead\n   */\n  swap(e, t) {\n    I(\n      \"`blocks.swap()` method is deprecated and will be removed in the next major release. Use `block.move()` method instead\",\n      \"info\"\n    ), this.Editor.BlockManager.swap(e, t);\n  }\n  /**\n   * Move block from one index to another\n   *\n   * @param {number} toIndex - index to move to\n   * @param {number} fromIndex - index to move from\n   */\n  move(e, t) {\n    this.Editor.BlockManager.move(e, t);\n  }\n  /**\n   * Deletes Block\n   *\n   * @param {number} blockIndex - index of Block to delete\n   */\n  delete(e = this.Editor.BlockManager.currentBlockIndex) {\n    try {\n      const t = this.Editor.BlockManager.getBlockByIndex(e);\n      this.Editor.BlockManager.removeBlock(t);\n    } catch (t) {\n      K(t, \"warn\");\n      return;\n    }\n    this.Editor.BlockManager.blocks.length === 0 && this.Editor.BlockManager.insert(), this.Editor.BlockManager.currentBlock && this.Editor.Caret.setToBlock(this.Editor.BlockManager.currentBlock, this.Editor.Caret.positions.END), this.Editor.Toolbar.close();\n  }\n  /**\n   * Clear Editor's area\n   */\n  async clear() {\n    await this.Editor.BlockManager.clear(!0), this.Editor.InlineToolbar.close();\n  }\n  /**\n   * Fills Editor with Blocks data\n   *\n   * @param {OutputData} data  Saved Editor data\n   */\n  async render(e) {\n    if (e === void 0 || e.blocks === void 0)\n      throw new Error(\"Incorrect data passed to the render() method\");\n    this.Editor.ModificationsObserver.disable(), await this.Editor.BlockManager.clear(), await this.Editor.Renderer.render(e.blocks), this.Editor.ModificationsObserver.enable();\n  }\n  /**\n   * Render passed HTML string\n   *\n   * @param {string} data - HTML string to render\n   * @returns {Promise<void>}\n   */\n  renderFromHTML(e) {\n    return this.Editor.BlockManager.clear(), this.Editor.Paste.processText(e, !0);\n  }\n  /**\n   * Stretch Block's content\n   *\n   * @param {number} index - index of Block to stretch\n   * @param {boolean} status - true to enable, false to disable\n   * @deprecated Use BlockAPI interface to stretch Blocks\n   */\n  stretchBlock(e, t = !0) {\n    Ze(\n      !0,\n      \"blocks.stretchBlock()\",\n      \"BlockAPI\"\n    );\n    const o = this.Editor.BlockManager.getBlockByIndex(e);\n    o && (o.stretched = t);\n  }\n  /**\n   * Insert new Block\n   * After set caret to this Block\n   *\n   * @todo remove in 3.0.0\n   * @deprecated with insert() method\n   */\n  insertNewBlock() {\n    I(\"Method blocks.insertNewBlock() is deprecated and it will be removed in the next major release. Use blocks.insert() instead.\", \"warn\"), this.insert();\n  }\n  /**\n   * Validated block index and throws an error if it's invalid\n   *\n   * @param index - index to validate\n   */\n  validateIndex(e) {\n    if (typeof e != \"number\")\n      throw new Error(\"Index should be a number\");\n    if (e < 0)\n      throw new Error(\"Index should be greater than or equal to 0\");\n    if (e === null)\n      throw new Error(\"Index should be greater than or equal to 0\");\n  }\n}\nfunction gi(n, e) {\n  return typeof n == \"number\" ? e.BlockManager.getBlockByIndex(n) : typeof n == \"string\" ? e.BlockManager.getBlockById(n) : e.BlockManager.getBlockById(n.id);\n}\nclass mi extends y {\n  constructor() {\n    super(...arguments), this.setToFirstBlock = (e = this.Editor.Caret.positions.DEFAULT, t = 0) => this.Editor.BlockManager.firstBlock ? (this.Editor.Caret.setToBlock(this.Editor.BlockManager.firstBlock, e, t), !0) : !1, this.setToLastBlock = (e = this.Editor.Caret.positions.DEFAULT, t = 0) => this.Editor.BlockManager.lastBlock ? (this.Editor.Caret.setToBlock(this.Editor.BlockManager.lastBlock, e, t), !0) : !1, this.setToPreviousBlock = (e = this.Editor.Caret.positions.DEFAULT, t = 0) => this.Editor.BlockManager.previousBlock ? (this.Editor.Caret.setToBlock(this.Editor.BlockManager.previousBlock, e, t), !0) : !1, this.setToNextBlock = (e = this.Editor.Caret.positions.DEFAULT, t = 0) => this.Editor.BlockManager.nextBlock ? (this.Editor.Caret.setToBlock(this.Editor.BlockManager.nextBlock, e, t), !0) : !1, this.setToBlock = (e, t = this.Editor.Caret.positions.DEFAULT, o = 0) => {\n      const i = gi(e, this.Editor);\n      return i === void 0 ? !1 : (this.Editor.Caret.setToBlock(i, t, o), !0);\n    }, this.focus = (e = !1) => e ? this.setToLastBlock(this.Editor.Caret.positions.END) : this.setToFirstBlock(this.Editor.Caret.positions.START);\n  }\n  /**\n   * Available methods\n   *\n   * @returns {Caret}\n   */\n  get methods() {\n    return {\n      setToFirstBlock: this.setToFirstBlock,\n      setToLastBlock: this.setToLastBlock,\n      setToPreviousBlock: this.setToPreviousBlock,\n      setToNextBlock: this.setToNextBlock,\n      setToBlock: this.setToBlock,\n      focus: this.focus\n    };\n  }\n}\nclass bi extends y {\n  /**\n   * Available methods\n   *\n   * @returns {Events}\n   */\n  get methods() {\n    return {\n      emit: (e, t) => this.emit(e, t),\n      off: (e, t) => this.off(e, t),\n      on: (e, t) => this.on(e, t)\n    };\n  }\n  /**\n   * Subscribe on Events\n   *\n   * @param {string} eventName - event name to subscribe\n   * @param {Function} callback - event handler\n   */\n  on(e, t) {\n    this.eventsDispatcher.on(e, t);\n  }\n  /**\n   * Emit event with data\n   *\n   * @param {string} eventName - event to emit\n   * @param {object} data - event's data\n   */\n  emit(e, t) {\n    this.eventsDispatcher.emit(e, t);\n  }\n  /**\n   * Unsubscribe from Event\n   *\n   * @param {string} eventName - event to unsubscribe\n   * @param {Function} callback - event handler\n   */\n  off(e, t) {\n    this.eventsDispatcher.off(e, t);\n  }\n}\nclass st extends y {\n  /**\n   * Return namespace section for tool or block tune\n   *\n   * @param toolName - tool name\n   * @param isTune - is tool a block tune\n   */\n  static getNamespace(e, t) {\n    return t ? `blockTunes.${e}` : `tools.${e}`;\n  }\n  /**\n   * Return I18n API methods with global dictionary access\n   */\n  get methods() {\n    return {\n      t: () => {\n        K(\"I18n.t() method can be accessed only from Tools\", \"warn\");\n      }\n    };\n  }\n  /**\n   * Return I18n API methods with tool namespaced dictionary\n   *\n   * @param toolName - tool name\n   * @param isTune - is tool a block tune\n   */\n  getMethodsForTool(e, t) {\n    return Object.assign(\n      this.methods,\n      {\n        t: (o) => W.t(st.getNamespace(e, t), o)\n      }\n    );\n  }\n}\nclass ki extends y {\n  /**\n   * Editor.js Core API modules\n   */\n  get methods() {\n    return {\n      blocks: this.Editor.BlocksAPI.methods,\n      caret: this.Editor.CaretAPI.methods,\n      tools: this.Editor.ToolsAPI.methods,\n      events: this.Editor.EventsAPI.methods,\n      listeners: this.Editor.ListenersAPI.methods,\n      notifier: this.Editor.NotifierAPI.methods,\n      sanitizer: this.Editor.SanitizerAPI.methods,\n      saver: this.Editor.SaverAPI.methods,\n      selection: this.Editor.SelectionAPI.methods,\n      styles: this.Editor.StylesAPI.classes,\n      toolbar: this.Editor.ToolbarAPI.methods,\n      inlineToolbar: this.Editor.InlineToolbarAPI.methods,\n      tooltip: this.Editor.TooltipAPI.methods,\n      i18n: this.Editor.I18nAPI.methods,\n      readOnly: this.Editor.ReadOnlyAPI.methods,\n      ui: this.Editor.UiAPI.methods\n    };\n  }\n  /**\n   * Returns Editor.js Core API methods for passed tool\n   *\n   * @param toolName - tool name\n   * @param isTune - is tool a block tune\n   */\n  getMethodsForTool(e, t) {\n    return Object.assign(\n      this.methods,\n      {\n        i18n: this.Editor.I18nAPI.getMethodsForTool(e, t)\n      }\n    );\n  }\n}\nclass vi extends y {\n  /**\n   * Available methods\n   *\n   * @returns {InlineToolbar}\n   */\n  get methods() {\n    return {\n      close: () => this.close(),\n      open: () => this.open()\n    };\n  }\n  /**\n   * Open Inline Toolbar\n   */\n  open() {\n    this.Editor.InlineToolbar.tryToShow();\n  }\n  /**\n   * Close Inline Toolbar\n   */\n  close() {\n    this.Editor.InlineToolbar.close();\n  }\n}\nclass wi extends y {\n  /**\n   * Available methods\n   *\n   * @returns {Listeners}\n   */\n  get methods() {\n    return {\n      on: (e, t, o, i) => this.on(e, t, o, i),\n      off: (e, t, o, i) => this.off(e, t, o, i),\n      offById: (e) => this.offById(e)\n    };\n  }\n  /**\n   * Ads a DOM event listener. Return it's id.\n   *\n   * @param {HTMLElement} element - Element to set handler to\n   * @param {string} eventType - event type\n   * @param {() => void} handler - event handler\n   * @param {boolean} useCapture - capture event or not\n   */\n  on(e, t, o, i) {\n    return this.listeners.on(e, t, o, i);\n  }\n  /**\n   * Removes DOM listener from element\n   *\n   * @param {Element} element - Element to remove handler from\n   * @param eventType - event type\n   * @param handler - event handler\n   * @param {boolean} useCapture - capture event or not\n   */\n  off(e, t, o, i) {\n    this.listeners.off(e, t, o, i);\n  }\n  /**\n   * Removes DOM listener by the listener id\n   *\n   * @param id - id of the listener to remove\n   */\n  offById(e) {\n    this.listeners.offById(e);\n  }\n}\nvar Zt = { exports: {} };\n(function(n, e) {\n  (function(t, o) {\n    n.exports = o();\n  })(window, function() {\n    return function(t) {\n      var o = {};\n      function i(s) {\n        if (o[s])\n          return o[s].exports;\n        var r = o[s] = { i: s, l: !1, exports: {} };\n        return t[s].call(r.exports, r, r.exports, i), r.l = !0, r.exports;\n      }\n      return i.m = t, i.c = o, i.d = function(s, r, l) {\n        i.o(s, r) || Object.defineProperty(s, r, { enumerable: !0, get: l });\n      }, i.r = function(s) {\n        typeof Symbol < \"u\" && Symbol.toStringTag && Object.defineProperty(s, Symbol.toStringTag, { value: \"Module\" }), Object.defineProperty(s, \"__esModule\", { value: !0 });\n      }, i.t = function(s, r) {\n        if (1 & r && (s = i(s)), 8 & r || 4 & r && typeof s == \"object\" && s && s.__esModule)\n          return s;\n        var l = /* @__PURE__ */ Object.create(null);\n        if (i.r(l), Object.defineProperty(l, \"default\", { enumerable: !0, value: s }), 2 & r && typeof s != \"string\")\n          for (var a in s)\n            i.d(l, a, (function(c) {\n              return s[c];\n            }).bind(null, a));\n        return l;\n      }, i.n = function(s) {\n        var r = s && s.__esModule ? function() {\n          return s.default;\n        } : function() {\n          return s;\n        };\n        return i.d(r, \"a\", r), r;\n      }, i.o = function(s, r) {\n        return Object.prototype.hasOwnProperty.call(s, r);\n      }, i.p = \"/\", i(i.s = 0);\n    }([function(t, o, i) {\n      i(1), /*!\n       * Codex JavaScript Notification module\n       * https://github.com/codex-team/js-notifier\n       */\n      t.exports = function() {\n        var s = i(6), r = \"cdx-notify--bounce-in\", l = null;\n        return { show: function(a) {\n          if (a.message) {\n            (function() {\n              if (l)\n                return !0;\n              l = s.getWrapper(), document.body.appendChild(l);\n            })();\n            var c = null, u = a.time || 8e3;\n            switch (a.type) {\n              case \"confirm\":\n                c = s.confirm(a);\n                break;\n              case \"prompt\":\n                c = s.prompt(a);\n                break;\n              default:\n                c = s.alert(a), window.setTimeout(function() {\n                  c.remove();\n                }, u);\n            }\n            l.appendChild(c), c.classList.add(r);\n          }\n        } };\n      }();\n    }, function(t, o, i) {\n      var s = i(2);\n      typeof s == \"string\" && (s = [[t.i, s, \"\"]]);\n      var r = { hmr: !0, transform: void 0, insertInto: void 0 };\n      i(4)(s, r), s.locals && (t.exports = s.locals);\n    }, function(t, o, i) {\n      (t.exports = i(3)(!1)).push([t.i, `.cdx-notify--error{background:#fffbfb!important}.cdx-notify--error::before{background:#fb5d5d!important}.cdx-notify__input{max-width:130px;padding:5px 10px;background:#f7f7f7;border:0;border-radius:3px;font-size:13px;color:#656b7c;outline:0}.cdx-notify__input:-ms-input-placeholder{color:#656b7c}.cdx-notify__input::placeholder{color:#656b7c}.cdx-notify__input:focus:-ms-input-placeholder{color:rgba(101,107,124,.3)}.cdx-notify__input:focus::placeholder{color:rgba(101,107,124,.3)}.cdx-notify__button{border:none;border-radius:3px;font-size:13px;padding:5px 10px;cursor:pointer}.cdx-notify__button:last-child{margin-left:10px}.cdx-notify__button--cancel{background:#f2f5f7;box-shadow:0 2px 1px 0 rgba(16,19,29,0);color:#656b7c}.cdx-notify__button--cancel:hover{background:#eee}.cdx-notify__button--confirm{background:#34c992;box-shadow:0 1px 1px 0 rgba(18,49,35,.05);color:#fff}.cdx-notify__button--confirm:hover{background:#33b082}.cdx-notify__btns-wrapper{display:-ms-flexbox;display:flex;-ms-flex-flow:row nowrap;flex-flow:row nowrap;margin-top:5px}.cdx-notify__cross{position:absolute;top:5px;right:5px;width:10px;height:10px;padding:5px;opacity:.54;cursor:pointer}.cdx-notify__cross::after,.cdx-notify__cross::before{content:'';position:absolute;left:9px;top:5px;height:12px;width:2px;background:#575d67}.cdx-notify__cross::before{transform:rotate(-45deg)}.cdx-notify__cross::after{transform:rotate(45deg)}.cdx-notify__cross:hover{opacity:1}.cdx-notifies{position:fixed;z-index:2;bottom:20px;left:20px;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen,Ubuntu,Cantarell,\"Fira Sans\",\"Droid Sans\",\"Helvetica Neue\",sans-serif}.cdx-notify{position:relative;width:220px;margin-top:15px;padding:13px 16px;background:#fff;box-shadow:0 11px 17px 0 rgba(23,32,61,.13);border-radius:5px;font-size:14px;line-height:1.4em;word-wrap:break-word}.cdx-notify::before{content:'';position:absolute;display:block;top:0;left:0;width:3px;height:calc(100% - 6px);margin:3px;border-radius:5px;background:0 0}@keyframes bounceIn{0%{opacity:0;transform:scale(.3)}50%{opacity:1;transform:scale(1.05)}70%{transform:scale(.9)}100%{transform:scale(1)}}.cdx-notify--bounce-in{animation-name:bounceIn;animation-duration:.6s;animation-iteration-count:1}.cdx-notify--success{background:#fafffe!important}.cdx-notify--success::before{background:#41ffb1!important}`, \"\"]);\n    }, function(t, o) {\n      t.exports = function(i) {\n        var s = [];\n        return s.toString = function() {\n          return this.map(function(r) {\n            var l = function(a, c) {\n              var u = a[1] || \"\", h = a[3];\n              if (!h)\n                return u;\n              if (c && typeof btoa == \"function\") {\n                var p = (f = h, \"/*# sourceMappingURL=data:application/json;charset=utf-8;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(f)))) + \" */\"), g = h.sources.map(function(k) {\n                  return \"/*# sourceURL=\" + h.sourceRoot + k + \" */\";\n                });\n                return [u].concat(g).concat([p]).join(`\n`);\n              }\n              var f;\n              return [u].join(`\n`);\n            }(r, i);\n            return r[2] ? \"@media \" + r[2] + \"{\" + l + \"}\" : l;\n          }).join(\"\");\n        }, s.i = function(r, l) {\n          typeof r == \"string\" && (r = [[null, r, \"\"]]);\n          for (var a = {}, c = 0; c < this.length; c++) {\n            var u = this[c][0];\n            typeof u == \"number\" && (a[u] = !0);\n          }\n          for (c = 0; c < r.length; c++) {\n            var h = r[c];\n            typeof h[0] == \"number\" && a[h[0]] || (l && !h[2] ? h[2] = l : l && (h[2] = \"(\" + h[2] + \") and (\" + l + \")\"), s.push(h));\n          }\n        }, s;\n      };\n    }, function(t, o, i) {\n      var s, r, l = {}, a = (s = function() {\n        return window && document && document.all && !window.atob;\n      }, function() {\n        return r === void 0 && (r = s.apply(this, arguments)), r;\n      }), c = function(v) {\n        var m = {};\n        return function(x) {\n          if (typeof x == \"function\")\n            return x();\n          if (m[x] === void 0) {\n            var E = (function(M) {\n              return document.querySelector(M);\n            }).call(this, x);\n            if (window.HTMLIFrameElement && E instanceof window.HTMLIFrameElement)\n              try {\n                E = E.contentDocument.head;\n              } catch {\n                E = null;\n              }\n            m[x] = E;\n          }\n          return m[x];\n        };\n      }(), u = null, h = 0, p = [], g = i(5);\n      function f(v, m) {\n        for (var x = 0; x < v.length; x++) {\n          var E = v[x], M = l[E.id];\n          if (M) {\n            M.refs++;\n            for (var T = 0; T < M.parts.length; T++)\n              M.parts[T](E.parts[T]);\n            for (; T < E.parts.length; T++)\n              M.parts.push(U(E.parts[T], m));\n          } else {\n            var P = [];\n            for (T = 0; T < E.parts.length; T++)\n              P.push(U(E.parts[T], m));\n            l[E.id] = { id: E.id, refs: 1, parts: P };\n          }\n        }\n      }\n      function k(v, m) {\n        for (var x = [], E = {}, M = 0; M < v.length; M++) {\n          var T = v[M], P = m.base ? T[0] + m.base : T[0], B = { css: T[1], media: T[2], sourceMap: T[3] };\n          E[P] ? E[P].parts.push(B) : x.push(E[P] = { id: P, parts: [B] });\n        }\n        return x;\n      }\n      function C(v, m) {\n        var x = c(v.insertInto);\n        if (!x)\n          throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n        var E = p[p.length - 1];\n        if (v.insertAt === \"top\")\n          E ? E.nextSibling ? x.insertBefore(m, E.nextSibling) : x.appendChild(m) : x.insertBefore(m, x.firstChild), p.push(m);\n        else if (v.insertAt === \"bottom\")\n          x.appendChild(m);\n        else {\n          if (typeof v.insertAt != \"object\" || !v.insertAt.before)\n            throw new Error(`[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n`);\n          var M = c(v.insertInto + \" \" + v.insertAt.before);\n          x.insertBefore(m, M);\n        }\n      }\n      function S(v) {\n        if (v.parentNode === null)\n          return !1;\n        v.parentNode.removeChild(v);\n        var m = p.indexOf(v);\n        m >= 0 && p.splice(m, 1);\n      }\n      function _(v) {\n        var m = document.createElement(\"style\");\n        return v.attrs.type === void 0 && (v.attrs.type = \"text/css\"), ee(m, v.attrs), C(v, m), m;\n      }\n      function ee(v, m) {\n        Object.keys(m).forEach(function(x) {\n          v.setAttribute(x, m[x]);\n        });\n      }\n      function U(v, m) {\n        var x, E, M, T;\n        if (m.transform && v.css) {\n          if (!(T = m.transform(v.css)))\n            return function() {\n            };\n          v.css = T;\n        }\n        if (m.singleton) {\n          var P = h++;\n          x = u || (u = _(m)), E = pe.bind(null, x, P, !1), M = pe.bind(null, x, P, !0);\n        } else\n          v.sourceMap && typeof URL == \"function\" && typeof URL.createObjectURL == \"function\" && typeof URL.revokeObjectURL == \"function\" && typeof Blob == \"function\" && typeof btoa == \"function\" ? (x = function(B) {\n            var $ = document.createElement(\"link\");\n            return B.attrs.type === void 0 && (B.attrs.type = \"text/css\"), B.attrs.rel = \"stylesheet\", ee($, B.attrs), C(B, $), $;\n          }(m), E = (function(B, $, fe) {\n            var ie = fe.css, He = fe.sourceMap, mo = $.convertToAbsoluteUrls === void 0 && He;\n            ($.convertToAbsoluteUrls || mo) && (ie = g(ie)), He && (ie += `\n/*# sourceMappingURL=data:application/json;base64,` + btoa(unescape(encodeURIComponent(JSON.stringify(He)))) + \" */\");\n            var bo = new Blob([ie], { type: \"text/css\" }), gt = B.href;\n            B.href = URL.createObjectURL(bo), gt && URL.revokeObjectURL(gt);\n          }).bind(null, x, m), M = function() {\n            S(x), x.href && URL.revokeObjectURL(x.href);\n          }) : (x = _(m), E = (function(B, $) {\n            var fe = $.css, ie = $.media;\n            if (ie && B.setAttribute(\"media\", ie), B.styleSheet)\n              B.styleSheet.cssText = fe;\n            else {\n              for (; B.firstChild; )\n                B.removeChild(B.firstChild);\n              B.appendChild(document.createTextNode(fe));\n            }\n          }).bind(null, x), M = function() {\n            S(x);\n          });\n        return E(v), function(B) {\n          if (B) {\n            if (B.css === v.css && B.media === v.media && B.sourceMap === v.sourceMap)\n              return;\n            E(v = B);\n          } else\n            M();\n        };\n      }\n      t.exports = function(v, m) {\n        if (typeof DEBUG < \"u\" && DEBUG && typeof document != \"object\")\n          throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n        (m = m || {}).attrs = typeof m.attrs == \"object\" ? m.attrs : {}, m.singleton || typeof m.singleton == \"boolean\" || (m.singleton = a()), m.insertInto || (m.insertInto = \"head\"), m.insertAt || (m.insertAt = \"bottom\");\n        var x = k(v, m);\n        return f(x, m), function(E) {\n          for (var M = [], T = 0; T < x.length; T++) {\n            var P = x[T];\n            (B = l[P.id]).refs--, M.push(B);\n          }\n          for (E && f(k(E, m), m), T = 0; T < M.length; T++) {\n            var B;\n            if ((B = M[T]).refs === 0) {\n              for (var $ = 0; $ < B.parts.length; $++)\n                B.parts[$]();\n              delete l[B.id];\n            }\n          }\n        };\n      };\n      var j, oe = (j = [], function(v, m) {\n        return j[v] = m, j.filter(Boolean).join(`\n`);\n      });\n      function pe(v, m, x, E) {\n        var M = x ? \"\" : E.css;\n        if (v.styleSheet)\n          v.styleSheet.cssText = oe(m, M);\n        else {\n          var T = document.createTextNode(M), P = v.childNodes;\n          P[m] && v.removeChild(P[m]), P.length ? v.insertBefore(T, P[m]) : v.appendChild(T);\n        }\n      }\n    }, function(t, o) {\n      t.exports = function(i) {\n        var s = typeof window < \"u\" && window.location;\n        if (!s)\n          throw new Error(\"fixUrls requires window.location\");\n        if (!i || typeof i != \"string\")\n          return i;\n        var r = s.protocol + \"//\" + s.host, l = r + s.pathname.replace(/\\/[^\\/]*$/, \"/\");\n        return i.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(a, c) {\n          var u, h = c.trim().replace(/^\"(.*)\"$/, function(p, g) {\n            return g;\n          }).replace(/^'(.*)'$/, function(p, g) {\n            return g;\n          });\n          return /^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(h) ? a : (u = h.indexOf(\"//\") === 0 ? h : h.indexOf(\"/\") === 0 ? r + h : l + h.replace(/^\\.\\//, \"\"), \"url(\" + JSON.stringify(u) + \")\");\n        });\n      };\n    }, function(t, o, i) {\n      var s, r, l, a, c, u, h, p, g;\n      t.exports = (s = \"cdx-notifies\", r = \"cdx-notify\", l = \"cdx-notify__cross\", a = \"cdx-notify__button--confirm\", c = \"cdx-notify__button--cancel\", u = \"cdx-notify__input\", h = \"cdx-notify__button\", p = \"cdx-notify__btns-wrapper\", { alert: g = function(f) {\n        var k = document.createElement(\"DIV\"), C = document.createElement(\"DIV\"), S = f.message, _ = f.style;\n        return k.classList.add(r), _ && k.classList.add(r + \"--\" + _), k.innerHTML = S, C.classList.add(l), C.addEventListener(\"click\", k.remove.bind(k)), k.appendChild(C), k;\n      }, confirm: function(f) {\n        var k = g(f), C = document.createElement(\"div\"), S = document.createElement(\"button\"), _ = document.createElement(\"button\"), ee = k.querySelector(\".\" + l), U = f.cancelHandler, j = f.okHandler;\n        return C.classList.add(p), S.innerHTML = f.okText || \"Confirm\", _.innerHTML = f.cancelText || \"Cancel\", S.classList.add(h), _.classList.add(h), S.classList.add(a), _.classList.add(c), U && typeof U == \"function\" && (_.addEventListener(\"click\", U), ee.addEventListener(\"click\", U)), j && typeof j == \"function\" && S.addEventListener(\"click\", j), S.addEventListener(\"click\", k.remove.bind(k)), _.addEventListener(\"click\", k.remove.bind(k)), C.appendChild(S), C.appendChild(_), k.appendChild(C), k;\n      }, prompt: function(f) {\n        var k = g(f), C = document.createElement(\"div\"), S = document.createElement(\"button\"), _ = document.createElement(\"input\"), ee = k.querySelector(\".\" + l), U = f.cancelHandler, j = f.okHandler;\n        return C.classList.add(p), S.innerHTML = f.okText || \"Ok\", S.classList.add(h), S.classList.add(a), _.classList.add(u), f.placeholder && _.setAttribute(\"placeholder\", f.placeholder), f.default && (_.value = f.default), f.inputType && (_.type = f.inputType), U && typeof U == \"function\" && ee.addEventListener(\"click\", U), j && typeof j == \"function\" && S.addEventListener(\"click\", function() {\n          j(_.value);\n        }), S.addEventListener(\"click\", k.remove.bind(k)), C.appendChild(_), C.appendChild(S), k.appendChild(C), k;\n      }, getWrapper: function() {\n        var f = document.createElement(\"DIV\");\n        return f.classList.add(s), f;\n      } });\n    }]);\n  });\n})(Zt);\nvar xi = Zt.exports;\nconst yi = /* @__PURE__ */ Re(xi);\nclass Ei {\n  /**\n   * Show web notification\n   *\n   * @param {NotifierOptions | ConfirmNotifierOptions | PromptNotifierOptions} options - notification options\n   */\n  show(e) {\n    yi.show(e);\n  }\n}\nclass Bi extends y {\n  /**\n   * @param moduleConfiguration - Module Configuration\n   * @param moduleConfiguration.config - Editor's config\n   * @param moduleConfiguration.eventsDispatcher - Editor's event dispatcher\n   */\n  constructor({ config: e, eventsDispatcher: t }) {\n    super({\n      config: e,\n      eventsDispatcher: t\n    }), this.notifier = new Ei();\n  }\n  /**\n   * Available methods\n   */\n  get methods() {\n    return {\n      show: (e) => this.show(e)\n    };\n  }\n  /**\n   * Show notification\n   *\n   * @param {NotifierOptions} options - message option\n   */\n  show(e) {\n    return this.notifier.show(e);\n  }\n}\nclass Ti extends y {\n  /**\n   * Available methods\n   */\n  get methods() {\n    const e = () => this.isEnabled;\n    return {\n      toggle: (t) => this.toggle(t),\n      get isEnabled() {\n        return e();\n      }\n    };\n  }\n  /**\n   * Set or toggle read-only state\n   *\n   * @param {boolean|undefined} state - set or toggle state\n   * @returns {boolean} current value\n   */\n  toggle(e) {\n    return this.Editor.ReadOnly.toggle(e);\n  }\n  /**\n   * Returns current read-only state\n   */\n  get isEnabled() {\n    return this.Editor.ReadOnly.isEnabled;\n  }\n}\nvar Gt = { exports: {} };\n(function(n, e) {\n  (function(t, o) {\n    n.exports = o();\n  })(ko, function() {\n    function t(h) {\n      var p = h.tags, g = Object.keys(p), f = g.map(function(k) {\n        return typeof p[k];\n      }).every(function(k) {\n        return k === \"object\" || k === \"boolean\" || k === \"function\";\n      });\n      if (!f)\n        throw new Error(\"The configuration was invalid\");\n      this.config = h;\n    }\n    var o = [\"P\", \"LI\", \"TD\", \"TH\", \"DIV\", \"H1\", \"H2\", \"H3\", \"H4\", \"H5\", \"H6\", \"PRE\"];\n    function i(h) {\n      return o.indexOf(h.nodeName) !== -1;\n    }\n    var s = [\"A\", \"B\", \"STRONG\", \"I\", \"EM\", \"SUB\", \"SUP\", \"U\", \"STRIKE\"];\n    function r(h) {\n      return s.indexOf(h.nodeName) !== -1;\n    }\n    t.prototype.clean = function(h) {\n      const p = document.implementation.createHTMLDocument(), g = p.createElement(\"div\");\n      return g.innerHTML = h, this._sanitize(p, g), g.innerHTML;\n    }, t.prototype._sanitize = function(h, p) {\n      var g = l(h, p), f = g.firstChild();\n      if (f)\n        do {\n          if (f.nodeType === Node.TEXT_NODE)\n            if (f.data.trim() === \"\" && (f.previousElementSibling && i(f.previousElementSibling) || f.nextElementSibling && i(f.nextElementSibling))) {\n              p.removeChild(f), this._sanitize(h, p);\n              break;\n            } else\n              continue;\n          if (f.nodeType === Node.COMMENT_NODE) {\n            p.removeChild(f), this._sanitize(h, p);\n            break;\n          }\n          var k = r(f), C;\n          k && (C = Array.prototype.some.call(f.childNodes, i));\n          var S = !!p.parentNode, _ = i(p) && i(f) && S, ee = f.nodeName.toLowerCase(), U = a(this.config, ee, f), j = k && C;\n          if (j || c(f, U) || !this.config.keepNestedBlockElements && _) {\n            if (!(f.nodeName === \"SCRIPT\" || f.nodeName === \"STYLE\"))\n              for (; f.childNodes.length > 0; )\n                p.insertBefore(f.childNodes[0], f);\n            p.removeChild(f), this._sanitize(h, p);\n            break;\n          }\n          for (var oe = 0; oe < f.attributes.length; oe += 1) {\n            var pe = f.attributes[oe];\n            u(pe, U, f) && (f.removeAttribute(pe.name), oe = oe - 1);\n          }\n          this._sanitize(h, f);\n        } while (f = g.nextSibling());\n    };\n    function l(h, p) {\n      return h.createTreeWalker(\n        p,\n        NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT,\n        null,\n        !1\n      );\n    }\n    function a(h, p, g) {\n      return typeof h.tags[p] == \"function\" ? h.tags[p](g) : h.tags[p];\n    }\n    function c(h, p) {\n      return typeof p > \"u\" ? !0 : typeof p == \"boolean\" ? !p : !1;\n    }\n    function u(h, p, g) {\n      var f = h.name.toLowerCase();\n      return p === !0 ? !1 : typeof p[f] == \"function\" ? !p[f](h.value, g) : typeof p[f] > \"u\" || p[f] === !1 ? !0 : typeof p[f] == \"string\" ? p[f] !== h.value : !1;\n    }\n    return t;\n  });\n})(Gt);\nvar Ci = Gt.exports;\nconst Si = /* @__PURE__ */ Re(Ci);\nfunction nt(n, e) {\n  return n.map((t) => {\n    const o = O(e) ? e(t.tool) : e;\n    return X(o) || (t.data = rt(t.data, o)), t;\n  });\n}\nfunction q(n, e = {}) {\n  const t = {\n    tags: e\n  };\n  return new Si(t).clean(n);\n}\nfunction rt(n, e) {\n  return Array.isArray(n) ? Ii(n, e) : R(n) ? Mi(n, e) : Q(n) ? Ai(n, e) : n;\n}\nfunction Ii(n, e) {\n  return n.map((t) => rt(t, e));\n}\nfunction Mi(n, e) {\n  const t = {};\n  for (const o in n) {\n    if (!Object.prototype.hasOwnProperty.call(n, o))\n      continue;\n    const i = n[o], s = Oi(e[o]) ? e[o] : e;\n    t[o] = rt(i, s);\n  }\n  return t;\n}\nfunction Ai(n, e) {\n  return R(e) ? q(n, e) : e === !1 ? q(n, {}) : n;\n}\nfunction Oi(n) {\n  return R(n) || yo(n) || O(n);\n}\nclass Li extends y {\n  /**\n   * Available methods\n   *\n   * @returns {SanitizerConfig}\n   */\n  get methods() {\n    return {\n      clean: (e, t) => this.clean(e, t)\n    };\n  }\n  /**\n   * Perform sanitizing of a string\n   *\n   * @param {string} taintString - what to sanitize\n   * @param {SanitizerConfig} config - sanitizer config\n   * @returns {string}\n   */\n  clean(e, t) {\n    return q(e, t);\n  }\n}\nclass _i extends y {\n  /**\n   * Available methods\n   *\n   * @returns {Saver}\n   */\n  get methods() {\n    return {\n      save: () => this.save()\n    };\n  }\n  /**\n   * Return Editor's data\n   *\n   * @returns {OutputData}\n   */\n  save() {\n    const e = \"Editor's content can not be saved in read-only mode\";\n    return this.Editor.ReadOnly.isEnabled ? (K(e, \"warn\"), Promise.reject(new Error(e))) : this.Editor.Saver.save();\n  }\n}\nclass Ni extends y {\n  constructor() {\n    super(...arguments), this.selectionUtils = new b();\n  }\n  /**\n   * Available methods\n   *\n   * @returns {SelectionAPIInterface}\n   */\n  get methods() {\n    return {\n      findParentTag: (e, t) => this.findParentTag(e, t),\n      expandToTag: (e) => this.expandToTag(e),\n      save: () => this.selectionUtils.save(),\n      restore: () => this.selectionUtils.restore(),\n      setFakeBackground: () => this.selectionUtils.setFakeBackground(),\n      removeFakeBackground: () => this.selectionUtils.removeFakeBackground()\n    };\n  }\n  /**\n   * Looks ahead from selection and find passed tag with class name\n   *\n   * @param {string} tagName - tag to find\n   * @param {string} className - tag's class name\n   * @returns {HTMLElement|null}\n   */\n  findParentTag(e, t) {\n    return this.selectionUtils.findParentTag(e, t);\n  }\n  /**\n   * Expand selection to passed tag\n   *\n   * @param {HTMLElement} node - tag that should contain selection\n   */\n  expandToTag(e) {\n    this.selectionUtils.expandToTag(e);\n  }\n}\nclass Pi extends y {\n  /**\n   * Available methods\n   */\n  get methods() {\n    return {\n      getBlockTools: () => Array.from(this.Editor.Tools.blockTools.values())\n    };\n  }\n}\nclass Di extends y {\n  /**\n   * Exported classes\n   */\n  get classes() {\n    return {\n      /**\n       * Base Block styles\n       */\n      block: \"cdx-block\",\n      /**\n       * Inline Tools styles\n       */\n      inlineToolButton: \"ce-inline-tool\",\n      inlineToolButtonActive: \"ce-inline-tool--active\",\n      /**\n       * UI elements\n       */\n      input: \"cdx-input\",\n      loader: \"cdx-loader\",\n      button: \"cdx-button\",\n      /**\n       * Settings styles\n       */\n      settingsButton: \"cdx-settings-button\",\n      settingsButtonActive: \"cdx-settings-button--active\"\n    };\n  }\n}\nclass Ri extends y {\n  /**\n   * Available methods\n   *\n   * @returns {Toolbar}\n   */\n  get methods() {\n    return {\n      close: () => this.close(),\n      open: () => this.open(),\n      toggleBlockSettings: (e) => this.toggleBlockSettings(e),\n      toggleToolbox: (e) => this.toggleToolbox(e)\n    };\n  }\n  /**\n   * Open toolbar\n   */\n  open() {\n    this.Editor.Toolbar.moveAndOpen();\n  }\n  /**\n   * Close toolbar and all included elements\n   */\n  close() {\n    this.Editor.Toolbar.close();\n  }\n  /**\n   * Toggles Block Setting of the current block\n   *\n   * @param {boolean} openingState   opening state of Block Setting\n   */\n  toggleBlockSettings(e) {\n    if (this.Editor.BlockManager.currentBlockIndex === -1) {\n      K(\"Could't toggle the Toolbar because there is no block selected \", \"warn\");\n      return;\n    }\n    e ?? !this.Editor.BlockSettings.opened ? (this.Editor.Toolbar.moveAndOpen(), this.Editor.BlockSettings.open()) : this.Editor.BlockSettings.close();\n  }\n  /**\n   * Open toolbox\n   *\n   * @param {boolean} openingState - Opening state of toolbox\n   */\n  toggleToolbox(e) {\n    if (this.Editor.BlockManager.currentBlockIndex === -1) {\n      K(\"Could't toggle the Toolbox because there is no block selected \", \"warn\");\n      return;\n    }\n    e ?? !this.Editor.Toolbar.toolbox.opened ? (this.Editor.Toolbar.moveAndOpen(), this.Editor.Toolbar.toolbox.open()) : this.Editor.Toolbar.toolbox.close();\n  }\n}\nclass Fi extends y {\n  /**\n   * @class\n   * @param moduleConfiguration - Module Configuration\n   * @param moduleConfiguration.config - Editor's config\n   * @param moduleConfiguration.eventsDispatcher - Editor's event dispatcher\n   */\n  constructor({ config: e, eventsDispatcher: t }) {\n    super({\n      config: e,\n      eventsDispatcher: t\n    });\n  }\n  /**\n   * Available methods\n   */\n  get methods() {\n    return {\n      show: (e, t, o) => this.show(e, t, o),\n      hide: () => this.hide(),\n      onHover: (e, t, o) => this.onHover(e, t, o)\n    };\n  }\n  /**\n   * Method show tooltip on element with passed HTML content\n   *\n   * @param {HTMLElement} element - element on which tooltip should be shown\n   * @param {TooltipContent} content - tooltip content\n   * @param {TooltipOptions} options - tooltip options\n   */\n  show(e, t, o) {\n    ti(e, t, o);\n  }\n  /**\n   * Method hides tooltip on HTML page\n   */\n  hide() {\n    _e();\n  }\n  /**\n   * Decorator for showing Tooltip by mouseenter/mouseleave\n   *\n   * @param {HTMLElement} element - element on which tooltip should be shown\n   * @param {TooltipContent} content - tooltip content\n   * @param {TooltipOptions} options - tooltip options\n   */\n  onHover(e, t, o) {\n    Ne(e, t, o);\n  }\n}\nclass Hi extends y {\n  /**\n   * Available methods / getters\n   */\n  get methods() {\n    return {\n      nodes: this.editorNodes\n      /**\n       * There can be added some UI methods, like toggleThinMode() etc\n       */\n    };\n  }\n  /**\n   * Exported classes\n   */\n  get editorNodes() {\n    return {\n      /**\n       * Top-level editor instance wrapper\n       */\n      wrapper: this.Editor.UI.nodes.wrapper,\n      /**\n       * Element that holds all the Blocks\n       */\n      redactor: this.Editor.UI.nodes.redactor\n    };\n  }\n}\nfunction Jt(n, e) {\n  const t = {};\n  return Object.entries(n).forEach(([o, i]) => {\n    if (R(i)) {\n      const s = e ? `${e}.${o}` : o;\n      Object.values(i).every((l) => Q(l)) ? t[o] = s : t[o] = Jt(i, s);\n      return;\n    }\n    t[o] = i;\n  }), t;\n}\nconst V = Jt(Lt);\nfunction zi(n, e) {\n  const t = {};\n  return Object.keys(n).forEach((o) => {\n    const i = e[o];\n    i !== void 0 ? t[i] = n[o] : t[o] = n[o];\n  }), t;\n}\nclass Ui extends y {\n  constructor() {\n    super(...arguments), this.opened = !1, this.selection = new b(), this.popover = null, this.close = () => {\n      this.opened && (this.opened = !1, b.isAtEditor || this.selection.restore(), this.selection.clearSaved(), !this.Editor.CrossBlockSelection.isCrossBlockSelectionStarted && this.Editor.BlockManager.currentBlock && this.Editor.BlockSelection.unselectBlock(this.Editor.BlockManager.currentBlock), this.eventsDispatcher.emit(this.events.closed), this.popover && (this.popover.off(Z.Closed, this.onPopoverClose), this.popover.destroy(), this.popover.getElement().remove(), this.popover = null));\n    }, this.onPopoverClose = () => {\n      this.close();\n    };\n  }\n  /**\n   * Module Events\n   */\n  get events() {\n    return {\n      opened: \"block-settings-opened\",\n      closed: \"block-settings-closed\"\n    };\n  }\n  /**\n   * Block Settings CSS\n   */\n  get CSS() {\n    return {\n      settings: \"ce-settings\"\n    };\n  }\n  /**\n   * Getter for inner popover's flipper instance\n   *\n   * @todo remove once BlockSettings becomes standalone non-module class\n   */\n  get flipper() {\n    var e;\n    if (this.popover !== null)\n      return \"flipper\" in this.popover ? (e = this.popover) == null ? void 0 : e.flipper : void 0;\n  }\n  /**\n   * Panel with block settings with 2 sections:\n   *  - Tool's Settings\n   *  - Default Settings [Move, Remove, etc]\n   */\n  make() {\n    this.nodes.wrapper = d.make(\"div\", [this.CSS.settings]), this.eventsDispatcher.on(xe, this.close);\n  }\n  /**\n   * Destroys module\n   */\n  destroy() {\n    this.removeAllNodes(), this.listeners.destroy(), this.eventsDispatcher.off(xe, this.close);\n  }\n  /**\n   * Open Block Settings pane\n   *\n   * @param targetBlock - near which Block we should open BlockSettings\n   */\n  async open(e = this.Editor.BlockManager.currentBlock) {\n    var s;\n    this.opened = !0, this.selection.save(), this.Editor.BlockSelection.selectBlock(e), this.Editor.BlockSelection.clearCache();\n    const { toolTunes: t, commonTunes: o } = e.getTunes();\n    this.eventsDispatcher.emit(this.events.opened);\n    const i = ue() ? qt : it;\n    this.popover = new i({\n      searchable: !0,\n      items: await this.getTunesItems(e, o, t),\n      scopeElement: this.Editor.API.methods.ui.nodes.redactor,\n      messages: {\n        nothingFound: W.ui(V.ui.popover, \"Nothing found\"),\n        search: W.ui(V.ui.popover, \"Filter\")\n      }\n    }), this.popover.on(Z.Closed, this.onPopoverClose), (s = this.nodes.wrapper) == null || s.append(this.popover.getElement()), this.popover.show();\n  }\n  /**\n   * Returns root block settings element\n   */\n  getElement() {\n    return this.nodes.wrapper;\n  }\n  /**\n   * Returns list of items to be displayed in block tunes menu.\n   * Merges tool specific tunes, conversion menu and common tunes in one list in predefined order\n   *\n   * @param currentBlock   block we are about to open block tunes for\n   * @param commonTunes  common tunes\n   * @param toolTunes - tool specific tunes\n   */\n  async getTunesItems(e, t, o) {\n    const i = [];\n    o !== void 0 && o.length > 0 && (i.push(...o), i.push({\n      type: A.Separator\n    }));\n    const s = Array.from(this.Editor.Tools.blockTools.values()), l = (await zt(e, s)).reduce((a, c) => (c.toolbox.forEach((u) => {\n      a.push({\n        icon: u.icon,\n        title: u.title,\n        name: c.name,\n        closeOnActivate: !0,\n        onActivate: async () => {\n          const { BlockManager: h, Caret: p, Toolbar: g } = this.Editor, f = await h.convert(e, c.name, u.data);\n          g.close(), p.setToBlock(f, p.positions.END);\n        }\n      });\n    }), a), []);\n    return l.length > 0 && (i.push({\n      icon: jt,\n      title: W.ui(V.ui.popover, \"Convert to\"),\n      children: {\n        searchable: !0,\n        items: l\n      }\n    }), i.push({\n      type: A.Separator\n    })), i.push(...t), i.map((a) => this.resolveTuneAliases(a));\n  }\n  /**\n   * Resolves aliases in tunes menu items\n   *\n   * @param item - item with resolved aliases\n   */\n  resolveTuneAliases(e) {\n    if (e.type === A.Separator || e.type === A.Html)\n      return e;\n    const t = zi(e, { label: \"title\" });\n    return e.confirmation && (t.confirmation = this.resolveTuneAliases(e.confirmation)), t;\n  }\n}\nvar Qt = { exports: {} };\n/*!\n * Library for handling keyboard shortcuts\n * @copyright CodeX (https://codex.so)\n * @license MIT\n * @author CodeX (https://codex.so)\n * @version 1.2.0\n */\n(function(n, e) {\n  (function(t, o) {\n    n.exports = o();\n  })(window, function() {\n    return function(t) {\n      var o = {};\n      function i(s) {\n        if (o[s])\n          return o[s].exports;\n        var r = o[s] = { i: s, l: !1, exports: {} };\n        return t[s].call(r.exports, r, r.exports, i), r.l = !0, r.exports;\n      }\n      return i.m = t, i.c = o, i.d = function(s, r, l) {\n        i.o(s, r) || Object.defineProperty(s, r, { enumerable: !0, get: l });\n      }, i.r = function(s) {\n        typeof Symbol < \"u\" && Symbol.toStringTag && Object.defineProperty(s, Symbol.toStringTag, { value: \"Module\" }), Object.defineProperty(s, \"__esModule\", { value: !0 });\n      }, i.t = function(s, r) {\n        if (1 & r && (s = i(s)), 8 & r || 4 & r && typeof s == \"object\" && s && s.__esModule)\n          return s;\n        var l = /* @__PURE__ */ Object.create(null);\n        if (i.r(l), Object.defineProperty(l, \"default\", { enumerable: !0, value: s }), 2 & r && typeof s != \"string\")\n          for (var a in s)\n            i.d(l, a, (function(c) {\n              return s[c];\n            }).bind(null, a));\n        return l;\n      }, i.n = function(s) {\n        var r = s && s.__esModule ? function() {\n          return s.default;\n        } : function() {\n          return s;\n        };\n        return i.d(r, \"a\", r), r;\n      }, i.o = function(s, r) {\n        return Object.prototype.hasOwnProperty.call(s, r);\n      }, i.p = \"\", i(i.s = 0);\n    }([function(t, o, i) {\n      function s(a, c) {\n        for (var u = 0; u < c.length; u++) {\n          var h = c[u];\n          h.enumerable = h.enumerable || !1, h.configurable = !0, \"value\" in h && (h.writable = !0), Object.defineProperty(a, h.key, h);\n        }\n      }\n      function r(a, c, u) {\n        return c && s(a.prototype, c), u && s(a, u), a;\n      }\n      i.r(o);\n      var l = function() {\n        function a(c) {\n          var u = this;\n          (function(h, p) {\n            if (!(h instanceof p))\n              throw new TypeError(\"Cannot call a class as a function\");\n          })(this, a), this.commands = {}, this.keys = {}, this.name = c.name, this.parseShortcutName(c.name), this.element = c.on, this.callback = c.callback, this.executeShortcut = function(h) {\n            u.execute(h);\n          }, this.element.addEventListener(\"keydown\", this.executeShortcut, !1);\n        }\n        return r(a, null, [{ key: \"supportedCommands\", get: function() {\n          return { SHIFT: [\"SHIFT\"], CMD: [\"CMD\", \"CONTROL\", \"COMMAND\", \"WINDOWS\", \"CTRL\"], ALT: [\"ALT\", \"OPTION\"] };\n        } }, { key: \"keyCodes\", get: function() {\n          return { 0: 48, 1: 49, 2: 50, 3: 51, 4: 52, 5: 53, 6: 54, 7: 55, 8: 56, 9: 57, A: 65, B: 66, C: 67, D: 68, E: 69, F: 70, G: 71, H: 72, I: 73, J: 74, K: 75, L: 76, M: 77, N: 78, O: 79, P: 80, Q: 81, R: 82, S: 83, T: 84, U: 85, V: 86, W: 87, X: 88, Y: 89, Z: 90, BACKSPACE: 8, ENTER: 13, ESCAPE: 27, LEFT: 37, UP: 38, RIGHT: 39, DOWN: 40, INSERT: 45, DELETE: 46, \".\": 190 };\n        } }]), r(a, [{ key: \"parseShortcutName\", value: function(c) {\n          c = c.split(\"+\");\n          for (var u = 0; u < c.length; u++) {\n            c[u] = c[u].toUpperCase();\n            var h = !1;\n            for (var p in a.supportedCommands)\n              if (a.supportedCommands[p].includes(c[u])) {\n                h = this.commands[p] = !0;\n                break;\n              }\n            h || (this.keys[c[u]] = !0);\n          }\n          for (var g in a.supportedCommands)\n            this.commands[g] || (this.commands[g] = !1);\n        } }, { key: \"execute\", value: function(c) {\n          var u, h = { CMD: c.ctrlKey || c.metaKey, SHIFT: c.shiftKey, ALT: c.altKey }, p = !0;\n          for (u in this.commands)\n            this.commands[u] !== h[u] && (p = !1);\n          var g, f = !0;\n          for (g in this.keys)\n            f = f && c.keyCode === a.keyCodes[g];\n          p && f && this.callback(c);\n        } }, { key: \"remove\", value: function() {\n          this.element.removeEventListener(\"keydown\", this.executeShortcut);\n        } }]), a;\n      }();\n      o.default = l;\n    }]).default;\n  });\n})(Qt);\nvar ji = Qt.exports;\nconst $i = /* @__PURE__ */ Re(ji);\nclass Yi {\n  constructor() {\n    this.registeredShortcuts = /* @__PURE__ */ new Map();\n  }\n  /**\n   * Register shortcut\n   *\n   * @param shortcut - shortcut options\n   */\n  add(e) {\n    if (this.findShortcut(e.on, e.name))\n      throw Error(\n        `Shortcut ${e.name} is already registered for ${e.on}. Please remove it before add a new handler.`\n      );\n    const o = new $i({\n      name: e.name,\n      on: e.on,\n      callback: e.handler\n    }), i = this.registeredShortcuts.get(e.on) || [];\n    this.registeredShortcuts.set(e.on, [...i, o]);\n  }\n  /**\n   * Remove shortcut\n   *\n   * @param element - Element shortcut is set for\n   * @param name - shortcut name\n   */\n  remove(e, t) {\n    const o = this.findShortcut(e, t);\n    if (!o)\n      return;\n    o.remove();\n    const i = this.registeredShortcuts.get(e);\n    this.registeredShortcuts.set(e, i.filter((s) => s !== o));\n  }\n  /**\n   * Get Shortcut instance if exist\n   *\n   * @param element - Element shorcut is set for\n   * @param shortcut - shortcut name\n   * @returns {number} index - shortcut index if exist\n   */\n  findShortcut(e, t) {\n    return (this.registeredShortcuts.get(e) || []).find(({ name: i }) => i === t);\n  }\n}\nconst de = new Yi();\nvar Wi = Object.defineProperty, Ki = Object.getOwnPropertyDescriptor, eo = (n, e, t, o) => {\n  for (var i = o > 1 ? void 0 : o ? Ki(e, t) : e, s = n.length - 1, r; s >= 0; s--)\n    (r = n[s]) && (i = (o ? r(e, t, i) : r(i)) || i);\n  return o && i && Wi(e, t, i), i;\n}, Ce = /* @__PURE__ */ ((n) => (n.Opened = \"toolbox-opened\", n.Closed = \"toolbox-closed\", n.BlockAdded = \"toolbox-block-added\", n))(Ce || {});\nconst lt = class to extends Be {\n  /**\n   * Toolbox constructor\n   *\n   * @param options - available parameters\n   * @param options.api - Editor API methods\n   * @param options.tools - Tools available to check whether some of them should be displayed at the Toolbox or not\n   */\n  constructor({ api: e, tools: t, i18nLabels: o }) {\n    super(), this.opened = !1, this.listeners = new Te(), this.popover = null, this.handleMobileLayoutToggle = () => {\n      this.destroyPopover(), this.initPopover();\n    }, this.onPopoverClose = () => {\n      this.opened = !1, this.emit(\n        \"toolbox-closed\"\n        /* Closed */\n      );\n    }, this.api = e, this.tools = t, this.i18nLabels = o, this.enableShortcuts(), this.nodes = {\n      toolbox: d.make(\"div\", to.CSS.toolbox)\n    }, this.initPopover(), this.api.events.on(xe, this.handleMobileLayoutToggle);\n  }\n  /**\n   * Returns True if Toolbox is Empty and nothing to show\n   *\n   * @returns {boolean}\n   */\n  get isEmpty() {\n    return this.toolsToBeDisplayed.length === 0;\n  }\n  /**\n   * CSS styles\n   */\n  static get CSS() {\n    return {\n      toolbox: \"ce-toolbox\"\n    };\n  }\n  /**\n   * Returns root block settings element\n   */\n  getElement() {\n    return this.nodes.toolbox;\n  }\n  /**\n   * Returns true if the Toolbox has the Flipper activated and the Flipper has selected button\n   */\n  hasFocus() {\n    if (this.popover !== null)\n      return \"hasFocus\" in this.popover ? this.popover.hasFocus() : void 0;\n  }\n  /**\n   * Destroy Module\n   */\n  destroy() {\n    var e;\n    super.destroy(), this.nodes && this.nodes.toolbox && this.nodes.toolbox.remove(), this.removeAllShortcuts(), (e = this.popover) == null || e.off(Z.Closed, this.onPopoverClose), this.listeners.destroy(), this.api.events.off(xe, this.handleMobileLayoutToggle);\n  }\n  /**\n   * Toolbox Tool's button click handler\n   *\n   * @param toolName - tool type to be activated\n   * @param blockDataOverrides - Block data predefined by the activated Toolbox item\n   */\n  toolButtonActivated(e, t) {\n    this.insertNewBlock(e, t);\n  }\n  /**\n   * Open Toolbox with Tools\n   */\n  open() {\n    var e;\n    this.isEmpty || ((e = this.popover) == null || e.show(), this.opened = !0, this.emit(\n      \"toolbox-opened\"\n      /* Opened */\n    ));\n  }\n  /**\n   * Close Toolbox\n   */\n  close() {\n    var e;\n    (e = this.popover) == null || e.hide(), this.opened = !1, this.emit(\n      \"toolbox-closed\"\n      /* Closed */\n    );\n  }\n  /**\n   * Close Toolbox\n   */\n  toggle() {\n    this.opened ? this.close() : this.open();\n  }\n  /**\n   * Creates toolbox popover and appends it inside wrapper element\n   */\n  initPopover() {\n    var t;\n    const e = ue() ? qt : it;\n    this.popover = new e({\n      scopeElement: this.api.ui.nodes.redactor,\n      searchable: !0,\n      messages: {\n        nothingFound: this.i18nLabels.nothingFound,\n        search: this.i18nLabels.filter\n      },\n      items: this.toolboxItemsToBeDisplayed\n    }), this.popover.on(Z.Closed, this.onPopoverClose), (t = this.nodes.toolbox) == null || t.append(this.popover.getElement());\n  }\n  /**\n   * Destroys popover instance and removes it from DOM\n   */\n  destroyPopover() {\n    this.popover !== null && (this.popover.hide(), this.popover.off(Z.Closed, this.onPopoverClose), this.popover.destroy(), this.popover = null), this.nodes.toolbox !== null && (this.nodes.toolbox.innerHTML = \"\");\n  }\n  get toolsToBeDisplayed() {\n    const e = [];\n    return this.tools.forEach((t) => {\n      t.toolbox && e.push(t);\n    }), e;\n  }\n  get toolboxItemsToBeDisplayed() {\n    const e = (t, o) => ({\n      icon: t.icon,\n      title: W.t(V.toolNames, t.title || Oe(o.name)),\n      name: o.name,\n      onActivate: () => {\n        this.toolButtonActivated(o.name, t.data);\n      },\n      secondaryLabel: o.shortcut ? et(o.shortcut) : \"\"\n    });\n    return this.toolsToBeDisplayed.reduce((t, o) => (Array.isArray(o.toolbox) ? o.toolbox.forEach((i) => {\n      t.push(e(i, o));\n    }) : o.toolbox !== void 0 && t.push(e(o.toolbox, o)), t), []);\n  }\n  /**\n   * Iterate all tools and enable theirs shortcuts if specified\n   */\n  enableShortcuts() {\n    this.toolsToBeDisplayed.forEach((e) => {\n      const t = e.shortcut;\n      t && this.enableShortcutForTool(e.name, t);\n    });\n  }\n  /**\n   * Enable shortcut Block Tool implemented shortcut\n   *\n   * @param {string} toolName - Tool name\n   * @param {string} shortcut - shortcut according to the ShortcutData Module format\n   */\n  enableShortcutForTool(e, t) {\n    de.add({\n      name: t,\n      on: this.api.ui.nodes.redactor,\n      handler: async (o) => {\n        o.preventDefault();\n        const i = this.api.blocks.getCurrentBlockIndex(), s = this.api.blocks.getBlockByIndex(i);\n        if (s)\n          try {\n            const r = await this.api.blocks.convert(s.id, e);\n            this.api.caret.setToBlock(r, \"end\");\n            return;\n          } catch {\n          }\n        this.insertNewBlock(e);\n      }\n    });\n  }\n  /**\n   * Removes all added shortcuts\n   * Fired when the Read-Only mode is activated\n   */\n  removeAllShortcuts() {\n    this.toolsToBeDisplayed.forEach((e) => {\n      const t = e.shortcut;\n      t && de.remove(this.api.ui.nodes.redactor, t);\n    });\n  }\n  /**\n   * Inserts new block\n   * Can be called when button clicked on Toolbox or by ShortcutData\n   *\n   * @param {string} toolName - Tool name\n   * @param blockDataOverrides - predefined Block data\n   */\n  async insertNewBlock(e, t) {\n    const o = this.api.blocks.getCurrentBlockIndex(), i = this.api.blocks.getBlockByIndex(o);\n    if (!i)\n      return;\n    const s = i.isEmpty ? o : o + 1;\n    let r;\n    if (t) {\n      const a = await this.api.blocks.composeBlockData(e);\n      r = Object.assign(a, t);\n    }\n    const l = this.api.blocks.insert(\n      e,\n      r,\n      void 0,\n      s,\n      void 0,\n      i.isEmpty\n    );\n    l.call(J.APPEND_CALLBACK), this.api.caret.setToBlock(s), this.emit(\"toolbox-block-added\", {\n      block: l\n    }), this.api.toolbar.close();\n  }\n};\neo([\n  he\n], lt.prototype, \"toolsToBeDisplayed\", 1);\neo([\n  he\n], lt.prototype, \"toolboxItemsToBeDisplayed\", 1);\nlet Xi = lt;\nconst oo = \"block hovered\";\nasync function Vi(n, e) {\n  const t = navigator.keyboard;\n  return t && (await t.getLayoutMap()).get(n) || e;\n}\nclass qi extends y {\n  /**\n   * @class\n   * @param moduleConfiguration - Module Configuration\n   * @param moduleConfiguration.config - Editor's config\n   * @param moduleConfiguration.eventsDispatcher - Editor's event dispatcher\n   */\n  constructor({ config: e, eventsDispatcher: t }) {\n    super({\n      config: e,\n      eventsDispatcher: t\n    }), this.toolboxInstance = null;\n  }\n  /**\n   * CSS styles\n   *\n   * @returns {object}\n   */\n  get CSS() {\n    return {\n      toolbar: \"ce-toolbar\",\n      content: \"ce-toolbar__content\",\n      actions: \"ce-toolbar__actions\",\n      actionsOpened: \"ce-toolbar__actions--opened\",\n      toolbarOpened: \"ce-toolbar--opened\",\n      openedToolboxHolderModifier: \"codex-editor--toolbox-opened\",\n      plusButton: \"ce-toolbar__plus\",\n      plusButtonShortcut: \"ce-toolbar__plus-shortcut\",\n      settingsToggler: \"ce-toolbar__settings-btn\",\n      settingsTogglerHidden: \"ce-toolbar__settings-btn--hidden\"\n    };\n  }\n  /**\n   * Returns the Toolbar opening state\n   *\n   * @returns {boolean}\n   */\n  get opened() {\n    return this.nodes.wrapper.classList.contains(this.CSS.toolbarOpened);\n  }\n  /**\n   * Public interface for accessing the Toolbox\n   */\n  get toolbox() {\n    var e;\n    return {\n      opened: (e = this.toolboxInstance) == null ? void 0 : e.opened,\n      close: () => {\n        var t;\n        (t = this.toolboxInstance) == null || t.close();\n      },\n      open: () => {\n        if (this.toolboxInstance === null) {\n          I(\"toolbox.open() called before initialization is finished\", \"warn\");\n          return;\n        }\n        this.Editor.BlockManager.currentBlock = this.hoveredBlock, this.toolboxInstance.open();\n      },\n      toggle: () => {\n        if (this.toolboxInstance === null) {\n          I(\"toolbox.toggle() called before initialization is finished\", \"warn\");\n          return;\n        }\n        this.toolboxInstance.toggle();\n      },\n      hasFocus: () => {\n        var t;\n        return (t = this.toolboxInstance) == null ? void 0 : t.hasFocus();\n      }\n    };\n  }\n  /**\n   * Block actions appearance manipulations\n   */\n  get blockActions() {\n    return {\n      hide: () => {\n        this.nodes.actions.classList.remove(this.CSS.actionsOpened);\n      },\n      show: () => {\n        this.nodes.actions.classList.add(this.CSS.actionsOpened);\n      }\n    };\n  }\n  /**\n   * Methods for working with Block Tunes toggler\n   */\n  get blockTunesToggler() {\n    return {\n      hide: () => this.nodes.settingsToggler.classList.add(this.CSS.settingsTogglerHidden),\n      show: () => this.nodes.settingsToggler.classList.remove(this.CSS.settingsTogglerHidden)\n    };\n  }\n  /**\n   * Toggles read-only mode\n   *\n   * @param {boolean} readOnlyEnabled - read-only mode\n   */\n  toggleReadOnly(e) {\n    e ? (this.destroy(), this.Editor.BlockSettings.destroy(), this.disableModuleBindings()) : window.requestIdleCallback(() => {\n      this.drawUI(), this.enableModuleBindings();\n    }, { timeout: 2e3 });\n  }\n  /**\n   * Move Toolbar to the passed (or current) Block\n   *\n   * @param block - block to move Toolbar near it\n   */\n  moveAndOpen(e = this.Editor.BlockManager.currentBlock) {\n    if (this.toolboxInstance === null) {\n      I(\"Can't open Toolbar since Editor initialization is not finished yet\", \"warn\");\n      return;\n    }\n    if (this.toolboxInstance.opened && this.toolboxInstance.close(), this.Editor.BlockSettings.opened && this.Editor.BlockSettings.close(), !e)\n      return;\n    this.hoveredBlock = e;\n    const t = e.holder, { isMobile: o } = this.Editor.UI;\n    let i;\n    const s = 20, r = e.firstInput, l = t.getBoundingClientRect(), a = r !== void 0 ? r.getBoundingClientRect() : null, c = a !== null ? a.top - l.top : null, u = c !== null ? c > s : void 0;\n    if (o)\n      i = t.offsetTop + t.offsetHeight;\n    else if (r === void 0 || u) {\n      const h = parseInt(window.getComputedStyle(e.pluginsContent).paddingTop);\n      i = t.offsetTop + h;\n    } else {\n      const h = _o(r), p = parseInt(window.getComputedStyle(this.nodes.plusButton).height, 10), g = 8;\n      i = t.offsetTop + h - p + g + c;\n    }\n    this.nodes.wrapper.style.top = `${Math.floor(i)}px`, this.Editor.BlockManager.blocks.length === 1 && e.isEmpty ? this.blockTunesToggler.hide() : this.blockTunesToggler.show(), this.open();\n  }\n  /**\n   * Close the Toolbar\n   */\n  close() {\n    var e, t;\n    this.Editor.ReadOnly.isEnabled || ((e = this.nodes.wrapper) == null || e.classList.remove(this.CSS.toolbarOpened), this.blockActions.hide(), (t = this.toolboxInstance) == null || t.close(), this.Editor.BlockSettings.close(), this.reset());\n  }\n  /**\n   * Reset the Toolbar position to prevent DOM height growth, for example after blocks deletion\n   */\n  reset() {\n    this.nodes.wrapper.style.top = \"unset\";\n  }\n  /**\n   * Open Toolbar with Plus Button and Actions\n   *\n   * @param {boolean} withBlockActions - by default, Toolbar opens with Block Actions.\n   *                                     This flag allows to open Toolbar without Actions.\n   */\n  open(e = !0) {\n    this.nodes.wrapper.classList.add(this.CSS.toolbarOpened), e ? this.blockActions.show() : this.blockActions.hide();\n  }\n  /**\n   * Draws Toolbar elements\n   */\n  async make() {\n    this.nodes.wrapper = d.make(\"div\", this.CSS.toolbar), [\"content\", \"actions\"].forEach((s) => {\n      this.nodes[s] = d.make(\"div\", this.CSS[s]);\n    }), d.append(this.nodes.wrapper, this.nodes.content), d.append(this.nodes.content, this.nodes.actions), this.nodes.plusButton = d.make(\"div\", this.CSS.plusButton, {\n      innerHTML: qo\n    }), d.append(this.nodes.actions, this.nodes.plusButton), this.readOnlyMutableListeners.on(this.nodes.plusButton, \"click\", () => {\n      _e(!0), this.plusButtonClicked();\n    }, !1);\n    const e = d.make(\"div\");\n    e.appendChild(document.createTextNode(W.ui(V.ui.toolbar.toolbox, \"Add\"))), e.appendChild(d.make(\"div\", this.CSS.plusButtonShortcut, {\n      textContent: \"/\"\n    })), Ne(this.nodes.plusButton, e, {\n      hidingDelay: 400\n    }), this.nodes.settingsToggler = d.make(\"span\", this.CSS.settingsToggler, {\n      innerHTML: Vo\n    }), d.append(this.nodes.actions, this.nodes.settingsToggler);\n    const t = d.make(\"div\"), o = d.text(W.ui(V.ui.blockTunes.toggler, \"Click to tune\")), i = await Vi(\"Slash\", \"/\");\n    t.appendChild(o), t.appendChild(d.make(\"div\", this.CSS.plusButtonShortcut, {\n      textContent: et(`CMD + ${i}`)\n    })), Ne(this.nodes.settingsToggler, t, {\n      hidingDelay: 400\n    }), d.append(this.nodes.actions, this.makeToolbox()), d.append(this.nodes.actions, this.Editor.BlockSettings.getElement()), d.append(this.Editor.UI.nodes.wrapper, this.nodes.wrapper);\n  }\n  /**\n   * Creates the Toolbox instance and return it's rendered element\n   */\n  makeToolbox() {\n    return this.toolboxInstance = new Xi({\n      api: this.Editor.API.methods,\n      tools: this.Editor.Tools.blockTools,\n      i18nLabels: {\n        filter: W.ui(V.ui.popover, \"Filter\"),\n        nothingFound: W.ui(V.ui.popover, \"Nothing found\")\n      }\n    }), this.toolboxInstance.on(Ce.Opened, () => {\n      this.Editor.UI.nodes.wrapper.classList.add(this.CSS.openedToolboxHolderModifier);\n    }), this.toolboxInstance.on(Ce.Closed, () => {\n      this.Editor.UI.nodes.wrapper.classList.remove(this.CSS.openedToolboxHolderModifier);\n    }), this.toolboxInstance.on(Ce.BlockAdded, ({ block: e }) => {\n      const { BlockManager: t, Caret: o } = this.Editor, i = t.getBlockById(e.id);\n      i.inputs.length === 0 && (i === t.lastBlock ? (t.insertAtEnd(), o.setToBlock(t.lastBlock)) : o.setToBlock(t.nextBlock));\n    }), this.toolboxInstance.getElement();\n  }\n  /**\n   * Handler for Plus Button\n   */\n  plusButtonClicked() {\n    var e;\n    this.Editor.BlockManager.currentBlock = this.hoveredBlock, (e = this.toolboxInstance) == null || e.toggle();\n  }\n  /**\n   * Enable bindings\n   */\n  enableModuleBindings() {\n    this.readOnlyMutableListeners.on(this.nodes.settingsToggler, \"mousedown\", (e) => {\n      var t;\n      e.stopPropagation(), this.settingsTogglerClicked(), (t = this.toolboxInstance) != null && t.opened && this.toolboxInstance.close(), _e(!0);\n    }, !0), ue() || this.eventsDispatcher.on(oo, (e) => {\n      var t;\n      this.Editor.BlockSettings.opened || (t = this.toolboxInstance) != null && t.opened || this.moveAndOpen(e.block);\n    });\n  }\n  /**\n   * Disable bindings\n   */\n  disableModuleBindings() {\n    this.readOnlyMutableListeners.clearAll();\n  }\n  /**\n   * Clicks on the Block Settings toggler\n   */\n  settingsTogglerClicked() {\n    this.Editor.BlockManager.currentBlock = this.hoveredBlock, this.Editor.BlockSettings.opened ? this.Editor.BlockSettings.close() : this.Editor.BlockSettings.open(this.hoveredBlock);\n  }\n  /**\n   * Draws Toolbar UI\n   *\n   * Toolbar contains BlockSettings and Toolbox.\n   * That's why at first we draw its components and then Toolbar itself\n   *\n   * Steps:\n   *  - Make Toolbar dependent components like BlockSettings, Toolbox and so on\n   *  - Make itself and append dependent nodes to itself\n   *\n   */\n  drawUI() {\n    this.Editor.BlockSettings.make(), this.make();\n  }\n  /**\n   * Removes all created and saved HTMLElements\n   * It is used in Read-Only mode\n   */\n  destroy() {\n    this.removeAllNodes(), this.toolboxInstance && this.toolboxInstance.destroy();\n  }\n}\nvar Fe = /* @__PURE__ */ ((n) => (n[n.Block = 0] = \"Block\", n[n.Inline = 1] = \"Inline\", n[n.Tune = 2] = \"Tune\", n))(Fe || {}), Se = /* @__PURE__ */ ((n) => (n.Shortcut = \"shortcut\", n.Toolbox = \"toolbox\", n.EnabledInlineTools = \"inlineToolbar\", n.EnabledBlockTunes = \"tunes\", n.Config = \"config\", n))(Se || {}), io = /* @__PURE__ */ ((n) => (n.Shortcut = \"shortcut\", n.SanitizeConfig = \"sanitize\", n))(io || {}), ae = /* @__PURE__ */ ((n) => (n.IsEnabledLineBreaks = \"enableLineBreaks\", n.Toolbox = \"toolbox\", n.ConversionConfig = \"conversionConfig\", n.IsReadOnlySupported = \"isReadOnlySupported\", n.PasteConfig = \"pasteConfig\", n))(ae || {}), at = /* @__PURE__ */ ((n) => (n.IsInline = \"isInline\", n.Title = \"title\", n))(at || {}), Qe = /* @__PURE__ */ ((n) => (n.IsTune = \"isTune\", n))(Qe || {});\nclass ct {\n  /**\n   * @class\n   * @param {ConstructorOptions} options - Constructor options\n   */\n  constructor({\n    name: e,\n    constructable: t,\n    config: o,\n    api: i,\n    isDefault: s,\n    isInternal: r = !1,\n    defaultPlaceholder: l\n  }) {\n    this.api = i, this.name = e, this.constructable = t, this.config = o, this.isDefault = s, this.isInternal = r, this.defaultPlaceholder = l;\n  }\n  /**\n   * Returns Tool user configuration\n   */\n  get settings() {\n    const e = this.config.config || {};\n    return this.isDefault && !(\"placeholder\" in e) && this.defaultPlaceholder && (e.placeholder = this.defaultPlaceholder), e;\n  }\n  /**\n   * Calls Tool's reset method\n   */\n  reset() {\n    if (O(this.constructable.reset))\n      return this.constructable.reset();\n  }\n  /**\n   * Calls Tool's prepare method\n   */\n  prepare() {\n    if (O(this.constructable.prepare))\n      return this.constructable.prepare({\n        toolName: this.name,\n        config: this.settings\n      });\n  }\n  /**\n   * Returns shortcut for Tool (internal or specified by user)\n   */\n  get shortcut() {\n    const e = this.constructable.shortcut;\n    return this.config.shortcut || e;\n  }\n  /**\n   * Returns Tool's sanitizer configuration\n   */\n  get sanitizeConfig() {\n    return this.constructable.sanitize || {};\n  }\n  /**\n   * Returns true if Tools is inline\n   */\n  isInline() {\n    return this.type === 1;\n  }\n  /**\n   * Returns true if Tools is block\n   */\n  isBlock() {\n    return this.type === 0;\n  }\n  /**\n   * Returns true if Tools is tune\n   */\n  isTune() {\n    return this.type === 2;\n  }\n}\nclass Zi extends y {\n  /**\n   * @param moduleConfiguration - Module Configuration\n   * @param moduleConfiguration.config - Editor's config\n   * @param moduleConfiguration.eventsDispatcher - Editor's event dispatcher\n   */\n  constructor({ config: e, eventsDispatcher: t }) {\n    super({\n      config: e,\n      eventsDispatcher: t\n    }), this.CSS = {\n      inlineToolbar: \"ce-inline-toolbar\"\n    }, this.opened = !1, this.popover = null, this.toolbarVerticalMargin = ue() ? 20 : 6, this.toolsInstances = /* @__PURE__ */ new Map();\n  }\n  /**\n   * Toggles read-only mode\n   *\n   * @param {boolean} readOnlyEnabled - read-only mode\n   */\n  toggleReadOnly(e) {\n    e ? this.destroy() : window.requestIdleCallback(() => {\n      this.make();\n    }, { timeout: 2e3 });\n  }\n  /**\n   *  Moving / appearance\n   *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n   */\n  /**\n   * Shows Inline Toolbar if something is selected\n   *\n   * @param [needToClose] - pass true to close toolbar if it is not allowed.\n   *                                  Avoid to use it just for closing IT, better call .close() clearly.\n   */\n  async tryToShow(e = !1) {\n    e && this.close(), this.allowedToShow() && (await this.open(), this.Editor.Toolbar.close());\n  }\n  /**\n   * Hides Inline Toolbar\n   */\n  close() {\n    var e, t;\n    this.opened && (this.Editor.ReadOnly.isEnabled || (Array.from(this.toolsInstances.entries()).forEach(([o, i]) => {\n      const s = this.getToolShortcut(o);\n      s && de.remove(this.Editor.UI.nodes.redactor, s), O(i.clear) && i.clear();\n    }), this.toolsInstances = null, this.reset(), this.opened = !1, (e = this.popover) == null || e.hide(), (t = this.popover) == null || t.destroy(), this.popover = null));\n  }\n  /**\n   * Check if node is contained by Inline Toolbar\n   *\n   * @param {Node} node  node to check\n   */\n  containsNode(e) {\n    return this.nodes.wrapper === void 0 ? !1 : this.nodes.wrapper.contains(e);\n  }\n  /**\n   * Removes UI and its components\n   */\n  destroy() {\n    var e;\n    this.removeAllNodes(), (e = this.popover) == null || e.destroy(), this.popover = null;\n  }\n  /**\n   * Making DOM\n   */\n  make() {\n    this.nodes.wrapper = d.make(\"div\", [\n      this.CSS.inlineToolbar,\n      ...this.isRtl ? [this.Editor.UI.CSS.editorRtlFix] : []\n    ]), d.append(this.Editor.UI.nodes.wrapper, this.nodes.wrapper);\n  }\n  /**\n   * Shows Inline Toolbar\n   */\n  async open() {\n    var t;\n    if (this.opened)\n      return;\n    this.opened = !0, this.popover !== null && this.popover.destroy();\n    const e = await this.getInlineTools();\n    this.popover = new di({\n      items: e,\n      scopeElement: this.Editor.API.methods.ui.nodes.redactor,\n      messages: {\n        nothingFound: W.ui(V.ui.popover, \"Nothing found\"),\n        search: W.ui(V.ui.popover, \"Filter\")\n      }\n    }), this.move(this.popover.size.width), (t = this.nodes.wrapper) == null || t.append(this.popover.getElement()), this.popover.show();\n  }\n  /**\n   * Move Toolbar to the selected text\n   *\n   * @param popoverWidth - width of the toolbar popover\n   */\n  move(e) {\n    const t = b.rect, o = this.Editor.UI.nodes.wrapper.getBoundingClientRect(), i = {\n      x: t.x - o.x,\n      y: t.y + t.height - // + window.scrollY\n      o.top + this.toolbarVerticalMargin\n    };\n    i.x + e + o.x > this.Editor.UI.contentRect.right && (i.x = this.Editor.UI.contentRect.right - e - o.x), this.nodes.wrapper.style.left = Math.floor(i.x) + \"px\", this.nodes.wrapper.style.top = Math.floor(i.y) + \"px\";\n  }\n  /**\n   * Clear orientation classes and reset position\n   */\n  reset() {\n    this.nodes.wrapper.style.left = \"0\", this.nodes.wrapper.style.top = \"0\";\n  }\n  /**\n   * Need to show Inline Toolbar or not\n   */\n  allowedToShow() {\n    const e = [\"IMG\", \"INPUT\"], t = b.get(), o = b.text;\n    if (!t || !t.anchorNode || t.isCollapsed || o.length < 1)\n      return !1;\n    const i = d.isElement(t.anchorNode) ? t.anchorNode : t.anchorNode.parentElement;\n    if (i === null || t && e.includes(i.tagName) || i.closest('[contenteditable=\"true\"]') === null)\n      return !1;\n    const r = this.Editor.BlockManager.getBlock(t.anchorNode);\n    return r ? r.tool.inlineTools.size !== 0 : !1;\n  }\n  /**\n   *  Working with Tools\n   *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n   */\n  /**\n   * Returns Inline Tools segregated by their appearance type: popover items and custom html elements.\n   * Sets this.toolsInstances map\n   */\n  async getInlineTools() {\n    const e = b.get(), t = this.Editor.BlockManager.getBlock(e.anchorNode), o = Array.from(t.tool.inlineTools.values()), i = [];\n    this.toolsInstances === null && (this.toolsInstances = /* @__PURE__ */ new Map());\n    for (let s = 0; s < o.length; s++) {\n      const r = o[s], l = r.create(), a = await l.render();\n      this.toolsInstances.set(r.name, l);\n      const c = this.getToolShortcut(r.name);\n      if (c)\n        try {\n          this.enableShortcuts(r.name, c);\n        } catch {\n        }\n      const u = c !== void 0 ? et(c) : void 0, h = W.t(\n        V.toolNames,\n        r.title || Oe(r.name)\n      );\n      [a].flat().forEach((p) => {\n        var f, k;\n        const g = {\n          name: r.name,\n          onActivate: () => {\n            this.toolClicked(l);\n          },\n          hint: {\n            title: h,\n            description: u\n          }\n        };\n        if (d.isElement(p)) {\n          const C = {\n            ...g,\n            element: p,\n            type: A.Html\n          };\n          if (O(l.renderActions)) {\n            const S = l.renderActions();\n            C.children = {\n              isOpen: (f = l.checkState) == null ? void 0 : f.call(l, b.get()),\n              /** Disable keyboard navigation in actions, as it might conflict with enter press handling */\n              isFlippable: !1,\n              items: [\n                {\n                  type: A.Html,\n                  element: S\n                }\n              ]\n            };\n          } else\n            (k = l.checkState) == null || k.call(l, b.get());\n          i.push(C);\n        } else if (p.type === A.Html)\n          i.push({\n            ...g,\n            ...p,\n            type: A.Html\n          });\n        else if (p.type === A.Separator)\n          i.push({\n            type: A.Separator\n          });\n        else {\n          const C = {\n            ...g,\n            ...p,\n            type: A.Default\n          };\n          \"children\" in C && s !== 0 && i.push({\n            type: A.Separator\n          }), i.push(C), \"children\" in C && s < o.length - 1 && i.push({\n            type: A.Separator\n          });\n        }\n      });\n    }\n    return i;\n  }\n  /**\n   * Get shortcut name for tool\n   *\n   * @param toolName  Tool name\n   */\n  getToolShortcut(e) {\n    const { Tools: t } = this.Editor, o = t.inlineTools.get(e), i = t.internal.inlineTools;\n    return Array.from(i.keys()).includes(e) ? this.inlineTools[e][io.Shortcut] : o == null ? void 0 : o.shortcut;\n  }\n  /**\n   * Enable Tool shortcut with Editor Shortcuts Module\n   *\n   * @param toolName - tool name\n   * @param shortcut - shortcut according to the ShortcutData Module format\n   */\n  enableShortcuts(e, t) {\n    de.add({\n      name: t,\n      handler: (o) => {\n        var s;\n        const { currentBlock: i } = this.Editor.BlockManager;\n        i && i.tool.enabledInlineTools && (o.preventDefault(), (s = this.popover) == null || s.activateItemByName(e));\n      },\n      on: this.Editor.UI.nodes.redactor\n    });\n  }\n  /**\n   * Inline Tool button clicks\n   *\n   * @param tool - Tool's instance\n   */\n  toolClicked(e) {\n    var o;\n    const t = b.range;\n    (o = e.surround) == null || o.call(e, t), this.checkToolsState();\n  }\n  /**\n   * Check Tools` state by selection\n   */\n  checkToolsState() {\n    var e;\n    (e = this.toolsInstances) == null || e.forEach((t) => {\n      var o;\n      (o = t.checkState) == null || o.call(t, b.get());\n    });\n  }\n  /**\n   * Get inline tools tools\n   * Tools that has isInline is true\n   */\n  get inlineTools() {\n    const e = {};\n    return Array.from(this.Editor.Tools.inlineTools.entries()).forEach(([t, o]) => {\n      e[t] = o.create();\n    }), e;\n  }\n}\nfunction so() {\n  const n = window.getSelection();\n  if (n === null)\n    return [null, 0];\n  let e = n.focusNode, t = n.focusOffset;\n  return e === null ? [null, 0] : (e.nodeType !== Node.TEXT_NODE && e.childNodes.length > 0 && (e.childNodes[t] ? (e = e.childNodes[t], t = 0) : (e = e.childNodes[t - 1], t = e.textContent.length)), [e, t]);\n}\nfunction no(n, e, t, o) {\n  const i = document.createRange();\n  o === \"left\" ? (i.setStart(n, 0), i.setEnd(e, t)) : (i.setStart(e, t), i.setEnd(n, n.childNodes.length));\n  const s = i.cloneContents(), r = document.createElement(\"div\");\n  r.appendChild(s);\n  const l = r.textContent || \"\";\n  return Lo(l);\n}\nfunction Ie(n) {\n  const e = d.getDeepestNode(n);\n  if (e === null || d.isEmpty(n))\n    return !0;\n  if (d.isNativeInput(e))\n    return e.selectionEnd === 0;\n  if (d.isEmpty(n))\n    return !0;\n  const [t, o] = so();\n  return t === null ? !1 : no(n, t, o, \"left\");\n}\nfunction Me(n) {\n  const e = d.getDeepestNode(n, !0);\n  if (e === null)\n    return !0;\n  if (d.isNativeInput(e))\n    return e.selectionEnd === e.value.length;\n  const [t, o] = so();\n  return t === null ? !1 : no(n, t, o, \"right\");\n}\nclass Gi extends y {\n  /**\n   * All keydowns on Block\n   *\n   * @param {KeyboardEvent} event - keydown\n   */\n  keydown(e) {\n    switch (this.beforeKeydownProcessing(e), e.keyCode) {\n      case w.BACKSPACE:\n        this.backspace(e);\n        break;\n      case w.DELETE:\n        this.delete(e);\n        break;\n      case w.ENTER:\n        this.enter(e);\n        break;\n      case w.DOWN:\n      case w.RIGHT:\n        this.arrowRightAndDown(e);\n        break;\n      case w.UP:\n      case w.LEFT:\n        this.arrowLeftAndUp(e);\n        break;\n      case w.TAB:\n        this.tabPressed(e);\n        break;\n    }\n    e.key === \"/\" && !e.ctrlKey && !e.metaKey && this.slashPressed(e), e.code === \"Slash\" && (e.ctrlKey || e.metaKey) && (e.preventDefault(), this.commandSlashPressed());\n  }\n  /**\n   * Fires on keydown before event processing\n   *\n   * @param {KeyboardEvent} event - keydown\n   */\n  beforeKeydownProcessing(e) {\n    this.needToolbarClosing(e) && It(e.keyCode) && (this.Editor.Toolbar.close(), e.ctrlKey || e.metaKey || e.altKey || e.shiftKey || this.Editor.BlockSelection.clearSelection(e));\n  }\n  /**\n   * Key up on Block:\n   * - shows Inline Toolbar if something selected\n   * - shows conversion toolbar with 85% of block selection\n   *\n   * @param {KeyboardEvent} event - keyup event\n   */\n  keyup(e) {\n    e.shiftKey || this.Editor.UI.checkEmptiness();\n  }\n  /**\n   * Add drop target styles\n   *\n   * @param {DragEvent} event - drag over event\n   */\n  dragOver(e) {\n    const t = this.Editor.BlockManager.getBlockByChildNode(e.target);\n    t.dropTarget = !0;\n  }\n  /**\n   * Remove drop target style\n   *\n   * @param {DragEvent} event - drag leave event\n   */\n  dragLeave(e) {\n    const t = this.Editor.BlockManager.getBlockByChildNode(e.target);\n    t.dropTarget = !1;\n  }\n  /**\n   * Copying selected blocks\n   * Before putting to the clipboard we sanitize all blocks and then copy to the clipboard\n   *\n   * @param {ClipboardEvent} event - clipboard event\n   */\n  handleCommandC(e) {\n    const { BlockSelection: t } = this.Editor;\n    t.anyBlockSelected && t.copySelectedBlocks(e);\n  }\n  /**\n   * Copy and Delete selected Blocks\n   *\n   * @param {ClipboardEvent} event - clipboard event\n   */\n  handleCommandX(e) {\n    const { BlockSelection: t, BlockManager: o, Caret: i } = this.Editor;\n    t.anyBlockSelected && t.copySelectedBlocks(e).then(() => {\n      const s = o.removeSelectedBlocks(), r = o.insertDefaultBlockAtIndex(s, !0);\n      i.setToBlock(r, i.positions.START), t.clearSelection(e);\n    });\n  }\n  /**\n   * Tab pressed inside a Block.\n   *\n   * @param {KeyboardEvent} event - keydown\n   */\n  tabPressed(e) {\n    const { InlineToolbar: t, Caret: o } = this.Editor;\n    if (t.opened)\n      return;\n    (e.shiftKey ? o.navigatePrevious(!0) : o.navigateNext(!0)) && e.preventDefault();\n  }\n  /**\n   * '/' + 'command' keydown inside a Block\n   */\n  commandSlashPressed() {\n    this.Editor.BlockSelection.selectedBlocks.length > 1 || this.activateBlockSettings();\n  }\n  /**\n   * '/' keydown inside a Block\n   *\n   * @param event - keydown\n   */\n  slashPressed(e) {\n    this.Editor.BlockManager.currentBlock.isEmpty && (e.preventDefault(), this.Editor.Caret.insertContentAtCaretPosition(\"/\"), this.activateToolbox());\n  }\n  /**\n   * ENTER pressed on block\n   *\n   * @param {KeyboardEvent} event - keydown\n   */\n  enter(e) {\n    const { BlockManager: t, UI: o } = this.Editor, i = t.currentBlock;\n    if (i === void 0 || i.tool.isLineBreaksEnabled || o.someToolbarOpened && o.someFlipperButtonFocused || e.shiftKey && !Ge)\n      return;\n    let s = i;\n    i.currentInput !== void 0 && Ie(i.currentInput) && !i.hasMedia ? this.Editor.BlockManager.insertDefaultBlockAtIndex(this.Editor.BlockManager.currentBlockIndex) : i.currentInput && Me(i.currentInput) ? s = this.Editor.BlockManager.insertDefaultBlockAtIndex(this.Editor.BlockManager.currentBlockIndex + 1) : s = this.Editor.BlockManager.split(), this.Editor.Caret.setToBlock(s), this.Editor.Toolbar.moveAndOpen(s), e.preventDefault();\n  }\n  /**\n   * Handle backspace keydown on Block\n   *\n   * @param {KeyboardEvent} event - keydown\n   */\n  backspace(e) {\n    const { BlockManager: t, Caret: o } = this.Editor, { currentBlock: i, previousBlock: s } = t;\n    if (i === void 0 || !b.isCollapsed || !i.currentInput || !Ie(i.currentInput))\n      return;\n    if (e.preventDefault(), this.Editor.Toolbar.close(), !(i.currentInput === i.firstInput)) {\n      o.navigatePrevious();\n      return;\n    }\n    if (s === null)\n      return;\n    if (s.isEmpty) {\n      t.removeBlock(s);\n      return;\n    }\n    if (i.isEmpty) {\n      t.removeBlock(i);\n      const a = t.currentBlock;\n      o.setToBlock(a, o.positions.END);\n      return;\n    }\n    vt(s, i) ? this.mergeBlocks(s, i) : o.setToBlock(s, o.positions.END);\n  }\n  /**\n   * Handles delete keydown on Block\n   * Removes char after the caret.\n   * If caret is at the end of the block, merge next block with current\n   *\n   * @param {KeyboardEvent} event - keydown\n   */\n  delete(e) {\n    const { BlockManager: t, Caret: o } = this.Editor, { currentBlock: i, nextBlock: s } = t;\n    if (!b.isCollapsed || !Me(i.currentInput))\n      return;\n    if (e.preventDefault(), this.Editor.Toolbar.close(), !(i.currentInput === i.lastInput)) {\n      o.navigateNext();\n      return;\n    }\n    if (s === null)\n      return;\n    if (s.isEmpty) {\n      t.removeBlock(s);\n      return;\n    }\n    if (i.isEmpty) {\n      t.removeBlock(i), o.setToBlock(s, o.positions.START);\n      return;\n    }\n    vt(i, s) ? this.mergeBlocks(i, s) : o.setToBlock(s, o.positions.START);\n  }\n  /**\n   * Merge passed Blocks\n   *\n   * @param targetBlock - to which Block we want to merge\n   * @param blockToMerge - what Block we want to merge\n   */\n  mergeBlocks(e, t) {\n    const { BlockManager: o, Caret: i, Toolbar: s } = this.Editor;\n    i.createShadow(e.lastInput), o.mergeBlocks(e, t).then(() => {\n      i.restoreCaret(e.pluginsContent), s.close();\n    });\n  }\n  /**\n   * Handle right and down keyboard keys\n   *\n   * @param {KeyboardEvent} event - keyboard event\n   */\n  arrowRightAndDown(e) {\n    const t = re.usedKeys.includes(e.keyCode) && (!e.shiftKey || e.keyCode === w.TAB);\n    if (this.Editor.UI.someToolbarOpened && t)\n      return;\n    this.Editor.Toolbar.close();\n    const { currentBlock: o } = this.Editor.BlockManager, s = ((o == null ? void 0 : o.currentInput) !== void 0 ? Me(o.currentInput) : void 0) || this.Editor.BlockSelection.anyBlockSelected;\n    if (e.shiftKey && e.keyCode === w.DOWN && s) {\n      this.Editor.CrossBlockSelection.toggleBlockSelectedState();\n      return;\n    }\n    if (e.keyCode === w.DOWN || e.keyCode === w.RIGHT && !this.isRtl ? this.Editor.Caret.navigateNext() : this.Editor.Caret.navigatePrevious()) {\n      e.preventDefault();\n      return;\n    }\n    Ae(() => {\n      this.Editor.BlockManager.currentBlock && this.Editor.BlockManager.currentBlock.updateCurrentInput();\n    }, 20)(), this.Editor.BlockSelection.clearSelection(e);\n  }\n  /**\n   * Handle left and up keyboard keys\n   *\n   * @param {KeyboardEvent} event - keyboard event\n   */\n  arrowLeftAndUp(e) {\n    if (this.Editor.UI.someToolbarOpened) {\n      if (re.usedKeys.includes(e.keyCode) && (!e.shiftKey || e.keyCode === w.TAB))\n        return;\n      this.Editor.UI.closeAllToolbars();\n    }\n    this.Editor.Toolbar.close();\n    const { currentBlock: t } = this.Editor.BlockManager, i = ((t == null ? void 0 : t.currentInput) !== void 0 ? Ie(t.currentInput) : void 0) || this.Editor.BlockSelection.anyBlockSelected;\n    if (e.shiftKey && e.keyCode === w.UP && i) {\n      this.Editor.CrossBlockSelection.toggleBlockSelectedState(!1);\n      return;\n    }\n    if (e.keyCode === w.UP || e.keyCode === w.LEFT && !this.isRtl ? this.Editor.Caret.navigatePrevious() : this.Editor.Caret.navigateNext()) {\n      e.preventDefault();\n      return;\n    }\n    Ae(() => {\n      this.Editor.BlockManager.currentBlock && this.Editor.BlockManager.currentBlock.updateCurrentInput();\n    }, 20)(), this.Editor.BlockSelection.clearSelection(e);\n  }\n  /**\n   * Cases when we need to close Toolbar\n   *\n   * @param {KeyboardEvent} event - keyboard event\n   */\n  needToolbarClosing(e) {\n    const t = e.keyCode === w.ENTER && this.Editor.Toolbar.toolbox.opened, o = e.keyCode === w.ENTER && this.Editor.BlockSettings.opened, i = e.keyCode === w.ENTER && this.Editor.InlineToolbar.opened, s = e.keyCode === w.TAB;\n    return !(e.shiftKey || s || t || o || i);\n  }\n  /**\n   * If Toolbox is not open, then just open it and show plus button\n   */\n  activateToolbox() {\n    this.Editor.Toolbar.opened || this.Editor.Toolbar.moveAndOpen(), this.Editor.Toolbar.toolbox.open();\n  }\n  /**\n   * Open Toolbar and show BlockSettings before flipping Tools\n   */\n  activateBlockSettings() {\n    this.Editor.Toolbar.opened || this.Editor.Toolbar.moveAndOpen(), this.Editor.BlockSettings.opened || this.Editor.BlockSettings.open();\n  }\n}\nclass Xe {\n  /**\n   * @class\n   * @param {HTMLElement} workingArea  editor`s working node\n   */\n  constructor(e) {\n    this.blocks = [], this.workingArea = e;\n  }\n  /**\n   * Get length of Block instances array\n   *\n   * @returns {number}\n   */\n  get length() {\n    return this.blocks.length;\n  }\n  /**\n   * Get Block instances array\n   *\n   * @returns {Block[]}\n   */\n  get array() {\n    return this.blocks;\n  }\n  /**\n   * Get blocks html elements array\n   *\n   * @returns {HTMLElement[]}\n   */\n  get nodes() {\n    return Mt(this.workingArea.children);\n  }\n  /**\n   * Proxy trap to implement array-like setter\n   *\n   * @example\n   * blocks[0] = new Block(...)\n   * @param {Blocks} instance  Blocks instance\n   * @param {PropertyKey} property  block index or any Blocks class property key to set\n   * @param {Block} value  value to set\n   * @returns {boolean}\n   */\n  static set(e, t, o) {\n    return isNaN(Number(t)) ? (Reflect.set(e, t, o), !0) : (e.insert(+t, o), !0);\n  }\n  /**\n   * Proxy trap to implement array-like getter\n   *\n   * @param {Blocks} instance  Blocks instance\n   * @param {PropertyKey} property  Blocks class property key\n   * @returns {Block|*}\n   */\n  static get(e, t) {\n    return isNaN(Number(t)) ? Reflect.get(e, t) : e.get(+t);\n  }\n  /**\n   * Push new Block to the blocks array and append it to working area\n   *\n   * @param {Block} block - Block to add\n   */\n  push(e) {\n    this.blocks.push(e), this.insertToDOM(e);\n  }\n  /**\n   * Swaps blocks with indexes first and second\n   *\n   * @param {number} first - first block index\n   * @param {number} second - second block index\n   * @deprecated  use 'move' instead\n   */\n  swap(e, t) {\n    const o = this.blocks[t];\n    d.swap(this.blocks[e].holder, o.holder), this.blocks[t] = this.blocks[e], this.blocks[e] = o;\n  }\n  /**\n   * Move a block from one to another index\n   *\n   * @param {number} toIndex - new index of the block\n   * @param {number} fromIndex - block to move\n   */\n  move(e, t) {\n    const o = this.blocks.splice(t, 1)[0], i = e - 1, s = Math.max(0, i), r = this.blocks[s];\n    e > 0 ? this.insertToDOM(o, \"afterend\", r) : this.insertToDOM(o, \"beforebegin\", r), this.blocks.splice(e, 0, o);\n    const l = this.composeBlockEvent(\"move\", {\n      fromIndex: t,\n      toIndex: e\n    });\n    o.call(J.MOVED, l);\n  }\n  /**\n   * Insert new Block at passed index\n   *\n   * @param {number} index  index to insert Block\n   * @param {Block} block  Block to insert\n   * @param {boolean} replace  it true, replace block on given index\n   */\n  insert(e, t, o = !1) {\n    if (!this.length) {\n      this.push(t);\n      return;\n    }\n    e > this.length && (e = this.length), o && (this.blocks[e].holder.remove(), this.blocks[e].call(J.REMOVED));\n    const i = o ? 1 : 0;\n    if (this.blocks.splice(e, i, t), e > 0) {\n      const s = this.blocks[e - 1];\n      this.insertToDOM(t, \"afterend\", s);\n    } else {\n      const s = this.blocks[e + 1];\n      s ? this.insertToDOM(t, \"beforebegin\", s) : this.insertToDOM(t);\n    }\n  }\n  /**\n   * Replaces block under passed index with passed block\n   *\n   * @param index - index of existed block\n   * @param block - new block\n   */\n  replace(e, t) {\n    if (this.blocks[e] === void 0)\n      throw Error(\"Incorrect index\");\n    this.blocks[e].holder.replaceWith(t.holder), this.blocks[e] = t;\n  }\n  /**\n   * Inserts several blocks at once\n   *\n   * @param blocks - blocks to insert\n   * @param index - index to insert blocks at\n   */\n  insertMany(e, t) {\n    const o = new DocumentFragment();\n    for (const i of e)\n      o.appendChild(i.holder);\n    if (this.length > 0) {\n      if (t > 0) {\n        const i = Math.min(t - 1, this.length - 1);\n        this.blocks[i].holder.after(o);\n      } else\n        t === 0 && this.workingArea.prepend(o);\n      this.blocks.splice(t, 0, ...e);\n    } else\n      this.blocks.push(...e), this.workingArea.appendChild(o);\n    e.forEach((i) => i.call(J.RENDERED));\n  }\n  /**\n   * Remove block\n   *\n   * @param {number} index - index of Block to remove\n   */\n  remove(e) {\n    isNaN(e) && (e = this.length - 1), this.blocks[e].holder.remove(), this.blocks[e].call(J.REMOVED), this.blocks.splice(e, 1);\n  }\n  /**\n   * Remove all blocks\n   */\n  removeAll() {\n    this.workingArea.innerHTML = \"\", this.blocks.forEach((e) => e.call(J.REMOVED)), this.blocks.length = 0;\n  }\n  /**\n   * Insert Block after passed target\n   *\n   * @todo decide if this method is necessary\n   * @param {Block} targetBlock  target after which Block should be inserted\n   * @param {Block} newBlock  Block to insert\n   */\n  insertAfter(e, t) {\n    const o = this.blocks.indexOf(e);\n    this.insert(o + 1, t);\n  }\n  /**\n   * Get Block by index\n   *\n   * @param {number} index  Block index\n   * @returns {Block}\n   */\n  get(e) {\n    return this.blocks[e];\n  }\n  /**\n   * Return index of passed Block\n   *\n   * @param {Block} block - Block to find\n   * @returns {number}\n   */\n  indexOf(e) {\n    return this.blocks.indexOf(e);\n  }\n  /**\n   * Insert new Block into DOM\n   *\n   * @param {Block} block - Block to insert\n   * @param {InsertPosition} position  insert position (if set, will use insertAdjacentElement)\n   * @param {Block} target  Block related to position\n   */\n  insertToDOM(e, t, o) {\n    t ? o.holder.insertAdjacentElement(t, e.holder) : this.workingArea.appendChild(e.holder), e.call(J.RENDERED);\n  }\n  /**\n   * Composes Block event with passed type and details\n   *\n   * @param {string} type - event type\n   * @param {object} detail - event detail\n   */\n  composeBlockEvent(e, t) {\n    return new CustomEvent(e, {\n      detail: t\n    });\n  }\n}\nconst Bt = \"block-removed\", Tt = \"block-added\", Ji = \"block-moved\", Ct = \"block-changed\";\nclass Qi {\n  constructor() {\n    this.completed = Promise.resolve();\n  }\n  /**\n   * Add new promise to queue\n   *\n   * @param operation - promise should be added to queue\n   */\n  add(e) {\n    return new Promise((t, o) => {\n      this.completed = this.completed.then(e).then(t).catch(o);\n    });\n  }\n}\nclass es extends y {\n  constructor() {\n    super(...arguments), this._currentBlockIndex = -1, this._blocks = null;\n  }\n  /**\n   * Returns current Block index\n   *\n   * @returns {number}\n   */\n  get currentBlockIndex() {\n    return this._currentBlockIndex;\n  }\n  /**\n   * Set current Block index and fire Block lifecycle callbacks\n   *\n   * @param {number} newIndex - index of Block to set as current\n   */\n  set currentBlockIndex(e) {\n    this._currentBlockIndex = e;\n  }\n  /**\n   * returns first Block\n   *\n   * @returns {Block}\n   */\n  get firstBlock() {\n    return this._blocks[0];\n  }\n  /**\n   * returns last Block\n   *\n   * @returns {Block}\n   */\n  get lastBlock() {\n    return this._blocks[this._blocks.length - 1];\n  }\n  /**\n   * Get current Block instance\n   *\n   * @returns {Block}\n   */\n  get currentBlock() {\n    return this._blocks[this.currentBlockIndex];\n  }\n  /**\n   * Set passed Block as a current\n   *\n   * @param block - block to set as a current\n   */\n  set currentBlock(e) {\n    this.currentBlockIndex = this.getBlockIndex(e);\n  }\n  /**\n   * Returns next Block instance\n   *\n   * @returns {Block|null}\n   */\n  get nextBlock() {\n    return this.currentBlockIndex === this._blocks.length - 1 ? null : this._blocks[this.currentBlockIndex + 1];\n  }\n  /**\n   * Return first Block with inputs after current Block\n   *\n   * @returns {Block | undefined}\n   */\n  get nextContentfulBlock() {\n    return this.blocks.slice(this.currentBlockIndex + 1).find((t) => !!t.inputs.length);\n  }\n  /**\n   * Return first Block with inputs before current Block\n   *\n   * @returns {Block | undefined}\n   */\n  get previousContentfulBlock() {\n    return this.blocks.slice(0, this.currentBlockIndex).reverse().find((t) => !!t.inputs.length);\n  }\n  /**\n   * Returns previous Block instance\n   *\n   * @returns {Block|null}\n   */\n  get previousBlock() {\n    return this.currentBlockIndex === 0 ? null : this._blocks[this.currentBlockIndex - 1];\n  }\n  /**\n   * Get array of Block instances\n   *\n   * @returns {Block[]} {@link Blocks#array}\n   */\n  get blocks() {\n    return this._blocks.array;\n  }\n  /**\n   * Check if each Block is empty\n   *\n   * @returns {boolean}\n   */\n  get isEditorEmpty() {\n    return this.blocks.every((e) => e.isEmpty);\n  }\n  /**\n   * Should be called after Editor.UI preparation\n   * Define this._blocks property\n   */\n  prepare() {\n    const e = new Xe(this.Editor.UI.nodes.redactor);\n    this._blocks = new Proxy(e, {\n      set: Xe.set,\n      get: Xe.get\n    }), this.listeners.on(\n      document,\n      \"copy\",\n      (t) => this.Editor.BlockEvents.handleCommandC(t)\n    );\n  }\n  /**\n   * Toggle read-only state\n   *\n   * If readOnly is true:\n   *  - Unbind event handlers from created Blocks\n   *\n   * if readOnly is false:\n   *  - Bind event handlers to all existing Blocks\n   *\n   * @param {boolean} readOnlyEnabled - \"read only\" state\n   */\n  toggleReadOnly(e) {\n    e ? this.disableModuleBindings() : this.enableModuleBindings();\n  }\n  /**\n   * Creates Block instance by tool name\n   *\n   * @param {object} options - block creation options\n   * @param {string} options.tool - tools passed in editor config {@link EditorConfig#tools}\n   * @param {string} [options.id] - unique id for this block\n   * @param {BlockToolData} [options.data] - constructor params\n   * @returns {Block}\n   */\n  composeBlock({\n    tool: e,\n    data: t = {},\n    id: o = void 0,\n    tunes: i = {}\n  }) {\n    const s = this.Editor.ReadOnly.isEnabled, r = this.Editor.Tools.blockTools.get(e), l = new D({\n      id: o,\n      data: t,\n      tool: r,\n      api: this.Editor.API,\n      readOnly: s,\n      tunesData: i\n    }, this.eventsDispatcher);\n    return s || window.requestIdleCallback(() => {\n      this.bindBlockEvents(l);\n    }, { timeout: 2e3 }), l;\n  }\n  /**\n   * Insert new block into _blocks\n   *\n   * @param {object} options - insert options\n   * @param {string} [options.id] - block's unique id\n   * @param {string} [options.tool] - plugin name, by default method inserts the default block type\n   * @param {object} [options.data] - plugin data\n   * @param {number} [options.index] - index where to insert new Block\n   * @param {boolean} [options.needToFocus] - flag shows if needed to update current Block index\n   * @param {boolean} [options.replace] - flag shows if block by passed index should be replaced with inserted one\n   * @returns {Block}\n   */\n  insert({\n    id: e = void 0,\n    tool: t = this.config.defaultBlock,\n    data: o = {},\n    index: i,\n    needToFocus: s = !0,\n    replace: r = !1,\n    tunes: l = {}\n  } = {}) {\n    let a = i;\n    a === void 0 && (a = this.currentBlockIndex + (r ? 0 : 1));\n    const c = this.composeBlock({\n      id: e,\n      tool: t,\n      data: o,\n      tunes: l\n    });\n    return r && this.blockDidMutated(Bt, this.getBlockByIndex(a), {\n      index: a\n    }), this._blocks.insert(a, c, r), this.blockDidMutated(Tt, c, {\n      index: a\n    }), s ? this.currentBlockIndex = a : a <= this.currentBlockIndex && this.currentBlockIndex++, c;\n  }\n  /**\n   * Inserts several blocks at once\n   *\n   * @param blocks - blocks to insert\n   * @param index - index where to insert\n   */\n  insertMany(e, t = 0) {\n    this._blocks.insertMany(e, t);\n  }\n  /**\n   * Update Block data.\n   *\n   * Currently we don't have an 'update' method in the Tools API, so we just create a new block with the same id and type\n   * Should not trigger 'block-removed' or 'block-added' events.\n   *\n   * If neither data nor tunes is provided, return the provided block instead.\n   *\n   * @param block - block to update\n   * @param data - (optional) new data\n   * @param tunes - (optional) tune data\n   */\n  async update(e, t, o) {\n    if (!t && !o)\n      return e;\n    const i = await e.data, s = this.composeBlock({\n      id: e.id,\n      tool: e.name,\n      data: Object.assign({}, i, t ?? {}),\n      tunes: o ?? e.tunes\n    }), r = this.getBlockIndex(e);\n    return this._blocks.replace(r, s), this.blockDidMutated(Ct, s, {\n      index: r\n    }), s;\n  }\n  /**\n   * Replace passed Block with the new one with specified Tool and data\n   *\n   * @param block - block to replace\n   * @param newTool - new Tool name\n   * @param data - new Tool data\n   */\n  replace(e, t, o) {\n    const i = this.getBlockIndex(e);\n    return this.insert({\n      tool: t,\n      data: o,\n      index: i,\n      replace: !0\n    });\n  }\n  /**\n   * Insert pasted content. Call onPaste callback after insert.\n   *\n   * @param {string} toolName - name of Tool to insert\n   * @param {PasteEvent} pasteEvent - pasted data\n   * @param {boolean} replace - should replace current block\n   */\n  paste(e, t, o = !1) {\n    const i = this.insert({\n      tool: e,\n      replace: o\n    });\n    try {\n      window.requestIdleCallback(() => {\n        i.call(J.ON_PASTE, t);\n      });\n    } catch (s) {\n      I(`${e}: onPaste callback call is failed`, \"error\", s);\n    }\n    return i;\n  }\n  /**\n   * Insert new default block at passed index\n   *\n   * @param {number} index - index where Block should be inserted\n   * @param {boolean} needToFocus - if true, updates current Block index\n   *\n   * TODO: Remove method and use insert() with index instead (?)\n   * @returns {Block} inserted Block\n   */\n  insertDefaultBlockAtIndex(e, t = !1) {\n    const o = this.composeBlock({ tool: this.config.defaultBlock });\n    return this._blocks[e] = o, this.blockDidMutated(Tt, o, {\n      index: e\n    }), t ? this.currentBlockIndex = e : e <= this.currentBlockIndex && this.currentBlockIndex++, o;\n  }\n  /**\n   * Always inserts at the end\n   *\n   * @returns {Block}\n   */\n  insertAtEnd() {\n    return this.currentBlockIndex = this.blocks.length - 1, this.insert();\n  }\n  /**\n   * Merge two blocks\n   *\n   * @param {Block} targetBlock - previous block will be append to this block\n   * @param {Block} blockToMerge - block that will be merged with target block\n   * @returns {Promise} - the sequence that can be continued\n   */\n  async mergeBlocks(e, t) {\n    let o;\n    if (e.name === t.name && e.mergeable) {\n      const i = await t.data;\n      if (X(i)) {\n        console.error(\"Could not merge Block. Failed to extract original Block data.\");\n        return;\n      }\n      const [s] = nt([i], e.tool.sanitizeConfig);\n      o = s;\n    } else if (e.mergeable && Le(t, \"export\") && Le(e, \"import\")) {\n      const i = await t.exportDataAsString(), s = q(i, e.tool.sanitizeConfig);\n      o = wt(s, e.tool.conversionConfig);\n    }\n    o !== void 0 && (await e.mergeWith(o), this.removeBlock(t), this.currentBlockIndex = this._blocks.indexOf(e));\n  }\n  /**\n   * Remove passed Block\n   *\n   * @param block - Block to remove\n   * @param addLastBlock - if true, adds new default block at the end. @todo remove this logic and use event-bus instead\n   */\n  removeBlock(e, t = !0) {\n    return new Promise((o) => {\n      const i = this._blocks.indexOf(e);\n      if (!this.validateIndex(i))\n        throw new Error(\"Can't find a Block to remove\");\n      e.destroy(), this._blocks.remove(i), this.blockDidMutated(Bt, e, {\n        index: i\n      }), this.currentBlockIndex >= i && this.currentBlockIndex--, this.blocks.length ? i === 0 && (this.currentBlockIndex = 0) : (this.unsetCurrentBlock(), t && this.insert()), o();\n    });\n  }\n  /**\n   * Remove only selected Blocks\n   * and returns first Block index where started removing...\n   *\n   * @returns {number|undefined}\n   */\n  removeSelectedBlocks() {\n    let e;\n    for (let t = this.blocks.length - 1; t >= 0; t--)\n      this.blocks[t].selected && (this.removeBlock(this.blocks[t]), e = t);\n    return e;\n  }\n  /**\n   * Attention!\n   * After removing insert the new default typed Block and focus on it\n   * Removes all blocks\n   */\n  removeAllBlocks() {\n    for (let e = this.blocks.length - 1; e >= 0; e--)\n      this._blocks.remove(e);\n    this.unsetCurrentBlock(), this.insert(), this.currentBlock.firstInput.focus();\n  }\n  /**\n   * Split current Block\n   * 1. Extract content from Caret position to the Block`s end\n   * 2. Insert a new Block below current one with extracted content\n   *\n   * @returns {Block}\n   */\n  split() {\n    const e = this.Editor.Caret.extractFragmentFromCaretPosition(), t = d.make(\"div\");\n    t.appendChild(e);\n    const o = {\n      text: d.isEmpty(t) ? \"\" : t.innerHTML\n    };\n    return this.insert({ data: o });\n  }\n  /**\n   * Returns Block by passed index\n   *\n   * @param {number} index - index to get. -1 to get last\n   * @returns {Block}\n   */\n  getBlockByIndex(e) {\n    return e === -1 && (e = this._blocks.length - 1), this._blocks[e];\n  }\n  /**\n   * Returns an index for passed Block\n   *\n   * @param block - block to find index\n   */\n  getBlockIndex(e) {\n    return this._blocks.indexOf(e);\n  }\n  /**\n   * Returns the Block by passed id\n   *\n   * @param id - id of block to get\n   * @returns {Block}\n   */\n  getBlockById(e) {\n    return this._blocks.array.find((t) => t.id === e);\n  }\n  /**\n   * Get Block instance by html element\n   *\n   * @param {Node} element - html element to get Block by\n   */\n  getBlock(e) {\n    d.isElement(e) || (e = e.parentNode);\n    const t = this._blocks.nodes, o = e.closest(`.${D.CSS.wrapper}`), i = t.indexOf(o);\n    if (i >= 0)\n      return this._blocks[i];\n  }\n  /**\n   * 1) Find first-level Block from passed child Node\n   * 2) Mark it as current\n   *\n   * @param {Node} childNode - look ahead from this node.\n   * @returns {Block | undefined} can return undefined in case when the passed child note is not a part of the current editor instance\n   */\n  setCurrentBlockByChildNode(e) {\n    d.isElement(e) || (e = e.parentNode);\n    const t = e.closest(`.${D.CSS.wrapper}`);\n    if (!t)\n      return;\n    const o = t.closest(`.${this.Editor.UI.CSS.editorWrapper}`);\n    if (o != null && o.isEqualNode(this.Editor.UI.nodes.wrapper))\n      return this.currentBlockIndex = this._blocks.nodes.indexOf(t), this.currentBlock.updateCurrentInput(), this.currentBlock;\n  }\n  /**\n   * Return block which contents passed node\n   *\n   * @param {Node} childNode - node to get Block by\n   * @returns {Block}\n   */\n  getBlockByChildNode(e) {\n    if (!e || !(e instanceof Node))\n      return;\n    d.isElement(e) || (e = e.parentNode);\n    const t = e.closest(`.${D.CSS.wrapper}`);\n    return this.blocks.find((o) => o.holder === t);\n  }\n  /**\n   * Swap Blocks Position\n   *\n   * @param {number} fromIndex - index of first block\n   * @param {number} toIndex - index of second block\n   * @deprecated  use 'move' instead\n   */\n  swap(e, t) {\n    this._blocks.swap(e, t), this.currentBlockIndex = t;\n  }\n  /**\n   * Move a block to a new index\n   *\n   * @param {number} toIndex - index where to move Block\n   * @param {number} fromIndex - index of Block to move\n   */\n  move(e, t = this.currentBlockIndex) {\n    if (isNaN(e) || isNaN(t)) {\n      I(\"Warning during 'move' call: incorrect indices provided.\", \"warn\");\n      return;\n    }\n    if (!this.validateIndex(e) || !this.validateIndex(t)) {\n      I(\"Warning during 'move' call: indices cannot be lower than 0 or greater than the amount of blocks.\", \"warn\");\n      return;\n    }\n    this._blocks.move(e, t), this.currentBlockIndex = e, this.blockDidMutated(Ji, this.currentBlock, {\n      fromIndex: t,\n      toIndex: e\n    });\n  }\n  /**\n   * Converts passed Block to the new Tool\n   * Uses Conversion Config\n   *\n   * @param blockToConvert - Block that should be converted\n   * @param targetToolName - name of the Tool to convert to\n   * @param blockDataOverrides - optional new Block data overrides\n   */\n  async convert(e, t, o) {\n    if (!await e.save())\n      throw new Error(\"Could not convert Block. Failed to extract original Block data.\");\n    const s = this.Editor.Tools.blockTools.get(t);\n    if (!s)\n      throw new Error(`Could not convert Block. Tool ${t} not found.`);\n    const r = await e.exportDataAsString(), l = q(\n      r,\n      s.sanitizeConfig\n    );\n    let a = wt(l, s.conversionConfig);\n    return o && (a = Object.assign(a, o)), this.replace(e, s.name, a);\n  }\n  /**\n   * Sets current Block Index -1 which means unknown\n   * and clear highlights\n   */\n  unsetCurrentBlock() {\n    this.currentBlockIndex = -1;\n  }\n  /**\n   * Clears Editor\n   *\n   * @param {boolean} needToAddDefaultBlock - 1) in internal calls (for example, in api.blocks.render)\n   *                                             we don't need to add an empty default block\n   *                                        2) in api.blocks.clear we should add empty block\n   */\n  async clear(e = !1) {\n    const t = new Qi();\n    this.blocks.forEach((o) => {\n      t.add(async () => {\n        await this.removeBlock(o, !1);\n      });\n    }), await t.completed, this.unsetCurrentBlock(), e && this.insert(), this.Editor.UI.checkEmptiness();\n  }\n  /**\n   * Cleans up all the block tools' resources\n   * This is called when editor is destroyed\n   */\n  async destroy() {\n    await Promise.all(this.blocks.map((e) => e.destroy()));\n  }\n  /**\n   * Bind Block events\n   *\n   * @param {Block} block - Block to which event should be bound\n   */\n  bindBlockEvents(e) {\n    const { BlockEvents: t } = this.Editor;\n    this.readOnlyMutableListeners.on(e.holder, \"keydown\", (o) => {\n      t.keydown(o);\n    }), this.readOnlyMutableListeners.on(e.holder, \"keyup\", (o) => {\n      t.keyup(o);\n    }), this.readOnlyMutableListeners.on(e.holder, \"dragover\", (o) => {\n      t.dragOver(o);\n    }), this.readOnlyMutableListeners.on(e.holder, \"dragleave\", (o) => {\n      t.dragLeave(o);\n    }), e.on(\"didMutated\", (o) => this.blockDidMutated(Ct, o, {\n      index: this.getBlockIndex(o)\n    }));\n  }\n  /**\n   * Disable mutable handlers and bindings\n   */\n  disableModuleBindings() {\n    this.readOnlyMutableListeners.clearAll();\n  }\n  /**\n   * Enables all module handlers and bindings for all Blocks\n   */\n  enableModuleBindings() {\n    this.readOnlyMutableListeners.on(\n      document,\n      \"cut\",\n      (e) => this.Editor.BlockEvents.handleCommandX(e)\n    ), this.blocks.forEach((e) => {\n      this.bindBlockEvents(e);\n    });\n  }\n  /**\n   * Validates that the given index is not lower than 0 or higher than the amount of blocks\n   *\n   * @param {number} index - index of blocks array to validate\n   * @returns {boolean}\n   */\n  validateIndex(e) {\n    return !(e < 0 || e >= this._blocks.length);\n  }\n  /**\n   * Block mutation callback\n   *\n   * @param mutationType - what happened with block\n   * @param block - mutated block\n   * @param detailData - additional data to pass with change event\n   */\n  blockDidMutated(e, t, o) {\n    const i = new CustomEvent(e, {\n      detail: {\n        target: new G(t),\n        ...o\n      }\n    });\n    return this.eventsDispatcher.emit(Pt, {\n      event: i\n    }), t;\n  }\n}\nclass ts extends y {\n  constructor() {\n    super(...arguments), this.anyBlockSelectedCache = null, this.needToSelectAll = !1, this.nativeInputSelected = !1, this.readyToBlockSelection = !1;\n  }\n  /**\n   * Sanitizer Config\n   *\n   * @returns {SanitizerConfig}\n   */\n  get sanitizerConfig() {\n    return {\n      p: {},\n      h1: {},\n      h2: {},\n      h3: {},\n      h4: {},\n      h5: {},\n      h6: {},\n      ol: {},\n      ul: {},\n      li: {},\n      br: !0,\n      img: {\n        src: !0,\n        width: !0,\n        height: !0\n      },\n      a: {\n        href: !0\n      },\n      b: {},\n      i: {},\n      u: {}\n    };\n  }\n  /**\n   * Flag that identifies all Blocks selection\n   *\n   * @returns {boolean}\n   */\n  get allBlocksSelected() {\n    const { BlockManager: e } = this.Editor;\n    return e.blocks.every((t) => t.selected === !0);\n  }\n  /**\n   * Set selected all blocks\n   *\n   * @param {boolean} state - state to set\n   */\n  set allBlocksSelected(e) {\n    const { BlockManager: t } = this.Editor;\n    t.blocks.forEach((o) => {\n      o.selected = e;\n    }), this.clearCache();\n  }\n  /**\n   * Flag that identifies any Block selection\n   *\n   * @returns {boolean}\n   */\n  get anyBlockSelected() {\n    const { BlockManager: e } = this.Editor;\n    return this.anyBlockSelectedCache === null && (this.anyBlockSelectedCache = e.blocks.some((t) => t.selected === !0)), this.anyBlockSelectedCache;\n  }\n  /**\n   * Return selected Blocks array\n   *\n   * @returns {Block[]}\n   */\n  get selectedBlocks() {\n    return this.Editor.BlockManager.blocks.filter((e) => e.selected);\n  }\n  /**\n   * Module Preparation\n   * Registers Shortcuts CMD+A and CMD+C\n   * to select all and copy them\n   */\n  prepare() {\n    this.selection = new b(), de.add({\n      name: \"CMD+A\",\n      handler: (e) => {\n        const { BlockManager: t, ReadOnly: o } = this.Editor;\n        if (o.isEnabled) {\n          e.preventDefault(), this.selectAllBlocks();\n          return;\n        }\n        t.currentBlock && this.handleCommandA(e);\n      },\n      on: this.Editor.UI.nodes.redactor\n    });\n  }\n  /**\n   * Toggle read-only state\n   *\n   *  - Remove all ranges\n   *  - Unselect all Blocks\n   */\n  toggleReadOnly() {\n    b.get().removeAllRanges(), this.allBlocksSelected = !1;\n  }\n  /**\n   * Remove selection of Block\n   *\n   * @param {number?} index - Block index according to the BlockManager's indexes\n   */\n  unSelectBlockByIndex(e) {\n    const { BlockManager: t } = this.Editor;\n    let o;\n    isNaN(e) ? o = t.currentBlock : o = t.getBlockByIndex(e), o.selected = !1, this.clearCache();\n  }\n  /**\n   * Clear selection from Blocks\n   *\n   * @param {Event} reason - event caused clear of selection\n   * @param {boolean} restoreSelection - if true, restore saved selection\n   */\n  clearSelection(e, t = !1) {\n    const { BlockManager: o, Caret: i, RectangleSelection: s } = this.Editor;\n    this.needToSelectAll = !1, this.nativeInputSelected = !1, this.readyToBlockSelection = !1;\n    const r = e && e instanceof KeyboardEvent, l = r && It(e.keyCode);\n    if (this.anyBlockSelected && r && l && !b.isSelectionExists) {\n      const a = o.removeSelectedBlocks();\n      o.insertDefaultBlockAtIndex(a, !0), i.setToBlock(o.currentBlock), Ae(() => {\n        const c = e.key;\n        i.insertContentAtCaretPosition(c.length > 1 ? \"\" : c);\n      }, 20)();\n    }\n    if (this.Editor.CrossBlockSelection.clear(e), !this.anyBlockSelected || s.isRectActivated()) {\n      this.Editor.RectangleSelection.clearSelection();\n      return;\n    }\n    t && this.selection.restore(), this.allBlocksSelected = !1;\n  }\n  /**\n   * Reduce each Block and copy its content\n   *\n   * @param {ClipboardEvent} e - copy/cut event\n   * @returns {Promise<void>}\n   */\n  copySelectedBlocks(e) {\n    e.preventDefault();\n    const t = d.make(\"div\");\n    this.selectedBlocks.forEach((s) => {\n      const r = q(s.holder.innerHTML, this.sanitizerConfig), l = d.make(\"p\");\n      l.innerHTML = r, t.appendChild(l);\n    });\n    const o = Array.from(t.childNodes).map((s) => s.textContent).join(`\n\n`), i = t.innerHTML;\n    return e.clipboardData.setData(\"text/plain\", o), e.clipboardData.setData(\"text/html\", i), Promise.all(this.selectedBlocks.map((s) => s.save())).then((s) => {\n      try {\n        e.clipboardData.setData(this.Editor.Paste.MIME_TYPE, JSON.stringify(s));\n      } catch {\n      }\n    });\n  }\n  /**\n   * Select Block by its index\n   *\n   * @param {number?} index - Block index according to the BlockManager's indexes\n   */\n  selectBlockByIndex(e) {\n    const { BlockManager: t } = this.Editor, o = t.getBlockByIndex(e);\n    o !== void 0 && this.selectBlock(o);\n  }\n  /**\n   * Select passed Block\n   *\n   * @param {Block} block - Block to select\n   */\n  selectBlock(e) {\n    this.selection.save(), b.get().removeAllRanges(), e.selected = !0, this.clearCache(), this.Editor.InlineToolbar.close();\n  }\n  /**\n   * Remove selection from passed Block\n   *\n   * @param {Block} block - Block to unselect\n   */\n  unselectBlock(e) {\n    e.selected = !1, this.clearCache();\n  }\n  /**\n   * Clear anyBlockSelected cache\n   */\n  clearCache() {\n    this.anyBlockSelectedCache = null;\n  }\n  /**\n   * Module destruction\n   * De-registers Shortcut CMD+A\n   */\n  destroy() {\n    de.remove(this.Editor.UI.nodes.redactor, \"CMD+A\");\n  }\n  /**\n   * First CMD+A selects all input content by native behaviour,\n   * next CMD+A keypress selects all blocks\n   *\n   * @param {KeyboardEvent} event - keyboard event\n   */\n  handleCommandA(e) {\n    if (this.Editor.RectangleSelection.clearSelection(), d.isNativeInput(e.target) && !this.readyToBlockSelection) {\n      this.readyToBlockSelection = !0;\n      return;\n    }\n    const t = this.Editor.BlockManager.getBlock(e.target), o = t.inputs;\n    if (o.length > 1 && !this.readyToBlockSelection) {\n      this.readyToBlockSelection = !0;\n      return;\n    }\n    if (o.length === 1 && !this.needToSelectAll) {\n      this.needToSelectAll = !0;\n      return;\n    }\n    this.needToSelectAll ? (e.preventDefault(), this.selectAllBlocks(), this.needToSelectAll = !1, this.readyToBlockSelection = !1) : this.readyToBlockSelection && (e.preventDefault(), this.selectBlock(t), this.needToSelectAll = !0);\n  }\n  /**\n   * Select All Blocks\n   * Each Block has selected setter that makes Block copyable\n   */\n  selectAllBlocks() {\n    this.selection.save(), b.get().removeAllRanges(), this.allBlocksSelected = !0, this.Editor.InlineToolbar.close();\n  }\n}\nclass De extends y {\n  /**\n   * Allowed caret positions in input\n   *\n   * @static\n   * @returns {{START: string, END: string, DEFAULT: string}}\n   */\n  get positions() {\n    return {\n      START: \"start\",\n      END: \"end\",\n      DEFAULT: \"default\"\n    };\n  }\n  /**\n   * Elements styles that can be useful for Caret Module\n   */\n  static get CSS() {\n    return {\n      shadowCaret: \"cdx-shadow-caret\"\n    };\n  }\n  /**\n   * Method gets Block instance and puts caret to the text node with offset\n   * There two ways that method applies caret position:\n   *   - first found text node: sets at the beginning, but you can pass an offset\n   *   - last found text node: sets at the end of the node. Also, you can customize the behaviour\n   *\n   * @param {Block} block - Block class\n   * @param {string} position - position where to set caret.\n   *                            If default - leave default behaviour and apply offset if it's passed\n   * @param {number} offset - caret offset regarding to the text node\n   */\n  setToBlock(e, t = this.positions.DEFAULT, o = 0) {\n    var c;\n    const { BlockManager: i, BlockSelection: s } = this.Editor;\n    if (s.clearSelection(), !e.focusable) {\n      (c = window.getSelection()) == null || c.removeAllRanges(), s.selectBlock(e), i.currentBlock = e;\n      return;\n    }\n    let r;\n    switch (t) {\n      case this.positions.START:\n        r = e.firstInput;\n        break;\n      case this.positions.END:\n        r = e.lastInput;\n        break;\n      default:\n        r = e.currentInput;\n    }\n    if (!r)\n      return;\n    const l = d.getDeepestNode(r, t === this.positions.END), a = d.getContentLength(l);\n    switch (!0) {\n      case t === this.positions.START:\n        o = 0;\n        break;\n      case t === this.positions.END:\n      case o > a:\n        o = a;\n        break;\n    }\n    this.set(l, o), i.setCurrentBlockByChildNode(e.holder), i.currentBlock.currentInput = r;\n  }\n  /**\n   * Set caret to the current input of current Block.\n   *\n   * @param {HTMLElement} input - input where caret should be set\n   * @param {string} position - position of the caret.\n   *                            If default - leave default behaviour and apply offset if it's passed\n   * @param {number} offset - caret offset regarding to the text node\n   */\n  setToInput(e, t = this.positions.DEFAULT, o = 0) {\n    const { currentBlock: i } = this.Editor.BlockManager, s = d.getDeepestNode(e);\n    switch (t) {\n      case this.positions.START:\n        this.set(s, 0);\n        break;\n      case this.positions.END:\n        this.set(s, d.getContentLength(s));\n        break;\n      default:\n        o && this.set(s, o);\n    }\n    i.currentInput = e;\n  }\n  /**\n   * Creates Document Range and sets caret to the element with offset\n   *\n   * @param {HTMLElement} element - target node.\n   * @param {number} offset - offset\n   */\n  set(e, t = 0) {\n    const { top: i, bottom: s } = b.setCursor(e, t), { innerHeight: r } = window;\n    i < 0 ? window.scrollBy(0, i - 30) : s > r && window.scrollBy(0, s - r + 30);\n  }\n  /**\n   * Set Caret to the last Block\n   * If last block is not empty, append another empty block\n   */\n  setToTheLastBlock() {\n    const e = this.Editor.BlockManager.lastBlock;\n    if (e)\n      if (e.tool.isDefault && e.isEmpty)\n        this.setToBlock(e);\n      else {\n        const t = this.Editor.BlockManager.insertAtEnd();\n        this.setToBlock(t);\n      }\n  }\n  /**\n   * Extract content fragment of current Block from Caret position to the end of the Block\n   */\n  extractFragmentFromCaretPosition() {\n    const e = b.get();\n    if (e.rangeCount) {\n      const t = e.getRangeAt(0), o = this.Editor.BlockManager.currentBlock.currentInput;\n      if (t.deleteContents(), o)\n        if (d.isNativeInput(o)) {\n          const i = o, s = document.createDocumentFragment(), r = i.value.substring(0, i.selectionStart), l = i.value.substring(i.selectionStart);\n          return s.textContent = l, i.value = r, s;\n        } else {\n          const i = t.cloneRange();\n          return i.selectNodeContents(o), i.setStart(t.endContainer, t.endOffset), i.extractContents();\n        }\n    }\n  }\n  /**\n   * Set's caret to the next Block or Tool`s input\n   * Before moving caret, we should check if caret position is at the end of Plugins node\n   * Using {@link Dom#getDeepestNode} to get a last node and match with current selection\n   *\n   * @param {boolean} force - pass true to skip check for caret position\n   */\n  navigateNext(e = !1) {\n    const { BlockManager: t } = this.Editor, { currentBlock: o, nextBlock: i } = t;\n    if (o === void 0)\n      return !1;\n    const { nextInput: s, currentInput: r } = o, l = r !== void 0 ? Me(r) : void 0;\n    let a = i;\n    const c = e || l || !o.focusable;\n    if (s && c)\n      return this.setToInput(s, this.positions.START), !0;\n    if (a === null) {\n      if (o.tool.isDefault || !c)\n        return !1;\n      a = t.insertAtEnd();\n    }\n    return c ? (this.setToBlock(a, this.positions.START), !0) : !1;\n  }\n  /**\n   * Set's caret to the previous Tool`s input or Block\n   * Before moving caret, we should check if caret position is start of the Plugins node\n   * Using {@link Dom#getDeepestNode} to get a last node and match with current selection\n   *\n   * @param {boolean} force - pass true to skip check for caret position\n   */\n  navigatePrevious(e = !1) {\n    const { currentBlock: t, previousBlock: o } = this.Editor.BlockManager;\n    if (!t)\n      return !1;\n    const { previousInput: i, currentInput: s } = t, r = s !== void 0 ? Ie(s) : void 0, l = e || r || !t.focusable;\n    return i && l ? (this.setToInput(i, this.positions.END), !0) : o !== null && l ? (this.setToBlock(o, this.positions.END), !0) : !1;\n  }\n  /**\n   * Inserts shadow element after passed element where caret can be placed\n   *\n   * @param {Element} element - element after which shadow caret should be inserted\n   */\n  createShadow(e) {\n    const t = document.createElement(\"span\");\n    t.classList.add(De.CSS.shadowCaret), e.insertAdjacentElement(\"beforeend\", t);\n  }\n  /**\n   * Restores caret position\n   *\n   * @param {HTMLElement} element - element where caret should be restored\n   */\n  restoreCaret(e) {\n    const t = e.querySelector(`.${De.CSS.shadowCaret}`);\n    if (!t)\n      return;\n    new b().expandToTag(t);\n    const i = document.createRange();\n    i.selectNode(t), i.extractContents();\n  }\n  /**\n   * Inserts passed content at caret position\n   *\n   * @param {string} content - content to insert\n   */\n  insertContentAtCaretPosition(e) {\n    const t = document.createDocumentFragment(), o = document.createElement(\"div\"), i = b.get(), s = b.range;\n    o.innerHTML = e, Array.from(o.childNodes).forEach((c) => t.appendChild(c)), t.childNodes.length === 0 && t.appendChild(new Text());\n    const r = t.lastChild;\n    s.deleteContents(), s.insertNode(t);\n    const l = document.createRange(), a = r.nodeType === Node.TEXT_NODE ? r : r.firstChild;\n    a !== null && a.textContent !== null && l.setStart(a, a.textContent.length), i.removeAllRanges(), i.addRange(l);\n  }\n}\nclass os extends y {\n  constructor() {\n    super(...arguments), this.onMouseUp = () => {\n      this.listeners.off(document, \"mouseover\", this.onMouseOver), this.listeners.off(document, \"mouseup\", this.onMouseUp);\n    }, this.onMouseOver = (e) => {\n      const { BlockManager: t, BlockSelection: o } = this.Editor;\n      if (e.relatedTarget === null && e.target === null)\n        return;\n      const i = t.getBlockByChildNode(e.relatedTarget) || this.lastSelectedBlock, s = t.getBlockByChildNode(e.target);\n      if (!(!i || !s) && s !== i) {\n        if (i === this.firstSelectedBlock) {\n          b.get().removeAllRanges(), i.selected = !0, s.selected = !0, o.clearCache();\n          return;\n        }\n        if (s === this.firstSelectedBlock) {\n          i.selected = !1, s.selected = !1, o.clearCache();\n          return;\n        }\n        this.Editor.InlineToolbar.close(), this.toggleBlocksSelectedState(i, s), this.lastSelectedBlock = s;\n      }\n    };\n  }\n  /**\n   * Module preparation\n   *\n   * @returns {Promise}\n   */\n  async prepare() {\n    this.listeners.on(document, \"mousedown\", (e) => {\n      this.enableCrossBlockSelection(e);\n    });\n  }\n  /**\n   * Sets up listeners\n   *\n   * @param {MouseEvent} event - mouse down event\n   */\n  watchSelection(e) {\n    if (e.button !== wo.LEFT)\n      return;\n    const { BlockManager: t } = this.Editor;\n    this.firstSelectedBlock = t.getBlock(e.target), this.lastSelectedBlock = this.firstSelectedBlock, this.listeners.on(document, \"mouseover\", this.onMouseOver), this.listeners.on(document, \"mouseup\", this.onMouseUp);\n  }\n  /**\n   * Return boolean is cross block selection started:\n   * there should be at least 2 selected blocks\n   */\n  get isCrossBlockSelectionStarted() {\n    return !!this.firstSelectedBlock && !!this.lastSelectedBlock && this.firstSelectedBlock !== this.lastSelectedBlock;\n  }\n  /**\n   * Change selection state of the next Block\n   * Used for CBS via Shift + arrow keys\n   *\n   * @param {boolean} next - if true, toggle next block. Previous otherwise\n   */\n  toggleBlockSelectedState(e = !0) {\n    const { BlockManager: t, BlockSelection: o } = this.Editor;\n    this.lastSelectedBlock || (this.lastSelectedBlock = this.firstSelectedBlock = t.currentBlock), this.firstSelectedBlock === this.lastSelectedBlock && (this.firstSelectedBlock.selected = !0, o.clearCache(), b.get().removeAllRanges());\n    const i = t.blocks.indexOf(this.lastSelectedBlock) + (e ? 1 : -1), s = t.blocks[i];\n    s && (this.lastSelectedBlock.selected !== s.selected ? (s.selected = !0, o.clearCache()) : (this.lastSelectedBlock.selected = !1, o.clearCache()), this.lastSelectedBlock = s, this.Editor.InlineToolbar.close(), s.holder.scrollIntoView({\n      block: \"nearest\"\n    }));\n  }\n  /**\n   * Clear saved state\n   *\n   * @param {Event} reason - event caused clear of selection\n   */\n  clear(e) {\n    const { BlockManager: t, BlockSelection: o, Caret: i } = this.Editor, s = t.blocks.indexOf(this.firstSelectedBlock), r = t.blocks.indexOf(this.lastSelectedBlock);\n    if (o.anyBlockSelected && s > -1 && r > -1 && e && e instanceof KeyboardEvent)\n      switch (e.keyCode) {\n        case w.DOWN:\n        case w.RIGHT:\n          i.setToBlock(t.blocks[Math.max(s, r)], i.positions.END);\n          break;\n        case w.UP:\n        case w.LEFT:\n          i.setToBlock(t.blocks[Math.min(s, r)], i.positions.START);\n          break;\n        default:\n          i.setToBlock(t.blocks[Math.max(s, r)], i.positions.END);\n      }\n    this.firstSelectedBlock = this.lastSelectedBlock = null;\n  }\n  /**\n   * Enables Cross Block Selection\n   *\n   * @param {MouseEvent} event - mouse down event\n   */\n  enableCrossBlockSelection(e) {\n    const { UI: t } = this.Editor;\n    b.isCollapsed || this.Editor.BlockSelection.clearSelection(e), t.nodes.redactor.contains(e.target) ? this.watchSelection(e) : this.Editor.BlockSelection.clearSelection(e);\n  }\n  /**\n   * Change blocks selection state between passed two blocks.\n   *\n   * @param {Block} firstBlock - first block in range\n   * @param {Block} lastBlock - last block in range\n   */\n  toggleBlocksSelectedState(e, t) {\n    const { BlockManager: o, BlockSelection: i } = this.Editor, s = o.blocks.indexOf(e), r = o.blocks.indexOf(t), l = e.selected !== t.selected;\n    for (let a = Math.min(s, r); a <= Math.max(s, r); a++) {\n      const c = o.blocks[a];\n      c !== this.firstSelectedBlock && c !== (l ? e : t) && (o.blocks[a].selected = !o.blocks[a].selected, i.clearCache());\n    }\n  }\n}\nclass is extends y {\n  constructor() {\n    super(...arguments), this.isStartedAtEditor = !1;\n  }\n  /**\n   * Toggle read-only state\n   *\n   * if state is true:\n   *  - disable all drag-n-drop event handlers\n   *\n   * if state is false:\n   *  - restore drag-n-drop event handlers\n   *\n   * @param {boolean} readOnlyEnabled - \"read only\" state\n   */\n  toggleReadOnly(e) {\n    e ? this.disableModuleBindings() : this.enableModuleBindings();\n  }\n  /**\n   * Add drag events listeners to editor zone\n   */\n  enableModuleBindings() {\n    const { UI: e } = this.Editor;\n    this.readOnlyMutableListeners.on(e.nodes.holder, \"drop\", async (t) => {\n      await this.processDrop(t);\n    }, !0), this.readOnlyMutableListeners.on(e.nodes.holder, \"dragstart\", () => {\n      this.processDragStart();\n    }), this.readOnlyMutableListeners.on(e.nodes.holder, \"dragover\", (t) => {\n      this.processDragOver(t);\n    }, !0);\n  }\n  /**\n   * Unbind drag-n-drop event handlers\n   */\n  disableModuleBindings() {\n    this.readOnlyMutableListeners.clearAll();\n  }\n  /**\n   * Handle drop event\n   *\n   * @param {DragEvent} dropEvent - drop event\n   */\n  async processDrop(e) {\n    const {\n      BlockManager: t,\n      Paste: o,\n      Caret: i\n    } = this.Editor;\n    e.preventDefault(), t.blocks.forEach((r) => {\n      r.dropTarget = !1;\n    }), b.isAtEditor && !b.isCollapsed && this.isStartedAtEditor && document.execCommand(\"delete\"), this.isStartedAtEditor = !1;\n    const s = t.setCurrentBlockByChildNode(e.target);\n    if (s)\n      this.Editor.Caret.setToBlock(s, i.positions.END);\n    else {\n      const r = t.setCurrentBlockByChildNode(t.lastBlock.holder);\n      this.Editor.Caret.setToBlock(r, i.positions.END);\n    }\n    await o.processDataTransfer(e.dataTransfer, !0);\n  }\n  /**\n   * Handle drag start event\n   */\n  processDragStart() {\n    b.isAtEditor && !b.isCollapsed && (this.isStartedAtEditor = !0), this.Editor.InlineToolbar.close();\n  }\n  /**\n   * @param {DragEvent} dragEvent - drag event\n   */\n  processDragOver(e) {\n    e.preventDefault();\n  }\n}\nclass ss extends y {\n  /**\n   * Prepare the module\n   *\n   * @param options - options used by the modification observer module\n   * @param options.config - Editor configuration object\n   * @param options.eventsDispatcher - common Editor event bus\n   */\n  constructor({ config: e, eventsDispatcher: t }) {\n    super({\n      config: e,\n      eventsDispatcher: t\n    }), this.disabled = !1, this.batchingTimeout = null, this.batchingOnChangeQueue = /* @__PURE__ */ new Map(), this.batchTime = 400, this.mutationObserver = new MutationObserver((o) => {\n      this.redactorChanged(o);\n    }), this.eventsDispatcher.on(Pt, (o) => {\n      this.particularBlockChanged(o.event);\n    }), this.eventsDispatcher.on(Dt, () => {\n      this.disable();\n    }), this.eventsDispatcher.on(Rt, () => {\n      this.enable();\n    });\n  }\n  /**\n   * Enables onChange event\n   */\n  enable() {\n    this.mutationObserver.observe(\n      this.Editor.UI.nodes.redactor,\n      {\n        childList: !0,\n        subtree: !0,\n        characterData: !0,\n        attributes: !0\n      }\n    ), this.disabled = !1;\n  }\n  /**\n   * Disables onChange event\n   */\n  disable() {\n    this.mutationObserver.disconnect(), this.disabled = !0;\n  }\n  /**\n   * Call onChange event passed to Editor.js configuration\n   *\n   * @param event - some of our custom change events\n   */\n  particularBlockChanged(e) {\n    this.disabled || !O(this.config.onChange) || (this.batchingOnChangeQueue.set(`block:${e.detail.target.id}:event:${e.type}`, e), this.batchingTimeout && clearTimeout(this.batchingTimeout), this.batchingTimeout = setTimeout(() => {\n      let t;\n      this.batchingOnChangeQueue.size === 1 ? t = this.batchingOnChangeQueue.values().next().value : t = Array.from(this.batchingOnChangeQueue.values()), this.config.onChange && this.config.onChange(this.Editor.API.methods, t), this.batchingOnChangeQueue.clear();\n    }, this.batchTime));\n  }\n  /**\n   * Fired on every blocks wrapper dom change\n   *\n   * @param mutations - mutations happened\n   */\n  redactorChanged(e) {\n    this.eventsDispatcher.emit(Je, {\n      mutations: e\n    });\n  }\n}\nconst ro = class lo extends y {\n  constructor() {\n    super(...arguments), this.MIME_TYPE = \"application/x-editor-js\", this.toolsTags = {}, this.tagsByTool = {}, this.toolsPatterns = [], this.toolsFiles = {}, this.exceptionList = [], this.processTool = (e) => {\n      try {\n        const t = e.create({}, {}, !1);\n        if (e.pasteConfig === !1) {\n          this.exceptionList.push(e.name);\n          return;\n        }\n        if (!O(t.onPaste))\n          return;\n        this.getTagsConfig(e), this.getFilesConfig(e), this.getPatternsConfig(e);\n      } catch (t) {\n        I(\n          `Paste handling for ${e.name} Tool hasn't been set up because of the error`,\n          \"warn\",\n          t\n        );\n      }\n    }, this.handlePasteEvent = async (e) => {\n      const { BlockManager: t, Toolbar: o } = this.Editor, i = t.setCurrentBlockByChildNode(e.target);\n      !i || this.isNativeBehaviour(e.target) && !e.clipboardData.types.includes(\"Files\") || i && this.exceptionList.includes(i.name) || (e.preventDefault(), this.processDataTransfer(e.clipboardData), o.close());\n    };\n  }\n  /**\n   * Set onPaste callback and collect tools` paste configurations\n   */\n  async prepare() {\n    this.processTools();\n  }\n  /**\n   * Set read-only state\n   *\n   * @param {boolean} readOnlyEnabled - read only flag value\n   */\n  toggleReadOnly(e) {\n    e ? this.unsetCallback() : this.setCallback();\n  }\n  /**\n   * Handle pasted or dropped data transfer object\n   *\n   * @param {DataTransfer} dataTransfer - pasted or dropped data transfer object\n   * @param {boolean} isDragNDrop - true if data transfer comes from drag'n'drop events\n   */\n  async processDataTransfer(e, t = !1) {\n    const { Tools: o } = this.Editor, i = e.types;\n    if ((i.includes ? i.includes(\"Files\") : i.contains(\"Files\")) && !X(this.toolsFiles)) {\n      await this.processFiles(e.files);\n      return;\n    }\n    const r = e.getData(this.MIME_TYPE), l = e.getData(\"text/plain\");\n    let a = e.getData(\"text/html\");\n    if (r)\n      try {\n        this.insertEditorJSData(JSON.parse(r));\n        return;\n      } catch {\n      }\n    t && l.trim() && a.trim() && (a = \"<p>\" + (a.trim() ? a : l) + \"</p>\");\n    const c = Object.keys(this.toolsTags).reduce((p, g) => (p[g.toLowerCase()] = this.toolsTags[g].sanitizationConfig ?? {}, p), {}), u = Object.assign({}, c, o.getAllInlineToolsSanitizeConfig(), { br: {} }), h = q(a, u);\n    !h.trim() || h.trim() === l || !d.isHTMLString(h) ? await this.processText(l) : await this.processText(h, !0);\n  }\n  /**\n   * Process pasted text and divide them into Blocks\n   *\n   * @param {string} data - text to process. Can be HTML or plain.\n   * @param {boolean} isHTML - if passed string is HTML, this parameter should be true\n   */\n  async processText(e, t = !1) {\n    const { Caret: o, BlockManager: i } = this.Editor, s = t ? this.processHTML(e) : this.processPlain(e);\n    if (!s.length)\n      return;\n    if (s.length === 1) {\n      s[0].isBlock ? this.processSingleBlock(s.pop()) : this.processInlinePaste(s.pop());\n      return;\n    }\n    const l = i.currentBlock && i.currentBlock.tool.isDefault && i.currentBlock.isEmpty;\n    s.map(\n      async (a, c) => this.insertBlock(a, c === 0 && l)\n    ), i.currentBlock && o.setToBlock(i.currentBlock, o.positions.END);\n  }\n  /**\n   * Set onPaste callback handler\n   */\n  setCallback() {\n    this.listeners.on(this.Editor.UI.nodes.holder, \"paste\", this.handlePasteEvent);\n  }\n  /**\n   * Unset onPaste callback handler\n   */\n  unsetCallback() {\n    this.listeners.off(this.Editor.UI.nodes.holder, \"paste\", this.handlePasteEvent);\n  }\n  /**\n   * Get and process tool`s paste configs\n   */\n  processTools() {\n    const e = this.Editor.Tools.blockTools;\n    Array.from(e.values()).forEach(this.processTool);\n  }\n  /**\n   * Get tags name list from either tag name or sanitization config.\n   *\n   * @param {string | object} tagOrSanitizeConfig - tag name or sanitize config object.\n   * @returns {string[]} array of tags.\n   */\n  collectTagNames(e) {\n    return Q(e) ? [e] : R(e) ? Object.keys(e) : [];\n  }\n  /**\n   * Get tags to substitute by Tool\n   *\n   * @param tool - BlockTool object\n   */\n  getTagsConfig(e) {\n    if (e.pasteConfig === !1)\n      return;\n    const t = e.pasteConfig.tags || [], o = [];\n    t.forEach((i) => {\n      const s = this.collectTagNames(i);\n      o.push(...s), s.forEach((r) => {\n        if (Object.prototype.hasOwnProperty.call(this.toolsTags, r)) {\n          I(\n            `Paste handler for ${e.name} Tool on ${r} tag is skipped because it is already used by ${this.toolsTags[r].tool.name} Tool.`,\n            \"warn\"\n          );\n          return;\n        }\n        const l = R(i) ? i[r] : null;\n        this.toolsTags[r.toUpperCase()] = {\n          tool: e,\n          sanitizationConfig: l\n        };\n      });\n    }), this.tagsByTool[e.name] = o.map((i) => i.toUpperCase());\n  }\n  /**\n   * Get files` types and extensions to substitute by Tool\n   *\n   * @param tool - BlockTool object\n   */\n  getFilesConfig(e) {\n    if (e.pasteConfig === !1)\n      return;\n    const { files: t = {} } = e.pasteConfig;\n    let { extensions: o, mimeTypes: i } = t;\n    !o && !i || (o && !Array.isArray(o) && (I(`extensions property of the onDrop config for ${e.name} Tool should be an array`), o = []), i && !Array.isArray(i) && (I(`mimeTypes property of the onDrop config for ${e.name} Tool should be an array`), i = []), i && (i = i.filter((s) => To(s) ? !0 : (I(`MIME type value ${s} for the ${e.name} Tool is not a valid MIME type`, \"warn\"), !1))), this.toolsFiles[e.name] = {\n      extensions: o || [],\n      mimeTypes: i || []\n    });\n  }\n  /**\n   * Get RegExp patterns to substitute by Tool\n   *\n   * @param tool - BlockTool object\n   */\n  getPatternsConfig(e) {\n    e.pasteConfig === !1 || !e.pasteConfig.patterns || X(e.pasteConfig.patterns) || Object.entries(e.pasteConfig.patterns).forEach(([t, o]) => {\n      o instanceof RegExp || I(\n        `Pattern ${o} for ${e.name} Tool is skipped because it should be a Regexp instance.`,\n        \"warn\"\n      ), this.toolsPatterns.push({\n        key: t,\n        pattern: o,\n        tool: e\n      });\n    });\n  }\n  /**\n   * Check if browser behavior suits better\n   *\n   * @param {EventTarget} element - element where content has been pasted\n   * @returns {boolean}\n   */\n  isNativeBehaviour(e) {\n    return d.isNativeInput(e);\n  }\n  /**\n   * Get files from data transfer object and insert related Tools\n   *\n   * @param {FileList} items - pasted or dropped items\n   */\n  async processFiles(e) {\n    const { BlockManager: t } = this.Editor;\n    let o;\n    o = await Promise.all(\n      Array.from(e).map((r) => this.processFile(r))\n    ), o = o.filter((r) => !!r);\n    const s = t.currentBlock.tool.isDefault && t.currentBlock.isEmpty;\n    o.forEach(\n      (r, l) => {\n        t.paste(r.type, r.event, l === 0 && s);\n      }\n    );\n  }\n  /**\n   * Get information about file and find Tool to handle it\n   *\n   * @param {File} file - file to process\n   */\n  async processFile(e) {\n    const t = Bo(e), o = Object.entries(this.toolsFiles).find(([r, { mimeTypes: l, extensions: a }]) => {\n      const [c, u] = e.type.split(\"/\"), h = a.find((g) => g.toLowerCase() === t.toLowerCase()), p = l.find((g) => {\n        const [f, k] = g.split(\"/\");\n        return f === c && (k === u || k === \"*\");\n      });\n      return !!h || !!p;\n    });\n    if (!o)\n      return;\n    const [i] = o;\n    return {\n      event: this.composePasteEvent(\"file\", {\n        file: e\n      }),\n      type: i\n    };\n  }\n  /**\n   * Split HTML string to blocks and return it as array of Block data\n   *\n   * @param {string} innerHTML - html string to process\n   * @returns {PasteData[]}\n   */\n  processHTML(e) {\n    const { Tools: t } = this.Editor, o = d.make(\"DIV\");\n    return o.innerHTML = e, this.getNodes(o).map((s) => {\n      let r, l = t.defaultTool, a = !1;\n      switch (s.nodeType) {\n        case Node.DOCUMENT_FRAGMENT_NODE:\n          r = d.make(\"div\"), r.appendChild(s);\n          break;\n        case Node.ELEMENT_NODE:\n          r = s, a = !0, this.toolsTags[r.tagName] && (l = this.toolsTags[r.tagName].tool);\n          break;\n      }\n      const { tags: c } = l.pasteConfig || { tags: [] }, u = c.reduce((g, f) => (this.collectTagNames(f).forEach((C) => {\n        const S = R(f) ? f[C] : null;\n        g[C.toLowerCase()] = S || {};\n      }), g), {}), h = Object.assign({}, u, l.baseSanitizeConfig);\n      if (r.tagName.toLowerCase() === \"table\") {\n        const g = q(r.outerHTML, h);\n        r = d.make(\"div\", void 0, {\n          innerHTML: g\n        }).firstChild;\n      } else\n        r.innerHTML = q(r.innerHTML, h);\n      const p = this.composePasteEvent(\"tag\", {\n        data: r\n      });\n      return {\n        content: r,\n        isBlock: a,\n        tool: l.name,\n        event: p\n      };\n    }).filter((s) => {\n      const r = d.isEmpty(s.content), l = d.isSingleTag(s.content);\n      return !r || l;\n    });\n  }\n  /**\n   * Split plain text by new line symbols and return it as array of Block data\n   *\n   * @param {string} plain - string to process\n   * @returns {PasteData[]}\n   */\n  processPlain(e) {\n    const { defaultBlock: t } = this.config;\n    if (!e)\n      return [];\n    const o = t;\n    return e.split(/\\r?\\n/).filter((i) => i.trim()).map((i) => {\n      const s = d.make(\"div\");\n      s.textContent = i;\n      const r = this.composePasteEvent(\"tag\", {\n        data: s\n      });\n      return {\n        content: s,\n        tool: o,\n        isBlock: !1,\n        event: r\n      };\n    });\n  }\n  /**\n   * Process paste of single Block tool content\n   *\n   * @param {PasteData} dataToInsert - data of Block to insert\n   */\n  async processSingleBlock(e) {\n    const { Caret: t, BlockManager: o } = this.Editor, { currentBlock: i } = o;\n    if (!i || e.tool !== i.name || !d.containsOnlyInlineElements(e.content.innerHTML)) {\n      this.insertBlock(e, (i == null ? void 0 : i.tool.isDefault) && i.isEmpty);\n      return;\n    }\n    t.insertContentAtCaretPosition(e.content.innerHTML);\n  }\n  /**\n   * Process paste to single Block:\n   * 1. Find patterns` matches\n   * 2. Insert new block if it is not the same type as current one\n   * 3. Just insert text if there is no substitutions\n   *\n   * @param {PasteData} dataToInsert - data of Block to insert\n   */\n  async processInlinePaste(e) {\n    const { BlockManager: t, Caret: o } = this.Editor, { content: i } = e;\n    if (t.currentBlock && t.currentBlock.tool.isDefault && i.textContent.length < lo.PATTERN_PROCESSING_MAX_LENGTH) {\n      const r = await this.processPattern(i.textContent);\n      if (r) {\n        const l = t.currentBlock && t.currentBlock.tool.isDefault && t.currentBlock.isEmpty, a = t.paste(r.tool, r.event, l);\n        o.setToBlock(a, o.positions.END);\n        return;\n      }\n    }\n    if (t.currentBlock && t.currentBlock.currentInput) {\n      const r = t.currentBlock.tool.baseSanitizeConfig;\n      document.execCommand(\n        \"insertHTML\",\n        !1,\n        q(i.innerHTML, r)\n      );\n    } else\n      this.insertBlock(e);\n  }\n  /**\n   * Get patterns` matches\n   *\n   * @param {string} text - text to process\n   * @returns {Promise<{event: PasteEvent, tool: string}>}\n   */\n  async processPattern(e) {\n    const t = this.toolsPatterns.find((i) => {\n      const s = i.pattern.exec(e);\n      return s ? e === s.shift() : !1;\n    });\n    return t ? {\n      event: this.composePasteEvent(\"pattern\", {\n        key: t.key,\n        data: e\n      }),\n      tool: t.tool.name\n    } : void 0;\n  }\n  /**\n   * Insert pasted Block content to Editor\n   *\n   * @param {PasteData} data - data to insert\n   * @param {boolean} canReplaceCurrentBlock - if true and is current Block is empty, will replace current Block\n   * @returns {void}\n   */\n  insertBlock(e, t = !1) {\n    const { BlockManager: o, Caret: i } = this.Editor, { currentBlock: s } = o;\n    let r;\n    if (t && s && s.isEmpty) {\n      r = o.paste(e.tool, e.event, !0), i.setToBlock(r, i.positions.END);\n      return;\n    }\n    r = o.paste(e.tool, e.event), i.setToBlock(r, i.positions.END);\n  }\n  /**\n   * Insert data passed as application/x-editor-js JSON\n   *\n   * @param {Array} blocks  Blocks' data to insert\n   * @returns {void}\n   */\n  insertEditorJSData(e) {\n    const { BlockManager: t, Caret: o, Tools: i } = this.Editor;\n    nt(\n      e,\n      (r) => i.blockTools.get(r).sanitizeConfig\n    ).forEach(({ tool: r, data: l }, a) => {\n      let c = !1;\n      a === 0 && (c = t.currentBlock && t.currentBlock.tool.isDefault && t.currentBlock.isEmpty);\n      const u = t.insert({\n        tool: r,\n        data: l,\n        replace: c\n      });\n      o.setToBlock(u, o.positions.END);\n    });\n  }\n  /**\n   * Fetch nodes from Element node\n   *\n   * @param {Node} node - current node\n   * @param {Node[]} nodes - processed nodes\n   * @param {Node} destNode - destination node\n   */\n  processElementNode(e, t, o) {\n    const i = Object.keys(this.toolsTags), s = e, { tool: r } = this.toolsTags[s.tagName] || {}, l = this.tagsByTool[r == null ? void 0 : r.name] || [], a = i.includes(s.tagName), c = d.blockElements.includes(s.tagName.toLowerCase()), u = Array.from(s.children).some(\n      ({ tagName: p }) => i.includes(p) && !l.includes(p)\n    ), h = Array.from(s.children).some(\n      ({ tagName: p }) => d.blockElements.includes(p.toLowerCase())\n    );\n    if (!c && !a && !u)\n      return o.appendChild(s), [...t, o];\n    if (a && !u || c && !h && !u)\n      return [...t, o, s];\n  }\n  /**\n   * Recursively divide HTML string to two types of nodes:\n   * 1. Block element\n   * 2. Document Fragments contained text and markup tags like a, b, i etc.\n   *\n   * @param {Node} wrapper - wrapper of paster HTML content\n   * @returns {Node[]}\n   */\n  getNodes(e) {\n    const t = Array.from(e.childNodes);\n    let o;\n    const i = (s, r) => {\n      if (d.isEmpty(r) && !d.isSingleTag(r))\n        return s;\n      const l = s[s.length - 1];\n      let a = new DocumentFragment();\n      switch (l && d.isFragment(l) && (a = s.pop()), r.nodeType) {\n        case Node.ELEMENT_NODE:\n          if (o = this.processElementNode(r, s, a), o)\n            return o;\n          break;\n        case Node.TEXT_NODE:\n          return a.appendChild(r), [...s, a];\n        default:\n          return [...s, a];\n      }\n      return [...s, ...Array.from(r.childNodes).reduce(i, [])];\n    };\n    return t.reduce(i, []);\n  }\n  /**\n   * Compose paste event with passed type and detail\n   *\n   * @param {string} type - event type\n   * @param {PasteEventDetail} detail - event detail\n   */\n  composePasteEvent(e, t) {\n    return new CustomEvent(e, {\n      detail: t\n    });\n  }\n};\nro.PATTERN_PROCESSING_MAX_LENGTH = 450;\nlet ns = ro;\nclass rs extends y {\n  constructor() {\n    super(...arguments), this.toolsDontSupportReadOnly = [], this.readOnlyEnabled = !1;\n  }\n  /**\n   * Returns state of read only mode\n   */\n  get isEnabled() {\n    return this.readOnlyEnabled;\n  }\n  /**\n   * Set initial state\n   */\n  async prepare() {\n    const { Tools: e } = this.Editor, { blockTools: t } = e, o = [];\n    Array.from(t.entries()).forEach(([i, s]) => {\n      s.isReadOnlySupported || o.push(i);\n    }), this.toolsDontSupportReadOnly = o, this.config.readOnly && o.length > 0 && this.throwCriticalError(), this.toggle(this.config.readOnly);\n  }\n  /**\n   * Set read-only mode or toggle current state\n   * Call all Modules `toggleReadOnly` method and re-render Editor\n   *\n   * @param {boolean} state - (optional) read-only state or toggle\n   */\n  async toggle(e = !this.readOnlyEnabled) {\n    e && this.toolsDontSupportReadOnly.length > 0 && this.throwCriticalError();\n    const t = this.readOnlyEnabled;\n    this.readOnlyEnabled = e;\n    for (const i in this.Editor)\n      this.Editor[i].toggleReadOnly && this.Editor[i].toggleReadOnly(e);\n    if (t === e)\n      return this.readOnlyEnabled;\n    const o = await this.Editor.Saver.save();\n    return await this.Editor.BlockManager.clear(), await this.Editor.Renderer.render(o.blocks), this.readOnlyEnabled;\n  }\n  /**\n   * Throws an error about tools which don't support read-only mode\n   */\n  throwCriticalError() {\n    throw new Nt(\n      `To enable read-only mode all connected tools should support it. Tools ${this.toolsDontSupportReadOnly.join(\", \")} don't support read-only mode.`\n    );\n  }\n}\nclass we extends y {\n  constructor() {\n    super(...arguments), this.isRectSelectionActivated = !1, this.SCROLL_SPEED = 3, this.HEIGHT_OF_SCROLL_ZONE = 40, this.BOTTOM_SCROLL_ZONE = 1, this.TOP_SCROLL_ZONE = 2, this.MAIN_MOUSE_BUTTON = 0, this.mousedown = !1, this.isScrolling = !1, this.inScrollZone = null, this.startX = 0, this.startY = 0, this.mouseX = 0, this.mouseY = 0, this.stackOfSelected = [], this.listenerIds = [];\n  }\n  /**\n   * CSS classes for the Block\n   *\n   * @returns {{wrapper: string, content: string}}\n   */\n  static get CSS() {\n    return {\n      overlay: \"codex-editor-overlay\",\n      overlayContainer: \"codex-editor-overlay__container\",\n      rect: \"codex-editor-overlay__rectangle\",\n      topScrollZone: \"codex-editor-overlay__scroll-zone--top\",\n      bottomScrollZone: \"codex-editor-overlay__scroll-zone--bottom\"\n    };\n  }\n  /**\n   * Module Preparation\n   * Creating rect and hang handlers\n   */\n  prepare() {\n    this.enableModuleBindings();\n  }\n  /**\n   * Init rect params\n   *\n   * @param {number} pageX - X coord of mouse\n   * @param {number} pageY - Y coord of mouse\n   */\n  startSelection(e, t) {\n    const o = document.elementFromPoint(e - window.pageXOffset, t - window.pageYOffset);\n    o.closest(`.${this.Editor.Toolbar.CSS.toolbar}`) || (this.Editor.BlockSelection.allBlocksSelected = !1, this.clearSelection(), this.stackOfSelected = []);\n    const s = [\n      `.${D.CSS.content}`,\n      `.${this.Editor.Toolbar.CSS.toolbar}`,\n      `.${this.Editor.InlineToolbar.CSS.inlineToolbar}`\n    ], r = o.closest(\".\" + this.Editor.UI.CSS.editorWrapper), l = s.some((a) => !!o.closest(a));\n    !r || l || (this.mousedown = !0, this.startX = e, this.startY = t);\n  }\n  /**\n   * Clear all params to end selection\n   */\n  endSelection() {\n    this.mousedown = !1, this.startX = 0, this.startY = 0, this.overlayRectangle.style.display = \"none\";\n  }\n  /**\n   * is RectSelection Activated\n   */\n  isRectActivated() {\n    return this.isRectSelectionActivated;\n  }\n  /**\n   * Mark that selection is end\n   */\n  clearSelection() {\n    this.isRectSelectionActivated = !1;\n  }\n  /**\n   * Sets Module necessary event handlers\n   */\n  enableModuleBindings() {\n    const { container: e } = this.genHTML();\n    this.listeners.on(e, \"mousedown\", (t) => {\n      this.processMouseDown(t);\n    }, !1), this.listeners.on(document.body, \"mousemove\", Ve((t) => {\n      this.processMouseMove(t);\n    }, 10), {\n      passive: !0\n    }), this.listeners.on(document.body, \"mouseleave\", () => {\n      this.processMouseLeave();\n    }), this.listeners.on(window, \"scroll\", Ve((t) => {\n      this.processScroll(t);\n    }, 10), {\n      passive: !0\n    }), this.listeners.on(document.body, \"mouseup\", () => {\n      this.processMouseUp();\n    }, !1);\n  }\n  /**\n   * Handle mouse down events\n   *\n   * @param {MouseEvent} mouseEvent - mouse event payload\n   */\n  processMouseDown(e) {\n    if (e.button !== this.MAIN_MOUSE_BUTTON)\n      return;\n    e.target.closest(d.allInputsSelector) !== null || this.startSelection(e.pageX, e.pageY);\n  }\n  /**\n   * Handle mouse move events\n   *\n   * @param {MouseEvent} mouseEvent - mouse event payload\n   */\n  processMouseMove(e) {\n    this.changingRectangle(e), this.scrollByZones(e.clientY);\n  }\n  /**\n   * Handle mouse leave\n   */\n  processMouseLeave() {\n    this.clearSelection(), this.endSelection();\n  }\n  /**\n   * @param {MouseEvent} mouseEvent - mouse event payload\n   */\n  processScroll(e) {\n    this.changingRectangle(e);\n  }\n  /**\n   * Handle mouse up\n   */\n  processMouseUp() {\n    this.clearSelection(), this.endSelection();\n  }\n  /**\n   * Scroll If mouse in scroll zone\n   *\n   * @param {number} clientY - Y coord of mouse\n   */\n  scrollByZones(e) {\n    if (this.inScrollZone = null, e <= this.HEIGHT_OF_SCROLL_ZONE && (this.inScrollZone = this.TOP_SCROLL_ZONE), document.documentElement.clientHeight - e <= this.HEIGHT_OF_SCROLL_ZONE && (this.inScrollZone = this.BOTTOM_SCROLL_ZONE), !this.inScrollZone) {\n      this.isScrolling = !1;\n      return;\n    }\n    this.isScrolling || (this.scrollVertical(this.inScrollZone === this.TOP_SCROLL_ZONE ? -this.SCROLL_SPEED : this.SCROLL_SPEED), this.isScrolling = !0);\n  }\n  /**\n   * Generates required HTML elements\n   *\n   * @returns {Object<string, Element>}\n   */\n  genHTML() {\n    const { UI: e } = this.Editor, t = e.nodes.holder.querySelector(\".\" + e.CSS.editorWrapper), o = d.make(\"div\", we.CSS.overlay, {}), i = d.make(\"div\", we.CSS.overlayContainer, {}), s = d.make(\"div\", we.CSS.rect, {});\n    return i.appendChild(s), o.appendChild(i), t.appendChild(o), this.overlayRectangle = s, {\n      container: t,\n      overlay: o\n    };\n  }\n  /**\n   * Activates scrolling if blockSelection is active and mouse is in scroll zone\n   *\n   * @param {number} speed - speed of scrolling\n   */\n  scrollVertical(e) {\n    if (!(this.inScrollZone && this.mousedown))\n      return;\n    const t = window.pageYOffset;\n    window.scrollBy(0, e), this.mouseY += window.pageYOffset - t, setTimeout(() => {\n      this.scrollVertical(e);\n    }, 0);\n  }\n  /**\n   * Handles the change in the rectangle and its effect\n   *\n   * @param {MouseEvent} event - mouse event\n   */\n  changingRectangle(e) {\n    if (!this.mousedown)\n      return;\n    e.pageY !== void 0 && (this.mouseX = e.pageX, this.mouseY = e.pageY);\n    const { rightPos: t, leftPos: o, index: i } = this.genInfoForMouseSelection(), s = this.startX > t && this.mouseX > t, r = this.startX < o && this.mouseX < o;\n    this.rectCrossesBlocks = !(s || r), this.isRectSelectionActivated || (this.rectCrossesBlocks = !1, this.isRectSelectionActivated = !0, this.shrinkRectangleToPoint(), this.overlayRectangle.style.display = \"block\"), this.updateRectangleSize(), this.Editor.Toolbar.close(), i !== void 0 && (this.trySelectNextBlock(i), this.inverseSelection(), b.get().removeAllRanges());\n  }\n  /**\n   * Shrink rect to singular point\n   */\n  shrinkRectangleToPoint() {\n    this.overlayRectangle.style.left = `${this.startX - window.pageXOffset}px`, this.overlayRectangle.style.top = `${this.startY - window.pageYOffset}px`, this.overlayRectangle.style.bottom = `calc(100% - ${this.startY - window.pageYOffset}px`, this.overlayRectangle.style.right = `calc(100% - ${this.startX - window.pageXOffset}px`;\n  }\n  /**\n   * Select or unselect all of blocks in array if rect is out or in selectable area\n   */\n  inverseSelection() {\n    const t = this.Editor.BlockManager.getBlockByIndex(this.stackOfSelected[0]).selected;\n    if (this.rectCrossesBlocks && !t)\n      for (const o of this.stackOfSelected)\n        this.Editor.BlockSelection.selectBlockByIndex(o);\n    if (!this.rectCrossesBlocks && t)\n      for (const o of this.stackOfSelected)\n        this.Editor.BlockSelection.unSelectBlockByIndex(o);\n  }\n  /**\n   * Updates size of rectangle\n   */\n  updateRectangleSize() {\n    this.mouseY >= this.startY ? (this.overlayRectangle.style.top = `${this.startY - window.pageYOffset}px`, this.overlayRectangle.style.bottom = `calc(100% - ${this.mouseY - window.pageYOffset}px`) : (this.overlayRectangle.style.bottom = `calc(100% - ${this.startY - window.pageYOffset}px`, this.overlayRectangle.style.top = `${this.mouseY - window.pageYOffset}px`), this.mouseX >= this.startX ? (this.overlayRectangle.style.left = `${this.startX - window.pageXOffset}px`, this.overlayRectangle.style.right = `calc(100% - ${this.mouseX - window.pageXOffset}px`) : (this.overlayRectangle.style.right = `calc(100% - ${this.startX - window.pageXOffset}px`, this.overlayRectangle.style.left = `${this.mouseX - window.pageXOffset}px`);\n  }\n  /**\n   * Collects information needed to determine the behavior of the rectangle\n   *\n   * @returns {object} index - index next Block, leftPos - start of left border of Block, rightPos - right border\n   */\n  genInfoForMouseSelection() {\n    const t = document.body.offsetWidth / 2, o = this.mouseY - window.pageYOffset, i = document.elementFromPoint(t, o), s = this.Editor.BlockManager.getBlockByChildNode(i);\n    let r;\n    s !== void 0 && (r = this.Editor.BlockManager.blocks.findIndex((h) => h.holder === s.holder));\n    const l = this.Editor.BlockManager.lastBlock.holder.querySelector(\".\" + D.CSS.content), a = Number.parseInt(window.getComputedStyle(l).width, 10) / 2, c = t - a, u = t + a;\n    return {\n      index: r,\n      leftPos: c,\n      rightPos: u\n    };\n  }\n  /**\n   * Select block with index index\n   *\n   * @param index - index of block in redactor\n   */\n  addBlockInSelection(e) {\n    this.rectCrossesBlocks && this.Editor.BlockSelection.selectBlockByIndex(e), this.stackOfSelected.push(e);\n  }\n  /**\n   * Adds a block to the selection and determines which blocks should be selected\n   *\n   * @param {object} index - index of new block in the reactor\n   */\n  trySelectNextBlock(e) {\n    const t = this.stackOfSelected[this.stackOfSelected.length - 1] === e, o = this.stackOfSelected.length, i = 1, s = -1, r = 0;\n    if (t)\n      return;\n    const l = this.stackOfSelected[o - 1] - this.stackOfSelected[o - 2] > 0;\n    let a = r;\n    o > 1 && (a = l ? i : s);\n    const c = e > this.stackOfSelected[o - 1] && a === i, u = e < this.stackOfSelected[o - 1] && a === s, p = !(c || u || a === r);\n    if (!p && (e > this.stackOfSelected[o - 1] || this.stackOfSelected[o - 1] === void 0)) {\n      let k = this.stackOfSelected[o - 1] + 1 || e;\n      for (k; k <= e; k++)\n        this.addBlockInSelection(k);\n      return;\n    }\n    if (!p && e < this.stackOfSelected[o - 1]) {\n      for (let k = this.stackOfSelected[o - 1] - 1; k >= e; k--)\n        this.addBlockInSelection(k);\n      return;\n    }\n    if (!p)\n      return;\n    let g = o - 1, f;\n    for (e > this.stackOfSelected[o - 1] ? f = () => e > this.stackOfSelected[g] : f = () => e < this.stackOfSelected[g]; f(); )\n      this.rectCrossesBlocks && this.Editor.BlockSelection.unSelectBlockByIndex(this.stackOfSelected[g]), this.stackOfSelected.pop(), g--;\n  }\n}\nclass ls extends y {\n  /**\n   * Renders passed blocks as one batch\n   *\n   * @param blocksData - blocks to render\n   */\n  async render(e) {\n    return new Promise((t) => {\n      const { Tools: o, BlockManager: i } = this.Editor;\n      if (e.length === 0)\n        i.insert();\n      else {\n        const s = e.map(({ type: r, data: l, tunes: a, id: c }) => {\n          o.available.has(r) === !1 && (K(`Tool ${r} is not found. Check 'tools' property at the Editor.js config.`, \"warn\"), l = this.composeStubDataForTool(r, l, c), r = o.stubTool);\n          let u;\n          try {\n            u = i.composeBlock({\n              id: c,\n              tool: r,\n              data: l,\n              tunes: a\n            });\n          } catch (h) {\n            I(`Block ${r} skipped because of plugins error`, \"error\", {\n              data: l,\n              error: h\n            }), l = this.composeStubDataForTool(r, l, c), r = o.stubTool, u = i.composeBlock({\n              id: c,\n              tool: r,\n              data: l,\n              tunes: a\n            });\n          }\n          return u;\n        });\n        i.insertMany(s);\n      }\n      window.requestIdleCallback(() => {\n        t();\n      }, { timeout: 2e3 });\n    });\n  }\n  /**\n   * Create data for the Stub Tool that will be used instead of unavailable tool\n   *\n   * @param tool - unavailable tool name to stub\n   * @param data - data of unavailable block\n   * @param [id] - id of unavailable block\n   */\n  composeStubDataForTool(e, t, o) {\n    const { Tools: i } = this.Editor;\n    let s = e;\n    if (i.unavailable.has(e)) {\n      const r = i.unavailable.get(e).toolbox;\n      r !== void 0 && r[0].title !== void 0 && (s = r[0].title);\n    }\n    return {\n      savedData: {\n        id: o,\n        type: e,\n        data: t\n      },\n      title: s\n    };\n  }\n}\nclass as extends y {\n  /**\n   * Composes new chain of Promises to fire them alternatelly\n   *\n   * @returns {OutputData}\n   */\n  async save() {\n    const { BlockManager: e, Tools: t } = this.Editor, o = e.blocks, i = [];\n    try {\n      o.forEach((l) => {\n        i.push(this.getSavedData(l));\n      });\n      const s = await Promise.all(i), r = await nt(s, (l) => t.blockTools.get(l).sanitizeConfig);\n      return this.makeOutput(r);\n    } catch (s) {\n      K(\"Saving failed due to the Error %o\", \"error\", s);\n    }\n  }\n  /**\n   * Saves and validates\n   *\n   * @param {Block} block - Editor's Tool\n   * @returns {ValidatedData} - Tool's validated data\n   */\n  async getSavedData(e) {\n    const t = await e.save(), o = t && await e.validate(t.data);\n    return {\n      ...t,\n      isValid: o\n    };\n  }\n  /**\n   * Creates output object with saved data, time and version of editor\n   *\n   * @param {ValidatedData} allExtractedData - data extracted from Blocks\n   * @returns {OutputData}\n   */\n  makeOutput(e) {\n    const t = [];\n    return e.forEach(({ id: o, tool: i, data: s, tunes: r, isValid: l }) => {\n      if (!l) {\n        I(`Block ${i} skipped because saved data is invalid`);\n        return;\n      }\n      if (i === this.Editor.Tools.stubTool) {\n        t.push(s);\n        return;\n      }\n      const a = {\n        id: o,\n        type: i,\n        data: s,\n        ...!X(r) && {\n          tunes: r\n        }\n      };\n      t.push(a);\n    }), {\n      time: +/* @__PURE__ */ new Date(),\n      blocks: t,\n      version: \"2.30.0\"\n    };\n  }\n}\n(function() {\n  try {\n    if (typeof document < \"u\") {\n      var n = document.createElement(\"style\");\n      n.appendChild(document.createTextNode(\".ce-paragraph{line-height:1.6em;outline:none}.ce-block:only-of-type .ce-paragraph[data-placeholder-active]:empty:before,.ce-block:only-of-type .ce-paragraph[data-placeholder-active][data-empty=true]:before{content:attr(data-placeholder-active)}.ce-paragraph p:first-of-type{margin-top:0}.ce-paragraph p:last-of-type{margin-bottom:0}\")), document.head.appendChild(n);\n    }\n  } catch (e) {\n    console.error(\"vite-plugin-css-injected-by-js\", e);\n  }\n})();\nconst cs = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M8 9V7.2C8 7.08954 8.08954 7 8.2 7L12 7M16 9V7.2C16 7.08954 15.9105 7 15.8 7L12 7M12 7L12 17M12 17H10M12 17H14\"/></svg>';\nfunction ds(n) {\n  const e = document.createElement(\"div\");\n  e.innerHTML = n.trim();\n  const t = document.createDocumentFragment();\n  return t.append(...Array.from(e.childNodes)), t;\n}\n/**\n * Base Paragraph Block for the Editor.js.\n * Represents a regular text block\n *\n * @author CodeX (team@codex.so)\n * @copyright CodeX 2018\n * @license The MIT License (MIT)\n */\nclass dt {\n  /**\n   * Default placeholder for Paragraph Tool\n   *\n   * @returns {string}\n   * @class\n   */\n  static get DEFAULT_PLACEHOLDER() {\n    return \"\";\n  }\n  /**\n   * Render plugin`s main Element and fill it with saved data\n   *\n   * @param {object} params - constructor params\n   * @param {ParagraphData} params.data - previously saved data\n   * @param {ParagraphConfig} params.config - user config for Tool\n   * @param {object} params.api - editor.js api\n   * @param {boolean} readOnly - read only mode flag\n   */\n  constructor({ data: e, config: t, api: o, readOnly: i }) {\n    this.api = o, this.readOnly = i, this._CSS = {\n      block: this.api.styles.block,\n      wrapper: \"ce-paragraph\"\n    }, this.readOnly || (this.onKeyUp = this.onKeyUp.bind(this)), this._placeholder = t.placeholder ? t.placeholder : dt.DEFAULT_PLACEHOLDER, this._data = e ?? {}, this._element = null, this._preserveBlank = t.preserveBlank ?? !1;\n  }\n  /**\n   * Check if text content is empty and set empty string to inner html.\n   * We need this because some browsers (e.g. Safari) insert <br> into empty contenteditanle elements\n   *\n   * @param {KeyboardEvent} e - key up event\n   */\n  onKeyUp(e) {\n    if (e.code !== \"Backspace\" && e.code !== \"Delete\" || !this._element)\n      return;\n    const { textContent: t } = this._element;\n    t === \"\" && (this._element.innerHTML = \"\");\n  }\n  /**\n   * Create Tool's view\n   *\n   * @returns {HTMLDivElement}\n   * @private\n   */\n  drawView() {\n    const e = document.createElement(\"DIV\");\n    return e.classList.add(this._CSS.wrapper, this._CSS.block), e.contentEditable = \"false\", e.dataset.placeholderActive = this.api.i18n.t(this._placeholder), this._data.text && (e.innerHTML = this._data.text), this.readOnly || (e.contentEditable = \"true\", e.addEventListener(\"keyup\", this.onKeyUp)), e;\n  }\n  /**\n   * Return Tool's view\n   *\n   * @returns {HTMLDivElement}\n   */\n  render() {\n    return this._element = this.drawView(), this._element;\n  }\n  /**\n   * Method that specified how to merge two Text blocks.\n   * Called by Editor.js by backspace at the beginning of the Block\n   *\n   * @param {ParagraphData} data\n   * @public\n   */\n  merge(e) {\n    if (!this._element)\n      return;\n    this._data.text += e.text;\n    const t = ds(e.text);\n    this._element.appendChild(t), this._element.normalize();\n  }\n  /**\n   * Validate Paragraph block data:\n   * - check for emptiness\n   *\n   * @param {ParagraphData} savedData  data received after saving\n   * @returns {boolean} false if saved data is not correct, otherwise true\n   * @public\n   */\n  validate(e) {\n    return !(e.text.trim() === \"\" && !this._preserveBlank);\n  }\n  /**\n   * Extract Tool's data from the view\n   *\n   * @param {HTMLDivElement} toolsContent - Paragraph tools rendered view\n   * @returns {ParagraphData} - saved data\n   * @public\n   */\n  save(e) {\n    return {\n      text: e.innerHTML\n    };\n  }\n  /**\n   * On paste callback fired from Editor.\n   *\n   * @param {HTMLPasteEvent} event - event with pasted data\n   */\n  onPaste(e) {\n    const t = {\n      text: e.detail.data.innerHTML\n    };\n    this._data = t, window.requestAnimationFrame(() => {\n      this._element && (this._element.innerHTML = this._data.text || \"\");\n    });\n  }\n  /**\n   * Enable Conversion Toolbar. Paragraph can be converted to/from other tools\n   * @returns {ConversionConfig}\n   */\n  static get conversionConfig() {\n    return {\n      export: \"text\",\n      // to convert Paragraph to other block, use 'text' property of saved data\n      import: \"text\"\n      // to covert other block's exported string to Paragraph, fill 'text' property of tool data\n    };\n  }\n  /**\n   * Sanitizer rules\n   * @returns {SanitizerConfig} - Edtior.js sanitizer config\n   */\n  static get sanitize() {\n    return {\n      text: {\n        br: !0\n      }\n    };\n  }\n  /**\n   * Returns true to notify the core that read-only mode is supported\n   *\n   * @returns {boolean}\n   */\n  static get isReadOnlySupported() {\n    return !0;\n  }\n  /**\n   * Used by Editor paste handling API.\n   * Provides configuration to handle P tags.\n   *\n   * @returns {PasteConfig} - Paragraph Paste Setting\n   */\n  static get pasteConfig() {\n    return {\n      tags: [\"P\"]\n    };\n  }\n  /**\n   * Icon and title for displaying at the Toolbox\n   *\n   * @returns {ToolboxConfig} - Paragraph Toolbox Setting\n   */\n  static get toolbox() {\n    return {\n      icon: cs,\n      title: \"Text\"\n    };\n  }\n}\nclass ht {\n  constructor() {\n    this.commandName = \"bold\";\n  }\n  /**\n   * Sanitizer Rule\n   * Leave <b> tags\n   *\n   * @returns {object}\n   */\n  static get sanitize() {\n    return {\n      b: {}\n    };\n  }\n  /**\n   * Create button for Inline Toolbar\n   */\n  render() {\n    return {\n      icon: zo,\n      name: \"bold\",\n      onActivate: () => {\n        document.execCommand(this.commandName);\n      },\n      isActive: () => document.queryCommandState(this.commandName)\n    };\n  }\n  /**\n   * Set a shortcut\n   *\n   * @returns {boolean}\n   */\n  get shortcut() {\n    return \"CMD+B\";\n  }\n}\nht.isInline = !0;\nht.title = \"Bold\";\nclass ut {\n  constructor() {\n    this.commandName = \"italic\", this.CSS = {\n      button: \"ce-inline-tool\",\n      buttonActive: \"ce-inline-tool--active\",\n      buttonModifier: \"ce-inline-tool--italic\"\n    }, this.nodes = {\n      button: null\n    };\n  }\n  /**\n   * Sanitizer Rule\n   * Leave <i> tags\n   *\n   * @returns {object}\n   */\n  static get sanitize() {\n    return {\n      i: {}\n    };\n  }\n  /**\n   * Create button for Inline Toolbar\n   */\n  render() {\n    return this.nodes.button = document.createElement(\"button\"), this.nodes.button.type = \"button\", this.nodes.button.classList.add(this.CSS.button, this.CSS.buttonModifier), this.nodes.button.innerHTML = Xo, this.nodes.button;\n  }\n  /**\n   * Wrap range with <i> tag\n   */\n  surround() {\n    document.execCommand(this.commandName);\n  }\n  /**\n   * Check selection and set activated state to button if there are <i> tag\n   */\n  checkState() {\n    const e = document.queryCommandState(this.commandName);\n    return this.nodes.button.classList.toggle(this.CSS.buttonActive, e), e;\n  }\n  /**\n   * Set a shortcut\n   */\n  get shortcut() {\n    return \"CMD+I\";\n  }\n}\nut.isInline = !0;\nut.title = \"Italic\";\nclass pt {\n  /**\n   * @param api - Editor.js API\n   */\n  constructor({ api: e }) {\n    this.commandLink = \"createLink\", this.commandUnlink = \"unlink\", this.ENTER_KEY = 13, this.CSS = {\n      button: \"ce-inline-tool\",\n      buttonActive: \"ce-inline-tool--active\",\n      buttonModifier: \"ce-inline-tool--link\",\n      buttonUnlink: \"ce-inline-tool--unlink\",\n      input: \"ce-inline-tool-input\",\n      inputShowed: \"ce-inline-tool-input--showed\"\n    }, this.nodes = {\n      button: null,\n      input: null\n    }, this.inputOpened = !1, this.toolbar = e.toolbar, this.inlineToolbar = e.inlineToolbar, this.notifier = e.notifier, this.i18n = e.i18n, this.selection = new b();\n  }\n  /**\n   * Sanitizer Rule\n   * Leave <a> tags\n   *\n   * @returns {object}\n   */\n  static get sanitize() {\n    return {\n      a: {\n        href: !0,\n        target: \"_blank\",\n        rel: \"nofollow\"\n      }\n    };\n  }\n  /**\n   * Create button for Inline Toolbar\n   */\n  render() {\n    return this.nodes.button = document.createElement(\"button\"), this.nodes.button.type = \"button\", this.nodes.button.classList.add(this.CSS.button, this.CSS.buttonModifier), this.nodes.button.innerHTML = xt, this.nodes.button;\n  }\n  /**\n   * Input for the link\n   */\n  renderActions() {\n    return this.nodes.input = document.createElement(\"input\"), this.nodes.input.placeholder = this.i18n.t(\"Add a link\"), this.nodes.input.enterKeyHint = \"done\", this.nodes.input.classList.add(this.CSS.input), this.nodes.input.addEventListener(\"keydown\", (e) => {\n      e.keyCode === this.ENTER_KEY && this.enterPressed(e);\n    }), this.nodes.input;\n  }\n  /**\n   * Handle clicks on the Inline Toolbar icon\n   *\n   * @param {Range} range - range to wrap with link\n   */\n  surround(e) {\n    if (e) {\n      this.inputOpened ? (this.selection.restore(), this.selection.removeFakeBackground()) : (this.selection.setFakeBackground(), this.selection.save());\n      const t = this.selection.findParentTag(\"A\");\n      if (t) {\n        this.selection.expandToTag(t), this.unlink(), this.closeActions(), this.checkState(), this.toolbar.close();\n        return;\n      }\n    }\n    this.toggleActions();\n  }\n  /**\n   * Check selection and set activated state to button if there are <a> tag\n   */\n  checkState() {\n    const e = this.selection.findParentTag(\"A\");\n    if (e) {\n      this.nodes.button.innerHTML = Go, this.nodes.button.classList.add(this.CSS.buttonUnlink), this.nodes.button.classList.add(this.CSS.buttonActive), this.openActions();\n      const t = e.getAttribute(\"href\");\n      this.nodes.input.value = t !== \"null\" ? t : \"\", this.selection.save();\n    } else\n      this.nodes.button.innerHTML = xt, this.nodes.button.classList.remove(this.CSS.buttonUnlink), this.nodes.button.classList.remove(this.CSS.buttonActive);\n    return !!e;\n  }\n  /**\n   * Function called with Inline Toolbar closing\n   */\n  clear() {\n    this.closeActions();\n  }\n  /**\n   * Set a shortcut\n   */\n  get shortcut() {\n    return \"CMD+K\";\n  }\n  /**\n   * Show/close link input\n   */\n  toggleActions() {\n    this.inputOpened ? this.closeActions(!1) : this.openActions(!0);\n  }\n  /**\n   * @param {boolean} needFocus - on link creation we need to focus input. On editing - nope.\n   */\n  openActions(e = !1) {\n    this.nodes.input.classList.add(this.CSS.inputShowed), e && this.nodes.input.focus(), this.inputOpened = !0;\n  }\n  /**\n   * Close input\n   *\n   * @param {boolean} clearSavedSelection  we don't need to clear saved selection\n   *                                        on toggle-clicks on the icon of opened Toolbar\n   */\n  closeActions(e = !0) {\n    if (this.selection.isFakeBackgroundEnabled) {\n      const t = new b();\n      t.save(), this.selection.restore(), this.selection.removeFakeBackground(), t.restore();\n    }\n    this.nodes.input.classList.remove(this.CSS.inputShowed), this.nodes.input.value = \"\", e && this.selection.clearSaved(), this.inputOpened = !1;\n  }\n  /**\n   * Enter pressed on input\n   *\n   * @param {KeyboardEvent} event - enter keydown event\n   */\n  enterPressed(e) {\n    let t = this.nodes.input.value || \"\";\n    if (!t.trim()) {\n      this.selection.restore(), this.unlink(), e.preventDefault(), this.closeActions();\n      return;\n    }\n    if (!this.validateURL(t)) {\n      this.notifier.show({\n        message: \"Pasted link is not valid.\",\n        style: \"error\"\n      }), I(\"Incorrect Link pasted\", \"warn\", t);\n      return;\n    }\n    t = this.prepareLink(t), this.selection.restore(), this.selection.removeFakeBackground(), this.insertLink(t), e.preventDefault(), e.stopPropagation(), e.stopImmediatePropagation(), this.selection.collapseToEnd(), this.inlineToolbar.close();\n  }\n  /**\n   * Detects if passed string is URL\n   *\n   * @param {string} str - string to validate\n   * @returns {boolean}\n   */\n  validateURL(e) {\n    return !/\\s/.test(e);\n  }\n  /**\n   * Process link before injection\n   * - sanitize\n   * - add protocol for links like 'google.com'\n   *\n   * @param {string} link - raw user input\n   */\n  prepareLink(e) {\n    return e = e.trim(), e = this.addProtocol(e), e;\n  }\n  /**\n   * Add 'http' protocol to the links like 'vc.ru', 'google.com'\n   *\n   * @param {string} link - string to process\n   */\n  addProtocol(e) {\n    if (/^(\\w+):(\\/\\/)?/.test(e))\n      return e;\n    const t = /^\\/[^/\\s]/.test(e), o = e.substring(0, 1) === \"#\", i = /^\\/\\/[^/\\s]/.test(e);\n    return !t && !o && !i && (e = \"http://\" + e), e;\n  }\n  /**\n   * Inserts <a> tag with \"href\"\n   *\n   * @param {string} link - \"href\" value\n   */\n  insertLink(e) {\n    const t = this.selection.findParentTag(\"A\");\n    t && this.selection.expandToTag(t), document.execCommand(this.commandLink, !1, e);\n  }\n  /**\n   * Removes <a> tag\n   */\n  unlink() {\n    document.execCommand(this.commandUnlink);\n  }\n}\npt.isInline = !0;\npt.title = \"Link\";\nclass ao {\n  /**\n   * @param api - Editor.js API\n   */\n  constructor({ api: e }) {\n    this.i18nAPI = e.i18n, this.blocksAPI = e.blocks, this.selectionAPI = e.selection, this.toolsAPI = e.tools, this.caretAPI = e.caret;\n  }\n  /**\n   * Returns tool's UI config\n   */\n  async render() {\n    const e = b.get(), t = this.blocksAPI.getBlockByElement(e.anchorNode);\n    if (t === void 0)\n      return [];\n    const o = this.toolsAPI.getBlockTools(), i = await zt(t, o);\n    if (i.length === 0)\n      return [];\n    const s = i.reduce((c, u) => {\n      var h;\n      return (h = u.toolbox) == null || h.forEach((p) => {\n        c.push({\n          icon: p.icon,\n          title: p.title,\n          name: u.name,\n          closeOnActivate: !0,\n          onActivate: async () => {\n            const g = await this.blocksAPI.convert(t.id, u.name, p.data);\n            this.caretAPI.setToBlock(g, \"end\");\n          }\n        });\n      }), c;\n    }, []), r = await t.getActiveToolboxEntry(), l = r !== void 0 ? r.icon : jt, a = !ue();\n    return {\n      icon: l,\n      name: \"convert-to\",\n      hint: {\n        title: this.i18nAPI.t(\"Convert to\")\n      },\n      children: {\n        searchable: a,\n        items: s,\n        onOpen: () => {\n          a && (this.selectionAPI.setFakeBackground(), this.selectionAPI.save());\n        },\n        onClose: () => {\n          a && (this.selectionAPI.restore(), this.selectionAPI.removeFakeBackground());\n        }\n      }\n    };\n  }\n}\nao.isInline = !0;\nclass co {\n  /**\n   * @param options - constructor options\n   * @param options.data - stub tool data\n   * @param options.api - Editor.js API\n   */\n  constructor({ data: e, api: t }) {\n    this.CSS = {\n      wrapper: \"ce-stub\",\n      info: \"ce-stub__info\",\n      title: \"ce-stub__title\",\n      subtitle: \"ce-stub__subtitle\"\n    }, this.api = t, this.title = e.title || this.api.i18n.t(\"Error\"), this.subtitle = this.api.i18n.t(\"The block can not be displayed correctly.\"), this.savedData = e.savedData, this.wrapper = this.make();\n  }\n  /**\n   * Returns stub holder\n   *\n   * @returns {HTMLElement}\n   */\n  render() {\n    return this.wrapper;\n  }\n  /**\n   * Return original Tool data\n   *\n   * @returns {BlockToolData}\n   */\n  save() {\n    return this.savedData;\n  }\n  /**\n   * Create Tool html markup\n   *\n   * @returns {HTMLElement}\n   */\n  make() {\n    const e = d.make(\"div\", this.CSS.wrapper), t = Jo, o = d.make(\"div\", this.CSS.info), i = d.make(\"div\", this.CSS.title, {\n      textContent: this.title\n    }), s = d.make(\"div\", this.CSS.subtitle, {\n      textContent: this.subtitle\n    });\n    return e.innerHTML = t, o.appendChild(i), o.appendChild(s), e.appendChild(o), e;\n  }\n}\nco.isReadOnlySupported = !0;\nclass hs extends ct {\n  constructor() {\n    super(...arguments), this.type = Fe.Inline;\n  }\n  /**\n   * Returns title for Inline Tool if specified by user\n   */\n  get title() {\n    return this.constructable[at.Title];\n  }\n  /**\n   * Constructs new InlineTool instance from constructable\n   */\n  create() {\n    return new this.constructable({\n      api: this.api,\n      config: this.settings\n    });\n  }\n}\nclass us extends ct {\n  constructor() {\n    super(...arguments), this.type = Fe.Tune;\n  }\n  /**\n   * Constructs new BlockTune instance from constructable\n   *\n   * @param data - Tune data\n   * @param block - Block API object\n   */\n  create(e, t) {\n    return new this.constructable({\n      api: this.api,\n      config: this.settings,\n      block: t,\n      data: e\n    });\n  }\n}\nclass F extends Map {\n  /**\n   * Returns Block Tools collection\n   */\n  get blockTools() {\n    const e = Array.from(this.entries()).filter(([, t]) => t.isBlock());\n    return new F(e);\n  }\n  /**\n   * Returns Inline Tools collection\n   */\n  get inlineTools() {\n    const e = Array.from(this.entries()).filter(([, t]) => t.isInline());\n    return new F(e);\n  }\n  /**\n   * Returns Block Tunes collection\n   */\n  get blockTunes() {\n    const e = Array.from(this.entries()).filter(([, t]) => t.isTune());\n    return new F(e);\n  }\n  /**\n   * Returns internal Tools collection\n   */\n  get internalTools() {\n    const e = Array.from(this.entries()).filter(([, t]) => t.isInternal);\n    return new F(e);\n  }\n  /**\n   * Returns Tools collection provided by user\n   */\n  get externalTools() {\n    const e = Array.from(this.entries()).filter(([, t]) => !t.isInternal);\n    return new F(e);\n  }\n}\nvar ps = Object.defineProperty, fs = Object.getOwnPropertyDescriptor, ho = (n, e, t, o) => {\n  for (var i = o > 1 ? void 0 : o ? fs(e, t) : e, s = n.length - 1, r; s >= 0; s--)\n    (r = n[s]) && (i = (o ? r(e, t, i) : r(i)) || i);\n  return o && i && ps(e, t, i), i;\n};\nclass ft extends ct {\n  constructor() {\n    super(...arguments), this.type = Fe.Block, this.inlineTools = new F(), this.tunes = new F();\n  }\n  /**\n   * Creates new Tool instance\n   *\n   * @param data - Tool data\n   * @param block - BlockAPI for current Block\n   * @param readOnly - True if Editor is in read-only mode\n   */\n  create(e, t, o) {\n    return new this.constructable({\n      data: e,\n      block: t,\n      readOnly: o,\n      api: this.api,\n      config: this.settings\n    });\n  }\n  /**\n   * Returns true if read-only mode is supported by Tool\n   */\n  get isReadOnlySupported() {\n    return this.constructable[ae.IsReadOnlySupported] === !0;\n  }\n  /**\n   * Returns true if Tool supports linebreaks\n   */\n  get isLineBreaksEnabled() {\n    return this.constructable[ae.IsEnabledLineBreaks];\n  }\n  /**\n   * Returns Tool toolbox configuration (internal or user-specified).\n   *\n   * Merges internal and user-defined toolbox configs based on the following rules:\n   *\n   * - If both internal and user-defined toolbox configs are arrays their items are merged.\n   * Length of the second one is kept.\n   *\n   * - If both are objects their properties are merged.\n   *\n   * - If one is an object and another is an array than internal config is replaced with user-defined\n   * config. This is made to allow user to override default tool's toolbox representation (single/multiple entries)\n   */\n  get toolbox() {\n    const e = this.constructable[ae.Toolbox], t = this.config[Se.Toolbox];\n    if (!X(e) && t !== !1)\n      return t ? Array.isArray(e) ? Array.isArray(t) ? t.map((o, i) => {\n        const s = e[i];\n        return s ? {\n          ...s,\n          ...o\n        } : o;\n      }) : [t] : Array.isArray(t) ? t : [\n        {\n          ...e,\n          ...t\n        }\n      ] : Array.isArray(e) ? e : [e];\n  }\n  /**\n   * Returns Tool conversion configuration\n   */\n  get conversionConfig() {\n    return this.constructable[ae.ConversionConfig];\n  }\n  /**\n   * Returns enabled inline tools for Tool\n   */\n  get enabledInlineTools() {\n    return this.config[Se.EnabledInlineTools] || !1;\n  }\n  /**\n   * Returns enabled tunes for Tool\n   */\n  get enabledBlockTunes() {\n    return this.config[Se.EnabledBlockTunes];\n  }\n  /**\n   * Returns Tool paste configuration\n   */\n  get pasteConfig() {\n    return this.constructable[ae.PasteConfig] ?? {};\n  }\n  get sanitizeConfig() {\n    const e = super.sanitizeConfig, t = this.baseSanitizeConfig;\n    if (X(e))\n      return t;\n    const o = {};\n    for (const i in e)\n      if (Object.prototype.hasOwnProperty.call(e, i)) {\n        const s = e[i];\n        R(s) ? o[i] = Object.assign({}, t, s) : o[i] = s;\n      }\n    return o;\n  }\n  get baseSanitizeConfig() {\n    const e = {};\n    return Array.from(this.inlineTools.values()).forEach((t) => Object.assign(e, t.sanitizeConfig)), Array.from(this.tunes.values()).forEach((t) => Object.assign(e, t.sanitizeConfig)), e;\n  }\n}\nho([\n  he\n], ft.prototype, \"sanitizeConfig\", 1);\nho([\n  he\n], ft.prototype, \"baseSanitizeConfig\", 1);\nclass gs {\n  /**\n   * @class\n   * @param config - tools config\n   * @param editorConfig - EditorJS config\n   * @param api - EditorJS API module\n   */\n  constructor(e, t, o) {\n    this.api = o, this.config = e, this.editorConfig = t;\n  }\n  /**\n   * Returns Tool object based on it's type\n   *\n   * @param name - tool name\n   */\n  get(e) {\n    const { class: t, isInternal: o = !1, ...i } = this.config[e], s = this.getConstructor(t), r = t[Qe.IsTune];\n    return new s({\n      name: e,\n      constructable: t,\n      config: i,\n      api: this.api.getMethodsForTool(e, r),\n      isDefault: e === this.editorConfig.defaultBlock,\n      defaultPlaceholder: this.editorConfig.placeholder,\n      isInternal: o\n    });\n  }\n  /**\n   * Find appropriate Tool object constructor for Tool constructable\n   *\n   * @param constructable - Tools constructable\n   */\n  getConstructor(e) {\n    switch (!0) {\n      case e[at.IsInline]:\n        return hs;\n      case e[Qe.IsTune]:\n        return us;\n      default:\n        return ft;\n    }\n  }\n}\nclass uo {\n  /**\n   * MoveDownTune constructor\n   *\n   * @param {API} api  Editor's API\n   */\n  constructor({ api: e }) {\n    this.CSS = {\n      animation: \"wobble\"\n    }, this.api = e;\n  }\n  /**\n   * Tune's appearance in block settings menu\n   */\n  render() {\n    return {\n      icon: Uo,\n      title: this.api.i18n.t(\"Move down\"),\n      onActivate: () => this.handleClick(),\n      name: \"move-down\"\n    };\n  }\n  /**\n   * Handle clicks on 'move down' button\n   */\n  handleClick() {\n    const e = this.api.blocks.getCurrentBlockIndex(), t = this.api.blocks.getBlockByIndex(e + 1);\n    if (!t)\n      throw new Error(\"Unable to move Block down since it is already the last\");\n    const o = t.holder, i = o.getBoundingClientRect();\n    let s = Math.abs(window.innerHeight - o.offsetHeight);\n    i.top < window.innerHeight && (s = window.scrollY + o.offsetHeight), window.scrollTo(0, s), this.api.blocks.move(e + 1), this.api.toolbar.toggleBlockSettings(!0);\n  }\n}\nuo.isTune = !0;\nclass po {\n  /**\n   * DeleteTune constructor\n   *\n   * @param {API} api - Editor's API\n   */\n  constructor({ api: e }) {\n    this.api = e;\n  }\n  /**\n   * Tune's appearance in block settings menu\n   */\n  render() {\n    return {\n      icon: Wo,\n      title: this.api.i18n.t(\"Delete\"),\n      name: \"delete\",\n      confirmation: {\n        title: this.api.i18n.t(\"Click to delete\"),\n        onActivate: () => this.handleClick()\n      }\n    };\n  }\n  /**\n   * Delete block conditions passed\n   */\n  handleClick() {\n    this.api.blocks.delete();\n  }\n}\npo.isTune = !0;\nclass fo {\n  /**\n   * MoveUpTune constructor\n   *\n   * @param {API} api - Editor's API\n   */\n  constructor({ api: e }) {\n    this.CSS = {\n      animation: \"wobble\"\n    }, this.api = e;\n  }\n  /**\n   * Tune's appearance in block settings menu\n   */\n  render() {\n    return {\n      icon: Yo,\n      title: this.api.i18n.t(\"Move up\"),\n      onActivate: () => this.handleClick(),\n      name: \"move-up\"\n    };\n  }\n  /**\n   * Move current block up\n   */\n  handleClick() {\n    const e = this.api.blocks.getCurrentBlockIndex(), t = this.api.blocks.getBlockByIndex(e), o = this.api.blocks.getBlockByIndex(e - 1);\n    if (e === 0 || !t || !o)\n      throw new Error(\"Unable to move Block up since it is already the first\");\n    const i = t.holder, s = o.holder, r = i.getBoundingClientRect(), l = s.getBoundingClientRect();\n    let a;\n    l.top > 0 ? a = Math.abs(r.top) - Math.abs(l.top) : a = Math.abs(r.top) + l.height, window.scrollBy(0, -1 * a), this.api.blocks.move(e - 1), this.api.toolbar.toggleBlockSettings(!0);\n  }\n}\nfo.isTune = !0;\nvar ms = Object.defineProperty, bs = Object.getOwnPropertyDescriptor, ks = (n, e, t, o) => {\n  for (var i = o > 1 ? void 0 : o ? bs(e, t) : e, s = n.length - 1, r; s >= 0; s--)\n    (r = n[s]) && (i = (o ? r(e, t, i) : r(i)) || i);\n  return o && i && ms(e, t, i), i;\n};\nclass go extends y {\n  constructor() {\n    super(...arguments), this.stubTool = \"stub\", this.toolsAvailable = new F(), this.toolsUnavailable = new F();\n  }\n  /**\n   * Returns available Tools\n   */\n  get available() {\n    return this.toolsAvailable;\n  }\n  /**\n   * Returns unavailable Tools\n   */\n  get unavailable() {\n    return this.toolsUnavailable;\n  }\n  /**\n   * Return Tools for the Inline Toolbar\n   */\n  get inlineTools() {\n    return this.available.inlineTools;\n  }\n  /**\n   * Return editor block tools\n   */\n  get blockTools() {\n    return this.available.blockTools;\n  }\n  /**\n   * Return available Block Tunes\n   *\n   * @returns {object} - object of Inline Tool's classes\n   */\n  get blockTunes() {\n    return this.available.blockTunes;\n  }\n  /**\n   * Returns default Tool object\n   */\n  get defaultTool() {\n    return this.blockTools.get(this.config.defaultBlock);\n  }\n  /**\n   * Returns internal tools\n   */\n  get internal() {\n    return this.available.internalTools;\n  }\n  /**\n   * Creates instances via passed or default configuration\n   *\n   * @returns {Promise<void>}\n   */\n  async prepare() {\n    if (this.validateTools(), this.config.tools = qe({}, this.internalTools, this.config.tools), !Object.prototype.hasOwnProperty.call(this.config, \"tools\") || Object.keys(this.config.tools).length === 0)\n      throw Error(\"Can't start without tools\");\n    const e = this.prepareConfig();\n    this.factory = new gs(e, this.config, this.Editor.API);\n    const t = this.getListOfPrepareFunctions(e);\n    if (t.length === 0)\n      return Promise.resolve();\n    await Eo(t, (o) => {\n      this.toolPrepareMethodSuccess(o);\n    }, (o) => {\n      this.toolPrepareMethodFallback(o);\n    }), this.prepareBlockTools();\n  }\n  getAllInlineToolsSanitizeConfig() {\n    const e = {};\n    return Array.from(this.inlineTools.values()).forEach((t) => {\n      Object.assign(e, t.sanitizeConfig);\n    }), e;\n  }\n  /**\n   * Calls each Tool reset method to clean up anything set by Tool\n   */\n  destroy() {\n    Object.values(this.available).forEach(async (e) => {\n      O(e.reset) && await e.reset();\n    });\n  }\n  /**\n   * Returns internal tools\n   * Includes Bold, Italic, Link and Paragraph\n   */\n  get internalTools() {\n    return {\n      convertTo: {\n        class: ao,\n        isInternal: !0\n      },\n      link: {\n        class: pt,\n        isInternal: !0\n      },\n      bold: {\n        class: ht,\n        isInternal: !0\n      },\n      italic: {\n        class: ut,\n        isInternal: !0\n      },\n      paragraph: {\n        class: dt,\n        inlineToolbar: !0,\n        isInternal: !0\n      },\n      stub: {\n        class: co,\n        isInternal: !0\n      },\n      moveUp: {\n        class: fo,\n        isInternal: !0\n      },\n      delete: {\n        class: po,\n        isInternal: !0\n      },\n      moveDown: {\n        class: uo,\n        isInternal: !0\n      }\n    };\n  }\n  /**\n   * Tool prepare method success callback\n   *\n   * @param {object} data - append tool to available list\n   */\n  toolPrepareMethodSuccess(e) {\n    const t = this.factory.get(e.toolName);\n    if (t.isInline()) {\n      const i = [\"render\"].filter((s) => !t.create()[s]);\n      if (i.length) {\n        I(\n          `Incorrect Inline Tool: ${t.name}. Some of required methods is not implemented %o`,\n          \"warn\",\n          i\n        ), this.toolsUnavailable.set(t.name, t);\n        return;\n      }\n    }\n    this.toolsAvailable.set(t.name, t);\n  }\n  /**\n   * Tool prepare method fail callback\n   *\n   * @param {object} data - append tool to unavailable list\n   */\n  toolPrepareMethodFallback(e) {\n    this.toolsUnavailable.set(e.toolName, this.factory.get(e.toolName));\n  }\n  /**\n   * Binds prepare function of plugins with user or default config\n   *\n   * @returns {Array} list of functions that needs to be fired sequentially\n   * @param config - tools config\n   */\n  getListOfPrepareFunctions(e) {\n    const t = [];\n    return Object.entries(e).forEach(([o, i]) => {\n      t.push({\n        // eslint-disable-next-line @typescript-eslint/no-empty-function\n        function: O(i.class.prepare) ? i.class.prepare : () => {\n        },\n        data: {\n          toolName: o,\n          config: i.config\n        }\n      });\n    }), t;\n  }\n  /**\n   * Assign enabled Inline Tools and Block Tunes for Block Tool\n   */\n  prepareBlockTools() {\n    Array.from(this.blockTools.values()).forEach((e) => {\n      this.assignInlineToolsToBlockTool(e), this.assignBlockTunesToBlockTool(e);\n    });\n  }\n  /**\n   * Assign enabled Inline Tools for Block Tool\n   *\n   * @param tool - Block Tool\n   */\n  assignInlineToolsToBlockTool(e) {\n    if (this.config.inlineToolbar !== !1) {\n      if (e.enabledInlineTools === !0) {\n        e.inlineTools = new F(\n          Array.isArray(this.config.inlineToolbar) ? this.config.inlineToolbar.map((t) => [t, this.inlineTools.get(t)]) : Array.from(this.inlineTools.entries())\n        );\n        return;\n      }\n      Array.isArray(e.enabledInlineTools) && (e.inlineTools = new F(\n        /** Prepend ConvertTo Inline Tool */\n        [\"convertTo\", ...e.enabledInlineTools].map((t) => [t, this.inlineTools.get(t)])\n      ));\n    }\n  }\n  /**\n   * Assign enabled Block Tunes for Block Tool\n   *\n   * @param tool  Block Tool\n   */\n  assignBlockTunesToBlockTool(e) {\n    if (e.enabledBlockTunes !== !1) {\n      if (Array.isArray(e.enabledBlockTunes)) {\n        const t = new F(\n          e.enabledBlockTunes.map((o) => [o, this.blockTunes.get(o)])\n        );\n        e.tunes = new F([...t, ...this.blockTunes.internalTools]);\n        return;\n      }\n      if (Array.isArray(this.config.tunes)) {\n        const t = new F(\n          this.config.tunes.map((o) => [o, this.blockTunes.get(o)])\n        );\n        e.tunes = new F([...t, ...this.blockTunes.internalTools]);\n        return;\n      }\n      e.tunes = this.blockTunes.internalTools;\n    }\n  }\n  /**\n   * Validate Tools configuration objects and throw Error for user if it is invalid\n   */\n  validateTools() {\n    for (const e in this.config.tools)\n      if (Object.prototype.hasOwnProperty.call(this.config.tools, e)) {\n        if (e in this.internalTools)\n          return;\n        const t = this.config.tools[e];\n        if (!O(t) && !O(t.class))\n          throw Error(\n            `Tool ${e} must be a constructor function or an object with function in the class property`\n          );\n      }\n  }\n  /**\n   * Unify tools config\n   */\n  prepareConfig() {\n    const e = {};\n    for (const t in this.config.tools)\n      R(this.config.tools[t]) ? e[t] = this.config.tools[t] : e[t] = { class: this.config.tools[t] };\n    return e;\n  }\n}\nks([\n  he\n], go.prototype, \"getAllInlineToolsSanitizeConfig\", 1);\nconst vs = `:root{--selectionColor: #e1f2ff;--inlineSelectionColor: #d4ecff;--bg-light: #eff2f5;--grayText: #707684;--color-dark: #1D202B;--color-active-icon: #388AE5;--color-gray-border: rgba(201, 201, 204, .48);--content-width: 650px;--narrow-mode-right-padding: 50px;--toolbox-buttons-size: 26px;--toolbox-buttons-size--mobile: 36px;--icon-size: 20px;--icon-size--mobile: 28px;--block-padding-vertical: .4em;--color-line-gray: #EFF0F1 }.codex-editor{position:relative;-webkit-box-sizing:border-box;box-sizing:border-box;z-index:1}.codex-editor .hide{display:none}.codex-editor__redactor [contenteditable]:empty:after{content:\"\\\\feff\"}@media (min-width: 651px){.codex-editor--narrow .codex-editor__redactor{margin-right:50px}}@media (min-width: 651px){.codex-editor--narrow.codex-editor--rtl .codex-editor__redactor{margin-left:50px;margin-right:0}}@media (min-width: 651px){.codex-editor--narrow .ce-toolbar__actions{right:-5px}}.codex-editor-copyable{position:absolute;height:1px;width:1px;top:-400%;opacity:.001}.codex-editor-overlay{position:fixed;top:0;left:0;right:0;bottom:0;z-index:999;pointer-events:none;overflow:hidden}.codex-editor-overlay__container{position:relative;pointer-events:auto;z-index:0}.codex-editor-overlay__rectangle{position:absolute;pointer-events:none;background-color:#2eaadc33;border:1px solid transparent}.codex-editor svg{max-height:100%}.codex-editor path{stroke:currentColor}.codex-editor ::-moz-selection{background-color:#d4ecff}.codex-editor ::selection{background-color:#d4ecff}.codex-editor--toolbox-opened [contentEditable=true][data-placeholder]:focus:before{opacity:0!important}.ce-scroll-locked{overflow:hidden}.ce-scroll-locked--hard{overflow:hidden;top:calc(-1 * var(--window-scroll-offset));position:fixed;width:100%}.ce-toolbar{position:absolute;left:0;right:0;top:0;-webkit-transition:opacity .1s ease;transition:opacity .1s ease;will-change:opacity,top;display:none}.ce-toolbar--opened{display:block}.ce-toolbar__content{max-width:650px;margin:0 auto;position:relative}.ce-toolbar__plus{color:#1d202b;cursor:pointer;width:26px;height:26px;border-radius:7px;display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-ms-flex-negative:0;flex-shrink:0}@media (max-width: 650px){.ce-toolbar__plus{width:36px;height:36px}}@media (hover: hover){.ce-toolbar__plus:hover{background-color:#eff2f5}}.ce-toolbar__plus--active{background-color:#eff2f5;-webkit-animation:bounceIn .75s 1;animation:bounceIn .75s 1;-webkit-animation-fill-mode:forwards;animation-fill-mode:forwards}.ce-toolbar__plus-shortcut{opacity:.6;word-spacing:-2px;margin-top:5px}@media (max-width: 650px){.ce-toolbar__plus{position:absolute;background-color:#fff;border:1px solid #E8E8EB;-webkit-box-shadow:0 3px 15px -3px rgba(13,20,33,.13);box-shadow:0 3px 15px -3px #0d142121;border-radius:6px;z-index:2;position:static}.ce-toolbar__plus--left-oriented:before{left:15px;margin-left:0}.ce-toolbar__plus--right-oriented:before{left:auto;right:15px;margin-left:0}}.ce-toolbar__actions{position:absolute;right:100%;opacity:0;display:-webkit-box;display:-ms-flexbox;display:flex;padding-right:5px}.ce-toolbar__actions--opened{opacity:1}@media (max-width: 650px){.ce-toolbar__actions{right:auto}}.ce-toolbar__settings-btn{color:#1d202b;width:26px;height:26px;border-radius:7px;display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;margin-left:3px;cursor:pointer;user-select:none}@media (max-width: 650px){.ce-toolbar__settings-btn{width:36px;height:36px}}@media (hover: hover){.ce-toolbar__settings-btn:hover{background-color:#eff2f5}}.ce-toolbar__settings-btn--active{background-color:#eff2f5;-webkit-animation:bounceIn .75s 1;animation:bounceIn .75s 1;-webkit-animation-fill-mode:forwards;animation-fill-mode:forwards}@media (min-width: 651px){.ce-toolbar__settings-btn{width:24px}}.ce-toolbar__settings-btn--hidden{display:none}@media (max-width: 650px){.ce-toolbar__settings-btn{position:absolute;background-color:#fff;border:1px solid #E8E8EB;-webkit-box-shadow:0 3px 15px -3px rgba(13,20,33,.13);box-shadow:0 3px 15px -3px #0d142121;border-radius:6px;z-index:2;position:static}.ce-toolbar__settings-btn--left-oriented:before{left:15px;margin-left:0}.ce-toolbar__settings-btn--right-oriented:before{left:auto;right:15px;margin-left:0}}.ce-toolbar__plus svg,.ce-toolbar__settings-btn svg{width:24px;height:24px}@media (min-width: 651px){.codex-editor--narrow .ce-toolbar__plus{left:5px}}@media (min-width: 651px){.codex-editor--narrow .ce-toolbox .ce-popover{right:0;left:auto;left:initial}}.ce-inline-toolbar{--y-offset: 8px;--color-background-icon-active: rgba(56, 138, 229, .1);--color-text-icon-active: #388AE5;--color-text-primary: black;position:absolute;visibility:hidden;-webkit-transition:opacity .25s ease;transition:opacity .25s ease;will-change:opacity,left,top;top:0;left:0;z-index:3;opacity:1;visibility:visible}.ce-inline-toolbar [hidden]{display:none!important}.ce-inline-toolbar__toggler-and-button-wrapper{display:-webkit-box;display:-ms-flexbox;display:flex;width:100%;padding:0 6px}.ce-inline-toolbar__buttons{display:-webkit-box;display:-ms-flexbox;display:flex}.ce-inline-toolbar__dropdown{display:-webkit-box;display:-ms-flexbox;display:flex;padding:6px;margin:0 6px 0 -6px;-webkit-box-align:center;-ms-flex-align:center;align-items:center;cursor:pointer;border-right:1px solid rgba(201,201,204,.48);-webkit-box-sizing:border-box;box-sizing:border-box}@media (hover: hover){.ce-inline-toolbar__dropdown:hover{background:#eff2f5}}.ce-inline-toolbar__dropdown--hidden{display:none}.ce-inline-toolbar__dropdown-content,.ce-inline-toolbar__dropdown-arrow{display:-webkit-box;display:-ms-flexbox;display:flex}.ce-inline-toolbar__dropdown-content svg,.ce-inline-toolbar__dropdown-arrow svg{width:20px;height:20px}.ce-inline-toolbar__shortcut{opacity:.6;word-spacing:-3px;margin-top:3px}.ce-inline-tool{color:var(--color-text-primary);display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;border:0;border-radius:4px;line-height:normal;height:100%;padding:0;width:28px;background-color:transparent;cursor:pointer}@media (max-width: 650px){.ce-inline-tool{width:36px;height:36px}}@media (hover: hover){.ce-inline-tool:hover{background-color:#f8f8f8}}.ce-inline-tool svg{display:block;width:20px;height:20px}@media (max-width: 650px){.ce-inline-tool svg{width:28px;height:28px}}.ce-inline-tool--link .icon--unlink,.ce-inline-tool--unlink .icon--link{display:none}.ce-inline-tool--unlink .icon--unlink{display:inline-block;margin-bottom:-1px}.ce-inline-tool-input{background:#F8F8F8;border:1px solid rgba(226,226,229,.2);border-radius:6px;padding:4px 8px;font-size:14px;line-height:22px;outline:none;margin:0;width:100%;-webkit-box-sizing:border-box;box-sizing:border-box;display:none;font-weight:500;-webkit-appearance:none;font-family:inherit}@media (max-width: 650px){.ce-inline-tool-input{font-size:15px;font-weight:500}}.ce-inline-tool-input::-webkit-input-placeholder{color:#707684}.ce-inline-tool-input::-moz-placeholder{color:#707684}.ce-inline-tool-input:-ms-input-placeholder{color:#707684}.ce-inline-tool-input::-ms-input-placeholder{color:#707684}.ce-inline-tool-input::placeholder{color:#707684}.ce-inline-tool-input--showed{display:block}.ce-inline-tool--active{background:var(--color-background-icon-active);color:var(--color-text-icon-active)}@-webkit-keyframes fade-in{0%{opacity:0}to{opacity:1}}@keyframes fade-in{0%{opacity:0}to{opacity:1}}.ce-block{-webkit-animation:fade-in .3s ease;animation:fade-in .3s ease;-webkit-animation-fill-mode:none;animation-fill-mode:none;-webkit-animation-fill-mode:initial;animation-fill-mode:initial}.ce-block:first-of-type{margin-top:0}.ce-block--selected .ce-block__content{background:#e1f2ff}.ce-block--selected .ce-block__content [contenteditable]{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.ce-block--selected .ce-block__content img,.ce-block--selected .ce-block__content .ce-stub{opacity:.55}.ce-block--stretched .ce-block__content{max-width:none}.ce-block__content{position:relative;max-width:650px;margin:0 auto;-webkit-transition:background-color .15s ease;transition:background-color .15s ease}.ce-block--drop-target .ce-block__content:before{content:\"\";position:absolute;top:100%;left:-20px;margin-top:-1px;height:8px;width:8px;border:solid #388AE5;border-width:1px 1px 0 0;-webkit-transform-origin:right;transform-origin:right;-webkit-transform:rotate(45deg);transform:rotate(45deg)}.ce-block--drop-target .ce-block__content:after{content:\"\";position:absolute;top:100%;height:1px;width:100%;color:#388ae5;background:repeating-linear-gradient(90deg,#388AE5,#388AE5 1px,#fff 1px,#fff 6px)}.ce-block a{cursor:pointer;-webkit-text-decoration:underline;text-decoration:underline}.ce-block b{font-weight:700}.ce-block i{font-style:italic}@-webkit-keyframes bounceIn{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{-webkit-transform:scale3d(.9,.9,.9);transform:scale3d(.9,.9,.9)}20%{-webkit-transform:scale3d(1.03,1.03,1.03);transform:scale3d(1.03,1.03,1.03)}60%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}@keyframes bounceIn{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{-webkit-transform:scale3d(.9,.9,.9);transform:scale3d(.9,.9,.9)}20%{-webkit-transform:scale3d(1.03,1.03,1.03);transform:scale3d(1.03,1.03,1.03)}60%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}@-webkit-keyframes selectionBounce{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}50%{-webkit-transform:scale3d(1.01,1.01,1.01);transform:scale3d(1.01,1.01,1.01)}70%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}@keyframes selectionBounce{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}50%{-webkit-transform:scale3d(1.01,1.01,1.01);transform:scale3d(1.01,1.01,1.01)}70%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}@-webkit-keyframes buttonClicked{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{-webkit-transform:scale3d(.95,.95,.95);transform:scale3d(.95,.95,.95)}60%{-webkit-transform:scale3d(1.02,1.02,1.02);transform:scale3d(1.02,1.02,1.02)}80%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}@keyframes buttonClicked{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{-webkit-transform:scale3d(.95,.95,.95);transform:scale3d(.95,.95,.95)}60%{-webkit-transform:scale3d(1.02,1.02,1.02);transform:scale3d(1.02,1.02,1.02)}80%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}.cdx-block{padding:.4em 0}.cdx-block::-webkit-input-placeholder{line-height:normal!important}.cdx-input{border:1px solid rgba(201,201,204,.48);-webkit-box-shadow:inset 0 1px 2px 0 rgba(35,44,72,.06);box-shadow:inset 0 1px 2px #232c480f;border-radius:3px;padding:10px 12px;outline:none;width:100%;-webkit-box-sizing:border-box;box-sizing:border-box}.cdx-input[data-placeholder]:before{position:static!important}.cdx-input[data-placeholder]:before{display:inline-block;width:0;white-space:nowrap;pointer-events:none}.cdx-settings-button{display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;border-radius:3px;cursor:pointer;border:0;outline:none;background-color:transparent;vertical-align:bottom;color:inherit;margin:0;min-width:26px;min-height:26px}.cdx-settings-button--focused{background:rgba(34,186,255,.08)!important}.cdx-settings-button--focused{-webkit-box-shadow:inset 0 0 0px 1px rgba(7,161,227,.08);box-shadow:inset 0 0 0 1px #07a1e314}.cdx-settings-button--focused-animated{-webkit-animation-name:buttonClicked;animation-name:buttonClicked;-webkit-animation-duration:.25s;animation-duration:.25s}.cdx-settings-button--active{color:#388ae5}.cdx-settings-button svg{width:auto;height:auto}@media (max-width: 650px){.cdx-settings-button svg{width:28px;height:28px}}@media (max-width: 650px){.cdx-settings-button{width:36px;height:36px;border-radius:8px}}@media (hover: hover){.cdx-settings-button:hover{background-color:#eff2f5}}.cdx-loader{position:relative;border:1px solid rgba(201,201,204,.48)}.cdx-loader:before{content:\"\";position:absolute;left:50%;top:50%;width:18px;height:18px;margin:-11px 0 0 -11px;border:2px solid rgba(201,201,204,.48);border-left-color:#388ae5;border-radius:50%;-webkit-animation:cdxRotation 1.2s infinite linear;animation:cdxRotation 1.2s infinite linear}@-webkit-keyframes cdxRotation{0%{-webkit-transform:rotate(0deg);transform:rotate(0)}to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes cdxRotation{0%{-webkit-transform:rotate(0deg);transform:rotate(0)}to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}.cdx-button{padding:13px;border-radius:3px;border:1px solid rgba(201,201,204,.48);font-size:14.9px;background:#fff;-webkit-box-shadow:0 2px 2px 0 rgba(18,30,57,.04);box-shadow:0 2px 2px #121e390a;color:#707684;text-align:center;cursor:pointer}@media (hover: hover){.cdx-button:hover{background:#FBFCFE;-webkit-box-shadow:0 1px 3px 0 rgba(18,30,57,.08);box-shadow:0 1px 3px #121e3914}}.cdx-button svg{height:20px;margin-right:.2em;margin-top:-2px}.ce-stub{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding:12px 18px;margin:10px 0;border-radius:10px;background:#eff2f5;border:1px solid #EFF0F1;color:#707684;font-size:14px}.ce-stub svg{width:20px;height:20px}.ce-stub__info{margin-left:14px}.ce-stub__title{font-weight:500;text-transform:capitalize}.codex-editor.codex-editor--rtl{direction:rtl}.codex-editor.codex-editor--rtl .cdx-list{padding-left:0;padding-right:40px}.codex-editor.codex-editor--rtl .ce-toolbar__plus{right:-26px;left:auto}.codex-editor.codex-editor--rtl .ce-toolbar__actions{right:auto;left:-26px}@media (max-width: 650px){.codex-editor.codex-editor--rtl .ce-toolbar__actions{margin-left:0;margin-right:auto;padding-right:0;padding-left:10px}}.codex-editor.codex-editor--rtl .ce-settings{left:5px;right:auto}.codex-editor.codex-editor--rtl .ce-settings:before{right:auto;left:25px}.codex-editor.codex-editor--rtl .ce-settings__button:not(:nth-child(3n+3)){margin-left:3px;margin-right:0}.codex-editor.codex-editor--rtl .ce-conversion-tool__icon{margin-right:0;margin-left:10px}.codex-editor.codex-editor--rtl .ce-inline-toolbar__dropdown{border-right:0px solid transparent;border-left:1px solid rgba(201,201,204,.48);margin:0 -6px 0 6px}.codex-editor.codex-editor--rtl .ce-inline-toolbar__dropdown .icon--toggler-down{margin-left:0;margin-right:4px}@media (min-width: 651px){.codex-editor--narrow.codex-editor--rtl .ce-toolbar__plus{left:0;right:5px}}@media (min-width: 651px){.codex-editor--narrow.codex-editor--rtl .ce-toolbar__actions{left:-5px}}.cdx-search-field{--icon-margin-right: 10px;background:#F8F8F8;border:1px solid rgba(226,226,229,.2);border-radius:6px;padding:2px;display:grid;grid-template-columns:auto auto 1fr;grid-template-rows:auto}.cdx-search-field__icon{width:26px;height:26px;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;margin-right:var(--icon-margin-right)}.cdx-search-field__icon svg{width:20px;height:20px;color:#707684}.cdx-search-field__input{font-size:14px;outline:none;font-weight:500;font-family:inherit;border:0;background:transparent;margin:0;padding:0;line-height:22px;min-width:calc(100% - 26px - var(--icon-margin-right))}.cdx-search-field__input::-webkit-input-placeholder{color:#707684;font-weight:500}.cdx-search-field__input::-moz-placeholder{color:#707684;font-weight:500}.cdx-search-field__input:-ms-input-placeholder{color:#707684;font-weight:500}.cdx-search-field__input::-ms-input-placeholder{color:#707684;font-weight:500}.cdx-search-field__input::placeholder{color:#707684;font-weight:500}.ce-popover{--border-radius: 6px;--width: 200px;--max-height: 270px;--padding: 6px;--offset-from-target: 8px;--color-border: #EFF0F1;--color-shadow: rgba(13, 20, 33, .1);--color-background: white;--color-text-primary: black;--color-text-secondary: #707684;--color-border-icon: rgba(201, 201, 204, .48);--color-border-icon-disabled: #EFF0F1;--color-text-icon-active: #388AE5;--color-background-icon-active: rgba(56, 138, 229, .1);--color-background-item-focus: rgba(34, 186, 255, .08);--color-shadow-item-focus: rgba(7, 161, 227, .08);--color-background-item-hover: #F8F8F8;--color-background-item-confirm: #E24A4A;--color-background-item-confirm-hover: #CE4343;--popover-top: calc(100% + var(--offset-from-target));--popover-left: 0;--nested-popover-overlap: 4px;--icon-size: 20px;--item-padding: 3px;--item-height: calc(var(--icon-size) + 2 * var(--item-padding))}.ce-popover__container{min-width:var(--width);width:var(--width);max-height:var(--max-height);border-radius:var(--border-radius);overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-box-shadow:0px 3px 15px -3px var(--color-shadow);box-shadow:0 3px 15px -3px var(--color-shadow);position:absolute;left:var(--popover-left);top:var(--popover-top);background:var(--color-background);display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;z-index:4;opacity:0;max-height:0;pointer-events:none;padding:0;border:none}.ce-popover--opened>.ce-popover__container{opacity:1;padding:var(--padding);max-height:var(--max-height);pointer-events:auto;-webkit-animation:panelShowing .1s ease;animation:panelShowing .1s ease;border:1px solid var(--color-border)}@media (max-width: 650px){.ce-popover--opened>.ce-popover__container{-webkit-animation:panelShowingMobile .25s ease;animation:panelShowingMobile .25s ease}}.ce-popover--open-top .ce-popover__container{--popover-top: calc(-1 * (var(--offset-from-target) + var(--popover-height)))}.ce-popover--open-left .ce-popover__container{--popover-left: calc(-1 * var(--width) + 100%)}.ce-popover__items{overflow-y:auto;-ms-scroll-chaining:none;overscroll-behavior:contain}@media (max-width: 650px){.ce-popover__overlay{position:fixed;top:0;bottom:0;left:0;right:0;background:#1D202B;z-index:3;opacity:.5;-webkit-transition:opacity .12s ease-in;transition:opacity .12s ease-in;will-change:opacity;visibility:visible}}.ce-popover__overlay--hidden{display:none}@media (max-width: 650px){.ce-popover .ce-popover__container{--offset: 5px;position:fixed;max-width:none;min-width:calc(100% - var(--offset) * 2);left:var(--offset);right:var(--offset);bottom:calc(var(--offset) + env(safe-area-inset-bottom));top:auto;border-radius:10px}}.ce-popover__search{margin-bottom:5px}.ce-popover__nothing-found-message{color:#707684;display:none;cursor:default;padding:3px;font-size:14px;line-height:20px;font-weight:500;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.ce-popover__nothing-found-message--displayed{display:block}.ce-popover--nested .ce-popover__container{--popover-left: calc(var(--nesting-level) * (var(--width) - var(--nested-popover-overlap)));top:calc(var(--trigger-item-top) - var(--nested-popover-overlap));position:absolute}.ce-popover--open-top.ce-popover--nested .ce-popover__container{top:calc(var(--trigger-item-top) - var(--popover-height) + var(--item-height) + var(--offset-from-target) + var(--nested-popover-overlap))}.ce-popover--open-left .ce-popover--nested .ce-popover__container{--popover-left: calc(-1 * (var(--nesting-level) + 1) * var(--width) + 100%)}.ce-popover-item-separator{padding:4px 3px}.ce-popover-item-separator--hidden{display:none}.ce-popover-item-separator__line{height:1px;background:var(--color-border);width:100%}.ce-popover-item-html--hidden{display:none}.ce-popover-item{--border-radius: 6px;border-radius:var(--border-radius);display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding:var(--item-padding);color:var(--color-text-primary);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;border:none;background:transparent}@media (max-width: 650px){.ce-popover-item{padding:4px}}.ce-popover-item:not(:last-of-type){margin-bottom:1px}.ce-popover-item__icon{width:26px;height:26px;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center}.ce-popover-item__icon svg{width:20px;height:20px}@media (max-width: 650px){.ce-popover-item__icon{width:36px;height:36px;border-radius:8px}.ce-popover-item__icon svg{width:28px;height:28px}}.ce-popover-item__icon--tool{margin-right:4px}.ce-popover-item__title{font-size:14px;line-height:20px;font-weight:500;overflow:hidden;white-space:nowrap;text-overflow:ellipsis;margin-right:auto}@media (max-width: 650px){.ce-popover-item__title{font-size:16px}}.ce-popover-item__secondary-title{color:var(--color-text-secondary);font-size:12px;white-space:nowrap;letter-spacing:-.1em;padding-right:5px;opacity:.6}@media (max-width: 650px){.ce-popover-item__secondary-title{display:none}}.ce-popover-item--active{background:var(--color-background-icon-active);color:var(--color-text-icon-active)}.ce-popover-item--disabled{color:var(--color-text-secondary);cursor:default;pointer-events:none}.ce-popover-item--focused:not(.ce-popover-item--no-focus){background:var(--color-background-item-focus)!important}.ce-popover-item--hidden{display:none}@media (hover: hover){.ce-popover-item:hover{cursor:pointer}.ce-popover-item:hover:not(.ce-popover-item--no-hover){background-color:var(--color-background-item-hover)}}.ce-popover-item--confirmation{background:var(--color-background-item-confirm)}.ce-popover-item--confirmation .ce-popover-item__title,.ce-popover-item--confirmation .ce-popover-item__icon{color:#fff}@media (hover: hover){.ce-popover-item--confirmation:not(.ce-popover-item--no-hover):hover{background:var(--color-background-item-confirm-hover)}}.ce-popover-item--confirmation:not(.ce-popover-item--no-focus).ce-popover-item--focused{background:var(--color-background-item-confirm-hover)!important}@-webkit-keyframes panelShowing{0%{opacity:0;-webkit-transform:translateY(-8px) scale(.9);transform:translateY(-8px) scale(.9)}70%{opacity:1;-webkit-transform:translateY(2px);transform:translateY(2px)}to{-webkit-transform:translateY(0);transform:translateY(0)}}@keyframes panelShowing{0%{opacity:0;-webkit-transform:translateY(-8px) scale(.9);transform:translateY(-8px) scale(.9)}70%{opacity:1;-webkit-transform:translateY(2px);transform:translateY(2px)}to{-webkit-transform:translateY(0);transform:translateY(0)}}@-webkit-keyframes panelShowingMobile{0%{opacity:0;-webkit-transform:translateY(14px) scale(.98);transform:translateY(14px) scale(.98)}70%{opacity:1;-webkit-transform:translateY(-4px);transform:translateY(-4px)}to{-webkit-transform:translateY(0);transform:translateY(0)}}@keyframes panelShowingMobile{0%{opacity:0;-webkit-transform:translateY(14px) scale(.98);transform:translateY(14px) scale(.98)}70%{opacity:1;-webkit-transform:translateY(-4px);transform:translateY(-4px)}to{-webkit-transform:translateY(0);transform:translateY(0)}}.wobble{-webkit-animation-name:wobble;animation-name:wobble;-webkit-animation-duration:.4s;animation-duration:.4s}@-webkit-keyframes wobble{0%{-webkit-transform:translate3d(0,0,0);transform:translateZ(0)}15%{-webkit-transform:translate3d(-9%,0,0);transform:translate3d(-9%,0,0)}30%{-webkit-transform:translate3d(9%,0,0);transform:translate3d(9%,0,0)}45%{-webkit-transform:translate3d(-4%,0,0);transform:translate3d(-4%,0,0)}60%{-webkit-transform:translate3d(4%,0,0);transform:translate3d(4%,0,0)}75%{-webkit-transform:translate3d(-1%,0,0);transform:translate3d(-1%,0,0)}to{-webkit-transform:translate3d(0,0,0);transform:translateZ(0)}}@keyframes wobble{0%{-webkit-transform:translate3d(0,0,0);transform:translateZ(0)}15%{-webkit-transform:translate3d(-9%,0,0);transform:translate3d(-9%,0,0)}30%{-webkit-transform:translate3d(9%,0,0);transform:translate3d(9%,0,0)}45%{-webkit-transform:translate3d(-4%,0,0);transform:translate3d(-4%,0,0)}60%{-webkit-transform:translate3d(4%,0,0);transform:translate3d(4%,0,0)}75%{-webkit-transform:translate3d(-1%,0,0);transform:translate3d(-1%,0,0)}to{-webkit-transform:translate3d(0,0,0);transform:translateZ(0)}}.ce-popover-header{margin-bottom:8px;margin-top:4px;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.ce-popover-header__text{font-size:18px;font-weight:600}.ce-popover-header__back-button{border:0;background:transparent;width:36px;height:36px;color:var(--color-text-primary)}.ce-popover-header__back-button svg{display:block;width:28px;height:28px}.ce-popover--inline{--height: 38px;--height-mobile: 46px;--container-padding: 4px;position:relative}.ce-popover--inline .ce-popover__custom-content{margin-bottom:0}.ce-popover--inline .ce-popover__items{display:-webkit-box;display:-ms-flexbox;display:flex}.ce-popover--inline .ce-popover__container{-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;padding:var(--container-padding);height:var(--height);top:0;min-width:-webkit-max-content;min-width:-moz-max-content;min-width:max-content;width:-webkit-max-content;width:-moz-max-content;width:max-content;-webkit-animation:none;animation:none}@media (max-width: 650px){.ce-popover--inline .ce-popover__container{height:var(--height-mobile);position:absolute}}.ce-popover--inline .ce-popover-item-separator{padding:0 4px}.ce-popover--inline .ce-popover-item-separator__line{height:100%;width:1px}.ce-popover--inline .ce-popover-item{border-radius:4px;padding:4px}.ce-popover--inline .ce-popover-item__icon--tool{-webkit-box-shadow:none;box-shadow:none;background:transparent;margin-right:0}.ce-popover--inline .ce-popover-item__icon{width:auto;width:initial;height:auto;height:initial}.ce-popover--inline .ce-popover-item__icon svg{width:20px;height:20px}@media (max-width: 650px){.ce-popover--inline .ce-popover-item__icon svg{width:28px;height:28px}}.ce-popover--inline .ce-popover-item:not(:last-of-type){margin-bottom:0;margin-bottom:initial}.ce-popover--inline .ce-popover-item-html{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.ce-popover--inline .ce-popover-item__icon--chevron-right{-webkit-transform:rotate(90deg);transform:rotate(90deg)}.ce-popover--inline .ce-popover--nested-level-1 .ce-popover__container{--offset: 3px;left:0;top:calc(var(--height) + var(--offset))}@media (max-width: 650px){.ce-popover--inline .ce-popover--nested-level-1 .ce-popover__container{top:calc(var(--height-mobile) + var(--offset))}}.ce-popover--inline .ce-popover--nested .ce-popover__container{min-width:var(--width);width:var(--width);height:-webkit-fit-content;height:-moz-fit-content;height:fit-content;padding:6px;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column}.ce-popover--inline .ce-popover--nested .ce-popover__items{display:block;width:100%}.ce-popover--inline .ce-popover--nested .ce-popover-item{border-radius:6px;padding:3px}@media (max-width: 650px){.ce-popover--inline .ce-popover--nested .ce-popover-item{padding:4px}}.ce-popover--inline .ce-popover--nested .ce-popover-item__icon--tool{margin-right:4px}.ce-popover--inline .ce-popover--nested .ce-popover-item__icon{width:26px;height:26px}.ce-popover--inline .ce-popover--nested .ce-popover-item-separator{padding:4px 3px}.ce-popover--inline .ce-popover--nested .ce-popover-item-separator__line{width:100%;height:1px}.codex-editor [data-placeholder]:empty:before,.codex-editor [data-placeholder][data-empty=true]:before{pointer-events:none;color:#707684;cursor:text;content:attr(data-placeholder)}.codex-editor [data-placeholder-active]:empty:before,.codex-editor [data-placeholder-active][data-empty=true]:before{pointer-events:none;color:#707684;cursor:text}.codex-editor [data-placeholder-active]:empty:focus:before,.codex-editor [data-placeholder-active][data-empty=true]:focus:before{content:attr(data-placeholder-active)}\n`, ws = 180;\nclass xs extends y {\n  constructor() {\n    super(...arguments), this.isMobile = !1, this.contentRectCache = void 0, this.resizeDebouncer = kt(() => {\n      this.windowResize();\n    }, 200);\n  }\n  /**\n   * Editor.js UI CSS class names\n   *\n   * @returns {{editorWrapper: string, editorZone: string}}\n   */\n  get CSS() {\n    return {\n      editorWrapper: \"codex-editor\",\n      editorWrapperNarrow: \"codex-editor--narrow\",\n      editorZone: \"codex-editor__redactor\",\n      editorZoneHidden: \"codex-editor__redactor--hidden\",\n      editorEmpty: \"codex-editor--empty\",\n      editorRtlFix: \"codex-editor--rtl\"\n    };\n  }\n  /**\n   * Return Width of center column of Editor\n   *\n   * @returns {DOMRect}\n   */\n  get contentRect() {\n    if (this.contentRectCache)\n      return this.contentRectCache;\n    const e = this.nodes.wrapper.querySelector(`.${D.CSS.content}`);\n    return e ? (this.contentRectCache = e.getBoundingClientRect(), this.contentRectCache) : {\n      width: 650,\n      left: 0,\n      right: 0\n    };\n  }\n  /**\n   * Making main interface\n   */\n  async prepare() {\n    this.setIsMobile(), this.make(), this.loadStyles();\n  }\n  /**\n   * Toggle read-only state\n   *\n   * If readOnly is true:\n   *  - removes all listeners from main UI module elements\n   *\n   * if readOnly is false:\n   *  - enables all listeners to UI module elements\n   *\n   * @param {boolean} readOnlyEnabled - \"read only\" state\n   */\n  toggleReadOnly(e) {\n    e ? this.disableModuleBindings() : window.requestIdleCallback(() => {\n      this.enableModuleBindings();\n    }, {\n      timeout: 2e3\n    });\n  }\n  /**\n   * Check if Editor is empty and set CSS class to wrapper\n   */\n  checkEmptiness() {\n    const { BlockManager: e } = this.Editor;\n    this.nodes.wrapper.classList.toggle(this.CSS.editorEmpty, e.isEditorEmpty);\n  }\n  /**\n   * Check if one of Toolbar is opened\n   * Used to prevent global keydowns (for example, Enter) conflicts with Enter-on-toolbar\n   *\n   * @returns {boolean}\n   */\n  get someToolbarOpened() {\n    const { Toolbar: e, BlockSettings: t, InlineToolbar: o } = this.Editor;\n    return !!(t.opened || o.opened || e.toolbox.opened);\n  }\n  /**\n   * Check for some Flipper-buttons is under focus\n   */\n  get someFlipperButtonFocused() {\n    return this.Editor.Toolbar.toolbox.hasFocus() ? !0 : Object.entries(this.Editor).filter(([e, t]) => t.flipper instanceof re).some(([e, t]) => t.flipper.hasFocus());\n  }\n  /**\n   * Clean editor`s UI\n   */\n  destroy() {\n    this.nodes.holder.innerHTML = \"\";\n  }\n  /**\n   * Close all Editor's toolbars\n   */\n  closeAllToolbars() {\n    const { Toolbar: e, BlockSettings: t, InlineToolbar: o } = this.Editor;\n    t.close(), o.close(), e.toolbox.close();\n  }\n  /**\n   * Check for mobile mode and save the result\n   */\n  setIsMobile() {\n    const e = window.innerWidth < At;\n    e !== this.isMobile && this.eventsDispatcher.emit(xe, {\n      isEnabled: this.isMobile\n    }), this.isMobile = e;\n  }\n  /**\n   * Makes Editor.js interface\n   */\n  make() {\n    this.nodes.holder = d.getHolder(this.config.holder), this.nodes.wrapper = d.make(\"div\", [\n      this.CSS.editorWrapper,\n      ...this.isRtl ? [this.CSS.editorRtlFix] : []\n    ]), this.nodes.redactor = d.make(\"div\", this.CSS.editorZone), this.nodes.holder.offsetWidth < this.contentRect.width && this.nodes.wrapper.classList.add(this.CSS.editorWrapperNarrow), this.nodes.redactor.style.paddingBottom = this.config.minHeight + \"px\", this.nodes.wrapper.appendChild(this.nodes.redactor), this.nodes.holder.appendChild(this.nodes.wrapper);\n  }\n  /**\n   * Appends CSS\n   */\n  loadStyles() {\n    const e = \"editor-js-styles\";\n    if (d.get(e))\n      return;\n    const t = d.make(\"style\", null, {\n      id: e,\n      textContent: vs.toString()\n    });\n    this.config.style && !X(this.config.style) && this.config.style.nonce && t.setAttribute(\"nonce\", this.config.style.nonce), d.prepend(document.head, t);\n  }\n  /**\n   * Bind events on the Editor.js interface\n   */\n  enableModuleBindings() {\n    this.readOnlyMutableListeners.on(this.nodes.redactor, \"click\", (t) => {\n      this.redactorClicked(t);\n    }, !1), this.readOnlyMutableListeners.on(this.nodes.redactor, \"mousedown\", (t) => {\n      this.documentTouched(t);\n    }, {\n      capture: !0,\n      passive: !0\n    }), this.readOnlyMutableListeners.on(this.nodes.redactor, \"touchstart\", (t) => {\n      this.documentTouched(t);\n    }, {\n      capture: !0,\n      passive: !0\n    }), this.readOnlyMutableListeners.on(document, \"keydown\", (t) => {\n      this.documentKeydown(t);\n    }, !0), this.readOnlyMutableListeners.on(document, \"mousedown\", (t) => {\n      this.documentClicked(t);\n    }, !0);\n    const e = kt(() => {\n      this.selectionChanged();\n    }, ws);\n    this.readOnlyMutableListeners.on(document, \"selectionchange\", e, !0), this.readOnlyMutableListeners.on(window, \"resize\", () => {\n      this.resizeDebouncer();\n    }, {\n      passive: !0\n    }), this.watchBlockHoveredEvents(), this.enableInputsEmptyMark();\n  }\n  /**\n   * Listen redactor mousemove to emit 'block-hovered' event\n   */\n  watchBlockHoveredEvents() {\n    let e;\n    this.readOnlyMutableListeners.on(this.nodes.redactor, \"mousemove\", Ve((t) => {\n      const o = t.target.closest(\".ce-block\");\n      this.Editor.BlockSelection.anyBlockSelected || o && e !== o && (e = o, this.eventsDispatcher.emit(oo, {\n        block: this.Editor.BlockManager.getBlockByChildNode(o)\n      }));\n    }, 20), {\n      passive: !0\n    });\n  }\n  /**\n   * Unbind events on the Editor.js interface\n   */\n  disableModuleBindings() {\n    this.readOnlyMutableListeners.clearAll();\n  }\n  /**\n   * Resize window handler\n   */\n  windowResize() {\n    this.contentRectCache = null, this.setIsMobile();\n  }\n  /**\n   * All keydowns on document\n   *\n   * @param {KeyboardEvent} event - keyboard event\n   */\n  documentKeydown(e) {\n    switch (e.keyCode) {\n      case w.ENTER:\n        this.enterPressed(e);\n        break;\n      case w.BACKSPACE:\n      case w.DELETE:\n        this.backspacePressed(e);\n        break;\n      case w.ESC:\n        this.escapePressed(e);\n        break;\n      default:\n        this.defaultBehaviour(e);\n        break;\n    }\n  }\n  /**\n   * Ignore all other document's keydown events\n   *\n   * @param {KeyboardEvent} event - keyboard event\n   */\n  defaultBehaviour(e) {\n    const { currentBlock: t } = this.Editor.BlockManager, o = e.target.closest(`.${this.CSS.editorWrapper}`), i = e.altKey || e.ctrlKey || e.metaKey || e.shiftKey;\n    if (t !== void 0 && o === null) {\n      this.Editor.BlockEvents.keydown(e);\n      return;\n    }\n    o || t && i || (this.Editor.BlockManager.unsetCurrentBlock(), this.Editor.Toolbar.close());\n  }\n  /**\n   * @param {KeyboardEvent} event - keyboard event\n   */\n  backspacePressed(e) {\n    const { BlockManager: t, BlockSelection: o, Caret: i } = this.Editor;\n    if (o.anyBlockSelected && !b.isSelectionExists) {\n      const s = t.removeSelectedBlocks(), r = t.insertDefaultBlockAtIndex(s, !0);\n      i.setToBlock(r, i.positions.START), o.clearSelection(e), e.preventDefault(), e.stopPropagation(), e.stopImmediatePropagation();\n    }\n  }\n  /**\n   * Escape pressed\n   * If some of Toolbar components are opened, then close it otherwise close Toolbar\n   *\n   * @param {Event} event - escape keydown event\n   */\n  escapePressed(e) {\n    this.Editor.BlockSelection.clearSelection(e), this.Editor.Toolbar.toolbox.opened ? (this.Editor.Toolbar.toolbox.close(), this.Editor.Caret.setToBlock(this.Editor.BlockManager.currentBlock, this.Editor.Caret.positions.END)) : this.Editor.BlockSettings.opened ? this.Editor.BlockSettings.close() : this.Editor.InlineToolbar.opened ? this.Editor.InlineToolbar.close() : this.Editor.Toolbar.close();\n  }\n  /**\n   * Enter pressed on document\n   *\n   * @param {KeyboardEvent} event - keyboard event\n   */\n  enterPressed(e) {\n    const { BlockManager: t, BlockSelection: o } = this.Editor;\n    if (this.someToolbarOpened)\n      return;\n    const i = t.currentBlockIndex >= 0;\n    if (o.anyBlockSelected && !b.isSelectionExists) {\n      o.clearSelection(e), e.preventDefault(), e.stopImmediatePropagation(), e.stopPropagation();\n      return;\n    }\n    if (!this.someToolbarOpened && i && e.target.tagName === \"BODY\") {\n      const s = this.Editor.BlockManager.insert();\n      e.preventDefault(), this.Editor.Caret.setToBlock(s), this.Editor.Toolbar.moveAndOpen(s);\n    }\n    this.Editor.BlockSelection.clearSelection(e);\n  }\n  /**\n   * All clicks on document\n   *\n   * @param {MouseEvent} event - Click event\n   */\n  documentClicked(e) {\n    var l, a;\n    if (!e.isTrusted)\n      return;\n    const t = e.target;\n    this.nodes.holder.contains(t) || b.isAtEditor || (this.Editor.BlockManager.unsetCurrentBlock(), this.Editor.Toolbar.close());\n    const i = (l = this.Editor.BlockSettings.nodes.wrapper) == null ? void 0 : l.contains(t), s = (a = this.Editor.Toolbar.nodes.settingsToggler) == null ? void 0 : a.contains(t), r = i || s;\n    if (this.Editor.BlockSettings.opened && !r) {\n      this.Editor.BlockSettings.close();\n      const c = this.Editor.BlockManager.getBlockByChildNode(t);\n      this.Editor.Toolbar.moveAndOpen(c);\n    }\n    this.Editor.BlockSelection.clearSelection(e);\n  }\n  /**\n   * First touch on editor\n   * Fired before click\n   *\n   * Used to change current block  we need to do it before 'selectionChange' event.\n   * Also:\n   * - Move and show the Toolbar\n   * - Set a Caret\n   *\n   * @param {MouseEvent | TouchEvent} event - touch or mouse event\n   */\n  documentTouched(e) {\n    let t = e.target;\n    if (t === this.nodes.redactor) {\n      const o = e instanceof MouseEvent ? e.clientX : e.touches[0].clientX, i = e instanceof MouseEvent ? e.clientY : e.touches[0].clientY;\n      t = document.elementFromPoint(o, i);\n    }\n    try {\n      this.Editor.BlockManager.setCurrentBlockByChildNode(t);\n    } catch {\n      this.Editor.RectangleSelection.isRectActivated() || this.Editor.Caret.setToTheLastBlock();\n    }\n    this.Editor.Toolbar.moveAndOpen();\n  }\n  /**\n   * All clicks on the redactor zone\n   *\n   * @param {MouseEvent} event - click event\n   * @description\n   * - By clicks on the Editor's bottom zone:\n   *      - if last Block is empty, set a Caret to this\n   *      - otherwise, add a new empty Block and set a Caret to that\n   */\n  redactorClicked(e) {\n    if (!b.isCollapsed)\n      return;\n    const t = e.target, o = e.metaKey || e.ctrlKey;\n    if (d.isAnchor(t) && o) {\n      e.stopImmediatePropagation(), e.stopPropagation();\n      const i = t.getAttribute(\"href\"), s = So(i);\n      Mo(s);\n      return;\n    }\n    this.processBottomZoneClick(e);\n  }\n  /**\n   * Check if user clicks on the Editor's bottom zone:\n   *  - set caret to the last block\n   *  - or add new empty block\n   *\n   * @param event - click event\n   */\n  processBottomZoneClick(e) {\n    const t = this.Editor.BlockManager.getBlockByIndex(-1), o = d.offset(t.holder).bottom, i = e.pageY, { BlockSelection: s } = this.Editor;\n    if (e.target instanceof Element && e.target.isEqualNode(this.nodes.redactor) && /**\n    * If there is cross block selection started, target will be equal to redactor so we need additional check\n    */\n    !s.anyBlockSelected && /**\n    * Prevent caret jumping (to last block) when clicking between blocks\n    */\n    o < i) {\n      e.stopImmediatePropagation(), e.stopPropagation();\n      const { BlockManager: l, Caret: a, Toolbar: c } = this.Editor;\n      (!l.lastBlock.tool.isDefault || !l.lastBlock.isEmpty) && l.insertAtEnd(), a.setToTheLastBlock(), c.moveAndOpen(l.lastBlock);\n    }\n  }\n  /**\n   * Handle selection changes on mobile devices\n   * Uses for showing the Inline Toolbar\n   */\n  selectionChanged() {\n    const { CrossBlockSelection: e, BlockSelection: t } = this.Editor, o = b.anchorElement;\n    if (e.isCrossBlockSelectionStarted && t.anyBlockSelected && b.get().removeAllRanges(), !o) {\n      b.range || this.Editor.InlineToolbar.close();\n      return;\n    }\n    o.closest(`.${D.CSS.content}`) === null && (this.Editor.InlineToolbar.containsNode(o) || this.Editor.InlineToolbar.close(), !(o.dataset.inlineToolbar === \"true\")) || (this.Editor.BlockManager.currentBlock || this.Editor.BlockManager.setCurrentBlockByChildNode(o), this.Editor.InlineToolbar.tryToShow(!0));\n  }\n  /**\n   * Editor.js provides and ability to show placeholders for empty contenteditable elements\n   *\n   * This method watches for input and focus events and toggles 'data-empty' attribute\n   * to workaroud the case, when inputs contains only <br>s and has no visible content\n   * Then, CSS could rely on this attribute to show placeholders\n   */\n  enableInputsEmptyMark() {\n    function e(t) {\n      const o = t.target;\n      Ot(o);\n    }\n    this.readOnlyMutableListeners.on(this.nodes.wrapper, \"input\", e), this.readOnlyMutableListeners.on(this.nodes.wrapper, \"focusin\", e), this.readOnlyMutableListeners.on(this.nodes.wrapper, \"focusout\", e);\n  }\n}\nconst ys = {\n  // API Modules\n  BlocksAPI: fi,\n  CaretAPI: mi,\n  EventsAPI: bi,\n  I18nAPI: st,\n  API: ki,\n  InlineToolbarAPI: vi,\n  ListenersAPI: wi,\n  NotifierAPI: Bi,\n  ReadOnlyAPI: Ti,\n  SanitizerAPI: Li,\n  SaverAPI: _i,\n  SelectionAPI: Ni,\n  ToolsAPI: Pi,\n  StylesAPI: Di,\n  ToolbarAPI: Ri,\n  TooltipAPI: Fi,\n  UiAPI: Hi,\n  // Toolbar Modules\n  BlockSettings: Ui,\n  Toolbar: qi,\n  InlineToolbar: Zi,\n  // Modules\n  BlockEvents: Gi,\n  BlockManager: es,\n  BlockSelection: ts,\n  Caret: De,\n  CrossBlockSelection: os,\n  DragNDrop: is,\n  ModificationsObserver: ss,\n  Paste: ns,\n  ReadOnly: rs,\n  RectangleSelection: we,\n  Renderer: ls,\n  Saver: as,\n  Tools: go,\n  UI: xs\n};\nclass Es {\n  /**\n   * @param {EditorConfig} config - user configuration\n   */\n  constructor(e) {\n    this.moduleInstances = {}, this.eventsDispatcher = new Be();\n    let t, o;\n    this.isReady = new Promise((i, s) => {\n      t = i, o = s;\n    }), Promise.resolve().then(async () => {\n      this.configuration = e, this.validate(), this.init(), await this.start(), await this.render();\n      const { BlockManager: i, Caret: s, UI: r, ModificationsObserver: l } = this.moduleInstances;\n      r.checkEmptiness(), l.enable(), this.configuration.autofocus && s.setToBlock(i.blocks[0], s.positions.START), t();\n    }).catch((i) => {\n      I(`Editor.js is not ready because of ${i}`, \"error\"), o(i);\n    });\n  }\n  /**\n   * Setting for configuration\n   *\n   * @param {EditorConfig|string} config - Editor's config to set\n   */\n  set configuration(e) {\n    var o, i;\n    R(e) ? this.config = {\n      ...e\n    } : this.config = {\n      holder: e\n    }, Ze(!!this.config.holderId, \"config.holderId\", \"config.holder\"), this.config.holderId && !this.config.holder && (this.config.holder = this.config.holderId, this.config.holderId = null), this.config.holder == null && (this.config.holder = \"editorjs\"), this.config.logLevel || (this.config.logLevel = St.VERBOSE), xo(this.config.logLevel), Ze(!!this.config.initialBlock, \"config.initialBlock\", \"config.defaultBlock\"), this.config.defaultBlock = this.config.defaultBlock || this.config.initialBlock || \"paragraph\", this.config.minHeight = this.config.minHeight !== void 0 ? this.config.minHeight : 300;\n    const t = {\n      type: this.config.defaultBlock,\n      data: {}\n    };\n    this.config.placeholder = this.config.placeholder || !1, this.config.sanitizer = this.config.sanitizer || {\n      p: !0,\n      b: !0,\n      a: !0\n    }, this.config.hideToolbar = this.config.hideToolbar ? this.config.hideToolbar : !1, this.config.tools = this.config.tools || {}, this.config.i18n = this.config.i18n || {}, this.config.data = this.config.data || { blocks: [] }, this.config.onReady = this.config.onReady || (() => {\n    }), this.config.onChange = this.config.onChange || (() => {\n    }), this.config.inlineToolbar = this.config.inlineToolbar !== void 0 ? this.config.inlineToolbar : !0, (X(this.config.data) || !this.config.data.blocks || this.config.data.blocks.length === 0) && (this.config.data = { blocks: [t] }), this.config.readOnly = this.config.readOnly || !1, (o = this.config.i18n) != null && o.messages && W.setDictionary(this.config.i18n.messages), this.config.i18n.direction = ((i = this.config.i18n) == null ? void 0 : i.direction) || \"ltr\";\n  }\n  /**\n   * Returns private property\n   *\n   * @returns {EditorConfig}\n   */\n  get configuration() {\n    return this.config;\n  }\n  /**\n   * Checks for required fields in Editor's config\n   */\n  validate() {\n    const { holderId: e, holder: t } = this.config;\n    if (e && t)\n      throw Error(\"holderId and holder param can't assign at the same time.\");\n    if (Q(t) && !d.get(t))\n      throw Error(`element with ID ${t} is missing. Pass correct holder's ID.`);\n    if (t && R(t) && !d.isElement(t))\n      throw Error(\"holder value must be an Element node\");\n  }\n  /**\n   * Initializes modules:\n   *  - make and save instances\n   *  - configure\n   */\n  init() {\n    this.constructModules(), this.configureModules();\n  }\n  /**\n   * Start Editor!\n   *\n   * Get list of modules that needs to be prepared and return a sequence (Promise)\n   *\n   * @returns {Promise<void>}\n   */\n  async start() {\n    await [\n      \"Tools\",\n      \"UI\",\n      \"BlockManager\",\n      \"Paste\",\n      \"BlockSelection\",\n      \"RectangleSelection\",\n      \"CrossBlockSelection\",\n      \"ReadOnly\"\n    ].reduce(\n      (t, o) => t.then(async () => {\n        try {\n          await this.moduleInstances[o].prepare();\n        } catch (i) {\n          if (i instanceof Nt)\n            throw new Error(i.message);\n          I(`Module ${o} was skipped because of %o`, \"warn\", i);\n        }\n      }),\n      Promise.resolve()\n    );\n  }\n  /**\n   * Render initial data\n   */\n  render() {\n    return this.moduleInstances.Renderer.render(this.config.data.blocks);\n  }\n  /**\n   * Make modules instances and save it to the @property this.moduleInstances\n   */\n  constructModules() {\n    Object.entries(ys).forEach(([e, t]) => {\n      try {\n        this.moduleInstances[e] = new t({\n          config: this.configuration,\n          eventsDispatcher: this.eventsDispatcher\n        });\n      } catch (o) {\n        I(\"[constructModules]\", `Module ${e} skipped because`, \"error\", o);\n      }\n    });\n  }\n  /**\n   * Modules instances configuration:\n   *  - pass other modules to the 'state' property\n   *  - ...\n   */\n  configureModules() {\n    for (const e in this.moduleInstances)\n      Object.prototype.hasOwnProperty.call(this.moduleInstances, e) && (this.moduleInstances[e].state = this.getModulesDiff(e));\n  }\n  /**\n   * Return modules without passed name\n   *\n   * @param {string} name - module for witch modules difference should be calculated\n   */\n  getModulesDiff(e) {\n    const t = {};\n    for (const o in this.moduleInstances)\n      o !== e && (t[o] = this.moduleInstances[o]);\n    return t;\n  }\n}\n/**\n * Editor.js\n *\n * @license Apache-2.0\n * @see Editor.js <https://editorjs.io>\n * @author CodeX Team <https://codex.so>\n */\nclass Bs {\n  /** Editor version */\n  static get version() {\n    return \"2.30.0\";\n  }\n  /**\n   * @param {EditorConfig|string|undefined} [configuration] - user configuration\n   */\n  constructor(e) {\n    let t = () => {\n    };\n    R(e) && O(e.onReady) && (t = e.onReady);\n    const o = new Es(e);\n    this.isReady = o.isReady.then(() => {\n      this.exportAPI(o), t();\n    });\n  }\n  /**\n   * Export external API methods\n   *\n   * @param {Core} editor  Editor's instance\n   */\n  exportAPI(e) {\n    const t = [\"configuration\"], o = () => {\n      Object.values(e.moduleInstances).forEach((s) => {\n        O(s.destroy) && s.destroy(), s.listeners.removeAll();\n      }), oi(), e = null;\n      for (const s in this)\n        Object.prototype.hasOwnProperty.call(this, s) && delete this[s];\n      Object.setPrototypeOf(this, null);\n    };\n    t.forEach((s) => {\n      this[s] = e[s];\n    }), this.destroy = o, Object.setPrototypeOf(this, e.moduleInstances.API.methods), delete this.exportAPI, Object.entries({\n      blocks: {\n        clear: \"clear\",\n        render: \"render\"\n      },\n      caret: {\n        focus: \"focus\"\n      },\n      events: {\n        on: \"on\",\n        off: \"off\",\n        emit: \"emit\"\n      },\n      saver: {\n        save: \"save\"\n      }\n    }).forEach(([s, r]) => {\n      Object.entries(r).forEach(([l, a]) => {\n        this[a] = e.moduleInstances.API.methods[s][l];\n      });\n    });\n  }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZWRpdG9yanMvZWRpdG9yanMvZGlzdC9lZGl0b3Jqcy5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLFlBQVksYUFBYSxJQUFJLHdCQUF3QixzQ0FBc0MsNkRBQTZELGdCQUFnQix1QkFBdUIsa0JBQWtCLHNCQUFzQixXQUFXLGVBQWUsa0NBQWtDLFNBQVMsbURBQW1EO0FBQy9WO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLFNBQVMsZ0NBQWdDO0FBQ3pDO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEhBQTBIO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLHVDQUF1QyxFQUFFLEtBQUssRUFBRSxjQUFjLEdBQUcsR0FBRyxFQUFFO0FBQ3RF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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLGFBQWE7QUFDOUY7QUFDQTtBQUNBLG9CQUFvQixnQ0FBZ0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsVUFB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsdUhBQXVIO0FBQ3BJO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUscURBQXFEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksaU1BQWlNO0FBQ3JNO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCx3QkFBd0I7QUFDM0UsT0FBTztB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbU9BQW1PLFVBQVU7QUFDN087QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtHQUErRywyR0FBMkc7QUFDMU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsYUFBYTtBQUNyRTtBQUNBO0FBQ0E7QUFDQSw2UEFBNlA7QUFDN1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsb0JBQW9CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUssa0JBQWtCO0FBQ3ZCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDBCQUEwQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsUUFBUTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG9CQUFvQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx5QkFBeUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLEVBQUUsYUFBYSxFQUFFO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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ZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQ0FBZ0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUIsYUFBYSxnQkFBZ0I7QUFDN0IsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUIsYUFBYSxnQkFBZ0I7QUFDN0IsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsRUFBRSxHQUFHLEVBQUU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0JBQStCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSSxjQUFjO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsY0FBYztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwrQkFBK0IsRUFBRTtBQUNqQyxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSyw2Q0FBNkMsVUFBVTtBQUM1RCxjQUFjLDRCQUE0QjtBQUMxQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEhBQTRILHlMQUF5TCxxR0FBcUcsdU9BQXVPLHlGQUF5RixrRUFBa0U7QUFDNXhCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdDQUFnQztBQUNoRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUksY0FBYztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0EsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQSxZQUFZLCtDQUErQztBQUMzRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBLFlBQVksNkJBQTZCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0EsWUFBWSx5QkFBeUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0EsWUFBWSw0QkFBNEIsaUJBQWlCLG9DQUFvQztBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0EsWUFBWSw0QkFBNEIsaUJBQWlCLGdDQUFnQztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksd0NBQXdDO0FBQ3BEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxhQUFhO0FBQzFCLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxhQUFhO0FBQzFCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsT0FBTztBQUNwQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLGdCQUFnQjtBQUM3QixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRLDhDQUE4QztBQUNuRSxhQUFhLFFBQVE7QUFDckIsYUFBYSxlQUFlO0FBQzVCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSyxJQUFJLGNBQWM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixZQUFZO0FBQ3hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsWUFBWTtBQUN6QixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOLFdBQVcsRUFBRTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0Esa0NBQWtDLGdDQUFnQztBQUNsRTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixTQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsY0FBYztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixlQUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsY0FBYztBQUMxQztBQUNBO0FBQ0EsNEJBQTRCLGlDQUFpQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsY0FBYztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELEVBQUU7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFlBQVk7QUFDWixZQUFZO0FBQ1osWUFBWTtBQUNaLFlBQVk7QUFDWixZQUFZO0FBQ1osWUFBWTtBQUNaLFlBQVk7QUFDWixZQUFZO0FBQ1osWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxXQUFXO0FBQ1gsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0EsWUFBWSxtREFBbUQ7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQ0FBcUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLFlBQVksb0JBQW9CLHVCQUF1QixpQkFBaUI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDBCQUEwQjtBQUN0QztBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0EsWUFBWSxrQkFBa0IsaUJBQWlCLGdDQUFnQztBQUMvRTtBQUNBO0FBQ0EsWUFBWSxnQ0FBZ0M7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMEJBQTBCO0FBQ3RDO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSxZQUFZLG9DQUFvQztBQUNoRDtBQUNBO0FBQ0EsWUFBWSxvQ0FBb0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQSxrQ0FBa0MsbUJBQW1CO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGNBQWMscUNBQXFDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLFlBQVkscUNBQXFDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQSxZQUFZLCtDQUErQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0EsWUFBWSxxQ0FBcUM7QUFDakQsaUNBQWlDLHFCQUFxQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdDQUFnQztBQUNoRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLG1CQUFtQixTQUFTLE9BQU87QUFDN0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0Ysc0JBQXNCLCtDQUErQztBQUM3SjtBQUNBLDZCQUE2QixJQUFJO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsaUNBQWlDLE9BQU87QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsY0FBYyw4QkFBOEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSwySEFBMkgsUUFBUSx1QkFBdUIsNENBQTRDLFFBQVE7QUFDOU07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLFlBQVksNEJBQTRCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTyxhQUFhLEVBQUUsa0RBQWtELDRCQUE0QjtBQUN0STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCLFVBQVUsOEJBQThCO0FBQ3hDLGlHQUFpRyxPQUFPLHFIQUFxSCxPQUFPLG9HQUFvRyxFQUFFLGFBQWEsT0FBTztBQUM5VjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixHQUFHLE9BQU8sT0FBTztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBLHFFQUFxRSw2QkFBNkI7QUFDbEc7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFVBQVUscUJBQXFCLFVBQVU7QUFDdkQ7QUFDQTtBQUNBLE9BQU8sU0FBUyx1QkFBdUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQSxZQUFZLDRCQUE0QixpQkFBaUIsa0JBQWtCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0EsWUFBWSw0QkFBNEIsaUJBQWlCLGFBQWE7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxTQUFTLGdDQUFnQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCLGFBQWEsU0FBUztBQUN0QixlQUFlO0FBQ2Y7QUFDQTtBQUNBLFlBQVksNEJBQTRCLGlCQUFpQixrQkFBa0I7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQSxZQUFZLHNDQUFzQztBQUNsRDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixhQUFhLFFBQVE7QUFDckIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQSxvREFBb0QsVUFBVSxpQ0FBaUM7QUFDL0YsU0FBUyxZQUFZO0FBQ3JCO0FBQ0EsU0FBUyxZQUFZO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXLGlCQUFpQixnQkFBZ0I7QUFDeEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsMENBQTBDO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQ0FBZ0M7QUFDbEQ7QUFDQSxVQUFVLGNBQWM7QUFDeEIsVUFBVSxnQ0FBZ0M7QUFDMUMsVUFBVSw0Q0FBNEM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxZQUFZLFFBQVEsZ0hBQWdILGdEQUFnRCxvQ0FBb0M7QUFDeE47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQ0FBb0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGlDQUFpQywwQ0FBMEMsaUNBQWlDLHlEQUF5RCxpQ0FBaUMsd0RBQXdELGlDQUFpQztBQUN6VTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLGlDQUFpQyx5REFBeUQsaUNBQWlDLDREQUE0RCxpQ0FBaUMsMENBQTBDLGlDQUFpQywwRUFBMEUsaUNBQWlDLHdEQUF3RCxpQ0FBaUMsMkRBQTJELGlDQUFpQywyQ0FBMkMsaUNBQWlDO0FBQ3R0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsUUFBUTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwSEFBMEgsS0FBSztBQUMvSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw0QkFBNEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1DQUFtQztBQUM5RCxtREFBbUQsRUFBRTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1osd0JBQXdCLEVBQUU7QUFDMUI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxJQUFJLGNBQWM7QUFDekIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxZQUFZLDRCQUE0QjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwrQ0FBK0M7QUFDdkU7QUFDQSxvQkFBb0IsRUFBRTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsa0JBQWtCLGFBQWEsaUtBQWlLLHNDQUFzQyw4QkFBOEIsYUFBYSw2QkFBNkIsZ0JBQWdCO0FBQ3pYO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLGVBQWU7QUFDNUIsYUFBYSxpQkFBaUI7QUFDOUIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBLGdCQUFnQix5Q0FBeUM7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsS0FBSyw2SkFBNko7QUFDbEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QixlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsUUFBUTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQ0FBcUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEI7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEI7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQjtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxRQUFRO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFlBQVksaURBQWlEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaURBQWlEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxzQkFBc0IsR0FBRztBQUN6QjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSLDBDQUEwQyxHQUFHO0FBQzdDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsK0JBQStCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGVkaXRvcmpzL2VkaXRvcmpzL2Rpc3QvZWRpdG9yanMubWpzPzBmZGIiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7dHJ5e2lmKHR5cGVvZiBkb2N1bWVudDxcInVcIil7dmFyIGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO2UuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCIuY2UtaGludC0tYWxpZ24tc3RhcnR7dGV4dC1hbGlnbjpsZWZ0fS5jZS1oaW50LS1hbGlnbi1jZW50ZXJ7dGV4dC1hbGlnbjpjZW50ZXJ9LmNlLWhpbnRfX2Rlc2NyaXB0aW9ue29wYWNpdHk6LjY7bWFyZ2luLXRvcDozcHh9XCIpKSxkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGUpfX1jYXRjaCh0KXtjb25zb2xlLmVycm9yKFwidml0ZS1wbHVnaW4tY3NzLWluamVjdGVkLWJ5LWpzXCIsdCl9fSkoKTtcbnZhciBrbyA9IHR5cGVvZiBnbG9iYWxUaGlzIDwgXCJ1XCIgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyA8IFwidVwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCA8IFwidVwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgPCBcInVcIiA/IHNlbGYgOiB7fTtcbmZ1bmN0aW9uIFJlKG4pIHtcbiAgcmV0dXJuIG4gJiYgbi5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuLCBcImRlZmF1bHRcIikgPyBuLmRlZmF1bHQgOiBuO1xufVxuZnVuY3Rpb24gemUoKSB7XG59XG5PYmplY3QuYXNzaWduKHplLCB7XG4gIGRlZmF1bHQ6IHplLFxuICByZWdpc3RlcjogemUsXG4gIHJldmVydDogZnVuY3Rpb24oKSB7XG4gIH0sXG4gIF9fZXNNb2R1bGU6ICEwXG59KTtcbkVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMgfHwgKEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMgPSBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzU2VsZWN0b3IgfHwgRWxlbWVudC5wcm90b3R5cGUubW96TWF0Y2hlc1NlbGVjdG9yIHx8IEVsZW1lbnQucHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yIHx8IEVsZW1lbnQucHJvdG90eXBlLm9NYXRjaGVzU2VsZWN0b3IgfHwgRWxlbWVudC5wcm90b3R5cGUud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8IGZ1bmN0aW9uKG4pIHtcbiAgY29uc3QgZSA9ICh0aGlzLmRvY3VtZW50IHx8IHRoaXMub3duZXJEb2N1bWVudCkucXVlcnlTZWxlY3RvckFsbChuKTtcbiAgbGV0IHQgPSBlLmxlbmd0aDtcbiAgZm9yICg7IC0tdCA+PSAwICYmIGUuaXRlbSh0KSAhPT0gdGhpczsgKVxuICAgIDtcbiAgcmV0dXJuIHQgPiAtMTtcbn0pO1xuRWxlbWVudC5wcm90b3R5cGUuY2xvc2VzdCB8fCAoRWxlbWVudC5wcm90b3R5cGUuY2xvc2VzdCA9IGZ1bmN0aW9uKG4pIHtcbiAgbGV0IGUgPSB0aGlzO1xuICBpZiAoIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucyhlKSlcbiAgICByZXR1cm4gbnVsbDtcbiAgZG8ge1xuICAgIGlmIChlLm1hdGNoZXMobikpXG4gICAgICByZXR1cm4gZTtcbiAgICBlID0gZS5wYXJlbnRFbGVtZW50IHx8IGUucGFyZW50Tm9kZTtcbiAgfSB3aGlsZSAoZSAhPT0gbnVsbCk7XG4gIHJldHVybiBudWxsO1xufSk7XG5FbGVtZW50LnByb3RvdHlwZS5wcmVwZW5kIHx8IChFbGVtZW50LnByb3RvdHlwZS5wcmVwZW5kID0gZnVuY3Rpb24oZSkge1xuICBjb25zdCB0ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICBBcnJheS5pc0FycmF5KGUpIHx8IChlID0gW2VdKSwgZS5mb3JFYWNoKChvKSA9PiB7XG4gICAgY29uc3QgaSA9IG8gaW5zdGFuY2VvZiBOb2RlO1xuICAgIHQuYXBwZW5kQ2hpbGQoaSA/IG8gOiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShvKSk7XG4gIH0pLCB0aGlzLmluc2VydEJlZm9yZSh0LCB0aGlzLmZpcnN0Q2hpbGQpO1xufSk7XG5FbGVtZW50LnByb3RvdHlwZS5zY3JvbGxJbnRvVmlld0lmTmVlZGVkIHx8IChFbGVtZW50LnByb3RvdHlwZS5zY3JvbGxJbnRvVmlld0lmTmVlZGVkID0gZnVuY3Rpb24obikge1xuICBuID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMCA/ICEwIDogISFuO1xuICBjb25zdCBlID0gdGhpcy5wYXJlbnROb2RlLCB0ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZSwgbnVsbCksIG8gPSBwYXJzZUludCh0LmdldFByb3BlcnR5VmFsdWUoXCJib3JkZXItdG9wLXdpZHRoXCIpKSwgaSA9IHBhcnNlSW50KHQuZ2V0UHJvcGVydHlWYWx1ZShcImJvcmRlci1sZWZ0LXdpZHRoXCIpKSwgcyA9IHRoaXMub2Zmc2V0VG9wIC0gZS5vZmZzZXRUb3AgPCBlLnNjcm9sbFRvcCwgciA9IHRoaXMub2Zmc2V0VG9wIC0gZS5vZmZzZXRUb3AgKyB0aGlzLmNsaWVudEhlaWdodCAtIG8gPiBlLnNjcm9sbFRvcCArIGUuY2xpZW50SGVpZ2h0LCBsID0gdGhpcy5vZmZzZXRMZWZ0IC0gZS5vZmZzZXRMZWZ0IDwgZS5zY3JvbGxMZWZ0LCBhID0gdGhpcy5vZmZzZXRMZWZ0IC0gZS5vZmZzZXRMZWZ0ICsgdGhpcy5jbGllbnRXaWR0aCAtIGkgPiBlLnNjcm9sbExlZnQgKyBlLmNsaWVudFdpZHRoLCBjID0gcyAmJiAhcjtcbiAgKHMgfHwgcikgJiYgbiAmJiAoZS5zY3JvbGxUb3AgPSB0aGlzLm9mZnNldFRvcCAtIGUub2Zmc2V0VG9wIC0gZS5jbGllbnRIZWlnaHQgLyAyIC0gbyArIHRoaXMuY2xpZW50SGVpZ2h0IC8gMiksIChsIHx8IGEpICYmIG4gJiYgKGUuc2Nyb2xsTGVmdCA9IHRoaXMub2Zmc2V0TGVmdCAtIGUub2Zmc2V0TGVmdCAtIGUuY2xpZW50V2lkdGggLyAyIC0gaSArIHRoaXMuY2xpZW50V2lkdGggLyAyKSwgKHMgfHwgciB8fCBsIHx8IGEpICYmICFuICYmIHRoaXMuc2Nyb2xsSW50b1ZpZXcoYyk7XG59KTtcbndpbmRvdy5yZXF1ZXN0SWRsZUNhbGxiYWNrID0gd2luZG93LnJlcXVlc3RJZGxlQ2FsbGJhY2sgfHwgZnVuY3Rpb24obikge1xuICBjb25zdCBlID0gRGF0ZS5ub3coKTtcbiAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgbih7XG4gICAgICBkaWRUaW1lb3V0OiAhMSxcbiAgICAgIHRpbWVSZW1haW5pbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgNTAgLSAoRGF0ZS5ub3coKSAtIGUpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgMSk7XG59O1xud2luZG93LmNhbmNlbElkbGVDYWxsYmFjayA9IHdpbmRvdy5jYW5jZWxJZGxlQ2FsbGJhY2sgfHwgZnVuY3Rpb24obikge1xuICBjbGVhclRpbWVvdXQobik7XG59O1xubGV0IHZvID0gKG4gPSAyMSkgPT4gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShuKSkucmVkdWNlKChlLCB0KSA9PiAodCAmPSA2MywgdCA8IDM2ID8gZSArPSB0LnRvU3RyaW5nKDM2KSA6IHQgPCA2MiA/IGUgKz0gKHQgLSAyNikudG9TdHJpbmcoMzYpLnRvVXBwZXJDYXNlKCkgOiB0ID4gNjIgPyBlICs9IFwiLVwiIDogZSArPSBcIl9cIiwgZSksIFwiXCIpO1xudmFyIFN0ID0gLyogQF9fUFVSRV9fICovICgobikgPT4gKG4uVkVSQk9TRSA9IFwiVkVSQk9TRVwiLCBuLklORk8gPSBcIklORk9cIiwgbi5XQVJOID0gXCJXQVJOXCIsIG4uRVJST1IgPSBcIkVSUk9SXCIsIG4pKShTdCB8fCB7fSk7XG5jb25zdCB3ID0ge1xuICBCQUNLU1BBQ0U6IDgsXG4gIFRBQjogOSxcbiAgRU5URVI6IDEzLFxuICBTSElGVDogMTYsXG4gIENUUkw6IDE3LFxuICBBTFQ6IDE4LFxuICBFU0M6IDI3LFxuICBTUEFDRTogMzIsXG4gIExFRlQ6IDM3LFxuICBVUDogMzgsXG4gIERPV046IDQwLFxuICBSSUdIVDogMzksXG4gIERFTEVURTogNDYsXG4gIE1FVEE6IDkxLFxuICBTTEFTSDogMTkxXG59LCB3byA9IHtcbiAgTEVGVDogMCxcbiAgV0hFRUw6IDEsXG4gIFJJR0hUOiAyLFxuICBCQUNLV0FSRDogMyxcbiAgRk9SV0FSRDogNFxufTtcbmZ1bmN0aW9uIEVlKG4sIGUsIHQgPSBcImxvZ1wiLCBvLCBpID0gXCJjb2xvcjogaW5oZXJpdFwiKSB7XG4gIGlmICghKFwiY29uc29sZVwiIGluIHdpbmRvdykgfHwgIXdpbmRvdy5jb25zb2xlW3RdKVxuICAgIHJldHVybjtcbiAgY29uc3QgcyA9IFtcImluZm9cIiwgXCJsb2dcIiwgXCJ3YXJuXCIsIFwiZXJyb3JcIl0uaW5jbHVkZXModCksIHIgPSBbXTtcbiAgc3dpdGNoIChFZS5sb2dMZXZlbCkge1xuICAgIGNhc2UgXCJFUlJPUlwiOlxuICAgICAgaWYgKHQgIT09IFwiZXJyb3JcIilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIldBUk5cIjpcbiAgICAgIGlmICghW1wiZXJyb3JcIiwgXCJ3YXJuXCJdLmluY2x1ZGVzKHQpKVxuICAgICAgICByZXR1cm47XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiSU5GT1wiOlxuICAgICAgaWYgKCFzIHx8IG4pXG4gICAgICAgIHJldHVybjtcbiAgICAgIGJyZWFrO1xuICB9XG4gIG8gJiYgci5wdXNoKG8pO1xuICBjb25zdCBsID0gXCJFZGl0b3IuanMgMi4zMC4wXCIsIGEgPSBgbGluZS1oZWlnaHQ6IDFlbTtcbiAgICAgICAgICAgIGNvbG9yOiAjMDA2RkVBO1xuICAgICAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgICAgICAgZm9udC1zaXplOiAxMXB4O1xuICAgICAgICAgICAgbGluZS1oZWlnaHQ6IDFlbTtcbiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XG4gICAgICAgICAgICBwYWRkaW5nOiA0cHggOXB4O1xuICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogMzBweDtcbiAgICAgICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIHJnYmEoNTYsIDEzOCwgMjI5LCAwLjE2KTtcbiAgICAgICAgICAgIG1hcmdpbjogNHB4IDVweCA0cHggMDtgO1xuICBuICYmIChzID8gKHIudW5zaGlmdChhLCBpKSwgZSA9IGAlYyR7bH0lYyAke2V9YCkgOiBlID0gYCggJHtsfSApJHtlfWApO1xuICB0cnkge1xuICAgIHMgPyBvID8gY29uc29sZVt0XShgJHtlfSAlb2AsIC4uLnIpIDogY29uc29sZVt0XShlLCAuLi5yKSA6IGNvbnNvbGVbdF0oZSk7XG4gIH0gY2F0Y2gge1xuICB9XG59XG5FZS5sb2dMZXZlbCA9IFwiVkVSQk9TRVwiO1xuZnVuY3Rpb24geG8obikge1xuICBFZS5sb2dMZXZlbCA9IG47XG59XG5jb25zdCBJID0gRWUuYmluZCh3aW5kb3csICExKSwgSyA9IEVlLmJpbmQod2luZG93LCAhMCk7XG5mdW5jdGlvbiBuZShuKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobikubWF0Y2goL1xccyhbYS16QS1aXSspLylbMV0udG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIE8obikge1xuICByZXR1cm4gbmUobikgPT09IFwiZnVuY3Rpb25cIiB8fCBuZShuKSA9PT0gXCJhc3luY2Z1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBSKG4pIHtcbiAgcmV0dXJuIG5lKG4pID09PSBcIm9iamVjdFwiO1xufVxuZnVuY3Rpb24gUShuKSB7XG4gIHJldHVybiBuZShuKSA9PT0gXCJzdHJpbmdcIjtcbn1cbmZ1bmN0aW9uIHlvKG4pIHtcbiAgcmV0dXJuIG5lKG4pID09PSBcImJvb2xlYW5cIjtcbn1cbmZ1bmN0aW9uIG10KG4pIHtcbiAgcmV0dXJuIG5lKG4pID09PSBcIm51bWJlclwiO1xufVxuZnVuY3Rpb24gYnQobikge1xuICByZXR1cm4gbmUobikgPT09IFwidW5kZWZpbmVkXCI7XG59XG5mdW5jdGlvbiBYKG4pIHtcbiAgcmV0dXJuIG4gPyBPYmplY3Qua2V5cyhuKS5sZW5ndGggPT09IDAgJiYgbi5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0IDogITA7XG59XG5mdW5jdGlvbiBJdChuKSB7XG4gIHJldHVybiBuID4gNDcgJiYgbiA8IDU4IHx8IC8vIG51bWJlciBrZXlzXG4gIG4gPT09IDMyIHx8IG4gPT09IDEzIHx8IC8vIFNwYWNlIGJhciAmIHJldHVybiBrZXkocylcbiAgbiA9PT0gMjI5IHx8IC8vIHByb2Nlc3Npbmcga2V5IGlucHV0IGZvciBjZXJ0YWluIGxhbmd1YWdlcyDigJQgQ2hpbmVzZSwgSmFwYW5lc2UsIGV0Yy5cbiAgbiA+IDY0ICYmIG4gPCA5MSB8fCAvLyBsZXR0ZXIga2V5c1xuICBuID4gOTUgJiYgbiA8IDExMiB8fCAvLyBOdW1wYWQga2V5c1xuICBuID4gMTg1ICYmIG4gPCAxOTMgfHwgLy8gOz0sLS4vYCAoaW4gb3JkZXIpXG4gIG4gPiAyMTggJiYgbiA8IDIyMztcbn1cbmFzeW5jIGZ1bmN0aW9uIEVvKG4sIGUgPSAoKSA9PiB7XG59LCB0ID0gKCkgPT4ge1xufSkge1xuICBhc3luYyBmdW5jdGlvbiBvKGksIHMsIHIpIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgaS5mdW5jdGlvbihpLmRhdGEpLCBhd2FpdCBzKGJ0KGkuZGF0YSkgPyB7fSA6IGkuZGF0YSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICByKGJ0KGkuZGF0YSkgPyB7fSA6IGkuZGF0YSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuLnJlZHVjZShhc3luYyAoaSwgcykgPT4gKGF3YWl0IGksIG8ocywgZSwgdCkpLCBQcm9taXNlLnJlc29sdmUoKSk7XG59XG5mdW5jdGlvbiBNdChuKSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChuKTtcbn1cbmZ1bmN0aW9uIEFlKG4sIGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLCBvID0gYXJndW1lbnRzO1xuICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IG4uYXBwbHkodCwgbyksIGUpO1xuICB9O1xufVxuZnVuY3Rpb24gQm8obikge1xuICByZXR1cm4gbi5uYW1lLnNwbGl0KFwiLlwiKS5wb3AoKTtcbn1cbmZ1bmN0aW9uIFRvKG4pIHtcbiAgcmV0dXJuIC9eWy1cXHddK1xcLyhbLStcXHddK3xcXCopJC8udGVzdChuKTtcbn1cbmZ1bmN0aW9uIGt0KG4sIGUsIHQpIHtcbiAgbGV0IG87XG4gIHJldHVybiAoLi4uaSkgPT4ge1xuICAgIGNvbnN0IHMgPSB0aGlzLCByID0gKCkgPT4ge1xuICAgICAgbyA9IG51bGwsIHQgfHwgbi5hcHBseShzLCBpKTtcbiAgICB9LCBsID0gdCAmJiAhbztcbiAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KG8pLCBvID0gd2luZG93LnNldFRpbWVvdXQociwgZSksIGwgJiYgbi5hcHBseShzLCBpKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIFZlKG4sIGUsIHQgPSB2b2lkIDApIHtcbiAgbGV0IG8sIGksIHMsIHIgPSBudWxsLCBsID0gMDtcbiAgdCB8fCAodCA9IHt9KTtcbiAgY29uc3QgYSA9IGZ1bmN0aW9uKCkge1xuICAgIGwgPSB0LmxlYWRpbmcgPT09ICExID8gMCA6IERhdGUubm93KCksIHIgPSBudWxsLCBzID0gbi5hcHBseShvLCBpKSwgciB8fCAobyA9IGkgPSBudWxsKTtcbiAgfTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IGMgPSBEYXRlLm5vdygpO1xuICAgICFsICYmIHQubGVhZGluZyA9PT0gITEgJiYgKGwgPSBjKTtcbiAgICBjb25zdCB1ID0gZSAtIChjIC0gbCk7XG4gICAgcmV0dXJuIG8gPSB0aGlzLCBpID0gYXJndW1lbnRzLCB1IDw9IDAgfHwgdSA+IGUgPyAociAmJiAoY2xlYXJUaW1lb3V0KHIpLCByID0gbnVsbCksIGwgPSBjLCBzID0gbi5hcHBseShvLCBpKSwgciB8fCAobyA9IGkgPSBudWxsKSkgOiAhciAmJiB0LnRyYWlsaW5nICE9PSAhMSAmJiAociA9IHNldFRpbWVvdXQoYSwgdSkpLCBzO1xuICB9O1xufVxuZnVuY3Rpb24gQ28oKSB7XG4gIGNvbnN0IG4gPSB7XG4gICAgd2luOiAhMSxcbiAgICBtYWM6ICExLFxuICAgIHgxMTogITEsXG4gICAgbGludXg6ICExXG4gIH0sIGUgPSBPYmplY3Qua2V5cyhuKS5maW5kKCh0KSA9PiB3aW5kb3cubmF2aWdhdG9yLmFwcFZlcnNpb24udG9Mb3dlckNhc2UoKS5pbmRleE9mKHQpICE9PSAtMSk7XG4gIHJldHVybiBlICYmIChuW2VdID0gITApLCBuO1xufVxuZnVuY3Rpb24gT2Uobikge1xuICByZXR1cm4gblswXS50b1VwcGVyQ2FzZSgpICsgbi5zbGljZSgxKTtcbn1cbmZ1bmN0aW9uIHFlKG4sIC4uLmUpIHtcbiAgaWYgKCFlLmxlbmd0aClcbiAgICByZXR1cm4gbjtcbiAgY29uc3QgdCA9IGUuc2hpZnQoKTtcbiAgaWYgKFIobikgJiYgUih0KSlcbiAgICBmb3IgKGNvbnN0IG8gaW4gdClcbiAgICAgIFIodFtvXSkgPyAobltvXSB8fCBPYmplY3QuYXNzaWduKG4sIHsgW29dOiB7fSB9KSwgcWUobltvXSwgdFtvXSkpIDogT2JqZWN0LmFzc2lnbihuLCB7IFtvXTogdFtvXSB9KTtcbiAgcmV0dXJuIHFlKG4sIC4uLmUpO1xufVxuZnVuY3Rpb24gZXQobikge1xuICBjb25zdCBlID0gQ28oKTtcbiAgcmV0dXJuIG4gPSBuLnJlcGxhY2UoL3NoaWZ0L2dpLCBcIuKHp1wiKS5yZXBsYWNlKC9iYWNrc3BhY2UvZ2ksIFwi4oyrXCIpLnJlcGxhY2UoL2VudGVyL2dpLCBcIuKPjlwiKS5yZXBsYWNlKC91cC9naSwgXCLihpFcIikucmVwbGFjZSgvbGVmdC9naSwgXCLihpJcIikucmVwbGFjZSgvZG93bi9naSwgXCLihpNcIikucmVwbGFjZSgvcmlnaHQvZ2ksIFwi4oaQXCIpLnJlcGxhY2UoL2VzY2FwZS9naSwgXCLijotcIikucmVwbGFjZSgvaW5zZXJ0L2dpLCBcIkluc1wiKS5yZXBsYWNlKC9kZWxldGUvZ2ksIFwi4pChXCIpLnJlcGxhY2UoL1xcKy9naSwgXCIgKyBcIiksIGUubWFjID8gbiA9IG4ucmVwbGFjZSgvY3RybHxjbWQvZ2ksIFwi4oyYXCIpLnJlcGxhY2UoL2FsdC9naSwgXCLijKVcIikgOiBuID0gbi5yZXBsYWNlKC9jbWQvZ2ksIFwiQ3RybFwiKS5yZXBsYWNlKC93aW5kb3dzL2dpLCBcIldJTlwiKSwgbjtcbn1cbmZ1bmN0aW9uIFNvKG4pIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IFVSTChuKS5ocmVmO1xuICB9IGNhdGNoIHtcbiAgfVxuICByZXR1cm4gbi5zdWJzdHJpbmcoMCwgMikgPT09IFwiLy9cIiA/IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCArIG4gOiB3aW5kb3cubG9jYXRpb24ub3JpZ2luICsgbjtcbn1cbmZ1bmN0aW9uIElvKCkge1xuICByZXR1cm4gdm8oMTApO1xufVxuZnVuY3Rpb24gTW8obikge1xuICB3aW5kb3cub3BlbihuLCBcIl9ibGFua1wiKTtcbn1cbmZ1bmN0aW9uIEFvKG4gPSBcIlwiKSB7XG4gIHJldHVybiBgJHtufSR7TWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMWU4KS50b1N0cmluZygxNil9YDtcbn1cbmZ1bmN0aW9uIFplKG4sIGUsIHQpIHtcbiAgY29uc3QgbyA9IGDCqyR7ZX3CuyBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS4gUGxlYXNlIHVzZSB0aGUgwqske3R9wrsgaW5zdGVhZC5gO1xuICBuICYmIEsobywgXCJ3YXJuXCIpO1xufVxuZnVuY3Rpb24gaGUobiwgZSwgdCkge1xuICBjb25zdCBvID0gdC52YWx1ZSA/IFwidmFsdWVcIiA6IFwiZ2V0XCIsIGkgPSB0W29dLCBzID0gYCMke2V9Q2FjaGVgO1xuICBpZiAodFtvXSA9IGZ1bmN0aW9uKC4uLnIpIHtcbiAgICByZXR1cm4gdGhpc1tzXSA9PT0gdm9pZCAwICYmICh0aGlzW3NdID0gaS5hcHBseSh0aGlzLCAuLi5yKSksIHRoaXNbc107XG4gIH0sIG8gPT09IFwiZ2V0XCIgJiYgdC5zZXQpIHtcbiAgICBjb25zdCByID0gdC5zZXQ7XG4gICAgdC5zZXQgPSBmdW5jdGlvbihsKSB7XG4gICAgICBkZWxldGUgbltzXSwgci5hcHBseSh0aGlzLCBsKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiB0O1xufVxuY29uc3QgQXQgPSA2NTA7XG5mdW5jdGlvbiB1ZSgpIHtcbiAgcmV0dXJuIHdpbmRvdy5tYXRjaE1lZGlhKGAobWF4LXdpZHRoOiAke0F0fXB4KWApLm1hdGNoZXM7XG59XG5jb25zdCBHZSA9IHR5cGVvZiB3aW5kb3cgPCBcInVcIiAmJiB3aW5kb3cubmF2aWdhdG9yICYmIHdpbmRvdy5uYXZpZ2F0b3IucGxhdGZvcm0gJiYgKC9pUChhZHxob25lfG9kKS8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnBsYXRmb3JtKSB8fCB3aW5kb3cubmF2aWdhdG9yLnBsYXRmb3JtID09PSBcIk1hY0ludGVsXCIgJiYgd2luZG93Lm5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDEpO1xuZnVuY3Rpb24gT28obiwgZSkge1xuICBjb25zdCB0ID0gQXJyYXkuaXNBcnJheShuKSB8fCBSKG4pLCBvID0gQXJyYXkuaXNBcnJheShlKSB8fCBSKGUpO1xuICByZXR1cm4gdCB8fCBvID8gSlNPTi5zdHJpbmdpZnkobikgPT09IEpTT04uc3RyaW5naWZ5KGUpIDogbiA9PT0gZTtcbn1cbmNsYXNzIGQge1xuICAvKipcbiAgICogQ2hlY2sgaWYgcGFzc2VkIHRhZyBoYXMgbm8gY2xvc2VkIHRhZ1xuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YWcgLSBlbGVtZW50IHRvIGNoZWNrXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzU2luZ2xlVGFnKGUpIHtcbiAgICByZXR1cm4gZS50YWdOYW1lICYmIFtcbiAgICAgIFwiQVJFQVwiLFxuICAgICAgXCJCQVNFXCIsXG4gICAgICBcIkJSXCIsXG4gICAgICBcIkNPTFwiLFxuICAgICAgXCJDT01NQU5EXCIsXG4gICAgICBcIkVNQkVEXCIsXG4gICAgICBcIkhSXCIsXG4gICAgICBcIklNR1wiLFxuICAgICAgXCJJTlBVVFwiLFxuICAgICAgXCJLRVlHRU5cIixcbiAgICAgIFwiTElOS1wiLFxuICAgICAgXCJNRVRBXCIsXG4gICAgICBcIlBBUkFNXCIsXG4gICAgICBcIlNPVVJDRVwiLFxuICAgICAgXCJUUkFDS1wiLFxuICAgICAgXCJXQlJcIlxuICAgIF0uaW5jbHVkZXMoZS50YWdOYW1lKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgZWxlbWVudCBpcyBCUiBvciBXQlJcbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIGVsZW1lbnQgdG8gY2hlY2tcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNMaW5lQnJlYWtUYWcoZSkge1xuICAgIHJldHVybiBlICYmIGUudGFnTmFtZSAmJiBbXG4gICAgICBcIkJSXCIsXG4gICAgICBcIldCUlwiXG4gICAgXS5pbmNsdWRlcyhlLnRhZ05hbWUpO1xuICB9XG4gIC8qKlxuICAgKiBIZWxwZXIgZm9yIG1ha2luZyBFbGVtZW50cyB3aXRoIGNsYXNzIG5hbWUgYW5kIGF0dHJpYnV0ZXNcbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSB0YWdOYW1lIC0gbmV3IEVsZW1lbnQgdGFnIG5hbWVcbiAgICogQHBhcmFtICB7c3RyaW5nW118c3RyaW5nfSBbY2xhc3NOYW1lc10gLSBsaXN0IG9yIG5hbWUgb2YgQ1NTIGNsYXNzIG5hbWUocylcbiAgICogQHBhcmFtICB7b2JqZWN0fSBbYXR0cmlidXRlc10gLSBhbnkgYXR0cmlidXRlc1xuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICBzdGF0aWMgbWFrZShlLCB0ID0gbnVsbCwgbyA9IHt9KSB7XG4gICAgY29uc3QgaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodCkpIHtcbiAgICAgIGNvbnN0IHMgPSB0LmZpbHRlcigocikgPT4gciAhPT0gdm9pZCAwKTtcbiAgICAgIGkuY2xhc3NMaXN0LmFkZCguLi5zKTtcbiAgICB9IGVsc2VcbiAgICAgIHQgJiYgaS5jbGFzc0xpc3QuYWRkKHQpO1xuICAgIGZvciAoY29uc3QgcyBpbiBvKVxuICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIHMpICYmIChpW3NdID0gb1tzXSk7XG4gICAgcmV0dXJuIGk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgVGV4dCBOb2RlIHdpdGggdGhlIHBhc3NlZCBjb250ZW50XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50IC0gdGV4dCBjb250ZW50XG4gICAqIEByZXR1cm5zIHtUZXh0fVxuICAgKi9cbiAgc3RhdGljIHRleHQoZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShlKTtcbiAgfVxuICAvKipcbiAgICogQXBwZW5kIG9uZSBvciBzZXZlcmFsIGVsZW1lbnRzIHRvIHRoZSBwYXJlbnRcbiAgICpcbiAgICogQHBhcmFtICB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fSBwYXJlbnQgLSB3aGVyZSB0byBhcHBlbmRcbiAgICogQHBhcmFtICB7RWxlbWVudHxFbGVtZW50W118RG9jdW1lbnRGcmFnbWVudHxUZXh0fFRleHRbXX0gZWxlbWVudHMgLSBlbGVtZW50IG9yIGVsZW1lbnRzIGxpc3RcbiAgICovXG4gIHN0YXRpYyBhcHBlbmQoZSwgdCkge1xuICAgIEFycmF5LmlzQXJyYXkodCkgPyB0LmZvckVhY2goKG8pID0+IGUuYXBwZW5kQ2hpbGQobykpIDogZS5hcHBlbmRDaGlsZCh0KTtcbiAgfVxuICAvKipcbiAgICogQXBwZW5kIGVsZW1lbnQgb3IgYSBjb3VwbGUgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgcGFyZW50IGVsZW1lbnRzXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gcGFyZW50IC0gd2hlcmUgdG8gYXBwZW5kXG4gICAqIEBwYXJhbSB7RWxlbWVudHxFbGVtZW50W119IGVsZW1lbnRzIC0gZWxlbWVudCBvciBlbGVtZW50cyBsaXN0XG4gICAqL1xuICBzdGF0aWMgcHJlcGVuZChlLCB0KSB7XG4gICAgQXJyYXkuaXNBcnJheSh0KSA/ICh0ID0gdC5yZXZlcnNlKCksIHQuZm9yRWFjaCgobykgPT4gZS5wcmVwZW5kKG8pKSkgOiBlLnByZXBlbmQodCk7XG4gIH1cbiAgLyoqXG4gICAqIFN3YXAgdHdvIGVsZW1lbnRzIGluIHBhcmVudFxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbDEgLSBmcm9tXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsMiAtIHRvXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBzdGF0aWMgc3dhcChlLCB0KSB7XG4gICAgY29uc3QgbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIGkgPSBlLnBhcmVudE5vZGU7XG4gICAgaS5pbnNlcnRCZWZvcmUobywgZSksIGkuaW5zZXJ0QmVmb3JlKGUsIHQpLCBpLmluc2VydEJlZm9yZSh0LCBvKSwgaS5yZW1vdmVDaGlsZChvKTtcbiAgfVxuICAvKipcbiAgICogU2VsZWN0b3IgRGVjb3JhdG9yXG4gICAqXG4gICAqIFJldHVybnMgZmlyc3QgbWF0Y2hcbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbCAtIGVsZW1lbnQgd2Ugc2VhcmNoaW5nIGluc2lkZS4gRGVmYXVsdCAtIERPTSBEb2N1bWVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgLSBzZWFyY2hpbmcgc3RyaW5nXG4gICAqIEByZXR1cm5zIHtFbGVtZW50fVxuICAgKi9cbiAgc3RhdGljIGZpbmQoZSA9IGRvY3VtZW50LCB0KSB7XG4gICAgcmV0dXJuIGUucXVlcnlTZWxlY3Rvcih0KTtcbiAgfVxuICAvKipcbiAgICogR2V0IEVsZW1lbnQgYnkgSWRcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gaWQgdG8gZmluZFxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCBudWxsfVxuICAgKi9cbiAgc3RhdGljIGdldChlKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGUpO1xuICB9XG4gIC8qKlxuICAgKiBTZWxlY3RvciBEZWNvcmF0b3IuXG4gICAqXG4gICAqIFJldHVybnMgYWxsIG1hdGNoZXNcbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fERvY3VtZW50fSBlbCAtIGVsZW1lbnQgd2Ugc2VhcmNoaW5nIGluc2lkZS4gRGVmYXVsdCAtIERPTSBEb2N1bWVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgLSBzZWFyY2hpbmcgc3RyaW5nXG4gICAqIEByZXR1cm5zIHtOb2RlTGlzdH1cbiAgICovXG4gIHN0YXRpYyBmaW5kQWxsKGUgPSBkb2N1bWVudCwgdCkge1xuICAgIHJldHVybiBlLnF1ZXJ5U2VsZWN0b3JBbGwodCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgQ1NTIHNlbGVjdG9yIGZvciBhbGwgdGV4dCBpbnB1dHNcbiAgICovXG4gIHN0YXRpYyBnZXQgYWxsSW5wdXRzU2VsZWN0b3IoKSB7XG4gICAgcmV0dXJuIFwiW2NvbnRlbnRlZGl0YWJsZT10cnVlXSwgdGV4dGFyZWEsIGlucHV0Om5vdChbdHlwZV0pLCBcIiArIFtcInRleHRcIiwgXCJwYXNzd29yZFwiLCBcImVtYWlsXCIsIFwibnVtYmVyXCIsIFwic2VhcmNoXCIsIFwidGVsXCIsIFwidXJsXCJdLm1hcCgodCkgPT4gYGlucHV0W3R5cGU9XCIke3R9XCJdYCkuam9pbihcIiwgXCIpO1xuICB9XG4gIC8qKlxuICAgKiBGaW5kIGFsbCBjb250ZW50ZWRpdGFibGUsIHRleHRhcmVhIGFuZCBlZGl0YWJsZSBpbnB1dCBlbGVtZW50cyBwYXNzZWQgaG9sZGVyIGNvbnRhaW5zXG4gICAqXG4gICAqIEBwYXJhbSBob2xkZXIgLSBlbGVtZW50IHdoZXJlIHRvIGZpbmQgaW5wdXRzXG4gICAqL1xuICBzdGF0aWMgZmluZEFsbElucHV0cyhlKSB7XG4gICAgcmV0dXJuIE10KGUucXVlcnlTZWxlY3RvckFsbChkLmFsbElucHV0c1NlbGVjdG9yKSkucmVkdWNlKCh0LCBvKSA9PiBkLmlzTmF0aXZlSW5wdXQobykgfHwgZC5jb250YWluc09ubHlJbmxpbmVFbGVtZW50cyhvKSA/IFsuLi50LCBvXSA6IFsuLi50LCAuLi5kLmdldERlZXBlc3RCbG9ja0VsZW1lbnRzKG8pXSwgW10pO1xuICB9XG4gIC8qKlxuICAgKiBTZWFyY2ggZm9yIGRlZXBlc3Qgbm9kZSB3aGljaCBpcyBMZWFmLlxuICAgKiBMZWFmIGlzIHRoZSB2ZXJ0ZXggdGhhdCBkb2Vzbid0IGhhdmUgYW55IGNoaWxkIG5vZGVzXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgcmVjdXJzaXZlbHkgZ29lcyB0aHJvdyB0aGUgYWxsIE5vZGUgdW50aWwgaXQgZmluZHMgdGhlIExlYWZcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlIC0gcm9vdCBOb2RlLiBGcm9tIHRoaXMgdmVydGV4IHdlIHN0YXJ0IERlZXAtZmlyc3Qgc2VhcmNoXG4gICAqICAgICAgICAgICAgICAgICAgICAgIHtAbGluayBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EZXB0aC1maXJzdF9zZWFyY2h9XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2F0TGFzdF0gLSBmaW5kIGxhc3QgdGV4dCBub2RlXG4gICAqIEByZXR1cm5zIC0gaXQgY2FuIGJlIHRleHQgTm9kZSBvciBFbGVtZW50IE5vZGUsIHNvIHRoYXQgY2FyZXQgd2lsbCBhYmxlIHRvIHdvcmsgd2l0aCBpdFxuICAgKiAgICAgICAgICAgIENhbiByZXR1cm4gbnVsbCBpZiBub2RlIGlzIERvY3VtZW50IG9yIERvY3VtZW50RnJhZ21lbnQsIG9yIG5vZGUgaXMgbm90IGF0dGFjaGVkIHRvIHRoZSBET01cbiAgICovXG4gIHN0YXRpYyBnZXREZWVwZXN0Tm9kZShlLCB0ID0gITEpIHtcbiAgICBjb25zdCBvID0gdCA/IFwibGFzdENoaWxkXCIgOiBcImZpcnN0Q2hpbGRcIiwgaSA9IHQgPyBcInByZXZpb3VzU2libGluZ1wiIDogXCJuZXh0U2libGluZ1wiO1xuICAgIGlmIChlICYmIGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFICYmIGVbb10pIHtcbiAgICAgIGxldCBzID0gZVtvXTtcbiAgICAgIGlmIChkLmlzU2luZ2xlVGFnKHMpICYmICFkLmlzTmF0aXZlSW5wdXQocykgJiYgIWQuaXNMaW5lQnJlYWtUYWcocykpXG4gICAgICAgIGlmIChzW2ldKVxuICAgICAgICAgIHMgPSBzW2ldO1xuICAgICAgICBlbHNlIGlmIChzLnBhcmVudE5vZGVbaV0pXG4gICAgICAgICAgcyA9IHMucGFyZW50Tm9kZVtpXTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJldHVybiBzLnBhcmVudE5vZGU7XG4gICAgICByZXR1cm4gdGhpcy5nZXREZWVwZXN0Tm9kZShzLCB0KTtcbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIG9iamVjdCBpcyBET00gbm9kZVxuICAgKlxuICAgKiBAcGFyYW0geyp9IG5vZGUgLSBvYmplY3QgdG8gY2hlY2tcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICBzdGF0aWMgaXNFbGVtZW50KGUpIHtcbiAgICByZXR1cm4gbXQoZSkgPyAhMSA6IGUgJiYgZS5ub2RlVHlwZSAmJiBlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgb2JqZWN0IGlzIERvY3VtZW50RnJhZ21lbnQgbm9kZVxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbm9kZSAtIG9iamVjdCB0byBjaGVja1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gIHN0YXRpYyBpc0ZyYWdtZW50KGUpIHtcbiAgICByZXR1cm4gbXQoZSkgPyAhMSA6IGUgJiYgZS5ub2RlVHlwZSAmJiBlLm5vZGVUeXBlID09PSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREU7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIHBhc3NlZCBlbGVtZW50IGlzIGNvbnRlbnRlZGl0YWJsZVxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gaHRtbCBlbGVtZW50IHRvIGNoZWNrXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzQ29udGVudEVkaXRhYmxlKGUpIHtcbiAgICByZXR1cm4gZS5jb250ZW50RWRpdGFibGUgPT09IFwidHJ1ZVwiO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgdGFyZ2V0IGlmIGl0IGlzIG5hdGl2ZSBpbnB1dFxuICAgKlxuICAgKiBAcGFyYW0geyp9IHRhcmdldCAtIEhUTUwgZWxlbWVudCBvciBzdHJpbmdcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICBzdGF0aWMgaXNOYXRpdmVJbnB1dChlKSB7XG4gICAgY29uc3QgdCA9IFtcbiAgICAgIFwiSU5QVVRcIixcbiAgICAgIFwiVEVYVEFSRUFcIlxuICAgIF07XG4gICAgcmV0dXJuIGUgJiYgZS50YWdOYW1lID8gdC5pbmNsdWRlcyhlLnRhZ05hbWUpIDogITE7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB3ZSBjYW4gc2V0IGNhcmV0XG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldCAtIHRhcmdldCB0byBjaGVja1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBjYW5TZXRDYXJldChlKSB7XG4gICAgbGV0IHQgPSAhMDtcbiAgICBpZiAoZC5pc05hdGl2ZUlucHV0KGUpKVxuICAgICAgc3dpdGNoIChlLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcImZpbGVcIjpcbiAgICAgICAgY2FzZSBcImNoZWNrYm94XCI6XG4gICAgICAgIGNhc2UgXCJyYWRpb1wiOlxuICAgICAgICBjYXNlIFwiaGlkZGVuXCI6XG4gICAgICAgIGNhc2UgXCJzdWJtaXRcIjpcbiAgICAgICAgY2FzZSBcImJ1dHRvblwiOlxuICAgICAgICBjYXNlIFwiaW1hZ2VcIjpcbiAgICAgICAgY2FzZSBcInJlc2V0XCI6XG4gICAgICAgICAgdCA9ICExO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGVsc2VcbiAgICAgIHQgPSBkLmlzQ29udGVudEVkaXRhYmxlKGUpO1xuICAgIHJldHVybiB0O1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3Mgbm9kZSBpZiBpdCBpcyBlbXB0eVxuICAgKlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGNoZWNrcyBzaW1wbGUgTm9kZSB3aXRob3V0IGFueSBjaGlsZHMgZm9yIGVtcHRpbmVzc1xuICAgKiBJZiB5b3UgaGF2ZSBOb2RlIHdpdGggMiBvciBtb3JlIGNoaWxkcmVuIGlkIGRlcHRoLCB5b3UgYmV0dGVyIHVzZSB7QGxpbmsgRG9tI2lzRW1wdHl9IG1ldGhvZFxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgLSBub2RlIHRvIGNoZWNrXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbaWdub3JlQ2hhcnNdIC0gY2hhciBvciBzdWJzdHJpbmcgdG8gdHJlYXQgYXMgZW1wdHlcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgaXQgaXMgZW1wdHlcbiAgICovXG4gIHN0YXRpYyBpc05vZGVFbXB0eShlLCB0KSB7XG4gICAgbGV0IG87XG4gICAgcmV0dXJuIHRoaXMuaXNTaW5nbGVUYWcoZSkgJiYgIXRoaXMuaXNMaW5lQnJlYWtUYWcoZSkgPyAhMSA6ICh0aGlzLmlzRWxlbWVudChlKSAmJiB0aGlzLmlzTmF0aXZlSW5wdXQoZSkgPyBvID0gZS52YWx1ZSA6IG8gPSBlLnRleHRDb250ZW50LnJlcGxhY2UoXCLigItcIiwgXCJcIiksIHQgJiYgKG8gPSBvLnJlcGxhY2UobmV3IFJlZ0V4cCh0LCBcImdcIiksIFwiXCIpKSwgby50cmltKCkubGVuZ3RoID09PSAwKTtcbiAgfVxuICAvKipcbiAgICogY2hlY2tzIG5vZGUgaWYgaXQgaXMgZG9lc24ndCBoYXZlIGFueSBjaGlsZCBub2Rlc1xuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgLSBub2RlIHRvIGNoZWNrXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzTGVhZihlKSB7XG4gICAgcmV0dXJuIGUgPyBlLmNoaWxkTm9kZXMubGVuZ3RoID09PSAwIDogITE7XG4gIH1cbiAgLyoqXG4gICAqIGJyZWFkdGgtZmlyc3Qgc2VhcmNoIChCRlMpXG4gICAqIHtAbGluayBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CcmVhZHRoLWZpcnN0X3NlYXJjaH1cbiAgICpcbiAgICogQGRlc2NyaXB0aW9uIFB1c2hlcyB0byBzdGFjayBhbGwgRE9NIGxlYWZzIGFuZCBjaGVja3MgZm9yIGVtcHRpbmVzc1xuICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgLSBub2RlIHRvIGNoZWNrXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbaWdub3JlQ2hhcnNdIC0gY2hhciBvciBzdWJzdHJpbmcgdG8gdHJlYXQgYXMgZW1wdHlcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNFbXB0eShlLCB0KSB7XG4gICAgZS5ub3JtYWxpemUoKTtcbiAgICBjb25zdCBvID0gW2VdO1xuICAgIGZvciAoOyBvLmxlbmd0aCA+IDA7IClcbiAgICAgIGlmIChlID0gby5zaGlmdCgpLCAhIWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNMZWFmKGUpICYmICF0aGlzLmlzTm9kZUVtcHR5KGUsIHQpKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgZS5jaGlsZE5vZGVzICYmIG8ucHVzaCguLi5BcnJheS5mcm9tKGUuY2hpbGROb2RlcykpO1xuICAgICAgfVxuICAgIHJldHVybiAhMDtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgc3RyaW5nIGNvbnRhaW5zIGh0bWwgZWxlbWVudHNcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciAtIHN0cmluZyB0byBjaGVja1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc0hUTUxTdHJpbmcoZSkge1xuICAgIGNvbnN0IHQgPSBkLm1ha2UoXCJkaXZcIik7XG4gICAgcmV0dXJuIHQuaW5uZXJIVE1MID0gZSwgdC5jaGlsZEVsZW1lbnRDb3VudCA+IDA7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBsZW5ndGggb2Ygbm9kZWBzIHRleHQgY29udGVudFxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgLSBub2RlIHdpdGggY29udGVudFxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgc3RhdGljIGdldENvbnRlbnRMZW5ndGgoZSkge1xuICAgIHJldHVybiBkLmlzTmF0aXZlSW5wdXQoZSkgPyBlLnZhbHVlLmxlbmd0aCA6IGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFID8gZS5sZW5ndGggOiBlLnRleHRDb250ZW50Lmxlbmd0aDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGFycmF5IG9mIG5hbWVzIG9mIGJsb2NrIGh0bWwgZWxlbWVudHNcbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ1tdfVxuICAgKi9cbiAgc3RhdGljIGdldCBibG9ja0VsZW1lbnRzKCkge1xuICAgIHJldHVybiBbXG4gICAgICBcImFkZHJlc3NcIixcbiAgICAgIFwiYXJ0aWNsZVwiLFxuICAgICAgXCJhc2lkZVwiLFxuICAgICAgXCJibG9ja3F1b3RlXCIsXG4gICAgICBcImNhbnZhc1wiLFxuICAgICAgXCJkaXZcIixcbiAgICAgIFwiZGxcIixcbiAgICAgIFwiZHRcIixcbiAgICAgIFwiZmllbGRzZXRcIixcbiAgICAgIFwiZmlnY2FwdGlvblwiLFxuICAgICAgXCJmaWd1cmVcIixcbiAgICAgIFwiZm9vdGVyXCIsXG4gICAgICBcImZvcm1cIixcbiAgICAgIFwiaDFcIixcbiAgICAgIFwiaDJcIixcbiAgICAgIFwiaDNcIixcbiAgICAgIFwiaDRcIixcbiAgICAgIFwiaDVcIixcbiAgICAgIFwiaDZcIixcbiAgICAgIFwiaGVhZGVyXCIsXG4gICAgICBcImhncm91cFwiLFxuICAgICAgXCJoclwiLFxuICAgICAgXCJsaVwiLFxuICAgICAgXCJtYWluXCIsXG4gICAgICBcIm5hdlwiLFxuICAgICAgXCJub3NjcmlwdFwiLFxuICAgICAgXCJvbFwiLFxuICAgICAgXCJvdXRwdXRcIixcbiAgICAgIFwicFwiLFxuICAgICAgXCJwcmVcIixcbiAgICAgIFwicnVieVwiLFxuICAgICAgXCJzZWN0aW9uXCIsXG4gICAgICBcInRhYmxlXCIsXG4gICAgICBcInRib2R5XCIsXG4gICAgICBcInRoZWFkXCIsXG4gICAgICBcInRyXCIsXG4gICAgICBcInRmb290XCIsXG4gICAgICBcInVsXCIsXG4gICAgICBcInZpZGVvXCJcbiAgICBdO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBwYXNzZWQgY29udGVudCBpbmNsdWRlcyBvbmx5IGlubGluZSBlbGVtZW50c1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xIVE1MRWxlbWVudH0gZGF0YSAtIGVsZW1lbnQgb3IgaHRtbCBzdHJpbmdcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgY29udGFpbnNPbmx5SW5saW5lRWxlbWVudHMoZSkge1xuICAgIGxldCB0O1xuICAgIFEoZSkgPyAodCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIHQuaW5uZXJIVE1MID0gZSkgOiB0ID0gZTtcbiAgICBjb25zdCBvID0gKGkpID0+ICFkLmJsb2NrRWxlbWVudHMuaW5jbHVkZXMoaS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpICYmIEFycmF5LmZyb20oaS5jaGlsZHJlbikuZXZlcnkobyk7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odC5jaGlsZHJlbikuZXZlcnkobyk7XG4gIH1cbiAgLyoqXG4gICAqIEZpbmQgYW5kIHJldHVybiBhbGwgYmxvY2sgZWxlbWVudHMgaW4gdGhlIHBhc3NlZCBwYXJlbnQgKGluY2x1ZGluZyBzdWJ0cmVlKVxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnQgLSByb290IGVsZW1lbnRcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50W119XG4gICAqL1xuICBzdGF0aWMgZ2V0RGVlcGVzdEJsb2NrRWxlbWVudHMoZSkge1xuICAgIHJldHVybiBkLmNvbnRhaW5zT25seUlubGluZUVsZW1lbnRzKGUpID8gW2VdIDogQXJyYXkuZnJvbShlLmNoaWxkcmVuKS5yZWR1Y2UoKHQsIG8pID0+IFsuLi50LCAuLi5kLmdldERlZXBlc3RCbG9ja0VsZW1lbnRzKG8pXSwgW10pO1xuICB9XG4gIC8qKlxuICAgKiBIZWxwZXIgZm9yIGdldCBob2xkZXIgZnJvbSB7c3RyaW5nfSBvciByZXR1cm4gSFRNTEVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmcgfCBIVE1MRWxlbWVudH0gZWxlbWVudCAtIGhvbGRlcidzIGlkIG9yIGhvbGRlcidzIEhUTUwgRWxlbWVudFxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICBzdGF0aWMgZ2V0SG9sZGVyKGUpIHtcbiAgICByZXR1cm4gUShlKSA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGUpIDogZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGVsZW1lbnQgaXMgYW5jaG9yIChpcyBBIHRhZylcbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gZWxlbWVudCB0byBjaGVja1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc0FuY2hvcihlKSB7XG4gICAgcmV0dXJuIGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImFcIjtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGVsZW1lbnQncyBvZmZzZXQgcmVsYXRlZCB0byB0aGUgZG9jdW1lbnRcbiAgICpcbiAgICogQHRvZG8gaGFuZGxlIGNhc2Ugd2hlbiBlZGl0b3IgaW5pdGlhbGl6ZWQgaW4gc2Nyb2xsYWJsZSBwb3B1cFxuICAgKiBAcGFyYW0gZWwgLSBlbGVtZW50IHRvIGNvbXB1dGUgb2Zmc2V0XG4gICAqL1xuICBzdGF0aWMgb2Zmc2V0KGUpIHtcbiAgICBjb25zdCB0ID0gZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgbyA9IHdpbmRvdy5wYWdlWE9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCwgaSA9IHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wLCBzID0gdC50b3AgKyBpLCByID0gdC5sZWZ0ICsgbztcbiAgICByZXR1cm4ge1xuICAgICAgdG9wOiBzLFxuICAgICAgbGVmdDogcixcbiAgICAgIGJvdHRvbTogcyArIHQuaGVpZ2h0LFxuICAgICAgcmlnaHQ6IHIgKyB0LndpZHRoXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gTG8obikge1xuICByZXR1cm4gIS9bXlxcdFxcblxcciBdLy50ZXN0KG4pO1xufVxuZnVuY3Rpb24gX28obikge1xuICBjb25zdCBlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUobiksIHQgPSBwYXJzZUZsb2F0KGUuZm9udFNpemUpLCBvID0gcGFyc2VGbG9hdChlLmxpbmVIZWlnaHQpIHx8IHQgKiAxLjIsIGkgPSBwYXJzZUZsb2F0KGUucGFkZGluZ1RvcCksIHMgPSBwYXJzZUZsb2F0KGUuYm9yZGVyVG9wV2lkdGgpLCByID0gcGFyc2VGbG9hdChlLm1hcmdpblRvcCksIGwgPSB0ICogMC44LCBhID0gKG8gLSB0KSAvIDI7XG4gIHJldHVybiByICsgcyArIGkgKyBhICsgbDtcbn1cbmZ1bmN0aW9uIE90KG4pIHtcbiAgbi5kYXRhc2V0LmVtcHR5ID0gZC5pc0VtcHR5KG4pID8gXCJ0cnVlXCIgOiBcImZhbHNlXCI7XG59XG5jb25zdCBObyA9IHtcbiAgYmxvY2tUdW5lczoge1xuICAgIHRvZ2dsZXI6IHtcbiAgICAgIFwiQ2xpY2sgdG8gdHVuZVwiOiBcIlwiLFxuICAgICAgXCJvciBkcmFnIHRvIG1vdmVcIjogXCJcIlxuICAgIH1cbiAgfSxcbiAgaW5saW5lVG9vbGJhcjoge1xuICAgIGNvbnZlcnRlcjoge1xuICAgICAgXCJDb252ZXJ0IHRvXCI6IFwiXCJcbiAgICB9XG4gIH0sXG4gIHRvb2xiYXI6IHtcbiAgICB0b29sYm94OiB7XG4gICAgICBBZGQ6IFwiXCJcbiAgICB9XG4gIH0sXG4gIHBvcG92ZXI6IHtcbiAgICBGaWx0ZXI6IFwiXCIsXG4gICAgXCJOb3RoaW5nIGZvdW5kXCI6IFwiXCIsXG4gICAgXCJDb252ZXJ0IHRvXCI6IFwiXCJcbiAgfVxufSwgUG8gPSB7XG4gIFRleHQ6IFwiXCIsXG4gIExpbms6IFwiXCIsXG4gIEJvbGQ6IFwiXCIsXG4gIEl0YWxpYzogXCJcIlxufSwgRG8gPSB7XG4gIGxpbms6IHtcbiAgICBcIkFkZCBhIGxpbmtcIjogXCJcIlxuICB9LFxuICBzdHViOiB7XG4gICAgXCJUaGUgYmxvY2sgY2FuIG5vdCBiZSBkaXNwbGF5ZWQgY29ycmVjdGx5LlwiOiBcIlwiXG4gIH1cbn0sIFJvID0ge1xuICBkZWxldGU6IHtcbiAgICBEZWxldGU6IFwiXCIsXG4gICAgXCJDbGljayB0byBkZWxldGVcIjogXCJcIlxuICB9LFxuICBtb3ZlVXA6IHtcbiAgICBcIk1vdmUgdXBcIjogXCJcIlxuICB9LFxuICBtb3ZlRG93bjoge1xuICAgIFwiTW92ZSBkb3duXCI6IFwiXCJcbiAgfVxufSwgTHQgPSB7XG4gIHVpOiBObyxcbiAgdG9vbE5hbWVzOiBQbyxcbiAgdG9vbHM6IERvLFxuICBibG9ja1R1bmVzOiBSb1xufSwgX3QgPSBjbGFzcyBsZSB7XG4gIC8qKlxuICAgKiBUeXBlLXNhZmUgdHJhbnNsYXRpb24gZm9yIGludGVybmFsIFVJIHRleHRzOlxuICAgKiBQZXJmb3JtIHRyYW5zbGF0aW9uIG9mIHRoZSBzdHJpbmcgYnkgbmFtZXNwYWNlIGFuZCBhIGtleVxuICAgKlxuICAgKiBAZXhhbXBsZSBJMThuLnVpKEkxOG5JbnRlcm5hbE5TLnVpLmJsb2NrVHVuZXMudG9nZ2xlciwgJ0NsaWNrIHRvIHR1bmUnKVxuICAgKiBAcGFyYW0gaW50ZXJuYWxOYW1lc3BhY2UgLSBwYXRoIHRvIHRyYW5zbGF0ZWQgc3RyaW5nIGluIGRpY3Rpb25hcnlcbiAgICogQHBhcmFtIGRpY3RLZXkgLSBkaWN0aW9uYXJ5IGtleS4gQmV0dGVyIHRvIHVzZSBkZWZhdWx0IGxvY2FsZSBvcmlnaW5hbCB0ZXh0XG4gICAqL1xuICBzdGF0aWMgdWkoZSwgdCkge1xuICAgIHJldHVybiBsZS5fdChlLCB0KTtcbiAgfVxuICAvKipcbiAgICogVHJhbnNsYXRlIGZvciBleHRlcm5hbCBzdHJpbmdzIHRoYXQgaXMgbm90IHByZXNlbnRlZCBpbiBkZWZhdWx0IGRpY3Rpb25hcnkuXG4gICAqIEZvciBleGFtcGxlLCBmb3IgdXNlci1zcGVjaWZpZWQgdG9vbCBuYW1lc1xuICAgKlxuICAgKiBAcGFyYW0gbmFtZXNwYWNlIC0gcGF0aCB0byB0cmFuc2xhdGVkIHN0cmluZyBpbiBkaWN0aW9uYXJ5XG4gICAqIEBwYXJhbSBkaWN0S2V5IC0gZGljdGlvbmFyeSBrZXkuIEJldHRlciB0byB1c2UgZGVmYXVsdCBsb2NhbGUgb3JpZ2luYWwgdGV4dFxuICAgKi9cbiAgc3RhdGljIHQoZSwgdCkge1xuICAgIHJldHVybiBsZS5fdChlLCB0KTtcbiAgfVxuICAvKipcbiAgICogQWRqdXN0IG1vZHVsZSBmb3IgdXNpbmcgZXh0ZXJuYWwgZGljdGlvbmFyeVxuICAgKlxuICAgKiBAcGFyYW0gZGljdGlvbmFyeSAtIG5ldyBtZXNzYWdlcyBsaXN0IHRvIG92ZXJyaWRlIGRlZmF1bHRcbiAgICovXG4gIHN0YXRpYyBzZXREaWN0aW9uYXJ5KGUpIHtcbiAgICBsZS5jdXJyZW50RGljdGlvbmFyeSA9IGU7XG4gIH1cbiAgLyoqXG4gICAqIFBlcmZvcm0gdHJhbnNsYXRpb24gYm90aCBmb3IgaW50ZXJuYWwgYW5kIGV4dGVybmFsIG5hbWVzcGFjZXNcbiAgICogSWYgdGhlcmUgaXMgbm8gdHJhbnNsYXRpb24gZm91bmQsIHJldHVybnMgcGFzc2VkIGtleSBhcyBhIHRyYW5zbGF0ZWQgbWVzc2FnZVxuICAgKlxuICAgKiBAcGFyYW0gbmFtZXNwYWNlIC0gcGF0aCB0byB0cmFuc2xhdGVkIHN0cmluZyBpbiBkaWN0aW9uYXJ5XG4gICAqIEBwYXJhbSBkaWN0S2V5IC0gZGljdGlvbmFyeSBrZXkuIEJldHRlciB0byB1c2UgZGVmYXVsdCBsb2NhbGUgb3JpZ2luYWwgdGV4dFxuICAgKi9cbiAgc3RhdGljIF90KGUsIHQpIHtcbiAgICBjb25zdCBvID0gbGUuZ2V0TmFtZXNwYWNlKGUpO1xuICAgIHJldHVybiAhbyB8fCAhb1t0XSA/IHQgOiBvW3RdO1xuICB9XG4gIC8qKlxuICAgKiBGaW5kIG1lc3NhZ2VzIHNlY3Rpb24gYnkgbmFtZXNwYWNlIHBhdGhcbiAgICpcbiAgICogQHBhcmFtIG5hbWVzcGFjZSAtIHBhdGggdG8gc2VjdGlvblxuICAgKi9cbiAgc3RhdGljIGdldE5hbWVzcGFjZShlKSB7XG4gICAgcmV0dXJuIGUuc3BsaXQoXCIuXCIpLnJlZHVjZSgobywgaSkgPT4gIW8gfHwgIU9iamVjdC5rZXlzKG8pLmxlbmd0aCA/IHt9IDogb1tpXSwgbGUuY3VycmVudERpY3Rpb25hcnkpO1xuICB9XG59O1xuX3QuY3VycmVudERpY3Rpb25hcnkgPSBMdDtcbmxldCBXID0gX3Q7XG5jbGFzcyBOdCBleHRlbmRzIEVycm9yIHtcbn1cbmNsYXNzIEJlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zdWJzY3JpYmVycyA9IHt9O1xuICB9XG4gIC8qKlxuICAgKiBTdWJzY3JpYmUgYW55IGV2ZW50IG9uIGNhbGxiYWNrXG4gICAqXG4gICAqIEBwYXJhbSBldmVudE5hbWUgLSBldmVudCBuYW1lXG4gICAqIEBwYXJhbSBjYWxsYmFjayAtIHN1YnNjcmliZXJcbiAgICovXG4gIG9uKGUsIHQpIHtcbiAgICBlIGluIHRoaXMuc3Vic2NyaWJlcnMgfHwgKHRoaXMuc3Vic2NyaWJlcnNbZV0gPSBbXSksIHRoaXMuc3Vic2NyaWJlcnNbZV0ucHVzaCh0KTtcbiAgfVxuICAvKipcbiAgICogU3Vic2NyaWJlIGFueSBldmVudCBvbiBjYWxsYmFjay4gQ2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgb25jZSBhbmQgYmUgcmVtb3ZlZCBmcm9tIHN1YnNjcmliZXJzIGFycmF5IGFmdGVyIGNhbGwuXG4gICAqXG4gICAqIEBwYXJhbSBldmVudE5hbWUgLSBldmVudCBuYW1lXG4gICAqIEBwYXJhbSBjYWxsYmFjayAtIHN1YnNjcmliZXJcbiAgICovXG4gIG9uY2UoZSwgdCkge1xuICAgIGUgaW4gdGhpcy5zdWJzY3JpYmVycyB8fCAodGhpcy5zdWJzY3JpYmVyc1tlXSA9IFtdKTtcbiAgICBjb25zdCBvID0gKGkpID0+IHtcbiAgICAgIGNvbnN0IHMgPSB0KGkpLCByID0gdGhpcy5zdWJzY3JpYmVyc1tlXS5pbmRleE9mKG8pO1xuICAgICAgcmV0dXJuIHIgIT09IC0xICYmIHRoaXMuc3Vic2NyaWJlcnNbZV0uc3BsaWNlKHIsIDEpLCBzO1xuICAgIH07XG4gICAgdGhpcy5zdWJzY3JpYmVyc1tlXS5wdXNoKG8pO1xuICB9XG4gIC8qKlxuICAgKiBFbWl0IGNhbGxiYWNrcyB3aXRoIHBhc3NlZCBkYXRhXG4gICAqXG4gICAqIEBwYXJhbSBldmVudE5hbWUgLSBldmVudCBuYW1lXG4gICAqIEBwYXJhbSBkYXRhIC0gc3Vic2NyaWJlcnMgZ2V0IHRoaXMgZGF0YSB3aGVuIHRoZXkgd2VyZSBmaXJlZFxuICAgKi9cbiAgZW1pdChlLCB0KSB7XG4gICAgWCh0aGlzLnN1YnNjcmliZXJzKSB8fCAhdGhpcy5zdWJzY3JpYmVyc1tlXSB8fCB0aGlzLnN1YnNjcmliZXJzW2VdLnJlZHVjZSgobywgaSkgPT4ge1xuICAgICAgY29uc3QgcyA9IGkobyk7XG4gICAgICByZXR1cm4gcyAhPT0gdm9pZCAwID8gcyA6IG87XG4gICAgfSwgdCk7XG4gIH1cbiAgLyoqXG4gICAqIFVuc3Vic2NyaWJlIGNhbGxiYWNrIGZyb20gZXZlbnRcbiAgICpcbiAgICogQHBhcmFtIGV2ZW50TmFtZSAtIGV2ZW50IG5hbWVcbiAgICogQHBhcmFtIGNhbGxiYWNrIC0gZXZlbnQgaGFuZGxlclxuICAgKi9cbiAgb2ZmKGUsIHQpIHtcbiAgICBpZiAodGhpcy5zdWJzY3JpYmVyc1tlXSA9PT0gdm9pZCAwKSB7XG4gICAgICBjb25zb2xlLndhcm4oYEV2ZW50RGlzcGF0Y2hlciAub2ZmKCk6IHRoZXJlIGlzIG5vIHN1YnNjcmliZXJzIGZvciBldmVudCBcIiR7ZS50b1N0cmluZygpfVwiLiBQcm9iYWJseSwgLm9mZigpIGNhbGxlZCBiZWZvcmUgLm9uKClgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChsZXQgbyA9IDA7IG8gPCB0aGlzLnN1YnNjcmliZXJzW2VdLmxlbmd0aDsgbysrKVxuICAgICAgaWYgKHRoaXMuc3Vic2NyaWJlcnNbZV1bb10gPT09IHQpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuc3Vic2NyaWJlcnNbZV1bb107XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICB9XG4gIC8qKlxuICAgKiBEZXN0cm95ZXJcbiAgICogY2xlYXJzIHN1YnNjcmliZXJzIGxpc3RcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWJzY3JpYmVycyA9IHt9O1xuICB9XG59XG5mdW5jdGlvbiBHKG4pIHtcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIHtcbiAgICAvKipcbiAgICAgKiBCbG9jayBpZFxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgaWQoKSB7XG4gICAgICByZXR1cm4gbi5pZDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRvb2wgbmFtZVxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgIHJldHVybiBuLm5hbWU7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUb29sIGNvbmZpZyBwYXNzZWQgb24gRWRpdG9yJ3MgaW5pdGlhbGl6YXRpb25cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtUb29sQ29uZmlnfVxuICAgICAqL1xuICAgIGdldCBjb25maWcoKSB7XG4gICAgICByZXR1cm4gbi5jb25maWc7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiAuY2UtYmxvY2sgZWxlbWVudCwgdGhhdCB3cmFwcyBwbHVnaW4gY29udGVudHNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgICBnZXQgaG9sZGVyKCkge1xuICAgICAgcmV0dXJuIG4uaG9sZGVyO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiBCbG9jayBjb250ZW50IGlzIGVtcHR5XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgaXNFbXB0eSgpIHtcbiAgICAgIHJldHVybiBuLmlzRW1wdHk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIEJsb2NrIGlzIHNlbGVjdGVkIHdpdGggQ3Jvc3MtQmxvY2sgc2VsZWN0aW9uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgc2VsZWN0ZWQoKSB7XG4gICAgICByZXR1cm4gbi5zZWxlY3RlZDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFNldCBCbG9jaydzIHN0cmV0Y2ggc3RhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc3RhdGUg4oCUIHN0YXRlIHRvIHNldFxuICAgICAqL1xuICAgIHNldCBzdHJldGNoZWQodCkge1xuICAgICAgbi5zdHJldGNoZWQgPSB0O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiBCbG9jayBpcyBzdHJldGNoZWRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGdldCBzdHJldGNoZWQoKSB7XG4gICAgICByZXR1cm4gbi5zdHJldGNoZWQ7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIEJsb2NrIGhhcyBpbnB1dHMgdG8gYmUgZm9jdXNlZFxuICAgICAqL1xuICAgIGdldCBmb2N1c2FibGUoKSB7XG4gICAgICByZXR1cm4gbi5mb2N1c2FibGU7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDYWxsIFRvb2wgbWV0aG9kIHdpdGggZXJyb3JzIGhhbmRsZXIgdW5kZXItdGhlLWhvb2RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIC0gbWV0aG9kIHRvIGNhbGxcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW0gLSBvYmplY3Qgd2l0aCBwYXJhbWV0ZXJzXG4gICAgICogQHJldHVybnMge3Vua25vd259XG4gICAgICovXG4gICAgY2FsbCh0LCBvKSB7XG4gICAgICByZXR1cm4gbi5jYWxsKHQsIG8pO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogU2F2ZSBCbG9jayBjb250ZW50XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkfFNhdmVkRGF0YT59XG4gICAgICovXG4gICAgc2F2ZSgpIHtcbiAgICAgIHJldHVybiBuLnNhdmUoKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlIEJsb2NrIGRhdGFcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QmxvY2tUb29sRGF0YX0gZGF0YSAtIGRhdGEgdG8gdmFsaWRhdGVcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn1cbiAgICAgKi9cbiAgICB2YWxpZGF0ZSh0KSB7XG4gICAgICByZXR1cm4gbi52YWxpZGF0ZSh0KTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEFsbG93cyB0byBzYXkgRWRpdG9yIHRoYXQgQmxvY2sgd2FzIGNoYW5nZWQuIFVzZWQgdG8gbWFudWFsbHkgdHJpZ2dlciBFZGl0b3IncyAnb25DaGFuZ2UnIGNhbGxiYWNrXG4gICAgICogQ2FuIGJlIHVzZWZ1bCBmb3IgYmxvY2sgY2hhbmdlcyBpbnZpc2libGUgZm9yIGVkaXRvciBjb3JlLlxuICAgICAqL1xuICAgIGRpc3BhdGNoQ2hhbmdlKCkge1xuICAgICAgbi5kaXNwYXRjaENoYW5nZSgpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVG9vbCBjb3VsZCBzcGVjaWZ5IHNldmVyYWwgZW50cmllcyB0byBiZSBkaXNwbGF5ZWQgYXQgdGhlIFRvb2xib3ggKGZvciBleGFtcGxlLCBcIkhlYWRpbmcgMVwiLCBcIkhlYWRpbmcgMlwiLCBcIkhlYWRpbmcgM1wiKVxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGVudHJ5IHRoYXQgaXMgcmVsYXRlZCB0byB0aGUgQmxvY2sgKGRlcGVuZGVkIG9uIHRoZSBCbG9jayBkYXRhKVxuICAgICAqL1xuICAgIGdldEFjdGl2ZVRvb2xib3hFbnRyeSgpIHtcbiAgICAgIHJldHVybiBuLmdldEFjdGl2ZVRvb2xib3hFbnRyeSgpO1xuICAgIH1cbiAgfSk7XG59XG5jbGFzcyBUZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuYWxsTGlzdGVuZXJzID0gW107XG4gIH1cbiAgLyoqXG4gICAqIEFzc2lnbnMgZXZlbnQgbGlzdGVuZXIgb24gZWxlbWVudCBhbmQgcmV0dXJucyB1bmlxdWUgaWRlbnRpZmllclxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSBlbGVtZW50IC0gRE9NIGVsZW1lbnQgdGhhdCBuZWVkcyB0byBiZSBsaXN0ZW5lZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlIC0gZXZlbnQgdHlwZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIC0gbWV0aG9kIHRoYXQgd2lsbCBiZSBmaXJlZCBvbiBldmVudFxuICAgKiBAcGFyYW0ge2Jvb2xlYW58QWRkRXZlbnRMaXN0ZW5lck9wdGlvbnN9IG9wdGlvbnMgLSB1c2VDYXB0dXJlIG9yIHtjYXB0dXJlLCBwYXNzaXZlLCBvbmNlfVxuICAgKi9cbiAgb24oZSwgdCwgbywgaSA9ICExKSB7XG4gICAgY29uc3QgcyA9IEFvKFwibFwiKSwgciA9IHtcbiAgICAgIGlkOiBzLFxuICAgICAgZWxlbWVudDogZSxcbiAgICAgIGV2ZW50VHlwZTogdCxcbiAgICAgIGhhbmRsZXI6IG8sXG4gICAgICBvcHRpb25zOiBpXG4gICAgfTtcbiAgICBpZiAoIXRoaXMuZmluZE9uZShlLCB0LCBvKSlcbiAgICAgIHJldHVybiB0aGlzLmFsbExpc3RlbmVycy5wdXNoKHIpLCBlLmFkZEV2ZW50TGlzdGVuZXIodCwgbywgaSksIHM7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgZXZlbnQgbGlzdGVuZXIgZnJvbSBlbGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IGVsZW1lbnQgLSBET00gZWxlbWVudCB0aGF0IHdlIHJlbW92aW5nIGxpc3RlbmVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgLSBldmVudCB0eXBlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgLSByZW1vdmUgaGFuZGxlciwgaWYgZWxlbWVudCBsaXN0ZW5zIHNldmVyYWwgaGFuZGxlcnMgb24gdGhlIHNhbWUgZXZlbnQgdHlwZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW58QWRkRXZlbnRMaXN0ZW5lck9wdGlvbnN9IG9wdGlvbnMgLSB1c2VDYXB0dXJlIG9yIHtjYXB0dXJlLCBwYXNzaXZlLCBvbmNlfVxuICAgKi9cbiAgb2ZmKGUsIHQsIG8sIGkpIHtcbiAgICBjb25zdCBzID0gdGhpcy5maW5kQWxsKGUsIHQsIG8pO1xuICAgIHMuZm9yRWFjaCgociwgbCkgPT4ge1xuICAgICAgY29uc3QgYSA9IHRoaXMuYWxsTGlzdGVuZXJzLmluZGV4T2Yoc1tsXSk7XG4gICAgICBhID4gLTEgJiYgKHRoaXMuYWxsTGlzdGVuZXJzLnNwbGljZShhLCAxKSwgci5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoci5ldmVudFR5cGUsIHIuaGFuZGxlciwgci5vcHRpb25zKSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgbGlzdGVuZXIgYnkgaWRcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gbGlzdGVuZXIgaWRlbnRpZmllclxuICAgKi9cbiAgb2ZmQnlJZChlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZmluZEJ5SWQoZSk7XG4gICAgdCAmJiB0LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0LmV2ZW50VHlwZSwgdC5oYW5kbGVyLCB0Lm9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBGaW5kcyBhbmQgcmV0dXJucyBmaXJzdCBsaXN0ZW5lciBieSBwYXNzZWQgcGFyYW1zXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IGVsZW1lbnQgLSBldmVudCB0YXJnZXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtldmVudFR5cGVdIC0gZXZlbnQgdHlwZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaGFuZGxlcl0gLSBldmVudCBoYW5kbGVyXG4gICAqIEByZXR1cm5zIHtMaXN0ZW5lckRhdGF8bnVsbH1cbiAgICovXG4gIGZpbmRPbmUoZSwgdCwgbykge1xuICAgIGNvbnN0IGkgPSB0aGlzLmZpbmRBbGwoZSwgdCwgbyk7XG4gICAgcmV0dXJuIGkubGVuZ3RoID4gMCA/IGlbMF0gOiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gYWxsIHN0b3JlZCBsaXN0ZW5lcnMgYnkgcGFzc2VkIHBhcmFtc1xuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSBlbGVtZW50IC0gZXZlbnQgdGFyZ2V0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgLSBldmVudCB0eXBlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgLSBldmVudCBoYW5kbGVyXG4gICAqIEByZXR1cm5zIHtMaXN0ZW5lckRhdGFbXX1cbiAgICovXG4gIGZpbmRBbGwoZSwgdCwgbykge1xuICAgIGxldCBpO1xuICAgIGNvbnN0IHMgPSBlID8gdGhpcy5maW5kQnlFdmVudFRhcmdldChlKSA6IFtdO1xuICAgIHJldHVybiBlICYmIHQgJiYgbyA/IGkgPSBzLmZpbHRlcigocikgPT4gci5ldmVudFR5cGUgPT09IHQgJiYgci5oYW5kbGVyID09PSBvKSA6IGUgJiYgdCA/IGkgPSBzLmZpbHRlcigocikgPT4gci5ldmVudFR5cGUgPT09IHQpIDogaSA9IHMsIGk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIGxpc3RlbmVyc1xuICAgKi9cbiAgcmVtb3ZlQWxsKCkge1xuICAgIHRoaXMuYWxsTGlzdGVuZXJzLm1hcCgoZSkgPT4ge1xuICAgICAgZS5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZS5ldmVudFR5cGUsIGUuaGFuZGxlciwgZS5vcHRpb25zKTtcbiAgICB9KSwgdGhpcy5hbGxMaXN0ZW5lcnMgPSBbXTtcbiAgfVxuICAvKipcbiAgICogTW9kdWxlIGNsZWFudXAgb24gZGVzdHJ1Y3Rpb25cbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZW1vdmVBbGwoKTtcbiAgfVxuICAvKipcbiAgICogU2VhcmNoIG1ldGhvZDogbG9va3MgZm9yIGxpc3RlbmVyIGJ5IHBhc3NlZCBlbGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IGVsZW1lbnQgLSBzZWFyY2hpbmcgZWxlbWVudFxuICAgKiBAcmV0dXJucyB7QXJyYXl9IGxpc3RlbmVycyB0aGF0IGZvdW5kIG9uIGVsZW1lbnRcbiAgICovXG4gIGZpbmRCeUV2ZW50VGFyZ2V0KGUpIHtcbiAgICByZXR1cm4gdGhpcy5hbGxMaXN0ZW5lcnMuZmlsdGVyKCh0KSA9PiB7XG4gICAgICBpZiAodC5lbGVtZW50ID09PSBlKVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU2VhcmNoIG1ldGhvZDogbG9va3MgZm9yIGxpc3RlbmVyIGJ5IHBhc3NlZCBldmVudCB0eXBlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgLSBldmVudCB0eXBlXG4gICAqIEByZXR1cm5zIHtMaXN0ZW5lckRhdGFbXX0gbGlzdGVuZXJzIHRoYXQgZm91bmQgb24gZWxlbWVudFxuICAgKi9cbiAgZmluZEJ5VHlwZShlKSB7XG4gICAgcmV0dXJuIHRoaXMuYWxsTGlzdGVuZXJzLmZpbHRlcigodCkgPT4ge1xuICAgICAgaWYgKHQuZXZlbnRUeXBlID09PSBlKVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU2VhcmNoIG1ldGhvZDogbG9va3MgZm9yIGxpc3RlbmVyIGJ5IHBhc3NlZCBoYW5kbGVyXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgLSBldmVudCBoYW5kbGVyXG4gICAqIEByZXR1cm5zIHtMaXN0ZW5lckRhdGFbXX0gbGlzdGVuZXJzIHRoYXQgZm91bmQgb24gZWxlbWVudFxuICAgKi9cbiAgZmluZEJ5SGFuZGxlcihlKSB7XG4gICAgcmV0dXJuIHRoaXMuYWxsTGlzdGVuZXJzLmZpbHRlcigodCkgPT4ge1xuICAgICAgaWYgKHQuaGFuZGxlciA9PT0gZSlcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgbGlzdGVuZXIgZGF0YSBmb3VuZCBieSBpZFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgLSBsaXN0ZW5lciBpZGVudGlmaWVyXG4gICAqIEByZXR1cm5zIHtMaXN0ZW5lckRhdGF9XG4gICAqL1xuICBmaW5kQnlJZChlKSB7XG4gICAgcmV0dXJuIHRoaXMuYWxsTGlzdGVuZXJzLmZpbmQoKHQpID0+IHQuaWQgPT09IGUpO1xuICB9XG59XG5jbGFzcyB5IHtcbiAgLyoqXG4gICAqIEBjbGFzc1xuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE1vZHVsZSBvcHRpb25zXG4gICAqIEBwYXJhbSBvcHRpb25zLmNvbmZpZyAtIE1vZHVsZSBjb25maWdcbiAgICogQHBhcmFtIG9wdGlvbnMuZXZlbnRzRGlzcGF0Y2hlciAtIENvbW1vbiBldmVudCBidXNcbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgY29uZmlnOiBlLCBldmVudHNEaXNwYXRjaGVyOiB0IH0pIHtcbiAgICBpZiAodGhpcy5ub2RlcyA9IHt9LCB0aGlzLmxpc3RlbmVycyA9IG5ldyBUZSgpLCB0aGlzLnJlYWRPbmx5TXV0YWJsZUxpc3RlbmVycyA9IHtcbiAgICAgIC8qKlxuICAgICAgICogQXNzaWducyBldmVudCBsaXN0ZW5lciBvbiBET00gZWxlbWVudCBhbmQgcHVzaGVzIGludG8gc3BlY2lhbCBhcnJheSB0aGF0IG1pZ2h0IGJlIHJlbW92ZWRcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSBlbGVtZW50IC0gRE9NIEVsZW1lbnRcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgLSBFdmVudCBuYW1lXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIC0gRXZlbnQgaGFuZGxlclxuICAgICAgICogQHBhcmFtIHtib29sZWFufEFkZEV2ZW50TGlzdGVuZXJPcHRpb25zfSBvcHRpb25zIC0gTGlzdGVuaW5nIG9wdGlvbnNcbiAgICAgICAqL1xuICAgICAgb246IChvLCBpLCBzLCByID0gITEpID0+IHtcbiAgICAgICAgdGhpcy5tdXRhYmxlTGlzdGVuZXJJZHMucHVzaChcbiAgICAgICAgICB0aGlzLmxpc3RlbmVycy5vbihvLCBpLCBzLCByKVxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogQ2xlYXJzIGFsbCBtdXRhYmxlIGxpc3RlbmVyc1xuICAgICAgICovXG4gICAgICBjbGVhckFsbDogKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IG8gb2YgdGhpcy5tdXRhYmxlTGlzdGVuZXJJZHMpXG4gICAgICAgICAgdGhpcy5saXN0ZW5lcnMub2ZmQnlJZChvKTtcbiAgICAgICAgdGhpcy5tdXRhYmxlTGlzdGVuZXJJZHMgPSBbXTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLm11dGFibGVMaXN0ZW5lcklkcyA9IFtdLCBuZXcudGFyZ2V0ID09PSB5KVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNvbnN0cnVjdG9ycyBmb3IgYWJzdHJhY3QgY2xhc3MgTW9kdWxlIGFyZSBub3QgYWxsb3dlZC5cIik7XG4gICAgdGhpcy5jb25maWcgPSBlLCB0aGlzLmV2ZW50c0Rpc3BhdGNoZXIgPSB0O1xuICB9XG4gIC8qKlxuICAgKiBFZGl0b3IgbW9kdWxlcyBzZXR0ZXJcbiAgICpcbiAgICogQHBhcmFtIHtFZGl0b3JNb2R1bGVzfSBFZGl0b3IgLSBFZGl0b3IncyBNb2R1bGVzXG4gICAqL1xuICBzZXQgc3RhdGUoZSkge1xuICAgIHRoaXMuRWRpdG9yID0gZTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIG1lbW9yaXplZCBub2Rlc1xuICAgKi9cbiAgcmVtb3ZlQWxsTm9kZXMoKSB7XG4gICAgZm9yIChjb25zdCBlIGluIHRoaXMubm9kZXMpIHtcbiAgICAgIGNvbnN0IHQgPSB0aGlzLm5vZGVzW2VdO1xuICAgICAgdCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIHQucmVtb3ZlKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgY3VycmVudCBkaXJlY3Rpb24gaXMgUlRMIChSaWdodC1Uby1MZWZ0KVxuICAgKi9cbiAgZ2V0IGlzUnRsKCkge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5pMThuLmRpcmVjdGlvbiA9PT0gXCJydGxcIjtcbiAgfVxufVxuY2xhc3MgYiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaW5zdGFuY2UgPSBudWxsLCB0aGlzLnNlbGVjdGlvbiA9IG51bGwsIHRoaXMuc2F2ZWRTZWxlY3Rpb25SYW5nZSA9IG51bGwsIHRoaXMuaXNGYWtlQmFja2dyb3VuZEVuYWJsZWQgPSAhMSwgdGhpcy5jb21tYW5kQmFja2dyb3VuZCA9IFwiYmFja0NvbG9yXCIsIHRoaXMuY29tbWFuZFJlbW92ZUZvcm1hdCA9IFwicmVtb3ZlRm9ybWF0XCI7XG4gIH1cbiAgLyoqXG4gICAqIEVkaXRvciBzdHlsZXNcbiAgICpcbiAgICogQHJldHVybnMge3tlZGl0b3JXcmFwcGVyOiBzdHJpbmcsIGVkaXRvclpvbmU6IHN0cmluZ319XG4gICAqL1xuICBzdGF0aWMgZ2V0IENTUygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZWRpdG9yV3JhcHBlcjogXCJjb2RleC1lZGl0b3JcIixcbiAgICAgIGVkaXRvclpvbmU6IFwiY29kZXgtZWRpdG9yX19yZWRhY3RvclwiXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBzZWxlY3RlZCBhbmNob3JcbiAgICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL3J1L2RvY3MvV2ViL0FQSS9TZWxlY3Rpb24vYW5jaG9yTm9kZX1cbiAgICpcbiAgICogQHJldHVybnMge05vZGV8bnVsbH1cbiAgICovXG4gIHN0YXRpYyBnZXQgYW5jaG9yTm9kZSgpIHtcbiAgICBjb25zdCBlID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgIHJldHVybiBlID8gZS5hbmNob3JOb2RlIDogbnVsbDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBzZWxlY3RlZCBhbmNob3IgZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJucyB7RWxlbWVudHxudWxsfVxuICAgKi9cbiAgc3RhdGljIGdldCBhbmNob3JFbGVtZW50KCkge1xuICAgIGNvbnN0IGUgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCFlKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgdCA9IGUuYW5jaG9yTm9kZTtcbiAgICByZXR1cm4gdCA/IGQuaXNFbGVtZW50KHQpID8gdCA6IHQucGFyZW50RWxlbWVudCA6IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgc2VsZWN0aW9uIG9mZnNldCBhY2NvcmRpbmcgdG8gdGhlIGFuY2hvciBub2RlXG4gICAqIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9ydS9kb2NzL1dlYi9BUEkvU2VsZWN0aW9uL2FuY2hvck9mZnNldH1cbiAgICpcbiAgICogQHJldHVybnMge251bWJlcnxudWxsfVxuICAgKi9cbiAgc3RhdGljIGdldCBhbmNob3JPZmZzZXQoKSB7XG4gICAgY29uc3QgZSA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICByZXR1cm4gZSA/IGUuYW5jaG9yT2Zmc2V0IDogbnVsbDtcbiAgfVxuICAvKipcbiAgICogSXMgY3VycmVudCBzZWxlY3Rpb24gcmFuZ2UgY29sbGFwc2VkXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufG51bGx9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGlzQ29sbGFwc2VkKCkge1xuICAgIGNvbnN0IGUgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgcmV0dXJuIGUgPyBlLmlzQ29sbGFwc2VkIDogbnVsbDtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgY3VycmVudCBzZWxlY3Rpb24gaWYgaXQgaXMgYXQgRWRpdG9yJ3Mgem9uZVxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBnZXQgaXNBdEVkaXRvcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1NlbGVjdGlvbkF0RWRpdG9yKGIuZ2V0KCkpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBwYXNzZWQgc2VsZWN0aW9uIGlzIGF0IEVkaXRvcidzIHpvbmVcbiAgICpcbiAgICogQHBhcmFtIHNlbGVjdGlvbiAtIFNlbGVjdGlvbiBvYmplY3QgdG8gY2hlY2tcbiAgICovXG4gIHN0YXRpYyBpc1NlbGVjdGlvbkF0RWRpdG9yKGUpIHtcbiAgICBpZiAoIWUpXG4gICAgICByZXR1cm4gITE7XG4gICAgbGV0IHQgPSBlLmFuY2hvck5vZGUgfHwgZS5mb2N1c05vZGU7XG4gICAgdCAmJiB0Lm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSAmJiAodCA9IHQucGFyZW50Tm9kZSk7XG4gICAgbGV0IG8gPSBudWxsO1xuICAgIHJldHVybiB0ICYmIHQgaW5zdGFuY2VvZiBFbGVtZW50ICYmIChvID0gdC5jbG9zZXN0KGAuJHtiLkNTUy5lZGl0b3Jab25lfWApKSwgbyA/IG8ubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFIDogITE7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIHBhc3NlZCByYW5nZSBhdCBFZGl0b3Igem9uZVxuICAgKlxuICAgKiBAcGFyYW0gcmFuZ2UgLSByYW5nZSB0byBjaGVja1xuICAgKi9cbiAgc3RhdGljIGlzUmFuZ2VBdEVkaXRvcihlKSB7XG4gICAgaWYgKCFlKVxuICAgICAgcmV0dXJuO1xuICAgIGxldCB0ID0gZS5zdGFydENvbnRhaW5lcjtcbiAgICB0ICYmIHQubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFICYmICh0ID0gdC5wYXJlbnROb2RlKTtcbiAgICBsZXQgbyA9IG51bGw7XG4gICAgcmV0dXJuIHQgJiYgdCBpbnN0YW5jZW9mIEVsZW1lbnQgJiYgKG8gPSB0LmNsb3Nlc3QoYC4ke2IuQ1NTLmVkaXRvclpvbmV9YCkpLCBvID8gby5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUgOiAhMTtcbiAgfVxuICAvKipcbiAgICogTWV0aG9kcyByZXR1cm4gYm9vbGVhbiB0aGF0IHRydWUgaWYgc2VsZWN0aW9uIGV4aXN0cyBvbiB0aGUgcGFnZVxuICAgKi9cbiAgc3RhdGljIGdldCBpc1NlbGVjdGlvbkV4aXN0cygpIHtcbiAgICByZXR1cm4gISFiLmdldCgpLmFuY2hvck5vZGU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBmaXJzdCByYW5nZVxuICAgKlxuICAgKiBAcmV0dXJucyB7UmFuZ2V8bnVsbH1cbiAgICovXG4gIHN0YXRpYyBnZXQgcmFuZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UmFuZ2VGcm9tU2VsZWN0aW9uKHRoaXMuZ2V0KCkpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHJhbmdlIGZyb20gcGFzc2VkIFNlbGVjdGlvbiBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIHNlbGVjdGlvbiAtIFNlbGVjdGlvbiBvYmplY3QgdG8gZ2V0IFJhbmdlIGZyb21cbiAgICovXG4gIHN0YXRpYyBnZXRSYW5nZUZyb21TZWxlY3Rpb24oZSkge1xuICAgIHJldHVybiBlICYmIGUucmFuZ2VDb3VudCA/IGUuZ2V0UmFuZ2VBdCgwKSA6IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgcG9zaXRpb24gYW5kIHNpemUgb2Ygc2VsZWN0ZWQgdGV4dFxuICAgKlxuICAgKiBAcmV0dXJucyB7RE9NUmVjdCB8IENsaWVudFJlY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IHJlY3QoKSB7XG4gICAgbGV0IGUgPSBkb2N1bWVudC5zZWxlY3Rpb24sIHQsIG8gPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwXG4gICAgfTtcbiAgICBpZiAoZSAmJiBlLnR5cGUgIT09IFwiQ29udHJvbFwiKVxuICAgICAgcmV0dXJuIGUgPSBlLCB0ID0gZS5jcmVhdGVSYW5nZSgpLCBvLnggPSB0LmJvdW5kaW5nTGVmdCwgby55ID0gdC5ib3VuZGluZ1RvcCwgby53aWR0aCA9IHQuYm91bmRpbmdXaWR0aCwgby5oZWlnaHQgPSB0LmJvdW5kaW5nSGVpZ2h0LCBvO1xuICAgIGlmICghd2luZG93LmdldFNlbGVjdGlvbilcbiAgICAgIHJldHVybiBJKFwiTWV0aG9kIHdpbmRvdy5nZXRTZWxlY3Rpb24gaXMgbm90IHN1cHBvcnRlZFwiLCBcIndhcm5cIiksIG87XG4gICAgaWYgKGUgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCksIGUucmFuZ2VDb3VudCA9PT0gbnVsbCB8fCBpc05hTihlLnJhbmdlQ291bnQpKVxuICAgICAgcmV0dXJuIEkoXCJNZXRob2QgU2VsZWN0aW9uVXRpbHMucmFuZ2VDb3VudCBpcyBub3Qgc3VwcG9ydGVkXCIsIFwid2FyblwiKSwgbztcbiAgICBpZiAoZS5yYW5nZUNvdW50ID09PSAwKVxuICAgICAgcmV0dXJuIG87XG4gICAgaWYgKHQgPSBlLmdldFJhbmdlQXQoMCkuY2xvbmVSYW5nZSgpLCB0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCAmJiAobyA9IHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpLCBvLnggPT09IDAgJiYgby55ID09PSAwKSB7XG4gICAgICBjb25zdCBpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICBpZiAoaS5nZXRCb3VuZGluZ0NsaWVudFJlY3QpIHtcbiAgICAgICAgaS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIuKAi1wiKSksIHQuaW5zZXJ0Tm9kZShpKSwgbyA9IGkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnN0IHMgPSBpLnBhcmVudE5vZGU7XG4gICAgICAgIHMucmVtb3ZlQ2hpbGQoaSksIHMubm9ybWFsaXplKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHNlbGVjdGVkIHRleHQgYXMgU3RyaW5nXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZ2V0IHRleHQoKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5nZXRTZWxlY3Rpb24gPyB3aW5kb3cuZ2V0U2VsZWN0aW9uKCkudG9TdHJpbmcoKSA6IFwiXCI7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgd2luZG93IFNlbGVjdGlvblV0aWxzXG4gICAqIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9ydS9kb2NzL1dlYi9BUEkvV2luZG93L2dldFNlbGVjdGlvbn1cbiAgICpcbiAgICogQHJldHVybnMge1NlbGVjdGlvbn1cbiAgICovXG4gIHN0YXRpYyBnZXQoKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgfVxuICAvKipcbiAgICogU2V0IGZvY3VzIHRvIGNvbnRlbnRlZGl0YWJsZSBvciBuYXRpdmUgaW5wdXQgZWxlbWVudFxuICAgKlxuICAgKiBAcGFyYW0gZWxlbWVudCAtIGVsZW1lbnQgd2hlcmUgdG8gc2V0IGZvY3VzXG4gICAqIEBwYXJhbSBvZmZzZXQgLSBvZmZzZXQgb2YgY3Vyc29yXG4gICAqL1xuICBzdGF0aWMgc2V0Q3Vyc29yKGUsIHQgPSAwKSB7XG4gICAgY29uc3QgbyA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCksIGkgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgcmV0dXJuIGQuaXNOYXRpdmVJbnB1dChlKSA/IGQuY2FuU2V0Q2FyZXQoZSkgPyAoZS5mb2N1cygpLCBlLnNlbGVjdGlvblN0YXJ0ID0gZS5zZWxlY3Rpb25FbmQgPSB0LCBlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKSA6IHZvaWQgMCA6IChvLnNldFN0YXJ0KGUsIHQpLCBvLnNldEVuZChlLCB0KSwgaS5yZW1vdmVBbGxSYW5nZXMoKSwgaS5hZGRSYW5nZShvKSwgby5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIGN1cnJlbnQgcmFuZ2UgZXhpc3RzIGFuZCBiZWxvbmdzIHRvIGNvbnRhaW5lclxuICAgKlxuICAgKiBAcGFyYW0gY29udGFpbmVyIC0gd2hlcmUgcmFuZ2Ugc2hvdWxkIGJlXG4gICAqL1xuICBzdGF0aWMgaXNSYW5nZUluc2lkZUNvbnRhaW5lcihlKSB7XG4gICAgY29uc3QgdCA9IGIucmFuZ2U7XG4gICAgcmV0dXJuIHQgPT09IG51bGwgPyAhMSA6IGUuY29udGFpbnModC5zdGFydENvbnRhaW5lcik7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgZmFrZSBjdXJzb3IgdG8gdGhlIGN1cnJlbnQgcmFuZ2VcbiAgICovXG4gIHN0YXRpYyBhZGRGYWtlQ3Vyc29yKCkge1xuICAgIGNvbnN0IGUgPSBiLnJhbmdlO1xuICAgIGlmIChlID09PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHQgPSBkLm1ha2UoXCJzcGFuXCIsIFwiY29kZXgtZWRpdG9yX19mYWtlLWN1cnNvclwiKTtcbiAgICB0LmRhdGFzZXQubXV0YXRpb25GcmVlID0gXCJ0cnVlXCIsIGUuY29sbGFwc2UoKSwgZS5pbnNlcnROb2RlKHQpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBwYXNzZWQgZWxlbWVudCBjb250YWlucyBhIGZha2UgY3Vyc29yXG4gICAqXG4gICAqIEBwYXJhbSBlbCAtIHdoZXJlIHRvIGNoZWNrXG4gICAqL1xuICBzdGF0aWMgaXNGYWtlQ3Vyc29ySW5zaWRlQ29udGFpbmVyKGUpIHtcbiAgICByZXR1cm4gZC5maW5kKGUsIFwiLmNvZGV4LWVkaXRvcl9fZmFrZS1jdXJzb3JcIikgIT09IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgZmFrZSBjdXJzb3IgZnJvbSBhIGNvbnRhaW5lclxuICAgKlxuICAgKiBAcGFyYW0gY29udGFpbmVyIC0gY29udGFpbmVyIHRvIGxvb2sgZm9yXG4gICAqL1xuICBzdGF0aWMgcmVtb3ZlRmFrZUN1cnNvcihlID0gZG9jdW1lbnQuYm9keSkge1xuICAgIGNvbnN0IHQgPSBkLmZpbmQoZSwgXCIuY29kZXgtZWRpdG9yX19mYWtlLWN1cnNvclwiKTtcbiAgICB0ICYmIHQucmVtb3ZlKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgZmFrZSBiYWNrZ3JvdW5kXG4gICAqL1xuICByZW1vdmVGYWtlQmFja2dyb3VuZCgpIHtcbiAgICB0aGlzLmlzRmFrZUJhY2tncm91bmRFbmFibGVkICYmICh0aGlzLmlzRmFrZUJhY2tncm91bmRFbmFibGVkID0gITEsIGRvY3VtZW50LmV4ZWNDb21tYW5kKHRoaXMuY29tbWFuZFJlbW92ZUZvcm1hdCkpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIGZha2UgYmFja2dyb3VuZFxuICAgKi9cbiAgc2V0RmFrZUJhY2tncm91bmQoKSB7XG4gICAgZG9jdW1lbnQuZXhlY0NvbW1hbmQodGhpcy5jb21tYW5kQmFja2dyb3VuZCwgITEsIFwiI2E4ZDZmZlwiKSwgdGhpcy5pc0Zha2VCYWNrZ3JvdW5kRW5hYmxlZCA9ICEwO1xuICB9XG4gIC8qKlxuICAgKiBTYXZlIFNlbGVjdGlvblV0aWxzJ3MgcmFuZ2VcbiAgICovXG4gIHNhdmUoKSB7XG4gICAgdGhpcy5zYXZlZFNlbGVjdGlvblJhbmdlID0gYi5yYW5nZTtcbiAgfVxuICAvKipcbiAgICogUmVzdG9yZSBzYXZlZCBTZWxlY3Rpb25VdGlscydzIHJhbmdlXG4gICAqL1xuICByZXN0b3JlKCkge1xuICAgIGlmICghdGhpcy5zYXZlZFNlbGVjdGlvblJhbmdlKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGUgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgZS5yZW1vdmVBbGxSYW5nZXMoKSwgZS5hZGRSYW5nZSh0aGlzLnNhdmVkU2VsZWN0aW9uUmFuZ2UpO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhcnMgc2F2ZWQgc2VsZWN0aW9uXG4gICAqL1xuICBjbGVhclNhdmVkKCkge1xuICAgIHRoaXMuc2F2ZWRTZWxlY3Rpb25SYW5nZSA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIENvbGxhcHNlIGN1cnJlbnQgc2VsZWN0aW9uXG4gICAqL1xuICBjb2xsYXBzZVRvRW5kKCkge1xuICAgIGNvbnN0IGUgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCksIHQgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgIHQuc2VsZWN0Tm9kZUNvbnRlbnRzKGUuZm9jdXNOb2RlKSwgdC5jb2xsYXBzZSghMSksIGUucmVtb3ZlQWxsUmFuZ2VzKCksIGUuYWRkUmFuZ2UodCk7XG4gIH1cbiAgLyoqXG4gICAqIExvb2tzIGFoZWFkIHRvIGZpbmQgcGFzc2VkIHRhZyBmcm9tIGN1cnJlbnQgc2VsZWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gdGFnTmFtZSAgICAgICAtIHRhZyB0byBmb3VuZFxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IFtjbGFzc05hbWVdICAgLSB0YWcncyBjbGFzcyBuYW1lXG4gICAqIEBwYXJhbSAge251bWJlcn0gW3NlYXJjaERlcHRoXSAtIGNvdW50IG9mIHRhZ3MgdGhhdCBjYW4gYmUgaW5jbHVkZWQuIEZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudHxudWxsfVxuICAgKi9cbiAgZmluZFBhcmVudFRhZyhlLCB0LCBvID0gMTApIHtcbiAgICBjb25zdCBpID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgIGxldCBzID0gbnVsbDtcbiAgICByZXR1cm4gIWkgfHwgIWkuYW5jaG9yTm9kZSB8fCAhaS5mb2N1c05vZGUgPyBudWxsIDogKFtcbiAgICAgIC8qKiB0aGUgTm9kZSBpbiB3aGljaCB0aGUgc2VsZWN0aW9uIGJlZ2lucyAqL1xuICAgICAgaS5hbmNob3JOb2RlLFxuICAgICAgLyoqIHRoZSBOb2RlIGluIHdoaWNoIHRoZSBzZWxlY3Rpb24gZW5kcyAqL1xuICAgICAgaS5mb2N1c05vZGVcbiAgICBdLmZvckVhY2goKGwpID0+IHtcbiAgICAgIGxldCBhID0gbztcbiAgICAgIGZvciAoOyBhID4gMCAmJiBsLnBhcmVudE5vZGUgJiYgIShsLnRhZ05hbWUgPT09IGUgJiYgKHMgPSBsLCB0ICYmIGwuY2xhc3NMaXN0ICYmICFsLmNsYXNzTGlzdC5jb250YWlucyh0KSAmJiAocyA9IG51bGwpLCBzKSk7IClcbiAgICAgICAgbCA9IGwucGFyZW50Tm9kZSwgYS0tO1xuICAgIH0pLCBzKTtcbiAgfVxuICAvKipcbiAgICogRXhwYW5kcyBzZWxlY3Rpb24gcmFuZ2UgdG8gdGhlIHBhc3NlZCBwYXJlbnQgbm9kZVxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gZWxlbWVudCB3aGljaCBjb250ZW50cyBzaG91bGQgYmUgc2VsZWN0ZWRcbiAgICovXG4gIGV4cGFuZFRvVGFnKGUpIHtcbiAgICBjb25zdCB0ID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgIHQucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgY29uc3QgbyA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgby5zZWxlY3ROb2RlQ29udGVudHMoZSksIHQuYWRkUmFuZ2Uobyk7XG4gIH1cbn1cbmZ1bmN0aW9uIEZvKG4sIGUpIHtcbiAgY29uc3QgeyB0eXBlOiB0LCB0YXJnZXQ6IG8sIGFkZGVkTm9kZXM6IGksIHJlbW92ZWROb2RlczogcyB9ID0gbjtcbiAgcmV0dXJuIG4udHlwZSA9PT0gXCJhdHRyaWJ1dGVzXCIgJiYgbi5hdHRyaWJ1dGVOYW1lID09PSBcImRhdGEtZW1wdHlcIiA/ICExIDogISEoZS5jb250YWlucyhvKSB8fCB0ID09PSBcImNoaWxkTGlzdFwiICYmIChBcnJheS5mcm9tKGkpLnNvbWUoKGEpID0+IGEgPT09IGUpIHx8IEFycmF5LmZyb20ocykuc29tZSgoYSkgPT4gYSA9PT0gZSkpKTtcbn1cbmNvbnN0IEplID0gXCJyZWRhY3RvciBkb20gY2hhbmdlZFwiLCBQdCA9IFwiYmxvY2sgY2hhbmdlZFwiLCBEdCA9IFwiZmFrZSBjdXJzb3IgaXMgYWJvdXQgdG8gYmUgdG9nZ2xlZFwiLCBSdCA9IFwiZmFrZSBjdXJzb3IgaGF2ZSBiZWVuIHNldFwiLCB4ZSA9IFwiZWRpdG9yIG1vYmlsZSBsYXlvdXQgdG9nZ2xlZFwiO1xuZnVuY3Rpb24gRnQobiwgZSkge1xuICBpZiAoIW4uY29udmVyc2lvbkNvbmZpZylcbiAgICByZXR1cm4gITE7XG4gIGNvbnN0IHQgPSBuLmNvbnZlcnNpb25Db25maWdbZV07XG4gIHJldHVybiBPKHQpIHx8IFEodCk7XG59XG5mdW5jdGlvbiBMZShuLCBlKSB7XG4gIHJldHVybiBGdChuLnRvb2wsIGUpO1xufVxuZnVuY3Rpb24gSHQobiwgZSkge1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMobikuc29tZSgoW3QsIG9dKSA9PiBlW3RdICYmIE9vKGVbdF0sIG8pKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHp0KG4sIGUpIHtcbiAgY29uc3QgbyA9IChhd2FpdCBuLnNhdmUoKSkuZGF0YTtcbiAgcmV0dXJuIGUucmVkdWNlKChpLCBzKSA9PiB7XG4gICAgaWYgKCFGdChzLCBcImltcG9ydFwiKSlcbiAgICAgIHJldHVybiBpO1xuICAgIGNvbnN0IHIgPSBzLnRvb2xib3guZmlsdGVyKChsKSA9PiB7XG4gICAgICBpZiAoWChsKSB8fCAhbC5pY29uKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBpZiAobC5kYXRhICE9PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKEh0KGwuZGF0YSwgbykpXG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgfSBlbHNlIGlmIChzLm5hbWUgPT09IG4ubmFtZSlcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgcmV0dXJuICEwO1xuICAgIH0pO1xuICAgIHJldHVybiBpLnB1c2goe1xuICAgICAgLi4ucyxcbiAgICAgIHRvb2xib3g6IHJcbiAgICB9KSwgaTtcbiAgfSwgW10pO1xufVxuZnVuY3Rpb24gdnQobiwgZSkge1xuICByZXR1cm4gbi5tZXJnZWFibGUgPyBuLm5hbWUgPT09IGUubmFtZSA/ICEwIDogTGUoZSwgXCJleHBvcnRcIikgJiYgTGUobiwgXCJpbXBvcnRcIikgOiAhMTtcbn1cbmZ1bmN0aW9uIEhvKG4sIGUpIHtcbiAgY29uc3QgdCA9IGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUuZXhwb3J0O1xuICByZXR1cm4gTyh0KSA/IHQobikgOiBRKHQpID8gblt0XSA6ICh0ICE9PSB2b2lkIDAgJiYgSShcIkNvbnZlcnNpb24gwqtleHBvcnTCuyBwcm9wZXJ0eSBtdXN0IGJlIGEgc3RyaW5nIG9yIGZ1bmN0aW9uLiBTdHJpbmcgbWVhbnMga2V5IG9mIHNhdmVkIGRhdGEgb2JqZWN0IHRvIGV4cG9ydC4gRnVuY3Rpb24gc2hvdWxkIGV4cG9ydCBwcm9jZXNzZWQgc3RyaW5nIHRvIGV4cG9ydC5cIiksIFwiXCIpO1xufVxuZnVuY3Rpb24gd3QobiwgZSkge1xuICBjb25zdCB0ID0gZSA9PSBudWxsID8gdm9pZCAwIDogZS5pbXBvcnQ7XG4gIHJldHVybiBPKHQpID8gdChuKSA6IFEodCkgPyB7XG4gICAgW3RdOiBuXG4gIH0gOiAodCAhPT0gdm9pZCAwICYmIEkoXCJDb252ZXJzaW9uIMKraW1wb3J0wrsgcHJvcGVydHkgbXVzdCBiZSBhIHN0cmluZyBvciBmdW5jdGlvbi4gU3RyaW5nIG1lYW5zIGtleSBvZiB0b29sIGRhdGEgdG8gaW1wb3J0LiBGdW5jdGlvbiBhY2NlcHRzIGEgaW1wb3J0ZWQgc3RyaW5nIGFuZCByZXR1cm4gY29tcG9zZWQgdG9vbCBkYXRhLlwiKSwge30pO1xufVxuY29uc3QgVXQgPSBjbGFzcyBrZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50W119IG5vZGVMaXN0IOKAlCB0aGUgbGlzdCBvZiBpdGVyYWJsZSBIVE1MLWl0ZW1zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmb2N1c2VkQ3NzQ2xhc3MgLSB1c2VyLXByb3ZpZGVkIENTUy1jbGFzcyB0aGF0IHdpbGwgYmUgc2V0IGluIGZsaXBwaW5nIHByb2Nlc3NcbiAgICovXG4gIGNvbnN0cnVjdG9yKGUsIHQpIHtcbiAgICB0aGlzLmN1cnNvciA9IC0xLCB0aGlzLml0ZW1zID0gW10sIHRoaXMuaXRlbXMgPSBlIHx8IFtdLCB0aGlzLmZvY3VzZWRDc3NDbGFzcyA9IHQ7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgRm9jdXNlZCBidXR0b24gTm9kZVxuICAgKlxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICBnZXQgY3VycmVudEl0ZW0oKSB7XG4gICAgcmV0dXJuIHRoaXMuY3Vyc29yID09PSAtMSA/IG51bGwgOiB0aGlzLml0ZW1zW3RoaXMuY3Vyc29yXTtcbiAgfVxuICAvKipcbiAgICogU2V0cyBjdXJzb3IgdG8gc3BlY2lmaWVkIHBvc2l0aW9uXG4gICAqXG4gICAqIEBwYXJhbSBjdXJzb3JQb3NpdGlvbiAtIG5ldyBjdXJzb3IgcG9zaXRpb25cbiAgICovXG4gIHNldEN1cnNvcihlKSB7XG4gICAgZSA8IHRoaXMuaXRlbXMubGVuZ3RoICYmIGUgPj0gLTEgJiYgKHRoaXMuZHJvcEN1cnNvcigpLCB0aGlzLmN1cnNvciA9IGUsIHRoaXMuaXRlbXNbdGhpcy5jdXJzb3JdLmNsYXNzTGlzdC5hZGQodGhpcy5mb2N1c2VkQ3NzQ2xhc3MpKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyBpdGVtcy4gQ2FuIGJlIHVzZWQgd2hlbiBpdGVyYWJsZSBpdGVtcyBjaGFuZ2VkIGR5bmFtaWNhbGx5XG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnRbXX0gbm9kZUxpc3QgLSBub2RlcyB0byBpdGVyYXRlXG4gICAqL1xuICBzZXRJdGVtcyhlKSB7XG4gICAgdGhpcy5pdGVtcyA9IGU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgY3Vyc29yIG5leHQgdG8gdGhlIGN1cnJlbnRcbiAgICovXG4gIG5leHQoKSB7XG4gICAgdGhpcy5jdXJzb3IgPSB0aGlzLmxlYWZOb2Rlc0FuZFJldHVybkluZGV4KGtlLmRpcmVjdGlvbnMuUklHSFQpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIGN1cnNvciBiZWZvcmUgY3VycmVudFxuICAgKi9cbiAgcHJldmlvdXMoKSB7XG4gICAgdGhpcy5jdXJzb3IgPSB0aGlzLmxlYWZOb2Rlc0FuZFJldHVybkluZGV4KGtlLmRpcmVjdGlvbnMuTEVGVCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgY3Vyc29yIHRvIHRoZSBkZWZhdWx0IHBvc2l0aW9uIGFuZCByZW1vdmVzIENTUy1jbGFzcyBmcm9tIHByZXZpb3VzbHkgZm9jdXNlZCBpdGVtXG4gICAqL1xuICBkcm9wQ3Vyc29yKCkge1xuICAgIHRoaXMuY3Vyc29yICE9PSAtMSAmJiAodGhpcy5pdGVtc1t0aGlzLmN1cnNvcl0uY2xhc3NMaXN0LnJlbW92ZSh0aGlzLmZvY3VzZWRDc3NDbGFzcyksIHRoaXMuY3Vyc29yID0gLTEpO1xuICB9XG4gIC8qKlxuICAgKiBMZWFmcyBub2RlcyBpbnNpZGUgdGhlIHRhcmdldCBsaXN0IGZyb20gYWN0aXZlIGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGRpcmVjdGlvbiAtIGxlYWYgZGlyZWN0aW9uLiBDYW4gYmUgJ2xlZnQnIG9yICdyaWdodCdcbiAgICogQHJldHVybnMge251bWJlcn0gaW5kZXggb2YgZm9jdXNlZCBub2RlXG4gICAqL1xuICBsZWFmTm9kZXNBbmRSZXR1cm5JbmRleChlKSB7XG4gICAgaWYgKHRoaXMuaXRlbXMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIHRoaXMuY3Vyc29yO1xuICAgIGxldCB0ID0gdGhpcy5jdXJzb3I7XG4gICAgcmV0dXJuIHQgPT09IC0xID8gdCA9IGUgPT09IGtlLmRpcmVjdGlvbnMuUklHSFQgPyAtMSA6IDAgOiB0aGlzLml0ZW1zW3RdLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5mb2N1c2VkQ3NzQ2xhc3MpLCBlID09PSBrZS5kaXJlY3Rpb25zLlJJR0hUID8gdCA9ICh0ICsgMSkgJSB0aGlzLml0ZW1zLmxlbmd0aCA6IHQgPSAodGhpcy5pdGVtcy5sZW5ndGggKyB0IC0gMSkgJSB0aGlzLml0ZW1zLmxlbmd0aCwgZC5jYW5TZXRDYXJldCh0aGlzLml0ZW1zW3RdKSAmJiBBZSgoKSA9PiBiLnNldEN1cnNvcih0aGlzLml0ZW1zW3RdKSwgNTApKCksIHRoaXMuaXRlbXNbdF0uY2xhc3NMaXN0LmFkZCh0aGlzLmZvY3VzZWRDc3NDbGFzcyksIHQ7XG4gIH1cbn07XG5VdC5kaXJlY3Rpb25zID0ge1xuICBSSUdIVDogXCJyaWdodFwiLFxuICBMRUZUOiBcImxlZnRcIlxufTtcbmxldCBnZSA9IFV0O1xuY2xhc3MgcmUge1xuICAvKipcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBkaWZmZXJlbnQgY29uc3RydWN0aW5nIHNldHRpbmdzXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy5pdGVyYXRvciA9IG51bGwsIHRoaXMuYWN0aXZhdGVkID0gITEsIHRoaXMuZmxpcENhbGxiYWNrcyA9IFtdLCB0aGlzLm9uS2V5RG93biA9ICh0KSA9PiB7XG4gICAgICBpZiAodGhpcy5pc0V2ZW50UmVhZHlGb3JIYW5kbGluZyh0KSlcbiAgICAgICAgc3dpdGNoIChyZS51c2VkS2V5cy5pbmNsdWRlcyh0LmtleUNvZGUpICYmIHQucHJldmVudERlZmF1bHQoKSwgdC5rZXlDb2RlKSB7XG4gICAgICAgICAgY2FzZSB3LlRBQjpcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlVGFiUHJlc3ModCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIHcuTEVGVDpcbiAgICAgICAgICBjYXNlIHcuVVA6XG4gICAgICAgICAgICB0aGlzLmZsaXBMZWZ0KCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIHcuUklHSFQ6XG4gICAgICAgICAgY2FzZSB3LkRPV046XG4gICAgICAgICAgICB0aGlzLmZsaXBSaWdodCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSB3LkVOVEVSOlxuICAgICAgICAgICAgdGhpcy5oYW5kbGVFbnRlclByZXNzKHQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9LCB0aGlzLml0ZXJhdG9yID0gbmV3IGdlKGUuaXRlbXMsIGUuZm9jdXNlZEl0ZW1DbGFzcyksIHRoaXMuYWN0aXZhdGVDYWxsYmFjayA9IGUuYWN0aXZhdGVDYWxsYmFjaywgdGhpcy5hbGxvd2VkS2V5cyA9IGUuYWxsb3dlZEtleXMgfHwgcmUudXNlZEtleXM7XG4gIH1cbiAgLyoqXG4gICAqIFRydWUgaWYgZmxpcHBlciBpcyBjdXJyZW50bHkgYWN0aXZhdGVkXG4gICAqL1xuICBnZXQgaXNBY3RpdmF0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWN0aXZhdGVkO1xuICB9XG4gIC8qKlxuICAgKiBBcnJheSBvZiBrZXlzIChjb2RlcykgdGhhdCBpcyBoYW5kbGVkIGJ5IEZsaXBwZXJcbiAgICogVXNlZCB0bzpcbiAgICogIC0gcHJldmVudERlZmF1bHQgb25seSBmb3IgdGhpcyBrZXlzLCBub3QgYWxsIGtleWRvd25zIChAc2VlIGNvbnN0cnVjdG9yKVxuICAgKiAgLSB0byBza2lwIGV4dGVybmFsIGJlaGF2aW91cnMgb25seSBmb3IgdGhlc2Uga2V5cywgd2hlbiBmaWxsZXIgaXMgYWN0aXZhdGVkIChAc2VlIEJsb2NrRXZlbnRzQGFycm93UmlnaHRBbmREb3duKVxuICAgKi9cbiAgc3RhdGljIGdldCB1c2VkS2V5cygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgdy5UQUIsXG4gICAgICB3LkxFRlQsXG4gICAgICB3LlJJR0hULFxuICAgICAgdy5FTlRFUixcbiAgICAgIHcuVVAsXG4gICAgICB3LkRPV05cbiAgICBdO1xuICB9XG4gIC8qKlxuICAgKiBBY3RpdmUgdGFiL2Fycm93cyBoYW5kbGluZyBieSBmbGlwcGVyXG4gICAqXG4gICAqIEBwYXJhbSBpdGVtcyAtIFNvbWUgbW9kdWxlcyAobGlrZSwgSW5saW5lVG9vbGJhciwgQmxvY2tTZXR0aW5ncykgbWlnaHQgcmVmcmVzaCBidXR0b25zIGR5bmFtaWNhbGx5XG4gICAqIEBwYXJhbSBjdXJzb3JQb3NpdGlvbiAtIGluZGV4IG9mIHRoZSBpdGVtIHRoYXQgc2hvdWxkIGJlIGZvY3VzZWQgb25jZSBmbGlwcGVyIGlzIGFjdGl2YXRlZFxuICAgKi9cbiAgYWN0aXZhdGUoZSwgdCkge1xuICAgIHRoaXMuYWN0aXZhdGVkID0gITAsIGUgJiYgdGhpcy5pdGVyYXRvci5zZXRJdGVtcyhlKSwgdCAhPT0gdm9pZCAwICYmIHRoaXMuaXRlcmF0b3Iuc2V0Q3Vyc29yKHQpLCBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLm9uS2V5RG93biwgITApO1xuICB9XG4gIC8qKlxuICAgKiBEaXNhYmxlIHRhYi9hcnJvd3MgaGFuZGxpbmcgYnkgZmxpcHBlclxuICAgKi9cbiAgZGVhY3RpdmF0ZSgpIHtcbiAgICB0aGlzLmFjdGl2YXRlZCA9ICExLCB0aGlzLmRyb3BDdXJzb3IoKSwgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5vbktleURvd24pO1xuICB9XG4gIC8qKlxuICAgKiBGb2N1cyBmaXJzdCBpdGVtXG4gICAqL1xuICBmb2N1c0ZpcnN0KCkge1xuICAgIHRoaXMuZHJvcEN1cnNvcigpLCB0aGlzLmZsaXBSaWdodCgpO1xuICB9XG4gIC8qKlxuICAgKiBGb2N1c2VzIHByZXZpb3VzIGZsaXBwZXIgaXRlcmF0b3IgaXRlbVxuICAgKi9cbiAgZmxpcExlZnQoKSB7XG4gICAgdGhpcy5pdGVyYXRvci5wcmV2aW91cygpLCB0aGlzLmZsaXBDYWxsYmFjaygpO1xuICB9XG4gIC8qKlxuICAgKiBGb2N1c2VzIG5leHQgZmxpcHBlciBpdGVyYXRvciBpdGVtXG4gICAqL1xuICBmbGlwUmlnaHQoKSB7XG4gICAgdGhpcy5pdGVyYXRvci5uZXh0KCksIHRoaXMuZmxpcENhbGxiYWNrKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiB0cnVlIGlmIHNvbWUgYnV0dG9uIGlzIGZvY3VzZWRcbiAgICovXG4gIGhhc0ZvY3VzKCkge1xuICAgIHJldHVybiAhIXRoaXMuaXRlcmF0b3IuY3VycmVudEl0ZW07XG4gIH1cbiAgLyoqXG4gICAqIFJlZ2lzdGVyZXMgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgZXhlY3V0ZWQgb24gZWFjaCBuYXZpZ2F0aW9uIGFjdGlvblxuICAgKlxuICAgKiBAcGFyYW0gY2IgLSBmdW5jdGlvbiB0byBleGVjdXRlXG4gICAqL1xuICBvbkZsaXAoZSkge1xuICAgIHRoaXMuZmxpcENhbGxiYWNrcy5wdXNoKGUpO1xuICB9XG4gIC8qKlxuICAgKiBVbnJlZ2lzdGVyZXMgZnVuY3Rpb24gdGhhdCBpcyBleGVjdXRlZCBvbiBlYWNoIG5hdmlnYXRpb24gYWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSBjYiAtIGZ1bmN0aW9uIHRvIHN0b3AgZXhlY3V0aW5nXG4gICAqL1xuICByZW1vdmVPbkZsaXAoZSkge1xuICAgIHRoaXMuZmxpcENhbGxiYWNrcyA9IHRoaXMuZmxpcENhbGxiYWNrcy5maWx0ZXIoKHQpID0+IHQgIT09IGUpO1xuICB9XG4gIC8qKlxuICAgKiBEcm9wcyBmbGlwcGVyJ3MgaXRlcmF0b3IgY3Vyc29yXG4gICAqXG4gICAqIEBzZWUgRG9tSXRlcmF0b3IjZHJvcEN1cnNvclxuICAgKi9cbiAgZHJvcEN1cnNvcigpIHtcbiAgICB0aGlzLml0ZXJhdG9yLmRyb3BDdXJzb3IoKTtcbiAgfVxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBpcyBmaXJlZCBiZWZvcmUgaGFuZGxpbmcgZmxpcHBlciBrZXljb2Rlc1xuICAgKiBUaGUgcmVzdWx0IG9mIHRoaXMgZnVuY3Rpb24gZGVmaW5lcyBpZiBpdCBpcyBuZWVkIHRvIGJlIGhhbmRsZWQgb3Igbm90XG4gICAqXG4gICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnQgLSBrZXlkb3duIGtleWJvYXJkIGV2ZW50XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgaXNFdmVudFJlYWR5Rm9ySGFuZGxpbmcoZSkge1xuICAgIHJldHVybiB0aGlzLmFjdGl2YXRlZCAmJiB0aGlzLmFsbG93ZWRLZXlzLmluY2x1ZGVzKGUua2V5Q29kZSk7XG4gIH1cbiAgLyoqXG4gICAqIFdoZW4gZmxpcHBlciBpcyBhY3RpdmF0ZWQgdGFiIHByZXNzIHdpbGwgbGVhZiB0aGUgaXRlbXNcbiAgICpcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudCAtIHRhYiBrZXlkb3duIGV2ZW50XG4gICAqL1xuICBoYW5kbGVUYWJQcmVzcyhlKSB7XG4gICAgc3dpdGNoIChlLnNoaWZ0S2V5ID8gZ2UuZGlyZWN0aW9ucy5MRUZUIDogZ2UuZGlyZWN0aW9ucy5SSUdIVCkge1xuICAgICAgY2FzZSBnZS5kaXJlY3Rpb25zLlJJR0hUOlxuICAgICAgICB0aGlzLmZsaXBSaWdodCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgZ2UuZGlyZWN0aW9ucy5MRUZUOlxuICAgICAgICB0aGlzLmZsaXBMZWZ0KCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRW50ZXIgcHJlc3Mgd2lsbCBjbGljayBjdXJyZW50IGl0ZW0gaWYgZmxpcHBlciBpcyBhY3RpdmF0ZWRcbiAgICpcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudCAtIGVudGVyIGtleWRvd24gZXZlbnRcbiAgICovXG4gIGhhbmRsZUVudGVyUHJlc3MoZSkge1xuICAgIHRoaXMuYWN0aXZhdGVkICYmICh0aGlzLml0ZXJhdG9yLmN1cnJlbnRJdGVtICYmIChlLnN0b3BQcm9wYWdhdGlvbigpLCBlLnByZXZlbnREZWZhdWx0KCksIHRoaXMuaXRlcmF0b3IuY3VycmVudEl0ZW0uY2xpY2soKSksIE8odGhpcy5hY3RpdmF0ZUNhbGxiYWNrKSAmJiB0aGlzLmFjdGl2YXRlQ2FsbGJhY2sodGhpcy5pdGVyYXRvci5jdXJyZW50SXRlbSkpO1xuICB9XG4gIC8qKlxuICAgKiBGaXJlZCBhZnRlciBmbGlwcGluZyBpbiBhbnkgZGlyZWN0aW9uXG4gICAqL1xuICBmbGlwQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5pdGVyYXRvci5jdXJyZW50SXRlbSAmJiB0aGlzLml0ZXJhdG9yLmN1cnJlbnRJdGVtLnNjcm9sbEludG9WaWV3SWZOZWVkZWQoKSwgdGhpcy5mbGlwQ2FsbGJhY2tzLmZvckVhY2goKGUpID0+IGUoKSk7XG4gIH1cbn1cbmNvbnN0IHpvID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk05IDEyTDkgNy4xQzkgNy4wNDQ3NyA5LjA0NDc3IDcgOS4xIDdIMTAuNEMxMS41IDcgMTQgNy4xIDE0IDkuNUMxNCA5LjUgMTQgMTIgMTEgMTJNOSAxMlYxNi44QzkgMTYuOTEwNSA5LjA4OTU0IDE3IDkuMiAxN0gxMi41QzE0IDE3IDE1IDE2IDE1IDE0LjVDMTUgMTEuNzA0NiAxMSAxMiAxMSAxMk05IDEySDExXCIvPjwvc3ZnPicsIFVvID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk03IDEwTDExLjg1ODYgMTQuODU4NkMxMS45MzY3IDE0LjkzNjcgMTIuMDYzMyAxNC45MzY3IDEyLjE0MTQgMTQuODU4NkwxNyAxMFwiLz48L3N2Zz4nLCBqbyA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNMTQuNSAxNy41TDkuNjQxNDIgMTIuNjQxNEM5LjU2MzMxIDEyLjU2MzMgOS41NjMzMSAxMi40MzY3IDkuNjQxNDIgMTIuMzU4NkwxNC41IDcuNVwiLz48L3N2Zz4nLCAkbyA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNOS41ODI4NCAxNy41TDE0LjQ0MTQgMTIuNjQxNEMxNC41MTk1IDEyLjU2MzMgMTQuNTE5NSAxMi40MzY3IDE0LjQ0MTQgMTIuMzU4Nkw5LjU4Mjg0IDcuNVwiLz48L3N2Zz4nLCBZbyA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNNyAxNUwxMS44NTg2IDEwLjE0MTRDMTEuOTM2NyAxMC4wNjMzIDEyLjA2MzMgMTAuMDYzMyAxMi4xNDE0IDEwLjE0MTRMMTcgMTVcIi8+PC9zdmc+JywgV28gPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTggOEwxMiAxMk0xMiAxMkwxNiAxNk0xMiAxMkwxNiA4TTEyIDEyTDggMTZcIi8+PC9zdmc+JywgS28gPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PGNpcmNsZSBjeD1cIjEyXCIgY3k9XCIxMlwiIHI9XCI0XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLXdpZHRoPVwiMlwiLz48L3N2Zz4nLCBYbyA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNMTMuMzQgMTBDMTIuNDIyMyAxMi43MzM3IDExIDE3IDExIDE3XCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk0xNC4yMSA3SDE0LjJcIi8+PC9zdmc+JywgeHQgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTcuNjk5OTggMTIuNkw3LjY3ODk2IDEyLjYyQzYuNTM5OTMgMTMuNzA0OCA2LjUyMDEyIDE1LjUxNTUgNy42MzUxNiAxNi42MjVWMTYuNjI1QzguNzIyOTMgMTcuNzA3MyAxMC40Nzk5IDE3LjcxMDIgMTEuNTcxMiAxNi42MzE0TDEzLjAyNjMgMTUuMTkzQzE0LjA3MDMgMTQuMTYwOSAxNC4yMTQxIDEyLjUyNSAxMy4zNjYyIDExLjMyNjZMMTMuMjIgMTEuMTJcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTE2LjIyIDExLjEyTDE2LjM1NjQgMTAuOTgwNUMxNy4yODk1IDEwLjAyNjUgMTcuMzQ3OCA4LjUyMDcgMTYuNDkxNCA3LjQ5NzMzVjcuNDk3MzNDMTUuNTY5MSA2LjM5NTA5IDEzLjkyNjkgNi4yNTE0MyAxMi44MjcxIDcuMTc2NzVMMTEuMzkwMSA4LjM4NTg4QzEwLjA5MzUgOS40NzY3NCA5Ljk1NzA2IDExLjQyNDEgMTEuMDg4OCAxMi42ODUyTDExLjEyIDEyLjcyXCIvPjwvc3ZnPicsIFZvID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyLjZcIiBkPVwiTTkuNDA5OTkgNy4yOTk5OUg5LjRcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjIuNlwiIGQ9XCJNMTQuNiA3LjI5OTk5SDE0LjU5XCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyLjZcIiBkPVwiTTkuMzA5OTkgMTJIOS4zXCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyLjZcIiBkPVwiTTE0LjYgMTJIMTQuNTlcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjIuNlwiIGQ9XCJNOS40MDk5OSAxNi43SDkuNFwiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMi42XCIgZD1cIk0xNC42IDE2LjdIMTQuNTlcIi8+PC9zdmc+JywgcW8gPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTEyIDdWMTJNMTIgMTdWMTJNMTcgMTJIMTJNMTIgMTJIN1wiLz48L3N2Zz4nLCBqdCA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNMTEuNSAxNy41TDUgMTFNNSAxMVYxNS41TTUgMTFIOS41XCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk0xMi41IDYuNUwxOSAxM00xOSAxM1Y4LjVNMTkgMTNIMTQuNVwiLz48L3N2Zz4nLCBabyA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48Y2lyY2xlIGN4PVwiMTAuNVwiIGN5PVwiMTAuNVwiIHI9XCI1LjVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2Utd2lkdGg9XCIyXCIvPjxsaW5lIHgxPVwiMTUuNDE0MlwiIHgyPVwiMTlcIiB5MT1cIjE1XCIgeTI9XCIxOC41ODU4XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIi8+PC9zdmc+JywgR28gPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTE1Ljc3OTUgMTEuNUMxNS43Nzk1IDExLjUgMTYuMDUzIDExLjE5NjIgMTYuNTQ5NyAxMC42NzIyQzE3LjQ0NDIgOS43Mjg1NiAxNy40NzAxIDguMjQ3NSAxNi41NzgxIDcuMzAxNDVWNy4zMDE0NUMxNS42NDgyIDYuMzE1MjIgMTQuMDg3MyA2LjI5MjI3IDEzLjEyODggNy4yNTA3M0wxMS44Nzk2IDguNDk5OTlcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTguMjQ1MTcgMTIuMzg4M0M4LjI0NTE3IDEyLjM4ODMgNy45NzE3MSAxMi42OTIyIDcuNDc1MDQgMTMuMjE2MUM2LjU4MDUxIDE0LjE1OTggNi41NTQ2NyAxNS42NDA4IDcuNDQ2NjYgMTYuNTg2OVYxNi41ODY5QzguMzc2NTMgMTcuNTczMSA5LjkzNzQ0IDE3LjU5NjEgMTAuODk1OSAxNi42Mzc2TDEyLjE0NTIgMTUuMzg4M1wiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNMTcuNzgwMiAxNS4xMDMyTDE2LjU5NyAxNC45NDIyQzE2LjAxMDkgMTQuODYyNCAxNS40ODQxIDE1LjMwNTkgMTUuNDYyNyAxNS44OTY5TDE1LjQxOTkgMTcuMDgxOFwiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNNi4zOTA2NCA5LjAzMjM4TDcuNTg0MzIgOS4wNjY2OEM4LjE3NTUxIDkuMDgzNjYgOC42NTIyIDguNTg2NjUgOC42MTA1NiA3Ljk5NjY5TDguNTI3MSA2LjgxMzk3XCIvPjxsaW5lIHgxPVwiMTIuMTE0MlwiIHgyPVwiMTEuN1wiIHkxPVwiMTIuMlwiIHkyPVwiMTEuNzg1OFwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIvPjwvc3ZnPicsIEpvID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxyZWN0IHdpZHRoPVwiMTRcIiBoZWlnaHQ9XCIxNFwiIHg9XCI1XCIgeT1cIjVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2Utd2lkdGg9XCIyXCIgcng9XCI0XCIvPjxsaW5lIHgxPVwiMTJcIiB4Mj1cIjEyXCIgeTE9XCI5XCIgeTI9XCIxMlwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk0xMiAxNS4wMlYxNS4wMVwiLz48L3N2Zz4nO1xudmFyICR0ID0geyBleHBvcnRzOiB7fSB9O1xuLyohXG4gKiBDb2RlWC5Ub29sdGlwc1xuICogXG4gKiBAdmVyc2lvbiAxLjAuNVxuICogXG4gKiBAbGljZW5jZSBNSVRcbiAqIEBhdXRob3IgQ29kZVggPGh0dHBzOi8vY29kZXguc28+XG4gKiBcbiAqIFxuICovXG4oZnVuY3Rpb24obiwgZSkge1xuICAoZnVuY3Rpb24odCwgbykge1xuICAgIG4uZXhwb3J0cyA9IG8oKTtcbiAgfSkod2luZG93LCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgdmFyIG8gPSB7fTtcbiAgICAgIGZ1bmN0aW9uIGkocykge1xuICAgICAgICBpZiAob1tzXSlcbiAgICAgICAgICByZXR1cm4gb1tzXS5leHBvcnRzO1xuICAgICAgICB2YXIgciA9IG9bc10gPSB7IGk6IHMsIGw6ICExLCBleHBvcnRzOiB7fSB9O1xuICAgICAgICByZXR1cm4gdFtzXS5jYWxsKHIuZXhwb3J0cywgciwgci5leHBvcnRzLCBpKSwgci5sID0gITAsIHIuZXhwb3J0cztcbiAgICAgIH1cbiAgICAgIHJldHVybiBpLm0gPSB0LCBpLmMgPSBvLCBpLmQgPSBmdW5jdGlvbihzLCByLCBsKSB7XG4gICAgICAgIGkubyhzLCByKSB8fCBPYmplY3QuZGVmaW5lUHJvcGVydHkocywgciwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBsIH0pO1xuICAgICAgfSwgaS5yID0gZnVuY3Rpb24ocykge1xuICAgICAgICB0eXBlb2YgU3ltYm9sIDwgXCJ1XCIgJiYgU3ltYm9sLnRvU3RyaW5nVGFnICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG4gICAgICB9LCBpLnQgPSBmdW5jdGlvbihzLCByKSB7XG4gICAgICAgIGlmICgxICYgciAmJiAocyA9IGkocykpLCA4ICYgciB8fCA0ICYgciAmJiB0eXBlb2YgcyA9PSBcIm9iamVjdFwiICYmIHMgJiYgcy5fX2VzTW9kdWxlKVxuICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICB2YXIgbCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBpZiAoaS5yKGwpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkobCwgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogITAsIHZhbHVlOiBzIH0pLCAyICYgciAmJiB0eXBlb2YgcyAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgIGZvciAodmFyIGEgaW4gcylcbiAgICAgICAgICAgIGkuZChsLCBhLCAoZnVuY3Rpb24oYykge1xuICAgICAgICAgICAgICByZXR1cm4gc1tjXTtcbiAgICAgICAgICAgIH0pLmJpbmQobnVsbCwgYSkpO1xuICAgICAgICByZXR1cm4gbDtcbiAgICAgIH0sIGkubiA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgdmFyIHIgPSBzICYmIHMuX19lc01vZHVsZSA/IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBzLmRlZmF1bHQ7XG4gICAgICAgIH0gOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGkuZChyLCBcImFcIiwgciksIHI7XG4gICAgICB9LCBpLm8gPSBmdW5jdGlvbihzLCByKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcik7XG4gICAgICB9LCBpLnAgPSBcIlwiLCBpKGkucyA9IDApO1xuICAgIH0oW2Z1bmN0aW9uKHQsIG8sIGkpIHtcbiAgICAgIHQuZXhwb3J0cyA9IGkoMSk7XG4gICAgfSwgZnVuY3Rpb24odCwgbywgaSkge1xuICAgICAgaS5yKG8pLCBpLmQobywgXCJkZWZhdWx0XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcztcbiAgICAgIH0pO1xuICAgICAgY2xhc3MgcyB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgIHRoaXMubm9kZXMgPSB7IHdyYXBwZXI6IG51bGwsIGNvbnRlbnQ6IG51bGwgfSwgdGhpcy5zaG93ZWQgPSAhMSwgdGhpcy5vZmZzZXRUb3AgPSAxMCwgdGhpcy5vZmZzZXRMZWZ0ID0gMTAsIHRoaXMub2Zmc2V0UmlnaHQgPSAxMCwgdGhpcy5oaWRpbmdEZWxheSA9IDAsIHRoaXMuaGFuZGxlV2luZG93U2Nyb2xsID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zaG93ZWQgJiYgdGhpcy5oaWRlKCEwKTtcbiAgICAgICAgICB9LCB0aGlzLmxvYWRTdHlsZXMoKSwgdGhpcy5wcmVwYXJlKCksIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMuaGFuZGxlV2luZG93U2Nyb2xsLCB7IHBhc3NpdmU6ICEwIH0pO1xuICAgICAgICB9XG4gICAgICAgIGdldCBDU1MoKSB7XG4gICAgICAgICAgcmV0dXJuIHsgdG9vbHRpcDogXCJjdFwiLCB0b29sdGlwQ29udGVudDogXCJjdF9fY29udGVudFwiLCB0b29sdGlwU2hvd246IFwiY3QtLXNob3duXCIsIHBsYWNlbWVudDogeyBsZWZ0OiBcImN0LS1sZWZ0XCIsIGJvdHRvbTogXCJjdC0tYm90dG9tXCIsIHJpZ2h0OiBcImN0LS1yaWdodFwiLCB0b3A6IFwiY3QtLXRvcFwiIH0gfTtcbiAgICAgICAgfVxuICAgICAgICBzaG93KGwsIGEsIGMpIHtcbiAgICAgICAgICB0aGlzLm5vZGVzLndyYXBwZXIgfHwgdGhpcy5wcmVwYXJlKCksIHRoaXMuaGlkaW5nVGltZW91dCAmJiBjbGVhclRpbWVvdXQodGhpcy5oaWRpbmdUaW1lb3V0KTtcbiAgICAgICAgICBjb25zdCB1ID0gT2JqZWN0LmFzc2lnbih7IHBsYWNlbWVudDogXCJib3R0b21cIiwgbWFyZ2luVG9wOiAwLCBtYXJnaW5MZWZ0OiAwLCBtYXJnaW5SaWdodDogMCwgbWFyZ2luQm90dG9tOiAwLCBkZWxheTogNzAsIGhpZGluZ0RlbGF5OiAwIH0sIGMpO1xuICAgICAgICAgIGlmICh1LmhpZGluZ0RlbGF5ICYmICh0aGlzLmhpZGluZ0RlbGF5ID0gdS5oaWRpbmdEZWxheSksIHRoaXMubm9kZXMuY29udGVudC5pbm5lckhUTUwgPSBcIlwiLCB0eXBlb2YgYSA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgdGhpcy5ub2Rlcy5jb250ZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGEpKTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghKGEgaW5zdGFuY2VvZiBOb2RlKSlcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJbQ29kZVggVG9vbHRpcF0gV3JvbmcgdHlwZSBvZiDCq2NvbnRlbnTCuyBwYXNzZWQuIEl0IHNob3VsZCBiZSBhbiBpbnN0YW5jZSBvZiBOb2RlIG9yIFN0cmluZy4gQnV0IFwiICsgdHlwZW9mIGEgKyBcIiBnaXZlbi5cIik7XG4gICAgICAgICAgICB0aGlzLm5vZGVzLmNvbnRlbnQuYXBwZW5kQ2hpbGQoYSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN3aXRjaCAodGhpcy5ub2Rlcy53cmFwcGVyLmNsYXNzTGlzdC5yZW1vdmUoLi4uT2JqZWN0LnZhbHVlcyh0aGlzLkNTUy5wbGFjZW1lbnQpKSwgdS5wbGFjZW1lbnQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0b3BcIjpcbiAgICAgICAgICAgICAgdGhpcy5wbGFjZVRvcChsLCB1KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgICAgICAgICB0aGlzLnBsYWNlTGVmdChsLCB1KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgICAgICAgICAgdGhpcy5wbGFjZVJpZ2h0KGwsIHUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJib3R0b21cIjpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRoaXMucGxhY2VCb3R0b20obCwgdSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHUgJiYgdS5kZWxheSA/IHRoaXMuc2hvd2luZ1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubm9kZXMud3JhcHBlci5jbGFzc0xpc3QuYWRkKHRoaXMuQ1NTLnRvb2x0aXBTaG93biksIHRoaXMuc2hvd2VkID0gITA7XG4gICAgICAgICAgfSwgdS5kZWxheSkgOiAodGhpcy5ub2Rlcy53cmFwcGVyLmNsYXNzTGlzdC5hZGQodGhpcy5DU1MudG9vbHRpcFNob3duKSwgdGhpcy5zaG93ZWQgPSAhMCk7XG4gICAgICAgIH1cbiAgICAgICAgaGlkZShsID0gITEpIHtcbiAgICAgICAgICBpZiAodGhpcy5oaWRpbmdEZWxheSAmJiAhbClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhpZGluZ1RpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KHRoaXMuaGlkaW5nVGltZW91dCksIHZvaWQgKHRoaXMuaGlkaW5nVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLmhpZGUoITApO1xuICAgICAgICAgICAgfSwgdGhpcy5oaWRpbmdEZWxheSkpO1xuICAgICAgICAgIHRoaXMubm9kZXMud3JhcHBlci5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuQ1NTLnRvb2x0aXBTaG93biksIHRoaXMuc2hvd2VkID0gITEsIHRoaXMuc2hvd2luZ1RpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KHRoaXMuc2hvd2luZ1RpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIG9uSG92ZXIobCwgYSwgYykge1xuICAgICAgICAgIGwuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZW50ZXJcIiwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zaG93KGwsIGEsIGMpO1xuICAgICAgICAgIH0pLCBsLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGRlc3Ryb3koKSB7XG4gICAgICAgICAgdGhpcy5ub2Rlcy53cmFwcGVyLnJlbW92ZSgpLCB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLmhhbmRsZVdpbmRvd1Njcm9sbCk7XG4gICAgICAgIH1cbiAgICAgICAgcHJlcGFyZSgpIHtcbiAgICAgICAgICB0aGlzLm5vZGVzLndyYXBwZXIgPSB0aGlzLm1ha2UoXCJkaXZcIiwgdGhpcy5DU1MudG9vbHRpcCksIHRoaXMubm9kZXMuY29udGVudCA9IHRoaXMubWFrZShcImRpdlwiLCB0aGlzLkNTUy50b29sdGlwQ29udGVudCksIHRoaXMuYXBwZW5kKHRoaXMubm9kZXMud3JhcHBlciwgdGhpcy5ub2Rlcy5jb250ZW50KSwgdGhpcy5hcHBlbmQoZG9jdW1lbnQuYm9keSwgdGhpcy5ub2Rlcy53cmFwcGVyKTtcbiAgICAgICAgfVxuICAgICAgICBsb2FkU3R5bGVzKCkge1xuICAgICAgICAgIGNvbnN0IGwgPSBcImNvZGV4LXRvb2x0aXBzLXN0eWxlXCI7XG4gICAgICAgICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGwpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGNvbnN0IGEgPSBpKDIpLCBjID0gdGhpcy5tYWtlKFwic3R5bGVcIiwgbnVsbCwgeyB0ZXh0Q29udGVudDogYS50b1N0cmluZygpLCBpZDogbCB9KTtcbiAgICAgICAgICB0aGlzLnByZXBlbmQoZG9jdW1lbnQuaGVhZCwgYyk7XG4gICAgICAgIH1cbiAgICAgICAgcGxhY2VCb3R0b20obCwgYSkge1xuICAgICAgICAgIGNvbnN0IGMgPSBsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCB1ID0gYy5sZWZ0ICsgbC5jbGllbnRXaWR0aCAvIDIgLSB0aGlzLm5vZGVzLndyYXBwZXIub2Zmc2V0V2lkdGggLyAyLCBoID0gYy5ib3R0b20gKyB3aW5kb3cucGFnZVlPZmZzZXQgKyB0aGlzLm9mZnNldFRvcCArIGEubWFyZ2luVG9wO1xuICAgICAgICAgIHRoaXMuYXBwbHlQbGFjZW1lbnQoXCJib3R0b21cIiwgdSwgaCk7XG4gICAgICAgIH1cbiAgICAgICAgcGxhY2VUb3AobCwgYSkge1xuICAgICAgICAgIGNvbnN0IGMgPSBsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCB1ID0gYy5sZWZ0ICsgbC5jbGllbnRXaWR0aCAvIDIgLSB0aGlzLm5vZGVzLndyYXBwZXIub2Zmc2V0V2lkdGggLyAyLCBoID0gYy50b3AgKyB3aW5kb3cucGFnZVlPZmZzZXQgLSB0aGlzLm5vZGVzLndyYXBwZXIuY2xpZW50SGVpZ2h0IC0gdGhpcy5vZmZzZXRUb3A7XG4gICAgICAgICAgdGhpcy5hcHBseVBsYWNlbWVudChcInRvcFwiLCB1LCBoKTtcbiAgICAgICAgfVxuICAgICAgICBwbGFjZUxlZnQobCwgYSkge1xuICAgICAgICAgIGNvbnN0IGMgPSBsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCB1ID0gYy5sZWZ0IC0gdGhpcy5ub2Rlcy53cmFwcGVyLm9mZnNldFdpZHRoIC0gdGhpcy5vZmZzZXRMZWZ0IC0gYS5tYXJnaW5MZWZ0LCBoID0gYy50b3AgKyB3aW5kb3cucGFnZVlPZmZzZXQgKyBsLmNsaWVudEhlaWdodCAvIDIgLSB0aGlzLm5vZGVzLndyYXBwZXIub2Zmc2V0SGVpZ2h0IC8gMjtcbiAgICAgICAgICB0aGlzLmFwcGx5UGxhY2VtZW50KFwibGVmdFwiLCB1LCBoKTtcbiAgICAgICAgfVxuICAgICAgICBwbGFjZVJpZ2h0KGwsIGEpIHtcbiAgICAgICAgICBjb25zdCBjID0gbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgdSA9IGMucmlnaHQgKyB0aGlzLm9mZnNldFJpZ2h0ICsgYS5tYXJnaW5SaWdodCwgaCA9IGMudG9wICsgd2luZG93LnBhZ2VZT2Zmc2V0ICsgbC5jbGllbnRIZWlnaHQgLyAyIC0gdGhpcy5ub2Rlcy53cmFwcGVyLm9mZnNldEhlaWdodCAvIDI7XG4gICAgICAgICAgdGhpcy5hcHBseVBsYWNlbWVudChcInJpZ2h0XCIsIHUsIGgpO1xuICAgICAgICB9XG4gICAgICAgIGFwcGx5UGxhY2VtZW50KGwsIGEsIGMpIHtcbiAgICAgICAgICB0aGlzLm5vZGVzLndyYXBwZXIuY2xhc3NMaXN0LmFkZCh0aGlzLkNTUy5wbGFjZW1lbnRbbF0pLCB0aGlzLm5vZGVzLndyYXBwZXIuc3R5bGUubGVmdCA9IGEgKyBcInB4XCIsIHRoaXMubm9kZXMud3JhcHBlci5zdHlsZS50b3AgPSBjICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgICAgIG1ha2UobCwgYSA9IG51bGwsIGMgPSB7fSkge1xuICAgICAgICAgIGNvbnN0IHUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGwpO1xuICAgICAgICAgIEFycmF5LmlzQXJyYXkoYSkgPyB1LmNsYXNzTGlzdC5hZGQoLi4uYSkgOiBhICYmIHUuY2xhc3NMaXN0LmFkZChhKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGggaW4gYylcbiAgICAgICAgICAgIGMuaGFzT3duUHJvcGVydHkoaCkgJiYgKHVbaF0gPSBjW2hdKTtcbiAgICAgICAgICByZXR1cm4gdTtcbiAgICAgICAgfVxuICAgICAgICBhcHBlbmQobCwgYSkge1xuICAgICAgICAgIEFycmF5LmlzQXJyYXkoYSkgPyBhLmZvckVhY2goKGMpID0+IGwuYXBwZW5kQ2hpbGQoYykpIDogbC5hcHBlbmRDaGlsZChhKTtcbiAgICAgICAgfVxuICAgICAgICBwcmVwZW5kKGwsIGEpIHtcbiAgICAgICAgICBBcnJheS5pc0FycmF5KGEpID8gKGEgPSBhLnJldmVyc2UoKSkuZm9yRWFjaCgoYykgPT4gbC5wcmVwZW5kKGMpKSA6IGwucHJlcGVuZChhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uKHQsIG8pIHtcbiAgICAgIHQuZXhwb3J0cyA9IGAuY3R7ei1pbmRleDo5OTk7b3BhY2l0eTowOy13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTstbW96LXVzZXItc2VsZWN0Om5vbmU7LW1zLXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZTtwb2ludGVyLWV2ZW50czpub25lOy13ZWJraXQtdHJhbnNpdGlvbjpvcGFjaXR5IDUwbXMgZWFzZS1pbiwtd2Via2l0LXRyYW5zZm9ybSA3MG1zIGN1YmljLWJlemllciguMjE1LC42MSwuMzU1LDEpO3RyYW5zaXRpb246b3BhY2l0eSA1MG1zIGVhc2UtaW4sLXdlYmtpdC10cmFuc2Zvcm0gNzBtcyBjdWJpYy1iZXppZXIoLjIxNSwuNjEsLjM1NSwxKTt0cmFuc2l0aW9uOm9wYWNpdHkgNTBtcyBlYXNlLWluLHRyYW5zZm9ybSA3MG1zIGN1YmljLWJlemllciguMjE1LC42MSwuMzU1LDEpO3RyYW5zaXRpb246b3BhY2l0eSA1MG1zIGVhc2UtaW4sdHJhbnNmb3JtIDcwbXMgY3ViaWMtYmV6aWVyKC4yMTUsLjYxLC4zNTUsMSksLXdlYmtpdC10cmFuc2Zvcm0gNzBtcyBjdWJpYy1iZXppZXIoLjIxNSwuNjEsLjM1NSwxKTt3aWxsLWNoYW5nZTpvcGFjaXR5LHRvcCxsZWZ0Oy13ZWJraXQtYm94LXNoYWRvdzowIDhweCAxMnB4IDAgcmdiYSgyOSwzMiw0MywuMTcpLDAgNHB4IDVweCAtM3B4IHJnYmEoNSw2LDEyLC40OSk7Ym94LXNoYWRvdzowIDhweCAxMnB4IDAgcmdiYSgyOSwzMiw0MywuMTcpLDAgNHB4IDVweCAtM3B4IHJnYmEoNSw2LDEyLC40OSk7Ym9yZGVyLXJhZGl1czo5cHh9LmN0LC5jdDpiZWZvcmV7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7bGVmdDowfS5jdDpiZWZvcmV7Y29udGVudDpcIlwiO2JvdHRvbTowO3JpZ2h0OjA7YmFja2dyb3VuZC1jb2xvcjojMWQyMDJiO3otaW5kZXg6LTE7Ym9yZGVyLXJhZGl1czo0cHh9QHN1cHBvcnRzKC13ZWJraXQtbWFzay1ib3gtaW1hZ2U6dXJsKFwiXCIpKXsuY3Q6YmVmb3Jle2JvcmRlci1yYWRpdXM6MDstd2Via2l0LW1hc2stYm94LWltYWdlOnVybCgnZGF0YTppbWFnZS9zdmcreG1sO2NoYXJzZXQ9dXRmLTgsPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCI+PHBhdGggZD1cIk0xMC43MSAwaDIuNThjMy4wMiAwIDQuNjQuNDIgNi4xIDEuMmE4LjE4IDguMTggMCAwMTMuNCAzLjRDMjMuNiA2LjA3IDI0IDcuNyAyNCAxMC43MXYyLjU4YzAgMy4wMi0uNDIgNC42NC0xLjIgNi4xYTguMTggOC4xOCAwIDAxLTMuNCAzLjRjLTEuNDcuOC0zLjEgMS4yMS02LjExIDEuMjFIMTAuN2MtMy4wMiAwLTQuNjQtLjQyLTYuMS0xLjJhOC4xOCA4LjE4IDAgMDEtMy40LTMuNEMuNCAxNy45MyAwIDE2LjMgMCAxMy4yOVYxMC43YzAtMy4wMi40Mi00LjY0IDEuMi02LjFhOC4xOCA4LjE4IDAgMDEzLjQtMy40QzYuMDcuNCA3LjcgMCAxMC43MSAwelwiLz48L3N2Zz4nKSA0OCUgNDElIDM3LjklIDUzLjMlfX1AbWVkaWEgKC0tbW9iaWxlKXsuY3R7ZGlzcGxheTpub25lfX0uY3RfX2NvbnRlbnR7cGFkZGluZzo2cHggMTBweDtjb2xvcjojY2RkMWUwO2ZvbnQtc2l6ZToxMnB4O3RleHQtYWxpZ246Y2VudGVyO2xldHRlci1zcGFjaW5nOi4wMmVtO2xpbmUtaGVpZ2h0OjFlbX0uY3Q6YWZ0ZXJ7Y29udGVudDpcIlwiO3dpZHRoOjhweDtoZWlnaHQ6OHB4O3Bvc2l0aW9uOmFic29sdXRlO2JhY2tncm91bmQtY29sb3I6IzFkMjAyYjt6LWluZGV4Oi0xfS5jdC0tYm90dG9tey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoNXB4KTt0cmFuc2Zvcm06dHJhbnNsYXRlWSg1cHgpfS5jdC0tYm90dG9tOmFmdGVye3RvcDotM3B4O2xlZnQ6NTAlOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTUwJSkgcm90YXRlKC00NWRlZyk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTUwJSkgcm90YXRlKC00NWRlZyl9LmN0LS10b3B7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgtNXB4KTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtNXB4KX0uY3QtLXRvcDphZnRlcnt0b3A6YXV0bztib3R0b206LTNweDtsZWZ0OjUwJTstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKC01MCUpIHJvdGF0ZSgtNDVkZWcpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKC01MCUpIHJvdGF0ZSgtNDVkZWcpfS5jdC0tbGVmdHstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKC01cHgpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKC01cHgpfS5jdC0tbGVmdDphZnRlcnt0b3A6NTAlO2xlZnQ6YXV0bztyaWdodDowOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZSg0MS42JSwtNTAlKSByb3RhdGUoLTQ1ZGVnKTt0cmFuc2Zvcm06dHJhbnNsYXRlKDQxLjYlLC01MCUpIHJvdGF0ZSgtNDVkZWcpfS5jdC0tcmlnaHR7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWCg1cHgpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKDVweCl9LmN0LS1yaWdodDphZnRlcnt0b3A6NTAlO2xlZnQ6MDstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGUoLTQxLjYlLC01MCUpIHJvdGF0ZSgtNDVkZWcpO3RyYW5zZm9ybTp0cmFuc2xhdGUoLTQxLjYlLC01MCUpIHJvdGF0ZSgtNDVkZWcpfS5jdC0tc2hvd257b3BhY2l0eToxOy13ZWJraXQtdHJhbnNmb3JtOm5vbmU7dHJhbnNmb3JtOm5vbmV9YDtcbiAgICB9XSkuZGVmYXVsdDtcbiAgfSk7XG59KSgkdCk7XG52YXIgUW8gPSAkdC5leHBvcnRzO1xuY29uc3QgZWkgPSAvKiBAX19QVVJFX18gKi8gUmUoUW8pO1xubGV0IHogPSBudWxsO1xuZnVuY3Rpb24gdHQoKSB7XG4gIHogfHwgKHogPSBuZXcgZWkoKSk7XG59XG5mdW5jdGlvbiB0aShuLCBlLCB0KSB7XG4gIHR0KCksIHogPT0gbnVsbCB8fCB6LnNob3cobiwgZSwgdCk7XG59XG5mdW5jdGlvbiBfZShuID0gITEpIHtcbiAgdHQoKSwgeiA9PSBudWxsIHx8IHouaGlkZShuKTtcbn1cbmZ1bmN0aW9uIE5lKG4sIGUsIHQpIHtcbiAgdHQoKSwgeiA9PSBudWxsIHx8IHoub25Ib3ZlcihuLCBlLCB0KTtcbn1cbmZ1bmN0aW9uIG9pKCkge1xuICB6ID09IG51bGwgfHwgei5kZXN0cm95KCksIHogPSBudWxsO1xufVxuY29uc3QgaWkgPSBcIl9fXCIsIHNpID0gXCItLVwiO1xuZnVuY3Rpb24gdGUobikge1xuICByZXR1cm4gKGUsIHQpID0+IFtbbiwgZV0uZmlsdGVyKChpKSA9PiAhIWkpLmpvaW4oaWkpLCB0XS5maWx0ZXIoKGkpID0+ICEhaSkuam9pbihzaSk7XG59XG5jb25zdCBtZSA9IHRlKFwiY2UtaGludFwiKSwgYmUgPSB7XG4gIHJvb3Q6IG1lKCksXG4gIGFsaWduZWRTdGFydDogbWUobnVsbCwgXCJhbGlnbi1sZWZ0XCIpLFxuICBhbGlnbmVkQ2VudGVyOiBtZShudWxsLCBcImFsaWduLWNlbnRlclwiKSxcbiAgdGl0bGU6IG1lKFwidGl0bGVcIiksXG4gIGRlc2NyaXB0aW9uOiBtZShcImRlc2NyaXB0aW9uXCIpXG59O1xuY2xhc3Mgbmkge1xuICAvKipcbiAgICogQ29uc3RydWN0cyB0aGUgaGludCBjb250ZW50IGluc3RhbmNlXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBoaW50IGNvbnRlbnQgcGFyYW1ldGVyc1xuICAgKi9cbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHRoaXMubm9kZXMgPSB7XG4gICAgICByb290OiBkLm1ha2UoXCJkaXZcIiwgW2JlLnJvb3QsIGUuYWxpZ25tZW50ID09PSBcImNlbnRlclwiID8gYmUuYWxpZ25lZENlbnRlciA6IGJlLmFsaWduZWRTdGFydF0pLFxuICAgICAgdGl0bGU6IGQubWFrZShcImRpdlwiLCBiZS50aXRsZSwgeyB0ZXh0Q29udGVudDogZS50aXRsZSB9KVxuICAgIH0sIHRoaXMubm9kZXMucm9vdC5hcHBlbmRDaGlsZCh0aGlzLm5vZGVzLnRpdGxlKSwgZS5kZXNjcmlwdGlvbiAhPT0gdm9pZCAwICYmICh0aGlzLm5vZGVzLmRlc2NyaXB0aW9uID0gZC5tYWtlKFwiZGl2XCIsIGJlLmRlc2NyaXB0aW9uLCB7IHRleHRDb250ZW50OiBlLmRlc2NyaXB0aW9uIH0pLCB0aGlzLm5vZGVzLnJvb3QuYXBwZW5kQ2hpbGQodGhpcy5ub2Rlcy5kZXNjcmlwdGlvbikpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByb290IGVsZW1lbnQgb2YgdGhlIGhpbnQgY29udGVudFxuICAgKi9cbiAgZ2V0RWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2Rlcy5yb290O1xuICB9XG59XG5jbGFzcyBvdCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIHRoZSBpbnN0YW5jZVxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zIC0gaW5zdGFuY2UgcGFyYW1ldGVyc1xuICAgKi9cbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHRoaXMucGFyYW1zID0gZTtcbiAgfVxuICAvKipcbiAgICogSXRlbSBuYW1lIGlmIGV4aXN0c1xuICAgKi9cbiAgZ2V0IG5hbWUoKSB7XG4gICAgaWYgKHRoaXMucGFyYW1zICE9PSB2b2lkIDAgJiYgXCJuYW1lXCIgaW4gdGhpcy5wYXJhbXMpXG4gICAgICByZXR1cm4gdGhpcy5wYXJhbXMubmFtZTtcbiAgfVxuICAvKipcbiAgICogRGVzdHJveXMgdGhlIGluc3RhbmNlXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIF9lKCk7XG4gIH1cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGNoaWxkcmVuIHBvcG92ZXIgaXMgb3BlbmVkIChpZiBleGlzdHMpXG4gICAqL1xuICBvbkNoaWxkcmVuT3BlbigpIHtcbiAgICB2YXIgZTtcbiAgICB0aGlzLnBhcmFtcyAhPT0gdm9pZCAwICYmIFwiY2hpbGRyZW5cIiBpbiB0aGlzLnBhcmFtcyAmJiB0eXBlb2YgKChlID0gdGhpcy5wYXJhbXMuY2hpbGRyZW4pID09IG51bGwgPyB2b2lkIDAgOiBlLm9uT3BlbikgPT0gXCJmdW5jdGlvblwiICYmIHRoaXMucGFyYW1zLmNoaWxkcmVuLm9uT3BlbigpO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBjaGlsZHJlbiBwb3BvdmVyIGlzIGNsb3NlZCAoaWYgZXhpc3RzKVxuICAgKi9cbiAgb25DaGlsZHJlbkNsb3NlKCkge1xuICAgIHZhciBlO1xuICAgIHRoaXMucGFyYW1zICE9PSB2b2lkIDAgJiYgXCJjaGlsZHJlblwiIGluIHRoaXMucGFyYW1zICYmIHR5cGVvZiAoKGUgPSB0aGlzLnBhcmFtcy5jaGlsZHJlbikgPT0gbnVsbCA/IHZvaWQgMCA6IGUub25DbG9zZSkgPT0gXCJmdW5jdGlvblwiICYmIHRoaXMucGFyYW1zLmNoaWxkcmVuLm9uQ2xvc2UoKTtcbiAgfVxuICAvKipcbiAgICogQ2FsbGVkIG9uIHBvcG92ZXIgaXRlbSBjbGlja1xuICAgKi9cbiAgaGFuZGxlQ2xpY2soKSB7XG4gICAgdmFyIGUsIHQ7XG4gICAgdGhpcy5wYXJhbXMgIT09IHZvaWQgMCAmJiBcIm9uQWN0aXZhdGVcIiBpbiB0aGlzLnBhcmFtcyAmJiAoKHQgPSAoZSA9IHRoaXMucGFyYW1zKS5vbkFjdGl2YXRlKSA9PSBudWxsIHx8IHQuY2FsbChlLCB0aGlzLnBhcmFtcykpO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGhpbnQgdG8gdGhlIGl0ZW0gZWxlbWVudCBpZiBoaW50IGRhdGEgaXMgcHJvdmlkZWRcbiAgICpcbiAgICogQHBhcmFtIGl0ZW1FbGVtZW50IC0gcG9wb3ZlciBpdGVtIHJvb3QgZWxlbWVudCB0byBhZGQgaGludCB0b1xuICAgKiBAcGFyYW0gaGludERhdGEgLSBoaW50IGRhdGFcbiAgICovXG4gIGFkZEhpbnQoZSwgdCkge1xuICAgIGNvbnN0IG8gPSBuZXcgbmkodCk7XG4gICAgTmUoZSwgby5nZXRFbGVtZW50KCksIHtcbiAgICAgIHBsYWNlbWVudDogdC5wb3NpdGlvbixcbiAgICAgIGhpZGluZ0RlbGF5OiAxMDBcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBpdGVtIGNoaWxkcmVuIHRoYXQgYXJlIHJlcHJlc2VudGVkIGFzIHBvcG92ZXIgaXRlbXNcbiAgICovXG4gIGdldCBjaGlsZHJlbigpIHtcbiAgICB2YXIgZTtcbiAgICByZXR1cm4gdGhpcy5wYXJhbXMgIT09IHZvaWQgMCAmJiBcImNoaWxkcmVuXCIgaW4gdGhpcy5wYXJhbXMgJiYgKChlID0gdGhpcy5wYXJhbXMuY2hpbGRyZW4pID09IG51bGwgPyB2b2lkIDAgOiBlLml0ZW1zKSAhPT0gdm9pZCAwID8gdGhpcy5wYXJhbXMuY2hpbGRyZW4uaXRlbXMgOiBbXTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGl0ZW0gaGFzIGFueSB0eXBlIG9mIGNoaWxkcmVuXG4gICAqL1xuICBnZXQgaGFzQ2hpbGRyZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4ubGVuZ3RoID4gMDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGl0ZW0gY2hpbGRyZW4gc2hvdWxkIGJlIG9wZW4gaW5zdGFudGx5IGFmdGVyIHBvcG92ZXIgaXMgb3BlbmVkIGFuZCBub3Qgb24gaXRlbSBjbGljay9ob3ZlclxuICAgKi9cbiAgZ2V0IGlzQ2hpbGRyZW5PcGVuKCkge1xuICAgIHZhciBlO1xuICAgIHJldHVybiB0aGlzLnBhcmFtcyAhPT0gdm9pZCAwICYmIFwiY2hpbGRyZW5cIiBpbiB0aGlzLnBhcmFtcyAmJiAoKGUgPSB0aGlzLnBhcmFtcy5jaGlsZHJlbikgPT0gbnVsbCA/IHZvaWQgMCA6IGUuaXNPcGVuKSA9PT0gITA7XG4gIH1cbiAgLyoqXG4gICAqIFRydWUgaWYgaXRlbSBjaGlsZHJlbiBpdGVtcyBzaG91bGQgYmUgbmF2aWdhdGFibGUgdmlhIGtleWJvYXJkXG4gICAqL1xuICBnZXQgaXNDaGlsZHJlbkZsaXBwYWJsZSgpIHtcbiAgICB2YXIgZTtcbiAgICByZXR1cm4gISh0aGlzLnBhcmFtcyA9PT0gdm9pZCAwIHx8ICEoXCJjaGlsZHJlblwiIGluIHRoaXMucGFyYW1zKSB8fCAoKGUgPSB0aGlzLnBhcmFtcy5jaGlsZHJlbikgPT0gbnVsbCA/IHZvaWQgMCA6IGUuaXNGbGlwcGFibGUpID09PSAhMSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBpdGVtIGhhcyBjaGlsZHJlbiB0aGF0IHNob3VsZCBiZSBzZWFyY2hhYmxlXG4gICAqL1xuICBnZXQgaXNDaGlsZHJlblNlYXJjaGFibGUoKSB7XG4gICAgdmFyIGU7XG4gICAgcmV0dXJuIHRoaXMucGFyYW1zICE9PSB2b2lkIDAgJiYgXCJjaGlsZHJlblwiIGluIHRoaXMucGFyYW1zICYmICgoZSA9IHRoaXMucGFyYW1zLmNoaWxkcmVuKSA9PSBudWxsID8gdm9pZCAwIDogZS5zZWFyY2hhYmxlKSA9PT0gITA7XG4gIH1cbiAgLyoqXG4gICAqIFRydWUgaWYgcG9wb3ZlciBzaG91bGQgY2xvc2Ugb25jZSBpdGVtIGlzIGFjdGl2YXRlZFxuICAgKi9cbiAgZ2V0IGNsb3NlT25BY3RpdmF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJhbXMgIT09IHZvaWQgMCAmJiBcImNsb3NlT25BY3RpdmF0ZVwiIGluIHRoaXMucGFyYW1zICYmIHRoaXMucGFyYW1zLmNsb3NlT25BY3RpdmF0ZTtcbiAgfVxuICAvKipcbiAgICogVHJ1ZSBpZiBpdGVtIGlzIGFjdGl2ZVxuICAgKi9cbiAgZ2V0IGlzQWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLnBhcmFtcyA9PT0gdm9pZCAwIHx8ICEoXCJpc0FjdGl2ZVwiIGluIHRoaXMucGFyYW1zKSA/ICExIDogdHlwZW9mIHRoaXMucGFyYW1zLmlzQWN0aXZlID09IFwiZnVuY3Rpb25cIiA/IHRoaXMucGFyYW1zLmlzQWN0aXZlKCkgOiB0aGlzLnBhcmFtcy5pc0FjdGl2ZSA9PT0gITA7XG4gIH1cbn1cbmNvbnN0IFkgPSB0ZShcImNlLXBvcG92ZXItaXRlbVwiKSwgTCA9IHtcbiAgY29udGFpbmVyOiBZKCksXG4gIGFjdGl2ZTogWShudWxsLCBcImFjdGl2ZVwiKSxcbiAgZGlzYWJsZWQ6IFkobnVsbCwgXCJkaXNhYmxlZFwiKSxcbiAgZm9jdXNlZDogWShudWxsLCBcImZvY3VzZWRcIiksXG4gIGhpZGRlbjogWShudWxsLCBcImhpZGRlblwiKSxcbiAgY29uZmlybWF0aW9uU3RhdGU6IFkobnVsbCwgXCJjb25maXJtYXRpb25cIiksXG4gIG5vSG92ZXI6IFkobnVsbCwgXCJuby1ob3ZlclwiKSxcbiAgbm9Gb2N1czogWShudWxsLCBcIm5vLWZvY3VzXCIpLFxuICB0aXRsZTogWShcInRpdGxlXCIpLFxuICBzZWNvbmRhcnlUaXRsZTogWShcInNlY29uZGFyeS10aXRsZVwiKSxcbiAgaWNvbjogWShcImljb25cIiksXG4gIGljb25Ub29sOiBZKFwiaWNvblwiLCBcInRvb2xcIiksXG4gIGljb25DaGV2cm9uUmlnaHQ6IFkoXCJpY29uXCIsIFwiY2hldnJvbi1yaWdodFwiKSxcbiAgd29iYmxlQW5pbWF0aW9uOiB0ZShcIndvYmJsZVwiKSgpXG59O1xuY2xhc3Mgc2UgZXh0ZW5kcyBvdCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIHBvcG92ZXIgaXRlbSBpbnN0YW5jZVxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zIC0gcG9wb3ZlciBpdGVtIGNvbnN0cnVjdGlvbiBwYXJhbXNcbiAgICogQHBhcmFtIHJlbmRlclBhcmFtcyAtIHBvcG92ZXIgaXRlbSByZW5kZXIgcGFyYW1zLlxuICAgKiBUaGUgcGFyYW1ldGVycyB0aGF0IGFyZSBub3Qgc2V0IGJ5IHVzZXIgdmlhIHBvcG92ZXIgYXBpIGJ1dCByYXRoZXIgZGVwZW5kIG9uIHRlY2huaWNhbCBpbXBsZW1lbnRhdGlvblxuICAgKi9cbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHN1cGVyKGUpLCB0aGlzLnBhcmFtcyA9IGUsIHRoaXMubm9kZXMgPSB7XG4gICAgICByb290OiBudWxsLFxuICAgICAgaWNvbjogbnVsbFxuICAgIH0sIHRoaXMuY29uZmlybWF0aW9uU3RhdGUgPSBudWxsLCB0aGlzLnJlbW92ZVNwZWNpYWxGb2N1c0JlaGF2aW9yID0gKCkgPT4ge1xuICAgICAgdmFyIG87XG4gICAgICAobyA9IHRoaXMubm9kZXMucm9vdCkgPT0gbnVsbCB8fCBvLmNsYXNzTGlzdC5yZW1vdmUoTC5ub0ZvY3VzKTtcbiAgICB9LCB0aGlzLnJlbW92ZVNwZWNpYWxIb3ZlckJlaGF2aW9yID0gKCkgPT4ge1xuICAgICAgdmFyIG87XG4gICAgICAobyA9IHRoaXMubm9kZXMucm9vdCkgPT0gbnVsbCB8fCBvLmNsYXNzTGlzdC5yZW1vdmUoTC5ub0hvdmVyKTtcbiAgICB9LCB0aGlzLm9uRXJyb3JBbmltYXRpb25FbmQgPSAoKSA9PiB7XG4gICAgICB2YXIgbywgaTtcbiAgICAgIChvID0gdGhpcy5ub2Rlcy5pY29uKSA9PSBudWxsIHx8IG8uY2xhc3NMaXN0LnJlbW92ZShMLndvYmJsZUFuaW1hdGlvbiksIChpID0gdGhpcy5ub2Rlcy5pY29uKSA9PSBudWxsIHx8IGkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFuaW1hdGlvbmVuZFwiLCB0aGlzLm9uRXJyb3JBbmltYXRpb25FbmQpO1xuICAgIH0sIHRoaXMubm9kZXMucm9vdCA9IHRoaXMubWFrZShlLCB0KTtcbiAgfVxuICAvKipcbiAgICogVHJ1ZSBpZiBpdGVtIGlzIGRpc2FibGVkIGFuZCBoZW5jZSBub3QgY2xpY2thYmxlXG4gICAqL1xuICBnZXQgaXNEaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJhbXMuaXNEaXNhYmxlZCA9PT0gITA7XG4gIH1cbiAgLyoqXG4gICAqIEV4cG9zZXMgcG9wb3ZlciBpdGVtIHRvZ2dsZSBwYXJhbWV0ZXJcbiAgICovXG4gIGdldCB0b2dnbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyYW1zLnRvZ2dsZTtcbiAgfVxuICAvKipcbiAgICogSXRlbSB0aXRsZVxuICAgKi9cbiAgZ2V0IHRpdGxlKCkge1xuICAgIHJldHVybiB0aGlzLnBhcmFtcy50aXRsZTtcbiAgfVxuICAvKipcbiAgICogVHJ1ZSBpZiBjb25maXJtYXRpb24gc3RhdGUgaXMgZW5hYmxlZCBmb3IgcG9wb3ZlciBpdGVtXG4gICAqL1xuICBnZXQgaXNDb25maXJtYXRpb25TdGF0ZUVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlybWF0aW9uU3RhdGUgIT09IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFRydWUgaWYgaXRlbSBpcyBmb2N1c2VkIGluIGtleWJvYXJkIG5hdmlnYXRpb24gcHJvY2Vzc1xuICAgKi9cbiAgZ2V0IGlzRm9jdXNlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2Rlcy5yb290ID09PSBudWxsID8gITEgOiB0aGlzLm5vZGVzLnJvb3QuY2xhc3NMaXN0LmNvbnRhaW5zKEwuZm9jdXNlZCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgcG9wb3ZlciBpdGVtIHJvb3QgZWxlbWVudFxuICAgKi9cbiAgZ2V0RWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2Rlcy5yb290O1xuICB9XG4gIC8qKlxuICAgKiBDYWxsZWQgb24gcG9wb3ZlciBpdGVtIGNsaWNrXG4gICAqL1xuICBoYW5kbGVDbGljaygpIHtcbiAgICBpZiAodGhpcy5pc0NvbmZpcm1hdGlvblN0YXRlRW5hYmxlZCAmJiB0aGlzLmNvbmZpcm1hdGlvblN0YXRlICE9PSBudWxsKSB7XG4gICAgICB0aGlzLmFjdGl2YXRlT3JFbmFibGVDb25maXJtYXRpb25Nb2RlKHRoaXMuY29uZmlybWF0aW9uU3RhdGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmFjdGl2YXRlT3JFbmFibGVDb25maXJtYXRpb25Nb2RlKHRoaXMucGFyYW1zKTtcbiAgfVxuICAvKipcbiAgICogVG9nZ2xlcyBpdGVtIGFjdGl2ZSBzdGF0ZVxuICAgKlxuICAgKiBAcGFyYW0gaXNBY3RpdmUgLSB0cnVlIGlmIGl0ZW0gc2hvdWxkIHN0cmljdGx5IHNob3VsZCBiZWNvbWUgYWN0aXZlXG4gICAqL1xuICB0b2dnbGVBY3RpdmUoZSkge1xuICAgIHZhciB0O1xuICAgICh0ID0gdGhpcy5ub2Rlcy5yb290KSA9PSBudWxsIHx8IHQuY2xhc3NMaXN0LnRvZ2dsZShMLmFjdGl2ZSwgZSk7XG4gIH1cbiAgLyoqXG4gICAqIFRvZ2dsZXMgaXRlbSBoaWRkZW4gc3RhdGVcbiAgICpcbiAgICogQHBhcmFtIGlzSGlkZGVuIC0gdHJ1ZSBpZiBpdGVtIHNob3VsZCBiZSBoaWRkZW5cbiAgICovXG4gIHRvZ2dsZUhpZGRlbihlKSB7XG4gICAgdmFyIHQ7XG4gICAgKHQgPSB0aGlzLm5vZGVzLnJvb3QpID09IG51bGwgfHwgdC5jbGFzc0xpc3QudG9nZ2xlKEwuaGlkZGVuLCBlKTtcbiAgfVxuICAvKipcbiAgICogUmVzZXRzIHBvcG92ZXIgaXRlbSB0byBpdHMgb3JpZ2luYWwgc3RhdGVcbiAgICovXG4gIHJlc2V0KCkge1xuICAgIHRoaXMuaXNDb25maXJtYXRpb25TdGF0ZUVuYWJsZWQgJiYgdGhpcy5kaXNhYmxlQ29uZmlybWF0aW9uTW9kZSgpO1xuICB9XG4gIC8qKlxuICAgKiBNZXRob2QgY2FsbGVkIG9uY2UgaXRlbSBiZWNvbWVzIGZvY3VzZWQgZHVyaW5nIGtleWJvYXJkIG5hdmlnYXRpb25cbiAgICovXG4gIG9uRm9jdXMoKSB7XG4gICAgdGhpcy5kaXNhYmxlU3BlY2lhbEhvdmVyQW5kRm9jdXNCZWhhdmlvcigpO1xuICB9XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIEhUTUwgZWxlbWVudCBjb3JyZXNwb25kaW5nIHRvIHBvcG92ZXIgaXRlbSBwYXJhbXNcbiAgICpcbiAgICogQHBhcmFtIHBhcmFtcyAtIGl0ZW0gY29uc3RydWN0aW9uIHBhcmFtc1xuICAgKiBAcGFyYW0gcmVuZGVyUGFyYW1zIC0gcG9wb3ZlciBpdGVtIHJlbmRlciBwYXJhbXNcbiAgICovXG4gIG1ha2UoZSwgdCkge1xuICAgIHZhciBzLCByO1xuICAgIGNvbnN0IG8gPSAodCA9PSBudWxsID8gdm9pZCAwIDogdC53cmFwcGVyVGFnKSB8fCBcImRpdlwiLCBpID0gZC5tYWtlKG8sIEwuY29udGFpbmVyKTtcbiAgICByZXR1cm4gZS5uYW1lICYmIChpLmRhdGFzZXQuaXRlbU5hbWUgPSBlLm5hbWUpLCB0aGlzLm5vZGVzLmljb24gPSBkLm1ha2UoXCJkaXZcIiwgW0wuaWNvbiwgTC5pY29uVG9vbF0sIHtcbiAgICAgIGlubmVySFRNTDogZS5pY29uIHx8IEtvXG4gICAgfSksIGkuYXBwZW5kQ2hpbGQodGhpcy5ub2Rlcy5pY29uKSwgZS50aXRsZSAhPT0gdm9pZCAwICYmIGkuYXBwZW5kQ2hpbGQoZC5tYWtlKFwiZGl2XCIsIEwudGl0bGUsIHtcbiAgICAgIGlubmVySFRNTDogZS50aXRsZSB8fCBcIlwiXG4gICAgfSkpLCBlLnNlY29uZGFyeUxhYmVsICYmIGkuYXBwZW5kQ2hpbGQoZC5tYWtlKFwiZGl2XCIsIEwuc2Vjb25kYXJ5VGl0bGUsIHtcbiAgICAgIHRleHRDb250ZW50OiBlLnNlY29uZGFyeUxhYmVsXG4gICAgfSkpLCB0aGlzLmhhc0NoaWxkcmVuICYmIGkuYXBwZW5kQ2hpbGQoZC5tYWtlKFwiZGl2XCIsIFtMLmljb24sIEwuaWNvbkNoZXZyb25SaWdodF0sIHtcbiAgICAgIGlubmVySFRNTDogJG9cbiAgICB9KSksIHRoaXMuaXNBY3RpdmUgJiYgaS5jbGFzc0xpc3QuYWRkKEwuYWN0aXZlKSwgZS5pc0Rpc2FibGVkICYmIGkuY2xhc3NMaXN0LmFkZChMLmRpc2FibGVkKSwgZS5oaW50ICE9PSB2b2lkIDAgJiYgKChzID0gdCA9PSBudWxsID8gdm9pZCAwIDogdC5oaW50KSA9PSBudWxsID8gdm9pZCAwIDogcy5lbmFibGVkKSAhPT0gITEgJiYgdGhpcy5hZGRIaW50KGksIHtcbiAgICAgIC4uLmUuaGludCxcbiAgICAgIHBvc2l0aW9uOiAoKHIgPSB0ID09IG51bGwgPyB2b2lkIDAgOiB0LmhpbnQpID09IG51bGwgPyB2b2lkIDAgOiByLnBvc2l0aW9uKSB8fCBcInJpZ2h0XCJcbiAgICB9KSwgaTtcbiAgfVxuICAvKipcbiAgICogQWN0aXZhdGVzIGNvbmZpcm1hdGlvbiBtb2RlIGZvciB0aGUgaXRlbS5cbiAgICpcbiAgICogQHBhcmFtIG5ld1N0YXRlIC0gbmV3IHBvcG92ZXIgaXRlbSBwYXJhbXMgdGhhdCBzaG91bGQgYmUgYXBwbGllZFxuICAgKi9cbiAgZW5hYmxlQ29uZmlybWF0aW9uTW9kZShlKSB7XG4gICAgaWYgKHRoaXMubm9kZXMucm9vdCA9PT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0ge1xuICAgICAgLi4udGhpcy5wYXJhbXMsXG4gICAgICAuLi5lLFxuICAgICAgY29uZmlybWF0aW9uOiBcImNvbmZpcm1hdGlvblwiIGluIGUgPyBlLmNvbmZpcm1hdGlvbiA6IHZvaWQgMFxuICAgIH0sIG8gPSB0aGlzLm1ha2UodCk7XG4gICAgdGhpcy5ub2Rlcy5yb290LmlubmVySFRNTCA9IG8uaW5uZXJIVE1MLCB0aGlzLm5vZGVzLnJvb3QuY2xhc3NMaXN0LmFkZChMLmNvbmZpcm1hdGlvblN0YXRlKSwgdGhpcy5jb25maXJtYXRpb25TdGF0ZSA9IGUsIHRoaXMuZW5hYmxlU3BlY2lhbEhvdmVyQW5kRm9jdXNCZWhhdmlvcigpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGl0ZW0gdG8gaXRzIG9yaWdpbmFsIHN0YXRlXG4gICAqL1xuICBkaXNhYmxlQ29uZmlybWF0aW9uTW9kZSgpIHtcbiAgICBpZiAodGhpcy5ub2Rlcy5yb290ID09PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGUgPSB0aGlzLm1ha2UodGhpcy5wYXJhbXMpO1xuICAgIHRoaXMubm9kZXMucm9vdC5pbm5lckhUTUwgPSBlLmlubmVySFRNTCwgdGhpcy5ub2Rlcy5yb290LmNsYXNzTGlzdC5yZW1vdmUoTC5jb25maXJtYXRpb25TdGF0ZSksIHRoaXMuY29uZmlybWF0aW9uU3RhdGUgPSBudWxsLCB0aGlzLmRpc2FibGVTcGVjaWFsSG92ZXJBbmRGb2N1c0JlaGF2aW9yKCk7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZXMgc3BlY2lhbCBmb2N1cyBhbmQgaG92ZXIgYmVoYXZpb3IgZm9yIGl0ZW0gaW4gY29uZmlybWF0aW9uIHN0YXRlLlxuICAgKiBUaGlzIGlzIG5lZWRlZCB0byBwcmV2ZW50IGl0ZW0gZnJvbSBiZWluZyBoaWdobGlnaHRlZCBhcyBob3ZlcmVkL2ZvY3VzZWQganVzdCBhZnRlciBjbGljay5cbiAgICovXG4gIGVuYWJsZVNwZWNpYWxIb3ZlckFuZEZvY3VzQmVoYXZpb3IoKSB7XG4gICAgdmFyIGUsIHQsIG87XG4gICAgKGUgPSB0aGlzLm5vZGVzLnJvb3QpID09IG51bGwgfHwgZS5jbGFzc0xpc3QuYWRkKEwubm9Ib3ZlciksICh0ID0gdGhpcy5ub2Rlcy5yb290KSA9PSBudWxsIHx8IHQuY2xhc3NMaXN0LmFkZChMLm5vRm9jdXMpLCAobyA9IHRoaXMubm9kZXMucm9vdCkgPT0gbnVsbCB8fCBvLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIHRoaXMucmVtb3ZlU3BlY2lhbEhvdmVyQmVoYXZpb3IsIHsgb25jZTogITAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIERpc2FibGVzIHNwZWNpYWwgZm9jdXMgYW5kIGhvdmVyIGJlaGF2aW9yXG4gICAqL1xuICBkaXNhYmxlU3BlY2lhbEhvdmVyQW5kRm9jdXNCZWhhdmlvcigpIHtcbiAgICB2YXIgZTtcbiAgICB0aGlzLnJlbW92ZVNwZWNpYWxGb2N1c0JlaGF2aW9yKCksIHRoaXMucmVtb3ZlU3BlY2lhbEhvdmVyQmVoYXZpb3IoKSwgKGUgPSB0aGlzLm5vZGVzLnJvb3QpID09IG51bGwgfHwgZS5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCB0aGlzLnJlbW92ZVNwZWNpYWxIb3ZlckJlaGF2aW9yKTtcbiAgfVxuICAvKipcbiAgICogRXhlY3V0ZXMgaXRlbSdzIG9uQWN0aXZhdGUgY2FsbGJhY2sgaWYgdGhlIGl0ZW0gaGFzIG5vIGNvbmZpcm1hdGlvbiBjb25maWd1cmVkXG4gICAqXG4gICAqIEBwYXJhbSBpdGVtIC0gaXRlbSB0byBhY3RpdmF0ZSBvciBicmluZyB0byBjb25maXJtYXRpb24gbW9kZVxuICAgKi9cbiAgYWN0aXZhdGVPckVuYWJsZUNvbmZpcm1hdGlvbk1vZGUoZSkge1xuICAgIHZhciB0O1xuICAgIGlmICghKFwiY29uZmlybWF0aW9uXCIgaW4gZSkgfHwgZS5jb25maXJtYXRpb24gPT09IHZvaWQgMClcbiAgICAgIHRyeSB7XG4gICAgICAgICh0ID0gZS5vbkFjdGl2YXRlKSA9PSBudWxsIHx8IHQuY2FsbChlLCBlKSwgdGhpcy5kaXNhYmxlQ29uZmlybWF0aW9uTW9kZSgpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHRoaXMuYW5pbWF0ZUVycm9yKCk7XG4gICAgICB9XG4gICAgZWxzZVxuICAgICAgdGhpcy5lbmFibGVDb25maXJtYXRpb25Nb2RlKGUuY29uZmlybWF0aW9uKTtcbiAgfVxuICAvKipcbiAgICogQW5pbWF0ZXMgaXRlbSB3aGljaCBzeW1ib2xpemVzIHRoYXQgZXJyb3Igb2NjdXJlZCB3aGlsZSBleGVjdXRpbmcgJ29uQWN0aXZhdGUoKScgY2FsbGJhY2tcbiAgICovXG4gIGFuaW1hdGVFcnJvcigpIHtcbiAgICB2YXIgZSwgdCwgbztcbiAgICAoZSA9IHRoaXMubm9kZXMuaWNvbikgIT0gbnVsbCAmJiBlLmNsYXNzTGlzdC5jb250YWlucyhMLndvYmJsZUFuaW1hdGlvbikgfHwgKCh0ID0gdGhpcy5ub2Rlcy5pY29uKSA9PSBudWxsIHx8IHQuY2xhc3NMaXN0LmFkZChMLndvYmJsZUFuaW1hdGlvbiksIChvID0gdGhpcy5ub2Rlcy5pY29uKSA9PSBudWxsIHx8IG8uYWRkRXZlbnRMaXN0ZW5lcihcImFuaW1hdGlvbmVuZFwiLCB0aGlzLm9uRXJyb3JBbmltYXRpb25FbmQpKTtcbiAgfVxufVxuY29uc3QgVWUgPSB0ZShcImNlLXBvcG92ZXItaXRlbS1zZXBhcmF0b3JcIiksIGplID0ge1xuICBjb250YWluZXI6IFVlKCksXG4gIGxpbmU6IFVlKFwibGluZVwiKSxcbiAgaGlkZGVuOiBVZShudWxsLCBcImhpZGRlblwiKVxufTtcbmNsYXNzIFl0IGV4dGVuZHMgb3Qge1xuICAvKipcbiAgICogQ29uc3RydWN0cyB0aGUgaW5zdGFuY2VcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCksIHRoaXMubm9kZXMgPSB7XG4gICAgICByb290OiBkLm1ha2UoXCJkaXZcIiwgamUuY29udGFpbmVyKSxcbiAgICAgIGxpbmU6IGQubWFrZShcImRpdlwiLCBqZS5saW5lKVxuICAgIH0sIHRoaXMubm9kZXMucm9vdC5hcHBlbmRDaGlsZCh0aGlzLm5vZGVzLmxpbmUpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHBvcG92ZXIgc2VwYXJhdG9yIHJvb3QgZWxlbWVudFxuICAgKi9cbiAgZ2V0RWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2Rlcy5yb290O1xuICB9XG4gIC8qKlxuICAgKiBUb2dnbGVzIGl0ZW0gaGlkZGVuIHN0YXRlXG4gICAqXG4gICAqIEBwYXJhbSBpc0hpZGRlbiAtIHRydWUgaWYgaXRlbSBzaG91bGQgYmUgaGlkZGVuXG4gICAqL1xuICB0b2dnbGVIaWRkZW4oZSkge1xuICAgIHZhciB0O1xuICAgICh0ID0gdGhpcy5ub2Rlcy5yb290KSA9PSBudWxsIHx8IHQuY2xhc3NMaXN0LnRvZ2dsZShqZS5oaWRkZW4sIGUpO1xuICB9XG59XG52YXIgQSA9IC8qIEBfX1BVUkVfXyAqLyAoKG4pID0+IChuLkRlZmF1bHQgPSBcImRlZmF1bHRcIiwgbi5TZXBhcmF0b3IgPSBcInNlcGFyYXRvclwiLCBuLkh0bWwgPSBcImh0bWxcIiwgbikpKEEgfHwge30pLCBaID0gLyogQF9fUFVSRV9fICovICgobikgPT4gKG4uQ2xvc2VkID0gXCJjbG9zZWRcIiwgbi5DbG9zZWRPbkFjdGl2YXRlID0gXCJjbG9zZWQtb24tYWN0aXZhdGVcIiwgbikpKFogfHwge30pO1xuY29uc3QgSCA9IHRlKFwiY2UtcG9wb3ZlclwiKSwgTiA9IHtcbiAgcG9wb3ZlcjogSCgpLFxuICBwb3BvdmVyQ29udGFpbmVyOiBIKFwiY29udGFpbmVyXCIpLFxuICBwb3BvdmVyT3BlblRvcDogSChudWxsLCBcIm9wZW4tdG9wXCIpLFxuICBwb3BvdmVyT3BlbkxlZnQ6IEgobnVsbCwgXCJvcGVuLWxlZnRcIiksXG4gIHBvcG92ZXJPcGVuZWQ6IEgobnVsbCwgXCJvcGVuZWRcIiksXG4gIHNlYXJjaDogSChcInNlYXJjaFwiKSxcbiAgbm90aGluZ0ZvdW5kTWVzc2FnZTogSChcIm5vdGhpbmctZm91bmQtbWVzc2FnZVwiKSxcbiAgbm90aGluZ0ZvdW5kTWVzc2FnZURpc3BsYXllZDogSChcIm5vdGhpbmctZm91bmQtbWVzc2FnZVwiLCBcImRpc3BsYXllZFwiKSxcbiAgaXRlbXM6IEgoXCJpdGVtc1wiKSxcbiAgb3ZlcmxheTogSChcIm92ZXJsYXlcIiksXG4gIG92ZXJsYXlIaWRkZW46IEgoXCJvdmVybGF5XCIsIFwiaGlkZGVuXCIpLFxuICBwb3BvdmVyTmVzdGVkOiBIKG51bGwsIFwibmVzdGVkXCIpLFxuICBnZXRQb3BvdmVyTmVzdGVkQ2xhc3M6IChuKSA9PiBIKG51bGwsIGBuZXN0ZWQtbGV2ZWwtJHtuLnRvU3RyaW5nKCl9YCksXG4gIHBvcG92ZXJJbmxpbmU6IEgobnVsbCwgXCJpbmxpbmVcIiksXG4gIHBvcG92ZXJIZWFkZXI6IEgoXCJoZWFkZXJcIilcbn07XG52YXIgY2UgPSAvKiBAX19QVVJFX18gKi8gKChuKSA9PiAobi5OZXN0aW5nTGV2ZWwgPSBcIi0tbmVzdGluZy1sZXZlbFwiLCBuLlBvcG92ZXJIZWlnaHQgPSBcIi0tcG9wb3Zlci1oZWlnaHRcIiwgbi5JbmxpbmVQb3BvdmVyV2lkdGggPSBcIi0taW5saW5lLXBvcG92ZXItd2lkdGhcIiwgbi5UcmlnZ2VySXRlbUxlZnQgPSBcIi0tdHJpZ2dlci1pdGVtLWxlZnRcIiwgbi5UcmlnZ2VySXRlbVRvcCA9IFwiLS10cmlnZ2VyLWl0ZW0tdG9wXCIsIG4pKShjZSB8fCB7fSk7XG5jb25zdCB5dCA9IHRlKFwiY2UtcG9wb3Zlci1pdGVtLWh0bWxcIiksIEV0ID0ge1xuICByb290OiB5dCgpLFxuICBoaWRkZW46IHl0KG51bGwsIFwiaGlkZGVuXCIpXG59O1xuY2xhc3MgeWUgZXh0ZW5kcyBvdCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIHRoZSBpbnN0YW5jZVxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zIOKAkyBpbnN0YW5jZSBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSByZW5kZXJQYXJhbXMg4oCTIHBvcG92ZXIgaXRlbSByZW5kZXIgcGFyYW1zLlxuICAgKiBUaGUgcGFyYW1ldGVycyB0aGF0IGFyZSBub3Qgc2V0IGJ5IHVzZXIgdmlhIHBvcG92ZXIgYXBpIGJ1dCByYXRoZXIgZGVwZW5kIG9uIHRlY2huaWNhbCBpbXBsZW1lbnRhdGlvblxuICAgKi9cbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHZhciBvLCBpO1xuICAgIHN1cGVyKGUpLCB0aGlzLm5vZGVzID0ge1xuICAgICAgcm9vdDogZC5tYWtlKFwiZGl2XCIsIEV0LnJvb3QpXG4gICAgfSwgdGhpcy5ub2Rlcy5yb290LmFwcGVuZENoaWxkKGUuZWxlbWVudCksIGUubmFtZSAmJiAodGhpcy5ub2Rlcy5yb290LmRhdGFzZXQuaXRlbU5hbWUgPSBlLm5hbWUpLCBlLmhpbnQgIT09IHZvaWQgMCAmJiAoKG8gPSB0ID09IG51bGwgPyB2b2lkIDAgOiB0LmhpbnQpID09IG51bGwgPyB2b2lkIDAgOiBvLmVuYWJsZWQpICE9PSAhMSAmJiB0aGlzLmFkZEhpbnQodGhpcy5ub2Rlcy5yb290LCB7XG4gICAgICAuLi5lLmhpbnQsXG4gICAgICBwb3NpdGlvbjogKChpID0gdCA9PSBudWxsID8gdm9pZCAwIDogdC5oaW50KSA9PSBudWxsID8gdm9pZCAwIDogaS5wb3NpdGlvbikgfHwgXCJyaWdodFwiXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgcG9wb3ZlciBpdGVtIHJvb3QgZWxlbWVudFxuICAgKi9cbiAgZ2V0RWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2Rlcy5yb290O1xuICB9XG4gIC8qKlxuICAgKiBUb2dnbGVzIGl0ZW0gaGlkZGVuIHN0YXRlXG4gICAqXG4gICAqIEBwYXJhbSBpc0hpZGRlbiAtIHRydWUgaWYgaXRlbSBzaG91bGQgYmUgaGlkZGVuXG4gICAqL1xuICB0b2dnbGVIaWRkZW4oZSkge1xuICAgIHZhciB0O1xuICAgICh0ID0gdGhpcy5ub2Rlcy5yb290KSA9PSBudWxsIHx8IHQuY2xhc3NMaXN0LnRvZ2dsZShFdC5oaWRkZW4sIGUpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGxpc3Qgb2YgYnV0dG9ucyBhbmQgaW5wdXRzIGluc2lkZSBjdXN0b20gY29udGVudFxuICAgKi9cbiAgZ2V0Q29udHJvbHMoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMubm9kZXMucm9vdC5xdWVyeVNlbGVjdG9yQWxsKFxuICAgICAgYGJ1dHRvbiwgJHtkLmFsbElucHV0c1NlbGVjdG9yfWBcbiAgICApO1xuICAgIHJldHVybiBBcnJheS5mcm9tKGUpO1xuICB9XG59XG5jbGFzcyBXdCBleHRlbmRzIEJlIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgdGhlIGluc3RhbmNlXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBwb3BvdmVyIGNvbnN0cnVjdGlvbiBwYXJhbXNcbiAgICogQHBhcmFtIGl0ZW1zUmVuZGVyUGFyYW1zIC0gcG9wb3ZlciBpdGVtIHJlbmRlciBwYXJhbXMuXG4gICAqIFRoZSBwYXJhbWV0ZXJzIHRoYXQgYXJlIG5vdCBzZXQgYnkgdXNlciB2aWEgcG9wb3ZlciBhcGkgYnV0IHJhdGhlciBkZXBlbmQgb24gdGVjaG5pY2FsIGltcGxlbWVudGF0aW9uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlLCB0ID0ge30pIHtcbiAgICBzdXBlcigpLCB0aGlzLnBhcmFtcyA9IGUsIHRoaXMuaXRlbXNSZW5kZXJQYXJhbXMgPSB0LCB0aGlzLmxpc3RlbmVycyA9IG5ldyBUZSgpLCB0aGlzLm1lc3NhZ2VzID0ge1xuICAgICAgbm90aGluZ0ZvdW5kOiBcIk5vdGhpbmcgZm91bmRcIixcbiAgICAgIHNlYXJjaDogXCJTZWFyY2hcIlxuICAgIH0sIHRoaXMuaXRlbXMgPSB0aGlzLmJ1aWxkSXRlbXMoZS5pdGVtcyksIGUubWVzc2FnZXMgJiYgKHRoaXMubWVzc2FnZXMgPSB7XG4gICAgICAuLi50aGlzLm1lc3NhZ2VzLFxuICAgICAgLi4uZS5tZXNzYWdlc1xuICAgIH0pLCB0aGlzLm5vZGVzID0ge30sIHRoaXMubm9kZXMucG9wb3ZlckNvbnRhaW5lciA9IGQubWFrZShcImRpdlwiLCBbTi5wb3BvdmVyQ29udGFpbmVyXSksIHRoaXMubm9kZXMubm90aGluZ0ZvdW5kTWVzc2FnZSA9IGQubWFrZShcImRpdlwiLCBbTi5ub3RoaW5nRm91bmRNZXNzYWdlXSwge1xuICAgICAgdGV4dENvbnRlbnQ6IHRoaXMubWVzc2FnZXMubm90aGluZ0ZvdW5kXG4gICAgfSksIHRoaXMubm9kZXMucG9wb3ZlckNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLm5vZGVzLm5vdGhpbmdGb3VuZE1lc3NhZ2UpLCB0aGlzLm5vZGVzLml0ZW1zID0gZC5tYWtlKFwiZGl2XCIsIFtOLml0ZW1zXSksIHRoaXMuaXRlbXMuZm9yRWFjaCgobykgPT4ge1xuICAgICAgY29uc3QgaSA9IG8uZ2V0RWxlbWVudCgpO1xuICAgICAgaSAhPT0gbnVsbCAmJiB0aGlzLm5vZGVzLml0ZW1zLmFwcGVuZENoaWxkKGkpO1xuICAgIH0pLCB0aGlzLm5vZGVzLnBvcG92ZXJDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5ub2Rlcy5pdGVtcyksIHRoaXMubGlzdGVuZXJzLm9uKHRoaXMubm9kZXMucG9wb3ZlckNvbnRhaW5lciwgXCJjbGlja1wiLCAobykgPT4gdGhpcy5oYW5kbGVDbGljayhvKSksIHRoaXMubm9kZXMucG9wb3ZlciA9IGQubWFrZShcImRpdlwiLCBbXG4gICAgICBOLnBvcG92ZXIsXG4gICAgICB0aGlzLnBhcmFtcy5jbGFzc1xuICAgIF0pLCB0aGlzLm5vZGVzLnBvcG92ZXIuYXBwZW5kQ2hpbGQodGhpcy5ub2Rlcy5wb3BvdmVyQ29udGFpbmVyKTtcbiAgfVxuICAvKipcbiAgICogTGlzdCBvZiBkZWZhdWx0IHBvcG92ZXIgaXRlbXMgdGhhdCBhcmUgc2VhcmNoYWJsZSBhbmQgbWF5IGhhdmUgY29uZmlybWF0aW9uIHN0YXRlXG4gICAqL1xuICBnZXQgaXRlbXNEZWZhdWx0KCkge1xuICAgIHJldHVybiB0aGlzLml0ZW1zLmZpbHRlcigoZSkgPT4gZSBpbnN0YW5jZW9mIHNlKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBIVE1MIGVsZW1lbnQgY29ycmVzcG9uZGluZyB0byB0aGUgcG9wb3ZlclxuICAgKi9cbiAgZ2V0RWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2Rlcy5wb3BvdmVyO1xuICB9XG4gIC8qKlxuICAgKiBPcGVuIHBvcG92ZXJcbiAgICovXG4gIHNob3coKSB7XG4gICAgdGhpcy5ub2Rlcy5wb3BvdmVyLmNsYXNzTGlzdC5hZGQoTi5wb3BvdmVyT3BlbmVkKSwgdGhpcy5zZWFyY2ggIT09IHZvaWQgMCAmJiB0aGlzLnNlYXJjaC5mb2N1cygpO1xuICB9XG4gIC8qKlxuICAgKiBDbG9zZXMgcG9wb3ZlclxuICAgKi9cbiAgaGlkZSgpIHtcbiAgICB0aGlzLm5vZGVzLnBvcG92ZXIuY2xhc3NMaXN0LnJlbW92ZShOLnBvcG92ZXJPcGVuZWQpLCB0aGlzLm5vZGVzLnBvcG92ZXIuY2xhc3NMaXN0LnJlbW92ZShOLnBvcG92ZXJPcGVuVG9wKSwgdGhpcy5pdGVtc0RlZmF1bHQuZm9yRWFjaCgoZSkgPT4gZS5yZXNldCgpKSwgdGhpcy5zZWFyY2ggIT09IHZvaWQgMCAmJiB0aGlzLnNlYXJjaC5jbGVhcigpLCB0aGlzLmVtaXQoWi5DbG9zZWQpO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhcnMgbWVtb3J5XG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHZhciBlO1xuICAgIHRoaXMuaXRlbXMuZm9yRWFjaCgodCkgPT4gdC5kZXN0cm95KCkpLCB0aGlzLm5vZGVzLnBvcG92ZXIucmVtb3ZlKCksIHRoaXMubGlzdGVuZXJzLnJlbW92ZUFsbCgpLCAoZSA9IHRoaXMuc2VhcmNoKSA9PSBudWxsIHx8IGUuZGVzdHJveSgpO1xuICB9XG4gIC8qKlxuICAgKiBMb29rcyBmb3IgdGhlIGl0ZW0gYnkgbmFtZSBhbmQgaW1pdGF0ZXMgY2xpY2sgb24gaXRcbiAgICpcbiAgICogQHBhcmFtIG5hbWUgLSBuYW1lIG9mIHRoZSBpdGVtIHRvIGFjdGl2YXRlXG4gICAqL1xuICBhY3RpdmF0ZUl0ZW1CeU5hbWUoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLml0ZW1zLmZpbmQoKG8pID0+IG8ubmFtZSA9PT0gZSk7XG4gICAgdGhpcy5oYW5kbGVJdGVtQ2xpY2sodCk7XG4gIH1cbiAgLyoqXG4gICAqIEZhY3RvcnkgbWV0aG9kIGZvciBjcmVhdGluZyBwb3BvdmVyIGl0ZW1zXG4gICAqXG4gICAqIEBwYXJhbSBpdGVtcyAtIGxpc3Qgb2YgaXRlbXMgcGFyYW1zXG4gICAqL1xuICBidWlsZEl0ZW1zKGUpIHtcbiAgICByZXR1cm4gZS5tYXAoKHQpID0+IHtcbiAgICAgIHN3aXRjaCAodC50eXBlKSB7XG4gICAgICAgIGNhc2UgQS5TZXBhcmF0b3I6XG4gICAgICAgICAgcmV0dXJuIG5ldyBZdCgpO1xuICAgICAgICBjYXNlIEEuSHRtbDpcbiAgICAgICAgICByZXR1cm4gbmV3IHllKHQsIHRoaXMuaXRlbXNSZW5kZXJQYXJhbXNbQS5IdG1sXSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIG5ldyBzZSh0LCB0aGlzLml0ZW1zUmVuZGVyUGFyYW1zW0EuRGVmYXVsdF0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgcG9wb3ZlciBpdGVtIHRoYXQgaXMgdGhlIHRhcmdldCBvZiB0aGUgc3BlY2lmaWVkIGV2ZW50XG4gICAqXG4gICAqIEBwYXJhbSBldmVudCAtIGV2ZW50IHRvIHJldHJpZXZlIHBvcG92ZXIgaXRlbSBmcm9tXG4gICAqL1xuICBnZXRUYXJnZXRJdGVtKGUpIHtcbiAgICByZXR1cm4gdGhpcy5pdGVtcy5maWx0ZXIoKHQpID0+IHQgaW5zdGFuY2VvZiBzZSB8fCB0IGluc3RhbmNlb2YgeWUpLmZpbmQoKHQpID0+IHtcbiAgICAgIGNvbnN0IG8gPSB0LmdldEVsZW1lbnQoKTtcbiAgICAgIHJldHVybiBvID09PSBudWxsID8gITEgOiBlLmNvbXBvc2VkUGF0aCgpLmluY2x1ZGVzKG8pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIHBvcG92ZXIgaXRlbSBjbGlja1xuICAgKlxuICAgKiBAcGFyYW0gaXRlbSAtIGl0ZW0gdG8gaGFuZGxlIGNsaWNrIG9mXG4gICAqL1xuICBoYW5kbGVJdGVtQ2xpY2soZSkge1xuICAgIGlmICghKFwiaXNEaXNhYmxlZFwiIGluIGUgJiYgZS5pc0Rpc2FibGVkKSkge1xuICAgICAgaWYgKGUuaGFzQ2hpbGRyZW4pIHtcbiAgICAgICAgdGhpcy5zaG93TmVzdGVkSXRlbXMoZSksIFwiaGFuZGxlQ2xpY2tcIiBpbiBlICYmIHR5cGVvZiBlLmhhbmRsZUNsaWNrID09IFwiZnVuY3Rpb25cIiAmJiBlLmhhbmRsZUNsaWNrKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuaXRlbXNEZWZhdWx0LmZpbHRlcigodCkgPT4gdCAhPT0gZSkuZm9yRWFjaCgodCkgPT4gdC5yZXNldCgpKSwgXCJoYW5kbGVDbGlja1wiIGluIGUgJiYgdHlwZW9mIGUuaGFuZGxlQ2xpY2sgPT0gXCJmdW5jdGlvblwiICYmIGUuaGFuZGxlQ2xpY2soKSwgdGhpcy50b2dnbGVJdGVtQWN0aXZlbmVzc0lmTmVlZGVkKGUpLCBlLmNsb3NlT25BY3RpdmF0ZSAmJiAodGhpcy5oaWRlKCksIHRoaXMuZW1pdChaLkNsb3NlZE9uQWN0aXZhdGUpKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZXMgY2xpY2tzIGluc2lkZSBwb3BvdmVyXG4gICAqXG4gICAqIEBwYXJhbSBldmVudCAtIGl0ZW0gdG8gaGFuZGxlIGNsaWNrIG9mXG4gICAqL1xuICBoYW5kbGVDbGljayhlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZ2V0VGFyZ2V0SXRlbShlKTtcbiAgICB0ICE9PSB2b2lkIDAgJiYgdGhpcy5oYW5kbGVJdGVtQ2xpY2sodCk7XG4gIH1cbiAgLyoqXG4gICAqIC0gVG9nZ2xlcyBpdGVtIGFjdGl2ZSBzdGF0ZSwgaWYgY2xpY2tlZCBwb3BvdmVyIGl0ZW0gaGFzIHByb3BlcnR5ICd0b2dnbGUnIHNldCB0byB0cnVlLlxuICAgKlxuICAgKiAtIFBlcmZvcm1zIHJhZGlvYnV0dG9uLWxpa2UgYmVoYXZpb3IgaWYgdGhlIGl0ZW0gaGFzIHByb3BlcnR5ICd0b2dnbGUnIHNldCB0byBzdHJpbmcga2V5LlxuICAgKiAoQWxsIHRoZSBvdGhlciBpdGVtcyB3aXRoIHRoZSBzYW1lIGtleSBnZXQgaW5hY3RpdmUsIGFuZCB0aGUgaXRlbSBnZXRzIGFjdGl2ZSlcbiAgICpcbiAgICogQHBhcmFtIGNsaWNrZWRJdGVtIC0gcG9wb3ZlciBpdGVtIHRoYXQgd2FzIGNsaWNrZWRcbiAgICovXG4gIHRvZ2dsZUl0ZW1BY3RpdmVuZXNzSWZOZWVkZWQoZSkge1xuICAgIGlmIChlIGluc3RhbmNlb2Ygc2UgJiYgKGUudG9nZ2xlID09PSAhMCAmJiBlLnRvZ2dsZUFjdGl2ZSgpLCB0eXBlb2YgZS50b2dnbGUgPT0gXCJzdHJpbmdcIikpIHtcbiAgICAgIGNvbnN0IHQgPSB0aGlzLml0ZW1zRGVmYXVsdC5maWx0ZXIoKG8pID0+IG8udG9nZ2xlID09PSBlLnRvZ2dsZSk7XG4gICAgICBpZiAodC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgZS50b2dnbGVBY3RpdmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdC5mb3JFYWNoKChvKSA9PiB7XG4gICAgICAgIG8udG9nZ2xlQWN0aXZlKG8gPT09IGUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG52YXIgUGUgPSAvKiBAX19QVVJFX18gKi8gKChuKSA9PiAobi5TZWFyY2ggPSBcInNlYXJjaFwiLCBuKSkoUGUgfHwge30pO1xuY29uc3QgJGUgPSB0ZShcImNkeC1zZWFyY2gtZmllbGRcIiksIFllID0ge1xuICB3cmFwcGVyOiAkZSgpLFxuICBpY29uOiAkZShcImljb25cIiksXG4gIGlucHV0OiAkZShcImlucHV0XCIpXG59O1xuY2xhc3MgcmkgZXh0ZW5kcyBCZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIGF2YWlsYWJsZSBjb25maWdcbiAgICogQHBhcmFtIG9wdGlvbnMuaXRlbXMgLSBzZWFyY2hhYmxlIGl0ZW1zIGxpc3RcbiAgICogQHBhcmFtIG9wdGlvbnMucGxhY2Vob2xkZXIgLSBpbnB1dCBwbGFjZWhvbGRlclxuICAgKi9cbiAgY29uc3RydWN0b3IoeyBpdGVtczogZSwgcGxhY2Vob2xkZXI6IHQgfSkge1xuICAgIHN1cGVyKCksIHRoaXMubGlzdGVuZXJzID0gbmV3IFRlKCksIHRoaXMuaXRlbXMgPSBlLCB0aGlzLndyYXBwZXIgPSBkLm1ha2UoXCJkaXZcIiwgWWUud3JhcHBlcik7XG4gICAgY29uc3QgbyA9IGQubWFrZShcImRpdlwiLCBZZS5pY29uLCB7XG4gICAgICBpbm5lckhUTUw6IFpvXG4gICAgfSk7XG4gICAgdGhpcy5pbnB1dCA9IGQubWFrZShcImlucHV0XCIsIFllLmlucHV0LCB7XG4gICAgICBwbGFjZWhvbGRlcjogdCxcbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBwcmV2ZW50IGZvY3VzaW5nIG9uIHRoZSBpbnB1dCBieSBUYWIga2V5XG4gICAgICAgKiAoUG9wb3ZlciBpbiB0aGUgVG9vbGJhciBsYXlzIGJlbG93IHRoZSBibG9ja3MsXG4gICAgICAgKiBzbyBUYWIgaW4gdGhlIGxhc3QgYmxvY2sgd2lsbCBmb2N1cyB0aGlzIGhpZGRlbiBpbnB1dCBpZiB0aGlzIHByb3BlcnR5IGlzIG5vdCBzZXQpXG4gICAgICAgKi9cbiAgICAgIHRhYkluZGV4OiAtMVxuICAgIH0pLCB0aGlzLndyYXBwZXIuYXBwZW5kQ2hpbGQobyksIHRoaXMud3JhcHBlci5hcHBlbmRDaGlsZCh0aGlzLmlucHV0KSwgdGhpcy5saXN0ZW5lcnMub24odGhpcy5pbnB1dCwgXCJpbnB1dFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLnNlYXJjaFF1ZXJ5ID0gdGhpcy5pbnB1dC52YWx1ZSwgdGhpcy5lbWl0KFBlLlNlYXJjaCwge1xuICAgICAgICBxdWVyeTogdGhpcy5zZWFyY2hRdWVyeSxcbiAgICAgICAgaXRlbXM6IHRoaXMuZm91bmRJdGVtc1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgc2VhcmNoIGZpZWxkIGVsZW1lbnRcbiAgICovXG4gIGdldEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMud3JhcHBlcjtcbiAgfVxuICAvKipcbiAgICogU2V0cyBmb2N1cyB0byB0aGUgaW5wdXRcbiAgICovXG4gIGZvY3VzKCkge1xuICAgIHRoaXMuaW5wdXQuZm9jdXMoKTtcbiAgfVxuICAvKipcbiAgICogQ2xlYXJzIHNlYXJjaCBxdWVyeSBhbmQgcmVzdWx0c1xuICAgKi9cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5pbnB1dC52YWx1ZSA9IFwiXCIsIHRoaXMuc2VhcmNoUXVlcnkgPSBcIlwiLCB0aGlzLmVtaXQoUGUuU2VhcmNoLCB7XG4gICAgICBxdWVyeTogXCJcIixcbiAgICAgIGl0ZW1zOiB0aGlzLmZvdW5kSXRlbXNcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ2xlYXJzIG1lbW9yeVxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmxpc3RlbmVycy5yZW1vdmVBbGwoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBsaXN0IG9mIGZvdW5kIGl0ZW1zIGZvciB0aGUgY3VycmVudCBzZWFyY2ggcXVlcnlcbiAgICovXG4gIGdldCBmb3VuZEl0ZW1zKCkge1xuICAgIHJldHVybiB0aGlzLml0ZW1zLmZpbHRlcigoZSkgPT4gdGhpcy5jaGVja0l0ZW0oZSkpO1xuICB9XG4gIC8qKlxuICAgKiBDb250YWlucyBsb2dpYyBmb3IgY2hlY2tpbmcgd2hldGhlciBwYXNzZWQgaXRlbSBjb25mb3JtcyB0aGUgc2VhcmNoIHF1ZXJ5XG4gICAqXG4gICAqIEBwYXJhbSBpdGVtIC0gaXRlbSB0byBiZSBjaGVja2VkXG4gICAqL1xuICBjaGVja0l0ZW0oZSkge1xuICAgIHZhciBpLCBzO1xuICAgIGNvbnN0IHQgPSAoKGkgPSBlLnRpdGxlKSA9PSBudWxsID8gdm9pZCAwIDogaS50b0xvd2VyQ2FzZSgpKSB8fCBcIlwiLCBvID0gKHMgPSB0aGlzLnNlYXJjaFF1ZXJ5KSA9PSBudWxsID8gdm9pZCAwIDogcy50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiBvICE9PSB2b2lkIDAgPyB0LmluY2x1ZGVzKG8pIDogITE7XG4gIH1cbn1cbnZhciBsaSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgYWkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLCBjaSA9IChuLCBlLCB0LCBvKSA9PiB7XG4gIGZvciAodmFyIGkgPSBvID4gMSA/IHZvaWQgMCA6IG8gPyBhaShlLCB0KSA6IGUsIHMgPSBuLmxlbmd0aCAtIDEsIHI7IHMgPj0gMDsgcy0tKVxuICAgIChyID0gbltzXSkgJiYgKGkgPSAobyA/IHIoZSwgdCwgaSkgOiByKGkpKSB8fCBpKTtcbiAgcmV0dXJuIG8gJiYgaSAmJiBsaShlLCB0LCBpKSwgaTtcbn07XG5jb25zdCBLdCA9IGNsYXNzIFh0IGV4dGVuZHMgV3Qge1xuICAvKipcbiAgICogQ29uc3RydWN0IHRoZSBpbnN0YW5jZVxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zIC0gcG9wb3ZlciBwYXJhbXNcbiAgICogQHBhcmFtIGl0ZW1zUmVuZGVyUGFyYW1zIOKAk8KgcG9wb3ZlciBpdGVtIHJlbmRlciBwYXJhbXMuXG4gICAqIFRoZSBwYXJhbWV0ZXJzIHRoYXQgYXJlIG5vdCBzZXQgYnkgdXNlciB2aWEgcG9wb3ZlciBhcGkgYnV0IHJhdGhlciBkZXBlbmQgb24gdGVjaG5pY2FsIGltcGxlbWVudGF0aW9uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlLCB0KSB7XG4gICAgc3VwZXIoZSwgdCksIHRoaXMubmVzdGluZ0xldmVsID0gMCwgdGhpcy5uZXN0ZWRQb3BvdmVyVHJpZ2dlckl0ZW0gPSBudWxsLCB0aGlzLnByZXZpb3VzbHlIb3ZlcmVkSXRlbSA9IG51bGwsIHRoaXMuc2NvcGVFbGVtZW50ID0gZG9jdW1lbnQuYm9keSwgdGhpcy5oaWRlID0gKCkgPT4ge1xuICAgICAgdmFyIG87XG4gICAgICBzdXBlci5oaWRlKCksIHRoaXMuZGVzdHJveU5lc3RlZFBvcG92ZXJJZkV4aXN0cygpLCAobyA9IHRoaXMuZmxpcHBlcikgPT0gbnVsbCB8fCBvLmRlYWN0aXZhdGUoKSwgdGhpcy5wcmV2aW91c2x5SG92ZXJlZEl0ZW0gPSBudWxsO1xuICAgIH0sIHRoaXMub25GbGlwID0gKCkgPT4ge1xuICAgICAgY29uc3QgbyA9IHRoaXMuaXRlbXNEZWZhdWx0LmZpbmQoKGkpID0+IGkuaXNGb2N1c2VkKTtcbiAgICAgIG8gPT0gbnVsbCB8fCBvLm9uRm9jdXMoKTtcbiAgICB9LCB0aGlzLm9uU2VhcmNoID0gKG8pID0+IHtcbiAgICAgIHZhciBsO1xuICAgICAgY29uc3QgaSA9IG8ucXVlcnkgPT09IFwiXCIsIHMgPSBvLml0ZW1zLmxlbmd0aCA9PT0gMDtcbiAgICAgIHRoaXMuaXRlbXMuZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgICBsZXQgYyA9ICExO1xuICAgICAgICBhIGluc3RhbmNlb2Ygc2UgPyBjID0gIW8uaXRlbXMuaW5jbHVkZXMoYSkgOiAoYSBpbnN0YW5jZW9mIFl0IHx8IGEgaW5zdGFuY2VvZiB5ZSkgJiYgKGMgPSBzIHx8ICFpKSwgYS50b2dnbGVIaWRkZW4oYyk7XG4gICAgICB9KSwgdGhpcy50b2dnbGVOb3RoaW5nRm91bmRNZXNzYWdlKHMpO1xuICAgICAgY29uc3QgciA9IG8ucXVlcnkgPT09IFwiXCIgPyB0aGlzLmZsaXBwYWJsZUVsZW1lbnRzIDogby5pdGVtcy5tYXAoKGEpID0+IGEuZ2V0RWxlbWVudCgpKTtcbiAgICAgIChsID0gdGhpcy5mbGlwcGVyKSAhPSBudWxsICYmIGwuaXNBY3RpdmF0ZWQgJiYgKHRoaXMuZmxpcHBlci5kZWFjdGl2YXRlKCksIHRoaXMuZmxpcHBlci5hY3RpdmF0ZShyKSk7XG4gICAgfSwgZS5uZXN0aW5nTGV2ZWwgIT09IHZvaWQgMCAmJiAodGhpcy5uZXN0aW5nTGV2ZWwgPSBlLm5lc3RpbmdMZXZlbCksIHRoaXMubmVzdGluZ0xldmVsID4gMCAmJiB0aGlzLm5vZGVzLnBvcG92ZXIuY2xhc3NMaXN0LmFkZChOLnBvcG92ZXJOZXN0ZWQpLCBlLnNjb3BlRWxlbWVudCAhPT0gdm9pZCAwICYmICh0aGlzLnNjb3BlRWxlbWVudCA9IGUuc2NvcGVFbGVtZW50KSwgdGhpcy5ub2Rlcy5wb3BvdmVyQ29udGFpbmVyICE9PSBudWxsICYmIHRoaXMubGlzdGVuZXJzLm9uKHRoaXMubm9kZXMucG9wb3ZlckNvbnRhaW5lciwgXCJtb3VzZW92ZXJcIiwgKG8pID0+IHRoaXMuaGFuZGxlSG92ZXIobykpLCBlLnNlYXJjaGFibGUgJiYgdGhpcy5hZGRTZWFyY2goKSwgZS5mbGlwcGFibGUgIT09ICExICYmICh0aGlzLmZsaXBwZXIgPSBuZXcgcmUoe1xuICAgICAgaXRlbXM6IHRoaXMuZmxpcHBhYmxlRWxlbWVudHMsXG4gICAgICBmb2N1c2VkSXRlbUNsYXNzOiBMLmZvY3VzZWQsXG4gICAgICBhbGxvd2VkS2V5czogW1xuICAgICAgICB3LlRBQixcbiAgICAgICAgdy5VUCxcbiAgICAgICAgdy5ET1dOLFxuICAgICAgICB3LkVOVEVSXG4gICAgICBdXG4gICAgfSksIHRoaXMuZmxpcHBlci5vbkZsaXAodGhpcy5vbkZsaXApKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHNvbWUgaXRlbSBpbnNpZGUgcG9wb3ZlciBpcyBmb2N1c2VkXG4gICAqL1xuICBoYXNGb2N1cygpIHtcbiAgICByZXR1cm4gdGhpcy5mbGlwcGVyID09PSB2b2lkIDAgPyAhMSA6IHRoaXMuZmxpcHBlci5oYXNGb2N1cygpO1xuICB9XG4gIC8qKlxuICAgKiBTY3JvbGwgcG9zaXRpb24gaW5zaWRlIGl0ZW1zIGNvbnRhaW5lciBvZiB0aGUgcG9wb3ZlclxuICAgKi9cbiAgZ2V0IHNjcm9sbFRvcCgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2Rlcy5pdGVtcyA9PT0gbnVsbCA/IDAgOiB0aGlzLm5vZGVzLml0ZW1zLnNjcm9sbFRvcDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB2aXNpYmxlIGVsZW1lbnQgb2Zmc2V0IHRvcFxuICAgKi9cbiAgZ2V0IG9mZnNldFRvcCgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2Rlcy5wb3BvdmVyQ29udGFpbmVyID09PSBudWxsID8gMCA6IHRoaXMubm9kZXMucG9wb3ZlckNvbnRhaW5lci5vZmZzZXRUb3A7XG4gIH1cbiAgLyoqXG4gICAqIE9wZW4gcG9wb3ZlclxuICAgKi9cbiAgc2hvdygpIHtcbiAgICB2YXIgZTtcbiAgICB0aGlzLm5vZGVzLnBvcG92ZXIuc3R5bGUuc2V0UHJvcGVydHkoY2UuUG9wb3ZlckhlaWdodCwgdGhpcy5zaXplLmhlaWdodCArIFwicHhcIiksIHRoaXMuc2hvdWxkT3BlbkJvdHRvbSB8fCB0aGlzLm5vZGVzLnBvcG92ZXIuY2xhc3NMaXN0LmFkZChOLnBvcG92ZXJPcGVuVG9wKSwgdGhpcy5zaG91bGRPcGVuUmlnaHQgfHwgdGhpcy5ub2Rlcy5wb3BvdmVyLmNsYXNzTGlzdC5hZGQoTi5wb3BvdmVyT3BlbkxlZnQpLCBzdXBlci5zaG93KCksIChlID0gdGhpcy5mbGlwcGVyKSA9PSBudWxsIHx8IGUuYWN0aXZhdGUodGhpcy5mbGlwcGFibGVFbGVtZW50cyk7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFycyBtZW1vcnlcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5oaWRlKCksIHN1cGVyLmRlc3Ryb3koKTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlcyBkaXNwbGF5aW5nIG5lc3RlZCBpdGVtcyBmb3IgdGhlIGl0ZW0uXG4gICAqXG4gICAqIEBwYXJhbSBpdGVtIOKAkyBpdGVtIHRvIHNob3cgbmVzdGVkIHBvcG92ZXIgZm9yXG4gICAqL1xuICBzaG93TmVzdGVkSXRlbXMoZSkge1xuICAgIHRoaXMubmVzdGVkUG9wb3ZlciAhPT0gbnVsbCAmJiB0aGlzLm5lc3RlZFBvcG92ZXIgIT09IHZvaWQgMCB8fCAodGhpcy5uZXN0ZWRQb3BvdmVyVHJpZ2dlckl0ZW0gPSBlLCB0aGlzLnNob3dOZXN0ZWRQb3BvdmVyRm9ySXRlbShlKSk7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZXMgaG92ZXIgZXZlbnRzIGluc2lkZSBwb3BvdmVyIGl0ZW1zIGNvbnRhaW5lclxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgLSBob3ZlciBldmVudCBkYXRhXG4gICAqL1xuICBoYW5kbGVIb3ZlcihlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZ2V0VGFyZ2V0SXRlbShlKTtcbiAgICB0ICE9PSB2b2lkIDAgJiYgdGhpcy5wcmV2aW91c2x5SG92ZXJlZEl0ZW0gIT09IHQgJiYgKHRoaXMuZGVzdHJveU5lc3RlZFBvcG92ZXJJZkV4aXN0cygpLCB0aGlzLnByZXZpb3VzbHlIb3ZlcmVkSXRlbSA9IHQsIHQuaGFzQ2hpbGRyZW4gJiYgdGhpcy5zaG93TmVzdGVkUG9wb3ZlckZvckl0ZW0odCkpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIENTUyB2YXJpYWJsZSB3aXRoIHBvc2l0aW9uIG9mIGl0ZW0gbmVhciB3aGljaCBuZXN0ZWQgcG9wb3ZlciBzaG91bGQgYmUgZGlzcGxheWVkLlxuICAgKiBJcyB1c2VkIGZvciBjb3JyZWN0IHBvc2l0aW9uaW5nIG9mIHRoZSBuZXN0ZWQgcG9wb3ZlclxuICAgKlxuICAgKiBAcGFyYW0gbmVzdGVkUG9wb3ZlckVsIC0gbmVzdGVkIHBvcG92ZXIgZWxlbWVudFxuICAgKiBAcGFyYW0gaXRlbSDigJMgaXRlbSBuZWFyIHdoaWNoIG5lc3RlZCBwb3BvdmVyIHNob3VsZCBiZSBkaXNwbGF5ZWRcbiAgICovXG4gIHNldFRyaWdnZXJJdGVtUG9zaXRpb24oZSwgdCkge1xuICAgIGNvbnN0IG8gPSB0LmdldEVsZW1lbnQoKSwgaSA9IChvID8gby5vZmZzZXRUb3AgOiAwKSAtIHRoaXMuc2Nyb2xsVG9wLCBzID0gdGhpcy5vZmZzZXRUb3AgKyBpO1xuICAgIGUuc3R5bGUuc2V0UHJvcGVydHkoY2UuVHJpZ2dlckl0ZW1Ub3AsIHMgKyBcInB4XCIpO1xuICB9XG4gIC8qKlxuICAgKiBEZXN0cm95cyBleGlzdGluZyBuZXN0ZWQgcG9wb3ZlclxuICAgKi9cbiAgZGVzdHJveU5lc3RlZFBvcG92ZXJJZkV4aXN0cygpIHtcbiAgICB2YXIgZSwgdDtcbiAgICB0aGlzLm5lc3RlZFBvcG92ZXIgPT09IHZvaWQgMCB8fCB0aGlzLm5lc3RlZFBvcG92ZXIgPT09IG51bGwgfHwgKHRoaXMubmVzdGVkUG9wb3Zlci5vZmYoWi5DbG9zZWRPbkFjdGl2YXRlLCB0aGlzLmhpZGUpLCB0aGlzLm5lc3RlZFBvcG92ZXIuaGlkZSgpLCB0aGlzLm5lc3RlZFBvcG92ZXIuZGVzdHJveSgpLCB0aGlzLm5lc3RlZFBvcG92ZXIuZ2V0RWxlbWVudCgpLnJlbW92ZSgpLCB0aGlzLm5lc3RlZFBvcG92ZXIgPSBudWxsLCAoZSA9IHRoaXMuZmxpcHBlcikgPT0gbnVsbCB8fCBlLmFjdGl2YXRlKHRoaXMuZmxpcHBhYmxlRWxlbWVudHMpLCAodCA9IHRoaXMubmVzdGVkUG9wb3ZlclRyaWdnZXJJdGVtKSA9PSBudWxsIHx8IHQub25DaGlsZHJlbkNsb3NlKCkpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuZCBkaXNwbGF5cyBuZXN0ZWQgcG9wb3ZlciBmb3Igc3BlY2lmaWVkIGl0ZW0uXG4gICAqIElzIHVzZWQgb25seSBvbiBkZXNrdG9wXG4gICAqXG4gICAqIEBwYXJhbSBpdGVtIC0gaXRlbSB0byBkaXNwbGF5IG5lc3RlZCBwb3BvdmVyIGJ5XG4gICAqL1xuICBzaG93TmVzdGVkUG9wb3ZlckZvckl0ZW0oZSkge1xuICAgIHZhciBvO1xuICAgIHRoaXMubmVzdGVkUG9wb3ZlciA9IG5ldyBYdCh7XG4gICAgICBzZWFyY2hhYmxlOiBlLmlzQ2hpbGRyZW5TZWFyY2hhYmxlLFxuICAgICAgaXRlbXM6IGUuY2hpbGRyZW4sXG4gICAgICBuZXN0aW5nTGV2ZWw6IHRoaXMubmVzdGluZ0xldmVsICsgMSxcbiAgICAgIGZsaXBwYWJsZTogZS5pc0NoaWxkcmVuRmxpcHBhYmxlXG4gICAgfSksIGUub25DaGlsZHJlbk9wZW4oKSwgdGhpcy5uZXN0ZWRQb3BvdmVyLm9uKFouQ2xvc2VkT25BY3RpdmF0ZSwgdGhpcy5oaWRlKTtcbiAgICBjb25zdCB0ID0gdGhpcy5uZXN0ZWRQb3BvdmVyLmdldEVsZW1lbnQoKTtcbiAgICByZXR1cm4gdGhpcy5ub2Rlcy5wb3BvdmVyLmFwcGVuZENoaWxkKHQpLCB0aGlzLnNldFRyaWdnZXJJdGVtUG9zaXRpb24odCwgZSksIHQuc3R5bGUuc2V0UHJvcGVydHkoY2UuTmVzdGluZ0xldmVsLCB0aGlzLm5lc3RlZFBvcG92ZXIubmVzdGluZ0xldmVsLnRvU3RyaW5nKCkpLCB0aGlzLm5lc3RlZFBvcG92ZXIuc2hvdygpLCAobyA9IHRoaXMuZmxpcHBlcikgPT0gbnVsbCB8fCBvLmRlYWN0aXZhdGUoKSwgdGhpcy5uZXN0ZWRQb3BvdmVyO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgcG9wb3ZlciBzaG91bGQgYmUgb3BlbmVkIGJvdHRvbS5cbiAgICogSXQgc2hvdWxkIGhhcHBlbiB3aGVuIHRoZXJlIGlzIGVub3VnaCBzcGFjZSBiZWxvdyBvciBub3QgZW5vdWdoIHNwYWNlIGFib3ZlXG4gICAqL1xuICBnZXQgc2hvdWxkT3BlbkJvdHRvbSgpIHtcbiAgICBpZiAodGhpcy5ub2Rlcy5wb3BvdmVyID09PSB2b2lkIDAgfHwgdGhpcy5ub2Rlcy5wb3BvdmVyID09PSBudWxsKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IGUgPSB0aGlzLm5vZGVzLnBvcG92ZXJDb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHQgPSB0aGlzLnNjb3BlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgbyA9IHRoaXMuc2l6ZS5oZWlnaHQsIGkgPSBlLnRvcCArIG8sIHMgPSBlLnRvcCAtIG8sIHIgPSBNYXRoLm1pbih3aW5kb3cuaW5uZXJIZWlnaHQsIHQuYm90dG9tKTtcbiAgICByZXR1cm4gcyA8IHQudG9wIHx8IGkgPD0gcjtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIHBvcG92ZXIgc2hvdWxkIGJlIG9wZW5lZCBsZWZ0LlxuICAgKiBJdCBzaG91bGQgaGFwcGVuIHdoZW4gdGhlcmUgaXMgZW5vdWdoIHNwYWNlIGluIHRoZSByaWdodCBvciBub3QgZW5vdWdoIHNwYWNlIGluIHRoZSBsZWZ0XG4gICAqL1xuICBnZXQgc2hvdWxkT3BlblJpZ2h0KCkge1xuICAgIGlmICh0aGlzLm5vZGVzLnBvcG92ZXIgPT09IHZvaWQgMCB8fCB0aGlzLm5vZGVzLnBvcG92ZXIgPT09IG51bGwpXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgZSA9IHRoaXMubm9kZXMucG9wb3Zlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgdCA9IHRoaXMuc2NvcGVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBvID0gdGhpcy5zaXplLndpZHRoLCBpID0gZS5yaWdodCArIG8sIHMgPSBlLmxlZnQgLSBvLCByID0gTWF0aC5taW4od2luZG93LmlubmVyV2lkdGgsIHQucmlnaHQpO1xuICAgIHJldHVybiBzIDwgdC5sZWZ0IHx8IGkgPD0gcjtcbiAgfVxuICBnZXQgc2l6ZSgpIHtcbiAgICB2YXIgaTtcbiAgICBjb25zdCBlID0ge1xuICAgICAgaGVpZ2h0OiAwLFxuICAgICAgd2lkdGg6IDBcbiAgICB9O1xuICAgIGlmICh0aGlzLm5vZGVzLnBvcG92ZXIgPT09IG51bGwpXG4gICAgICByZXR1cm4gZTtcbiAgICBjb25zdCB0ID0gdGhpcy5ub2Rlcy5wb3BvdmVyLmNsb25lTm9kZSghMCk7XG4gICAgdC5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIiwgdC5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIiwgdC5zdHlsZS50b3AgPSBcIi0xMDAwcHhcIiwgdC5jbGFzc0xpc3QuYWRkKE4ucG9wb3Zlck9wZW5lZCksIChpID0gdC5xdWVyeVNlbGVjdG9yKFwiLlwiICsgTi5wb3BvdmVyTmVzdGVkKSkgPT0gbnVsbCB8fCBpLnJlbW92ZSgpLCBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHQpO1xuICAgIGNvbnN0IG8gPSB0LnF1ZXJ5U2VsZWN0b3IoXCIuXCIgKyBOLnBvcG92ZXJDb250YWluZXIpO1xuICAgIHJldHVybiBlLmhlaWdodCA9IG8ub2Zmc2V0SGVpZ2h0LCBlLndpZHRoID0gby5vZmZzZXRXaWR0aCwgdC5yZW1vdmUoKSwgZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBsaXN0IG9mIGVsZW1lbnRzIGF2YWlsYWJsZSBmb3Iga2V5Ym9hcmQgbmF2aWdhdGlvbi5cbiAgICovXG4gIGdldCBmbGlwcGFibGVFbGVtZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5pdGVtcy5tYXAoKHQpID0+IHtcbiAgICAgIGlmICh0IGluc3RhbmNlb2Ygc2UpXG4gICAgICAgIHJldHVybiB0LmdldEVsZW1lbnQoKTtcbiAgICAgIGlmICh0IGluc3RhbmNlb2YgeWUpXG4gICAgICAgIHJldHVybiB0LmdldENvbnRyb2xzKCk7XG4gICAgfSkuZmxhdCgpLmZpbHRlcigodCkgPT4gdCAhPSBudWxsKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBzZWFyY2ggdG8gdGhlIHBvcG92ZXJcbiAgICovXG4gIGFkZFNlYXJjaCgpIHtcbiAgICB0aGlzLnNlYXJjaCA9IG5ldyByaSh7XG4gICAgICBpdGVtczogdGhpcy5pdGVtc0RlZmF1bHQsXG4gICAgICBwbGFjZWhvbGRlcjogdGhpcy5tZXNzYWdlcy5zZWFyY2hcbiAgICB9KSwgdGhpcy5zZWFyY2gub24oUGUuU2VhcmNoLCB0aGlzLm9uU2VhcmNoKTtcbiAgICBjb25zdCBlID0gdGhpcy5zZWFyY2guZ2V0RWxlbWVudCgpO1xuICAgIGUuY2xhc3NMaXN0LmFkZChOLnNlYXJjaCksIHRoaXMubm9kZXMucG9wb3ZlckNvbnRhaW5lci5pbnNlcnRCZWZvcmUoZSwgdGhpcy5ub2Rlcy5wb3BvdmVyQ29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuICB9XG4gIC8qKlxuICAgKiBUb2dnbGVzIG5vdGhpbmcgZm91bmQgbWVzc2FnZSB2aXNpYmlsaXR5XG4gICAqXG4gICAqIEBwYXJhbSBpc0Rpc3BsYXllZCAtIHRydWUgaWYgdGhlIG1lc3NhZ2Ugc2hvdWxkIGJlIGRpc3BsYXllZFxuICAgKi9cbiAgdG9nZ2xlTm90aGluZ0ZvdW5kTWVzc2FnZShlKSB7XG4gICAgdGhpcy5ub2Rlcy5ub3RoaW5nRm91bmRNZXNzYWdlLmNsYXNzTGlzdC50b2dnbGUoTi5ub3RoaW5nRm91bmRNZXNzYWdlRGlzcGxheWVkLCBlKTtcbiAgfVxufTtcbmNpKFtcbiAgaGVcbl0sIEt0LnByb3RvdHlwZSwgXCJzaXplXCIsIDEpO1xubGV0IGl0ID0gS3Q7XG5jbGFzcyBkaSBleHRlbmRzIGl0IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgdGhlIGluc3RhbmNlXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBpbnN0YW5jZSBwYXJhbWV0ZXJzXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgY29uc3QgdCA9ICF1ZSgpO1xuICAgIHN1cGVyKFxuICAgICAge1xuICAgICAgICAuLi5lLFxuICAgICAgICBjbGFzczogTi5wb3BvdmVySW5saW5lXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBbQS5EZWZhdWx0XToge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFdlIHVzZSBidXR0b24gaW5zdGVhZCBvZiBkaXYgaGVyZSB0byBmaXggYnVnIGFzc29jaWF0ZWQgd2l0aCBmb2N1cyBsb3NzICh3aGljaCBsZWFkcyB0byBzZWxlY3Rpb24gY2hhbmdlKSBvbiBjbGljayBpbiBzYWZhcmlcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEB0b2RvIGZpZ3VyZSBvdXQgYmV0dGVyIHdheSB0byBzb2x2ZSB0aGUgaXNzdWVcbiAgICAgICAgICAgKi9cbiAgICAgICAgICB3cmFwcGVyVGFnOiBcImJ1dHRvblwiLFxuICAgICAgICAgIGhpbnQ6IHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcInRvcFwiLFxuICAgICAgICAgICAgYWxpZ25tZW50OiBcImNlbnRlclwiLFxuICAgICAgICAgICAgZW5hYmxlZDogdFxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgW0EuSHRtbF06IHtcbiAgICAgICAgICBoaW50OiB7XG4gICAgICAgICAgICBwb3NpdGlvbjogXCJ0b3BcIixcbiAgICAgICAgICAgIGFsaWdubWVudDogXCJjZW50ZXJcIixcbiAgICAgICAgICAgIGVuYWJsZWQ6IHRcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApLCB0aGlzLml0ZW1zLmZvckVhY2goKG8pID0+IHtcbiAgICAgICEobyBpbnN0YW5jZW9mIHNlKSAmJiAhKG8gaW5zdGFuY2VvZiB5ZSkgfHwgby5oYXNDaGlsZHJlbiAmJiBvLmlzQ2hpbGRyZW5PcGVuICYmIHRoaXMuc2hvd05lc3RlZEl0ZW1zKG8pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHZpc2libGUgZWxlbWVudCBvZmZzZXQgdG9wXG4gICAqL1xuICBnZXQgb2Zmc2V0TGVmdCgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2Rlcy5wb3BvdmVyQ29udGFpbmVyID09PSBudWxsID8gMCA6IHRoaXMubm9kZXMucG9wb3ZlckNvbnRhaW5lci5vZmZzZXRMZWZ0O1xuICB9XG4gIC8qKlxuICAgKiBPcGVuIHBvcG92ZXJcbiAgICovXG4gIHNob3coKSB7XG4gICAgdGhpcy5uZXN0aW5nTGV2ZWwgPT09IDAgJiYgdGhpcy5ub2Rlcy5wb3BvdmVyLnN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgY2UuSW5saW5lUG9wb3ZlcldpZHRoLFxuICAgICAgdGhpcy5zaXplLndpZHRoICsgXCJweFwiXG4gICAgKSwgc3VwZXIuc2hvdygpO1xuICB9XG4gIC8qKlxuICAgKiBEaXNhYmxlIGhvdmVyIGV2ZW50IGhhbmRsaW5nLlxuICAgKiBPdmVycmlkZXMgcGFyZW50J3MgY2xhc3MgYmVoYXZpb3JcbiAgICovXG4gIGhhbmRsZUhvdmVyKCkge1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIENTUyB2YXJpYWJsZSB3aXRoIHBvc2l0aW9uIG9mIGl0ZW0gbmVhciB3aGljaCBuZXN0ZWQgcG9wb3ZlciBzaG91bGQgYmUgZGlzcGxheWVkLlxuICAgKiBJcyB1c2VkIHRvIHBvc2l0aW9uIG5lc3RlZCBwb3BvdmVyIHJpZ2h0IGJlbG93IGNsaWNrZWQgaXRlbVxuICAgKlxuICAgKiBAcGFyYW0gbmVzdGVkUG9wb3ZlckVsIC0gbmVzdGVkIHBvcG92ZXIgZWxlbWVudFxuICAgKiBAcGFyYW0gaXRlbSDigJMgaXRlbSBuZWFyIHdoaWNoIG5lc3RlZCBwb3BvdmVyIHNob3VsZCBiZSBkaXNwbGF5ZWRcbiAgICovXG4gIHNldFRyaWdnZXJJdGVtUG9zaXRpb24oZSwgdCkge1xuICAgIGNvbnN0IG8gPSB0LmdldEVsZW1lbnQoKSwgaSA9IG8gPyBvLm9mZnNldExlZnQgOiAwLCBzID0gdGhpcy5vZmZzZXRMZWZ0ICsgaTtcbiAgICBlLnN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgY2UuVHJpZ2dlckl0ZW1MZWZ0LFxuICAgICAgcyArIFwicHhcIlxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZXMgZGlzcGxheWluZyBuZXN0ZWQgaXRlbXMgZm9yIHRoZSBpdGVtLlxuICAgKiBPdmVycmlkaW5nIGluIG9yZGVyIHRvIGFkZCB0b2dnbGluZyBiZWhhdmlvdXJcbiAgICpcbiAgICogQHBhcmFtIGl0ZW0g4oCTIGl0ZW0gdG8gdG9nZ2xlIG5lc3RlZCBwb3BvdmVyIGZvclxuICAgKi9cbiAgc2hvd05lc3RlZEl0ZW1zKGUpIHtcbiAgICBpZiAodGhpcy5uZXN0ZWRQb3BvdmVyVHJpZ2dlckl0ZW0gPT09IGUpIHtcbiAgICAgIHRoaXMubmVzdGVkUG9wb3ZlclRyaWdnZXJJdGVtID0gbnVsbCwgdGhpcy5kZXN0cm95TmVzdGVkUG9wb3ZlcklmRXhpc3RzKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLnNob3dOZXN0ZWRJdGVtcyhlKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhbmQgZGlzcGxheXMgbmVzdGVkIHBvcG92ZXIgZm9yIHNwZWNpZmllZCBpdGVtLlxuICAgKiBJcyB1c2VkIG9ubHkgb24gZGVza3RvcFxuICAgKlxuICAgKiBAcGFyYW0gaXRlbSAtIGl0ZW0gdG8gZGlzcGxheSBuZXN0ZWQgcG9wb3ZlciBieVxuICAgKi9cbiAgc2hvd05lc3RlZFBvcG92ZXJGb3JJdGVtKGUpIHtcbiAgICBjb25zdCB0ID0gc3VwZXIuc2hvd05lc3RlZFBvcG92ZXJGb3JJdGVtKGUpO1xuICAgIHJldHVybiB0LmdldEVsZW1lbnQoKS5jbGFzc0xpc3QuYWRkKE4uZ2V0UG9wb3Zlck5lc3RlZENsYXNzKHQubmVzdGluZ0xldmVsKSksIHQ7XG4gIH1cbiAgLyoqXG4gICAqIE92ZXJyaWRlcyBkZWZhdWx0IGl0ZW0gY2xpY2sgaGFuZGxpbmcuXG4gICAqIEhlbHBzIHRvIGNsb3NlIG5lc3RlZCBwb3BvdmVyIG9uY2Ugb3RoZXIgaXRlbSBpcyBjbGlja2VkLlxuICAgKlxuICAgKiBAcGFyYW0gaXRlbSAtIGNsaWNrZWQgaXRlbVxuICAgKi9cbiAgaGFuZGxlSXRlbUNsaWNrKGUpIHtcbiAgICB2YXIgdDtcbiAgICBlICE9PSB0aGlzLm5lc3RlZFBvcG92ZXJUcmlnZ2VySXRlbSAmJiAoKHQgPSB0aGlzLm5lc3RlZFBvcG92ZXJUcmlnZ2VySXRlbSkgPT0gbnVsbCB8fCB0LmhhbmRsZUNsaWNrKCksIHN1cGVyLmRlc3Ryb3lOZXN0ZWRQb3BvdmVySWZFeGlzdHMoKSksIHN1cGVyLmhhbmRsZUl0ZW1DbGljayhlKTtcbiAgfVxufVxuY29uc3QgVnQgPSBjbGFzcyB2ZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc2Nyb2xsUG9zaXRpb24gPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBMb2NrcyBib2R5IGVsZW1lbnQgc2Nyb2xsXG4gICAqL1xuICBsb2NrKCkge1xuICAgIEdlID8gdGhpcy5sb2NrSGFyZCgpIDogZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKHZlLkNTUy5zY3JvbGxMb2NrZWQpO1xuICB9XG4gIC8qKlxuICAgKiBVbmxvY2tzIGJvZHkgZWxlbWVudCBzY3JvbGxcbiAgICovXG4gIHVubG9jaygpIHtcbiAgICBHZSA/IHRoaXMudW5sb2NrSGFyZCgpIDogZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKHZlLkNTUy5zY3JvbGxMb2NrZWQpO1xuICB9XG4gIC8qKlxuICAgKiBMb2NrcyBzY3JvbGwgaW4gYSBoYXJkIHdheSAodmlhIHNldHRpbmcgZml4ZWQgcG9zaXRpb24gdG8gYm9keSBlbGVtZW50KVxuICAgKi9cbiAgbG9ja0hhcmQoKSB7XG4gICAgdGhpcy5zY3JvbGxQb3NpdGlvbiA9IHdpbmRvdy5wYWdlWU9mZnNldCwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgXCItLXdpbmRvdy1zY3JvbGwtb2Zmc2V0XCIsXG4gICAgICBgJHt0aGlzLnNjcm9sbFBvc2l0aW9ufXB4YFxuICAgICksIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZCh2ZS5DU1Muc2Nyb2xsTG9ja2VkSGFyZCk7XG4gIH1cbiAgLyoqXG4gICAqIFVubG9ja3MgaGFyZCBzY3JvbGwgbG9ja1xuICAgKi9cbiAgdW5sb2NrSGFyZCgpIHtcbiAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUodmUuQ1NTLnNjcm9sbExvY2tlZEhhcmQpLCB0aGlzLnNjcm9sbFBvc2l0aW9uICE9PSBudWxsICYmIHdpbmRvdy5zY3JvbGxUbygwLCB0aGlzLnNjcm9sbFBvc2l0aW9uKSwgdGhpcy5zY3JvbGxQb3NpdGlvbiA9IG51bGw7XG4gIH1cbn07XG5WdC5DU1MgPSB7XG4gIHNjcm9sbExvY2tlZDogXCJjZS1zY3JvbGwtbG9ja2VkXCIsXG4gIHNjcm9sbExvY2tlZEhhcmQ6IFwiY2Utc2Nyb2xsLWxvY2tlZC0taGFyZFwiXG59O1xubGV0IGhpID0gVnQ7XG5jb25zdCBXZSA9IHRlKFwiY2UtcG9wb3Zlci1oZWFkZXJcIiksIEtlID0ge1xuICByb290OiBXZSgpLFxuICB0ZXh0OiBXZShcInRleHRcIiksXG4gIGJhY2tCdXR0b246IFdlKFwiYmFjay1idXR0b25cIilcbn07XG5jbGFzcyB1aSB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIHRoZSBpbnN0YW5jZVxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zIC0gcG9wb3ZlciBoZWFkZXIgcGFyYW1zXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IHRleHQ6IGUsIG9uQmFja0J1dHRvbkNsaWNrOiB0IH0pIHtcbiAgICB0aGlzLmxpc3RlbmVycyA9IG5ldyBUZSgpLCB0aGlzLnRleHQgPSBlLCB0aGlzLm9uQmFja0J1dHRvbkNsaWNrID0gdCwgdGhpcy5ub2RlcyA9IHtcbiAgICAgIHJvb3Q6IGQubWFrZShcImRpdlwiLCBbS2Uucm9vdF0pLFxuICAgICAgYmFja0J1dHRvbjogZC5tYWtlKFwiYnV0dG9uXCIsIFtLZS5iYWNrQnV0dG9uXSksXG4gICAgICB0ZXh0OiBkLm1ha2UoXCJkaXZcIiwgW0tlLnRleHRdKVxuICAgIH0sIHRoaXMubm9kZXMuYmFja0J1dHRvbi5pbm5lckhUTUwgPSBqbywgdGhpcy5ub2Rlcy5yb290LmFwcGVuZENoaWxkKHRoaXMubm9kZXMuYmFja0J1dHRvbiksIHRoaXMubGlzdGVuZXJzLm9uKHRoaXMubm9kZXMuYmFja0J1dHRvbiwgXCJjbGlja1wiLCB0aGlzLm9uQmFja0J1dHRvbkNsaWNrKSwgdGhpcy5ub2Rlcy50ZXh0LmlubmVyVGV4dCA9IHRoaXMudGV4dCwgdGhpcy5ub2Rlcy5yb290LmFwcGVuZENoaWxkKHRoaXMubm9kZXMudGV4dCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgcG9wb3ZlciBoZWFkZXIgcm9vdCBodG1sIGVsZW1lbnRcbiAgICovXG4gIGdldEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMucm9vdDtcbiAgfVxuICAvKipcbiAgICogRGVzdHJveXMgdGhlIGluc3RhbmNlXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMubm9kZXMucm9vdC5yZW1vdmUoKSwgdGhpcy5saXN0ZW5lcnMuZGVzdHJveSgpO1xuICB9XG59XG5jbGFzcyBwaSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaGlzdG9yeSA9IFtdO1xuICB9XG4gIC8qKlxuICAgKiBQdXNoIG5ldyBwb3BvdmVyIHN0YXRlXG4gICAqXG4gICAqIEBwYXJhbSBzdGF0ZSAtIG5ldyBzdGF0ZVxuICAgKi9cbiAgcHVzaChlKSB7XG4gICAgdGhpcy5oaXN0b3J5LnB1c2goZSk7XG4gIH1cbiAgLyoqXG4gICAqIFBvcCBsYXN0IHBvcG92ZXIgc3RhdGVcbiAgICovXG4gIHBvcCgpIHtcbiAgICByZXR1cm4gdGhpcy5oaXN0b3J5LnBvcCgpO1xuICB9XG4gIC8qKlxuICAgKiBUaXRsZSByZXRyaWV2ZWQgZnJvbSB0aGUgY3VycmVudCBzdGF0ZVxuICAgKi9cbiAgZ2V0IGN1cnJlbnRUaXRsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5oaXN0b3J5Lmxlbmd0aCA9PT0gMCA/IFwiXCIgOiB0aGlzLmhpc3RvcnlbdGhpcy5oaXN0b3J5Lmxlbmd0aCAtIDFdLnRpdGxlO1xuICB9XG4gIC8qKlxuICAgKiBJdGVtcyBsaXN0IHJldHJpZXZlZCBmcm9tIHRoZSBjdXJyZW50IHN0YXRlXG4gICAqL1xuICBnZXQgY3VycmVudEl0ZW1zKCkge1xuICAgIHJldHVybiB0aGlzLmhpc3RvcnkubGVuZ3RoID09PSAwID8gW10gOiB0aGlzLmhpc3RvcnlbdGhpcy5oaXN0b3J5Lmxlbmd0aCAtIDFdLml0ZW1zO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGhpc3RvcnkgdG8gaW5pdGlhbCBwb3BvdmVyIHN0YXRlXG4gICAqL1xuICByZXNldCgpIHtcbiAgICBmb3IgKDsgdGhpcy5oaXN0b3J5Lmxlbmd0aCA+IDE7IClcbiAgICAgIHRoaXMucG9wKCk7XG4gIH1cbn1cbmNsYXNzIHF0IGV4dGVuZHMgV3Qge1xuICAvKipcbiAgICogQ29uc3RydWN0IHRoZSBpbnN0YW5jZVxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zIC0gcG9wb3ZlciBwYXJhbXNcbiAgICovXG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBzdXBlcihlLCB7XG4gICAgICBbQS5EZWZhdWx0XToge1xuICAgICAgICBoaW50OiB7XG4gICAgICAgICAgZW5hYmxlZDogITFcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFtBLkh0bWxdOiB7XG4gICAgICAgIGhpbnQ6IHtcbiAgICAgICAgICBlbmFibGVkOiAhMVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSksIHRoaXMuc2Nyb2xsTG9ja2VyID0gbmV3IGhpKCksIHRoaXMuaGlzdG9yeSA9IG5ldyBwaSgpLCB0aGlzLmlzSGlkZGVuID0gITAsIHRoaXMubm9kZXMub3ZlcmxheSA9IGQubWFrZShcImRpdlwiLCBbTi5vdmVybGF5LCBOLm92ZXJsYXlIaWRkZW5dKSwgdGhpcy5ub2Rlcy5wb3BvdmVyLmluc2VydEJlZm9yZSh0aGlzLm5vZGVzLm92ZXJsYXksIHRoaXMubm9kZXMucG9wb3Zlci5maXJzdENoaWxkKSwgdGhpcy5saXN0ZW5lcnMub24odGhpcy5ub2Rlcy5vdmVybGF5LCBcImNsaWNrXCIsICgpID0+IHtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH0pLCB0aGlzLmhpc3RvcnkucHVzaCh7IGl0ZW1zOiBlLml0ZW1zIH0pO1xuICB9XG4gIC8qKlxuICAgKiBPcGVuIHBvcG92ZXJcbiAgICovXG4gIHNob3coKSB7XG4gICAgdGhpcy5ub2Rlcy5vdmVybGF5LmNsYXNzTGlzdC5yZW1vdmUoTi5vdmVybGF5SGlkZGVuKSwgc3VwZXIuc2hvdygpLCB0aGlzLnNjcm9sbExvY2tlci5sb2NrKCksIHRoaXMuaXNIaWRkZW4gPSAhMTtcbiAgfVxuICAvKipcbiAgICogQ2xvc2VzIHBvcG92ZXJcbiAgICovXG4gIGhpZGUoKSB7XG4gICAgdGhpcy5pc0hpZGRlbiB8fCAoc3VwZXIuaGlkZSgpLCB0aGlzLm5vZGVzLm92ZXJsYXkuY2xhc3NMaXN0LmFkZChOLm92ZXJsYXlIaWRkZW4pLCB0aGlzLnNjcm9sbExvY2tlci51bmxvY2soKSwgdGhpcy5oaXN0b3J5LnJlc2V0KCksIHRoaXMuaXNIaWRkZW4gPSAhMCk7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFycyBtZW1vcnlcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgc3VwZXIuZGVzdHJveSgpLCB0aGlzLnNjcm9sbExvY2tlci51bmxvY2soKTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlcyBkaXNwbGF5aW5nIG5lc3RlZCBpdGVtcyBmb3IgdGhlIGl0ZW1cbiAgICpcbiAgICogQHBhcmFtIGl0ZW0g4oCTwqBpdGVtIHRvIHNob3cgbmVzdGVkIHBvcG92ZXIgZm9yXG4gICAqL1xuICBzaG93TmVzdGVkSXRlbXMoZSkge1xuICAgIHRoaXMudXBkYXRlSXRlbXNBbmRIZWFkZXIoZS5jaGlsZHJlbiwgZS50aXRsZSksIHRoaXMuaGlzdG9yeS5wdXNoKHtcbiAgICAgIHRpdGxlOiBlLnRpdGxlLFxuICAgICAgaXRlbXM6IGUuY2hpbGRyZW5cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyByZW5kZXJlZCBwb3BvdmVyIGl0ZW1zIGFuZCBoZWFkZXIgYW5kIGRpc3BsYXlzIG5ldyBvbmVzXG4gICAqXG4gICAqIEBwYXJhbSBpdGVtcyAtIG5ldyBwb3BvdmVyIGl0ZW1zXG4gICAqIEBwYXJhbSB0aXRsZSAtIG5ldyBwb3BvdmVyIGhlYWRlciB0ZXh0XG4gICAqL1xuICB1cGRhdGVJdGVtc0FuZEhlYWRlcihlLCB0KSB7XG4gICAgaWYgKHRoaXMuaGVhZGVyICE9PSBudWxsICYmIHRoaXMuaGVhZGVyICE9PSB2b2lkIDAgJiYgKHRoaXMuaGVhZGVyLmRlc3Ryb3koKSwgdGhpcy5oZWFkZXIgPSBudWxsKSwgdCAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLmhlYWRlciA9IG5ldyB1aSh7XG4gICAgICAgIHRleHQ6IHQsXG4gICAgICAgIG9uQmFja0J1dHRvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5oaXN0b3J5LnBvcCgpLCB0aGlzLnVwZGF0ZUl0ZW1zQW5kSGVhZGVyKHRoaXMuaGlzdG9yeS5jdXJyZW50SXRlbXMsIHRoaXMuaGlzdG9yeS5jdXJyZW50VGl0bGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG8gPSB0aGlzLmhlYWRlci5nZXRFbGVtZW50KCk7XG4gICAgICBvICE9PSBudWxsICYmIHRoaXMubm9kZXMucG9wb3ZlckNvbnRhaW5lci5pbnNlcnRCZWZvcmUobywgdGhpcy5ub2Rlcy5wb3BvdmVyQ29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICB0aGlzLml0ZW1zLmZvckVhY2goKG8pID0+IHtcbiAgICAgIHZhciBpO1xuICAgICAgcmV0dXJuIChpID0gby5nZXRFbGVtZW50KCkpID09IG51bGwgPyB2b2lkIDAgOiBpLnJlbW92ZSgpO1xuICAgIH0pLCB0aGlzLml0ZW1zID0gdGhpcy5idWlsZEl0ZW1zKGUpLCB0aGlzLml0ZW1zLmZvckVhY2goKG8pID0+IHtcbiAgICAgIHZhciBzO1xuICAgICAgY29uc3QgaSA9IG8uZ2V0RWxlbWVudCgpO1xuICAgICAgaSAhPT0gbnVsbCAmJiAoKHMgPSB0aGlzLm5vZGVzLml0ZW1zKSA9PSBudWxsIHx8IHMuYXBwZW5kQ2hpbGQoaSkpO1xuICAgIH0pO1xuICB9XG59XG52YXIgSiA9IC8qIEBfX1BVUkVfXyAqLyAoKG4pID0+IChuLkFQUEVORF9DQUxMQkFDSyA9IFwiYXBwZW5kQ2FsbGJhY2tcIiwgbi5SRU5ERVJFRCA9IFwicmVuZGVyZWRcIiwgbi5NT1ZFRCA9IFwibW92ZWRcIiwgbi5VUERBVEVEID0gXCJ1cGRhdGVkXCIsIG4uUkVNT1ZFRCA9IFwicmVtb3ZlZFwiLCBuLk9OX1BBU1RFID0gXCJvblBhc3RlXCIsIG4pKShKIHx8IHt9KTtcbmNsYXNzIEQgZXh0ZW5kcyBCZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIGJsb2NrIGNvbnN0cnVjdG9yIG9wdGlvbnNcbiAgICogQHBhcmFtIFtvcHRpb25zLmlkXSAtIGJsb2NrJ3MgaWQuIFdpbGwgYmUgZ2VuZXJhdGVkIGlmIG9taXR0ZWQuXG4gICAqIEBwYXJhbSBvcHRpb25zLmRhdGEgLSBUb29sJ3MgaW5pdGlhbCBkYXRhXG4gICAqIEBwYXJhbSBvcHRpb25zLnRvb2wg4oCUIGJsb2NrJ3MgdG9vbFxuICAgKiBAcGFyYW0gb3B0aW9ucy5hcGkgLSBFZGl0b3IgQVBJIG1vZHVsZSBmb3IgcGFzcyBpdCB0byB0aGUgQmxvY2sgVHVuZXNcbiAgICogQHBhcmFtIG9wdGlvbnMucmVhZE9ubHkgLSBSZWFkLU9ubHkgZmxhZ1xuICAgKiBAcGFyYW0gW2V2ZW50QnVzXSAtIEVkaXRvciBjb21tb24gZXZlbnQgYnVzLiBBbGxvd3MgdG8gc3Vic2NyaWJlIG9uIHNvbWUgRWRpdG9yIGV2ZW50cy4gQ291bGQgYmUgb21pdHRlZCB3aGVuIFwidmlydHVhbFwiIEJsb2NrIGlzIGNyZWF0ZWQuIFNlZSBCbG9ja3NBUElAY29tcG9zZUJsb2NrRGF0YS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBpZDogZSA9IElvKCksXG4gICAgZGF0YTogdCxcbiAgICB0b29sOiBvLFxuICAgIHJlYWRPbmx5OiBpLFxuICAgIHR1bmVzRGF0YTogc1xuICB9LCByKSB7XG4gICAgc3VwZXIoKSwgdGhpcy5jYWNoZWRJbnB1dHMgPSBbXSwgdGhpcy50b29sUmVuZGVyZWRFbGVtZW50ID0gbnVsbCwgdGhpcy50dW5lc0luc3RhbmNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIHRoaXMuZGVmYXVsdFR1bmVzSW5zdGFuY2VzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgdGhpcy51bmF2YWlsYWJsZVR1bmVzRGF0YSA9IHt9LCB0aGlzLmlucHV0SW5kZXggPSAwLCB0aGlzLmVkaXRvckV2ZW50QnVzID0gbnVsbCwgdGhpcy5oYW5kbGVGb2N1cyA9ICgpID0+IHtcbiAgICAgIHRoaXMuZHJvcElucHV0c0NhY2hlKCksIHRoaXMudXBkYXRlQ3VycmVudElucHV0KCk7XG4gICAgfSwgdGhpcy5kaWRNdXRhdGVkID0gKGwgPSB2b2lkIDApID0+IHtcbiAgICAgIGNvbnN0IGEgPSBsID09PSB2b2lkIDAsIGMgPSBsIGluc3RhbmNlb2YgSW5wdXRFdmVudDtcbiAgICAgICFhICYmICFjICYmIHRoaXMuZGV0ZWN0VG9vbFJvb3RDaGFuZ2UobCk7XG4gICAgICBsZXQgdTtcbiAgICAgIGEgfHwgYyA/IHUgPSAhMCA6IHUgPSAhKGwubGVuZ3RoID4gMCAmJiBsLmV2ZXJ5KChwKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgYWRkZWROb2RlczogZywgcmVtb3ZlZE5vZGVzOiBmLCB0YXJnZXQ6IGsgfSA9IHA7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgLi4uQXJyYXkuZnJvbShnKSxcbiAgICAgICAgICAuLi5BcnJheS5mcm9tKGYpLFxuICAgICAgICAgIGtcbiAgICAgICAgXS5zb21lKChTKSA9PiAoZC5pc0VsZW1lbnQoUykgfHwgKFMgPSBTLnBhcmVudEVsZW1lbnQpLCBTICYmIFMuY2xvc2VzdCgnW2RhdGEtbXV0YXRpb24tZnJlZT1cInRydWVcIl0nKSAhPT0gbnVsbCkpO1xuICAgICAgfSkpLCB1ICYmICh0aGlzLmRyb3BJbnB1dHNDYWNoZSgpLCB0aGlzLnVwZGF0ZUN1cnJlbnRJbnB1dCgpLCB0aGlzLnRvZ2dsZUlucHV0c0VtcHR5TWFyaygpLCB0aGlzLmNhbGwoXG4gICAgICAgIFwidXBkYXRlZFwiXG4gICAgICAgIC8qIFVQREFURUQgKi9cbiAgICAgICksIHRoaXMuZW1pdChcImRpZE11dGF0ZWRcIiwgdGhpcykpO1xuICAgIH0sIHRoaXMubmFtZSA9IG8ubmFtZSwgdGhpcy5pZCA9IGUsIHRoaXMuc2V0dGluZ3MgPSBvLnNldHRpbmdzLCB0aGlzLmNvbmZpZyA9IG8uc2V0dGluZ3MuY29uZmlnIHx8IHt9LCB0aGlzLmVkaXRvckV2ZW50QnVzID0gciB8fCBudWxsLCB0aGlzLmJsb2NrQVBJID0gbmV3IEcodGhpcyksIHRoaXMudG9vbCA9IG8sIHRoaXMudG9vbEluc3RhbmNlID0gby5jcmVhdGUodCwgdGhpcy5ibG9ja0FQSSwgaSksIHRoaXMudHVuZXMgPSBvLnR1bmVzLCB0aGlzLmNvbXBvc2VUdW5lcyhzKSwgdGhpcy5ob2xkZXIgPSB0aGlzLmNvbXBvc2UoKSwgd2luZG93LnJlcXVlc3RJZGxlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgdGhpcy53YXRjaEJsb2NrTXV0YXRpb25zKCksIHRoaXMuYWRkSW5wdXRFdmVudHMoKSwgdGhpcy50b2dnbGVJbnB1dHNFbXB0eU1hcmsoKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ1NTIGNsYXNzZXMgZm9yIHRoZSBCbG9ja1xuICAgKlxuICAgKiBAcmV0dXJucyB7e3dyYXBwZXI6IHN0cmluZywgY29udGVudDogc3RyaW5nfX1cbiAgICovXG4gIHN0YXRpYyBnZXQgQ1NTKCkge1xuICAgIHJldHVybiB7XG4gICAgICB3cmFwcGVyOiBcImNlLWJsb2NrXCIsXG4gICAgICB3cmFwcGVyU3RyZXRjaGVkOiBcImNlLWJsb2NrLS1zdHJldGNoZWRcIixcbiAgICAgIGNvbnRlbnQ6IFwiY2UtYmxvY2tfX2NvbnRlbnRcIixcbiAgICAgIHNlbGVjdGVkOiBcImNlLWJsb2NrLS1zZWxlY3RlZFwiLFxuICAgICAgZHJvcFRhcmdldDogXCJjZS1ibG9jay0tZHJvcC10YXJnZXRcIlxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEZpbmQgYW5kIHJldHVybiBhbGwgZWRpdGFibGUgZWxlbWVudHMgKGNvbnRlbnRlZGl0YWJsZSBhbmQgbmF0aXZlIGlucHV0cykgaW4gdGhlIFRvb2wgSFRNTFxuICAgKi9cbiAgZ2V0IGlucHV0cygpIHtcbiAgICBpZiAodGhpcy5jYWNoZWRJbnB1dHMubGVuZ3RoICE9PSAwKVxuICAgICAgcmV0dXJuIHRoaXMuY2FjaGVkSW5wdXRzO1xuICAgIGNvbnN0IGUgPSBkLmZpbmRBbGxJbnB1dHModGhpcy5ob2xkZXIpO1xuICAgIHJldHVybiB0aGlzLmlucHV0SW5kZXggPiBlLmxlbmd0aCAtIDEgJiYgKHRoaXMuaW5wdXRJbmRleCA9IGUubGVuZ3RoIC0gMSksIHRoaXMuY2FjaGVkSW5wdXRzID0gZSwgZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGN1cnJlbnQgVG9vbGBzIGlucHV0XG4gICAqIElmIEJsb2NrIGRvZXNuJ3QgY29udGFpbiBpbnB1dHMsIHJldHVybiB1bmRlZmluZWRcbiAgICovXG4gIGdldCBjdXJyZW50SW5wdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXRzW3RoaXMuaW5wdXRJbmRleF07XG4gIH1cbiAgLyoqXG4gICAqIFNldCBpbnB1dCBpbmRleCB0byB0aGUgcGFzc2VkIGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIGVsZW1lbnQgLSBIVE1MIEVsZW1lbnQgdG8gc2V0IGFzIGN1cnJlbnQgaW5wdXRcbiAgICovXG4gIHNldCBjdXJyZW50SW5wdXQoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmlucHV0cy5maW5kSW5kZXgoKG8pID0+IG8gPT09IGUgfHwgby5jb250YWlucyhlKSk7XG4gICAgdCAhPT0gLTEgJiYgKHRoaXMuaW5wdXRJbmRleCA9IHQpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gZmlyc3QgVG9vbGBzIGlucHV0XG4gICAqIElmIEJsb2NrIGRvZXNuJ3QgY29udGFpbiBpbnB1dHMsIHJldHVybiB1bmRlZmluZWRcbiAgICovXG4gIGdldCBmaXJzdElucHV0KCkge1xuICAgIHJldHVybiB0aGlzLmlucHV0c1swXTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGZpcnN0IFRvb2xgcyBpbnB1dFxuICAgKiBJZiBCbG9jayBkb2Vzbid0IGNvbnRhaW4gaW5wdXRzLCByZXR1cm4gdW5kZWZpbmVkXG4gICAqL1xuICBnZXQgbGFzdElucHV0KCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmlucHV0cztcbiAgICByZXR1cm4gZVtlLmxlbmd0aCAtIDFdO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gbmV4dCBUb29sYHMgaW5wdXQgb3IgdW5kZWZpbmVkIGlmIGl0IGRvZXNuJ3QgZXhpc3RcbiAgICogSWYgQmxvY2sgZG9lc24ndCBjb250YWluIGlucHV0cywgcmV0dXJuIHVuZGVmaW5lZFxuICAgKi9cbiAgZ2V0IG5leHRJbnB1dCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnB1dHNbdGhpcy5pbnB1dEluZGV4ICsgMV07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBwcmV2aW91cyBUb29sYHMgaW5wdXQgb3IgdW5kZWZpbmVkIGlmIGl0IGRvZXNuJ3QgZXhpc3RcbiAgICogSWYgQmxvY2sgZG9lc24ndCBjb250YWluIGlucHV0cywgcmV0dXJuIHVuZGVmaW5lZFxuICAgKi9cbiAgZ2V0IHByZXZpb3VzSW5wdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXRzW3RoaXMuaW5wdXRJbmRleCAtIDFdO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgQmxvY2sncyBKU09OIGRhdGFcbiAgICpcbiAgICogQHJldHVybnMge29iamVjdH1cbiAgICovXG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLnNhdmUoKS50aGVuKChlKSA9PiBlICYmICFYKGUuZGF0YSkgPyBlLmRhdGEgOiB7fSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdG9vbCdzIHNhbml0aXplciBjb25maWdcbiAgICpcbiAgICogQHJldHVybnMge29iamVjdH1cbiAgICovXG4gIGdldCBzYW5pdGl6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy50b29sLnNhbml0aXplQ29uZmlnO1xuICB9XG4gIC8qKlxuICAgKiBpcyBibG9jayBtZXJnZWFibGVcbiAgICogV2UgcGx1Z2luIGhhdmUgbWVyZ2UgZnVuY3Rpb24gdGhlbiB3ZSBjYWxsIGl0IG1lcmdlYWJsZVxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBtZXJnZWFibGUoKSB7XG4gICAgcmV0dXJuIE8odGhpcy50b29sSW5zdGFuY2UubWVyZ2UpO1xuICB9XG4gIC8qKlxuICAgKiBJZiBCbG9jayBjb250YWlucyBpbnB1dHMsIGl0IGlzIGZvY3VzYWJsZVxuICAgKi9cbiAgZ2V0IGZvY3VzYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnB1dHMubGVuZ3RoICE9PSAwO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBibG9jayBmb3IgZW1wdGluZXNzXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzRW1wdHkoKSB7XG4gICAgY29uc3QgZSA9IGQuaXNFbXB0eSh0aGlzLnBsdWdpbnNDb250ZW50LCBcIi9cIiksIHQgPSAhdGhpcy5oYXNNZWRpYTtcbiAgICByZXR1cm4gZSAmJiB0O1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBibG9jayBoYXMgYSBtZWRpYSBjb250ZW50IHN1Y2ggYXMgaW1hZ2VzLCBpZnJhbWUgYW5kIG90aGVyXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGhhc01lZGlhKCkge1xuICAgIGNvbnN0IGUgPSBbXG4gICAgICBcImltZ1wiLFxuICAgICAgXCJpZnJhbWVcIixcbiAgICAgIFwidmlkZW9cIixcbiAgICAgIFwiYXVkaW9cIixcbiAgICAgIFwic291cmNlXCIsXG4gICAgICBcImlucHV0XCIsXG4gICAgICBcInRleHRhcmVhXCIsXG4gICAgICBcInR3aXR0ZXJ3aWRnZXRcIlxuICAgIF07XG4gICAgcmV0dXJuICEhdGhpcy5ob2xkZXIucXVlcnlTZWxlY3RvcihlLmpvaW4oXCIsXCIpKTtcbiAgfVxuICAvKipcbiAgICogU2V0IHNlbGVjdGVkIHN0YXRlXG4gICAqIFdlIGRvbid0IG5lZWQgdG8gbWFyayBCbG9jayBhcyBTZWxlY3RlZCB3aGVuIGl0IGlzIGVtcHR5XG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc3RhdGUgLSAndHJ1ZScgdG8gc2VsZWN0LCAnZmFsc2UnIHRvIHJlbW92ZSBzZWxlY3Rpb25cbiAgICovXG4gIHNldCBzZWxlY3RlZChlKSB7XG4gICAgdmFyIGksIHM7XG4gICAgdGhpcy5ob2xkZXIuY2xhc3NMaXN0LnRvZ2dsZShELkNTUy5zZWxlY3RlZCwgZSk7XG4gICAgY29uc3QgdCA9IGUgPT09ICEwICYmIGIuaXNSYW5nZUluc2lkZUNvbnRhaW5lcih0aGlzLmhvbGRlciksIG8gPSBlID09PSAhMSAmJiBiLmlzRmFrZUN1cnNvckluc2lkZUNvbnRhaW5lcih0aGlzLmhvbGRlcik7XG4gICAgKHQgfHwgbykgJiYgKChpID0gdGhpcy5lZGl0b3JFdmVudEJ1cykgPT0gbnVsbCB8fCBpLmVtaXQoRHQsIHsgc3RhdGU6IGUgfSksIHQgPyBiLmFkZEZha2VDdXJzb3IoKSA6IGIucmVtb3ZlRmFrZUN1cnNvcih0aGlzLmhvbGRlciksIChzID0gdGhpcy5lZGl0b3JFdmVudEJ1cykgPT0gbnVsbCB8fCBzLmVtaXQoUnQsIHsgc3RhdGU6IGUgfSkpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIFRydWUgaWYgaXQgaXMgU2VsZWN0ZWRcbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgc2VsZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaG9sZGVyLmNsYXNzTGlzdC5jb250YWlucyhELkNTUy5zZWxlY3RlZCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldCBzdHJldGNoZWQgc3RhdGVcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBzdGF0ZSAtICd0cnVlJyB0byBlbmFibGUsICdmYWxzZScgdG8gZGlzYWJsZSBzdHJldGNoZWQgc3RhdGVcbiAgICovXG4gIHNldCBzdHJldGNoZWQoZSkge1xuICAgIHRoaXMuaG9sZGVyLmNsYXNzTGlzdC50b2dnbGUoRC5DU1Mud3JhcHBlclN0cmV0Y2hlZCwgZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBCbG9jaydzIHN0cmV0Y2hlZCBzdGF0ZVxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBzdHJldGNoZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaG9sZGVyLmNsYXNzTGlzdC5jb250YWlucyhELkNTUy53cmFwcGVyU3RyZXRjaGVkKTtcbiAgfVxuICAvKipcbiAgICogVG9nZ2xlIGRyb3AgdGFyZ2V0IHN0YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc3RhdGUgLSAndHJ1ZScgaWYgYmxvY2sgaXMgZHJvcCB0YXJnZXQsIGZhbHNlIG90aGVyd2lzZVxuICAgKi9cbiAgc2V0IGRyb3BUYXJnZXQoZSkge1xuICAgIHRoaXMuaG9sZGVyLmNsYXNzTGlzdC50b2dnbGUoRC5DU1MuZHJvcFRhcmdldCwgZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgUGx1Z2lucyBjb250ZW50XG4gICAqXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIGdldCBwbHVnaW5zQ29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy50b29sUmVuZGVyZWRFbGVtZW50O1xuICB9XG4gIC8qKlxuICAgKiBDYWxscyBUb29sJ3MgbWV0aG9kXG4gICAqXG4gICAqIE1ldGhvZCBjaGVja3MgdG9vbCBwcm9wZXJ0eSB7TWV0aG9kTmFtZX0uIEZpcmVzIG1ldGhvZCB3aXRoIHBhc3NlcyBwYXJhbXMgSWYgaXQgaXMgaW5zdGFuY2Ugb2YgRnVuY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgLSBtZXRob2QgdG8gY2FsbFxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gbWV0aG9kIGFyZ3VtZW50XG4gICAqL1xuICBjYWxsKGUsIHQpIHtcbiAgICBpZiAoTyh0aGlzLnRvb2xJbnN0YW5jZVtlXSkpIHtcbiAgICAgIGUgPT09IFwiYXBwZW5kQ2FsbGJhY2tcIiAmJiBJKFxuICAgICAgICBcImBhcHBlbmRDYWxsYmFja2AgaG9vayBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS4gVXNlIGByZW5kZXJlZGAgaG9vayBpbnN0ZWFkXCIsXG4gICAgICAgIFwid2FyblwiXG4gICAgICApO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy50b29sSW5zdGFuY2VbZV0uY2FsbCh0aGlzLnRvb2xJbnN0YW5jZSwgdCk7XG4gICAgICB9IGNhdGNoIChvKSB7XG4gICAgICAgIEkoYEVycm9yIGR1cmluZyAnJHtlfScgY2FsbDogJHtvLm1lc3NhZ2V9YCwgXCJlcnJvclwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgcGx1Z2lucyBtZXJnZSBtZXRob2RcbiAgICpcbiAgICogQHBhcmFtIHtCbG9ja1Rvb2xEYXRhfSBkYXRhIC0gZGF0YSB0byBtZXJnZVxuICAgKi9cbiAgYXN5bmMgbWVyZ2VXaXRoKGUpIHtcbiAgICBhd2FpdCB0aGlzLnRvb2xJbnN0YW5jZS5tZXJnZShlKTtcbiAgfVxuICAvKipcbiAgICogRXh0cmFjdHMgZGF0YSBmcm9tIEJsb2NrXG4gICAqIEdyb3VwcyBUb29sJ3Mgc2F2ZSBwcm9jZXNzaW5nIHRpbWVcbiAgICpcbiAgICogQHJldHVybnMge29iamVjdH1cbiAgICovXG4gIGFzeW5jIHNhdmUoKSB7XG4gICAgY29uc3QgZSA9IGF3YWl0IHRoaXMudG9vbEluc3RhbmNlLnNhdmUodGhpcy5wbHVnaW5zQ29udGVudCksIHQgPSB0aGlzLnVuYXZhaWxhYmxlVHVuZXNEYXRhO1xuICAgIFtcbiAgICAgIC4uLnRoaXMudHVuZXNJbnN0YW5jZXMuZW50cmllcygpLFxuICAgICAgLi4udGhpcy5kZWZhdWx0VHVuZXNJbnN0YW5jZXMuZW50cmllcygpXG4gICAgXS5mb3JFYWNoKChbcywgcl0pID0+IHtcbiAgICAgIGlmIChPKHIuc2F2ZSkpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdFtzXSA9IHIuc2F2ZSgpO1xuICAgICAgICB9IGNhdGNoIChsKSB7XG4gICAgICAgICAgSShgVHVuZSAke3IuY29uc3RydWN0b3IubmFtZX0gc2F2ZSBtZXRob2QgdGhyb3dzIGFuIEVycm9yICVvYCwgXCJ3YXJuXCIsIGwpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgbyA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICBsZXQgaTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGUpLnRoZW4oKHMpID0+IChpID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpLCB7XG4gICAgICBpZDogdGhpcy5pZCxcbiAgICAgIHRvb2w6IHRoaXMubmFtZSxcbiAgICAgIGRhdGE6IHMsXG4gICAgICB0dW5lczogdCxcbiAgICAgIHRpbWU6IGkgLSBvXG4gICAgfSkpLmNhdGNoKChzKSA9PiB7XG4gICAgICBJKGBTYXZpbmcgcHJvY2VzcyBmb3IgJHt0aGlzLm5hbWV9IHRvb2wgZmFpbGVkIGR1ZSB0byB0aGUgJHtzfWAsIFwibG9nXCIsIFwicmVkXCIpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBVc2VzIFRvb2wncyB2YWxpZGF0aW9uIG1ldGhvZCB0byBjaGVjayB0aGUgY29ycmVjdG5lc3Mgb2Ygb3V0cHV0IGRhdGFcbiAgICogVG9vbCdzIHZhbGlkYXRpb24gbWV0aG9kIGlzIG9wdGlvbmFsXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgcmV0dXJucyB0cnVlfGZhbHNlIHdoZXRoZXIgZGF0YSBwYXNzZWQgdGhlIHZhbGlkYXRpb24gb3Igbm90XG4gICAqIEBwYXJhbSB7QmxvY2tUb29sRGF0YX0gZGF0YSAtIGRhdGEgdG8gdmFsaWRhdGVcbiAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59IHZhbGlkXG4gICAqL1xuICBhc3luYyB2YWxpZGF0ZShlKSB7XG4gICAgbGV0IHQgPSAhMDtcbiAgICByZXR1cm4gdGhpcy50b29sSW5zdGFuY2UudmFsaWRhdGUgaW5zdGFuY2VvZiBGdW5jdGlvbiAmJiAodCA9IGF3YWl0IHRoaXMudG9vbEluc3RhbmNlLnZhbGlkYXRlKGUpKSwgdDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBkYXRhIHRvIHJlbmRlciBpbiBCbG9jayBUdW5lcyBtZW51LlxuICAgKiBTcGxpdHMgYmxvY2sgdHVuZXMgaW50byAyIGdyb3VwczogYmxvY2sgc3BlY2lmaWMgdHVuZXMgYW5kIGNvbW1vbiB0dW5lc1xuICAgKi9cbiAgZ2V0VHVuZXMoKSB7XG4gICAgY29uc3QgZSA9IFtdLCB0ID0gW10sIG8gPSB0eXBlb2YgdGhpcy50b29sSW5zdGFuY2UucmVuZGVyU2V0dGluZ3MgPT0gXCJmdW5jdGlvblwiID8gdGhpcy50b29sSW5zdGFuY2UucmVuZGVyU2V0dGluZ3MoKSA6IFtdO1xuICAgIHJldHVybiBkLmlzRWxlbWVudChvKSA/IGUucHVzaCh7XG4gICAgICB0eXBlOiBBLkh0bWwsXG4gICAgICBlbGVtZW50OiBvXG4gICAgfSkgOiBBcnJheS5pc0FycmF5KG8pID8gZS5wdXNoKC4uLm8pIDogZS5wdXNoKG8pLCBbXG4gICAgICAuLi50aGlzLnR1bmVzSW5zdGFuY2VzLnZhbHVlcygpLFxuICAgICAgLi4udGhpcy5kZWZhdWx0VHVuZXNJbnN0YW5jZXMudmFsdWVzKClcbiAgICBdLm1hcCgocykgPT4gcy5yZW5kZXIoKSkuZm9yRWFjaCgocykgPT4ge1xuICAgICAgZC5pc0VsZW1lbnQocykgPyB0LnB1c2goe1xuICAgICAgICB0eXBlOiBBLkh0bWwsXG4gICAgICAgIGVsZW1lbnQ6IHNcbiAgICAgIH0pIDogQXJyYXkuaXNBcnJheShzKSA/IHQucHVzaCguLi5zKSA6IHQucHVzaChzKTtcbiAgICB9KSwge1xuICAgICAgdG9vbFR1bmVzOiBlLFxuICAgICAgY29tbW9uVHVuZXM6IHRcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGUgY3VycmVudCBpbnB1dCBpbmRleCB3aXRoIHNlbGVjdGlvbiBhbmNob3Igbm9kZVxuICAgKi9cbiAgdXBkYXRlQ3VycmVudElucHV0KCkge1xuICAgIHRoaXMuY3VycmVudElucHV0ID0gZC5pc05hdGl2ZUlucHV0KGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHx8ICFiLmFuY2hvck5vZGUgPyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IDogYi5hbmNob3JOb2RlO1xuICB9XG4gIC8qKlxuICAgKiBBbGxvd3MgdG8gc2F5IEVkaXRvciB0aGF0IEJsb2NrIHdhcyBjaGFuZ2VkLiBVc2VkIHRvIG1hbnVhbGx5IHRyaWdnZXIgRWRpdG9yJ3MgJ29uQ2hhbmdlJyBjYWxsYmFja1xuICAgKiBDYW4gYmUgdXNlZnVsIGZvciBibG9jayBjaGFuZ2VzIGludmlzaWJsZSBmb3IgZWRpdG9yIGNvcmUuXG4gICAqL1xuICBkaXNwYXRjaENoYW5nZSgpIHtcbiAgICB0aGlzLmRpZE11dGF0ZWQoKTtcbiAgfVxuICAvKipcbiAgICogQ2FsbCBUb29sIGluc3RhbmNlIGRlc3Ryb3kgbWV0aG9kXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMudW53YXRjaEJsb2NrTXV0YXRpb25zKCksIHRoaXMucmVtb3ZlSW5wdXRFdmVudHMoKSwgc3VwZXIuZGVzdHJveSgpLCBPKHRoaXMudG9vbEluc3RhbmNlLmRlc3Ryb3kpICYmIHRoaXMudG9vbEluc3RhbmNlLmRlc3Ryb3koKTtcbiAgfVxuICAvKipcbiAgICogVG9vbCBjb3VsZCBzcGVjaWZ5IHNldmVyYWwgZW50cmllcyB0byBiZSBkaXNwbGF5ZWQgYXQgdGhlIFRvb2xib3ggKGZvciBleGFtcGxlLCBcIkhlYWRpbmcgMVwiLCBcIkhlYWRpbmcgMlwiLCBcIkhlYWRpbmcgM1wiKVxuICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBlbnRyeSB0aGF0IGlzIHJlbGF0ZWQgdG8gdGhlIEJsb2NrIChkZXBlbmRlZCBvbiB0aGUgQmxvY2sgZGF0YSlcbiAgICovXG4gIGFzeW5jIGdldEFjdGl2ZVRvb2xib3hFbnRyeSgpIHtcbiAgICBjb25zdCBlID0gdGhpcy50b29sLnRvb2xib3g7XG4gICAgaWYgKGUubGVuZ3RoID09PSAxKVxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLnRvb2wudG9vbGJveFswXSk7XG4gICAgY29uc3QgdCA9IGF3YWl0IHRoaXMuZGF0YSwgbyA9IGU7XG4gICAgcmV0dXJuIG8gPT0gbnVsbCA/IHZvaWQgMCA6IG8uZmluZCgoaSkgPT4gSHQoaS5kYXRhLCB0KSk7XG4gIH1cbiAgLyoqXG4gICAqIEV4cG9ydHMgQmxvY2sgZGF0YSBhcyBzdHJpbmcgdXNpbmcgY29udmVyc2lvbiBjb25maWdcbiAgICovXG4gIGFzeW5jIGV4cG9ydERhdGFBc1N0cmluZygpIHtcbiAgICBjb25zdCBlID0gYXdhaXQgdGhpcy5kYXRhO1xuICAgIHJldHVybiBIbyhlLCB0aGlzLnRvb2wuY29udmVyc2lvbkNvbmZpZyk7XG4gIH1cbiAgLyoqXG4gICAqIE1ha2UgZGVmYXVsdCBCbG9jayB3cmFwcGVycyBhbmQgcHV0IFRvb2xgcyBjb250ZW50IHRoZXJlXG4gICAqXG4gICAqIEByZXR1cm5zIHtIVE1MRGl2RWxlbWVudH1cbiAgICovXG4gIGNvbXBvc2UoKSB7XG4gICAgY29uc3QgZSA9IGQubWFrZShcImRpdlwiLCBELkNTUy53cmFwcGVyKSwgdCA9IGQubWFrZShcImRpdlwiLCBELkNTUy5jb250ZW50KSwgbyA9IHRoaXMudG9vbEluc3RhbmNlLnJlbmRlcigpO1xuICAgIGUuZGF0YXNldC5pZCA9IHRoaXMuaWQsIHRoaXMudG9vbFJlbmRlcmVkRWxlbWVudCA9IG8sIHQuYXBwZW5kQ2hpbGQodGhpcy50b29sUmVuZGVyZWRFbGVtZW50KTtcbiAgICBsZXQgaSA9IHQ7XG4gICAgcmV0dXJuIFsuLi50aGlzLnR1bmVzSW5zdGFuY2VzLnZhbHVlcygpLCAuLi50aGlzLmRlZmF1bHRUdW5lc0luc3RhbmNlcy52YWx1ZXMoKV0uZm9yRWFjaCgocykgPT4ge1xuICAgICAgaWYgKE8ocy53cmFwKSlcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpID0gcy53cmFwKGkpO1xuICAgICAgICB9IGNhdGNoIChyKSB7XG4gICAgICAgICAgSShgVHVuZSAke3MuY29uc3RydWN0b3IubmFtZX0gd3JhcCBtZXRob2QgdGhyb3dzIGFuIEVycm9yICVvYCwgXCJ3YXJuXCIsIHIpO1xuICAgICAgICB9XG4gICAgfSksIGUuYXBwZW5kQ2hpbGQoaSksIGU7XG4gIH1cbiAgLyoqXG4gICAqIEluc3RhbnRpYXRlIEJsb2NrIFR1bmVzXG4gICAqXG4gICAqIEBwYXJhbSB0dW5lc0RhdGEgLSBjdXJyZW50IEJsb2NrIHR1bmVzIGRhdGFcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbXBvc2VUdW5lcyhlKSB7XG4gICAgQXJyYXkuZnJvbSh0aGlzLnR1bmVzLnZhbHVlcygpKS5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICAodC5pc0ludGVybmFsID8gdGhpcy5kZWZhdWx0VHVuZXNJbnN0YW5jZXMgOiB0aGlzLnR1bmVzSW5zdGFuY2VzKS5zZXQodC5uYW1lLCB0LmNyZWF0ZShlW3QubmFtZV0sIHRoaXMuYmxvY2tBUEkpKTtcbiAgICB9KSwgT2JqZWN0LmVudHJpZXMoZSkuZm9yRWFjaCgoW3QsIG9dKSA9PiB7XG4gICAgICB0aGlzLnR1bmVzSW5zdGFuY2VzLmhhcyh0KSB8fCAodGhpcy51bmF2YWlsYWJsZVR1bmVzRGF0YVt0XSA9IG8pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGZvY3VzIGV2ZW50IGxpc3RlbmVycyB0byBhbGwgaW5wdXRzIGFuZCBjb250ZW50ZWRpdGFibGVcbiAgICovXG4gIGFkZElucHV0RXZlbnRzKCkge1xuICAgIHRoaXMuaW5wdXRzLmZvckVhY2goKGUpID0+IHtcbiAgICAgIGUuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHRoaXMuaGFuZGxlRm9jdXMpLCBkLmlzTmF0aXZlSW5wdXQoZSkgJiYgZS5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgdGhpcy5kaWRNdXRhdGVkKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogcmVtb3ZlcyBmb2N1cyBldmVudCBsaXN0ZW5lcnMgZnJvbSBhbGwgaW5wdXRzIGFuZCBjb250ZW50ZWRpdGFibGVcbiAgICovXG4gIHJlbW92ZUlucHV0RXZlbnRzKCkge1xuICAgIHRoaXMuaW5wdXRzLmZvckVhY2goKGUpID0+IHtcbiAgICAgIGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHRoaXMuaGFuZGxlRm9jdXMpLCBkLmlzTmF0aXZlSW5wdXQoZSkgJiYgZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgdGhpcy5kaWRNdXRhdGVkKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogTGlzdGVuIGNvbW1vbiBlZGl0b3IgRG9tIENoYW5nZWQgZXZlbnQgYW5kIGRldGVjdCBtdXRhdGlvbnMgcmVsYXRlZCB0byB0aGUgIEJsb2NrXG4gICAqL1xuICB3YXRjaEJsb2NrTXV0YXRpb25zKCkge1xuICAgIHZhciBlO1xuICAgIHRoaXMucmVkYWN0b3JEb21DaGFuZ2VkQ2FsbGJhY2sgPSAodCkgPT4ge1xuICAgICAgY29uc3QgeyBtdXRhdGlvbnM6IG8gfSA9IHQ7XG4gICAgICBvLnNvbWUoKHMpID0+IEZvKHMsIHRoaXMudG9vbFJlbmRlcmVkRWxlbWVudCkpICYmIHRoaXMuZGlkTXV0YXRlZChvKTtcbiAgICB9LCAoZSA9IHRoaXMuZWRpdG9yRXZlbnRCdXMpID09IG51bGwgfHwgZS5vbihKZSwgdGhpcy5yZWRhY3RvckRvbUNoYW5nZWRDYWxsYmFjayk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSByZWRhY3RvciBkb20gY2hhbmdlIGV2ZW50IGxpc3RlbmVyXG4gICAqL1xuICB1bndhdGNoQmxvY2tNdXRhdGlvbnMoKSB7XG4gICAgdmFyIGU7XG4gICAgKGUgPSB0aGlzLmVkaXRvckV2ZW50QnVzKSA9PSBudWxsIHx8IGUub2ZmKEplLCB0aGlzLnJlZGFjdG9yRG9tQ2hhbmdlZENhbGxiYWNrKTtcbiAgfVxuICAvKipcbiAgICogU29tZXRpbWVzIFRvb2wgY2FuIHJlcGxhY2Ugb3duIG1haW4gZWxlbWVudCwgZm9yIGV4YW1wbGUgSDIgLT4gSDQgb3IgVUwgLT4gT0xcbiAgICogV2UgbmVlZCB0byBkZXRlY3Qgc3VjaCBjaGFuZ2VzIGFuZCB1cGRhdGUgYSBsaW5rIHRvIHRvb2xzIG1haW4gZWxlbWVudCB3aXRoIHRoZSBuZXcgb25lXG4gICAqXG4gICAqIEBwYXJhbSBtdXRhdGlvbnMgLSByZWNvcmRzIG9mIGJsb2NrIGNvbnRlbnQgbXV0YXRpb25zXG4gICAqL1xuICBkZXRlY3RUb29sUm9vdENoYW5nZShlKSB7XG4gICAgZS5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBpZiAoQXJyYXkuZnJvbSh0LnJlbW92ZWROb2RlcykuaW5jbHVkZXModGhpcy50b29sUmVuZGVyZWRFbGVtZW50KSkge1xuICAgICAgICBjb25zdCBpID0gdC5hZGRlZE5vZGVzW3QuYWRkZWROb2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgdGhpcy50b29sUmVuZGVyZWRFbGVtZW50ID0gaTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ2xlYXJzIGlucHV0cyBjYWNoZWQgdmFsdWVcbiAgICovXG4gIGRyb3BJbnB1dHNDYWNoZSgpIHtcbiAgICB0aGlzLmNhY2hlZElucHV0cyA9IFtdO1xuICB9XG4gIC8qKlxuICAgKiBNYXJrIGlucHV0cyB3aXRoICdkYXRhLWVtcHR5JyBhdHRyaWJ1dGUgd2l0aCB0aGUgZW1wdHkgc3RhdGVcbiAgICovXG4gIHRvZ2dsZUlucHV0c0VtcHR5TWFyaygpIHtcbiAgICB0aGlzLmlucHV0cy5mb3JFYWNoKE90KTtcbiAgfVxufVxuY2xhc3MgZmkgZXh0ZW5kcyB5IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy5pbnNlcnQgPSAoZSA9IHRoaXMuY29uZmlnLmRlZmF1bHRCbG9jaywgdCA9IHt9LCBvID0ge30sIGksIHMsIHIsIGwpID0+IHtcbiAgICAgIGNvbnN0IGEgPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuaW5zZXJ0KHtcbiAgICAgICAgaWQ6IGwsXG4gICAgICAgIHRvb2w6IGUsXG4gICAgICAgIGRhdGE6IHQsXG4gICAgICAgIGluZGV4OiBpLFxuICAgICAgICBuZWVkVG9Gb2N1czogcyxcbiAgICAgICAgcmVwbGFjZTogclxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IEcoYSk7XG4gICAgfSwgdGhpcy5jb21wb3NlQmxvY2tEYXRhID0gYXN5bmMgKGUpID0+IHtcbiAgICAgIGNvbnN0IHQgPSB0aGlzLkVkaXRvci5Ub29scy5ibG9ja1Rvb2xzLmdldChlKTtcbiAgICAgIHJldHVybiBuZXcgRCh7XG4gICAgICAgIHRvb2w6IHQsXG4gICAgICAgIGFwaTogdGhpcy5FZGl0b3IuQVBJLFxuICAgICAgICByZWFkT25seTogITAsXG4gICAgICAgIGRhdGE6IHt9LFxuICAgICAgICB0dW5lc0RhdGE6IHt9XG4gICAgICB9KS5kYXRhO1xuICAgIH0sIHRoaXMudXBkYXRlID0gYXN5bmMgKGUsIHQsIG8pID0+IHtcbiAgICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiBpIH0gPSB0aGlzLkVkaXRvciwgcyA9IGkuZ2V0QmxvY2tCeUlkKGUpO1xuICAgICAgaWYgKHMgPT09IHZvaWQgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCbG9jayB3aXRoIGlkIFwiJHtlfVwiIG5vdCBmb3VuZGApO1xuICAgICAgY29uc3QgciA9IGF3YWl0IGkudXBkYXRlKHMsIHQsIG8pO1xuICAgICAgcmV0dXJuIG5ldyBHKHIpO1xuICAgIH0sIHRoaXMuY29udmVydCA9IGFzeW5jIChlLCB0LCBvKSA9PiB7XG4gICAgICB2YXIgaCwgcDtcbiAgICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiBpLCBUb29sczogcyB9ID0gdGhpcy5FZGl0b3IsIHIgPSBpLmdldEJsb2NrQnlJZChlKTtcbiAgICAgIGlmICghcilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCbG9jayB3aXRoIGlkIFwiJHtlfVwiIG5vdCBmb3VuZGApO1xuICAgICAgY29uc3QgbCA9IHMuYmxvY2tUb29scy5nZXQoci5uYW1lKSwgYSA9IHMuYmxvY2tUb29scy5nZXQodCk7XG4gICAgICBpZiAoIWEpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQmxvY2sgVG9vbCB3aXRoIHR5cGUgXCIke3R9XCIgbm90IGZvdW5kYCk7XG4gICAgICBjb25zdCBjID0gKChoID0gbCA9PSBudWxsID8gdm9pZCAwIDogbC5jb252ZXJzaW9uQ29uZmlnKSA9PSBudWxsID8gdm9pZCAwIDogaC5leHBvcnQpICE9PSB2b2lkIDAsIHUgPSAoKHAgPSBhLmNvbnZlcnNpb25Db25maWcpID09IG51bGwgPyB2b2lkIDAgOiBwLmltcG9ydCkgIT09IHZvaWQgMDtcbiAgICAgIGlmIChjICYmIHUpIHtcbiAgICAgICAgY29uc3QgZyA9IGF3YWl0IGkuY29udmVydChyLCB0LCBvKTtcbiAgICAgICAgcmV0dXJuIG5ldyBHKGcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZyA9IFtcbiAgICAgICAgICBjID8gITEgOiBPZShyLm5hbWUpLFxuICAgICAgICAgIHUgPyAhMSA6IE9lKHQpXG4gICAgICAgIF0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCIgYW5kIFwiKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb252ZXJzaW9uIGZyb20gXCIke3IubmFtZX1cIiB0byBcIiR7dH1cIiBpcyBub3QgcG9zc2libGUuICR7Z30gdG9vbChzKSBzaG91bGQgcHJvdmlkZSBhIFwiY29udmVyc2lvbkNvbmZpZ1wiYCk7XG4gICAgICB9XG4gICAgfSwgdGhpcy5pbnNlcnRNYW55ID0gKGUsIHQgPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuYmxvY2tzLmxlbmd0aCAtIDEpID0+IHtcbiAgICAgIHRoaXMudmFsaWRhdGVJbmRleCh0KTtcbiAgICAgIGNvbnN0IG8gPSBlLm1hcCgoeyBpZDogaSwgdHlwZTogcywgZGF0YTogciB9KSA9PiB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY29tcG9zZUJsb2NrKHtcbiAgICAgICAgaWQ6IGksXG4gICAgICAgIHRvb2w6IHMgfHwgdGhpcy5jb25maWcuZGVmYXVsdEJsb2NrLFxuICAgICAgICBkYXRhOiByXG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmluc2VydE1hbnkobywgdCksIG8ubWFwKChpKSA9PiBuZXcgRyhpKSk7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQXZhaWxhYmxlIG1ldGhvZHNcbiAgICpcbiAgICogQHJldHVybnMge0Jsb2Nrc31cbiAgICovXG4gIGdldCBtZXRob2RzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGVhcjogKCkgPT4gdGhpcy5jbGVhcigpLFxuICAgICAgcmVuZGVyOiAoZSkgPT4gdGhpcy5yZW5kZXIoZSksXG4gICAgICByZW5kZXJGcm9tSFRNTDogKGUpID0+IHRoaXMucmVuZGVyRnJvbUhUTUwoZSksXG4gICAgICBkZWxldGU6IChlKSA9PiB0aGlzLmRlbGV0ZShlKSxcbiAgICAgIHN3YXA6IChlLCB0KSA9PiB0aGlzLnN3YXAoZSwgdCksXG4gICAgICBtb3ZlOiAoZSwgdCkgPT4gdGhpcy5tb3ZlKGUsIHQpLFxuICAgICAgZ2V0QmxvY2tCeUluZGV4OiAoZSkgPT4gdGhpcy5nZXRCbG9ja0J5SW5kZXgoZSksXG4gICAgICBnZXRCeUlkOiAoZSkgPT4gdGhpcy5nZXRCeUlkKGUpLFxuICAgICAgZ2V0Q3VycmVudEJsb2NrSW5kZXg6ICgpID0+IHRoaXMuZ2V0Q3VycmVudEJsb2NrSW5kZXgoKSxcbiAgICAgIGdldEJsb2NrSW5kZXg6IChlKSA9PiB0aGlzLmdldEJsb2NrSW5kZXgoZSksXG4gICAgICBnZXRCbG9ja3NDb3VudDogKCkgPT4gdGhpcy5nZXRCbG9ja3NDb3VudCgpLFxuICAgICAgZ2V0QmxvY2tCeUVsZW1lbnQ6IChlKSA9PiB0aGlzLmdldEJsb2NrQnlFbGVtZW50KGUpLFxuICAgICAgc3RyZXRjaEJsb2NrOiAoZSwgdCA9ICEwKSA9PiB0aGlzLnN0cmV0Y2hCbG9jayhlLCB0KSxcbiAgICAgIGluc2VydE5ld0Jsb2NrOiAoKSA9PiB0aGlzLmluc2VydE5ld0Jsb2NrKCksXG4gICAgICBpbnNlcnQ6IHRoaXMuaW5zZXJ0LFxuICAgICAgaW5zZXJ0TWFueTogdGhpcy5pbnNlcnRNYW55LFxuICAgICAgdXBkYXRlOiB0aGlzLnVwZGF0ZSxcbiAgICAgIGNvbXBvc2VCbG9ja0RhdGE6IHRoaXMuY29tcG9zZUJsb2NrRGF0YSxcbiAgICAgIGNvbnZlcnQ6IHRoaXMuY29udmVydFxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgQmxvY2tzIGNvdW50XG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBnZXRCbG9ja3NDb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmJsb2Nrcy5sZW5ndGg7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgY3VycmVudCBibG9jayBpbmRleFxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0Q3VycmVudEJsb2NrSW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5jdXJyZW50QmxvY2tJbmRleDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaW5kZXggb2YgQmxvY2sgYnkgaWQ7XG4gICAqXG4gICAqIEBwYXJhbSBpZCAtIGJsb2NrIGlkXG4gICAqL1xuICBnZXRCbG9ja0luZGV4KGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmdldEJsb2NrQnlJZChlKTtcbiAgICBpZiAoIXQpIHtcbiAgICAgIEsoXCJUaGVyZSBpcyBubyBibG9jayB3aXRoIGlkIGBcIiArIGUgKyBcImBcIiwgXCJ3YXJuXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmdldEJsb2NrSW5kZXgodCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgQmxvY2tBUEkgb2JqZWN0IGJ5IEJsb2NrIGluZGV4XG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIGluZGV4IHRvIGdldFxuICAgKi9cbiAgZ2V0QmxvY2tCeUluZGV4KGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmdldEJsb2NrQnlJbmRleChlKTtcbiAgICBpZiAodCA9PT0gdm9pZCAwKSB7XG4gICAgICBLKFwiVGhlcmUgaXMgbm8gYmxvY2sgYXQgaW5kZXggYFwiICsgZSArIFwiYFwiLCBcIndhcm5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBuZXcgRyh0KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBCbG9ja0FQSSBvYmplY3QgYnkgQmxvY2sgaWRcbiAgICpcbiAgICogQHBhcmFtIGlkIC0gaWQgb2YgYmxvY2sgdG8gZ2V0XG4gICAqL1xuICBnZXRCeUlkKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmdldEJsb2NrQnlJZChlKTtcbiAgICByZXR1cm4gdCA9PT0gdm9pZCAwID8gKEsoXCJUaGVyZSBpcyBubyBibG9jayB3aXRoIGlkIGBcIiArIGUgKyBcImBcIiwgXCJ3YXJuXCIpLCBudWxsKSA6IG5ldyBHKHQpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgQmxvY2sgQVBJIG9iamVjdCBieSBhbnkgY2hpbGQgaHRtbCBlbGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSBlbGVtZW50IC0gaHRtbCBlbGVtZW50IHRvIGdldCBCbG9jayBieVxuICAgKi9cbiAgZ2V0QmxvY2tCeUVsZW1lbnQoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuZ2V0QmxvY2soZSk7XG4gICAgaWYgKHQgPT09IHZvaWQgMCkge1xuICAgICAgSyhcIlRoZXJlIGlzIG5vIGJsb2NrIGNvcnJlc3BvbmRpbmcgdG8gZWxlbWVudCBgXCIgKyBlICsgXCJgXCIsIFwid2FyblwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBHKHQpO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsIEJsb2NrIE1hbmFnZXIgbWV0aG9kIHRoYXQgc3dhcCBCbG9ja3NcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCAtIHBvc2l0aW9uIG9mIGZpcnN0IEJsb2NrXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0b0luZGV4IC0gcG9zaXRpb24gb2Ygc2Vjb25kIEJsb2NrXG4gICAqIEBkZXByZWNhdGVkIOKAlCB1c2UgJ21vdmUnIGluc3RlYWRcbiAgICovXG4gIHN3YXAoZSwgdCkge1xuICAgIEkoXG4gICAgICBcImBibG9ja3Muc3dhcCgpYCBtZXRob2QgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuIFVzZSBgYmxvY2subW92ZSgpYCBtZXRob2QgaW5zdGVhZFwiLFxuICAgICAgXCJpbmZvXCJcbiAgICApLCB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuc3dhcChlLCB0KTtcbiAgfVxuICAvKipcbiAgICogTW92ZSBibG9jayBmcm9tIG9uZSBpbmRleCB0byBhbm90aGVyXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0b0luZGV4IC0gaW5kZXggdG8gbW92ZSB0b1xuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IC0gaW5kZXggdG8gbW92ZSBmcm9tXG4gICAqL1xuICBtb3ZlKGUsIHQpIHtcbiAgICB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIubW92ZShlLCB0KTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlcyBCbG9ja1xuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gYmxvY2tJbmRleCAtIGluZGV4IG9mIEJsb2NrIHRvIGRlbGV0ZVxuICAgKi9cbiAgZGVsZXRlKGUgPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY3VycmVudEJsb2NrSW5kZXgpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdCA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5nZXRCbG9ja0J5SW5kZXgoZSk7XG4gICAgICB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIucmVtb3ZlQmxvY2sodCk7XG4gICAgfSBjYXRjaCAodCkge1xuICAgICAgSyh0LCBcIndhcm5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5ibG9ja3MubGVuZ3RoID09PSAwICYmIHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5pbnNlcnQoKSwgdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmN1cnJlbnRCbG9jayAmJiB0aGlzLkVkaXRvci5DYXJldC5zZXRUb0Jsb2NrKHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5jdXJyZW50QmxvY2ssIHRoaXMuRWRpdG9yLkNhcmV0LnBvc2l0aW9ucy5FTkQpLCB0aGlzLkVkaXRvci5Ub29sYmFyLmNsb3NlKCk7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFyIEVkaXRvcidzIGFyZWFcbiAgICovXG4gIGFzeW5jIGNsZWFyKCkge1xuICAgIGF3YWl0IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5jbGVhcighMCksIHRoaXMuRWRpdG9yLklubGluZVRvb2xiYXIuY2xvc2UoKTtcbiAgfVxuICAvKipcbiAgICogRmlsbHMgRWRpdG9yIHdpdGggQmxvY2tzIGRhdGFcbiAgICpcbiAgICogQHBhcmFtIHtPdXRwdXREYXRhfSBkYXRhIOKAlCBTYXZlZCBFZGl0b3IgZGF0YVxuICAgKi9cbiAgYXN5bmMgcmVuZGVyKGUpIHtcbiAgICBpZiAoZSA9PT0gdm9pZCAwIHx8IGUuYmxvY2tzID09PSB2b2lkIDApXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbmNvcnJlY3QgZGF0YSBwYXNzZWQgdG8gdGhlIHJlbmRlcigpIG1ldGhvZFwiKTtcbiAgICB0aGlzLkVkaXRvci5Nb2RpZmljYXRpb25zT2JzZXJ2ZXIuZGlzYWJsZSgpLCBhd2FpdCB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY2xlYXIoKSwgYXdhaXQgdGhpcy5FZGl0b3IuUmVuZGVyZXIucmVuZGVyKGUuYmxvY2tzKSwgdGhpcy5FZGl0b3IuTW9kaWZpY2F0aW9uc09ic2VydmVyLmVuYWJsZSgpO1xuICB9XG4gIC8qKlxuICAgKiBSZW5kZXIgcGFzc2VkIEhUTUwgc3RyaW5nXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhIC0gSFRNTCBzdHJpbmcgdG8gcmVuZGVyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cbiAgcmVuZGVyRnJvbUhUTUwoZSkge1xuICAgIHJldHVybiB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY2xlYXIoKSwgdGhpcy5FZGl0b3IuUGFzdGUucHJvY2Vzc1RleHQoZSwgITApO1xuICB9XG4gIC8qKlxuICAgKiBTdHJldGNoIEJsb2NrJ3MgY29udGVudFxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBpbmRleCBvZiBCbG9jayB0byBzdHJldGNoXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc3RhdHVzIC0gdHJ1ZSB0byBlbmFibGUsIGZhbHNlIHRvIGRpc2FibGVcbiAgICogQGRlcHJlY2F0ZWQgVXNlIEJsb2NrQVBJIGludGVyZmFjZSB0byBzdHJldGNoIEJsb2Nrc1xuICAgKi9cbiAgc3RyZXRjaEJsb2NrKGUsIHQgPSAhMCkge1xuICAgIFplKFxuICAgICAgITAsXG4gICAgICBcImJsb2Nrcy5zdHJldGNoQmxvY2soKVwiLFxuICAgICAgXCJCbG9ja0FQSVwiXG4gICAgKTtcbiAgICBjb25zdCBvID0gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmdldEJsb2NrQnlJbmRleChlKTtcbiAgICBvICYmIChvLnN0cmV0Y2hlZCA9IHQpO1xuICB9XG4gIC8qKlxuICAgKiBJbnNlcnQgbmV3IEJsb2NrXG4gICAqIEFmdGVyIHNldCBjYXJldCB0byB0aGlzIEJsb2NrXG4gICAqXG4gICAqIEB0b2RvIHJlbW92ZSBpbiAzLjAuMFxuICAgKiBAZGVwcmVjYXRlZCB3aXRoIGluc2VydCgpIG1ldGhvZFxuICAgKi9cbiAgaW5zZXJ0TmV3QmxvY2soKSB7XG4gICAgSShcIk1ldGhvZCBibG9ja3MuaW5zZXJ0TmV3QmxvY2soKSBpcyBkZXByZWNhdGVkIGFuZCBpdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS4gVXNlIGJsb2Nrcy5pbnNlcnQoKSBpbnN0ZWFkLlwiLCBcIndhcm5cIiksIHRoaXMuaW5zZXJ0KCk7XG4gIH1cbiAgLyoqXG4gICAqIFZhbGlkYXRlZCBibG9jayBpbmRleCBhbmQgdGhyb3dzIGFuIGVycm9yIGlmIGl0J3MgaW52YWxpZFxuICAgKlxuICAgKiBAcGFyYW0gaW5kZXggLSBpbmRleCB0byB2YWxpZGF0ZVxuICAgKi9cbiAgdmFsaWRhdGVJbmRleChlKSB7XG4gICAgaWYgKHR5cGVvZiBlICE9IFwibnVtYmVyXCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbmRleCBzaG91bGQgYmUgYSBudW1iZXJcIik7XG4gICAgaWYgKGUgPCAwKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5kZXggc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAwXCIpO1xuICAgIGlmIChlID09PSBudWxsKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5kZXggc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAwXCIpO1xuICB9XG59XG5mdW5jdGlvbiBnaShuLCBlKSB7XG4gIHJldHVybiB0eXBlb2YgbiA9PSBcIm51bWJlclwiID8gZS5CbG9ja01hbmFnZXIuZ2V0QmxvY2tCeUluZGV4KG4pIDogdHlwZW9mIG4gPT0gXCJzdHJpbmdcIiA/IGUuQmxvY2tNYW5hZ2VyLmdldEJsb2NrQnlJZChuKSA6IGUuQmxvY2tNYW5hZ2VyLmdldEJsb2NrQnlJZChuLmlkKTtcbn1cbmNsYXNzIG1pIGV4dGVuZHMgeSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMuc2V0VG9GaXJzdEJsb2NrID0gKGUgPSB0aGlzLkVkaXRvci5DYXJldC5wb3NpdGlvbnMuREVGQVVMVCwgdCA9IDApID0+IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5maXJzdEJsb2NrID8gKHRoaXMuRWRpdG9yLkNhcmV0LnNldFRvQmxvY2sodGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmZpcnN0QmxvY2ssIGUsIHQpLCAhMCkgOiAhMSwgdGhpcy5zZXRUb0xhc3RCbG9jayA9IChlID0gdGhpcy5FZGl0b3IuQ2FyZXQucG9zaXRpb25zLkRFRkFVTFQsIHQgPSAwKSA9PiB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIubGFzdEJsb2NrID8gKHRoaXMuRWRpdG9yLkNhcmV0LnNldFRvQmxvY2sodGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmxhc3RCbG9jaywgZSwgdCksICEwKSA6ICExLCB0aGlzLnNldFRvUHJldmlvdXNCbG9jayA9IChlID0gdGhpcy5FZGl0b3IuQ2FyZXQucG9zaXRpb25zLkRFRkFVTFQsIHQgPSAwKSA9PiB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIucHJldmlvdXNCbG9jayA/ICh0aGlzLkVkaXRvci5DYXJldC5zZXRUb0Jsb2NrKHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5wcmV2aW91c0Jsb2NrLCBlLCB0KSwgITApIDogITEsIHRoaXMuc2V0VG9OZXh0QmxvY2sgPSAoZSA9IHRoaXMuRWRpdG9yLkNhcmV0LnBvc2l0aW9ucy5ERUZBVUxULCB0ID0gMCkgPT4gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLm5leHRCbG9jayA/ICh0aGlzLkVkaXRvci5DYXJldC5zZXRUb0Jsb2NrKHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5uZXh0QmxvY2ssIGUsIHQpLCAhMCkgOiAhMSwgdGhpcy5zZXRUb0Jsb2NrID0gKGUsIHQgPSB0aGlzLkVkaXRvci5DYXJldC5wb3NpdGlvbnMuREVGQVVMVCwgbyA9IDApID0+IHtcbiAgICAgIGNvbnN0IGkgPSBnaShlLCB0aGlzLkVkaXRvcik7XG4gICAgICByZXR1cm4gaSA9PT0gdm9pZCAwID8gITEgOiAodGhpcy5FZGl0b3IuQ2FyZXQuc2V0VG9CbG9jayhpLCB0LCBvKSwgITApO1xuICAgIH0sIHRoaXMuZm9jdXMgPSAoZSA9ICExKSA9PiBlID8gdGhpcy5zZXRUb0xhc3RCbG9jayh0aGlzLkVkaXRvci5DYXJldC5wb3NpdGlvbnMuRU5EKSA6IHRoaXMuc2V0VG9GaXJzdEJsb2NrKHRoaXMuRWRpdG9yLkNhcmV0LnBvc2l0aW9ucy5TVEFSVCk7XG4gIH1cbiAgLyoqXG4gICAqIEF2YWlsYWJsZSBtZXRob2RzXG4gICAqXG4gICAqIEByZXR1cm5zIHtDYXJldH1cbiAgICovXG4gIGdldCBtZXRob2RzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzZXRUb0ZpcnN0QmxvY2s6IHRoaXMuc2V0VG9GaXJzdEJsb2NrLFxuICAgICAgc2V0VG9MYXN0QmxvY2s6IHRoaXMuc2V0VG9MYXN0QmxvY2ssXG4gICAgICBzZXRUb1ByZXZpb3VzQmxvY2s6IHRoaXMuc2V0VG9QcmV2aW91c0Jsb2NrLFxuICAgICAgc2V0VG9OZXh0QmxvY2s6IHRoaXMuc2V0VG9OZXh0QmxvY2ssXG4gICAgICBzZXRUb0Jsb2NrOiB0aGlzLnNldFRvQmxvY2ssXG4gICAgICBmb2N1czogdGhpcy5mb2N1c1xuICAgIH07XG4gIH1cbn1cbmNsYXNzIGJpIGV4dGVuZHMgeSB7XG4gIC8qKlxuICAgKiBBdmFpbGFibGUgbWV0aG9kc1xuICAgKlxuICAgKiBAcmV0dXJucyB7RXZlbnRzfVxuICAgKi9cbiAgZ2V0IG1ldGhvZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVtaXQ6IChlLCB0KSA9PiB0aGlzLmVtaXQoZSwgdCksXG4gICAgICBvZmY6IChlLCB0KSA9PiB0aGlzLm9mZihlLCB0KSxcbiAgICAgIG9uOiAoZSwgdCkgPT4gdGhpcy5vbihlLCB0KVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFN1YnNjcmliZSBvbiBFdmVudHNcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSAtIGV2ZW50IG5hbWUgdG8gc3Vic2NyaWJlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gZXZlbnQgaGFuZGxlclxuICAgKi9cbiAgb24oZSwgdCkge1xuICAgIHRoaXMuZXZlbnRzRGlzcGF0Y2hlci5vbihlLCB0KTtcbiAgfVxuICAvKipcbiAgICogRW1pdCBldmVudCB3aXRoIGRhdGFcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSAtIGV2ZW50IHRvIGVtaXRcbiAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgLSBldmVudCdzIGRhdGFcbiAgICovXG4gIGVtaXQoZSwgdCkge1xuICAgIHRoaXMuZXZlbnRzRGlzcGF0Y2hlci5lbWl0KGUsIHQpO1xuICB9XG4gIC8qKlxuICAgKiBVbnN1YnNjcmliZSBmcm9tIEV2ZW50XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgLSBldmVudCB0byB1bnN1YnNjcmliZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIGV2ZW50IGhhbmRsZXJcbiAgICovXG4gIG9mZihlLCB0KSB7XG4gICAgdGhpcy5ldmVudHNEaXNwYXRjaGVyLm9mZihlLCB0KTtcbiAgfVxufVxuY2xhc3Mgc3QgZXh0ZW5kcyB5IHtcbiAgLyoqXG4gICAqIFJldHVybiBuYW1lc3BhY2Ugc2VjdGlvbiBmb3IgdG9vbCBvciBibG9jayB0dW5lXG4gICAqXG4gICAqIEBwYXJhbSB0b29sTmFtZSAtIHRvb2wgbmFtZVxuICAgKiBAcGFyYW0gaXNUdW5lIC0gaXMgdG9vbCBhIGJsb2NrIHR1bmVcbiAgICovXG4gIHN0YXRpYyBnZXROYW1lc3BhY2UoZSwgdCkge1xuICAgIHJldHVybiB0ID8gYGJsb2NrVHVuZXMuJHtlfWAgOiBgdG9vbHMuJHtlfWA7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBJMThuIEFQSSBtZXRob2RzIHdpdGggZ2xvYmFsIGRpY3Rpb25hcnkgYWNjZXNzXG4gICAqL1xuICBnZXQgbWV0aG9kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdDogKCkgPT4ge1xuICAgICAgICBLKFwiSTE4bi50KCkgbWV0aG9kIGNhbiBiZSBhY2Nlc3NlZCBvbmx5IGZyb20gVG9vbHNcIiwgXCJ3YXJuXCIpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBJMThuIEFQSSBtZXRob2RzIHdpdGggdG9vbCBuYW1lc3BhY2VkIGRpY3Rpb25hcnlcbiAgICpcbiAgICogQHBhcmFtIHRvb2xOYW1lIC0gdG9vbCBuYW1lXG4gICAqIEBwYXJhbSBpc1R1bmUgLSBpcyB0b29sIGEgYmxvY2sgdHVuZVxuICAgKi9cbiAgZ2V0TWV0aG9kc0ZvclRvb2woZSwgdCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgICAgdGhpcy5tZXRob2RzLFxuICAgICAge1xuICAgICAgICB0OiAobykgPT4gVy50KHN0LmdldE5hbWVzcGFjZShlLCB0KSwgbylcbiAgICAgIH1cbiAgICApO1xuICB9XG59XG5jbGFzcyBraSBleHRlbmRzIHkge1xuICAvKipcbiAgICogRWRpdG9yLmpzIENvcmUgQVBJIG1vZHVsZXNcbiAgICovXG4gIGdldCBtZXRob2RzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBibG9ja3M6IHRoaXMuRWRpdG9yLkJsb2Nrc0FQSS5tZXRob2RzLFxuICAgICAgY2FyZXQ6IHRoaXMuRWRpdG9yLkNhcmV0QVBJLm1ldGhvZHMsXG4gICAgICB0b29sczogdGhpcy5FZGl0b3IuVG9vbHNBUEkubWV0aG9kcyxcbiAgICAgIGV2ZW50czogdGhpcy5FZGl0b3IuRXZlbnRzQVBJLm1ldGhvZHMsXG4gICAgICBsaXN0ZW5lcnM6IHRoaXMuRWRpdG9yLkxpc3RlbmVyc0FQSS5tZXRob2RzLFxuICAgICAgbm90aWZpZXI6IHRoaXMuRWRpdG9yLk5vdGlmaWVyQVBJLm1ldGhvZHMsXG4gICAgICBzYW5pdGl6ZXI6IHRoaXMuRWRpdG9yLlNhbml0aXplckFQSS5tZXRob2RzLFxuICAgICAgc2F2ZXI6IHRoaXMuRWRpdG9yLlNhdmVyQVBJLm1ldGhvZHMsXG4gICAgICBzZWxlY3Rpb246IHRoaXMuRWRpdG9yLlNlbGVjdGlvbkFQSS5tZXRob2RzLFxuICAgICAgc3R5bGVzOiB0aGlzLkVkaXRvci5TdHlsZXNBUEkuY2xhc3NlcyxcbiAgICAgIHRvb2xiYXI6IHRoaXMuRWRpdG9yLlRvb2xiYXJBUEkubWV0aG9kcyxcbiAgICAgIGlubGluZVRvb2xiYXI6IHRoaXMuRWRpdG9yLklubGluZVRvb2xiYXJBUEkubWV0aG9kcyxcbiAgICAgIHRvb2x0aXA6IHRoaXMuRWRpdG9yLlRvb2x0aXBBUEkubWV0aG9kcyxcbiAgICAgIGkxOG46IHRoaXMuRWRpdG9yLkkxOG5BUEkubWV0aG9kcyxcbiAgICAgIHJlYWRPbmx5OiB0aGlzLkVkaXRvci5SZWFkT25seUFQSS5tZXRob2RzLFxuICAgICAgdWk6IHRoaXMuRWRpdG9yLlVpQVBJLm1ldGhvZHNcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIEVkaXRvci5qcyBDb3JlIEFQSSBtZXRob2RzIGZvciBwYXNzZWQgdG9vbFxuICAgKlxuICAgKiBAcGFyYW0gdG9vbE5hbWUgLSB0b29sIG5hbWVcbiAgICogQHBhcmFtIGlzVHVuZSAtIGlzIHRvb2wgYSBibG9jayB0dW5lXG4gICAqL1xuICBnZXRNZXRob2RzRm9yVG9vbChlLCB0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICB0aGlzLm1ldGhvZHMsXG4gICAgICB7XG4gICAgICAgIGkxOG46IHRoaXMuRWRpdG9yLkkxOG5BUEkuZ2V0TWV0aG9kc0ZvclRvb2woZSwgdClcbiAgICAgIH1cbiAgICApO1xuICB9XG59XG5jbGFzcyB2aSBleHRlbmRzIHkge1xuICAvKipcbiAgICogQXZhaWxhYmxlIG1ldGhvZHNcbiAgICpcbiAgICogQHJldHVybnMge0lubGluZVRvb2xiYXJ9XG4gICAqL1xuICBnZXQgbWV0aG9kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xvc2U6ICgpID0+IHRoaXMuY2xvc2UoKSxcbiAgICAgIG9wZW46ICgpID0+IHRoaXMub3BlbigpXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogT3BlbiBJbmxpbmUgVG9vbGJhclxuICAgKi9cbiAgb3BlbigpIHtcbiAgICB0aGlzLkVkaXRvci5JbmxpbmVUb29sYmFyLnRyeVRvU2hvdygpO1xuICB9XG4gIC8qKlxuICAgKiBDbG9zZSBJbmxpbmUgVG9vbGJhclxuICAgKi9cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy5FZGl0b3IuSW5saW5lVG9vbGJhci5jbG9zZSgpO1xuICB9XG59XG5jbGFzcyB3aSBleHRlbmRzIHkge1xuICAvKipcbiAgICogQXZhaWxhYmxlIG1ldGhvZHNcbiAgICpcbiAgICogQHJldHVybnMge0xpc3RlbmVyc31cbiAgICovXG4gIGdldCBtZXRob2RzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBvbjogKGUsIHQsIG8sIGkpID0+IHRoaXMub24oZSwgdCwgbywgaSksXG4gICAgICBvZmY6IChlLCB0LCBvLCBpKSA9PiB0aGlzLm9mZihlLCB0LCBvLCBpKSxcbiAgICAgIG9mZkJ5SWQ6IChlKSA9PiB0aGlzLm9mZkJ5SWQoZSlcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBBZHMgYSBET00gZXZlbnQgbGlzdGVuZXIuIFJldHVybiBpdCdzIGlkLlxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byBzZXQgaGFuZGxlciB0b1xuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlIC0gZXZlbnQgdHlwZVxuICAgKiBAcGFyYW0geygpID0+IHZvaWR9IGhhbmRsZXIgLSBldmVudCBoYW5kbGVyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdXNlQ2FwdHVyZSAtIGNhcHR1cmUgZXZlbnQgb3Igbm90XG4gICAqL1xuICBvbihlLCB0LCBvLCBpKSB7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXJzLm9uKGUsIHQsIG8sIGkpO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIERPTSBsaXN0ZW5lciBmcm9tIGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byByZW1vdmUgaGFuZGxlciBmcm9tXG4gICAqIEBwYXJhbSBldmVudFR5cGUgLSBldmVudCB0eXBlXG4gICAqIEBwYXJhbSBoYW5kbGVyIC0gZXZlbnQgaGFuZGxlclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHVzZUNhcHR1cmUgLSBjYXB0dXJlIGV2ZW50IG9yIG5vdFxuICAgKi9cbiAgb2ZmKGUsIHQsIG8sIGkpIHtcbiAgICB0aGlzLmxpc3RlbmVycy5vZmYoZSwgdCwgbywgaSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgRE9NIGxpc3RlbmVyIGJ5IHRoZSBsaXN0ZW5lciBpZFxuICAgKlxuICAgKiBAcGFyYW0gaWQgLSBpZCBvZiB0aGUgbGlzdGVuZXIgdG8gcmVtb3ZlXG4gICAqL1xuICBvZmZCeUlkKGUpIHtcbiAgICB0aGlzLmxpc3RlbmVycy5vZmZCeUlkKGUpO1xuICB9XG59XG52YXIgWnQgPSB7IGV4cG9ydHM6IHt9IH07XG4oZnVuY3Rpb24obiwgZSkge1xuICAoZnVuY3Rpb24odCwgbykge1xuICAgIG4uZXhwb3J0cyA9IG8oKTtcbiAgfSkod2luZG93LCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgdmFyIG8gPSB7fTtcbiAgICAgIGZ1bmN0aW9uIGkocykge1xuICAgICAgICBpZiAob1tzXSlcbiAgICAgICAgICByZXR1cm4gb1tzXS5leHBvcnRzO1xuICAgICAgICB2YXIgciA9IG9bc10gPSB7IGk6IHMsIGw6ICExLCBleHBvcnRzOiB7fSB9O1xuICAgICAgICByZXR1cm4gdFtzXS5jYWxsKHIuZXhwb3J0cywgciwgci5leHBvcnRzLCBpKSwgci5sID0gITAsIHIuZXhwb3J0cztcbiAgICAgIH1cbiAgICAgIHJldHVybiBpLm0gPSB0LCBpLmMgPSBvLCBpLmQgPSBmdW5jdGlvbihzLCByLCBsKSB7XG4gICAgICAgIGkubyhzLCByKSB8fCBPYmplY3QuZGVmaW5lUHJvcGVydHkocywgciwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBsIH0pO1xuICAgICAgfSwgaS5yID0gZnVuY3Rpb24ocykge1xuICAgICAgICB0eXBlb2YgU3ltYm9sIDwgXCJ1XCIgJiYgU3ltYm9sLnRvU3RyaW5nVGFnICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG4gICAgICB9LCBpLnQgPSBmdW5jdGlvbihzLCByKSB7XG4gICAgICAgIGlmICgxICYgciAmJiAocyA9IGkocykpLCA4ICYgciB8fCA0ICYgciAmJiB0eXBlb2YgcyA9PSBcIm9iamVjdFwiICYmIHMgJiYgcy5fX2VzTW9kdWxlKVxuICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICB2YXIgbCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBpZiAoaS5yKGwpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkobCwgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogITAsIHZhbHVlOiBzIH0pLCAyICYgciAmJiB0eXBlb2YgcyAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgIGZvciAodmFyIGEgaW4gcylcbiAgICAgICAgICAgIGkuZChsLCBhLCAoZnVuY3Rpb24oYykge1xuICAgICAgICAgICAgICByZXR1cm4gc1tjXTtcbiAgICAgICAgICAgIH0pLmJpbmQobnVsbCwgYSkpO1xuICAgICAgICByZXR1cm4gbDtcbiAgICAgIH0sIGkubiA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgdmFyIHIgPSBzICYmIHMuX19lc01vZHVsZSA/IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBzLmRlZmF1bHQ7XG4gICAgICAgIH0gOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGkuZChyLCBcImFcIiwgciksIHI7XG4gICAgICB9LCBpLm8gPSBmdW5jdGlvbihzLCByKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcik7XG4gICAgICB9LCBpLnAgPSBcIi9cIiwgaShpLnMgPSAwKTtcbiAgICB9KFtmdW5jdGlvbih0LCBvLCBpKSB7XG4gICAgICBpKDEpLCAvKiFcbiAgICAgICAqIENvZGV4IEphdmFTY3JpcHQgTm90aWZpY2F0aW9uIG1vZHVsZVxuICAgICAgICogaHR0cHM6Ly9naXRodWIuY29tL2NvZGV4LXRlYW0vanMtbm90aWZpZXJcbiAgICAgICAqL1xuICAgICAgdC5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzID0gaSg2KSwgciA9IFwiY2R4LW5vdGlmeS0tYm91bmNlLWluXCIsIGwgPSBudWxsO1xuICAgICAgICByZXR1cm4geyBzaG93OiBmdW5jdGlvbihhKSB7XG4gICAgICAgICAgaWYgKGEubWVzc2FnZSkge1xuICAgICAgICAgICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBpZiAobClcbiAgICAgICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgICAgIGwgPSBzLmdldFdyYXBwZXIoKSwgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChsKTtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICB2YXIgYyA9IG51bGwsIHUgPSBhLnRpbWUgfHwgOGUzO1xuICAgICAgICAgICAgc3dpdGNoIChhLnR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcImNvbmZpcm1cIjpcbiAgICAgICAgICAgICAgICBjID0gcy5jb25maXJtKGEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwicHJvbXB0XCI6XG4gICAgICAgICAgICAgICAgYyA9IHMucHJvbXB0KGEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGMgPSBzLmFsZXJ0KGEpLCB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIGMucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgfSwgdSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsLmFwcGVuZENoaWxkKGMpLCBjLmNsYXNzTGlzdC5hZGQocik7XG4gICAgICAgICAgfVxuICAgICAgICB9IH07XG4gICAgICB9KCk7XG4gICAgfSwgZnVuY3Rpb24odCwgbywgaSkge1xuICAgICAgdmFyIHMgPSBpKDIpO1xuICAgICAgdHlwZW9mIHMgPT0gXCJzdHJpbmdcIiAmJiAocyA9IFtbdC5pLCBzLCBcIlwiXV0pO1xuICAgICAgdmFyIHIgPSB7IGhtcjogITAsIHRyYW5zZm9ybTogdm9pZCAwLCBpbnNlcnRJbnRvOiB2b2lkIDAgfTtcbiAgICAgIGkoNCkocywgciksIHMubG9jYWxzICYmICh0LmV4cG9ydHMgPSBzLmxvY2Fscyk7XG4gICAgfSwgZnVuY3Rpb24odCwgbywgaSkge1xuICAgICAgKHQuZXhwb3J0cyA9IGkoMykoITEpKS5wdXNoKFt0LmksIGAuY2R4LW5vdGlmeS0tZXJyb3J7YmFja2dyb3VuZDojZmZmYmZiIWltcG9ydGFudH0uY2R4LW5vdGlmeS0tZXJyb3I6OmJlZm9yZXtiYWNrZ3JvdW5kOiNmYjVkNWQhaW1wb3J0YW50fS5jZHgtbm90aWZ5X19pbnB1dHttYXgtd2lkdGg6MTMwcHg7cGFkZGluZzo1cHggMTBweDtiYWNrZ3JvdW5kOiNmN2Y3Zjc7Ym9yZGVyOjA7Ym9yZGVyLXJhZGl1czozcHg7Zm9udC1zaXplOjEzcHg7Y29sb3I6IzY1NmI3YztvdXRsaW5lOjB9LmNkeC1ub3RpZnlfX2lucHV0Oi1tcy1pbnB1dC1wbGFjZWhvbGRlcntjb2xvcjojNjU2YjdjfS5jZHgtbm90aWZ5X19pbnB1dDo6cGxhY2Vob2xkZXJ7Y29sb3I6IzY1NmI3Y30uY2R4LW5vdGlmeV9faW5wdXQ6Zm9jdXM6LW1zLWlucHV0LXBsYWNlaG9sZGVye2NvbG9yOnJnYmEoMTAxLDEwNywxMjQsLjMpfS5jZHgtbm90aWZ5X19pbnB1dDpmb2N1czo6cGxhY2Vob2xkZXJ7Y29sb3I6cmdiYSgxMDEsMTA3LDEyNCwuMyl9LmNkeC1ub3RpZnlfX2J1dHRvbntib3JkZXI6bm9uZTtib3JkZXItcmFkaXVzOjNweDtmb250LXNpemU6MTNweDtwYWRkaW5nOjVweCAxMHB4O2N1cnNvcjpwb2ludGVyfS5jZHgtbm90aWZ5X19idXR0b246bGFzdC1jaGlsZHttYXJnaW4tbGVmdDoxMHB4fS5jZHgtbm90aWZ5X19idXR0b24tLWNhbmNlbHtiYWNrZ3JvdW5kOiNmMmY1Zjc7Ym94LXNoYWRvdzowIDJweCAxcHggMCByZ2JhKDE2LDE5LDI5LDApO2NvbG9yOiM2NTZiN2N9LmNkeC1ub3RpZnlfX2J1dHRvbi0tY2FuY2VsOmhvdmVye2JhY2tncm91bmQ6I2VlZX0uY2R4LW5vdGlmeV9fYnV0dG9uLS1jb25maXJte2JhY2tncm91bmQ6IzM0Yzk5Mjtib3gtc2hhZG93OjAgMXB4IDFweCAwIHJnYmEoMTgsNDksMzUsLjA1KTtjb2xvcjojZmZmfS5jZHgtbm90aWZ5X19idXR0b24tLWNvbmZpcm06aG92ZXJ7YmFja2dyb3VuZDojMzNiMDgyfS5jZHgtbm90aWZ5X19idG5zLXdyYXBwZXJ7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7LW1zLWZsZXgtZmxvdzpyb3cgbm93cmFwO2ZsZXgtZmxvdzpyb3cgbm93cmFwO21hcmdpbi10b3A6NXB4fS5jZHgtbm90aWZ5X19jcm9zc3twb3NpdGlvbjphYnNvbHV0ZTt0b3A6NXB4O3JpZ2h0OjVweDt3aWR0aDoxMHB4O2hlaWdodDoxMHB4O3BhZGRpbmc6NXB4O29wYWNpdHk6LjU0O2N1cnNvcjpwb2ludGVyfS5jZHgtbm90aWZ5X19jcm9zczo6YWZ0ZXIsLmNkeC1ub3RpZnlfX2Nyb3NzOjpiZWZvcmV7Y29udGVudDonJztwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjlweDt0b3A6NXB4O2hlaWdodDoxMnB4O3dpZHRoOjJweDtiYWNrZ3JvdW5kOiM1NzVkNjd9LmNkeC1ub3RpZnlfX2Nyb3NzOjpiZWZvcmV7dHJhbnNmb3JtOnJvdGF0ZSgtNDVkZWcpfS5jZHgtbm90aWZ5X19jcm9zczo6YWZ0ZXJ7dHJhbnNmb3JtOnJvdGF0ZSg0NWRlZyl9LmNkeC1ub3RpZnlfX2Nyb3NzOmhvdmVye29wYWNpdHk6MX0uY2R4LW5vdGlmaWVze3Bvc2l0aW9uOmZpeGVkO3otaW5kZXg6Mjtib3R0b206MjBweDtsZWZ0OjIwcHg7Zm9udC1mYW1pbHk6LWFwcGxlLXN5c3RlbSxCbGlua01hY1N5c3RlbUZvbnQsXCJTZWdvZSBVSVwiLFJvYm90byxPeHlnZW4sVWJ1bnR1LENhbnRhcmVsbCxcIkZpcmEgU2Fuc1wiLFwiRHJvaWQgU2Fuc1wiLFwiSGVsdmV0aWNhIE5ldWVcIixzYW5zLXNlcmlmfS5jZHgtbm90aWZ5e3Bvc2l0aW9uOnJlbGF0aXZlO3dpZHRoOjIyMHB4O21hcmdpbi10b3A6MTVweDtwYWRkaW5nOjEzcHggMTZweDtiYWNrZ3JvdW5kOiNmZmY7Ym94LXNoYWRvdzowIDExcHggMTdweCAwIHJnYmEoMjMsMzIsNjEsLjEzKTtib3JkZXItcmFkaXVzOjVweDtmb250LXNpemU6MTRweDtsaW5lLWhlaWdodDoxLjRlbTt3b3JkLXdyYXA6YnJlYWstd29yZH0uY2R4LW5vdGlmeTo6YmVmb3Jle2NvbnRlbnQ6Jyc7cG9zaXRpb246YWJzb2x1dGU7ZGlzcGxheTpibG9jazt0b3A6MDtsZWZ0OjA7d2lkdGg6M3B4O2hlaWdodDpjYWxjKDEwMCUgLSA2cHgpO21hcmdpbjozcHg7Ym9yZGVyLXJhZGl1czo1cHg7YmFja2dyb3VuZDowIDB9QGtleWZyYW1lcyBib3VuY2VJbnswJXtvcGFjaXR5OjA7dHJhbnNmb3JtOnNjYWxlKC4zKX01MCV7b3BhY2l0eToxO3RyYW5zZm9ybTpzY2FsZSgxLjA1KX03MCV7dHJhbnNmb3JtOnNjYWxlKC45KX0xMDAle3RyYW5zZm9ybTpzY2FsZSgxKX19LmNkeC1ub3RpZnktLWJvdW5jZS1pbnthbmltYXRpb24tbmFtZTpib3VuY2VJbjthbmltYXRpb24tZHVyYXRpb246LjZzO2FuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6MX0uY2R4LW5vdGlmeS0tc3VjY2Vzc3tiYWNrZ3JvdW5kOiNmYWZmZmUhaW1wb3J0YW50fS5jZHgtbm90aWZ5LS1zdWNjZXNzOjpiZWZvcmV7YmFja2dyb3VuZDojNDFmZmIxIWltcG9ydGFudH1gLCBcIlwiXSk7XG4gICAgfSwgZnVuY3Rpb24odCwgbykge1xuICAgICAgdC5leHBvcnRzID0gZnVuY3Rpb24oaSkge1xuICAgICAgICB2YXIgcyA9IFtdO1xuICAgICAgICByZXR1cm4gcy50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbihyKSB7XG4gICAgICAgICAgICB2YXIgbCA9IGZ1bmN0aW9uKGEsIGMpIHtcbiAgICAgICAgICAgICAgdmFyIHUgPSBhWzFdIHx8IFwiXCIsIGggPSBhWzNdO1xuICAgICAgICAgICAgICBpZiAoIWgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHU7XG4gICAgICAgICAgICAgIGlmIChjICYmIHR5cGVvZiBidG9hID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHZhciBwID0gKGYgPSBoLCBcIi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KGYpKSkpICsgXCIgKi9cIiksIGcgPSBoLnNvdXJjZXMubWFwKGZ1bmN0aW9uKGspIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBcIi8qIyBzb3VyY2VVUkw9XCIgKyBoLnNvdXJjZVJvb3QgKyBrICsgXCIgKi9cIjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3VdLmNvbmNhdChnKS5jb25jYXQoW3BdKS5qb2luKGBcbmApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBmO1xuICAgICAgICAgICAgICByZXR1cm4gW3VdLmpvaW4oYFxuYCk7XG4gICAgICAgICAgICB9KHIsIGkpO1xuICAgICAgICAgICAgcmV0dXJuIHJbMl0gPyBcIkBtZWRpYSBcIiArIHJbMl0gKyBcIntcIiArIGwgKyBcIn1cIiA6IGw7XG4gICAgICAgICAgfSkuam9pbihcIlwiKTtcbiAgICAgICAgfSwgcy5pID0gZnVuY3Rpb24ociwgbCkge1xuICAgICAgICAgIHR5cGVvZiByID09IFwic3RyaW5nXCIgJiYgKHIgPSBbW251bGwsIHIsIFwiXCJdXSk7XG4gICAgICAgICAgZm9yICh2YXIgYSA9IHt9LCBjID0gMDsgYyA8IHRoaXMubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICAgIHZhciB1ID0gdGhpc1tjXVswXTtcbiAgICAgICAgICAgIHR5cGVvZiB1ID09IFwibnVtYmVyXCIgJiYgKGFbdV0gPSAhMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoYyA9IDA7IGMgPCByLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICB2YXIgaCA9IHJbY107XG4gICAgICAgICAgICB0eXBlb2YgaFswXSA9PSBcIm51bWJlclwiICYmIGFbaFswXV0gfHwgKGwgJiYgIWhbMl0gPyBoWzJdID0gbCA6IGwgJiYgKGhbMl0gPSBcIihcIiArIGhbMl0gKyBcIikgYW5kIChcIiArIGwgKyBcIilcIiksIHMucHVzaChoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBzO1xuICAgICAgfTtcbiAgICB9LCBmdW5jdGlvbih0LCBvLCBpKSB7XG4gICAgICB2YXIgcywgciwgbCA9IHt9LCBhID0gKHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iO1xuICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByID09PSB2b2lkIDAgJiYgKHIgPSBzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpLCByO1xuICAgICAgfSksIGMgPSBmdW5jdGlvbih2KSB7XG4gICAgICAgIHZhciBtID0ge307XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB4ID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIHJldHVybiB4KCk7XG4gICAgICAgICAgaWYgKG1beF0gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdmFyIEUgPSAoZnVuY3Rpb24oTSkge1xuICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihNKTtcbiAgICAgICAgICAgIH0pLmNhbGwodGhpcywgeCk7XG4gICAgICAgICAgICBpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIEUgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgRSA9IEUuY29udGVudERvY3VtZW50LmhlYWQ7XG4gICAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICAgIEUgPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBtW3hdID0gRTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1beF07XG4gICAgICAgIH07XG4gICAgICB9KCksIHUgPSBudWxsLCBoID0gMCwgcCA9IFtdLCBnID0gaSg1KTtcbiAgICAgIGZ1bmN0aW9uIGYodiwgbSkge1xuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHYubGVuZ3RoOyB4KyspIHtcbiAgICAgICAgICB2YXIgRSA9IHZbeF0sIE0gPSBsW0UuaWRdO1xuICAgICAgICAgIGlmIChNKSB7XG4gICAgICAgICAgICBNLnJlZnMrKztcbiAgICAgICAgICAgIGZvciAodmFyIFQgPSAwOyBUIDwgTS5wYXJ0cy5sZW5ndGg7IFQrKylcbiAgICAgICAgICAgICAgTS5wYXJ0c1tUXShFLnBhcnRzW1RdKTtcbiAgICAgICAgICAgIGZvciAoOyBUIDwgRS5wYXJ0cy5sZW5ndGg7IFQrKylcbiAgICAgICAgICAgICAgTS5wYXJ0cy5wdXNoKFUoRS5wYXJ0c1tUXSwgbSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgUCA9IFtdO1xuICAgICAgICAgICAgZm9yIChUID0gMDsgVCA8IEUucGFydHMubGVuZ3RoOyBUKyspXG4gICAgICAgICAgICAgIFAucHVzaChVKEUucGFydHNbVF0sIG0pKTtcbiAgICAgICAgICAgIGxbRS5pZF0gPSB7IGlkOiBFLmlkLCByZWZzOiAxLCBwYXJ0czogUCB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gayh2LCBtKSB7XG4gICAgICAgIGZvciAodmFyIHggPSBbXSwgRSA9IHt9LCBNID0gMDsgTSA8IHYubGVuZ3RoOyBNKyspIHtcbiAgICAgICAgICB2YXIgVCA9IHZbTV0sIFAgPSBtLmJhc2UgPyBUWzBdICsgbS5iYXNlIDogVFswXSwgQiA9IHsgY3NzOiBUWzFdLCBtZWRpYTogVFsyXSwgc291cmNlTWFwOiBUWzNdIH07XG4gICAgICAgICAgRVtQXSA/IEVbUF0ucGFydHMucHVzaChCKSA6IHgucHVzaChFW1BdID0geyBpZDogUCwgcGFydHM6IFtCXSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIEModiwgbSkge1xuICAgICAgICB2YXIgeCA9IGModi5pbnNlcnRJbnRvKTtcbiAgICAgICAgaWYgKCF4KVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0SW50bycgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuICAgICAgICB2YXIgRSA9IHBbcC5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKHYuaW5zZXJ0QXQgPT09IFwidG9wXCIpXG4gICAgICAgICAgRSA/IEUubmV4dFNpYmxpbmcgPyB4Lmluc2VydEJlZm9yZShtLCBFLm5leHRTaWJsaW5nKSA6IHguYXBwZW5kQ2hpbGQobSkgOiB4Lmluc2VydEJlZm9yZShtLCB4LmZpcnN0Q2hpbGQpLCBwLnB1c2gobSk7XG4gICAgICAgIGVsc2UgaWYgKHYuaW5zZXJ0QXQgPT09IFwiYm90dG9tXCIpXG4gICAgICAgICAgeC5hcHBlbmRDaGlsZChtKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB2Lmluc2VydEF0ICE9IFwib2JqZWN0XCIgfHwgIXYuaW5zZXJ0QXQuYmVmb3JlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbU3R5bGUgTG9hZGVyXVxuXG4gSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdpbnNlcnRBdCcgKCdvcHRpb25zLmluc2VydEF0JykgZm91bmQuXG4gTXVzdCBiZSAndG9wJywgJ2JvdHRvbScsIG9yIE9iamVjdC5cbiAoaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIjaW5zZXJ0YXQpXG5gKTtcbiAgICAgICAgICB2YXIgTSA9IGModi5pbnNlcnRJbnRvICsgXCIgXCIgKyB2Lmluc2VydEF0LmJlZm9yZSk7XG4gICAgICAgICAgeC5pbnNlcnRCZWZvcmUobSwgTSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIFModikge1xuICAgICAgICBpZiAodi5wYXJlbnROb2RlID09PSBudWxsKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgdi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHYpO1xuICAgICAgICB2YXIgbSA9IHAuaW5kZXhPZih2KTtcbiAgICAgICAgbSA+PSAwICYmIHAuc3BsaWNlKG0sIDEpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gXyh2KSB7XG4gICAgICAgIHZhciBtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgICAgICByZXR1cm4gdi5hdHRycy50eXBlID09PSB2b2lkIDAgJiYgKHYuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIiksIGVlKG0sIHYuYXR0cnMpLCBDKHYsIG0pLCBtO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZWUodiwgbSkge1xuICAgICAgICBPYmplY3Qua2V5cyhtKS5mb3JFYWNoKGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICB2LnNldEF0dHJpYnV0ZSh4LCBtW3hdKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBVKHYsIG0pIHtcbiAgICAgICAgdmFyIHgsIEUsIE0sIFQ7XG4gICAgICAgIGlmIChtLnRyYW5zZm9ybSAmJiB2LmNzcykge1xuICAgICAgICAgIGlmICghKFQgPSBtLnRyYW5zZm9ybSh2LmNzcykpKVxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB2LmNzcyA9IFQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG0uc2luZ2xldG9uKSB7XG4gICAgICAgICAgdmFyIFAgPSBoKys7XG4gICAgICAgICAgeCA9IHUgfHwgKHUgPSBfKG0pKSwgRSA9IHBlLmJpbmQobnVsbCwgeCwgUCwgITEpLCBNID0gcGUuYmluZChudWxsLCB4LCBQLCAhMCk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIHYuc291cmNlTWFwICYmIHR5cGVvZiBVUkwgPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIEJsb2IgPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBidG9hID09IFwiZnVuY3Rpb25cIiA/ICh4ID0gZnVuY3Rpb24oQikge1xuICAgICAgICAgICAgdmFyICQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcbiAgICAgICAgICAgIHJldHVybiBCLmF0dHJzLnR5cGUgPT09IHZvaWQgMCAmJiAoQi5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiKSwgQi5hdHRycy5yZWwgPSBcInN0eWxlc2hlZXRcIiwgZWUoJCwgQi5hdHRycyksIEMoQiwgJCksICQ7XG4gICAgICAgICAgfShtKSwgRSA9IChmdW5jdGlvbihCLCAkLCBmZSkge1xuICAgICAgICAgICAgdmFyIGllID0gZmUuY3NzLCBIZSA9IGZlLnNvdXJjZU1hcCwgbW8gPSAkLmNvbnZlcnRUb0Fic29sdXRlVXJscyA9PT0gdm9pZCAwICYmIEhlO1xuICAgICAgICAgICAgKCQuY29udmVydFRvQWJzb2x1dGVVcmxzIHx8IG1vKSAmJiAoaWUgPSBnKGllKSksIEhlICYmIChpZSArPSBgXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGAgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShIZSkpKSkgKyBcIiAqL1wiKTtcbiAgICAgICAgICAgIHZhciBibyA9IG5ldyBCbG9iKFtpZV0sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pLCBndCA9IEIuaHJlZjtcbiAgICAgICAgICAgIEIuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYm8pLCBndCAmJiBVUkwucmV2b2tlT2JqZWN0VVJMKGd0KTtcbiAgICAgICAgICB9KS5iaW5kKG51bGwsIHgsIG0pLCBNID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBTKHgpLCB4LmhyZWYgJiYgVVJMLnJldm9rZU9iamVjdFVSTCh4LmhyZWYpO1xuICAgICAgICAgIH0pIDogKHggPSBfKG0pLCBFID0gKGZ1bmN0aW9uKEIsICQpIHtcbiAgICAgICAgICAgIHZhciBmZSA9ICQuY3NzLCBpZSA9ICQubWVkaWE7XG4gICAgICAgICAgICBpZiAoaWUgJiYgQi5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBpZSksIEIuc3R5bGVTaGVldClcbiAgICAgICAgICAgICAgQi5zdHlsZVNoZWV0LmNzc1RleHQgPSBmZTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBmb3IgKDsgQi5maXJzdENoaWxkOyApXG4gICAgICAgICAgICAgICAgQi5yZW1vdmVDaGlsZChCLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICBCLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGZlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkuYmluZChudWxsLCB4KSwgTSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgUyh4KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIEUodiksIGZ1bmN0aW9uKEIpIHtcbiAgICAgICAgICBpZiAoQikge1xuICAgICAgICAgICAgaWYgKEIuY3NzID09PSB2LmNzcyAmJiBCLm1lZGlhID09PSB2Lm1lZGlhICYmIEIuc291cmNlTWFwID09PSB2LnNvdXJjZU1hcClcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgRSh2ID0gQik7XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICBNKCk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB0LmV4cG9ydHMgPSBmdW5jdGlvbih2LCBtKSB7XG4gICAgICAgIGlmICh0eXBlb2YgREVCVUcgPCBcInVcIiAmJiBERUJVRyAmJiB0eXBlb2YgZG9jdW1lbnQgIT0gXCJvYmplY3RcIilcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XG4gICAgICAgIChtID0gbSB8fCB7fSkuYXR0cnMgPSB0eXBlb2YgbS5hdHRycyA9PSBcIm9iamVjdFwiID8gbS5hdHRycyA6IHt9LCBtLnNpbmdsZXRvbiB8fCB0eXBlb2YgbS5zaW5nbGV0b24gPT0gXCJib29sZWFuXCIgfHwgKG0uc2luZ2xldG9uID0gYSgpKSwgbS5pbnNlcnRJbnRvIHx8IChtLmluc2VydEludG8gPSBcImhlYWRcIiksIG0uaW5zZXJ0QXQgfHwgKG0uaW5zZXJ0QXQgPSBcImJvdHRvbVwiKTtcbiAgICAgICAgdmFyIHggPSBrKHYsIG0pO1xuICAgICAgICByZXR1cm4gZih4LCBtKSwgZnVuY3Rpb24oRSkge1xuICAgICAgICAgIGZvciAodmFyIE0gPSBbXSwgVCA9IDA7IFQgPCB4Lmxlbmd0aDsgVCsrKSB7XG4gICAgICAgICAgICB2YXIgUCA9IHhbVF07XG4gICAgICAgICAgICAoQiA9IGxbUC5pZF0pLnJlZnMtLSwgTS5wdXNoKEIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKEUgJiYgZihrKEUsIG0pLCBtKSwgVCA9IDA7IFQgPCBNLmxlbmd0aDsgVCsrKSB7XG4gICAgICAgICAgICB2YXIgQjtcbiAgICAgICAgICAgIGlmICgoQiA9IE1bVF0pLnJlZnMgPT09IDApIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgJCA9IDA7ICQgPCBCLnBhcnRzLmxlbmd0aDsgJCsrKVxuICAgICAgICAgICAgICAgIEIucGFydHNbJF0oKTtcbiAgICAgICAgICAgICAgZGVsZXRlIGxbQi5pZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIHZhciBqLCBvZSA9IChqID0gW10sIGZ1bmN0aW9uKHYsIG0pIHtcbiAgICAgICAgcmV0dXJuIGpbdl0gPSBtLCBqLmZpbHRlcihCb29sZWFuKS5qb2luKGBcbmApO1xuICAgICAgfSk7XG4gICAgICBmdW5jdGlvbiBwZSh2LCBtLCB4LCBFKSB7XG4gICAgICAgIHZhciBNID0geCA/IFwiXCIgOiBFLmNzcztcbiAgICAgICAgaWYgKHYuc3R5bGVTaGVldClcbiAgICAgICAgICB2LnN0eWxlU2hlZXQuY3NzVGV4dCA9IG9lKG0sIE0pO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgVCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKE0pLCBQID0gdi5jaGlsZE5vZGVzO1xuICAgICAgICAgIFBbbV0gJiYgdi5yZW1vdmVDaGlsZChQW21dKSwgUC5sZW5ndGggPyB2Lmluc2VydEJlZm9yZShULCBQW21dKSA6IHYuYXBwZW5kQ2hpbGQoVCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBmdW5jdGlvbih0LCBvKSB7XG4gICAgICB0LmV4cG9ydHMgPSBmdW5jdGlvbihpKSB7XG4gICAgICAgIHZhciBzID0gdHlwZW9mIHdpbmRvdyA8IFwidVwiICYmIHdpbmRvdy5sb2NhdGlvbjtcbiAgICAgICAgaWYgKCFzKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImZpeFVybHMgcmVxdWlyZXMgd2luZG93LmxvY2F0aW9uXCIpO1xuICAgICAgICBpZiAoIWkgfHwgdHlwZW9mIGkgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgdmFyIHIgPSBzLnByb3RvY29sICsgXCIvL1wiICsgcy5ob3N0LCBsID0gciArIHMucGF0aG5hbWUucmVwbGFjZSgvXFwvW15cXC9dKiQvLCBcIi9cIik7XG4gICAgICAgIHJldHVybiBpLnJlcGxhY2UoL3VybFxccypcXCgoKD86W14pKF18XFwoKD86W14pKF0rfFxcKFteKShdKlxcKSkqXFwpKSopXFwpL2dpLCBmdW5jdGlvbihhLCBjKSB7XG4gICAgICAgICAgdmFyIHUsIGggPSBjLnRyaW0oKS5yZXBsYWNlKC9eXCIoLiopXCIkLywgZnVuY3Rpb24ocCwgZykge1xuICAgICAgICAgICAgcmV0dXJuIGc7XG4gICAgICAgICAgfSkucmVwbGFjZSgvXicoLiopJyQvLCBmdW5jdGlvbihwLCBnKSB7XG4gICAgICAgICAgICByZXR1cm4gZztcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gL14oI3xkYXRhOnxodHRwOlxcL1xcL3xodHRwczpcXC9cXC98ZmlsZTpcXC9cXC9cXC98XFxzKiQpL2kudGVzdChoKSA/IGEgOiAodSA9IGguaW5kZXhPZihcIi8vXCIpID09PSAwID8gaCA6IGguaW5kZXhPZihcIi9cIikgPT09IDAgPyByICsgaCA6IGwgKyBoLnJlcGxhY2UoL15cXC5cXC8vLCBcIlwiKSwgXCJ1cmwoXCIgKyBKU09OLnN0cmluZ2lmeSh1KSArIFwiKVwiKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH0sIGZ1bmN0aW9uKHQsIG8sIGkpIHtcbiAgICAgIHZhciBzLCByLCBsLCBhLCBjLCB1LCBoLCBwLCBnO1xuICAgICAgdC5leHBvcnRzID0gKHMgPSBcImNkeC1ub3RpZmllc1wiLCByID0gXCJjZHgtbm90aWZ5XCIsIGwgPSBcImNkeC1ub3RpZnlfX2Nyb3NzXCIsIGEgPSBcImNkeC1ub3RpZnlfX2J1dHRvbi0tY29uZmlybVwiLCBjID0gXCJjZHgtbm90aWZ5X19idXR0b24tLWNhbmNlbFwiLCB1ID0gXCJjZHgtbm90aWZ5X19pbnB1dFwiLCBoID0gXCJjZHgtbm90aWZ5X19idXR0b25cIiwgcCA9IFwiY2R4LW5vdGlmeV9fYnRucy13cmFwcGVyXCIsIHsgYWxlcnQ6IGcgPSBmdW5jdGlvbihmKSB7XG4gICAgICAgIHZhciBrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkRJVlwiKSwgQyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJESVZcIiksIFMgPSBmLm1lc3NhZ2UsIF8gPSBmLnN0eWxlO1xuICAgICAgICByZXR1cm4gay5jbGFzc0xpc3QuYWRkKHIpLCBfICYmIGsuY2xhc3NMaXN0LmFkZChyICsgXCItLVwiICsgXyksIGsuaW5uZXJIVE1MID0gUywgQy5jbGFzc0xpc3QuYWRkKGwpLCBDLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBrLnJlbW92ZS5iaW5kKGspKSwgay5hcHBlbmRDaGlsZChDKSwgaztcbiAgICAgIH0sIGNvbmZpcm06IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgdmFyIGsgPSBnKGYpLCBDID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgUyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiksIF8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpLCBlZSA9IGsucXVlcnlTZWxlY3RvcihcIi5cIiArIGwpLCBVID0gZi5jYW5jZWxIYW5kbGVyLCBqID0gZi5va0hhbmRsZXI7XG4gICAgICAgIHJldHVybiBDLmNsYXNzTGlzdC5hZGQocCksIFMuaW5uZXJIVE1MID0gZi5va1RleHQgfHwgXCJDb25maXJtXCIsIF8uaW5uZXJIVE1MID0gZi5jYW5jZWxUZXh0IHx8IFwiQ2FuY2VsXCIsIFMuY2xhc3NMaXN0LmFkZChoKSwgXy5jbGFzc0xpc3QuYWRkKGgpLCBTLmNsYXNzTGlzdC5hZGQoYSksIF8uY2xhc3NMaXN0LmFkZChjKSwgVSAmJiB0eXBlb2YgVSA9PSBcImZ1bmN0aW9uXCIgJiYgKF8uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIFUpLCBlZS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgVSkpLCBqICYmIHR5cGVvZiBqID09IFwiZnVuY3Rpb25cIiAmJiBTLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBqKSwgUy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgay5yZW1vdmUuYmluZChrKSksIF8uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGsucmVtb3ZlLmJpbmQoaykpLCBDLmFwcGVuZENoaWxkKFMpLCBDLmFwcGVuZENoaWxkKF8pLCBrLmFwcGVuZENoaWxkKEMpLCBrO1xuICAgICAgfSwgcHJvbXB0OiBmdW5jdGlvbihmKSB7XG4gICAgICAgIHZhciBrID0gZyhmKSwgQyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIFMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpLCBfID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpLCBlZSA9IGsucXVlcnlTZWxlY3RvcihcIi5cIiArIGwpLCBVID0gZi5jYW5jZWxIYW5kbGVyLCBqID0gZi5va0hhbmRsZXI7XG4gICAgICAgIHJldHVybiBDLmNsYXNzTGlzdC5hZGQocCksIFMuaW5uZXJIVE1MID0gZi5va1RleHQgfHwgXCJPa1wiLCBTLmNsYXNzTGlzdC5hZGQoaCksIFMuY2xhc3NMaXN0LmFkZChhKSwgXy5jbGFzc0xpc3QuYWRkKHUpLCBmLnBsYWNlaG9sZGVyICYmIF8uc2V0QXR0cmlidXRlKFwicGxhY2Vob2xkZXJcIiwgZi5wbGFjZWhvbGRlciksIGYuZGVmYXVsdCAmJiAoXy52YWx1ZSA9IGYuZGVmYXVsdCksIGYuaW5wdXRUeXBlICYmIChfLnR5cGUgPSBmLmlucHV0VHlwZSksIFUgJiYgdHlwZW9mIFUgPT0gXCJmdW5jdGlvblwiICYmIGVlLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBVKSwgaiAmJiB0eXBlb2YgaiA9PSBcImZ1bmN0aW9uXCIgJiYgUy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaihfLnZhbHVlKTtcbiAgICAgICAgfSksIFMuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGsucmVtb3ZlLmJpbmQoaykpLCBDLmFwcGVuZENoaWxkKF8pLCBDLmFwcGVuZENoaWxkKFMpLCBrLmFwcGVuZENoaWxkKEMpLCBrO1xuICAgICAgfSwgZ2V0V3JhcHBlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBmID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkRJVlwiKTtcbiAgICAgICAgcmV0dXJuIGYuY2xhc3NMaXN0LmFkZChzKSwgZjtcbiAgICAgIH0gfSk7XG4gICAgfV0pO1xuICB9KTtcbn0pKFp0KTtcbnZhciB4aSA9IFp0LmV4cG9ydHM7XG5jb25zdCB5aSA9IC8qIEBfX1BVUkVfXyAqLyBSZSh4aSk7XG5jbGFzcyBFaSB7XG4gIC8qKlxuICAgKiBTaG93IHdlYiBub3RpZmljYXRpb25cbiAgICpcbiAgICogQHBhcmFtIHtOb3RpZmllck9wdGlvbnMgfCBDb25maXJtTm90aWZpZXJPcHRpb25zIHwgUHJvbXB0Tm90aWZpZXJPcHRpb25zfSBvcHRpb25zIC0gbm90aWZpY2F0aW9uIG9wdGlvbnNcbiAgICovXG4gIHNob3coZSkge1xuICAgIHlpLnNob3coZSk7XG4gIH1cbn1cbmNsYXNzIEJpIGV4dGVuZHMgeSB7XG4gIC8qKlxuICAgKiBAcGFyYW0gbW9kdWxlQ29uZmlndXJhdGlvbiAtIE1vZHVsZSBDb25maWd1cmF0aW9uXG4gICAqIEBwYXJhbSBtb2R1bGVDb25maWd1cmF0aW9uLmNvbmZpZyAtIEVkaXRvcidzIGNvbmZpZ1xuICAgKiBAcGFyYW0gbW9kdWxlQ29uZmlndXJhdGlvbi5ldmVudHNEaXNwYXRjaGVyIC0gRWRpdG9yJ3MgZXZlbnQgZGlzcGF0Y2hlclxuICAgKi9cbiAgY29uc3RydWN0b3IoeyBjb25maWc6IGUsIGV2ZW50c0Rpc3BhdGNoZXI6IHQgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIGNvbmZpZzogZSxcbiAgICAgIGV2ZW50c0Rpc3BhdGNoZXI6IHRcbiAgICB9KSwgdGhpcy5ub3RpZmllciA9IG5ldyBFaSgpO1xuICB9XG4gIC8qKlxuICAgKiBBdmFpbGFibGUgbWV0aG9kc1xuICAgKi9cbiAgZ2V0IG1ldGhvZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNob3c6IChlKSA9PiB0aGlzLnNob3coZSlcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBTaG93IG5vdGlmaWNhdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge05vdGlmaWVyT3B0aW9uc30gb3B0aW9ucyAtIG1lc3NhZ2Ugb3B0aW9uXG4gICAqL1xuICBzaG93KGUpIHtcbiAgICByZXR1cm4gdGhpcy5ub3RpZmllci5zaG93KGUpO1xuICB9XG59XG5jbGFzcyBUaSBleHRlbmRzIHkge1xuICAvKipcbiAgICogQXZhaWxhYmxlIG1ldGhvZHNcbiAgICovXG4gIGdldCBtZXRob2RzKCkge1xuICAgIGNvbnN0IGUgPSAoKSA9PiB0aGlzLmlzRW5hYmxlZDtcbiAgICByZXR1cm4ge1xuICAgICAgdG9nZ2xlOiAodCkgPT4gdGhpcy50b2dnbGUodCksXG4gICAgICBnZXQgaXNFbmFibGVkKCkge1xuICAgICAgICByZXR1cm4gZSgpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFNldCBvciB0b2dnbGUgcmVhZC1vbmx5IHN0YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbnx1bmRlZmluZWR9IHN0YXRlIC0gc2V0IG9yIHRvZ2dsZSBzdGF0ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gY3VycmVudCB2YWx1ZVxuICAgKi9cbiAgdG9nZ2xlKGUpIHtcbiAgICByZXR1cm4gdGhpcy5FZGl0b3IuUmVhZE9ubHkudG9nZ2xlKGUpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGN1cnJlbnQgcmVhZC1vbmx5IHN0YXRlXG4gICAqL1xuICBnZXQgaXNFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLkVkaXRvci5SZWFkT25seS5pc0VuYWJsZWQ7XG4gIH1cbn1cbnZhciBHdCA9IHsgZXhwb3J0czoge30gfTtcbihmdW5jdGlvbihuLCBlKSB7XG4gIChmdW5jdGlvbih0LCBvKSB7XG4gICAgbi5leHBvcnRzID0gbygpO1xuICB9KShrbywgZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gdChoKSB7XG4gICAgICB2YXIgcCA9IGgudGFncywgZyA9IE9iamVjdC5rZXlzKHApLCBmID0gZy5tYXAoZnVuY3Rpb24oaykge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHBba107XG4gICAgICB9KS5ldmVyeShmdW5jdGlvbihrKSB7XG4gICAgICAgIHJldHVybiBrID09PSBcIm9iamVjdFwiIHx8IGsgPT09IFwiYm9vbGVhblwiIHx8IGsgPT09IFwiZnVuY3Rpb25cIjtcbiAgICAgIH0pO1xuICAgICAgaWYgKCFmKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgY29uZmlndXJhdGlvbiB3YXMgaW52YWxpZFwiKTtcbiAgICAgIHRoaXMuY29uZmlnID0gaDtcbiAgICB9XG4gICAgdmFyIG8gPSBbXCJQXCIsIFwiTElcIiwgXCJURFwiLCBcIlRIXCIsIFwiRElWXCIsIFwiSDFcIiwgXCJIMlwiLCBcIkgzXCIsIFwiSDRcIiwgXCJINVwiLCBcIkg2XCIsIFwiUFJFXCJdO1xuICAgIGZ1bmN0aW9uIGkoaCkge1xuICAgICAgcmV0dXJuIG8uaW5kZXhPZihoLm5vZGVOYW1lKSAhPT0gLTE7XG4gICAgfVxuICAgIHZhciBzID0gW1wiQVwiLCBcIkJcIiwgXCJTVFJPTkdcIiwgXCJJXCIsIFwiRU1cIiwgXCJTVUJcIiwgXCJTVVBcIiwgXCJVXCIsIFwiU1RSSUtFXCJdO1xuICAgIGZ1bmN0aW9uIHIoaCkge1xuICAgICAgcmV0dXJuIHMuaW5kZXhPZihoLm5vZGVOYW1lKSAhPT0gLTE7XG4gICAgfVxuICAgIHQucHJvdG90eXBlLmNsZWFuID0gZnVuY3Rpb24oaCkge1xuICAgICAgY29uc3QgcCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCgpLCBnID0gcC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgcmV0dXJuIGcuaW5uZXJIVE1MID0gaCwgdGhpcy5fc2FuaXRpemUocCwgZyksIGcuaW5uZXJIVE1MO1xuICAgIH0sIHQucHJvdG90eXBlLl9zYW5pdGl6ZSA9IGZ1bmN0aW9uKGgsIHApIHtcbiAgICAgIHZhciBnID0gbChoLCBwKSwgZiA9IGcuZmlyc3RDaGlsZCgpO1xuICAgICAgaWYgKGYpXG4gICAgICAgIGRvIHtcbiAgICAgICAgICBpZiAoZi5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpXG4gICAgICAgICAgICBpZiAoZi5kYXRhLnRyaW0oKSA9PT0gXCJcIiAmJiAoZi5wcmV2aW91c0VsZW1lbnRTaWJsaW5nICYmIGkoZi5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKSB8fCBmLm5leHRFbGVtZW50U2libGluZyAmJiBpKGYubmV4dEVsZW1lbnRTaWJsaW5nKSkpIHtcbiAgICAgICAgICAgICAgcC5yZW1vdmVDaGlsZChmKSwgdGhpcy5fc2FuaXRpemUoaCwgcCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGlmIChmLm5vZGVUeXBlID09PSBOb2RlLkNPTU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgcC5yZW1vdmVDaGlsZChmKSwgdGhpcy5fc2FuaXRpemUoaCwgcCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGsgPSByKGYpLCBDO1xuICAgICAgICAgIGsgJiYgKEMgPSBBcnJheS5wcm90b3R5cGUuc29tZS5jYWxsKGYuY2hpbGROb2RlcywgaSkpO1xuICAgICAgICAgIHZhciBTID0gISFwLnBhcmVudE5vZGUsIF8gPSBpKHApICYmIGkoZikgJiYgUywgZWUgPSBmLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksIFUgPSBhKHRoaXMuY29uZmlnLCBlZSwgZiksIGogPSBrICYmIEM7XG4gICAgICAgICAgaWYgKGogfHwgYyhmLCBVKSB8fCAhdGhpcy5jb25maWcua2VlcE5lc3RlZEJsb2NrRWxlbWVudHMgJiYgXykge1xuICAgICAgICAgICAgaWYgKCEoZi5ub2RlTmFtZSA9PT0gXCJTQ1JJUFRcIiB8fCBmLm5vZGVOYW1lID09PSBcIlNUWUxFXCIpKVxuICAgICAgICAgICAgICBmb3IgKDsgZi5jaGlsZE5vZGVzLmxlbmd0aCA+IDA7IClcbiAgICAgICAgICAgICAgICBwLmluc2VydEJlZm9yZShmLmNoaWxkTm9kZXNbMF0sIGYpO1xuICAgICAgICAgICAgcC5yZW1vdmVDaGlsZChmKSwgdGhpcy5fc2FuaXRpemUoaCwgcCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgb2UgPSAwOyBvZSA8IGYuYXR0cmlidXRlcy5sZW5ndGg7IG9lICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBwZSA9IGYuYXR0cmlidXRlc1tvZV07XG4gICAgICAgICAgICB1KHBlLCBVLCBmKSAmJiAoZi5yZW1vdmVBdHRyaWJ1dGUocGUubmFtZSksIG9lID0gb2UgLSAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fc2FuaXRpemUoaCwgZik7XG4gICAgICAgIH0gd2hpbGUgKGYgPSBnLm5leHRTaWJsaW5nKCkpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gbChoLCBwKSB7XG4gICAgICByZXR1cm4gaC5jcmVhdGVUcmVlV2Fsa2VyKFxuICAgICAgICBwLFxuICAgICAgICBOb2RlRmlsdGVyLlNIT1dfVEVYVCB8IE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5UIHwgTm9kZUZpbHRlci5TSE9XX0NPTU1FTlQsXG4gICAgICAgIG51bGwsXG4gICAgICAgICExXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhKGgsIHAsIGcpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgaC50YWdzW3BdID09IFwiZnVuY3Rpb25cIiA/IGgudGFnc1twXShnKSA6IGgudGFnc1twXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYyhoLCBwKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHAgPiBcInVcIiA/ICEwIDogdHlwZW9mIHAgPT0gXCJib29sZWFuXCIgPyAhcCA6ICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1KGgsIHAsIGcpIHtcbiAgICAgIHZhciBmID0gaC5uYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICByZXR1cm4gcCA9PT0gITAgPyAhMSA6IHR5cGVvZiBwW2ZdID09IFwiZnVuY3Rpb25cIiA/ICFwW2ZdKGgudmFsdWUsIGcpIDogdHlwZW9mIHBbZl0gPiBcInVcIiB8fCBwW2ZdID09PSAhMSA/ICEwIDogdHlwZW9mIHBbZl0gPT0gXCJzdHJpbmdcIiA/IHBbZl0gIT09IGgudmFsdWUgOiAhMTtcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG4gIH0pO1xufSkoR3QpO1xudmFyIENpID0gR3QuZXhwb3J0cztcbmNvbnN0IFNpID0gLyogQF9fUFVSRV9fICovIFJlKENpKTtcbmZ1bmN0aW9uIG50KG4sIGUpIHtcbiAgcmV0dXJuIG4ubWFwKCh0KSA9PiB7XG4gICAgY29uc3QgbyA9IE8oZSkgPyBlKHQudG9vbCkgOiBlO1xuICAgIHJldHVybiBYKG8pIHx8ICh0LmRhdGEgPSBydCh0LmRhdGEsIG8pKSwgdDtcbiAgfSk7XG59XG5mdW5jdGlvbiBxKG4sIGUgPSB7fSkge1xuICBjb25zdCB0ID0ge1xuICAgIHRhZ3M6IGVcbiAgfTtcbiAgcmV0dXJuIG5ldyBTaSh0KS5jbGVhbihuKTtcbn1cbmZ1bmN0aW9uIHJ0KG4sIGUpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkobikgPyBJaShuLCBlKSA6IFIobikgPyBNaShuLCBlKSA6IFEobikgPyBBaShuLCBlKSA6IG47XG59XG5mdW5jdGlvbiBJaShuLCBlKSB7XG4gIHJldHVybiBuLm1hcCgodCkgPT4gcnQodCwgZSkpO1xufVxuZnVuY3Rpb24gTWkobiwgZSkge1xuICBjb25zdCB0ID0ge307XG4gIGZvciAoY29uc3QgbyBpbiBuKSB7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobiwgbykpXG4gICAgICBjb250aW51ZTtcbiAgICBjb25zdCBpID0gbltvXSwgcyA9IE9pKGVbb10pID8gZVtvXSA6IGU7XG4gICAgdFtvXSA9IHJ0KGksIHMpO1xuICB9XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gQWkobiwgZSkge1xuICByZXR1cm4gUihlKSA/IHEobiwgZSkgOiBlID09PSAhMSA/IHEobiwge30pIDogbjtcbn1cbmZ1bmN0aW9uIE9pKG4pIHtcbiAgcmV0dXJuIFIobikgfHwgeW8obikgfHwgTyhuKTtcbn1cbmNsYXNzIExpIGV4dGVuZHMgeSB7XG4gIC8qKlxuICAgKiBBdmFpbGFibGUgbWV0aG9kc1xuICAgKlxuICAgKiBAcmV0dXJucyB7U2FuaXRpemVyQ29uZmlnfVxuICAgKi9cbiAgZ2V0IG1ldGhvZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsZWFuOiAoZSwgdCkgPT4gdGhpcy5jbGVhbihlLCB0KVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFBlcmZvcm0gc2FuaXRpemluZyBvZiBhIHN0cmluZ1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGFpbnRTdHJpbmcgLSB3aGF0IHRvIHNhbml0aXplXG4gICAqIEBwYXJhbSB7U2FuaXRpemVyQ29uZmlnfSBjb25maWcgLSBzYW5pdGl6ZXIgY29uZmlnXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBjbGVhbihlLCB0KSB7XG4gICAgcmV0dXJuIHEoZSwgdCk7XG4gIH1cbn1cbmNsYXNzIF9pIGV4dGVuZHMgeSB7XG4gIC8qKlxuICAgKiBBdmFpbGFibGUgbWV0aG9kc1xuICAgKlxuICAgKiBAcmV0dXJucyB7U2F2ZXJ9XG4gICAqL1xuICBnZXQgbWV0aG9kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2F2ZTogKCkgPT4gdGhpcy5zYXZlKClcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gRWRpdG9yJ3MgZGF0YVxuICAgKlxuICAgKiBAcmV0dXJucyB7T3V0cHV0RGF0YX1cbiAgICovXG4gIHNhdmUoKSB7XG4gICAgY29uc3QgZSA9IFwiRWRpdG9yJ3MgY29udGVudCBjYW4gbm90IGJlIHNhdmVkIGluIHJlYWQtb25seSBtb2RlXCI7XG4gICAgcmV0dXJuIHRoaXMuRWRpdG9yLlJlYWRPbmx5LmlzRW5hYmxlZCA/IChLKGUsIFwid2FyblwiKSwgUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGUpKSkgOiB0aGlzLkVkaXRvci5TYXZlci5zYXZlKCk7XG4gIH1cbn1cbmNsYXNzIE5pIGV4dGVuZHMgeSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMuc2VsZWN0aW9uVXRpbHMgPSBuZXcgYigpO1xuICB9XG4gIC8qKlxuICAgKiBBdmFpbGFibGUgbWV0aG9kc1xuICAgKlxuICAgKiBAcmV0dXJucyB7U2VsZWN0aW9uQVBJSW50ZXJmYWNlfVxuICAgKi9cbiAgZ2V0IG1ldGhvZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpbmRQYXJlbnRUYWc6IChlLCB0KSA9PiB0aGlzLmZpbmRQYXJlbnRUYWcoZSwgdCksXG4gICAgICBleHBhbmRUb1RhZzogKGUpID0+IHRoaXMuZXhwYW5kVG9UYWcoZSksXG4gICAgICBzYXZlOiAoKSA9PiB0aGlzLnNlbGVjdGlvblV0aWxzLnNhdmUoKSxcbiAgICAgIHJlc3RvcmU6ICgpID0+IHRoaXMuc2VsZWN0aW9uVXRpbHMucmVzdG9yZSgpLFxuICAgICAgc2V0RmFrZUJhY2tncm91bmQ6ICgpID0+IHRoaXMuc2VsZWN0aW9uVXRpbHMuc2V0RmFrZUJhY2tncm91bmQoKSxcbiAgICAgIHJlbW92ZUZha2VCYWNrZ3JvdW5kOiAoKSA9PiB0aGlzLnNlbGVjdGlvblV0aWxzLnJlbW92ZUZha2VCYWNrZ3JvdW5kKClcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBMb29rcyBhaGVhZCBmcm9tIHNlbGVjdGlvbiBhbmQgZmluZCBwYXNzZWQgdGFnIHdpdGggY2xhc3MgbmFtZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnTmFtZSAtIHRhZyB0byBmaW5kXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgLSB0YWcncyBjbGFzcyBuYW1lXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudHxudWxsfVxuICAgKi9cbiAgZmluZFBhcmVudFRhZyhlLCB0KSB7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uVXRpbHMuZmluZFBhcmVudFRhZyhlLCB0KTtcbiAgfVxuICAvKipcbiAgICogRXhwYW5kIHNlbGVjdGlvbiB0byBwYXNzZWQgdGFnXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGUgLSB0YWcgdGhhdCBzaG91bGQgY29udGFpbiBzZWxlY3Rpb25cbiAgICovXG4gIGV4cGFuZFRvVGFnKGUpIHtcbiAgICB0aGlzLnNlbGVjdGlvblV0aWxzLmV4cGFuZFRvVGFnKGUpO1xuICB9XG59XG5jbGFzcyBQaSBleHRlbmRzIHkge1xuICAvKipcbiAgICogQXZhaWxhYmxlIG1ldGhvZHNcbiAgICovXG4gIGdldCBtZXRob2RzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBnZXRCbG9ja1Rvb2xzOiAoKSA9PiBBcnJheS5mcm9tKHRoaXMuRWRpdG9yLlRvb2xzLmJsb2NrVG9vbHMudmFsdWVzKCkpXG4gICAgfTtcbiAgfVxufVxuY2xhc3MgRGkgZXh0ZW5kcyB5IHtcbiAgLyoqXG4gICAqIEV4cG9ydGVkIGNsYXNzZXNcbiAgICovXG4gIGdldCBjbGFzc2VzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAvKipcbiAgICAgICAqIEJhc2UgQmxvY2sgc3R5bGVzXG4gICAgICAgKi9cbiAgICAgIGJsb2NrOiBcImNkeC1ibG9ja1wiLFxuICAgICAgLyoqXG4gICAgICAgKiBJbmxpbmUgVG9vbHMgc3R5bGVzXG4gICAgICAgKi9cbiAgICAgIGlubGluZVRvb2xCdXR0b246IFwiY2UtaW5saW5lLXRvb2xcIixcbiAgICAgIGlubGluZVRvb2xCdXR0b25BY3RpdmU6IFwiY2UtaW5saW5lLXRvb2wtLWFjdGl2ZVwiLFxuICAgICAgLyoqXG4gICAgICAgKiBVSSBlbGVtZW50c1xuICAgICAgICovXG4gICAgICBpbnB1dDogXCJjZHgtaW5wdXRcIixcbiAgICAgIGxvYWRlcjogXCJjZHgtbG9hZGVyXCIsXG4gICAgICBidXR0b246IFwiY2R4LWJ1dHRvblwiLFxuICAgICAgLyoqXG4gICAgICAgKiBTZXR0aW5ncyBzdHlsZXNcbiAgICAgICAqL1xuICAgICAgc2V0dGluZ3NCdXR0b246IFwiY2R4LXNldHRpbmdzLWJ1dHRvblwiLFxuICAgICAgc2V0dGluZ3NCdXR0b25BY3RpdmU6IFwiY2R4LXNldHRpbmdzLWJ1dHRvbi0tYWN0aXZlXCJcbiAgICB9O1xuICB9XG59XG5jbGFzcyBSaSBleHRlbmRzIHkge1xuICAvKipcbiAgICogQXZhaWxhYmxlIG1ldGhvZHNcbiAgICpcbiAgICogQHJldHVybnMge1Rvb2xiYXJ9XG4gICAqL1xuICBnZXQgbWV0aG9kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xvc2U6ICgpID0+IHRoaXMuY2xvc2UoKSxcbiAgICAgIG9wZW46ICgpID0+IHRoaXMub3BlbigpLFxuICAgICAgdG9nZ2xlQmxvY2tTZXR0aW5nczogKGUpID0+IHRoaXMudG9nZ2xlQmxvY2tTZXR0aW5ncyhlKSxcbiAgICAgIHRvZ2dsZVRvb2xib3g6IChlKSA9PiB0aGlzLnRvZ2dsZVRvb2xib3goZSlcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBPcGVuIHRvb2xiYXJcbiAgICovXG4gIG9wZW4oKSB7XG4gICAgdGhpcy5FZGl0b3IuVG9vbGJhci5tb3ZlQW5kT3BlbigpO1xuICB9XG4gIC8qKlxuICAgKiBDbG9zZSB0b29sYmFyIGFuZCBhbGwgaW5jbHVkZWQgZWxlbWVudHNcbiAgICovXG4gIGNsb3NlKCkge1xuICAgIHRoaXMuRWRpdG9yLlRvb2xiYXIuY2xvc2UoKTtcbiAgfVxuICAvKipcbiAgICogVG9nZ2xlcyBCbG9jayBTZXR0aW5nIG9mIHRoZSBjdXJyZW50IGJsb2NrXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3BlbmluZ1N0YXRlIOKAlCAgb3BlbmluZyBzdGF0ZSBvZiBCbG9jayBTZXR0aW5nXG4gICAqL1xuICB0b2dnbGVCbG9ja1NldHRpbmdzKGUpIHtcbiAgICBpZiAodGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmN1cnJlbnRCbG9ja0luZGV4ID09PSAtMSkge1xuICAgICAgSyhcIkNvdWxkJ3QgdG9nZ2xlIHRoZSBUb29sYmFyIGJlY2F1c2UgdGhlcmUgaXMgbm8gYmxvY2sgc2VsZWN0ZWQgXCIsIFwid2FyblwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZSA/PyAhdGhpcy5FZGl0b3IuQmxvY2tTZXR0aW5ncy5vcGVuZWQgPyAodGhpcy5FZGl0b3IuVG9vbGJhci5tb3ZlQW5kT3BlbigpLCB0aGlzLkVkaXRvci5CbG9ja1NldHRpbmdzLm9wZW4oKSkgOiB0aGlzLkVkaXRvci5CbG9ja1NldHRpbmdzLmNsb3NlKCk7XG4gIH1cbiAgLyoqXG4gICAqIE9wZW4gdG9vbGJveFxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wZW5pbmdTdGF0ZSAtIE9wZW5pbmcgc3RhdGUgb2YgdG9vbGJveFxuICAgKi9cbiAgdG9nZ2xlVG9vbGJveChlKSB7XG4gICAgaWYgKHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5jdXJyZW50QmxvY2tJbmRleCA9PT0gLTEpIHtcbiAgICAgIEsoXCJDb3VsZCd0IHRvZ2dsZSB0aGUgVG9vbGJveCBiZWNhdXNlIHRoZXJlIGlzIG5vIGJsb2NrIHNlbGVjdGVkIFwiLCBcIndhcm5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGUgPz8gIXRoaXMuRWRpdG9yLlRvb2xiYXIudG9vbGJveC5vcGVuZWQgPyAodGhpcy5FZGl0b3IuVG9vbGJhci5tb3ZlQW5kT3BlbigpLCB0aGlzLkVkaXRvci5Ub29sYmFyLnRvb2xib3gub3BlbigpKSA6IHRoaXMuRWRpdG9yLlRvb2xiYXIudG9vbGJveC5jbG9zZSgpO1xuICB9XG59XG5jbGFzcyBGaSBleHRlbmRzIHkge1xuICAvKipcbiAgICogQGNsYXNzXG4gICAqIEBwYXJhbSBtb2R1bGVDb25maWd1cmF0aW9uIC0gTW9kdWxlIENvbmZpZ3VyYXRpb25cbiAgICogQHBhcmFtIG1vZHVsZUNvbmZpZ3VyYXRpb24uY29uZmlnIC0gRWRpdG9yJ3MgY29uZmlnXG4gICAqIEBwYXJhbSBtb2R1bGVDb25maWd1cmF0aW9uLmV2ZW50c0Rpc3BhdGNoZXIgLSBFZGl0b3IncyBldmVudCBkaXNwYXRjaGVyXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGNvbmZpZzogZSwgZXZlbnRzRGlzcGF0Y2hlcjogdCB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgY29uZmlnOiBlLFxuICAgICAgZXZlbnRzRGlzcGF0Y2hlcjogdFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBBdmFpbGFibGUgbWV0aG9kc1xuICAgKi9cbiAgZ2V0IG1ldGhvZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNob3c6IChlLCB0LCBvKSA9PiB0aGlzLnNob3coZSwgdCwgbyksXG4gICAgICBoaWRlOiAoKSA9PiB0aGlzLmhpZGUoKSxcbiAgICAgIG9uSG92ZXI6IChlLCB0LCBvKSA9PiB0aGlzLm9uSG92ZXIoZSwgdCwgbylcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBNZXRob2Qgc2hvdyB0b29sdGlwIG9uIGVsZW1lbnQgd2l0aCBwYXNzZWQgSFRNTCBjb250ZW50XG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBlbGVtZW50IG9uIHdoaWNoIHRvb2x0aXAgc2hvdWxkIGJlIHNob3duXG4gICAqIEBwYXJhbSB7VG9vbHRpcENvbnRlbnR9IGNvbnRlbnQgLSB0b29sdGlwIGNvbnRlbnRcbiAgICogQHBhcmFtIHtUb29sdGlwT3B0aW9uc30gb3B0aW9ucyAtIHRvb2x0aXAgb3B0aW9uc1xuICAgKi9cbiAgc2hvdyhlLCB0LCBvKSB7XG4gICAgdGkoZSwgdCwgbyk7XG4gIH1cbiAgLyoqXG4gICAqIE1ldGhvZCBoaWRlcyB0b29sdGlwIG9uIEhUTUwgcGFnZVxuICAgKi9cbiAgaGlkZSgpIHtcbiAgICBfZSgpO1xuICB9XG4gIC8qKlxuICAgKiBEZWNvcmF0b3IgZm9yIHNob3dpbmcgVG9vbHRpcCBieSBtb3VzZWVudGVyL21vdXNlbGVhdmVcbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIGVsZW1lbnQgb24gd2hpY2ggdG9vbHRpcCBzaG91bGQgYmUgc2hvd25cbiAgICogQHBhcmFtIHtUb29sdGlwQ29udGVudH0gY29udGVudCAtIHRvb2x0aXAgY29udGVudFxuICAgKiBAcGFyYW0ge1Rvb2x0aXBPcHRpb25zfSBvcHRpb25zIC0gdG9vbHRpcCBvcHRpb25zXG4gICAqL1xuICBvbkhvdmVyKGUsIHQsIG8pIHtcbiAgICBOZShlLCB0LCBvKTtcbiAgfVxufVxuY2xhc3MgSGkgZXh0ZW5kcyB5IHtcbiAgLyoqXG4gICAqIEF2YWlsYWJsZSBtZXRob2RzIC8gZ2V0dGVyc1xuICAgKi9cbiAgZ2V0IG1ldGhvZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5vZGVzOiB0aGlzLmVkaXRvck5vZGVzXG4gICAgICAvKipcbiAgICAgICAqIFRoZXJlIGNhbiBiZSBhZGRlZCBzb21lIFVJIG1ldGhvZHMsIGxpa2UgdG9nZ2xlVGhpbk1vZGUoKSBldGNcbiAgICAgICAqL1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEV4cG9ydGVkIGNsYXNzZXNcbiAgICovXG4gIGdldCBlZGl0b3JOb2RlcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLyoqXG4gICAgICAgKiBUb3AtbGV2ZWwgZWRpdG9yIGluc3RhbmNlIHdyYXBwZXJcbiAgICAgICAqL1xuICAgICAgd3JhcHBlcjogdGhpcy5FZGl0b3IuVUkubm9kZXMud3JhcHBlcixcbiAgICAgIC8qKlxuICAgICAgICogRWxlbWVudCB0aGF0IGhvbGRzIGFsbCB0aGUgQmxvY2tzXG4gICAgICAgKi9cbiAgICAgIHJlZGFjdG9yOiB0aGlzLkVkaXRvci5VSS5ub2Rlcy5yZWRhY3RvclxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIEp0KG4sIGUpIHtcbiAgY29uc3QgdCA9IHt9O1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMobikuZm9yRWFjaCgoW28sIGldKSA9PiB7XG4gICAgaWYgKFIoaSkpIHtcbiAgICAgIGNvbnN0IHMgPSBlID8gYCR7ZX0uJHtvfWAgOiBvO1xuICAgICAgT2JqZWN0LnZhbHVlcyhpKS5ldmVyeSgobCkgPT4gUShsKSkgPyB0W29dID0gcyA6IHRbb10gPSBKdChpLCBzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdFtvXSA9IGk7XG4gIH0pLCB0O1xufVxuY29uc3QgViA9IEp0KEx0KTtcbmZ1bmN0aW9uIHppKG4sIGUpIHtcbiAgY29uc3QgdCA9IHt9O1xuICByZXR1cm4gT2JqZWN0LmtleXMobikuZm9yRWFjaCgobykgPT4ge1xuICAgIGNvbnN0IGkgPSBlW29dO1xuICAgIGkgIT09IHZvaWQgMCA/IHRbaV0gPSBuW29dIDogdFtvXSA9IG5bb107XG4gIH0pLCB0O1xufVxuY2xhc3MgVWkgZXh0ZW5kcyB5IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy5vcGVuZWQgPSAhMSwgdGhpcy5zZWxlY3Rpb24gPSBuZXcgYigpLCB0aGlzLnBvcG92ZXIgPSBudWxsLCB0aGlzLmNsb3NlID0gKCkgPT4ge1xuICAgICAgdGhpcy5vcGVuZWQgJiYgKHRoaXMub3BlbmVkID0gITEsIGIuaXNBdEVkaXRvciB8fCB0aGlzLnNlbGVjdGlvbi5yZXN0b3JlKCksIHRoaXMuc2VsZWN0aW9uLmNsZWFyU2F2ZWQoKSwgIXRoaXMuRWRpdG9yLkNyb3NzQmxvY2tTZWxlY3Rpb24uaXNDcm9zc0Jsb2NrU2VsZWN0aW9uU3RhcnRlZCAmJiB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY3VycmVudEJsb2NrICYmIHRoaXMuRWRpdG9yLkJsb2NrU2VsZWN0aW9uLnVuc2VsZWN0QmxvY2sodGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmN1cnJlbnRCbG9jayksIHRoaXMuZXZlbnRzRGlzcGF0Y2hlci5lbWl0KHRoaXMuZXZlbnRzLmNsb3NlZCksIHRoaXMucG9wb3ZlciAmJiAodGhpcy5wb3BvdmVyLm9mZihaLkNsb3NlZCwgdGhpcy5vblBvcG92ZXJDbG9zZSksIHRoaXMucG9wb3Zlci5kZXN0cm95KCksIHRoaXMucG9wb3Zlci5nZXRFbGVtZW50KCkucmVtb3ZlKCksIHRoaXMucG9wb3ZlciA9IG51bGwpKTtcbiAgICB9LCB0aGlzLm9uUG9wb3ZlckNsb3NlID0gKCkgPT4ge1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIE1vZHVsZSBFdmVudHNcbiAgICovXG4gIGdldCBldmVudHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9wZW5lZDogXCJibG9jay1zZXR0aW5ncy1vcGVuZWRcIixcbiAgICAgIGNsb3NlZDogXCJibG9jay1zZXR0aW5ncy1jbG9zZWRcIlxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEJsb2NrIFNldHRpbmdzIENTU1xuICAgKi9cbiAgZ2V0IENTUygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0dGluZ3M6IFwiY2Utc2V0dGluZ3NcIlxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEdldHRlciBmb3IgaW5uZXIgcG9wb3ZlcidzIGZsaXBwZXIgaW5zdGFuY2VcbiAgICpcbiAgICogQHRvZG8gcmVtb3ZlIG9uY2UgQmxvY2tTZXR0aW5ncyBiZWNvbWVzIHN0YW5kYWxvbmUgbm9uLW1vZHVsZSBjbGFzc1xuICAgKi9cbiAgZ2V0IGZsaXBwZXIoKSB7XG4gICAgdmFyIGU7XG4gICAgaWYgKHRoaXMucG9wb3ZlciAhPT0gbnVsbClcbiAgICAgIHJldHVybiBcImZsaXBwZXJcIiBpbiB0aGlzLnBvcG92ZXIgPyAoZSA9IHRoaXMucG9wb3ZlcikgPT0gbnVsbCA/IHZvaWQgMCA6IGUuZmxpcHBlciA6IHZvaWQgMDtcbiAgfVxuICAvKipcbiAgICogUGFuZWwgd2l0aCBibG9jayBzZXR0aW5ncyB3aXRoIDIgc2VjdGlvbnM6XG4gICAqICAtIFRvb2wncyBTZXR0aW5nc1xuICAgKiAgLSBEZWZhdWx0IFNldHRpbmdzIFtNb3ZlLCBSZW1vdmUsIGV0Y11cbiAgICovXG4gIG1ha2UoKSB7XG4gICAgdGhpcy5ub2Rlcy53cmFwcGVyID0gZC5tYWtlKFwiZGl2XCIsIFt0aGlzLkNTUy5zZXR0aW5nc10pLCB0aGlzLmV2ZW50c0Rpc3BhdGNoZXIub24oeGUsIHRoaXMuY2xvc2UpO1xuICB9XG4gIC8qKlxuICAgKiBEZXN0cm95cyBtb2R1bGVcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZW1vdmVBbGxOb2RlcygpLCB0aGlzLmxpc3RlbmVycy5kZXN0cm95KCksIHRoaXMuZXZlbnRzRGlzcGF0Y2hlci5vZmYoeGUsIHRoaXMuY2xvc2UpO1xuICB9XG4gIC8qKlxuICAgKiBPcGVuIEJsb2NrIFNldHRpbmdzIHBhbmVcbiAgICpcbiAgICogQHBhcmFtIHRhcmdldEJsb2NrIC0gbmVhciB3aGljaCBCbG9jayB3ZSBzaG91bGQgb3BlbiBCbG9ja1NldHRpbmdzXG4gICAqL1xuICBhc3luYyBvcGVuKGUgPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY3VycmVudEJsb2NrKSB7XG4gICAgdmFyIHM7XG4gICAgdGhpcy5vcGVuZWQgPSAhMCwgdGhpcy5zZWxlY3Rpb24uc2F2ZSgpLCB0aGlzLkVkaXRvci5CbG9ja1NlbGVjdGlvbi5zZWxlY3RCbG9jayhlKSwgdGhpcy5FZGl0b3IuQmxvY2tTZWxlY3Rpb24uY2xlYXJDYWNoZSgpO1xuICAgIGNvbnN0IHsgdG9vbFR1bmVzOiB0LCBjb21tb25UdW5lczogbyB9ID0gZS5nZXRUdW5lcygpO1xuICAgIHRoaXMuZXZlbnRzRGlzcGF0Y2hlci5lbWl0KHRoaXMuZXZlbnRzLm9wZW5lZCk7XG4gICAgY29uc3QgaSA9IHVlKCkgPyBxdCA6IGl0O1xuICAgIHRoaXMucG9wb3ZlciA9IG5ldyBpKHtcbiAgICAgIHNlYXJjaGFibGU6ICEwLFxuICAgICAgaXRlbXM6IGF3YWl0IHRoaXMuZ2V0VHVuZXNJdGVtcyhlLCBvLCB0KSxcbiAgICAgIHNjb3BlRWxlbWVudDogdGhpcy5FZGl0b3IuQVBJLm1ldGhvZHMudWkubm9kZXMucmVkYWN0b3IsXG4gICAgICBtZXNzYWdlczoge1xuICAgICAgICBub3RoaW5nRm91bmQ6IFcudWkoVi51aS5wb3BvdmVyLCBcIk5vdGhpbmcgZm91bmRcIiksXG4gICAgICAgIHNlYXJjaDogVy51aShWLnVpLnBvcG92ZXIsIFwiRmlsdGVyXCIpXG4gICAgICB9XG4gICAgfSksIHRoaXMucG9wb3Zlci5vbihaLkNsb3NlZCwgdGhpcy5vblBvcG92ZXJDbG9zZSksIChzID0gdGhpcy5ub2Rlcy53cmFwcGVyKSA9PSBudWxsIHx8IHMuYXBwZW5kKHRoaXMucG9wb3Zlci5nZXRFbGVtZW50KCkpLCB0aGlzLnBvcG92ZXIuc2hvdygpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHJvb3QgYmxvY2sgc2V0dGluZ3MgZWxlbWVudFxuICAgKi9cbiAgZ2V0RWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2Rlcy53cmFwcGVyO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGxpc3Qgb2YgaXRlbXMgdG8gYmUgZGlzcGxheWVkIGluIGJsb2NrIHR1bmVzIG1lbnUuXG4gICAqIE1lcmdlcyB0b29sIHNwZWNpZmljIHR1bmVzLCBjb252ZXJzaW9uIG1lbnUgYW5kIGNvbW1vbiB0dW5lcyBpbiBvbmUgbGlzdCBpbiBwcmVkZWZpbmVkIG9yZGVyXG4gICAqXG4gICAqIEBwYXJhbSBjdXJyZW50QmxvY2sg4oCTICBibG9jayB3ZSBhcmUgYWJvdXQgdG8gb3BlbiBibG9jayB0dW5lcyBmb3JcbiAgICogQHBhcmFtIGNvbW1vblR1bmVzIOKAkyBjb21tb24gdHVuZXNcbiAgICogQHBhcmFtIHRvb2xUdW5lcyAtIHRvb2wgc3BlY2lmaWMgdHVuZXNcbiAgICovXG4gIGFzeW5jIGdldFR1bmVzSXRlbXMoZSwgdCwgbykge1xuICAgIGNvbnN0IGkgPSBbXTtcbiAgICBvICE9PSB2b2lkIDAgJiYgby5sZW5ndGggPiAwICYmIChpLnB1c2goLi4ubyksIGkucHVzaCh7XG4gICAgICB0eXBlOiBBLlNlcGFyYXRvclxuICAgIH0pKTtcbiAgICBjb25zdCBzID0gQXJyYXkuZnJvbSh0aGlzLkVkaXRvci5Ub29scy5ibG9ja1Rvb2xzLnZhbHVlcygpKSwgbCA9IChhd2FpdCB6dChlLCBzKSkucmVkdWNlKChhLCBjKSA9PiAoYy50b29sYm94LmZvckVhY2goKHUpID0+IHtcbiAgICAgIGEucHVzaCh7XG4gICAgICAgIGljb246IHUuaWNvbixcbiAgICAgICAgdGl0bGU6IHUudGl0bGUsXG4gICAgICAgIG5hbWU6IGMubmFtZSxcbiAgICAgICAgY2xvc2VPbkFjdGl2YXRlOiAhMCxcbiAgICAgICAgb25BY3RpdmF0ZTogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiBoLCBDYXJldDogcCwgVG9vbGJhcjogZyB9ID0gdGhpcy5FZGl0b3IsIGYgPSBhd2FpdCBoLmNvbnZlcnQoZSwgYy5uYW1lLCB1LmRhdGEpO1xuICAgICAgICAgIGcuY2xvc2UoKSwgcC5zZXRUb0Jsb2NrKGYsIHAucG9zaXRpb25zLkVORCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pLCBhKSwgW10pO1xuICAgIHJldHVybiBsLmxlbmd0aCA+IDAgJiYgKGkucHVzaCh7XG4gICAgICBpY29uOiBqdCxcbiAgICAgIHRpdGxlOiBXLnVpKFYudWkucG9wb3ZlciwgXCJDb252ZXJ0IHRvXCIpLFxuICAgICAgY2hpbGRyZW46IHtcbiAgICAgICAgc2VhcmNoYWJsZTogITAsXG4gICAgICAgIGl0ZW1zOiBsXG4gICAgICB9XG4gICAgfSksIGkucHVzaCh7XG4gICAgICB0eXBlOiBBLlNlcGFyYXRvclxuICAgIH0pKSwgaS5wdXNoKC4uLnQpLCBpLm1hcCgoYSkgPT4gdGhpcy5yZXNvbHZlVHVuZUFsaWFzZXMoYSkpO1xuICB9XG4gIC8qKlxuICAgKiBSZXNvbHZlcyBhbGlhc2VzIGluIHR1bmVzIG1lbnUgaXRlbXNcbiAgICpcbiAgICogQHBhcmFtIGl0ZW0gLSBpdGVtIHdpdGggcmVzb2x2ZWQgYWxpYXNlc1xuICAgKi9cbiAgcmVzb2x2ZVR1bmVBbGlhc2VzKGUpIHtcbiAgICBpZiAoZS50eXBlID09PSBBLlNlcGFyYXRvciB8fCBlLnR5cGUgPT09IEEuSHRtbClcbiAgICAgIHJldHVybiBlO1xuICAgIGNvbnN0IHQgPSB6aShlLCB7IGxhYmVsOiBcInRpdGxlXCIgfSk7XG4gICAgcmV0dXJuIGUuY29uZmlybWF0aW9uICYmICh0LmNvbmZpcm1hdGlvbiA9IHRoaXMucmVzb2x2ZVR1bmVBbGlhc2VzKGUuY29uZmlybWF0aW9uKSksIHQ7XG4gIH1cbn1cbnZhciBRdCA9IHsgZXhwb3J0czoge30gfTtcbi8qIVxuICogTGlicmFyeSBmb3IgaGFuZGxpbmcga2V5Ym9hcmQgc2hvcnRjdXRzXG4gKiBAY29weXJpZ2h0IENvZGVYIChodHRwczovL2NvZGV4LnNvKVxuICogQGxpY2Vuc2UgTUlUXG4gKiBAYXV0aG9yIENvZGVYIChodHRwczovL2NvZGV4LnNvKVxuICogQHZlcnNpb24gMS4yLjBcbiAqL1xuKGZ1bmN0aW9uKG4sIGUpIHtcbiAgKGZ1bmN0aW9uKHQsIG8pIHtcbiAgICBuLmV4cG9ydHMgPSBvKCk7XG4gIH0pKHdpbmRvdywgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHZhciBvID0ge307XG4gICAgICBmdW5jdGlvbiBpKHMpIHtcbiAgICAgICAgaWYgKG9bc10pXG4gICAgICAgICAgcmV0dXJuIG9bc10uZXhwb3J0cztcbiAgICAgICAgdmFyIHIgPSBvW3NdID0geyBpOiBzLCBsOiAhMSwgZXhwb3J0czoge30gfTtcbiAgICAgICAgcmV0dXJuIHRbc10uY2FsbChyLmV4cG9ydHMsIHIsIHIuZXhwb3J0cywgaSksIHIubCA9ICEwLCByLmV4cG9ydHM7XG4gICAgICB9XG4gICAgICByZXR1cm4gaS5tID0gdCwgaS5jID0gbywgaS5kID0gZnVuY3Rpb24ocywgciwgbCkge1xuICAgICAgICBpLm8ocywgcikgfHwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHMsIHIsIHsgZW51bWVyYWJsZTogITAsIGdldDogbCB9KTtcbiAgICAgIH0sIGkuciA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgdHlwZW9mIFN5bWJvbCA8IFwidVwiICYmIFN5bWJvbC50b1N0cmluZ1RhZyAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkocywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkocywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuICAgICAgfSwgaS50ID0gZnVuY3Rpb24ocywgcikge1xuICAgICAgICBpZiAoMSAmIHIgJiYgKHMgPSBpKHMpKSwgOCAmIHIgfHwgNCAmIHIgJiYgdHlwZW9mIHMgPT0gXCJvYmplY3RcIiAmJiBzICYmIHMuX19lc01vZHVsZSlcbiAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgdmFyIGwgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgaWYgKGkucihsKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGwsIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6ICEwLCB2YWx1ZTogcyB9KSwgMiAmIHIgJiYgdHlwZW9mIHMgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICBmb3IgKHZhciBhIGluIHMpXG4gICAgICAgICAgICBpLmQobCwgYSwgKGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNbY107XG4gICAgICAgICAgICB9KS5iaW5kKG51bGwsIGEpKTtcbiAgICAgICAgcmV0dXJuIGw7XG4gICAgICB9LCBpLm4gPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHZhciByID0gcyAmJiBzLl9fZXNNb2R1bGUgPyBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gcy5kZWZhdWx0O1xuICAgICAgICB9IDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBpLmQociwgXCJhXCIsIHIpLCByO1xuICAgICAgfSwgaS5vID0gZnVuY3Rpb24ocywgcikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHIpO1xuICAgICAgfSwgaS5wID0gXCJcIiwgaShpLnMgPSAwKTtcbiAgICB9KFtmdW5jdGlvbih0LCBvLCBpKSB7XG4gICAgICBmdW5jdGlvbiBzKGEsIGMpIHtcbiAgICAgICAgZm9yICh2YXIgdSA9IDA7IHUgPCBjLmxlbmd0aDsgdSsrKSB7XG4gICAgICAgICAgdmFyIGggPSBjW3VdO1xuICAgICAgICAgIGguZW51bWVyYWJsZSA9IGguZW51bWVyYWJsZSB8fCAhMSwgaC5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIGggJiYgKGgud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLCBoLmtleSwgaCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHIoYSwgYywgdSkge1xuICAgICAgICByZXR1cm4gYyAmJiBzKGEucHJvdG90eXBlLCBjKSwgdSAmJiBzKGEsIHUpLCBhO1xuICAgICAgfVxuICAgICAgaS5yKG8pO1xuICAgICAgdmFyIGwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gYShjKSB7XG4gICAgICAgICAgdmFyIHUgPSB0aGlzO1xuICAgICAgICAgIChmdW5jdGlvbihoLCBwKSB7XG4gICAgICAgICAgICBpZiAoIShoIGluc3RhbmNlb2YgcCkpXG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgICAgICAgfSkodGhpcywgYSksIHRoaXMuY29tbWFuZHMgPSB7fSwgdGhpcy5rZXlzID0ge30sIHRoaXMubmFtZSA9IGMubmFtZSwgdGhpcy5wYXJzZVNob3J0Y3V0TmFtZShjLm5hbWUpLCB0aGlzLmVsZW1lbnQgPSBjLm9uLCB0aGlzLmNhbGxiYWNrID0gYy5jYWxsYmFjaywgdGhpcy5leGVjdXRlU2hvcnRjdXQgPSBmdW5jdGlvbihoKSB7XG4gICAgICAgICAgICB1LmV4ZWN1dGUoaCk7XG4gICAgICAgICAgfSwgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuZXhlY3V0ZVNob3J0Y3V0LCAhMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHIoYSwgbnVsbCwgW3sga2V5OiBcInN1cHBvcnRlZENvbW1hbmRzXCIsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHsgU0hJRlQ6IFtcIlNISUZUXCJdLCBDTUQ6IFtcIkNNRFwiLCBcIkNPTlRST0xcIiwgXCJDT01NQU5EXCIsIFwiV0lORE9XU1wiLCBcIkNUUkxcIl0sIEFMVDogW1wiQUxUXCIsIFwiT1BUSU9OXCJdIH07XG4gICAgICAgIH0gfSwgeyBrZXk6IFwia2V5Q29kZXNcIiwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4geyAwOiA0OCwgMTogNDksIDI6IDUwLCAzOiA1MSwgNDogNTIsIDU6IDUzLCA2OiA1NCwgNzogNTUsIDg6IDU2LCA5OiA1NywgQTogNjUsIEI6IDY2LCBDOiA2NywgRDogNjgsIEU6IDY5LCBGOiA3MCwgRzogNzEsIEg6IDcyLCBJOiA3MywgSjogNzQsIEs6IDc1LCBMOiA3NiwgTTogNzcsIE46IDc4LCBPOiA3OSwgUDogODAsIFE6IDgxLCBSOiA4MiwgUzogODMsIFQ6IDg0LCBVOiA4NSwgVjogODYsIFc6IDg3LCBYOiA4OCwgWTogODksIFo6IDkwLCBCQUNLU1BBQ0U6IDgsIEVOVEVSOiAxMywgRVNDQVBFOiAyNywgTEVGVDogMzcsIFVQOiAzOCwgUklHSFQ6IDM5LCBET1dOOiA0MCwgSU5TRVJUOiA0NSwgREVMRVRFOiA0NiwgXCIuXCI6IDE5MCB9O1xuICAgICAgICB9IH1dKSwgcihhLCBbeyBrZXk6IFwicGFyc2VTaG9ydGN1dE5hbWVcIiwgdmFsdWU6IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICBjID0gYy5zcGxpdChcIitcIik7XG4gICAgICAgICAgZm9yICh2YXIgdSA9IDA7IHUgPCBjLmxlbmd0aDsgdSsrKSB7XG4gICAgICAgICAgICBjW3VdID0gY1t1XS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgdmFyIGggPSAhMTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gYS5zdXBwb3J0ZWRDb21tYW5kcylcbiAgICAgICAgICAgICAgaWYgKGEuc3VwcG9ydGVkQ29tbWFuZHNbcF0uaW5jbHVkZXMoY1t1XSkpIHtcbiAgICAgICAgICAgICAgICBoID0gdGhpcy5jb21tYW5kc1twXSA9ICEwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBoIHx8ICh0aGlzLmtleXNbY1t1XV0gPSAhMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIGcgaW4gYS5zdXBwb3J0ZWRDb21tYW5kcylcbiAgICAgICAgICAgIHRoaXMuY29tbWFuZHNbZ10gfHwgKHRoaXMuY29tbWFuZHNbZ10gPSAhMSk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiZXhlY3V0ZVwiLCB2YWx1ZTogZnVuY3Rpb24oYykge1xuICAgICAgICAgIHZhciB1LCBoID0geyBDTUQ6IGMuY3RybEtleSB8fCBjLm1ldGFLZXksIFNISUZUOiBjLnNoaWZ0S2V5LCBBTFQ6IGMuYWx0S2V5IH0sIHAgPSAhMDtcbiAgICAgICAgICBmb3IgKHUgaW4gdGhpcy5jb21tYW5kcylcbiAgICAgICAgICAgIHRoaXMuY29tbWFuZHNbdV0gIT09IGhbdV0gJiYgKHAgPSAhMSk7XG4gICAgICAgICAgdmFyIGcsIGYgPSAhMDtcbiAgICAgICAgICBmb3IgKGcgaW4gdGhpcy5rZXlzKVxuICAgICAgICAgICAgZiA9IGYgJiYgYy5rZXlDb2RlID09PSBhLmtleUNvZGVzW2ddO1xuICAgICAgICAgIHAgJiYgZiAmJiB0aGlzLmNhbGxiYWNrKGMpO1xuICAgICAgICB9IH0sIHsga2V5OiBcInJlbW92ZVwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuZXhlY3V0ZVNob3J0Y3V0KTtcbiAgICAgICAgfSB9XSksIGE7XG4gICAgICB9KCk7XG4gICAgICBvLmRlZmF1bHQgPSBsO1xuICAgIH1dKS5kZWZhdWx0O1xuICB9KTtcbn0pKFF0KTtcbnZhciBqaSA9IFF0LmV4cG9ydHM7XG5jb25zdCAkaSA9IC8qIEBfX1BVUkVfXyAqLyBSZShqaSk7XG5jbGFzcyBZaSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucmVnaXN0ZXJlZFNob3J0Y3V0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIHNob3J0Y3V0XG4gICAqXG4gICAqIEBwYXJhbSBzaG9ydGN1dCAtIHNob3J0Y3V0IG9wdGlvbnNcbiAgICovXG4gIGFkZChlKSB7XG4gICAgaWYgKHRoaXMuZmluZFNob3J0Y3V0KGUub24sIGUubmFtZSkpXG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgYFNob3J0Y3V0ICR7ZS5uYW1lfSBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQgZm9yICR7ZS5vbn0uIFBsZWFzZSByZW1vdmUgaXQgYmVmb3JlIGFkZCBhIG5ldyBoYW5kbGVyLmBcbiAgICAgICk7XG4gICAgY29uc3QgbyA9IG5ldyAkaSh7XG4gICAgICBuYW1lOiBlLm5hbWUsXG4gICAgICBvbjogZS5vbixcbiAgICAgIGNhbGxiYWNrOiBlLmhhbmRsZXJcbiAgICB9KSwgaSA9IHRoaXMucmVnaXN0ZXJlZFNob3J0Y3V0cy5nZXQoZS5vbikgfHwgW107XG4gICAgdGhpcy5yZWdpc3RlcmVkU2hvcnRjdXRzLnNldChlLm9uLCBbLi4uaSwgb10pO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgc2hvcnRjdXRcbiAgICpcbiAgICogQHBhcmFtIGVsZW1lbnQgLSBFbGVtZW50IHNob3J0Y3V0IGlzIHNldCBmb3JcbiAgICogQHBhcmFtIG5hbWUgLSBzaG9ydGN1dCBuYW1lXG4gICAqL1xuICByZW1vdmUoZSwgdCkge1xuICAgIGNvbnN0IG8gPSB0aGlzLmZpbmRTaG9ydGN1dChlLCB0KTtcbiAgICBpZiAoIW8pXG4gICAgICByZXR1cm47XG4gICAgby5yZW1vdmUoKTtcbiAgICBjb25zdCBpID0gdGhpcy5yZWdpc3RlcmVkU2hvcnRjdXRzLmdldChlKTtcbiAgICB0aGlzLnJlZ2lzdGVyZWRTaG9ydGN1dHMuc2V0KGUsIGkuZmlsdGVyKChzKSA9PiBzICE9PSBvKSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBTaG9ydGN1dCBpbnN0YW5jZSBpZiBleGlzdFxuICAgKlxuICAgKiBAcGFyYW0gZWxlbWVudCAtIEVsZW1lbnQgc2hvcmN1dCBpcyBzZXQgZm9yXG4gICAqIEBwYXJhbSBzaG9ydGN1dCAtIHNob3J0Y3V0IG5hbWVcbiAgICogQHJldHVybnMge251bWJlcn0gaW5kZXggLSBzaG9ydGN1dCBpbmRleCBpZiBleGlzdFxuICAgKi9cbiAgZmluZFNob3J0Y3V0KGUsIHQpIHtcbiAgICByZXR1cm4gKHRoaXMucmVnaXN0ZXJlZFNob3J0Y3V0cy5nZXQoZSkgfHwgW10pLmZpbmQoKHsgbmFtZTogaSB9KSA9PiBpID09PSB0KTtcbiAgfVxufVxuY29uc3QgZGUgPSBuZXcgWWkoKTtcbnZhciBXaSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgS2kgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLCBlbyA9IChuLCBlLCB0LCBvKSA9PiB7XG4gIGZvciAodmFyIGkgPSBvID4gMSA/IHZvaWQgMCA6IG8gPyBLaShlLCB0KSA6IGUsIHMgPSBuLmxlbmd0aCAtIDEsIHI7IHMgPj0gMDsgcy0tKVxuICAgIChyID0gbltzXSkgJiYgKGkgPSAobyA/IHIoZSwgdCwgaSkgOiByKGkpKSB8fCBpKTtcbiAgcmV0dXJuIG8gJiYgaSAmJiBXaShlLCB0LCBpKSwgaTtcbn0sIENlID0gLyogQF9fUFVSRV9fICovICgobikgPT4gKG4uT3BlbmVkID0gXCJ0b29sYm94LW9wZW5lZFwiLCBuLkNsb3NlZCA9IFwidG9vbGJveC1jbG9zZWRcIiwgbi5CbG9ja0FkZGVkID0gXCJ0b29sYm94LWJsb2NrLWFkZGVkXCIsIG4pKShDZSB8fCB7fSk7XG5jb25zdCBsdCA9IGNsYXNzIHRvIGV4dGVuZHMgQmUge1xuICAvKipcbiAgICogVG9vbGJveCBjb25zdHJ1Y3RvclxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIGF2YWlsYWJsZSBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSBvcHRpb25zLmFwaSAtIEVkaXRvciBBUEkgbWV0aG9kc1xuICAgKiBAcGFyYW0gb3B0aW9ucy50b29scyAtIFRvb2xzIGF2YWlsYWJsZSB0byBjaGVjayB3aGV0aGVyIHNvbWUgb2YgdGhlbSBzaG91bGQgYmUgZGlzcGxheWVkIGF0IHRoZSBUb29sYm94IG9yIG5vdFxuICAgKi9cbiAgY29uc3RydWN0b3IoeyBhcGk6IGUsIHRvb2xzOiB0LCBpMThuTGFiZWxzOiBvIH0pIHtcbiAgICBzdXBlcigpLCB0aGlzLm9wZW5lZCA9ICExLCB0aGlzLmxpc3RlbmVycyA9IG5ldyBUZSgpLCB0aGlzLnBvcG92ZXIgPSBudWxsLCB0aGlzLmhhbmRsZU1vYmlsZUxheW91dFRvZ2dsZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuZGVzdHJveVBvcG92ZXIoKSwgdGhpcy5pbml0UG9wb3ZlcigpO1xuICAgIH0sIHRoaXMub25Qb3BvdmVyQ2xvc2UgPSAoKSA9PiB7XG4gICAgICB0aGlzLm9wZW5lZCA9ICExLCB0aGlzLmVtaXQoXG4gICAgICAgIFwidG9vbGJveC1jbG9zZWRcIlxuICAgICAgICAvKiBDbG9zZWQgKi9cbiAgICAgICk7XG4gICAgfSwgdGhpcy5hcGkgPSBlLCB0aGlzLnRvb2xzID0gdCwgdGhpcy5pMThuTGFiZWxzID0gbywgdGhpcy5lbmFibGVTaG9ydGN1dHMoKSwgdGhpcy5ub2RlcyA9IHtcbiAgICAgIHRvb2xib3g6IGQubWFrZShcImRpdlwiLCB0by5DU1MudG9vbGJveClcbiAgICB9LCB0aGlzLmluaXRQb3BvdmVyKCksIHRoaXMuYXBpLmV2ZW50cy5vbih4ZSwgdGhpcy5oYW5kbGVNb2JpbGVMYXlvdXRUb2dnbGUpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIFRydWUgaWYgVG9vbGJveCBpcyBFbXB0eSBhbmQgbm90aGluZyB0byBzaG93XG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9vbHNUb0JlRGlzcGxheWVkLmxlbmd0aCA9PT0gMDtcbiAgfVxuICAvKipcbiAgICogQ1NTIHN0eWxlc1xuICAgKi9cbiAgc3RhdGljIGdldCBDU1MoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvb2xib3g6IFwiY2UtdG9vbGJveFwiXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyByb290IGJsb2NrIHNldHRpbmdzIGVsZW1lbnRcbiAgICovXG4gIGdldEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMudG9vbGJveDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBUb29sYm94IGhhcyB0aGUgRmxpcHBlciBhY3RpdmF0ZWQgYW5kIHRoZSBGbGlwcGVyIGhhcyBzZWxlY3RlZCBidXR0b25cbiAgICovXG4gIGhhc0ZvY3VzKCkge1xuICAgIGlmICh0aGlzLnBvcG92ZXIgIT09IG51bGwpXG4gICAgICByZXR1cm4gXCJoYXNGb2N1c1wiIGluIHRoaXMucG9wb3ZlciA/IHRoaXMucG9wb3Zlci5oYXNGb2N1cygpIDogdm9pZCAwO1xuICB9XG4gIC8qKlxuICAgKiBEZXN0cm95IE1vZHVsZVxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB2YXIgZTtcbiAgICBzdXBlci5kZXN0cm95KCksIHRoaXMubm9kZXMgJiYgdGhpcy5ub2Rlcy50b29sYm94ICYmIHRoaXMubm9kZXMudG9vbGJveC5yZW1vdmUoKSwgdGhpcy5yZW1vdmVBbGxTaG9ydGN1dHMoKSwgKGUgPSB0aGlzLnBvcG92ZXIpID09IG51bGwgfHwgZS5vZmYoWi5DbG9zZWQsIHRoaXMub25Qb3BvdmVyQ2xvc2UpLCB0aGlzLmxpc3RlbmVycy5kZXN0cm95KCksIHRoaXMuYXBpLmV2ZW50cy5vZmYoeGUsIHRoaXMuaGFuZGxlTW9iaWxlTGF5b3V0VG9nZ2xlKTtcbiAgfVxuICAvKipcbiAgICogVG9vbGJveCBUb29sJ3MgYnV0dG9uIGNsaWNrIGhhbmRsZXJcbiAgICpcbiAgICogQHBhcmFtIHRvb2xOYW1lIC0gdG9vbCB0eXBlIHRvIGJlIGFjdGl2YXRlZFxuICAgKiBAcGFyYW0gYmxvY2tEYXRhT3ZlcnJpZGVzIC0gQmxvY2sgZGF0YSBwcmVkZWZpbmVkIGJ5IHRoZSBhY3RpdmF0ZWQgVG9vbGJveCBpdGVtXG4gICAqL1xuICB0b29sQnV0dG9uQWN0aXZhdGVkKGUsIHQpIHtcbiAgICB0aGlzLmluc2VydE5ld0Jsb2NrKGUsIHQpO1xuICB9XG4gIC8qKlxuICAgKiBPcGVuIFRvb2xib3ggd2l0aCBUb29sc1xuICAgKi9cbiAgb3BlbigpIHtcbiAgICB2YXIgZTtcbiAgICB0aGlzLmlzRW1wdHkgfHwgKChlID0gdGhpcy5wb3BvdmVyKSA9PSBudWxsIHx8IGUuc2hvdygpLCB0aGlzLm9wZW5lZCA9ICEwLCB0aGlzLmVtaXQoXG4gICAgICBcInRvb2xib3gtb3BlbmVkXCJcbiAgICAgIC8qIE9wZW5lZCAqL1xuICAgICkpO1xuICB9XG4gIC8qKlxuICAgKiBDbG9zZSBUb29sYm94XG4gICAqL1xuICBjbG9zZSgpIHtcbiAgICB2YXIgZTtcbiAgICAoZSA9IHRoaXMucG9wb3ZlcikgPT0gbnVsbCB8fCBlLmhpZGUoKSwgdGhpcy5vcGVuZWQgPSAhMSwgdGhpcy5lbWl0KFxuICAgICAgXCJ0b29sYm94LWNsb3NlZFwiXG4gICAgICAvKiBDbG9zZWQgKi9cbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBDbG9zZSBUb29sYm94XG4gICAqL1xuICB0b2dnbGUoKSB7XG4gICAgdGhpcy5vcGVuZWQgPyB0aGlzLmNsb3NlKCkgOiB0aGlzLm9wZW4oKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyB0b29sYm94IHBvcG92ZXIgYW5kIGFwcGVuZHMgaXQgaW5zaWRlIHdyYXBwZXIgZWxlbWVudFxuICAgKi9cbiAgaW5pdFBvcG92ZXIoKSB7XG4gICAgdmFyIHQ7XG4gICAgY29uc3QgZSA9IHVlKCkgPyBxdCA6IGl0O1xuICAgIHRoaXMucG9wb3ZlciA9IG5ldyBlKHtcbiAgICAgIHNjb3BlRWxlbWVudDogdGhpcy5hcGkudWkubm9kZXMucmVkYWN0b3IsXG4gICAgICBzZWFyY2hhYmxlOiAhMCxcbiAgICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgIG5vdGhpbmdGb3VuZDogdGhpcy5pMThuTGFiZWxzLm5vdGhpbmdGb3VuZCxcbiAgICAgICAgc2VhcmNoOiB0aGlzLmkxOG5MYWJlbHMuZmlsdGVyXG4gICAgICB9LFxuICAgICAgaXRlbXM6IHRoaXMudG9vbGJveEl0ZW1zVG9CZURpc3BsYXllZFxuICAgIH0pLCB0aGlzLnBvcG92ZXIub24oWi5DbG9zZWQsIHRoaXMub25Qb3BvdmVyQ2xvc2UpLCAodCA9IHRoaXMubm9kZXMudG9vbGJveCkgPT0gbnVsbCB8fCB0LmFwcGVuZCh0aGlzLnBvcG92ZXIuZ2V0RWxlbWVudCgpKTtcbiAgfVxuICAvKipcbiAgICogRGVzdHJveXMgcG9wb3ZlciBpbnN0YW5jZSBhbmQgcmVtb3ZlcyBpdCBmcm9tIERPTVxuICAgKi9cbiAgZGVzdHJveVBvcG92ZXIoKSB7XG4gICAgdGhpcy5wb3BvdmVyICE9PSBudWxsICYmICh0aGlzLnBvcG92ZXIuaGlkZSgpLCB0aGlzLnBvcG92ZXIub2ZmKFouQ2xvc2VkLCB0aGlzLm9uUG9wb3ZlckNsb3NlKSwgdGhpcy5wb3BvdmVyLmRlc3Ryb3koKSwgdGhpcy5wb3BvdmVyID0gbnVsbCksIHRoaXMubm9kZXMudG9vbGJveCAhPT0gbnVsbCAmJiAodGhpcy5ub2Rlcy50b29sYm94LmlubmVySFRNTCA9IFwiXCIpO1xuICB9XG4gIGdldCB0b29sc1RvQmVEaXNwbGF5ZWQoKSB7XG4gICAgY29uc3QgZSA9IFtdO1xuICAgIHJldHVybiB0aGlzLnRvb2xzLmZvckVhY2goKHQpID0+IHtcbiAgICAgIHQudG9vbGJveCAmJiBlLnB1c2godCk7XG4gICAgfSksIGU7XG4gIH1cbiAgZ2V0IHRvb2xib3hJdGVtc1RvQmVEaXNwbGF5ZWQoKSB7XG4gICAgY29uc3QgZSA9ICh0LCBvKSA9PiAoe1xuICAgICAgaWNvbjogdC5pY29uLFxuICAgICAgdGl0bGU6IFcudChWLnRvb2xOYW1lcywgdC50aXRsZSB8fCBPZShvLm5hbWUpKSxcbiAgICAgIG5hbWU6IG8ubmFtZSxcbiAgICAgIG9uQWN0aXZhdGU6ICgpID0+IHtcbiAgICAgICAgdGhpcy50b29sQnV0dG9uQWN0aXZhdGVkKG8ubmFtZSwgdC5kYXRhKTtcbiAgICAgIH0sXG4gICAgICBzZWNvbmRhcnlMYWJlbDogby5zaG9ydGN1dCA/IGV0KG8uc2hvcnRjdXQpIDogXCJcIlxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLnRvb2xzVG9CZURpc3BsYXllZC5yZWR1Y2UoKHQsIG8pID0+IChBcnJheS5pc0FycmF5KG8udG9vbGJveCkgPyBvLnRvb2xib3guZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgdC5wdXNoKGUoaSwgbykpO1xuICAgIH0pIDogby50b29sYm94ICE9PSB2b2lkIDAgJiYgdC5wdXNoKGUoby50b29sYm94LCBvKSksIHQpLCBbXSk7XG4gIH1cbiAgLyoqXG4gICAqIEl0ZXJhdGUgYWxsIHRvb2xzIGFuZCBlbmFibGUgdGhlaXJzIHNob3J0Y3V0cyBpZiBzcGVjaWZpZWRcbiAgICovXG4gIGVuYWJsZVNob3J0Y3V0cygpIHtcbiAgICB0aGlzLnRvb2xzVG9CZURpc3BsYXllZC5mb3JFYWNoKChlKSA9PiB7XG4gICAgICBjb25zdCB0ID0gZS5zaG9ydGN1dDtcbiAgICAgIHQgJiYgdGhpcy5lbmFibGVTaG9ydGN1dEZvclRvb2woZS5uYW1lLCB0KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRW5hYmxlIHNob3J0Y3V0IEJsb2NrIFRvb2wgaW1wbGVtZW50ZWQgc2hvcnRjdXRcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvb2xOYW1lIC0gVG9vbCBuYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzaG9ydGN1dCAtIHNob3J0Y3V0IGFjY29yZGluZyB0byB0aGUgU2hvcnRjdXREYXRhIE1vZHVsZSBmb3JtYXRcbiAgICovXG4gIGVuYWJsZVNob3J0Y3V0Rm9yVG9vbChlLCB0KSB7XG4gICAgZGUuYWRkKHtcbiAgICAgIG5hbWU6IHQsXG4gICAgICBvbjogdGhpcy5hcGkudWkubm9kZXMucmVkYWN0b3IsXG4gICAgICBoYW5kbGVyOiBhc3luYyAobykgPT4ge1xuICAgICAgICBvLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGNvbnN0IGkgPSB0aGlzLmFwaS5ibG9ja3MuZ2V0Q3VycmVudEJsb2NrSW5kZXgoKSwgcyA9IHRoaXMuYXBpLmJsb2Nrcy5nZXRCbG9ja0J5SW5kZXgoaSk7XG4gICAgICAgIGlmIChzKVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByID0gYXdhaXQgdGhpcy5hcGkuYmxvY2tzLmNvbnZlcnQocy5pZCwgZSk7XG4gICAgICAgICAgICB0aGlzLmFwaS5jYXJldC5zZXRUb0Jsb2NrKHIsIFwiZW5kXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnNlcnROZXdCbG9jayhlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwgYWRkZWQgc2hvcnRjdXRzXG4gICAqIEZpcmVkIHdoZW4gdGhlIFJlYWQtT25seSBtb2RlIGlzIGFjdGl2YXRlZFxuICAgKi9cbiAgcmVtb3ZlQWxsU2hvcnRjdXRzKCkge1xuICAgIHRoaXMudG9vbHNUb0JlRGlzcGxheWVkLmZvckVhY2goKGUpID0+IHtcbiAgICAgIGNvbnN0IHQgPSBlLnNob3J0Y3V0O1xuICAgICAgdCAmJiBkZS5yZW1vdmUodGhpcy5hcGkudWkubm9kZXMucmVkYWN0b3IsIHQpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBJbnNlcnRzIG5ldyBibG9ja1xuICAgKiBDYW4gYmUgY2FsbGVkIHdoZW4gYnV0dG9uIGNsaWNrZWQgb24gVG9vbGJveCBvciBieSBTaG9ydGN1dERhdGFcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvb2xOYW1lIC0gVG9vbCBuYW1lXG4gICAqIEBwYXJhbSBibG9ja0RhdGFPdmVycmlkZXMgLSBwcmVkZWZpbmVkIEJsb2NrIGRhdGFcbiAgICovXG4gIGFzeW5jIGluc2VydE5ld0Jsb2NrKGUsIHQpIHtcbiAgICBjb25zdCBvID0gdGhpcy5hcGkuYmxvY2tzLmdldEN1cnJlbnRCbG9ja0luZGV4KCksIGkgPSB0aGlzLmFwaS5ibG9ja3MuZ2V0QmxvY2tCeUluZGV4KG8pO1xuICAgIGlmICghaSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBzID0gaS5pc0VtcHR5ID8gbyA6IG8gKyAxO1xuICAgIGxldCByO1xuICAgIGlmICh0KSB7XG4gICAgICBjb25zdCBhID0gYXdhaXQgdGhpcy5hcGkuYmxvY2tzLmNvbXBvc2VCbG9ja0RhdGEoZSk7XG4gICAgICByID0gT2JqZWN0LmFzc2lnbihhLCB0KTtcbiAgICB9XG4gICAgY29uc3QgbCA9IHRoaXMuYXBpLmJsb2Nrcy5pbnNlcnQoXG4gICAgICBlLFxuICAgICAgcixcbiAgICAgIHZvaWQgMCxcbiAgICAgIHMsXG4gICAgICB2b2lkIDAsXG4gICAgICBpLmlzRW1wdHlcbiAgICApO1xuICAgIGwuY2FsbChKLkFQUEVORF9DQUxMQkFDSyksIHRoaXMuYXBpLmNhcmV0LnNldFRvQmxvY2socyksIHRoaXMuZW1pdChcInRvb2xib3gtYmxvY2stYWRkZWRcIiwge1xuICAgICAgYmxvY2s6IGxcbiAgICB9KSwgdGhpcy5hcGkudG9vbGJhci5jbG9zZSgpO1xuICB9XG59O1xuZW8oW1xuICBoZVxuXSwgbHQucHJvdG90eXBlLCBcInRvb2xzVG9CZURpc3BsYXllZFwiLCAxKTtcbmVvKFtcbiAgaGVcbl0sIGx0LnByb3RvdHlwZSwgXCJ0b29sYm94SXRlbXNUb0JlRGlzcGxheWVkXCIsIDEpO1xubGV0IFhpID0gbHQ7XG5jb25zdCBvbyA9IFwiYmxvY2sgaG92ZXJlZFwiO1xuYXN5bmMgZnVuY3Rpb24gVmkobiwgZSkge1xuICBjb25zdCB0ID0gbmF2aWdhdG9yLmtleWJvYXJkO1xuICByZXR1cm4gdCAmJiAoYXdhaXQgdC5nZXRMYXlvdXRNYXAoKSkuZ2V0KG4pIHx8IGU7XG59XG5jbGFzcyBxaSBleHRlbmRzIHkge1xuICAvKipcbiAgICogQGNsYXNzXG4gICAqIEBwYXJhbSBtb2R1bGVDb25maWd1cmF0aW9uIC0gTW9kdWxlIENvbmZpZ3VyYXRpb25cbiAgICogQHBhcmFtIG1vZHVsZUNvbmZpZ3VyYXRpb24uY29uZmlnIC0gRWRpdG9yJ3MgY29uZmlnXG4gICAqIEBwYXJhbSBtb2R1bGVDb25maWd1cmF0aW9uLmV2ZW50c0Rpc3BhdGNoZXIgLSBFZGl0b3IncyBldmVudCBkaXNwYXRjaGVyXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGNvbmZpZzogZSwgZXZlbnRzRGlzcGF0Y2hlcjogdCB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgY29uZmlnOiBlLFxuICAgICAgZXZlbnRzRGlzcGF0Y2hlcjogdFxuICAgIH0pLCB0aGlzLnRvb2xib3hJbnN0YW5jZSA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIENTUyBzdHlsZXNcbiAgICpcbiAgICogQHJldHVybnMge29iamVjdH1cbiAgICovXG4gIGdldCBDU1MoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvb2xiYXI6IFwiY2UtdG9vbGJhclwiLFxuICAgICAgY29udGVudDogXCJjZS10b29sYmFyX19jb250ZW50XCIsXG4gICAgICBhY3Rpb25zOiBcImNlLXRvb2xiYXJfX2FjdGlvbnNcIixcbiAgICAgIGFjdGlvbnNPcGVuZWQ6IFwiY2UtdG9vbGJhcl9fYWN0aW9ucy0tb3BlbmVkXCIsXG4gICAgICB0b29sYmFyT3BlbmVkOiBcImNlLXRvb2xiYXItLW9wZW5lZFwiLFxuICAgICAgb3BlbmVkVG9vbGJveEhvbGRlck1vZGlmaWVyOiBcImNvZGV4LWVkaXRvci0tdG9vbGJveC1vcGVuZWRcIixcbiAgICAgIHBsdXNCdXR0b246IFwiY2UtdG9vbGJhcl9fcGx1c1wiLFxuICAgICAgcGx1c0J1dHRvblNob3J0Y3V0OiBcImNlLXRvb2xiYXJfX3BsdXMtc2hvcnRjdXRcIixcbiAgICAgIHNldHRpbmdzVG9nZ2xlcjogXCJjZS10b29sYmFyX19zZXR0aW5ncy1idG5cIixcbiAgICAgIHNldHRpbmdzVG9nZ2xlckhpZGRlbjogXCJjZS10b29sYmFyX19zZXR0aW5ncy1idG4tLWhpZGRlblwiXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgVG9vbGJhciBvcGVuaW5nIHN0YXRlXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IG9wZW5lZCgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2Rlcy53cmFwcGVyLmNsYXNzTGlzdC5jb250YWlucyh0aGlzLkNTUy50b29sYmFyT3BlbmVkKTtcbiAgfVxuICAvKipcbiAgICogUHVibGljIGludGVyZmFjZSBmb3IgYWNjZXNzaW5nIHRoZSBUb29sYm94XG4gICAqL1xuICBnZXQgdG9vbGJveCgpIHtcbiAgICB2YXIgZTtcbiAgICByZXR1cm4ge1xuICAgICAgb3BlbmVkOiAoZSA9IHRoaXMudG9vbGJveEluc3RhbmNlKSA9PSBudWxsID8gdm9pZCAwIDogZS5vcGVuZWQsXG4gICAgICBjbG9zZTogKCkgPT4ge1xuICAgICAgICB2YXIgdDtcbiAgICAgICAgKHQgPSB0aGlzLnRvb2xib3hJbnN0YW5jZSkgPT0gbnVsbCB8fCB0LmNsb3NlKCk7XG4gICAgICB9LFxuICAgICAgb3BlbjogKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy50b29sYm94SW5zdGFuY2UgPT09IG51bGwpIHtcbiAgICAgICAgICBJKFwidG9vbGJveC5vcGVuKCkgY2FsbGVkIGJlZm9yZSBpbml0aWFsaXphdGlvbiBpcyBmaW5pc2hlZFwiLCBcIndhcm5cIik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5jdXJyZW50QmxvY2sgPSB0aGlzLmhvdmVyZWRCbG9jaywgdGhpcy50b29sYm94SW5zdGFuY2Uub3BlbigpO1xuICAgICAgfSxcbiAgICAgIHRvZ2dsZTogKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy50b29sYm94SW5zdGFuY2UgPT09IG51bGwpIHtcbiAgICAgICAgICBJKFwidG9vbGJveC50b2dnbGUoKSBjYWxsZWQgYmVmb3JlIGluaXRpYWxpemF0aW9uIGlzIGZpbmlzaGVkXCIsIFwid2FyblwiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b29sYm94SW5zdGFuY2UudG9nZ2xlKCk7XG4gICAgICB9LFxuICAgICAgaGFzRm9jdXM6ICgpID0+IHtcbiAgICAgICAgdmFyIHQ7XG4gICAgICAgIHJldHVybiAodCA9IHRoaXMudG9vbGJveEluc3RhbmNlKSA9PSBudWxsID8gdm9pZCAwIDogdC5oYXNGb2N1cygpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEJsb2NrIGFjdGlvbnMgYXBwZWFyYW5jZSBtYW5pcHVsYXRpb25zXG4gICAqL1xuICBnZXQgYmxvY2tBY3Rpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBoaWRlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMubm9kZXMuYWN0aW9ucy5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuQ1NTLmFjdGlvbnNPcGVuZWQpO1xuICAgICAgfSxcbiAgICAgIHNob3c6ICgpID0+IHtcbiAgICAgICAgdGhpcy5ub2Rlcy5hY3Rpb25zLmNsYXNzTGlzdC5hZGQodGhpcy5DU1MuYWN0aW9uc09wZW5lZCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogTWV0aG9kcyBmb3Igd29ya2luZyB3aXRoIEJsb2NrIFR1bmVzIHRvZ2dsZXJcbiAgICovXG4gIGdldCBibG9ja1R1bmVzVG9nZ2xlcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaGlkZTogKCkgPT4gdGhpcy5ub2Rlcy5zZXR0aW5nc1RvZ2dsZXIuY2xhc3NMaXN0LmFkZCh0aGlzLkNTUy5zZXR0aW5nc1RvZ2dsZXJIaWRkZW4pLFxuICAgICAgc2hvdzogKCkgPT4gdGhpcy5ub2Rlcy5zZXR0aW5nc1RvZ2dsZXIuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLkNTUy5zZXR0aW5nc1RvZ2dsZXJIaWRkZW4pXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogVG9nZ2xlcyByZWFkLW9ubHkgbW9kZVxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlYWRPbmx5RW5hYmxlZCAtIHJlYWQtb25seSBtb2RlXG4gICAqL1xuICB0b2dnbGVSZWFkT25seShlKSB7XG4gICAgZSA/ICh0aGlzLmRlc3Ryb3koKSwgdGhpcy5FZGl0b3IuQmxvY2tTZXR0aW5ncy5kZXN0cm95KCksIHRoaXMuZGlzYWJsZU1vZHVsZUJpbmRpbmdzKCkpIDogd2luZG93LnJlcXVlc3RJZGxlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgdGhpcy5kcmF3VUkoKSwgdGhpcy5lbmFibGVNb2R1bGVCaW5kaW5ncygpO1xuICAgIH0sIHsgdGltZW91dDogMmUzIH0pO1xuICB9XG4gIC8qKlxuICAgKiBNb3ZlIFRvb2xiYXIgdG8gdGhlIHBhc3NlZCAob3IgY3VycmVudCkgQmxvY2tcbiAgICpcbiAgICogQHBhcmFtIGJsb2NrIC0gYmxvY2sgdG8gbW92ZSBUb29sYmFyIG5lYXIgaXRcbiAgICovXG4gIG1vdmVBbmRPcGVuKGUgPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY3VycmVudEJsb2NrKSB7XG4gICAgaWYgKHRoaXMudG9vbGJveEluc3RhbmNlID09PSBudWxsKSB7XG4gICAgICBJKFwiQ2FuJ3Qgb3BlbiBUb29sYmFyIHNpbmNlIEVkaXRvciBpbml0aWFsaXphdGlvbiBpcyBub3QgZmluaXNoZWQgeWV0XCIsIFwid2FyblwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMudG9vbGJveEluc3RhbmNlLm9wZW5lZCAmJiB0aGlzLnRvb2xib3hJbnN0YW5jZS5jbG9zZSgpLCB0aGlzLkVkaXRvci5CbG9ja1NldHRpbmdzLm9wZW5lZCAmJiB0aGlzLkVkaXRvci5CbG9ja1NldHRpbmdzLmNsb3NlKCksICFlKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuaG92ZXJlZEJsb2NrID0gZTtcbiAgICBjb25zdCB0ID0gZS5ob2xkZXIsIHsgaXNNb2JpbGU6IG8gfSA9IHRoaXMuRWRpdG9yLlVJO1xuICAgIGxldCBpO1xuICAgIGNvbnN0IHMgPSAyMCwgciA9IGUuZmlyc3RJbnB1dCwgbCA9IHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGEgPSByICE9PSB2b2lkIDAgPyByLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDogbnVsbCwgYyA9IGEgIT09IG51bGwgPyBhLnRvcCAtIGwudG9wIDogbnVsbCwgdSA9IGMgIT09IG51bGwgPyBjID4gcyA6IHZvaWQgMDtcbiAgICBpZiAobylcbiAgICAgIGkgPSB0Lm9mZnNldFRvcCArIHQub2Zmc2V0SGVpZ2h0O1xuICAgIGVsc2UgaWYgKHIgPT09IHZvaWQgMCB8fCB1KSB7XG4gICAgICBjb25zdCBoID0gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUoZS5wbHVnaW5zQ29udGVudCkucGFkZGluZ1RvcCk7XG4gICAgICBpID0gdC5vZmZzZXRUb3AgKyBoO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBoID0gX28ociksIHAgPSBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLm5vZGVzLnBsdXNCdXR0b24pLmhlaWdodCwgMTApLCBnID0gODtcbiAgICAgIGkgPSB0Lm9mZnNldFRvcCArIGggLSBwICsgZyArIGM7XG4gICAgfVxuICAgIHRoaXMubm9kZXMud3JhcHBlci5zdHlsZS50b3AgPSBgJHtNYXRoLmZsb29yKGkpfXB4YCwgdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmJsb2Nrcy5sZW5ndGggPT09IDEgJiYgZS5pc0VtcHR5ID8gdGhpcy5ibG9ja1R1bmVzVG9nZ2xlci5oaWRlKCkgOiB0aGlzLmJsb2NrVHVuZXNUb2dnbGVyLnNob3coKSwgdGhpcy5vcGVuKCk7XG4gIH1cbiAgLyoqXG4gICAqIENsb3NlIHRoZSBUb29sYmFyXG4gICAqL1xuICBjbG9zZSgpIHtcbiAgICB2YXIgZSwgdDtcbiAgICB0aGlzLkVkaXRvci5SZWFkT25seS5pc0VuYWJsZWQgfHwgKChlID0gdGhpcy5ub2Rlcy53cmFwcGVyKSA9PSBudWxsIHx8IGUuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLkNTUy50b29sYmFyT3BlbmVkKSwgdGhpcy5ibG9ja0FjdGlvbnMuaGlkZSgpLCAodCA9IHRoaXMudG9vbGJveEluc3RhbmNlKSA9PSBudWxsIHx8IHQuY2xvc2UoKSwgdGhpcy5FZGl0b3IuQmxvY2tTZXR0aW5ncy5jbG9zZSgpLCB0aGlzLnJlc2V0KCkpO1xuICB9XG4gIC8qKlxuICAgKiBSZXNldCB0aGUgVG9vbGJhciBwb3NpdGlvbiB0byBwcmV2ZW50IERPTSBoZWlnaHQgZ3Jvd3RoLCBmb3IgZXhhbXBsZSBhZnRlciBibG9ja3MgZGVsZXRpb25cbiAgICovXG4gIHJlc2V0KCkge1xuICAgIHRoaXMubm9kZXMud3JhcHBlci5zdHlsZS50b3AgPSBcInVuc2V0XCI7XG4gIH1cbiAgLyoqXG4gICAqIE9wZW4gVG9vbGJhciB3aXRoIFBsdXMgQnV0dG9uIGFuZCBBY3Rpb25zXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gd2l0aEJsb2NrQWN0aW9ucyAtIGJ5IGRlZmF1bHQsIFRvb2xiYXIgb3BlbnMgd2l0aCBCbG9jayBBY3Rpb25zLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGlzIGZsYWcgYWxsb3dzIHRvIG9wZW4gVG9vbGJhciB3aXRob3V0IEFjdGlvbnMuXG4gICAqL1xuICBvcGVuKGUgPSAhMCkge1xuICAgIHRoaXMubm9kZXMud3JhcHBlci5jbGFzc0xpc3QuYWRkKHRoaXMuQ1NTLnRvb2xiYXJPcGVuZWQpLCBlID8gdGhpcy5ibG9ja0FjdGlvbnMuc2hvdygpIDogdGhpcy5ibG9ja0FjdGlvbnMuaGlkZSgpO1xuICB9XG4gIC8qKlxuICAgKiBEcmF3cyBUb29sYmFyIGVsZW1lbnRzXG4gICAqL1xuICBhc3luYyBtYWtlKCkge1xuICAgIHRoaXMubm9kZXMud3JhcHBlciA9IGQubWFrZShcImRpdlwiLCB0aGlzLkNTUy50b29sYmFyKSwgW1wiY29udGVudFwiLCBcImFjdGlvbnNcIl0uZm9yRWFjaCgocykgPT4ge1xuICAgICAgdGhpcy5ub2Rlc1tzXSA9IGQubWFrZShcImRpdlwiLCB0aGlzLkNTU1tzXSk7XG4gICAgfSksIGQuYXBwZW5kKHRoaXMubm9kZXMud3JhcHBlciwgdGhpcy5ub2Rlcy5jb250ZW50KSwgZC5hcHBlbmQodGhpcy5ub2Rlcy5jb250ZW50LCB0aGlzLm5vZGVzLmFjdGlvbnMpLCB0aGlzLm5vZGVzLnBsdXNCdXR0b24gPSBkLm1ha2UoXCJkaXZcIiwgdGhpcy5DU1MucGx1c0J1dHRvbiwge1xuICAgICAgaW5uZXJIVE1MOiBxb1xuICAgIH0pLCBkLmFwcGVuZCh0aGlzLm5vZGVzLmFjdGlvbnMsIHRoaXMubm9kZXMucGx1c0J1dHRvbiksIHRoaXMucmVhZE9ubHlNdXRhYmxlTGlzdGVuZXJzLm9uKHRoaXMubm9kZXMucGx1c0J1dHRvbiwgXCJjbGlja1wiLCAoKSA9PiB7XG4gICAgICBfZSghMCksIHRoaXMucGx1c0J1dHRvbkNsaWNrZWQoKTtcbiAgICB9LCAhMSk7XG4gICAgY29uc3QgZSA9IGQubWFrZShcImRpdlwiKTtcbiAgICBlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFcudWkoVi51aS50b29sYmFyLnRvb2xib3gsIFwiQWRkXCIpKSksIGUuYXBwZW5kQ2hpbGQoZC5tYWtlKFwiZGl2XCIsIHRoaXMuQ1NTLnBsdXNCdXR0b25TaG9ydGN1dCwge1xuICAgICAgdGV4dENvbnRlbnQ6IFwiL1wiXG4gICAgfSkpLCBOZSh0aGlzLm5vZGVzLnBsdXNCdXR0b24sIGUsIHtcbiAgICAgIGhpZGluZ0RlbGF5OiA0MDBcbiAgICB9KSwgdGhpcy5ub2Rlcy5zZXR0aW5nc1RvZ2dsZXIgPSBkLm1ha2UoXCJzcGFuXCIsIHRoaXMuQ1NTLnNldHRpbmdzVG9nZ2xlciwge1xuICAgICAgaW5uZXJIVE1MOiBWb1xuICAgIH0pLCBkLmFwcGVuZCh0aGlzLm5vZGVzLmFjdGlvbnMsIHRoaXMubm9kZXMuc2V0dGluZ3NUb2dnbGVyKTtcbiAgICBjb25zdCB0ID0gZC5tYWtlKFwiZGl2XCIpLCBvID0gZC50ZXh0KFcudWkoVi51aS5ibG9ja1R1bmVzLnRvZ2dsZXIsIFwiQ2xpY2sgdG8gdHVuZVwiKSksIGkgPSBhd2FpdCBWaShcIlNsYXNoXCIsIFwiL1wiKTtcbiAgICB0LmFwcGVuZENoaWxkKG8pLCB0LmFwcGVuZENoaWxkKGQubWFrZShcImRpdlwiLCB0aGlzLkNTUy5wbHVzQnV0dG9uU2hvcnRjdXQsIHtcbiAgICAgIHRleHRDb250ZW50OiBldChgQ01EICsgJHtpfWApXG4gICAgfSkpLCBOZSh0aGlzLm5vZGVzLnNldHRpbmdzVG9nZ2xlciwgdCwge1xuICAgICAgaGlkaW5nRGVsYXk6IDQwMFxuICAgIH0pLCBkLmFwcGVuZCh0aGlzLm5vZGVzLmFjdGlvbnMsIHRoaXMubWFrZVRvb2xib3goKSksIGQuYXBwZW5kKHRoaXMubm9kZXMuYWN0aW9ucywgdGhpcy5FZGl0b3IuQmxvY2tTZXR0aW5ncy5nZXRFbGVtZW50KCkpLCBkLmFwcGVuZCh0aGlzLkVkaXRvci5VSS5ub2Rlcy53cmFwcGVyLCB0aGlzLm5vZGVzLndyYXBwZXIpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIHRoZSBUb29sYm94IGluc3RhbmNlIGFuZCByZXR1cm4gaXQncyByZW5kZXJlZCBlbGVtZW50XG4gICAqL1xuICBtYWtlVG9vbGJveCgpIHtcbiAgICByZXR1cm4gdGhpcy50b29sYm94SW5zdGFuY2UgPSBuZXcgWGkoe1xuICAgICAgYXBpOiB0aGlzLkVkaXRvci5BUEkubWV0aG9kcyxcbiAgICAgIHRvb2xzOiB0aGlzLkVkaXRvci5Ub29scy5ibG9ja1Rvb2xzLFxuICAgICAgaTE4bkxhYmVsczoge1xuICAgICAgICBmaWx0ZXI6IFcudWkoVi51aS5wb3BvdmVyLCBcIkZpbHRlclwiKSxcbiAgICAgICAgbm90aGluZ0ZvdW5kOiBXLnVpKFYudWkucG9wb3ZlciwgXCJOb3RoaW5nIGZvdW5kXCIpXG4gICAgICB9XG4gICAgfSksIHRoaXMudG9vbGJveEluc3RhbmNlLm9uKENlLk9wZW5lZCwgKCkgPT4ge1xuICAgICAgdGhpcy5FZGl0b3IuVUkubm9kZXMud3JhcHBlci5jbGFzc0xpc3QuYWRkKHRoaXMuQ1NTLm9wZW5lZFRvb2xib3hIb2xkZXJNb2RpZmllcik7XG4gICAgfSksIHRoaXMudG9vbGJveEluc3RhbmNlLm9uKENlLkNsb3NlZCwgKCkgPT4ge1xuICAgICAgdGhpcy5FZGl0b3IuVUkubm9kZXMud3JhcHBlci5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuQ1NTLm9wZW5lZFRvb2xib3hIb2xkZXJNb2RpZmllcik7XG4gICAgfSksIHRoaXMudG9vbGJveEluc3RhbmNlLm9uKENlLkJsb2NrQWRkZWQsICh7IGJsb2NrOiBlIH0pID0+IHtcbiAgICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiB0LCBDYXJldDogbyB9ID0gdGhpcy5FZGl0b3IsIGkgPSB0LmdldEJsb2NrQnlJZChlLmlkKTtcbiAgICAgIGkuaW5wdXRzLmxlbmd0aCA9PT0gMCAmJiAoaSA9PT0gdC5sYXN0QmxvY2sgPyAodC5pbnNlcnRBdEVuZCgpLCBvLnNldFRvQmxvY2sodC5sYXN0QmxvY2spKSA6IG8uc2V0VG9CbG9jayh0Lm5leHRCbG9jaykpO1xuICAgIH0pLCB0aGlzLnRvb2xib3hJbnN0YW5jZS5nZXRFbGVtZW50KCk7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZXIgZm9yIFBsdXMgQnV0dG9uXG4gICAqL1xuICBwbHVzQnV0dG9uQ2xpY2tlZCgpIHtcbiAgICB2YXIgZTtcbiAgICB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY3VycmVudEJsb2NrID0gdGhpcy5ob3ZlcmVkQmxvY2ssIChlID0gdGhpcy50b29sYm94SW5zdGFuY2UpID09IG51bGwgfHwgZS50b2dnbGUoKTtcbiAgfVxuICAvKipcbiAgICogRW5hYmxlIGJpbmRpbmdzXG4gICAqL1xuICBlbmFibGVNb2R1bGVCaW5kaW5ncygpIHtcbiAgICB0aGlzLnJlYWRPbmx5TXV0YWJsZUxpc3RlbmVycy5vbih0aGlzLm5vZGVzLnNldHRpbmdzVG9nZ2xlciwgXCJtb3VzZWRvd25cIiwgKGUpID0+IHtcbiAgICAgIHZhciB0O1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKSwgdGhpcy5zZXR0aW5nc1RvZ2dsZXJDbGlja2VkKCksICh0ID0gdGhpcy50b29sYm94SW5zdGFuY2UpICE9IG51bGwgJiYgdC5vcGVuZWQgJiYgdGhpcy50b29sYm94SW5zdGFuY2UuY2xvc2UoKSwgX2UoITApO1xuICAgIH0sICEwKSwgdWUoKSB8fCB0aGlzLmV2ZW50c0Rpc3BhdGNoZXIub24ob28sIChlKSA9PiB7XG4gICAgICB2YXIgdDtcbiAgICAgIHRoaXMuRWRpdG9yLkJsb2NrU2V0dGluZ3Mub3BlbmVkIHx8ICh0ID0gdGhpcy50b29sYm94SW5zdGFuY2UpICE9IG51bGwgJiYgdC5vcGVuZWQgfHwgdGhpcy5tb3ZlQW5kT3BlbihlLmJsb2NrKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRGlzYWJsZSBiaW5kaW5nc1xuICAgKi9cbiAgZGlzYWJsZU1vZHVsZUJpbmRpbmdzKCkge1xuICAgIHRoaXMucmVhZE9ubHlNdXRhYmxlTGlzdGVuZXJzLmNsZWFyQWxsKCk7XG4gIH1cbiAgLyoqXG4gICAqIENsaWNrcyBvbiB0aGUgQmxvY2sgU2V0dGluZ3MgdG9nZ2xlclxuICAgKi9cbiAgc2V0dGluZ3NUb2dnbGVyQ2xpY2tlZCgpIHtcbiAgICB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY3VycmVudEJsb2NrID0gdGhpcy5ob3ZlcmVkQmxvY2ssIHRoaXMuRWRpdG9yLkJsb2NrU2V0dGluZ3Mub3BlbmVkID8gdGhpcy5FZGl0b3IuQmxvY2tTZXR0aW5ncy5jbG9zZSgpIDogdGhpcy5FZGl0b3IuQmxvY2tTZXR0aW5ncy5vcGVuKHRoaXMuaG92ZXJlZEJsb2NrKTtcbiAgfVxuICAvKipcbiAgICogRHJhd3MgVG9vbGJhciBVSVxuICAgKlxuICAgKiBUb29sYmFyIGNvbnRhaW5zIEJsb2NrU2V0dGluZ3MgYW5kIFRvb2xib3guXG4gICAqIFRoYXQncyB3aHkgYXQgZmlyc3Qgd2UgZHJhdyBpdHMgY29tcG9uZW50cyBhbmQgdGhlbiBUb29sYmFyIGl0c2VsZlxuICAgKlxuICAgKiBTdGVwczpcbiAgICogIC0gTWFrZSBUb29sYmFyIGRlcGVuZGVudCBjb21wb25lbnRzIGxpa2UgQmxvY2tTZXR0aW5ncywgVG9vbGJveCBhbmQgc28gb25cbiAgICogIC0gTWFrZSBpdHNlbGYgYW5kIGFwcGVuZCBkZXBlbmRlbnQgbm9kZXMgdG8gaXRzZWxmXG4gICAqXG4gICAqL1xuICBkcmF3VUkoKSB7XG4gICAgdGhpcy5FZGl0b3IuQmxvY2tTZXR0aW5ncy5tYWtlKCksIHRoaXMubWFrZSgpO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCBjcmVhdGVkIGFuZCBzYXZlZCBIVE1MRWxlbWVudHNcbiAgICogSXQgaXMgdXNlZCBpbiBSZWFkLU9ubHkgbW9kZVxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnJlbW92ZUFsbE5vZGVzKCksIHRoaXMudG9vbGJveEluc3RhbmNlICYmIHRoaXMudG9vbGJveEluc3RhbmNlLmRlc3Ryb3koKTtcbiAgfVxufVxudmFyIEZlID0gLyogQF9fUFVSRV9fICovICgobikgPT4gKG5bbi5CbG9jayA9IDBdID0gXCJCbG9ja1wiLCBuW24uSW5saW5lID0gMV0gPSBcIklubGluZVwiLCBuW24uVHVuZSA9IDJdID0gXCJUdW5lXCIsIG4pKShGZSB8fCB7fSksIFNlID0gLyogQF9fUFVSRV9fICovICgobikgPT4gKG4uU2hvcnRjdXQgPSBcInNob3J0Y3V0XCIsIG4uVG9vbGJveCA9IFwidG9vbGJveFwiLCBuLkVuYWJsZWRJbmxpbmVUb29scyA9IFwiaW5saW5lVG9vbGJhclwiLCBuLkVuYWJsZWRCbG9ja1R1bmVzID0gXCJ0dW5lc1wiLCBuLkNvbmZpZyA9IFwiY29uZmlnXCIsIG4pKShTZSB8fCB7fSksIGlvID0gLyogQF9fUFVSRV9fICovICgobikgPT4gKG4uU2hvcnRjdXQgPSBcInNob3J0Y3V0XCIsIG4uU2FuaXRpemVDb25maWcgPSBcInNhbml0aXplXCIsIG4pKShpbyB8fCB7fSksIGFlID0gLyogQF9fUFVSRV9fICovICgobikgPT4gKG4uSXNFbmFibGVkTGluZUJyZWFrcyA9IFwiZW5hYmxlTGluZUJyZWFrc1wiLCBuLlRvb2xib3ggPSBcInRvb2xib3hcIiwgbi5Db252ZXJzaW9uQ29uZmlnID0gXCJjb252ZXJzaW9uQ29uZmlnXCIsIG4uSXNSZWFkT25seVN1cHBvcnRlZCA9IFwiaXNSZWFkT25seVN1cHBvcnRlZFwiLCBuLlBhc3RlQ29uZmlnID0gXCJwYXN0ZUNvbmZpZ1wiLCBuKSkoYWUgfHwge30pLCBhdCA9IC8qIEBfX1BVUkVfXyAqLyAoKG4pID0+IChuLklzSW5saW5lID0gXCJpc0lubGluZVwiLCBuLlRpdGxlID0gXCJ0aXRsZVwiLCBuKSkoYXQgfHwge30pLCBRZSA9IC8qIEBfX1BVUkVfXyAqLyAoKG4pID0+IChuLklzVHVuZSA9IFwiaXNUdW5lXCIsIG4pKShRZSB8fCB7fSk7XG5jbGFzcyBjdCB7XG4gIC8qKlxuICAgKiBAY2xhc3NcbiAgICogQHBhcmFtIHtDb25zdHJ1Y3Rvck9wdGlvbnN9IG9wdGlvbnMgLSBDb25zdHJ1Y3RvciBvcHRpb25zXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbmFtZTogZSxcbiAgICBjb25zdHJ1Y3RhYmxlOiB0LFxuICAgIGNvbmZpZzogbyxcbiAgICBhcGk6IGksXG4gICAgaXNEZWZhdWx0OiBzLFxuICAgIGlzSW50ZXJuYWw6IHIgPSAhMSxcbiAgICBkZWZhdWx0UGxhY2Vob2xkZXI6IGxcbiAgfSkge1xuICAgIHRoaXMuYXBpID0gaSwgdGhpcy5uYW1lID0gZSwgdGhpcy5jb25zdHJ1Y3RhYmxlID0gdCwgdGhpcy5jb25maWcgPSBvLCB0aGlzLmlzRGVmYXVsdCA9IHMsIHRoaXMuaXNJbnRlcm5hbCA9IHIsIHRoaXMuZGVmYXVsdFBsYWNlaG9sZGVyID0gbDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBUb29sIHVzZXIgY29uZmlndXJhdGlvblxuICAgKi9cbiAgZ2V0IHNldHRpbmdzKCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmNvbmZpZy5jb25maWcgfHwge307XG4gICAgcmV0dXJuIHRoaXMuaXNEZWZhdWx0ICYmICEoXCJwbGFjZWhvbGRlclwiIGluIGUpICYmIHRoaXMuZGVmYXVsdFBsYWNlaG9sZGVyICYmIChlLnBsYWNlaG9sZGVyID0gdGhpcy5kZWZhdWx0UGxhY2Vob2xkZXIpLCBlO1xuICB9XG4gIC8qKlxuICAgKiBDYWxscyBUb29sJ3MgcmVzZXQgbWV0aG9kXG4gICAqL1xuICByZXNldCgpIHtcbiAgICBpZiAoTyh0aGlzLmNvbnN0cnVjdGFibGUucmVzZXQpKVxuICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0YWJsZS5yZXNldCgpO1xuICB9XG4gIC8qKlxuICAgKiBDYWxscyBUb29sJ3MgcHJlcGFyZSBtZXRob2RcbiAgICovXG4gIHByZXBhcmUoKSB7XG4gICAgaWYgKE8odGhpcy5jb25zdHJ1Y3RhYmxlLnByZXBhcmUpKVxuICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0YWJsZS5wcmVwYXJlKHtcbiAgICAgICAgdG9vbE5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgY29uZmlnOiB0aGlzLnNldHRpbmdzXG4gICAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBzaG9ydGN1dCBmb3IgVG9vbCAoaW50ZXJuYWwgb3Igc3BlY2lmaWVkIGJ5IHVzZXIpXG4gICAqL1xuICBnZXQgc2hvcnRjdXQoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuY29uc3RydWN0YWJsZS5zaG9ydGN1dDtcbiAgICByZXR1cm4gdGhpcy5jb25maWcuc2hvcnRjdXQgfHwgZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBUb29sJ3Mgc2FuaXRpemVyIGNvbmZpZ3VyYXRpb25cbiAgICovXG4gIGdldCBzYW5pdGl6ZUNvbmZpZygpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3RhYmxlLnNhbml0aXplIHx8IHt9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgVG9vbHMgaXMgaW5saW5lXG4gICAqL1xuICBpc0lubGluZSgpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlID09PSAxO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgVG9vbHMgaXMgYmxvY2tcbiAgICovXG4gIGlzQmxvY2soKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gMDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIFRvb2xzIGlzIHR1bmVcbiAgICovXG4gIGlzVHVuZSgpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlID09PSAyO1xuICB9XG59XG5jbGFzcyBaaSBleHRlbmRzIHkge1xuICAvKipcbiAgICogQHBhcmFtIG1vZHVsZUNvbmZpZ3VyYXRpb24gLSBNb2R1bGUgQ29uZmlndXJhdGlvblxuICAgKiBAcGFyYW0gbW9kdWxlQ29uZmlndXJhdGlvbi5jb25maWcgLSBFZGl0b3IncyBjb25maWdcbiAgICogQHBhcmFtIG1vZHVsZUNvbmZpZ3VyYXRpb24uZXZlbnRzRGlzcGF0Y2hlciAtIEVkaXRvcidzIGV2ZW50IGRpc3BhdGNoZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgY29uZmlnOiBlLCBldmVudHNEaXNwYXRjaGVyOiB0IH0pIHtcbiAgICBzdXBlcih7XG4gICAgICBjb25maWc6IGUsXG4gICAgICBldmVudHNEaXNwYXRjaGVyOiB0XG4gICAgfSksIHRoaXMuQ1NTID0ge1xuICAgICAgaW5saW5lVG9vbGJhcjogXCJjZS1pbmxpbmUtdG9vbGJhclwiXG4gICAgfSwgdGhpcy5vcGVuZWQgPSAhMSwgdGhpcy5wb3BvdmVyID0gbnVsbCwgdGhpcy50b29sYmFyVmVydGljYWxNYXJnaW4gPSB1ZSgpID8gMjAgOiA2LCB0aGlzLnRvb2xzSW5zdGFuY2VzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICAvKipcbiAgICogVG9nZ2xlcyByZWFkLW9ubHkgbW9kZVxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlYWRPbmx5RW5hYmxlZCAtIHJlYWQtb25seSBtb2RlXG4gICAqL1xuICB0b2dnbGVSZWFkT25seShlKSB7XG4gICAgZSA/IHRoaXMuZGVzdHJveSgpIDogd2luZG93LnJlcXVlc3RJZGxlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgdGhpcy5tYWtlKCk7XG4gICAgfSwgeyB0aW1lb3V0OiAyZTMgfSk7XG4gIH1cbiAgLyoqXG4gICAqICBNb3ZpbmcgLyBhcHBlYXJhbmNlXG4gICAqICB+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+XG4gICAqL1xuICAvKipcbiAgICogU2hvd3MgSW5saW5lIFRvb2xiYXIgaWYgc29tZXRoaW5nIGlzIHNlbGVjdGVkXG4gICAqXG4gICAqIEBwYXJhbSBbbmVlZFRvQ2xvc2VdIC0gcGFzcyB0cnVlIHRvIGNsb3NlIHRvb2xiYXIgaWYgaXQgaXMgbm90IGFsbG93ZWQuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEF2b2lkIHRvIHVzZSBpdCBqdXN0IGZvciBjbG9zaW5nIElULCBiZXR0ZXIgY2FsbCAuY2xvc2UoKSBjbGVhcmx5LlxuICAgKi9cbiAgYXN5bmMgdHJ5VG9TaG93KGUgPSAhMSkge1xuICAgIGUgJiYgdGhpcy5jbG9zZSgpLCB0aGlzLmFsbG93ZWRUb1Nob3coKSAmJiAoYXdhaXQgdGhpcy5vcGVuKCksIHRoaXMuRWRpdG9yLlRvb2xiYXIuY2xvc2UoKSk7XG4gIH1cbiAgLyoqXG4gICAqIEhpZGVzIElubGluZSBUb29sYmFyXG4gICAqL1xuICBjbG9zZSgpIHtcbiAgICB2YXIgZSwgdDtcbiAgICB0aGlzLm9wZW5lZCAmJiAodGhpcy5FZGl0b3IuUmVhZE9ubHkuaXNFbmFibGVkIHx8IChBcnJheS5mcm9tKHRoaXMudG9vbHNJbnN0YW5jZXMuZW50cmllcygpKS5mb3JFYWNoKChbbywgaV0pID0+IHtcbiAgICAgIGNvbnN0IHMgPSB0aGlzLmdldFRvb2xTaG9ydGN1dChvKTtcbiAgICAgIHMgJiYgZGUucmVtb3ZlKHRoaXMuRWRpdG9yLlVJLm5vZGVzLnJlZGFjdG9yLCBzKSwgTyhpLmNsZWFyKSAmJiBpLmNsZWFyKCk7XG4gICAgfSksIHRoaXMudG9vbHNJbnN0YW5jZXMgPSBudWxsLCB0aGlzLnJlc2V0KCksIHRoaXMub3BlbmVkID0gITEsIChlID0gdGhpcy5wb3BvdmVyKSA9PSBudWxsIHx8IGUuaGlkZSgpLCAodCA9IHRoaXMucG9wb3ZlcikgPT0gbnVsbCB8fCB0LmRlc3Ryb3koKSwgdGhpcy5wb3BvdmVyID0gbnVsbCkpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBub2RlIGlzIGNvbnRhaW5lZCBieSBJbmxpbmUgVG9vbGJhclxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGUg4oCUIG5vZGUgdG8gY2hlY2tcbiAgICovXG4gIGNvbnRhaW5zTm9kZShlKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMud3JhcHBlciA9PT0gdm9pZCAwID8gITEgOiB0aGlzLm5vZGVzLndyYXBwZXIuY29udGFpbnMoZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgVUkgYW5kIGl0cyBjb21wb25lbnRzXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHZhciBlO1xuICAgIHRoaXMucmVtb3ZlQWxsTm9kZXMoKSwgKGUgPSB0aGlzLnBvcG92ZXIpID09IG51bGwgfHwgZS5kZXN0cm95KCksIHRoaXMucG9wb3ZlciA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIE1ha2luZyBET01cbiAgICovXG4gIG1ha2UoKSB7XG4gICAgdGhpcy5ub2Rlcy53cmFwcGVyID0gZC5tYWtlKFwiZGl2XCIsIFtcbiAgICAgIHRoaXMuQ1NTLmlubGluZVRvb2xiYXIsXG4gICAgICAuLi50aGlzLmlzUnRsID8gW3RoaXMuRWRpdG9yLlVJLkNTUy5lZGl0b3JSdGxGaXhdIDogW11cbiAgICBdKSwgZC5hcHBlbmQodGhpcy5FZGl0b3IuVUkubm9kZXMud3JhcHBlciwgdGhpcy5ub2Rlcy53cmFwcGVyKTtcbiAgfVxuICAvKipcbiAgICogU2hvd3MgSW5saW5lIFRvb2xiYXJcbiAgICovXG4gIGFzeW5jIG9wZW4oKSB7XG4gICAgdmFyIHQ7XG4gICAgaWYgKHRoaXMub3BlbmVkKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMub3BlbmVkID0gITAsIHRoaXMucG9wb3ZlciAhPT0gbnVsbCAmJiB0aGlzLnBvcG92ZXIuZGVzdHJveSgpO1xuICAgIGNvbnN0IGUgPSBhd2FpdCB0aGlzLmdldElubGluZVRvb2xzKCk7XG4gICAgdGhpcy5wb3BvdmVyID0gbmV3IGRpKHtcbiAgICAgIGl0ZW1zOiBlLFxuICAgICAgc2NvcGVFbGVtZW50OiB0aGlzLkVkaXRvci5BUEkubWV0aG9kcy51aS5ub2Rlcy5yZWRhY3RvcixcbiAgICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgIG5vdGhpbmdGb3VuZDogVy51aShWLnVpLnBvcG92ZXIsIFwiTm90aGluZyBmb3VuZFwiKSxcbiAgICAgICAgc2VhcmNoOiBXLnVpKFYudWkucG9wb3ZlciwgXCJGaWx0ZXJcIilcbiAgICAgIH1cbiAgICB9KSwgdGhpcy5tb3ZlKHRoaXMucG9wb3Zlci5zaXplLndpZHRoKSwgKHQgPSB0aGlzLm5vZGVzLndyYXBwZXIpID09IG51bGwgfHwgdC5hcHBlbmQodGhpcy5wb3BvdmVyLmdldEVsZW1lbnQoKSksIHRoaXMucG9wb3Zlci5zaG93KCk7XG4gIH1cbiAgLyoqXG4gICAqIE1vdmUgVG9vbGJhciB0byB0aGUgc2VsZWN0ZWQgdGV4dFxuICAgKlxuICAgKiBAcGFyYW0gcG9wb3ZlcldpZHRoIC0gd2lkdGggb2YgdGhlIHRvb2xiYXIgcG9wb3ZlclxuICAgKi9cbiAgbW92ZShlKSB7XG4gICAgY29uc3QgdCA9IGIucmVjdCwgbyA9IHRoaXMuRWRpdG9yLlVJLm5vZGVzLndyYXBwZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGkgPSB7XG4gICAgICB4OiB0LnggLSBvLngsXG4gICAgICB5OiB0LnkgKyB0LmhlaWdodCAtIC8vICsgd2luZG93LnNjcm9sbFlcbiAgICAgIG8udG9wICsgdGhpcy50b29sYmFyVmVydGljYWxNYXJnaW5cbiAgICB9O1xuICAgIGkueCArIGUgKyBvLnggPiB0aGlzLkVkaXRvci5VSS5jb250ZW50UmVjdC5yaWdodCAmJiAoaS54ID0gdGhpcy5FZGl0b3IuVUkuY29udGVudFJlY3QucmlnaHQgLSBlIC0gby54KSwgdGhpcy5ub2Rlcy53cmFwcGVyLnN0eWxlLmxlZnQgPSBNYXRoLmZsb29yKGkueCkgKyBcInB4XCIsIHRoaXMubm9kZXMud3JhcHBlci5zdHlsZS50b3AgPSBNYXRoLmZsb29yKGkueSkgKyBcInB4XCI7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFyIG9yaWVudGF0aW9uIGNsYXNzZXMgYW5kIHJlc2V0IHBvc2l0aW9uXG4gICAqL1xuICByZXNldCgpIHtcbiAgICB0aGlzLm5vZGVzLndyYXBwZXIuc3R5bGUubGVmdCA9IFwiMFwiLCB0aGlzLm5vZGVzLndyYXBwZXIuc3R5bGUudG9wID0gXCIwXCI7XG4gIH1cbiAgLyoqXG4gICAqIE5lZWQgdG8gc2hvdyBJbmxpbmUgVG9vbGJhciBvciBub3RcbiAgICovXG4gIGFsbG93ZWRUb1Nob3coKSB7XG4gICAgY29uc3QgZSA9IFtcIklNR1wiLCBcIklOUFVUXCJdLCB0ID0gYi5nZXQoKSwgbyA9IGIudGV4dDtcbiAgICBpZiAoIXQgfHwgIXQuYW5jaG9yTm9kZSB8fCB0LmlzQ29sbGFwc2VkIHx8IG8ubGVuZ3RoIDwgMSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBpID0gZC5pc0VsZW1lbnQodC5hbmNob3JOb2RlKSA/IHQuYW5jaG9yTm9kZSA6IHQuYW5jaG9yTm9kZS5wYXJlbnRFbGVtZW50O1xuICAgIGlmIChpID09PSBudWxsIHx8IHQgJiYgZS5pbmNsdWRlcyhpLnRhZ05hbWUpIHx8IGkuY2xvc2VzdCgnW2NvbnRlbnRlZGl0YWJsZT1cInRydWVcIl0nKSA9PT0gbnVsbClcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCByID0gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmdldEJsb2NrKHQuYW5jaG9yTm9kZSk7XG4gICAgcmV0dXJuIHIgPyByLnRvb2wuaW5saW5lVG9vbHMuc2l6ZSAhPT0gMCA6ICExO1xuICB9XG4gIC8qKlxuICAgKiAgV29ya2luZyB3aXRoIFRvb2xzXG4gICAqICB+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+XG4gICAqL1xuICAvKipcbiAgICogUmV0dXJucyBJbmxpbmUgVG9vbHMgc2VncmVnYXRlZCBieSB0aGVpciBhcHBlYXJhbmNlIHR5cGU6IHBvcG92ZXIgaXRlbXMgYW5kIGN1c3RvbSBodG1sIGVsZW1lbnRzLlxuICAgKiBTZXRzIHRoaXMudG9vbHNJbnN0YW5jZXMgbWFwXG4gICAqL1xuICBhc3luYyBnZXRJbmxpbmVUb29scygpIHtcbiAgICBjb25zdCBlID0gYi5nZXQoKSwgdCA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5nZXRCbG9jayhlLmFuY2hvck5vZGUpLCBvID0gQXJyYXkuZnJvbSh0LnRvb2wuaW5saW5lVG9vbHMudmFsdWVzKCkpLCBpID0gW107XG4gICAgdGhpcy50b29sc0luc3RhbmNlcyA9PT0gbnVsbCAmJiAodGhpcy50b29sc0luc3RhbmNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgIGZvciAobGV0IHMgPSAwOyBzIDwgby5sZW5ndGg7IHMrKykge1xuICAgICAgY29uc3QgciA9IG9bc10sIGwgPSByLmNyZWF0ZSgpLCBhID0gYXdhaXQgbC5yZW5kZXIoKTtcbiAgICAgIHRoaXMudG9vbHNJbnN0YW5jZXMuc2V0KHIubmFtZSwgbCk7XG4gICAgICBjb25zdCBjID0gdGhpcy5nZXRUb29sU2hvcnRjdXQoci5uYW1lKTtcbiAgICAgIGlmIChjKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuZW5hYmxlU2hvcnRjdXRzKHIubmFtZSwgYyk7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICB9XG4gICAgICBjb25zdCB1ID0gYyAhPT0gdm9pZCAwID8gZXQoYykgOiB2b2lkIDAsIGggPSBXLnQoXG4gICAgICAgIFYudG9vbE5hbWVzLFxuICAgICAgICByLnRpdGxlIHx8IE9lKHIubmFtZSlcbiAgICAgICk7XG4gICAgICBbYV0uZmxhdCgpLmZvckVhY2goKHApID0+IHtcbiAgICAgICAgdmFyIGYsIGs7XG4gICAgICAgIGNvbnN0IGcgPSB7XG4gICAgICAgICAgbmFtZTogci5uYW1lLFxuICAgICAgICAgIG9uQWN0aXZhdGU6ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudG9vbENsaWNrZWQobCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBoaW50OiB7XG4gICAgICAgICAgICB0aXRsZTogaCxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiB1XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoZC5pc0VsZW1lbnQocCkpIHtcbiAgICAgICAgICBjb25zdCBDID0ge1xuICAgICAgICAgICAgLi4uZyxcbiAgICAgICAgICAgIGVsZW1lbnQ6IHAsXG4gICAgICAgICAgICB0eXBlOiBBLkh0bWxcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChPKGwucmVuZGVyQWN0aW9ucykpIHtcbiAgICAgICAgICAgIGNvbnN0IFMgPSBsLnJlbmRlckFjdGlvbnMoKTtcbiAgICAgICAgICAgIEMuY2hpbGRyZW4gPSB7XG4gICAgICAgICAgICAgIGlzT3BlbjogKGYgPSBsLmNoZWNrU3RhdGUpID09IG51bGwgPyB2b2lkIDAgOiBmLmNhbGwobCwgYi5nZXQoKSksXG4gICAgICAgICAgICAgIC8qKiBEaXNhYmxlIGtleWJvYXJkIG5hdmlnYXRpb24gaW4gYWN0aW9ucywgYXMgaXQgbWlnaHQgY29uZmxpY3Qgd2l0aCBlbnRlciBwcmVzcyBoYW5kbGluZyAqL1xuICAgICAgICAgICAgICBpc0ZsaXBwYWJsZTogITEsXG4gICAgICAgICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdHlwZTogQS5IdG1sLFxuICAgICAgICAgICAgICAgICAgZWxlbWVudDogU1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIChrID0gbC5jaGVja1N0YXRlKSA9PSBudWxsIHx8IGsuY2FsbChsLCBiLmdldCgpKTtcbiAgICAgICAgICBpLnB1c2goQyk7XG4gICAgICAgIH0gZWxzZSBpZiAocC50eXBlID09PSBBLkh0bWwpXG4gICAgICAgICAgaS5wdXNoKHtcbiAgICAgICAgICAgIC4uLmcsXG4gICAgICAgICAgICAuLi5wLFxuICAgICAgICAgICAgdHlwZTogQS5IdG1sXG4gICAgICAgICAgfSk7XG4gICAgICAgIGVsc2UgaWYgKHAudHlwZSA9PT0gQS5TZXBhcmF0b3IpXG4gICAgICAgICAgaS5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IEEuU2VwYXJhdG9yXG4gICAgICAgICAgfSk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGNvbnN0IEMgPSB7XG4gICAgICAgICAgICAuLi5nLFxuICAgICAgICAgICAgLi4ucCxcbiAgICAgICAgICAgIHR5cGU6IEEuRGVmYXVsdFxuICAgICAgICAgIH07XG4gICAgICAgICAgXCJjaGlsZHJlblwiIGluIEMgJiYgcyAhPT0gMCAmJiBpLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogQS5TZXBhcmF0b3JcbiAgICAgICAgICB9KSwgaS5wdXNoKEMpLCBcImNoaWxkcmVuXCIgaW4gQyAmJiBzIDwgby5sZW5ndGggLSAxICYmIGkucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiBBLlNlcGFyYXRvclxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBzaG9ydGN1dCBuYW1lIGZvciB0b29sXG4gICAqXG4gICAqIEBwYXJhbSB0b29sTmFtZSDigJQgVG9vbCBuYW1lXG4gICAqL1xuICBnZXRUb29sU2hvcnRjdXQoZSkge1xuICAgIGNvbnN0IHsgVG9vbHM6IHQgfSA9IHRoaXMuRWRpdG9yLCBvID0gdC5pbmxpbmVUb29scy5nZXQoZSksIGkgPSB0LmludGVybmFsLmlubGluZVRvb2xzO1xuICAgIHJldHVybiBBcnJheS5mcm9tKGkua2V5cygpKS5pbmNsdWRlcyhlKSA/IHRoaXMuaW5saW5lVG9vbHNbZV1baW8uU2hvcnRjdXRdIDogbyA9PSBudWxsID8gdm9pZCAwIDogby5zaG9ydGN1dDtcbiAgfVxuICAvKipcbiAgICogRW5hYmxlIFRvb2wgc2hvcnRjdXQgd2l0aCBFZGl0b3IgU2hvcnRjdXRzIE1vZHVsZVxuICAgKlxuICAgKiBAcGFyYW0gdG9vbE5hbWUgLSB0b29sIG5hbWVcbiAgICogQHBhcmFtIHNob3J0Y3V0IC0gc2hvcnRjdXQgYWNjb3JkaW5nIHRvIHRoZSBTaG9ydGN1dERhdGEgTW9kdWxlIGZvcm1hdFxuICAgKi9cbiAgZW5hYmxlU2hvcnRjdXRzKGUsIHQpIHtcbiAgICBkZS5hZGQoe1xuICAgICAgbmFtZTogdCxcbiAgICAgIGhhbmRsZXI6IChvKSA9PiB7XG4gICAgICAgIHZhciBzO1xuICAgICAgICBjb25zdCB7IGN1cnJlbnRCbG9jazogaSB9ID0gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyO1xuICAgICAgICBpICYmIGkudG9vbC5lbmFibGVkSW5saW5lVG9vbHMgJiYgKG8ucHJldmVudERlZmF1bHQoKSwgKHMgPSB0aGlzLnBvcG92ZXIpID09IG51bGwgfHwgcy5hY3RpdmF0ZUl0ZW1CeU5hbWUoZSkpO1xuICAgICAgfSxcbiAgICAgIG9uOiB0aGlzLkVkaXRvci5VSS5ub2Rlcy5yZWRhY3RvclxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBJbmxpbmUgVG9vbCBidXR0b24gY2xpY2tzXG4gICAqXG4gICAqIEBwYXJhbSB0b29sIC0gVG9vbCdzIGluc3RhbmNlXG4gICAqL1xuICB0b29sQ2xpY2tlZChlKSB7XG4gICAgdmFyIG87XG4gICAgY29uc3QgdCA9IGIucmFuZ2U7XG4gICAgKG8gPSBlLnN1cnJvdW5kKSA9PSBudWxsIHx8IG8uY2FsbChlLCB0KSwgdGhpcy5jaGVja1Rvb2xzU3RhdGUoKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgVG9vbHNgIHN0YXRlIGJ5IHNlbGVjdGlvblxuICAgKi9cbiAgY2hlY2tUb29sc1N0YXRlKCkge1xuICAgIHZhciBlO1xuICAgIChlID0gdGhpcy50b29sc0luc3RhbmNlcykgPT0gbnVsbCB8fCBlLmZvckVhY2goKHQpID0+IHtcbiAgICAgIHZhciBvO1xuICAgICAgKG8gPSB0LmNoZWNrU3RhdGUpID09IG51bGwgfHwgby5jYWxsKHQsIGIuZ2V0KCkpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgaW5saW5lIHRvb2xzIHRvb2xzXG4gICAqIFRvb2xzIHRoYXQgaGFzIGlzSW5saW5lIGlzIHRydWVcbiAgICovXG4gIGdldCBpbmxpbmVUb29scygpIHtcbiAgICBjb25zdCBlID0ge307XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5FZGl0b3IuVG9vbHMuaW5saW5lVG9vbHMuZW50cmllcygpKS5mb3JFYWNoKChbdCwgb10pID0+IHtcbiAgICAgIGVbdF0gPSBvLmNyZWF0ZSgpO1xuICAgIH0pLCBlO1xuICB9XG59XG5mdW5jdGlvbiBzbygpIHtcbiAgY29uc3QgbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgaWYgKG4gPT09IG51bGwpXG4gICAgcmV0dXJuIFtudWxsLCAwXTtcbiAgbGV0IGUgPSBuLmZvY3VzTm9kZSwgdCA9IG4uZm9jdXNPZmZzZXQ7XG4gIHJldHVybiBlID09PSBudWxsID8gW251bGwsIDBdIDogKGUubm9kZVR5cGUgIT09IE5vZGUuVEVYVF9OT0RFICYmIGUuY2hpbGROb2Rlcy5sZW5ndGggPiAwICYmIChlLmNoaWxkTm9kZXNbdF0gPyAoZSA9IGUuY2hpbGROb2Rlc1t0XSwgdCA9IDApIDogKGUgPSBlLmNoaWxkTm9kZXNbdCAtIDFdLCB0ID0gZS50ZXh0Q29udGVudC5sZW5ndGgpKSwgW2UsIHRdKTtcbn1cbmZ1bmN0aW9uIG5vKG4sIGUsIHQsIG8pIHtcbiAgY29uc3QgaSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gIG8gPT09IFwibGVmdFwiID8gKGkuc2V0U3RhcnQobiwgMCksIGkuc2V0RW5kKGUsIHQpKSA6IChpLnNldFN0YXJ0KGUsIHQpLCBpLnNldEVuZChuLCBuLmNoaWxkTm9kZXMubGVuZ3RoKSk7XG4gIGNvbnN0IHMgPSBpLmNsb25lQ29udGVudHMoKSwgciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIHIuYXBwZW5kQ2hpbGQocyk7XG4gIGNvbnN0IGwgPSByLnRleHRDb250ZW50IHx8IFwiXCI7XG4gIHJldHVybiBMbyhsKTtcbn1cbmZ1bmN0aW9uIEllKG4pIHtcbiAgY29uc3QgZSA9IGQuZ2V0RGVlcGVzdE5vZGUobik7XG4gIGlmIChlID09PSBudWxsIHx8IGQuaXNFbXB0eShuKSlcbiAgICByZXR1cm4gITA7XG4gIGlmIChkLmlzTmF0aXZlSW5wdXQoZSkpXG4gICAgcmV0dXJuIGUuc2VsZWN0aW9uRW5kID09PSAwO1xuICBpZiAoZC5pc0VtcHR5KG4pKVxuICAgIHJldHVybiAhMDtcbiAgY29uc3QgW3QsIG9dID0gc28oKTtcbiAgcmV0dXJuIHQgPT09IG51bGwgPyAhMSA6IG5vKG4sIHQsIG8sIFwibGVmdFwiKTtcbn1cbmZ1bmN0aW9uIE1lKG4pIHtcbiAgY29uc3QgZSA9IGQuZ2V0RGVlcGVzdE5vZGUobiwgITApO1xuICBpZiAoZSA9PT0gbnVsbClcbiAgICByZXR1cm4gITA7XG4gIGlmIChkLmlzTmF0aXZlSW5wdXQoZSkpXG4gICAgcmV0dXJuIGUuc2VsZWN0aW9uRW5kID09PSBlLnZhbHVlLmxlbmd0aDtcbiAgY29uc3QgW3QsIG9dID0gc28oKTtcbiAgcmV0dXJuIHQgPT09IG51bGwgPyAhMSA6IG5vKG4sIHQsIG8sIFwicmlnaHRcIik7XG59XG5jbGFzcyBHaSBleHRlbmRzIHkge1xuICAvKipcbiAgICogQWxsIGtleWRvd25zIG9uIEJsb2NrXG4gICAqXG4gICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnQgLSBrZXlkb3duXG4gICAqL1xuICBrZXlkb3duKGUpIHtcbiAgICBzd2l0Y2ggKHRoaXMuYmVmb3JlS2V5ZG93blByb2Nlc3NpbmcoZSksIGUua2V5Q29kZSkge1xuICAgICAgY2FzZSB3LkJBQ0tTUEFDRTpcbiAgICAgICAgdGhpcy5iYWNrc3BhY2UoZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB3LkRFTEVURTpcbiAgICAgICAgdGhpcy5kZWxldGUoZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB3LkVOVEVSOlxuICAgICAgICB0aGlzLmVudGVyKGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugdy5ET1dOOlxuICAgICAgY2FzZSB3LlJJR0hUOlxuICAgICAgICB0aGlzLmFycm93UmlnaHRBbmREb3duKGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugdy5VUDpcbiAgICAgIGNhc2Ugdy5MRUZUOlxuICAgICAgICB0aGlzLmFycm93TGVmdEFuZFVwKGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugdy5UQUI6XG4gICAgICAgIHRoaXMudGFiUHJlc3NlZChlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGUua2V5ID09PSBcIi9cIiAmJiAhZS5jdHJsS2V5ICYmICFlLm1ldGFLZXkgJiYgdGhpcy5zbGFzaFByZXNzZWQoZSksIGUuY29kZSA9PT0gXCJTbGFzaFwiICYmIChlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KSAmJiAoZS5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLmNvbW1hbmRTbGFzaFByZXNzZWQoKSk7XG4gIH1cbiAgLyoqXG4gICAqIEZpcmVzIG9uIGtleWRvd24gYmVmb3JlIGV2ZW50IHByb2Nlc3NpbmdcbiAgICpcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudCAtIGtleWRvd25cbiAgICovXG4gIGJlZm9yZUtleWRvd25Qcm9jZXNzaW5nKGUpIHtcbiAgICB0aGlzLm5lZWRUb29sYmFyQ2xvc2luZyhlKSAmJiBJdChlLmtleUNvZGUpICYmICh0aGlzLkVkaXRvci5Ub29sYmFyLmNsb3NlKCksIGUuY3RybEtleSB8fCBlLm1ldGFLZXkgfHwgZS5hbHRLZXkgfHwgZS5zaGlmdEtleSB8fCB0aGlzLkVkaXRvci5CbG9ja1NlbGVjdGlvbi5jbGVhclNlbGVjdGlvbihlKSk7XG4gIH1cbiAgLyoqXG4gICAqIEtleSB1cCBvbiBCbG9jazpcbiAgICogLSBzaG93cyBJbmxpbmUgVG9vbGJhciBpZiBzb21ldGhpbmcgc2VsZWN0ZWRcbiAgICogLSBzaG93cyBjb252ZXJzaW9uIHRvb2xiYXIgd2l0aCA4NSUgb2YgYmxvY2sgc2VsZWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnQgLSBrZXl1cCBldmVudFxuICAgKi9cbiAga2V5dXAoZSkge1xuICAgIGUuc2hpZnRLZXkgfHwgdGhpcy5FZGl0b3IuVUkuY2hlY2tFbXB0aW5lc3MoKTtcbiAgfVxuICAvKipcbiAgICogQWRkIGRyb3AgdGFyZ2V0IHN0eWxlc1xuICAgKlxuICAgKiBAcGFyYW0ge0RyYWdFdmVudH0gZXZlbnQgLSBkcmFnIG92ZXIgZXZlbnRcbiAgICovXG4gIGRyYWdPdmVyKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmdldEJsb2NrQnlDaGlsZE5vZGUoZS50YXJnZXQpO1xuICAgIHQuZHJvcFRhcmdldCA9ICEwO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgZHJvcCB0YXJnZXQgc3R5bGVcbiAgICpcbiAgICogQHBhcmFtIHtEcmFnRXZlbnR9IGV2ZW50IC0gZHJhZyBsZWF2ZSBldmVudFxuICAgKi9cbiAgZHJhZ0xlYXZlKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmdldEJsb2NrQnlDaGlsZE5vZGUoZS50YXJnZXQpO1xuICAgIHQuZHJvcFRhcmdldCA9ICExO1xuICB9XG4gIC8qKlxuICAgKiBDb3B5aW5nIHNlbGVjdGVkIGJsb2Nrc1xuICAgKiBCZWZvcmUgcHV0dGluZyB0byB0aGUgY2xpcGJvYXJkIHdlIHNhbml0aXplIGFsbCBibG9ja3MgYW5kIHRoZW4gY29weSB0byB0aGUgY2xpcGJvYXJkXG4gICAqXG4gICAqIEBwYXJhbSB7Q2xpcGJvYXJkRXZlbnR9IGV2ZW50IC0gY2xpcGJvYXJkIGV2ZW50XG4gICAqL1xuICBoYW5kbGVDb21tYW5kQyhlKSB7XG4gICAgY29uc3QgeyBCbG9ja1NlbGVjdGlvbjogdCB9ID0gdGhpcy5FZGl0b3I7XG4gICAgdC5hbnlCbG9ja1NlbGVjdGVkICYmIHQuY29weVNlbGVjdGVkQmxvY2tzKGUpO1xuICB9XG4gIC8qKlxuICAgKiBDb3B5IGFuZCBEZWxldGUgc2VsZWN0ZWQgQmxvY2tzXG4gICAqXG4gICAqIEBwYXJhbSB7Q2xpcGJvYXJkRXZlbnR9IGV2ZW50IC0gY2xpcGJvYXJkIGV2ZW50XG4gICAqL1xuICBoYW5kbGVDb21tYW5kWChlKSB7XG4gICAgY29uc3QgeyBCbG9ja1NlbGVjdGlvbjogdCwgQmxvY2tNYW5hZ2VyOiBvLCBDYXJldDogaSB9ID0gdGhpcy5FZGl0b3I7XG4gICAgdC5hbnlCbG9ja1NlbGVjdGVkICYmIHQuY29weVNlbGVjdGVkQmxvY2tzKGUpLnRoZW4oKCkgPT4ge1xuICAgICAgY29uc3QgcyA9IG8ucmVtb3ZlU2VsZWN0ZWRCbG9ja3MoKSwgciA9IG8uaW5zZXJ0RGVmYXVsdEJsb2NrQXRJbmRleChzLCAhMCk7XG4gICAgICBpLnNldFRvQmxvY2sociwgaS5wb3NpdGlvbnMuU1RBUlQpLCB0LmNsZWFyU2VsZWN0aW9uKGUpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBUYWIgcHJlc3NlZCBpbnNpZGUgYSBCbG9jay5cbiAgICpcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudCAtIGtleWRvd25cbiAgICovXG4gIHRhYlByZXNzZWQoZSkge1xuICAgIGNvbnN0IHsgSW5saW5lVG9vbGJhcjogdCwgQ2FyZXQ6IG8gfSA9IHRoaXMuRWRpdG9yO1xuICAgIGlmICh0Lm9wZW5lZClcbiAgICAgIHJldHVybjtcbiAgICAoZS5zaGlmdEtleSA/IG8ubmF2aWdhdGVQcmV2aW91cyghMCkgOiBvLm5hdmlnYXRlTmV4dCghMCkpICYmIGUucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICAvKipcbiAgICogJy8nICsgJ2NvbW1hbmQnIGtleWRvd24gaW5zaWRlIGEgQmxvY2tcbiAgICovXG4gIGNvbW1hbmRTbGFzaFByZXNzZWQoKSB7XG4gICAgdGhpcy5FZGl0b3IuQmxvY2tTZWxlY3Rpb24uc2VsZWN0ZWRCbG9ja3MubGVuZ3RoID4gMSB8fCB0aGlzLmFjdGl2YXRlQmxvY2tTZXR0aW5ncygpO1xuICB9XG4gIC8qKlxuICAgKiAnLycga2V5ZG93biBpbnNpZGUgYSBCbG9ja1xuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgLSBrZXlkb3duXG4gICAqL1xuICBzbGFzaFByZXNzZWQoZSkge1xuICAgIHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5jdXJyZW50QmxvY2suaXNFbXB0eSAmJiAoZS5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLkVkaXRvci5DYXJldC5pbnNlcnRDb250ZW50QXRDYXJldFBvc2l0aW9uKFwiL1wiKSwgdGhpcy5hY3RpdmF0ZVRvb2xib3goKSk7XG4gIH1cbiAgLyoqXG4gICAqIEVOVEVSIHByZXNzZWQgb24gYmxvY2tcbiAgICpcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudCAtIGtleWRvd25cbiAgICovXG4gIGVudGVyKGUpIHtcbiAgICBjb25zdCB7IEJsb2NrTWFuYWdlcjogdCwgVUk6IG8gfSA9IHRoaXMuRWRpdG9yLCBpID0gdC5jdXJyZW50QmxvY2s7XG4gICAgaWYgKGkgPT09IHZvaWQgMCB8fCBpLnRvb2wuaXNMaW5lQnJlYWtzRW5hYmxlZCB8fCBvLnNvbWVUb29sYmFyT3BlbmVkICYmIG8uc29tZUZsaXBwZXJCdXR0b25Gb2N1c2VkIHx8IGUuc2hpZnRLZXkgJiYgIUdlKVxuICAgICAgcmV0dXJuO1xuICAgIGxldCBzID0gaTtcbiAgICBpLmN1cnJlbnRJbnB1dCAhPT0gdm9pZCAwICYmIEllKGkuY3VycmVudElucHV0KSAmJiAhaS5oYXNNZWRpYSA/IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5pbnNlcnREZWZhdWx0QmxvY2tBdEluZGV4KHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5jdXJyZW50QmxvY2tJbmRleCkgOiBpLmN1cnJlbnRJbnB1dCAmJiBNZShpLmN1cnJlbnRJbnB1dCkgPyBzID0gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmluc2VydERlZmF1bHRCbG9ja0F0SW5kZXgodGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmN1cnJlbnRCbG9ja0luZGV4ICsgMSkgOiBzID0gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLnNwbGl0KCksIHRoaXMuRWRpdG9yLkNhcmV0LnNldFRvQmxvY2socyksIHRoaXMuRWRpdG9yLlRvb2xiYXIubW92ZUFuZE9wZW4ocyksIGUucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlIGJhY2tzcGFjZSBrZXlkb3duIG9uIEJsb2NrXG4gICAqXG4gICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnQgLSBrZXlkb3duXG4gICAqL1xuICBiYWNrc3BhY2UoZSkge1xuICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiB0LCBDYXJldDogbyB9ID0gdGhpcy5FZGl0b3IsIHsgY3VycmVudEJsb2NrOiBpLCBwcmV2aW91c0Jsb2NrOiBzIH0gPSB0O1xuICAgIGlmIChpID09PSB2b2lkIDAgfHwgIWIuaXNDb2xsYXBzZWQgfHwgIWkuY3VycmVudElucHV0IHx8ICFJZShpLmN1cnJlbnRJbnB1dCkpXG4gICAgICByZXR1cm47XG4gICAgaWYgKGUucHJldmVudERlZmF1bHQoKSwgdGhpcy5FZGl0b3IuVG9vbGJhci5jbG9zZSgpLCAhKGkuY3VycmVudElucHV0ID09PSBpLmZpcnN0SW5wdXQpKSB7XG4gICAgICBvLm5hdmlnYXRlUHJldmlvdXMoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHMgPT09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgaWYgKHMuaXNFbXB0eSkge1xuICAgICAgdC5yZW1vdmVCbG9jayhzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGkuaXNFbXB0eSkge1xuICAgICAgdC5yZW1vdmVCbG9jayhpKTtcbiAgICAgIGNvbnN0IGEgPSB0LmN1cnJlbnRCbG9jaztcbiAgICAgIG8uc2V0VG9CbG9jayhhLCBvLnBvc2l0aW9ucy5FTkQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2dChzLCBpKSA/IHRoaXMubWVyZ2VCbG9ja3MocywgaSkgOiBvLnNldFRvQmxvY2socywgby5wb3NpdGlvbnMuRU5EKTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlcyBkZWxldGUga2V5ZG93biBvbiBCbG9ja1xuICAgKiBSZW1vdmVzIGNoYXIgYWZ0ZXIgdGhlIGNhcmV0LlxuICAgKiBJZiBjYXJldCBpcyBhdCB0aGUgZW5kIG9mIHRoZSBibG9jaywgbWVyZ2UgbmV4dCBibG9jayB3aXRoIGN1cnJlbnRcbiAgICpcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudCAtIGtleWRvd25cbiAgICovXG4gIGRlbGV0ZShlKSB7XG4gICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IHQsIENhcmV0OiBvIH0gPSB0aGlzLkVkaXRvciwgeyBjdXJyZW50QmxvY2s6IGksIG5leHRCbG9jazogcyB9ID0gdDtcbiAgICBpZiAoIWIuaXNDb2xsYXBzZWQgfHwgIU1lKGkuY3VycmVudElucHV0KSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLkVkaXRvci5Ub29sYmFyLmNsb3NlKCksICEoaS5jdXJyZW50SW5wdXQgPT09IGkubGFzdElucHV0KSkge1xuICAgICAgby5uYXZpZ2F0ZU5leHQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHMgPT09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgaWYgKHMuaXNFbXB0eSkge1xuICAgICAgdC5yZW1vdmVCbG9jayhzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGkuaXNFbXB0eSkge1xuICAgICAgdC5yZW1vdmVCbG9jayhpKSwgby5zZXRUb0Jsb2NrKHMsIG8ucG9zaXRpb25zLlNUQVJUKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdnQoaSwgcykgPyB0aGlzLm1lcmdlQmxvY2tzKGksIHMpIDogby5zZXRUb0Jsb2NrKHMsIG8ucG9zaXRpb25zLlNUQVJUKTtcbiAgfVxuICAvKipcbiAgICogTWVyZ2UgcGFzc2VkIEJsb2Nrc1xuICAgKlxuICAgKiBAcGFyYW0gdGFyZ2V0QmxvY2sgLSB0byB3aGljaCBCbG9jayB3ZSB3YW50IHRvIG1lcmdlXG4gICAqIEBwYXJhbSBibG9ja1RvTWVyZ2UgLSB3aGF0IEJsb2NrIHdlIHdhbnQgdG8gbWVyZ2VcbiAgICovXG4gIG1lcmdlQmxvY2tzKGUsIHQpIHtcbiAgICBjb25zdCB7IEJsb2NrTWFuYWdlcjogbywgQ2FyZXQ6IGksIFRvb2xiYXI6IHMgfSA9IHRoaXMuRWRpdG9yO1xuICAgIGkuY3JlYXRlU2hhZG93KGUubGFzdElucHV0KSwgby5tZXJnZUJsb2NrcyhlLCB0KS50aGVuKCgpID0+IHtcbiAgICAgIGkucmVzdG9yZUNhcmV0KGUucGx1Z2luc0NvbnRlbnQpLCBzLmNsb3NlKCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZSByaWdodCBhbmQgZG93biBrZXlib2FyZCBrZXlzXG4gICAqXG4gICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnQgLSBrZXlib2FyZCBldmVudFxuICAgKi9cbiAgYXJyb3dSaWdodEFuZERvd24oZSkge1xuICAgIGNvbnN0IHQgPSByZS51c2VkS2V5cy5pbmNsdWRlcyhlLmtleUNvZGUpICYmICghZS5zaGlmdEtleSB8fCBlLmtleUNvZGUgPT09IHcuVEFCKTtcbiAgICBpZiAodGhpcy5FZGl0b3IuVUkuc29tZVRvb2xiYXJPcGVuZWQgJiYgdClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLkVkaXRvci5Ub29sYmFyLmNsb3NlKCk7XG4gICAgY29uc3QgeyBjdXJyZW50QmxvY2s6IG8gfSA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlciwgcyA9ICgobyA9PSBudWxsID8gdm9pZCAwIDogby5jdXJyZW50SW5wdXQpICE9PSB2b2lkIDAgPyBNZShvLmN1cnJlbnRJbnB1dCkgOiB2b2lkIDApIHx8IHRoaXMuRWRpdG9yLkJsb2NrU2VsZWN0aW9uLmFueUJsb2NrU2VsZWN0ZWQ7XG4gICAgaWYgKGUuc2hpZnRLZXkgJiYgZS5rZXlDb2RlID09PSB3LkRPV04gJiYgcykge1xuICAgICAgdGhpcy5FZGl0b3IuQ3Jvc3NCbG9ja1NlbGVjdGlvbi50b2dnbGVCbG9ja1NlbGVjdGVkU3RhdGUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGUua2V5Q29kZSA9PT0gdy5ET1dOIHx8IGUua2V5Q29kZSA9PT0gdy5SSUdIVCAmJiAhdGhpcy5pc1J0bCA/IHRoaXMuRWRpdG9yLkNhcmV0Lm5hdmlnYXRlTmV4dCgpIDogdGhpcy5FZGl0b3IuQ2FyZXQubmF2aWdhdGVQcmV2aW91cygpKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIEFlKCgpID0+IHtcbiAgICAgIHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5jdXJyZW50QmxvY2sgJiYgdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmN1cnJlbnRCbG9jay51cGRhdGVDdXJyZW50SW5wdXQoKTtcbiAgICB9LCAyMCkoKSwgdGhpcy5FZGl0b3IuQmxvY2tTZWxlY3Rpb24uY2xlYXJTZWxlY3Rpb24oZSk7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZSBsZWZ0IGFuZCB1cCBrZXlib2FyZCBrZXlzXG4gICAqXG4gICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnQgLSBrZXlib2FyZCBldmVudFxuICAgKi9cbiAgYXJyb3dMZWZ0QW5kVXAoZSkge1xuICAgIGlmICh0aGlzLkVkaXRvci5VSS5zb21lVG9vbGJhck9wZW5lZCkge1xuICAgICAgaWYgKHJlLnVzZWRLZXlzLmluY2x1ZGVzKGUua2V5Q29kZSkgJiYgKCFlLnNoaWZ0S2V5IHx8IGUua2V5Q29kZSA9PT0gdy5UQUIpKVxuICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLkVkaXRvci5VSS5jbG9zZUFsbFRvb2xiYXJzKCk7XG4gICAgfVxuICAgIHRoaXMuRWRpdG9yLlRvb2xiYXIuY2xvc2UoKTtcbiAgICBjb25zdCB7IGN1cnJlbnRCbG9jazogdCB9ID0gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLCBpID0gKCh0ID09IG51bGwgPyB2b2lkIDAgOiB0LmN1cnJlbnRJbnB1dCkgIT09IHZvaWQgMCA/IEllKHQuY3VycmVudElucHV0KSA6IHZvaWQgMCkgfHwgdGhpcy5FZGl0b3IuQmxvY2tTZWxlY3Rpb24uYW55QmxvY2tTZWxlY3RlZDtcbiAgICBpZiAoZS5zaGlmdEtleSAmJiBlLmtleUNvZGUgPT09IHcuVVAgJiYgaSkge1xuICAgICAgdGhpcy5FZGl0b3IuQ3Jvc3NCbG9ja1NlbGVjdGlvbi50b2dnbGVCbG9ja1NlbGVjdGVkU3RhdGUoITEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZS5rZXlDb2RlID09PSB3LlVQIHx8IGUua2V5Q29kZSA9PT0gdy5MRUZUICYmICF0aGlzLmlzUnRsID8gdGhpcy5FZGl0b3IuQ2FyZXQubmF2aWdhdGVQcmV2aW91cygpIDogdGhpcy5FZGl0b3IuQ2FyZXQubmF2aWdhdGVOZXh0KCkpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgQWUoKCkgPT4ge1xuICAgICAgdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmN1cnJlbnRCbG9jayAmJiB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY3VycmVudEJsb2NrLnVwZGF0ZUN1cnJlbnRJbnB1dCgpO1xuICAgIH0sIDIwKSgpLCB0aGlzLkVkaXRvci5CbG9ja1NlbGVjdGlvbi5jbGVhclNlbGVjdGlvbihlKTtcbiAgfVxuICAvKipcbiAgICogQ2FzZXMgd2hlbiB3ZSBuZWVkIHRvIGNsb3NlIFRvb2xiYXJcbiAgICpcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudCAtIGtleWJvYXJkIGV2ZW50XG4gICAqL1xuICBuZWVkVG9vbGJhckNsb3NpbmcoZSkge1xuICAgIGNvbnN0IHQgPSBlLmtleUNvZGUgPT09IHcuRU5URVIgJiYgdGhpcy5FZGl0b3IuVG9vbGJhci50b29sYm94Lm9wZW5lZCwgbyA9IGUua2V5Q29kZSA9PT0gdy5FTlRFUiAmJiB0aGlzLkVkaXRvci5CbG9ja1NldHRpbmdzLm9wZW5lZCwgaSA9IGUua2V5Q29kZSA9PT0gdy5FTlRFUiAmJiB0aGlzLkVkaXRvci5JbmxpbmVUb29sYmFyLm9wZW5lZCwgcyA9IGUua2V5Q29kZSA9PT0gdy5UQUI7XG4gICAgcmV0dXJuICEoZS5zaGlmdEtleSB8fCBzIHx8IHQgfHwgbyB8fCBpKTtcbiAgfVxuICAvKipcbiAgICogSWYgVG9vbGJveCBpcyBub3Qgb3BlbiwgdGhlbiBqdXN0IG9wZW4gaXQgYW5kIHNob3cgcGx1cyBidXR0b25cbiAgICovXG4gIGFjdGl2YXRlVG9vbGJveCgpIHtcbiAgICB0aGlzLkVkaXRvci5Ub29sYmFyLm9wZW5lZCB8fCB0aGlzLkVkaXRvci5Ub29sYmFyLm1vdmVBbmRPcGVuKCksIHRoaXMuRWRpdG9yLlRvb2xiYXIudG9vbGJveC5vcGVuKCk7XG4gIH1cbiAgLyoqXG4gICAqIE9wZW4gVG9vbGJhciBhbmQgc2hvdyBCbG9ja1NldHRpbmdzIGJlZm9yZSBmbGlwcGluZyBUb29sc1xuICAgKi9cbiAgYWN0aXZhdGVCbG9ja1NldHRpbmdzKCkge1xuICAgIHRoaXMuRWRpdG9yLlRvb2xiYXIub3BlbmVkIHx8IHRoaXMuRWRpdG9yLlRvb2xiYXIubW92ZUFuZE9wZW4oKSwgdGhpcy5FZGl0b3IuQmxvY2tTZXR0aW5ncy5vcGVuZWQgfHwgdGhpcy5FZGl0b3IuQmxvY2tTZXR0aW5ncy5vcGVuKCk7XG4gIH1cbn1cbmNsYXNzIFhlIHtcbiAgLyoqXG4gICAqIEBjbGFzc1xuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB3b3JraW5nQXJlYSDigJQgZWRpdG9yYHMgd29ya2luZyBub2RlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy5ibG9ja3MgPSBbXSwgdGhpcy53b3JraW5nQXJlYSA9IGU7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBsZW5ndGggb2YgQmxvY2sgaW5zdGFuY2VzIGFycmF5XG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLmJsb2Nrcy5sZW5ndGg7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBCbG9jayBpbnN0YW5jZXMgYXJyYXlcbiAgICpcbiAgICogQHJldHVybnMge0Jsb2NrW119XG4gICAqL1xuICBnZXQgYXJyYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmxvY2tzO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYmxvY2tzIGh0bWwgZWxlbWVudHMgYXJyYXlcbiAgICpcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50W119XG4gICAqL1xuICBnZXQgbm9kZXMoKSB7XG4gICAgcmV0dXJuIE10KHRoaXMud29ya2luZ0FyZWEuY2hpbGRyZW4pO1xuICB9XG4gIC8qKlxuICAgKiBQcm94eSB0cmFwIHRvIGltcGxlbWVudCBhcnJheS1saWtlIHNldHRlclxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBibG9ja3NbMF0gPSBuZXcgQmxvY2soLi4uKVxuICAgKiBAcGFyYW0ge0Jsb2Nrc30gaW5zdGFuY2Ug4oCUIEJsb2NrcyBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge1Byb3BlcnR5S2V5fSBwcm9wZXJ0eSDigJQgYmxvY2sgaW5kZXggb3IgYW55IEJsb2NrcyBjbGFzcyBwcm9wZXJ0eSBrZXkgdG8gc2V0XG4gICAqIEBwYXJhbSB7QmxvY2t9IHZhbHVlIOKAlCB2YWx1ZSB0byBzZXRcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgc2V0KGUsIHQsIG8pIHtcbiAgICByZXR1cm4gaXNOYU4oTnVtYmVyKHQpKSA/IChSZWZsZWN0LnNldChlLCB0LCBvKSwgITApIDogKGUuaW5zZXJ0KCt0LCBvKSwgITApO1xuICB9XG4gIC8qKlxuICAgKiBQcm94eSB0cmFwIHRvIGltcGxlbWVudCBhcnJheS1saWtlIGdldHRlclxuICAgKlxuICAgKiBAcGFyYW0ge0Jsb2Nrc30gaW5zdGFuY2Ug4oCUIEJsb2NrcyBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge1Byb3BlcnR5S2V5fSBwcm9wZXJ0eSDigJQgQmxvY2tzIGNsYXNzIHByb3BlcnR5IGtleVxuICAgKiBAcmV0dXJucyB7QmxvY2t8Kn1cbiAgICovXG4gIHN0YXRpYyBnZXQoZSwgdCkge1xuICAgIHJldHVybiBpc05hTihOdW1iZXIodCkpID8gUmVmbGVjdC5nZXQoZSwgdCkgOiBlLmdldCgrdCk7XG4gIH1cbiAgLyoqXG4gICAqIFB1c2ggbmV3IEJsb2NrIHRvIHRoZSBibG9ja3MgYXJyYXkgYW5kIGFwcGVuZCBpdCB0byB3b3JraW5nIGFyZWFcbiAgICpcbiAgICogQHBhcmFtIHtCbG9ja30gYmxvY2sgLSBCbG9jayB0byBhZGRcbiAgICovXG4gIHB1c2goZSkge1xuICAgIHRoaXMuYmxvY2tzLnB1c2goZSksIHRoaXMuaW5zZXJ0VG9ET00oZSk7XG4gIH1cbiAgLyoqXG4gICAqIFN3YXBzIGJsb2NrcyB3aXRoIGluZGV4ZXMgZmlyc3QgYW5kIHNlY29uZFxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gZmlyc3QgLSBmaXJzdCBibG9jayBpbmRleFxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Vjb25kIC0gc2Vjb25kIGJsb2NrIGluZGV4XG4gICAqIEBkZXByZWNhdGVkIOKAlCB1c2UgJ21vdmUnIGluc3RlYWRcbiAgICovXG4gIHN3YXAoZSwgdCkge1xuICAgIGNvbnN0IG8gPSB0aGlzLmJsb2Nrc1t0XTtcbiAgICBkLnN3YXAodGhpcy5ibG9ja3NbZV0uaG9sZGVyLCBvLmhvbGRlciksIHRoaXMuYmxvY2tzW3RdID0gdGhpcy5ibG9ja3NbZV0sIHRoaXMuYmxvY2tzW2VdID0gbztcbiAgfVxuICAvKipcbiAgICogTW92ZSBhIGJsb2NrIGZyb20gb25lIHRvIGFub3RoZXIgaW5kZXhcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRvSW5kZXggLSBuZXcgaW5kZXggb2YgdGhlIGJsb2NrXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggLSBibG9jayB0byBtb3ZlXG4gICAqL1xuICBtb3ZlKGUsIHQpIHtcbiAgICBjb25zdCBvID0gdGhpcy5ibG9ja3Muc3BsaWNlKHQsIDEpWzBdLCBpID0gZSAtIDEsIHMgPSBNYXRoLm1heCgwLCBpKSwgciA9IHRoaXMuYmxvY2tzW3NdO1xuICAgIGUgPiAwID8gdGhpcy5pbnNlcnRUb0RPTShvLCBcImFmdGVyZW5kXCIsIHIpIDogdGhpcy5pbnNlcnRUb0RPTShvLCBcImJlZm9yZWJlZ2luXCIsIHIpLCB0aGlzLmJsb2Nrcy5zcGxpY2UoZSwgMCwgbyk7XG4gICAgY29uc3QgbCA9IHRoaXMuY29tcG9zZUJsb2NrRXZlbnQoXCJtb3ZlXCIsIHtcbiAgICAgIGZyb21JbmRleDogdCxcbiAgICAgIHRvSW5kZXg6IGVcbiAgICB9KTtcbiAgICBvLmNhbGwoSi5NT1ZFRCwgbCk7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydCBuZXcgQmxvY2sgYXQgcGFzc2VkIGluZGV4XG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCDigJQgaW5kZXggdG8gaW5zZXJ0IEJsb2NrXG4gICAqIEBwYXJhbSB7QmxvY2t9IGJsb2NrIOKAlCBCbG9jayB0byBpbnNlcnRcbiAgICogQHBhcmFtIHtib29sZWFufSByZXBsYWNlIOKAlCBpdCB0cnVlLCByZXBsYWNlIGJsb2NrIG9uIGdpdmVuIGluZGV4XG4gICAqL1xuICBpbnNlcnQoZSwgdCwgbyA9ICExKSB7XG4gICAgaWYgKCF0aGlzLmxlbmd0aCkge1xuICAgICAgdGhpcy5wdXNoKHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlID4gdGhpcy5sZW5ndGggJiYgKGUgPSB0aGlzLmxlbmd0aCksIG8gJiYgKHRoaXMuYmxvY2tzW2VdLmhvbGRlci5yZW1vdmUoKSwgdGhpcy5ibG9ja3NbZV0uY2FsbChKLlJFTU9WRUQpKTtcbiAgICBjb25zdCBpID0gbyA/IDEgOiAwO1xuICAgIGlmICh0aGlzLmJsb2Nrcy5zcGxpY2UoZSwgaSwgdCksIGUgPiAwKSB7XG4gICAgICBjb25zdCBzID0gdGhpcy5ibG9ja3NbZSAtIDFdO1xuICAgICAgdGhpcy5pbnNlcnRUb0RPTSh0LCBcImFmdGVyZW5kXCIsIHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzID0gdGhpcy5ibG9ja3NbZSArIDFdO1xuICAgICAgcyA/IHRoaXMuaW5zZXJ0VG9ET00odCwgXCJiZWZvcmViZWdpblwiLCBzKSA6IHRoaXMuaW5zZXJ0VG9ET00odCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXBsYWNlcyBibG9jayB1bmRlciBwYXNzZWQgaW5kZXggd2l0aCBwYXNzZWQgYmxvY2tcbiAgICpcbiAgICogQHBhcmFtIGluZGV4IC0gaW5kZXggb2YgZXhpc3RlZCBibG9ja1xuICAgKiBAcGFyYW0gYmxvY2sgLSBuZXcgYmxvY2tcbiAgICovXG4gIHJlcGxhY2UoZSwgdCkge1xuICAgIGlmICh0aGlzLmJsb2Nrc1tlXSA9PT0gdm9pZCAwKVxuICAgICAgdGhyb3cgRXJyb3IoXCJJbmNvcnJlY3QgaW5kZXhcIik7XG4gICAgdGhpcy5ibG9ja3NbZV0uaG9sZGVyLnJlcGxhY2VXaXRoKHQuaG9sZGVyKSwgdGhpcy5ibG9ja3NbZV0gPSB0O1xuICB9XG4gIC8qKlxuICAgKiBJbnNlcnRzIHNldmVyYWwgYmxvY2tzIGF0IG9uY2VcbiAgICpcbiAgICogQHBhcmFtIGJsb2NrcyAtIGJsb2NrcyB0byBpbnNlcnRcbiAgICogQHBhcmFtIGluZGV4IC0gaW5kZXggdG8gaW5zZXJ0IGJsb2NrcyBhdFxuICAgKi9cbiAgaW5zZXJ0TWFueShlLCB0KSB7XG4gICAgY29uc3QgbyA9IG5ldyBEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgZm9yIChjb25zdCBpIG9mIGUpXG4gICAgICBvLmFwcGVuZENoaWxkKGkuaG9sZGVyKTtcbiAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAodCA+IDApIHtcbiAgICAgICAgY29uc3QgaSA9IE1hdGgubWluKHQgLSAxLCB0aGlzLmxlbmd0aCAtIDEpO1xuICAgICAgICB0aGlzLmJsb2Nrc1tpXS5ob2xkZXIuYWZ0ZXIobyk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgdCA9PT0gMCAmJiB0aGlzLndvcmtpbmdBcmVhLnByZXBlbmQobyk7XG4gICAgICB0aGlzLmJsb2Nrcy5zcGxpY2UodCwgMCwgLi4uZSk7XG4gICAgfSBlbHNlXG4gICAgICB0aGlzLmJsb2Nrcy5wdXNoKC4uLmUpLCB0aGlzLndvcmtpbmdBcmVhLmFwcGVuZENoaWxkKG8pO1xuICAgIGUuZm9yRWFjaCgoaSkgPT4gaS5jYWxsKEouUkVOREVSRUQpKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIGJsb2NrXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIGluZGV4IG9mIEJsb2NrIHRvIHJlbW92ZVxuICAgKi9cbiAgcmVtb3ZlKGUpIHtcbiAgICBpc05hTihlKSAmJiAoZSA9IHRoaXMubGVuZ3RoIC0gMSksIHRoaXMuYmxvY2tzW2VdLmhvbGRlci5yZW1vdmUoKSwgdGhpcy5ibG9ja3NbZV0uY2FsbChKLlJFTU9WRUQpLCB0aGlzLmJsb2Nrcy5zcGxpY2UoZSwgMSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBhbGwgYmxvY2tzXG4gICAqL1xuICByZW1vdmVBbGwoKSB7XG4gICAgdGhpcy53b3JraW5nQXJlYS5pbm5lckhUTUwgPSBcIlwiLCB0aGlzLmJsb2Nrcy5mb3JFYWNoKChlKSA9PiBlLmNhbGwoSi5SRU1PVkVEKSksIHRoaXMuYmxvY2tzLmxlbmd0aCA9IDA7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydCBCbG9jayBhZnRlciBwYXNzZWQgdGFyZ2V0XG4gICAqXG4gICAqIEB0b2RvIGRlY2lkZSBpZiB0aGlzIG1ldGhvZCBpcyBuZWNlc3NhcnlcbiAgICogQHBhcmFtIHtCbG9ja30gdGFyZ2V0QmxvY2sg4oCUIHRhcmdldCBhZnRlciB3aGljaCBCbG9jayBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICogQHBhcmFtIHtCbG9ja30gbmV3QmxvY2sg4oCUIEJsb2NrIHRvIGluc2VydFxuICAgKi9cbiAgaW5zZXJ0QWZ0ZXIoZSwgdCkge1xuICAgIGNvbnN0IG8gPSB0aGlzLmJsb2Nrcy5pbmRleE9mKGUpO1xuICAgIHRoaXMuaW5zZXJ0KG8gKyAxLCB0KTtcbiAgfVxuICAvKipcbiAgICogR2V0IEJsb2NrIGJ5IGluZGV4XG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCDigJQgQmxvY2sgaW5kZXhcbiAgICogQHJldHVybnMge0Jsb2NrfVxuICAgKi9cbiAgZ2V0KGUpIHtcbiAgICByZXR1cm4gdGhpcy5ibG9ja3NbZV07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBpbmRleCBvZiBwYXNzZWQgQmxvY2tcbiAgICpcbiAgICogQHBhcmFtIHtCbG9ja30gYmxvY2sgLSBCbG9jayB0byBmaW5kXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBpbmRleE9mKGUpIHtcbiAgICByZXR1cm4gdGhpcy5ibG9ja3MuaW5kZXhPZihlKTtcbiAgfVxuICAvKipcbiAgICogSW5zZXJ0IG5ldyBCbG9jayBpbnRvIERPTVxuICAgKlxuICAgKiBAcGFyYW0ge0Jsb2NrfSBibG9jayAtIEJsb2NrIHRvIGluc2VydFxuICAgKiBAcGFyYW0ge0luc2VydFBvc2l0aW9ufSBwb3NpdGlvbiDigJQgaW5zZXJ0IHBvc2l0aW9uIChpZiBzZXQsIHdpbGwgdXNlIGluc2VydEFkamFjZW50RWxlbWVudClcbiAgICogQHBhcmFtIHtCbG9ja30gdGFyZ2V0IOKAlCBCbG9jayByZWxhdGVkIHRvIHBvc2l0aW9uXG4gICAqL1xuICBpbnNlcnRUb0RPTShlLCB0LCBvKSB7XG4gICAgdCA/IG8uaG9sZGVyLmluc2VydEFkamFjZW50RWxlbWVudCh0LCBlLmhvbGRlcikgOiB0aGlzLndvcmtpbmdBcmVhLmFwcGVuZENoaWxkKGUuaG9sZGVyKSwgZS5jYWxsKEouUkVOREVSRUQpO1xuICB9XG4gIC8qKlxuICAgKiBDb21wb3NlcyBCbG9jayBldmVudCB3aXRoIHBhc3NlZCB0eXBlIGFuZCBkZXRhaWxzXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gZXZlbnQgdHlwZVxuICAgKiBAcGFyYW0ge29iamVjdH0gZGV0YWlsIC0gZXZlbnQgZGV0YWlsXG4gICAqL1xuICBjb21wb3NlQmxvY2tFdmVudChlLCB0KSB7XG4gICAgcmV0dXJuIG5ldyBDdXN0b21FdmVudChlLCB7XG4gICAgICBkZXRhaWw6IHRcbiAgICB9KTtcbiAgfVxufVxuY29uc3QgQnQgPSBcImJsb2NrLXJlbW92ZWRcIiwgVHQgPSBcImJsb2NrLWFkZGVkXCIsIEppID0gXCJibG9jay1tb3ZlZFwiLCBDdCA9IFwiYmxvY2stY2hhbmdlZFwiO1xuY2xhc3MgUWkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNvbXBsZXRlZCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgbmV3IHByb21pc2UgdG8gcXVldWVcbiAgICpcbiAgICogQHBhcmFtIG9wZXJhdGlvbiAtIHByb21pc2Ugc2hvdWxkIGJlIGFkZGVkIHRvIHF1ZXVlXG4gICAqL1xuICBhZGQoZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgodCwgbykgPT4ge1xuICAgICAgdGhpcy5jb21wbGV0ZWQgPSB0aGlzLmNvbXBsZXRlZC50aGVuKGUpLnRoZW4odCkuY2F0Y2gobyk7XG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIGVzIGV4dGVuZHMgeSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMuX2N1cnJlbnRCbG9ja0luZGV4ID0gLTEsIHRoaXMuX2Jsb2NrcyA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgY3VycmVudCBCbG9jayBpbmRleFxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGN1cnJlbnRCbG9ja0luZGV4KCkge1xuICAgIHJldHVybiB0aGlzLl9jdXJyZW50QmxvY2tJbmRleDtcbiAgfVxuICAvKipcbiAgICogU2V0IGN1cnJlbnQgQmxvY2sgaW5kZXggYW5kIGZpcmUgQmxvY2sgbGlmZWN5Y2xlIGNhbGxiYWNrc1xuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbmV3SW5kZXggLSBpbmRleCBvZiBCbG9jayB0byBzZXQgYXMgY3VycmVudFxuICAgKi9cbiAgc2V0IGN1cnJlbnRCbG9ja0luZGV4KGUpIHtcbiAgICB0aGlzLl9jdXJyZW50QmxvY2tJbmRleCA9IGU7XG4gIH1cbiAgLyoqXG4gICAqIHJldHVybnMgZmlyc3QgQmxvY2tcbiAgICpcbiAgICogQHJldHVybnMge0Jsb2NrfVxuICAgKi9cbiAgZ2V0IGZpcnN0QmxvY2soKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Jsb2Nrc1swXTtcbiAgfVxuICAvKipcbiAgICogcmV0dXJucyBsYXN0IEJsb2NrXG4gICAqXG4gICAqIEByZXR1cm5zIHtCbG9ja31cbiAgICovXG4gIGdldCBsYXN0QmxvY2soKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Jsb2Nrc1t0aGlzLl9ibG9ja3MubGVuZ3RoIC0gMV07XG4gIH1cbiAgLyoqXG4gICAqIEdldCBjdXJyZW50IEJsb2NrIGluc3RhbmNlXG4gICAqXG4gICAqIEByZXR1cm5zIHtCbG9ja31cbiAgICovXG4gIGdldCBjdXJyZW50QmxvY2soKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Jsb2Nrc1t0aGlzLmN1cnJlbnRCbG9ja0luZGV4XTtcbiAgfVxuICAvKipcbiAgICogU2V0IHBhc3NlZCBCbG9jayBhcyBhIGN1cnJlbnRcbiAgICpcbiAgICogQHBhcmFtIGJsb2NrIC0gYmxvY2sgdG8gc2V0IGFzIGEgY3VycmVudFxuICAgKi9cbiAgc2V0IGN1cnJlbnRCbG9jayhlKSB7XG4gICAgdGhpcy5jdXJyZW50QmxvY2tJbmRleCA9IHRoaXMuZ2V0QmxvY2tJbmRleChlKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBuZXh0IEJsb2NrIGluc3RhbmNlXG4gICAqXG4gICAqIEByZXR1cm5zIHtCbG9ja3xudWxsfVxuICAgKi9cbiAgZ2V0IG5leHRCbG9jaygpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50QmxvY2tJbmRleCA9PT0gdGhpcy5fYmxvY2tzLmxlbmd0aCAtIDEgPyBudWxsIDogdGhpcy5fYmxvY2tzW3RoaXMuY3VycmVudEJsb2NrSW5kZXggKyAxXTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGZpcnN0IEJsb2NrIHdpdGggaW5wdXRzIGFmdGVyIGN1cnJlbnQgQmxvY2tcbiAgICpcbiAgICogQHJldHVybnMge0Jsb2NrIHwgdW5kZWZpbmVkfVxuICAgKi9cbiAgZ2V0IG5leHRDb250ZW50ZnVsQmxvY2soKSB7XG4gICAgcmV0dXJuIHRoaXMuYmxvY2tzLnNsaWNlKHRoaXMuY3VycmVudEJsb2NrSW5kZXggKyAxKS5maW5kKCh0KSA9PiAhIXQuaW5wdXRzLmxlbmd0aCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBmaXJzdCBCbG9jayB3aXRoIGlucHV0cyBiZWZvcmUgY3VycmVudCBCbG9ja1xuICAgKlxuICAgKiBAcmV0dXJucyB7QmxvY2sgfCB1bmRlZmluZWR9XG4gICAqL1xuICBnZXQgcHJldmlvdXNDb250ZW50ZnVsQmxvY2soKSB7XG4gICAgcmV0dXJuIHRoaXMuYmxvY2tzLnNsaWNlKDAsIHRoaXMuY3VycmVudEJsb2NrSW5kZXgpLnJldmVyc2UoKS5maW5kKCh0KSA9PiAhIXQuaW5wdXRzLmxlbmd0aCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgcHJldmlvdXMgQmxvY2sgaW5zdGFuY2VcbiAgICpcbiAgICogQHJldHVybnMge0Jsb2NrfG51bGx9XG4gICAqL1xuICBnZXQgcHJldmlvdXNCbG9jaygpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50QmxvY2tJbmRleCA9PT0gMCA/IG51bGwgOiB0aGlzLl9ibG9ja3NbdGhpcy5jdXJyZW50QmxvY2tJbmRleCAtIDFdO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYXJyYXkgb2YgQmxvY2sgaW5zdGFuY2VzXG4gICAqXG4gICAqIEByZXR1cm5zIHtCbG9ja1tdfSB7QGxpbmsgQmxvY2tzI2FycmF5fVxuICAgKi9cbiAgZ2V0IGJsb2NrcygpIHtcbiAgICByZXR1cm4gdGhpcy5fYmxvY2tzLmFycmF5O1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBlYWNoIEJsb2NrIGlzIGVtcHR5XG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzRWRpdG9yRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmxvY2tzLmV2ZXJ5KChlKSA9PiBlLmlzRW1wdHkpO1xuICB9XG4gIC8qKlxuICAgKiBTaG91bGQgYmUgY2FsbGVkIGFmdGVyIEVkaXRvci5VSSBwcmVwYXJhdGlvblxuICAgKiBEZWZpbmUgdGhpcy5fYmxvY2tzIHByb3BlcnR5XG4gICAqL1xuICBwcmVwYXJlKCkge1xuICAgIGNvbnN0IGUgPSBuZXcgWGUodGhpcy5FZGl0b3IuVUkubm9kZXMucmVkYWN0b3IpO1xuICAgIHRoaXMuX2Jsb2NrcyA9IG5ldyBQcm94eShlLCB7XG4gICAgICBzZXQ6IFhlLnNldCxcbiAgICAgIGdldDogWGUuZ2V0XG4gICAgfSksIHRoaXMubGlzdGVuZXJzLm9uKFxuICAgICAgZG9jdW1lbnQsXG4gICAgICBcImNvcHlcIixcbiAgICAgICh0KSA9PiB0aGlzLkVkaXRvci5CbG9ja0V2ZW50cy5oYW5kbGVDb21tYW5kQyh0KVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIFRvZ2dsZSByZWFkLW9ubHkgc3RhdGVcbiAgICpcbiAgICogSWYgcmVhZE9ubHkgaXMgdHJ1ZTpcbiAgICogIC0gVW5iaW5kIGV2ZW50IGhhbmRsZXJzIGZyb20gY3JlYXRlZCBCbG9ja3NcbiAgICpcbiAgICogaWYgcmVhZE9ubHkgaXMgZmFsc2U6XG4gICAqICAtIEJpbmQgZXZlbnQgaGFuZGxlcnMgdG8gYWxsIGV4aXN0aW5nIEJsb2Nrc1xuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlYWRPbmx5RW5hYmxlZCAtIFwicmVhZCBvbmx5XCIgc3RhdGVcbiAgICovXG4gIHRvZ2dsZVJlYWRPbmx5KGUpIHtcbiAgICBlID8gdGhpcy5kaXNhYmxlTW9kdWxlQmluZGluZ3MoKSA6IHRoaXMuZW5hYmxlTW9kdWxlQmluZGluZ3MoKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBCbG9jayBpbnN0YW5jZSBieSB0b29sIG5hbWVcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBibG9jayBjcmVhdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRvb2wgLSB0b29scyBwYXNzZWQgaW4gZWRpdG9yIGNvbmZpZyB7QGxpbmsgRWRpdG9yQ29uZmlnI3Rvb2xzfVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuaWRdIC0gdW5pcXVlIGlkIGZvciB0aGlzIGJsb2NrXG4gICAqIEBwYXJhbSB7QmxvY2tUb29sRGF0YX0gW29wdGlvbnMuZGF0YV0gLSBjb25zdHJ1Y3RvciBwYXJhbXNcbiAgICogQHJldHVybnMge0Jsb2NrfVxuICAgKi9cbiAgY29tcG9zZUJsb2NrKHtcbiAgICB0b29sOiBlLFxuICAgIGRhdGE6IHQgPSB7fSxcbiAgICBpZDogbyA9IHZvaWQgMCxcbiAgICB0dW5lczogaSA9IHt9XG4gIH0pIHtcbiAgICBjb25zdCBzID0gdGhpcy5FZGl0b3IuUmVhZE9ubHkuaXNFbmFibGVkLCByID0gdGhpcy5FZGl0b3IuVG9vbHMuYmxvY2tUb29scy5nZXQoZSksIGwgPSBuZXcgRCh7XG4gICAgICBpZDogbyxcbiAgICAgIGRhdGE6IHQsXG4gICAgICB0b29sOiByLFxuICAgICAgYXBpOiB0aGlzLkVkaXRvci5BUEksXG4gICAgICByZWFkT25seTogcyxcbiAgICAgIHR1bmVzRGF0YTogaVxuICAgIH0sIHRoaXMuZXZlbnRzRGlzcGF0Y2hlcik7XG4gICAgcmV0dXJuIHMgfHwgd2luZG93LnJlcXVlc3RJZGxlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgdGhpcy5iaW5kQmxvY2tFdmVudHMobCk7XG4gICAgfSwgeyB0aW1lb3V0OiAyZTMgfSksIGw7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydCBuZXcgYmxvY2sgaW50byBfYmxvY2tzXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gaW5zZXJ0IG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmlkXSAtIGJsb2NrJ3MgdW5pcXVlIGlkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50b29sXSAtIHBsdWdpbiBuYW1lLCBieSBkZWZhdWx0IG1ldGhvZCBpbnNlcnRzIHRoZSBkZWZhdWx0IGJsb2NrIHR5cGVcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLmRhdGFdIC0gcGx1Z2luIGRhdGFcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmluZGV4XSAtIGluZGV4IHdoZXJlIHRvIGluc2VydCBuZXcgQmxvY2tcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5uZWVkVG9Gb2N1c10gLSBmbGFnIHNob3dzIGlmIG5lZWRlZCB0byB1cGRhdGUgY3VycmVudCBCbG9jayBpbmRleFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJlcGxhY2VdIC0gZmxhZyBzaG93cyBpZiBibG9jayBieSBwYXNzZWQgaW5kZXggc2hvdWxkIGJlIHJlcGxhY2VkIHdpdGggaW5zZXJ0ZWQgb25lXG4gICAqIEByZXR1cm5zIHtCbG9ja31cbiAgICovXG4gIGluc2VydCh7XG4gICAgaWQ6IGUgPSB2b2lkIDAsXG4gICAgdG9vbDogdCA9IHRoaXMuY29uZmlnLmRlZmF1bHRCbG9jayxcbiAgICBkYXRhOiBvID0ge30sXG4gICAgaW5kZXg6IGksXG4gICAgbmVlZFRvRm9jdXM6IHMgPSAhMCxcbiAgICByZXBsYWNlOiByID0gITEsXG4gICAgdHVuZXM6IGwgPSB7fVxuICB9ID0ge30pIHtcbiAgICBsZXQgYSA9IGk7XG4gICAgYSA9PT0gdm9pZCAwICYmIChhID0gdGhpcy5jdXJyZW50QmxvY2tJbmRleCArIChyID8gMCA6IDEpKTtcbiAgICBjb25zdCBjID0gdGhpcy5jb21wb3NlQmxvY2soe1xuICAgICAgaWQ6IGUsXG4gICAgICB0b29sOiB0LFxuICAgICAgZGF0YTogbyxcbiAgICAgIHR1bmVzOiBsXG4gICAgfSk7XG4gICAgcmV0dXJuIHIgJiYgdGhpcy5ibG9ja0RpZE11dGF0ZWQoQnQsIHRoaXMuZ2V0QmxvY2tCeUluZGV4KGEpLCB7XG4gICAgICBpbmRleDogYVxuICAgIH0pLCB0aGlzLl9ibG9ja3MuaW5zZXJ0KGEsIGMsIHIpLCB0aGlzLmJsb2NrRGlkTXV0YXRlZChUdCwgYywge1xuICAgICAgaW5kZXg6IGFcbiAgICB9KSwgcyA/IHRoaXMuY3VycmVudEJsb2NrSW5kZXggPSBhIDogYSA8PSB0aGlzLmN1cnJlbnRCbG9ja0luZGV4ICYmIHRoaXMuY3VycmVudEJsb2NrSW5kZXgrKywgYztcbiAgfVxuICAvKipcbiAgICogSW5zZXJ0cyBzZXZlcmFsIGJsb2NrcyBhdCBvbmNlXG4gICAqXG4gICAqIEBwYXJhbSBibG9ja3MgLSBibG9ja3MgdG8gaW5zZXJ0XG4gICAqIEBwYXJhbSBpbmRleCAtIGluZGV4IHdoZXJlIHRvIGluc2VydFxuICAgKi9cbiAgaW5zZXJ0TWFueShlLCB0ID0gMCkge1xuICAgIHRoaXMuX2Jsb2Nrcy5pbnNlcnRNYW55KGUsIHQpO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGUgQmxvY2sgZGF0YS5cbiAgICpcbiAgICogQ3VycmVudGx5IHdlIGRvbid0IGhhdmUgYW4gJ3VwZGF0ZScgbWV0aG9kIGluIHRoZSBUb29scyBBUEksIHNvIHdlIGp1c3QgY3JlYXRlIGEgbmV3IGJsb2NrIHdpdGggdGhlIHNhbWUgaWQgYW5kIHR5cGVcbiAgICogU2hvdWxkIG5vdCB0cmlnZ2VyICdibG9jay1yZW1vdmVkJyBvciAnYmxvY2stYWRkZWQnIGV2ZW50cy5cbiAgICpcbiAgICogSWYgbmVpdGhlciBkYXRhIG5vciB0dW5lcyBpcyBwcm92aWRlZCwgcmV0dXJuIHRoZSBwcm92aWRlZCBibG9jayBpbnN0ZWFkLlxuICAgKlxuICAgKiBAcGFyYW0gYmxvY2sgLSBibG9jayB0byB1cGRhdGVcbiAgICogQHBhcmFtIGRhdGEgLSAob3B0aW9uYWwpIG5ldyBkYXRhXG4gICAqIEBwYXJhbSB0dW5lcyAtIChvcHRpb25hbCkgdHVuZSBkYXRhXG4gICAqL1xuICBhc3luYyB1cGRhdGUoZSwgdCwgbykge1xuICAgIGlmICghdCAmJiAhbylcbiAgICAgIHJldHVybiBlO1xuICAgIGNvbnN0IGkgPSBhd2FpdCBlLmRhdGEsIHMgPSB0aGlzLmNvbXBvc2VCbG9jayh7XG4gICAgICBpZDogZS5pZCxcbiAgICAgIHRvb2w6IGUubmFtZSxcbiAgICAgIGRhdGE6IE9iamVjdC5hc3NpZ24oe30sIGksIHQgPz8ge30pLFxuICAgICAgdHVuZXM6IG8gPz8gZS50dW5lc1xuICAgIH0pLCByID0gdGhpcy5nZXRCbG9ja0luZGV4KGUpO1xuICAgIHJldHVybiB0aGlzLl9ibG9ja3MucmVwbGFjZShyLCBzKSwgdGhpcy5ibG9ja0RpZE11dGF0ZWQoQ3QsIHMsIHtcbiAgICAgIGluZGV4OiByXG4gICAgfSksIHM7XG4gIH1cbiAgLyoqXG4gICAqIFJlcGxhY2UgcGFzc2VkIEJsb2NrIHdpdGggdGhlIG5ldyBvbmUgd2l0aCBzcGVjaWZpZWQgVG9vbCBhbmQgZGF0YVxuICAgKlxuICAgKiBAcGFyYW0gYmxvY2sgLSBibG9jayB0byByZXBsYWNlXG4gICAqIEBwYXJhbSBuZXdUb29sIC0gbmV3IFRvb2wgbmFtZVxuICAgKiBAcGFyYW0gZGF0YSAtIG5ldyBUb29sIGRhdGFcbiAgICovXG4gIHJlcGxhY2UoZSwgdCwgbykge1xuICAgIGNvbnN0IGkgPSB0aGlzLmdldEJsb2NrSW5kZXgoZSk7XG4gICAgcmV0dXJuIHRoaXMuaW5zZXJ0KHtcbiAgICAgIHRvb2w6IHQsXG4gICAgICBkYXRhOiBvLFxuICAgICAgaW5kZXg6IGksXG4gICAgICByZXBsYWNlOiAhMFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBJbnNlcnQgcGFzdGVkIGNvbnRlbnQuIENhbGwgb25QYXN0ZSBjYWxsYmFjayBhZnRlciBpbnNlcnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b29sTmFtZSAtIG5hbWUgb2YgVG9vbCB0byBpbnNlcnRcbiAgICogQHBhcmFtIHtQYXN0ZUV2ZW50fSBwYXN0ZUV2ZW50IC0gcGFzdGVkIGRhdGFcbiAgICogQHBhcmFtIHtib29sZWFufSByZXBsYWNlIC0gc2hvdWxkIHJlcGxhY2UgY3VycmVudCBibG9ja1xuICAgKi9cbiAgcGFzdGUoZSwgdCwgbyA9ICExKSB7XG4gICAgY29uc3QgaSA9IHRoaXMuaW5zZXJ0KHtcbiAgICAgIHRvb2w6IGUsXG4gICAgICByZXBsYWNlOiBvXG4gICAgfSk7XG4gICAgdHJ5IHtcbiAgICAgIHdpbmRvdy5yZXF1ZXN0SWRsZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgaS5jYWxsKEouT05fUEFTVEUsIHQpO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAocykge1xuICAgICAgSShgJHtlfTogb25QYXN0ZSBjYWxsYmFjayBjYWxsIGlzIGZhaWxlZGAsIFwiZXJyb3JcIiwgcyk7XG4gICAgfVxuICAgIHJldHVybiBpO1xuICB9XG4gIC8qKlxuICAgKiBJbnNlcnQgbmV3IGRlZmF1bHQgYmxvY2sgYXQgcGFzc2VkIGluZGV4XG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIGluZGV4IHdoZXJlIEJsb2NrIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG5lZWRUb0ZvY3VzIC0gaWYgdHJ1ZSwgdXBkYXRlcyBjdXJyZW50IEJsb2NrIGluZGV4XG4gICAqXG4gICAqIFRPRE86IFJlbW92ZSBtZXRob2QgYW5kIHVzZSBpbnNlcnQoKSB3aXRoIGluZGV4IGluc3RlYWQgKD8pXG4gICAqIEByZXR1cm5zIHtCbG9ja30gaW5zZXJ0ZWQgQmxvY2tcbiAgICovXG4gIGluc2VydERlZmF1bHRCbG9ja0F0SW5kZXgoZSwgdCA9ICExKSB7XG4gICAgY29uc3QgbyA9IHRoaXMuY29tcG9zZUJsb2NrKHsgdG9vbDogdGhpcy5jb25maWcuZGVmYXVsdEJsb2NrIH0pO1xuICAgIHJldHVybiB0aGlzLl9ibG9ja3NbZV0gPSBvLCB0aGlzLmJsb2NrRGlkTXV0YXRlZChUdCwgbywge1xuICAgICAgaW5kZXg6IGVcbiAgICB9KSwgdCA/IHRoaXMuY3VycmVudEJsb2NrSW5kZXggPSBlIDogZSA8PSB0aGlzLmN1cnJlbnRCbG9ja0luZGV4ICYmIHRoaXMuY3VycmVudEJsb2NrSW5kZXgrKywgbztcbiAgfVxuICAvKipcbiAgICogQWx3YXlzIGluc2VydHMgYXQgdGhlIGVuZFxuICAgKlxuICAgKiBAcmV0dXJucyB7QmxvY2t9XG4gICAqL1xuICBpbnNlcnRBdEVuZCgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50QmxvY2tJbmRleCA9IHRoaXMuYmxvY2tzLmxlbmd0aCAtIDEsIHRoaXMuaW5zZXJ0KCk7XG4gIH1cbiAgLyoqXG4gICAqIE1lcmdlIHR3byBibG9ja3NcbiAgICpcbiAgICogQHBhcmFtIHtCbG9ja30gdGFyZ2V0QmxvY2sgLSBwcmV2aW91cyBibG9jayB3aWxsIGJlIGFwcGVuZCB0byB0aGlzIGJsb2NrXG4gICAqIEBwYXJhbSB7QmxvY2t9IGJsb2NrVG9NZXJnZSAtIGJsb2NrIHRoYXQgd2lsbCBiZSBtZXJnZWQgd2l0aCB0YXJnZXQgYmxvY2tcbiAgICogQHJldHVybnMge1Byb21pc2V9IC0gdGhlIHNlcXVlbmNlIHRoYXQgY2FuIGJlIGNvbnRpbnVlZFxuICAgKi9cbiAgYXN5bmMgbWVyZ2VCbG9ja3MoZSwgdCkge1xuICAgIGxldCBvO1xuICAgIGlmIChlLm5hbWUgPT09IHQubmFtZSAmJiBlLm1lcmdlYWJsZSkge1xuICAgICAgY29uc3QgaSA9IGF3YWl0IHQuZGF0YTtcbiAgICAgIGlmIChYKGkpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDb3VsZCBub3QgbWVyZ2UgQmxvY2suIEZhaWxlZCB0byBleHRyYWN0IG9yaWdpbmFsIEJsb2NrIGRhdGEuXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBbc10gPSBudChbaV0sIGUudG9vbC5zYW5pdGl6ZUNvbmZpZyk7XG4gICAgICBvID0gcztcbiAgICB9IGVsc2UgaWYgKGUubWVyZ2VhYmxlICYmIExlKHQsIFwiZXhwb3J0XCIpICYmIExlKGUsIFwiaW1wb3J0XCIpKSB7XG4gICAgICBjb25zdCBpID0gYXdhaXQgdC5leHBvcnREYXRhQXNTdHJpbmcoKSwgcyA9IHEoaSwgZS50b29sLnNhbml0aXplQ29uZmlnKTtcbiAgICAgIG8gPSB3dChzLCBlLnRvb2wuY29udmVyc2lvbkNvbmZpZyk7XG4gICAgfVxuICAgIG8gIT09IHZvaWQgMCAmJiAoYXdhaXQgZS5tZXJnZVdpdGgobyksIHRoaXMucmVtb3ZlQmxvY2sodCksIHRoaXMuY3VycmVudEJsb2NrSW5kZXggPSB0aGlzLl9ibG9ja3MuaW5kZXhPZihlKSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBwYXNzZWQgQmxvY2tcbiAgICpcbiAgICogQHBhcmFtIGJsb2NrIC0gQmxvY2sgdG8gcmVtb3ZlXG4gICAqIEBwYXJhbSBhZGRMYXN0QmxvY2sgLSBpZiB0cnVlLCBhZGRzIG5ldyBkZWZhdWx0IGJsb2NrIGF0IHRoZSBlbmQuIEB0b2RvIHJlbW92ZSB0aGlzIGxvZ2ljIGFuZCB1c2UgZXZlbnQtYnVzIGluc3RlYWRcbiAgICovXG4gIHJlbW92ZUJsb2NrKGUsIHQgPSAhMCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgobykgPT4ge1xuICAgICAgY29uc3QgaSA9IHRoaXMuX2Jsb2Nrcy5pbmRleE9mKGUpO1xuICAgICAgaWYgKCF0aGlzLnZhbGlkYXRlSW5kZXgoaSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGZpbmQgYSBCbG9jayB0byByZW1vdmVcIik7XG4gICAgICBlLmRlc3Ryb3koKSwgdGhpcy5fYmxvY2tzLnJlbW92ZShpKSwgdGhpcy5ibG9ja0RpZE11dGF0ZWQoQnQsIGUsIHtcbiAgICAgICAgaW5kZXg6IGlcbiAgICAgIH0pLCB0aGlzLmN1cnJlbnRCbG9ja0luZGV4ID49IGkgJiYgdGhpcy5jdXJyZW50QmxvY2tJbmRleC0tLCB0aGlzLmJsb2Nrcy5sZW5ndGggPyBpID09PSAwICYmICh0aGlzLmN1cnJlbnRCbG9ja0luZGV4ID0gMCkgOiAodGhpcy51bnNldEN1cnJlbnRCbG9jaygpLCB0ICYmIHRoaXMuaW5zZXJ0KCkpLCBvKCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBvbmx5IHNlbGVjdGVkIEJsb2Nrc1xuICAgKiBhbmQgcmV0dXJucyBmaXJzdCBCbG9jayBpbmRleCB3aGVyZSBzdGFydGVkIHJlbW92aW5nLi4uXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgKi9cbiAgcmVtb3ZlU2VsZWN0ZWRCbG9ja3MoKSB7XG4gICAgbGV0IGU7XG4gICAgZm9yIChsZXQgdCA9IHRoaXMuYmxvY2tzLmxlbmd0aCAtIDE7IHQgPj0gMDsgdC0tKVxuICAgICAgdGhpcy5ibG9ja3NbdF0uc2VsZWN0ZWQgJiYgKHRoaXMucmVtb3ZlQmxvY2sodGhpcy5ibG9ja3NbdF0pLCBlID0gdCk7XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgLyoqXG4gICAqIEF0dGVudGlvbiFcbiAgICogQWZ0ZXIgcmVtb3ZpbmcgaW5zZXJ0IHRoZSBuZXcgZGVmYXVsdCB0eXBlZCBCbG9jayBhbmQgZm9jdXMgb24gaXRcbiAgICogUmVtb3ZlcyBhbGwgYmxvY2tzXG4gICAqL1xuICByZW1vdmVBbGxCbG9ja3MoKSB7XG4gICAgZm9yIChsZXQgZSA9IHRoaXMuYmxvY2tzLmxlbmd0aCAtIDE7IGUgPj0gMDsgZS0tKVxuICAgICAgdGhpcy5fYmxvY2tzLnJlbW92ZShlKTtcbiAgICB0aGlzLnVuc2V0Q3VycmVudEJsb2NrKCksIHRoaXMuaW5zZXJ0KCksIHRoaXMuY3VycmVudEJsb2NrLmZpcnN0SW5wdXQuZm9jdXMoKTtcbiAgfVxuICAvKipcbiAgICogU3BsaXQgY3VycmVudCBCbG9ja1xuICAgKiAxLiBFeHRyYWN0IGNvbnRlbnQgZnJvbSBDYXJldCBwb3NpdGlvbiB0byB0aGUgQmxvY2tgcyBlbmRcbiAgICogMi4gSW5zZXJ0IGEgbmV3IEJsb2NrIGJlbG93IGN1cnJlbnQgb25lIHdpdGggZXh0cmFjdGVkIGNvbnRlbnRcbiAgICpcbiAgICogQHJldHVybnMge0Jsb2NrfVxuICAgKi9cbiAgc3BsaXQoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuRWRpdG9yLkNhcmV0LmV4dHJhY3RGcmFnbWVudEZyb21DYXJldFBvc2l0aW9uKCksIHQgPSBkLm1ha2UoXCJkaXZcIik7XG4gICAgdC5hcHBlbmRDaGlsZChlKTtcbiAgICBjb25zdCBvID0ge1xuICAgICAgdGV4dDogZC5pc0VtcHR5KHQpID8gXCJcIiA6IHQuaW5uZXJIVE1MXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5pbnNlcnQoeyBkYXRhOiBvIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIEJsb2NrIGJ5IHBhc3NlZCBpbmRleFxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBpbmRleCB0byBnZXQuIC0xIHRvIGdldCBsYXN0XG4gICAqIEByZXR1cm5zIHtCbG9ja31cbiAgICovXG4gIGdldEJsb2NrQnlJbmRleChlKSB7XG4gICAgcmV0dXJuIGUgPT09IC0xICYmIChlID0gdGhpcy5fYmxvY2tzLmxlbmd0aCAtIDEpLCB0aGlzLl9ibG9ja3NbZV07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gaW5kZXggZm9yIHBhc3NlZCBCbG9ja1xuICAgKlxuICAgKiBAcGFyYW0gYmxvY2sgLSBibG9jayB0byBmaW5kIGluZGV4XG4gICAqL1xuICBnZXRCbG9ja0luZGV4KGUpIHtcbiAgICByZXR1cm4gdGhpcy5fYmxvY2tzLmluZGV4T2YoZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIEJsb2NrIGJ5IHBhc3NlZCBpZFxuICAgKlxuICAgKiBAcGFyYW0gaWQgLSBpZCBvZiBibG9jayB0byBnZXRcbiAgICogQHJldHVybnMge0Jsb2NrfVxuICAgKi9cbiAgZ2V0QmxvY2tCeUlkKGUpIHtcbiAgICByZXR1cm4gdGhpcy5fYmxvY2tzLmFycmF5LmZpbmQoKHQpID0+IHQuaWQgPT09IGUpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgQmxvY2sgaW5zdGFuY2UgYnkgaHRtbCBlbGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gZWxlbWVudCAtIGh0bWwgZWxlbWVudCB0byBnZXQgQmxvY2sgYnlcbiAgICovXG4gIGdldEJsb2NrKGUpIHtcbiAgICBkLmlzRWxlbWVudChlKSB8fCAoZSA9IGUucGFyZW50Tm9kZSk7XG4gICAgY29uc3QgdCA9IHRoaXMuX2Jsb2Nrcy5ub2RlcywgbyA9IGUuY2xvc2VzdChgLiR7RC5DU1Mud3JhcHBlcn1gKSwgaSA9IHQuaW5kZXhPZihvKTtcbiAgICBpZiAoaSA+PSAwKVxuICAgICAgcmV0dXJuIHRoaXMuX2Jsb2Nrc1tpXTtcbiAgfVxuICAvKipcbiAgICogMSkgRmluZCBmaXJzdC1sZXZlbCBCbG9jayBmcm9tIHBhc3NlZCBjaGlsZCBOb2RlXG4gICAqIDIpIE1hcmsgaXQgYXMgY3VycmVudFxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IGNoaWxkTm9kZSAtIGxvb2sgYWhlYWQgZnJvbSB0aGlzIG5vZGUuXG4gICAqIEByZXR1cm5zIHtCbG9jayB8IHVuZGVmaW5lZH0gY2FuIHJldHVybiB1bmRlZmluZWQgaW4gY2FzZSB3aGVuIHRoZSBwYXNzZWQgY2hpbGQgbm90ZSBpcyBub3QgYSBwYXJ0IG9mIHRoZSBjdXJyZW50IGVkaXRvciBpbnN0YW5jZVxuICAgKi9cbiAgc2V0Q3VycmVudEJsb2NrQnlDaGlsZE5vZGUoZSkge1xuICAgIGQuaXNFbGVtZW50KGUpIHx8IChlID0gZS5wYXJlbnROb2RlKTtcbiAgICBjb25zdCB0ID0gZS5jbG9zZXN0KGAuJHtELkNTUy53cmFwcGVyfWApO1xuICAgIGlmICghdClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBvID0gdC5jbG9zZXN0KGAuJHt0aGlzLkVkaXRvci5VSS5DU1MuZWRpdG9yV3JhcHBlcn1gKTtcbiAgICBpZiAobyAhPSBudWxsICYmIG8uaXNFcXVhbE5vZGUodGhpcy5FZGl0b3IuVUkubm9kZXMud3JhcHBlcikpXG4gICAgICByZXR1cm4gdGhpcy5jdXJyZW50QmxvY2tJbmRleCA9IHRoaXMuX2Jsb2Nrcy5ub2Rlcy5pbmRleE9mKHQpLCB0aGlzLmN1cnJlbnRCbG9jay51cGRhdGVDdXJyZW50SW5wdXQoKSwgdGhpcy5jdXJyZW50QmxvY2s7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBibG9jayB3aGljaCBjb250ZW50cyBwYXNzZWQgbm9kZVxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IGNoaWxkTm9kZSAtIG5vZGUgdG8gZ2V0IEJsb2NrIGJ5XG4gICAqIEByZXR1cm5zIHtCbG9ja31cbiAgICovXG4gIGdldEJsb2NrQnlDaGlsZE5vZGUoZSkge1xuICAgIGlmICghZSB8fCAhKGUgaW5zdGFuY2VvZiBOb2RlKSlcbiAgICAgIHJldHVybjtcbiAgICBkLmlzRWxlbWVudChlKSB8fCAoZSA9IGUucGFyZW50Tm9kZSk7XG4gICAgY29uc3QgdCA9IGUuY2xvc2VzdChgLiR7RC5DU1Mud3JhcHBlcn1gKTtcbiAgICByZXR1cm4gdGhpcy5ibG9ja3MuZmluZCgobykgPT4gby5ob2xkZXIgPT09IHQpO1xuICB9XG4gIC8qKlxuICAgKiBTd2FwIEJsb2NrcyBQb3NpdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IC0gaW5kZXggb2YgZmlyc3QgYmxvY2tcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRvSW5kZXggLSBpbmRleCBvZiBzZWNvbmQgYmxvY2tcbiAgICogQGRlcHJlY2F0ZWQg4oCUIHVzZSAnbW92ZScgaW5zdGVhZFxuICAgKi9cbiAgc3dhcChlLCB0KSB7XG4gICAgdGhpcy5fYmxvY2tzLnN3YXAoZSwgdCksIHRoaXMuY3VycmVudEJsb2NrSW5kZXggPSB0O1xuICB9XG4gIC8qKlxuICAgKiBNb3ZlIGEgYmxvY2sgdG8gYSBuZXcgaW5kZXhcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRvSW5kZXggLSBpbmRleCB3aGVyZSB0byBtb3ZlIEJsb2NrXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggLSBpbmRleCBvZiBCbG9jayB0byBtb3ZlXG4gICAqL1xuICBtb3ZlKGUsIHQgPSB0aGlzLmN1cnJlbnRCbG9ja0luZGV4KSB7XG4gICAgaWYgKGlzTmFOKGUpIHx8IGlzTmFOKHQpKSB7XG4gICAgICBJKFwiV2FybmluZyBkdXJpbmcgJ21vdmUnIGNhbGw6IGluY29ycmVjdCBpbmRpY2VzIHByb3ZpZGVkLlwiLCBcIndhcm5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy52YWxpZGF0ZUluZGV4KGUpIHx8ICF0aGlzLnZhbGlkYXRlSW5kZXgodCkpIHtcbiAgICAgIEkoXCJXYXJuaW5nIGR1cmluZyAnbW92ZScgY2FsbDogaW5kaWNlcyBjYW5ub3QgYmUgbG93ZXIgdGhhbiAwIG9yIGdyZWF0ZXIgdGhhbiB0aGUgYW1vdW50IG9mIGJsb2Nrcy5cIiwgXCJ3YXJuXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9ibG9ja3MubW92ZShlLCB0KSwgdGhpcy5jdXJyZW50QmxvY2tJbmRleCA9IGUsIHRoaXMuYmxvY2tEaWRNdXRhdGVkKEppLCB0aGlzLmN1cnJlbnRCbG9jaywge1xuICAgICAgZnJvbUluZGV4OiB0LFxuICAgICAgdG9JbmRleDogZVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyBwYXNzZWQgQmxvY2sgdG8gdGhlIG5ldyBUb29sXG4gICAqIFVzZXMgQ29udmVyc2lvbiBDb25maWdcbiAgICpcbiAgICogQHBhcmFtIGJsb2NrVG9Db252ZXJ0IC0gQmxvY2sgdGhhdCBzaG91bGQgYmUgY29udmVydGVkXG4gICAqIEBwYXJhbSB0YXJnZXRUb29sTmFtZSAtIG5hbWUgb2YgdGhlIFRvb2wgdG8gY29udmVydCB0b1xuICAgKiBAcGFyYW0gYmxvY2tEYXRhT3ZlcnJpZGVzIC0gb3B0aW9uYWwgbmV3IEJsb2NrIGRhdGEgb3ZlcnJpZGVzXG4gICAqL1xuICBhc3luYyBjb252ZXJ0KGUsIHQsIG8pIHtcbiAgICBpZiAoIWF3YWl0IGUuc2F2ZSgpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGNvbnZlcnQgQmxvY2suIEZhaWxlZCB0byBleHRyYWN0IG9yaWdpbmFsIEJsb2NrIGRhdGEuXCIpO1xuICAgIGNvbnN0IHMgPSB0aGlzLkVkaXRvci5Ub29scy5ibG9ja1Rvb2xzLmdldCh0KTtcbiAgICBpZiAoIXMpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBjb252ZXJ0IEJsb2NrLiBUb29sIMKrJHt0fcK7IG5vdCBmb3VuZC5gKTtcbiAgICBjb25zdCByID0gYXdhaXQgZS5leHBvcnREYXRhQXNTdHJpbmcoKSwgbCA9IHEoXG4gICAgICByLFxuICAgICAgcy5zYW5pdGl6ZUNvbmZpZ1xuICAgICk7XG4gICAgbGV0IGEgPSB3dChsLCBzLmNvbnZlcnNpb25Db25maWcpO1xuICAgIHJldHVybiBvICYmIChhID0gT2JqZWN0LmFzc2lnbihhLCBvKSksIHRoaXMucmVwbGFjZShlLCBzLm5hbWUsIGEpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIGN1cnJlbnQgQmxvY2sgSW5kZXggLTEgd2hpY2ggbWVhbnMgdW5rbm93blxuICAgKiBhbmQgY2xlYXIgaGlnaGxpZ2h0c1xuICAgKi9cbiAgdW5zZXRDdXJyZW50QmxvY2soKSB7XG4gICAgdGhpcy5jdXJyZW50QmxvY2tJbmRleCA9IC0xO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhcnMgRWRpdG9yXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gbmVlZFRvQWRkRGVmYXVsdEJsb2NrIC0gMSkgaW4gaW50ZXJuYWwgY2FsbHMgKGZvciBleGFtcGxlLCBpbiBhcGkuYmxvY2tzLnJlbmRlcilcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ZSBkb24ndCBuZWVkIHRvIGFkZCBhbiBlbXB0eSBkZWZhdWx0IGJsb2NrXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDIpIGluIGFwaS5ibG9ja3MuY2xlYXIgd2Ugc2hvdWxkIGFkZCBlbXB0eSBibG9ja1xuICAgKi9cbiAgYXN5bmMgY2xlYXIoZSA9ICExKSB7XG4gICAgY29uc3QgdCA9IG5ldyBRaSgpO1xuICAgIHRoaXMuYmxvY2tzLmZvckVhY2goKG8pID0+IHtcbiAgICAgIHQuYWRkKGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgdGhpcy5yZW1vdmVCbG9jayhvLCAhMSk7XG4gICAgICB9KTtcbiAgICB9KSwgYXdhaXQgdC5jb21wbGV0ZWQsIHRoaXMudW5zZXRDdXJyZW50QmxvY2soKSwgZSAmJiB0aGlzLmluc2VydCgpLCB0aGlzLkVkaXRvci5VSS5jaGVja0VtcHRpbmVzcygpO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhbnMgdXAgYWxsIHRoZSBibG9jayB0b29scycgcmVzb3VyY2VzXG4gICAqIFRoaXMgaXMgY2FsbGVkIHdoZW4gZWRpdG9yIGlzIGRlc3Ryb3llZFxuICAgKi9cbiAgYXN5bmMgZGVzdHJveSgpIHtcbiAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmJsb2Nrcy5tYXAoKGUpID0+IGUuZGVzdHJveSgpKSk7XG4gIH1cbiAgLyoqXG4gICAqIEJpbmQgQmxvY2sgZXZlbnRzXG4gICAqXG4gICAqIEBwYXJhbSB7QmxvY2t9IGJsb2NrIC0gQmxvY2sgdG8gd2hpY2ggZXZlbnQgc2hvdWxkIGJlIGJvdW5kXG4gICAqL1xuICBiaW5kQmxvY2tFdmVudHMoZSkge1xuICAgIGNvbnN0IHsgQmxvY2tFdmVudHM6IHQgfSA9IHRoaXMuRWRpdG9yO1xuICAgIHRoaXMucmVhZE9ubHlNdXRhYmxlTGlzdGVuZXJzLm9uKGUuaG9sZGVyLCBcImtleWRvd25cIiwgKG8pID0+IHtcbiAgICAgIHQua2V5ZG93bihvKTtcbiAgICB9KSwgdGhpcy5yZWFkT25seU11dGFibGVMaXN0ZW5lcnMub24oZS5ob2xkZXIsIFwia2V5dXBcIiwgKG8pID0+IHtcbiAgICAgIHQua2V5dXAobyk7XG4gICAgfSksIHRoaXMucmVhZE9ubHlNdXRhYmxlTGlzdGVuZXJzLm9uKGUuaG9sZGVyLCBcImRyYWdvdmVyXCIsIChvKSA9PiB7XG4gICAgICB0LmRyYWdPdmVyKG8pO1xuICAgIH0pLCB0aGlzLnJlYWRPbmx5TXV0YWJsZUxpc3RlbmVycy5vbihlLmhvbGRlciwgXCJkcmFnbGVhdmVcIiwgKG8pID0+IHtcbiAgICAgIHQuZHJhZ0xlYXZlKG8pO1xuICAgIH0pLCBlLm9uKFwiZGlkTXV0YXRlZFwiLCAobykgPT4gdGhpcy5ibG9ja0RpZE11dGF0ZWQoQ3QsIG8sIHtcbiAgICAgIGluZGV4OiB0aGlzLmdldEJsb2NrSW5kZXgobylcbiAgICB9KSk7XG4gIH1cbiAgLyoqXG4gICAqIERpc2FibGUgbXV0YWJsZSBoYW5kbGVycyBhbmQgYmluZGluZ3NcbiAgICovXG4gIGRpc2FibGVNb2R1bGVCaW5kaW5ncygpIHtcbiAgICB0aGlzLnJlYWRPbmx5TXV0YWJsZUxpc3RlbmVycy5jbGVhckFsbCgpO1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGVzIGFsbCBtb2R1bGUgaGFuZGxlcnMgYW5kIGJpbmRpbmdzIGZvciBhbGwgQmxvY2tzXG4gICAqL1xuICBlbmFibGVNb2R1bGVCaW5kaW5ncygpIHtcbiAgICB0aGlzLnJlYWRPbmx5TXV0YWJsZUxpc3RlbmVycy5vbihcbiAgICAgIGRvY3VtZW50LFxuICAgICAgXCJjdXRcIixcbiAgICAgIChlKSA9PiB0aGlzLkVkaXRvci5CbG9ja0V2ZW50cy5oYW5kbGVDb21tYW5kWChlKVxuICAgICksIHRoaXMuYmxvY2tzLmZvckVhY2goKGUpID0+IHtcbiAgICAgIHRoaXMuYmluZEJsb2NrRXZlbnRzKGUpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhhdCB0aGUgZ2l2ZW4gaW5kZXggaXMgbm90IGxvd2VyIHRoYW4gMCBvciBoaWdoZXIgdGhhbiB0aGUgYW1vdW50IG9mIGJsb2Nrc1xuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBpbmRleCBvZiBibG9ja3MgYXJyYXkgdG8gdmFsaWRhdGVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICB2YWxpZGF0ZUluZGV4KGUpIHtcbiAgICByZXR1cm4gIShlIDwgMCB8fCBlID49IHRoaXMuX2Jsb2Nrcy5sZW5ndGgpO1xuICB9XG4gIC8qKlxuICAgKiBCbG9jayBtdXRhdGlvbiBjYWxsYmFja1xuICAgKlxuICAgKiBAcGFyYW0gbXV0YXRpb25UeXBlIC0gd2hhdCBoYXBwZW5lZCB3aXRoIGJsb2NrXG4gICAqIEBwYXJhbSBibG9jayAtIG11dGF0ZWQgYmxvY2tcbiAgICogQHBhcmFtIGRldGFpbERhdGEgLSBhZGRpdGlvbmFsIGRhdGEgdG8gcGFzcyB3aXRoIGNoYW5nZSBldmVudFxuICAgKi9cbiAgYmxvY2tEaWRNdXRhdGVkKGUsIHQsIG8pIHtcbiAgICBjb25zdCBpID0gbmV3IEN1c3RvbUV2ZW50KGUsIHtcbiAgICAgIGRldGFpbDoge1xuICAgICAgICB0YXJnZXQ6IG5ldyBHKHQpLFxuICAgICAgICAuLi5vXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuZXZlbnRzRGlzcGF0Y2hlci5lbWl0KFB0LCB7XG4gICAgICBldmVudDogaVxuICAgIH0pLCB0O1xuICB9XG59XG5jbGFzcyB0cyBleHRlbmRzIHkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLmFueUJsb2NrU2VsZWN0ZWRDYWNoZSA9IG51bGwsIHRoaXMubmVlZFRvU2VsZWN0QWxsID0gITEsIHRoaXMubmF0aXZlSW5wdXRTZWxlY3RlZCA9ICExLCB0aGlzLnJlYWR5VG9CbG9ja1NlbGVjdGlvbiA9ICExO1xuICB9XG4gIC8qKlxuICAgKiBTYW5pdGl6ZXIgQ29uZmlnXG4gICAqXG4gICAqIEByZXR1cm5zIHtTYW5pdGl6ZXJDb25maWd9XG4gICAqL1xuICBnZXQgc2FuaXRpemVyQ29uZmlnKCkge1xuICAgIHJldHVybiB7XG4gICAgICBwOiB7fSxcbiAgICAgIGgxOiB7fSxcbiAgICAgIGgyOiB7fSxcbiAgICAgIGgzOiB7fSxcbiAgICAgIGg0OiB7fSxcbiAgICAgIGg1OiB7fSxcbiAgICAgIGg2OiB7fSxcbiAgICAgIG9sOiB7fSxcbiAgICAgIHVsOiB7fSxcbiAgICAgIGxpOiB7fSxcbiAgICAgIGJyOiAhMCxcbiAgICAgIGltZzoge1xuICAgICAgICBzcmM6ICEwLFxuICAgICAgICB3aWR0aDogITAsXG4gICAgICAgIGhlaWdodDogITBcbiAgICAgIH0sXG4gICAgICBhOiB7XG4gICAgICAgIGhyZWY6ICEwXG4gICAgICB9LFxuICAgICAgYjoge30sXG4gICAgICBpOiB7fSxcbiAgICAgIHU6IHt9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogRmxhZyB0aGF0IGlkZW50aWZpZXMgYWxsIEJsb2NrcyBzZWxlY3Rpb25cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgYWxsQmxvY2tzU2VsZWN0ZWQoKSB7XG4gICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IGUgfSA9IHRoaXMuRWRpdG9yO1xuICAgIHJldHVybiBlLmJsb2Nrcy5ldmVyeSgodCkgPT4gdC5zZWxlY3RlZCA9PT0gITApO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgc2VsZWN0ZWQgYWxsIGJsb2Nrc1xuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHN0YXRlIC0gc3RhdGUgdG8gc2V0XG4gICAqL1xuICBzZXQgYWxsQmxvY2tzU2VsZWN0ZWQoZSkge1xuICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiB0IH0gPSB0aGlzLkVkaXRvcjtcbiAgICB0LmJsb2Nrcy5mb3JFYWNoKChvKSA9PiB7XG4gICAgICBvLnNlbGVjdGVkID0gZTtcbiAgICB9KSwgdGhpcy5jbGVhckNhY2hlKCk7XG4gIH1cbiAgLyoqXG4gICAqIEZsYWcgdGhhdCBpZGVudGlmaWVzIGFueSBCbG9jayBzZWxlY3Rpb25cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgYW55QmxvY2tTZWxlY3RlZCgpIHtcbiAgICBjb25zdCB7IEJsb2NrTWFuYWdlcjogZSB9ID0gdGhpcy5FZGl0b3I7XG4gICAgcmV0dXJuIHRoaXMuYW55QmxvY2tTZWxlY3RlZENhY2hlID09PSBudWxsICYmICh0aGlzLmFueUJsb2NrU2VsZWN0ZWRDYWNoZSA9IGUuYmxvY2tzLnNvbWUoKHQpID0+IHQuc2VsZWN0ZWQgPT09ICEwKSksIHRoaXMuYW55QmxvY2tTZWxlY3RlZENhY2hlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gc2VsZWN0ZWQgQmxvY2tzIGFycmF5XG4gICAqXG4gICAqIEByZXR1cm5zIHtCbG9ja1tdfVxuICAgKi9cbiAgZ2V0IHNlbGVjdGVkQmxvY2tzKCkge1xuICAgIHJldHVybiB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuYmxvY2tzLmZpbHRlcigoZSkgPT4gZS5zZWxlY3RlZCk7XG4gIH1cbiAgLyoqXG4gICAqIE1vZHVsZSBQcmVwYXJhdGlvblxuICAgKiBSZWdpc3RlcnMgU2hvcnRjdXRzIENNRCtBIGFuZCBDTUQrQ1xuICAgKiB0byBzZWxlY3QgYWxsIGFuZCBjb3B5IHRoZW1cbiAgICovXG4gIHByZXBhcmUoKSB7XG4gICAgdGhpcy5zZWxlY3Rpb24gPSBuZXcgYigpLCBkZS5hZGQoe1xuICAgICAgbmFtZTogXCJDTUQrQVwiLFxuICAgICAgaGFuZGxlcjogKGUpID0+IHtcbiAgICAgICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IHQsIFJlYWRPbmx5OiBvIH0gPSB0aGlzLkVkaXRvcjtcbiAgICAgICAgaWYgKG8uaXNFbmFibGVkKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLnNlbGVjdEFsbEJsb2NrcygpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0LmN1cnJlbnRCbG9jayAmJiB0aGlzLmhhbmRsZUNvbW1hbmRBKGUpO1xuICAgICAgfSxcbiAgICAgIG9uOiB0aGlzLkVkaXRvci5VSS5ub2Rlcy5yZWRhY3RvclxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBUb2dnbGUgcmVhZC1vbmx5IHN0YXRlXG4gICAqXG4gICAqICAtIFJlbW92ZSBhbGwgcmFuZ2VzXG4gICAqICAtIFVuc2VsZWN0IGFsbCBCbG9ja3NcbiAgICovXG4gIHRvZ2dsZVJlYWRPbmx5KCkge1xuICAgIGIuZ2V0KCkucmVtb3ZlQWxsUmFuZ2VzKCksIHRoaXMuYWxsQmxvY2tzU2VsZWN0ZWQgPSAhMTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIHNlbGVjdGlvbiBvZiBCbG9ja1xuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcj99IGluZGV4IC0gQmxvY2sgaW5kZXggYWNjb3JkaW5nIHRvIHRoZSBCbG9ja01hbmFnZXIncyBpbmRleGVzXG4gICAqL1xuICB1blNlbGVjdEJsb2NrQnlJbmRleChlKSB7XG4gICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IHQgfSA9IHRoaXMuRWRpdG9yO1xuICAgIGxldCBvO1xuICAgIGlzTmFOKGUpID8gbyA9IHQuY3VycmVudEJsb2NrIDogbyA9IHQuZ2V0QmxvY2tCeUluZGV4KGUpLCBvLnNlbGVjdGVkID0gITEsIHRoaXMuY2xlYXJDYWNoZSgpO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhciBzZWxlY3Rpb24gZnJvbSBCbG9ja3NcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gcmVhc29uIC0gZXZlbnQgY2F1c2VkIGNsZWFyIG9mIHNlbGVjdGlvblxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlc3RvcmVTZWxlY3Rpb24gLSBpZiB0cnVlLCByZXN0b3JlIHNhdmVkIHNlbGVjdGlvblxuICAgKi9cbiAgY2xlYXJTZWxlY3Rpb24oZSwgdCA9ICExKSB7XG4gICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IG8sIENhcmV0OiBpLCBSZWN0YW5nbGVTZWxlY3Rpb246IHMgfSA9IHRoaXMuRWRpdG9yO1xuICAgIHRoaXMubmVlZFRvU2VsZWN0QWxsID0gITEsIHRoaXMubmF0aXZlSW5wdXRTZWxlY3RlZCA9ICExLCB0aGlzLnJlYWR5VG9CbG9ja1NlbGVjdGlvbiA9ICExO1xuICAgIGNvbnN0IHIgPSBlICYmIGUgaW5zdGFuY2VvZiBLZXlib2FyZEV2ZW50LCBsID0gciAmJiBJdChlLmtleUNvZGUpO1xuICAgIGlmICh0aGlzLmFueUJsb2NrU2VsZWN0ZWQgJiYgciAmJiBsICYmICFiLmlzU2VsZWN0aW9uRXhpc3RzKSB7XG4gICAgICBjb25zdCBhID0gby5yZW1vdmVTZWxlY3RlZEJsb2NrcygpO1xuICAgICAgby5pbnNlcnREZWZhdWx0QmxvY2tBdEluZGV4KGEsICEwKSwgaS5zZXRUb0Jsb2NrKG8uY3VycmVudEJsb2NrKSwgQWUoKCkgPT4ge1xuICAgICAgICBjb25zdCBjID0gZS5rZXk7XG4gICAgICAgIGkuaW5zZXJ0Q29udGVudEF0Q2FyZXRQb3NpdGlvbihjLmxlbmd0aCA+IDEgPyBcIlwiIDogYyk7XG4gICAgICB9LCAyMCkoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuRWRpdG9yLkNyb3NzQmxvY2tTZWxlY3Rpb24uY2xlYXIoZSksICF0aGlzLmFueUJsb2NrU2VsZWN0ZWQgfHwgcy5pc1JlY3RBY3RpdmF0ZWQoKSkge1xuICAgICAgdGhpcy5FZGl0b3IuUmVjdGFuZ2xlU2VsZWN0aW9uLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHQgJiYgdGhpcy5zZWxlY3Rpb24ucmVzdG9yZSgpLCB0aGlzLmFsbEJsb2Nrc1NlbGVjdGVkID0gITE7XG4gIH1cbiAgLyoqXG4gICAqIFJlZHVjZSBlYWNoIEJsb2NrIGFuZCBjb3B5IGl0cyBjb250ZW50XG4gICAqXG4gICAqIEBwYXJhbSB7Q2xpcGJvYXJkRXZlbnR9IGUgLSBjb3B5L2N1dCBldmVudFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICovXG4gIGNvcHlTZWxlY3RlZEJsb2NrcyhlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IHQgPSBkLm1ha2UoXCJkaXZcIik7XG4gICAgdGhpcy5zZWxlY3RlZEJsb2Nrcy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICBjb25zdCByID0gcShzLmhvbGRlci5pbm5lckhUTUwsIHRoaXMuc2FuaXRpemVyQ29uZmlnKSwgbCA9IGQubWFrZShcInBcIik7XG4gICAgICBsLmlubmVySFRNTCA9IHIsIHQuYXBwZW5kQ2hpbGQobCk7XG4gICAgfSk7XG4gICAgY29uc3QgbyA9IEFycmF5LmZyb20odC5jaGlsZE5vZGVzKS5tYXAoKHMpID0+IHMudGV4dENvbnRlbnQpLmpvaW4oYFxuXG5gKSwgaSA9IHQuaW5uZXJIVE1MO1xuICAgIHJldHVybiBlLmNsaXBib2FyZERhdGEuc2V0RGF0YShcInRleHQvcGxhaW5cIiwgbyksIGUuY2xpcGJvYXJkRGF0YS5zZXREYXRhKFwidGV4dC9odG1sXCIsIGkpLCBQcm9taXNlLmFsbCh0aGlzLnNlbGVjdGVkQmxvY2tzLm1hcCgocykgPT4gcy5zYXZlKCkpKS50aGVuKChzKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBlLmNsaXBib2FyZERhdGEuc2V0RGF0YSh0aGlzLkVkaXRvci5QYXN0ZS5NSU1FX1RZUEUsIEpTT04uc3RyaW5naWZ5KHMpKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTZWxlY3QgQmxvY2sgYnkgaXRzIGluZGV4XG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyP30gaW5kZXggLSBCbG9jayBpbmRleCBhY2NvcmRpbmcgdG8gdGhlIEJsb2NrTWFuYWdlcidzIGluZGV4ZXNcbiAgICovXG4gIHNlbGVjdEJsb2NrQnlJbmRleChlKSB7XG4gICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IHQgfSA9IHRoaXMuRWRpdG9yLCBvID0gdC5nZXRCbG9ja0J5SW5kZXgoZSk7XG4gICAgbyAhPT0gdm9pZCAwICYmIHRoaXMuc2VsZWN0QmxvY2sobyk7XG4gIH1cbiAgLyoqXG4gICAqIFNlbGVjdCBwYXNzZWQgQmxvY2tcbiAgICpcbiAgICogQHBhcmFtIHtCbG9ja30gYmxvY2sgLSBCbG9jayB0byBzZWxlY3RcbiAgICovXG4gIHNlbGVjdEJsb2NrKGUpIHtcbiAgICB0aGlzLnNlbGVjdGlvbi5zYXZlKCksIGIuZ2V0KCkucmVtb3ZlQWxsUmFuZ2VzKCksIGUuc2VsZWN0ZWQgPSAhMCwgdGhpcy5jbGVhckNhY2hlKCksIHRoaXMuRWRpdG9yLklubGluZVRvb2xiYXIuY2xvc2UoKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIHNlbGVjdGlvbiBmcm9tIHBhc3NlZCBCbG9ja1xuICAgKlxuICAgKiBAcGFyYW0ge0Jsb2NrfSBibG9jayAtIEJsb2NrIHRvIHVuc2VsZWN0XG4gICAqL1xuICB1bnNlbGVjdEJsb2NrKGUpIHtcbiAgICBlLnNlbGVjdGVkID0gITEsIHRoaXMuY2xlYXJDYWNoZSgpO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhciBhbnlCbG9ja1NlbGVjdGVkIGNhY2hlXG4gICAqL1xuICBjbGVhckNhY2hlKCkge1xuICAgIHRoaXMuYW55QmxvY2tTZWxlY3RlZENhY2hlID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogTW9kdWxlIGRlc3RydWN0aW9uXG4gICAqIERlLXJlZ2lzdGVycyBTaG9ydGN1dCBDTUQrQVxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICBkZS5yZW1vdmUodGhpcy5FZGl0b3IuVUkubm9kZXMucmVkYWN0b3IsIFwiQ01EK0FcIik7XG4gIH1cbiAgLyoqXG4gICAqIEZpcnN0IENNRCtBIHNlbGVjdHMgYWxsIGlucHV0IGNvbnRlbnQgYnkgbmF0aXZlIGJlaGF2aW91cixcbiAgICogbmV4dCBDTUQrQSBrZXlwcmVzcyBzZWxlY3RzIGFsbCBibG9ja3NcbiAgICpcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudCAtIGtleWJvYXJkIGV2ZW50XG4gICAqL1xuICBoYW5kbGVDb21tYW5kQShlKSB7XG4gICAgaWYgKHRoaXMuRWRpdG9yLlJlY3RhbmdsZVNlbGVjdGlvbi5jbGVhclNlbGVjdGlvbigpLCBkLmlzTmF0aXZlSW5wdXQoZS50YXJnZXQpICYmICF0aGlzLnJlYWR5VG9CbG9ja1NlbGVjdGlvbikge1xuICAgICAgdGhpcy5yZWFkeVRvQmxvY2tTZWxlY3Rpb24gPSAhMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdCA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5nZXRCbG9jayhlLnRhcmdldCksIG8gPSB0LmlucHV0cztcbiAgICBpZiAoby5sZW5ndGggPiAxICYmICF0aGlzLnJlYWR5VG9CbG9ja1NlbGVjdGlvbikge1xuICAgICAgdGhpcy5yZWFkeVRvQmxvY2tTZWxlY3Rpb24gPSAhMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG8ubGVuZ3RoID09PSAxICYmICF0aGlzLm5lZWRUb1NlbGVjdEFsbCkge1xuICAgICAgdGhpcy5uZWVkVG9TZWxlY3RBbGwgPSAhMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5uZWVkVG9TZWxlY3RBbGwgPyAoZS5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLnNlbGVjdEFsbEJsb2NrcygpLCB0aGlzLm5lZWRUb1NlbGVjdEFsbCA9ICExLCB0aGlzLnJlYWR5VG9CbG9ja1NlbGVjdGlvbiA9ICExKSA6IHRoaXMucmVhZHlUb0Jsb2NrU2VsZWN0aW9uICYmIChlLnByZXZlbnREZWZhdWx0KCksIHRoaXMuc2VsZWN0QmxvY2sodCksIHRoaXMubmVlZFRvU2VsZWN0QWxsID0gITApO1xuICB9XG4gIC8qKlxuICAgKiBTZWxlY3QgQWxsIEJsb2Nrc1xuICAgKiBFYWNoIEJsb2NrIGhhcyBzZWxlY3RlZCBzZXR0ZXIgdGhhdCBtYWtlcyBCbG9jayBjb3B5YWJsZVxuICAgKi9cbiAgc2VsZWN0QWxsQmxvY2tzKCkge1xuICAgIHRoaXMuc2VsZWN0aW9uLnNhdmUoKSwgYi5nZXQoKS5yZW1vdmVBbGxSYW5nZXMoKSwgdGhpcy5hbGxCbG9ja3NTZWxlY3RlZCA9ICEwLCB0aGlzLkVkaXRvci5JbmxpbmVUb29sYmFyLmNsb3NlKCk7XG4gIH1cbn1cbmNsYXNzIERlIGV4dGVuZHMgeSB7XG4gIC8qKlxuICAgKiBBbGxvd2VkIGNhcmV0IHBvc2l0aW9ucyBpbiBpbnB1dFxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEByZXR1cm5zIHt7U1RBUlQ6IHN0cmluZywgRU5EOiBzdHJpbmcsIERFRkFVTFQ6IHN0cmluZ319XG4gICAqL1xuICBnZXQgcG9zaXRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBTVEFSVDogXCJzdGFydFwiLFxuICAgICAgRU5EOiBcImVuZFwiLFxuICAgICAgREVGQVVMVDogXCJkZWZhdWx0XCJcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBFbGVtZW50cyBzdHlsZXMgdGhhdCBjYW4gYmUgdXNlZnVsIGZvciBDYXJldCBNb2R1bGVcbiAgICovXG4gIHN0YXRpYyBnZXQgQ1NTKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzaGFkb3dDYXJldDogXCJjZHgtc2hhZG93LWNhcmV0XCJcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBNZXRob2QgZ2V0cyBCbG9jayBpbnN0YW5jZSBhbmQgcHV0cyBjYXJldCB0byB0aGUgdGV4dCBub2RlIHdpdGggb2Zmc2V0XG4gICAqIFRoZXJlIHR3byB3YXlzIHRoYXQgbWV0aG9kIGFwcGxpZXMgY2FyZXQgcG9zaXRpb246XG4gICAqICAgLSBmaXJzdCBmb3VuZCB0ZXh0IG5vZGU6IHNldHMgYXQgdGhlIGJlZ2lubmluZywgYnV0IHlvdSBjYW4gcGFzcyBhbiBvZmZzZXRcbiAgICogICAtIGxhc3QgZm91bmQgdGV4dCBub2RlOiBzZXRzIGF0IHRoZSBlbmQgb2YgdGhlIG5vZGUuIEFsc28sIHlvdSBjYW4gY3VzdG9taXplIHRoZSBiZWhhdmlvdXJcbiAgICpcbiAgICogQHBhcmFtIHtCbG9ja30gYmxvY2sgLSBCbG9jayBjbGFzc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcG9zaXRpb24gLSBwb3NpdGlvbiB3aGVyZSB0byBzZXQgY2FyZXQuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIGRlZmF1bHQgLSBsZWF2ZSBkZWZhdWx0IGJlaGF2aW91ciBhbmQgYXBwbHkgb2Zmc2V0IGlmIGl0J3MgcGFzc2VkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgLSBjYXJldCBvZmZzZXQgcmVnYXJkaW5nIHRvIHRoZSB0ZXh0IG5vZGVcbiAgICovXG4gIHNldFRvQmxvY2soZSwgdCA9IHRoaXMucG9zaXRpb25zLkRFRkFVTFQsIG8gPSAwKSB7XG4gICAgdmFyIGM7XG4gICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IGksIEJsb2NrU2VsZWN0aW9uOiBzIH0gPSB0aGlzLkVkaXRvcjtcbiAgICBpZiAocy5jbGVhclNlbGVjdGlvbigpLCAhZS5mb2N1c2FibGUpIHtcbiAgICAgIChjID0gd2luZG93LmdldFNlbGVjdGlvbigpKSA9PSBudWxsIHx8IGMucmVtb3ZlQWxsUmFuZ2VzKCksIHMuc2VsZWN0QmxvY2soZSksIGkuY3VycmVudEJsb2NrID0gZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHI7XG4gICAgc3dpdGNoICh0KSB7XG4gICAgICBjYXNlIHRoaXMucG9zaXRpb25zLlNUQVJUOlxuICAgICAgICByID0gZS5maXJzdElucHV0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdGhpcy5wb3NpdGlvbnMuRU5EOlxuICAgICAgICByID0gZS5sYXN0SW5wdXQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgciA9IGUuY3VycmVudElucHV0O1xuICAgIH1cbiAgICBpZiAoIXIpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbCA9IGQuZ2V0RGVlcGVzdE5vZGUociwgdCA9PT0gdGhpcy5wb3NpdGlvbnMuRU5EKSwgYSA9IGQuZ2V0Q29udGVudExlbmd0aChsKTtcbiAgICBzd2l0Y2ggKCEwKSB7XG4gICAgICBjYXNlIHQgPT09IHRoaXMucG9zaXRpb25zLlNUQVJUOlxuICAgICAgICBvID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHQgPT09IHRoaXMucG9zaXRpb25zLkVORDpcbiAgICAgIGNhc2UgbyA+IGE6XG4gICAgICAgIG8gPSBhO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdGhpcy5zZXQobCwgbyksIGkuc2V0Q3VycmVudEJsb2NrQnlDaGlsZE5vZGUoZS5ob2xkZXIpLCBpLmN1cnJlbnRCbG9jay5jdXJyZW50SW5wdXQgPSByO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgY2FyZXQgdG8gdGhlIGN1cnJlbnQgaW5wdXQgb2YgY3VycmVudCBCbG9jay5cbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gaW5wdXQgLSBpbnB1dCB3aGVyZSBjYXJldCBzaG91bGQgYmUgc2V0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwb3NpdGlvbiAtIHBvc2l0aW9uIG9mIHRoZSBjYXJldC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgZGVmYXVsdCAtIGxlYXZlIGRlZmF1bHQgYmVoYXZpb3VyIGFuZCBhcHBseSBvZmZzZXQgaWYgaXQncyBwYXNzZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCAtIGNhcmV0IG9mZnNldCByZWdhcmRpbmcgdG8gdGhlIHRleHQgbm9kZVxuICAgKi9cbiAgc2V0VG9JbnB1dChlLCB0ID0gdGhpcy5wb3NpdGlvbnMuREVGQVVMVCwgbyA9IDApIHtcbiAgICBjb25zdCB7IGN1cnJlbnRCbG9jazogaSB9ID0gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLCBzID0gZC5nZXREZWVwZXN0Tm9kZShlKTtcbiAgICBzd2l0Y2ggKHQpIHtcbiAgICAgIGNhc2UgdGhpcy5wb3NpdGlvbnMuU1RBUlQ6XG4gICAgICAgIHRoaXMuc2V0KHMsIDApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdGhpcy5wb3NpdGlvbnMuRU5EOlxuICAgICAgICB0aGlzLnNldChzLCBkLmdldENvbnRlbnRMZW5ndGgocykpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIG8gJiYgdGhpcy5zZXQocywgbyk7XG4gICAgfVxuICAgIGkuY3VycmVudElucHV0ID0gZTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBEb2N1bWVudCBSYW5nZSBhbmQgc2V0cyBjYXJldCB0byB0aGUgZWxlbWVudCB3aXRoIG9mZnNldFxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gdGFyZ2V0IG5vZGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgLSBvZmZzZXRcbiAgICovXG4gIHNldChlLCB0ID0gMCkge1xuICAgIGNvbnN0IHsgdG9wOiBpLCBib3R0b206IHMgfSA9IGIuc2V0Q3Vyc29yKGUsIHQpLCB7IGlubmVySGVpZ2h0OiByIH0gPSB3aW5kb3c7XG4gICAgaSA8IDAgPyB3aW5kb3cuc2Nyb2xsQnkoMCwgaSAtIDMwKSA6IHMgPiByICYmIHdpbmRvdy5zY3JvbGxCeSgwLCBzIC0gciArIDMwKTtcbiAgfVxuICAvKipcbiAgICogU2V0IENhcmV0IHRvIHRoZSBsYXN0IEJsb2NrXG4gICAqIElmIGxhc3QgYmxvY2sgaXMgbm90IGVtcHR5LCBhcHBlbmQgYW5vdGhlciBlbXB0eSBibG9ja1xuICAgKi9cbiAgc2V0VG9UaGVMYXN0QmxvY2soKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5sYXN0QmxvY2s7XG4gICAgaWYgKGUpXG4gICAgICBpZiAoZS50b29sLmlzRGVmYXVsdCAmJiBlLmlzRW1wdHkpXG4gICAgICAgIHRoaXMuc2V0VG9CbG9jayhlKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBjb25zdCB0ID0gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmluc2VydEF0RW5kKCk7XG4gICAgICAgIHRoaXMuc2V0VG9CbG9jayh0KTtcbiAgICAgIH1cbiAgfVxuICAvKipcbiAgICogRXh0cmFjdCBjb250ZW50IGZyYWdtZW50IG9mIGN1cnJlbnQgQmxvY2sgZnJvbSBDYXJldCBwb3NpdGlvbiB0byB0aGUgZW5kIG9mIHRoZSBCbG9ja1xuICAgKi9cbiAgZXh0cmFjdEZyYWdtZW50RnJvbUNhcmV0UG9zaXRpb24oKSB7XG4gICAgY29uc3QgZSA9IGIuZ2V0KCk7XG4gICAgaWYgKGUucmFuZ2VDb3VudCkge1xuICAgICAgY29uc3QgdCA9IGUuZ2V0UmFuZ2VBdCgwKSwgbyA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5jdXJyZW50QmxvY2suY3VycmVudElucHV0O1xuICAgICAgaWYgKHQuZGVsZXRlQ29udGVudHMoKSwgbylcbiAgICAgICAgaWYgKGQuaXNOYXRpdmVJbnB1dChvKSkge1xuICAgICAgICAgIGNvbnN0IGkgPSBvLCBzID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCByID0gaS52YWx1ZS5zdWJzdHJpbmcoMCwgaS5zZWxlY3Rpb25TdGFydCksIGwgPSBpLnZhbHVlLnN1YnN0cmluZyhpLnNlbGVjdGlvblN0YXJ0KTtcbiAgICAgICAgICByZXR1cm4gcy50ZXh0Q29udGVudCA9IGwsIGkudmFsdWUgPSByLCBzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGkgPSB0LmNsb25lUmFuZ2UoKTtcbiAgICAgICAgICByZXR1cm4gaS5zZWxlY3ROb2RlQ29udGVudHMobyksIGkuc2V0U3RhcnQodC5lbmRDb250YWluZXIsIHQuZW5kT2Zmc2V0KSwgaS5leHRyYWN0Q29udGVudHMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2V0J3MgY2FyZXQgdG8gdGhlIG5leHQgQmxvY2sgb3IgVG9vbGBzIGlucHV0XG4gICAqIEJlZm9yZSBtb3ZpbmcgY2FyZXQsIHdlIHNob3VsZCBjaGVjayBpZiBjYXJldCBwb3NpdGlvbiBpcyBhdCB0aGUgZW5kIG9mIFBsdWdpbnMgbm9kZVxuICAgKiBVc2luZyB7QGxpbmsgRG9tI2dldERlZXBlc3ROb2RlfSB0byBnZXQgYSBsYXN0IG5vZGUgYW5kIG1hdGNoIHdpdGggY3VycmVudCBzZWxlY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBmb3JjZSAtIHBhc3MgdHJ1ZSB0byBza2lwIGNoZWNrIGZvciBjYXJldCBwb3NpdGlvblxuICAgKi9cbiAgbmF2aWdhdGVOZXh0KGUgPSAhMSkge1xuICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiB0IH0gPSB0aGlzLkVkaXRvciwgeyBjdXJyZW50QmxvY2s6IG8sIG5leHRCbG9jazogaSB9ID0gdDtcbiAgICBpZiAobyA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IHsgbmV4dElucHV0OiBzLCBjdXJyZW50SW5wdXQ6IHIgfSA9IG8sIGwgPSByICE9PSB2b2lkIDAgPyBNZShyKSA6IHZvaWQgMDtcbiAgICBsZXQgYSA9IGk7XG4gICAgY29uc3QgYyA9IGUgfHwgbCB8fCAhby5mb2N1c2FibGU7XG4gICAgaWYgKHMgJiYgYylcbiAgICAgIHJldHVybiB0aGlzLnNldFRvSW5wdXQocywgdGhpcy5wb3NpdGlvbnMuU1RBUlQpLCAhMDtcbiAgICBpZiAoYSA9PT0gbnVsbCkge1xuICAgICAgaWYgKG8udG9vbC5pc0RlZmF1bHQgfHwgIWMpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGEgPSB0Lmluc2VydEF0RW5kKCk7XG4gICAgfVxuICAgIHJldHVybiBjID8gKHRoaXMuc2V0VG9CbG9jayhhLCB0aGlzLnBvc2l0aW9ucy5TVEFSVCksICEwKSA6ICExO1xuICB9XG4gIC8qKlxuICAgKiBTZXQncyBjYXJldCB0byB0aGUgcHJldmlvdXMgVG9vbGBzIGlucHV0IG9yIEJsb2NrXG4gICAqIEJlZm9yZSBtb3ZpbmcgY2FyZXQsIHdlIHNob3VsZCBjaGVjayBpZiBjYXJldCBwb3NpdGlvbiBpcyBzdGFydCBvZiB0aGUgUGx1Z2lucyBub2RlXG4gICAqIFVzaW5nIHtAbGluayBEb20jZ2V0RGVlcGVzdE5vZGV9IHRvIGdldCBhIGxhc3Qgbm9kZSBhbmQgbWF0Y2ggd2l0aCBjdXJyZW50IHNlbGVjdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZvcmNlIC0gcGFzcyB0cnVlIHRvIHNraXAgY2hlY2sgZm9yIGNhcmV0IHBvc2l0aW9uXG4gICAqL1xuICBuYXZpZ2F0ZVByZXZpb3VzKGUgPSAhMSkge1xuICAgIGNvbnN0IHsgY3VycmVudEJsb2NrOiB0LCBwcmV2aW91c0Jsb2NrOiBvIH0gPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXI7XG4gICAgaWYgKCF0KVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IHsgcHJldmlvdXNJbnB1dDogaSwgY3VycmVudElucHV0OiBzIH0gPSB0LCByID0gcyAhPT0gdm9pZCAwID8gSWUocykgOiB2b2lkIDAsIGwgPSBlIHx8IHIgfHwgIXQuZm9jdXNhYmxlO1xuICAgIHJldHVybiBpICYmIGwgPyAodGhpcy5zZXRUb0lucHV0KGksIHRoaXMucG9zaXRpb25zLkVORCksICEwKSA6IG8gIT09IG51bGwgJiYgbCA/ICh0aGlzLnNldFRvQmxvY2sobywgdGhpcy5wb3NpdGlvbnMuRU5EKSwgITApIDogITE7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydHMgc2hhZG93IGVsZW1lbnQgYWZ0ZXIgcGFzc2VkIGVsZW1lbnQgd2hlcmUgY2FyZXQgY2FuIGJlIHBsYWNlZFxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSBlbGVtZW50IGFmdGVyIHdoaWNoIHNoYWRvdyBjYXJldCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICovXG4gIGNyZWF0ZVNoYWRvdyhlKSB7XG4gICAgY29uc3QgdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgIHQuY2xhc3NMaXN0LmFkZChEZS5DU1Muc2hhZG93Q2FyZXQpLCBlLmluc2VydEFkamFjZW50RWxlbWVudChcImJlZm9yZWVuZFwiLCB0KTtcbiAgfVxuICAvKipcbiAgICogUmVzdG9yZXMgY2FyZXQgcG9zaXRpb25cbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIGVsZW1lbnQgd2hlcmUgY2FyZXQgc2hvdWxkIGJlIHJlc3RvcmVkXG4gICAqL1xuICByZXN0b3JlQ2FyZXQoZSkge1xuICAgIGNvbnN0IHQgPSBlLnF1ZXJ5U2VsZWN0b3IoYC4ke0RlLkNTUy5zaGFkb3dDYXJldH1gKTtcbiAgICBpZiAoIXQpXG4gICAgICByZXR1cm47XG4gICAgbmV3IGIoKS5leHBhbmRUb1RhZyh0KTtcbiAgICBjb25zdCBpID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICBpLnNlbGVjdE5vZGUodCksIGkuZXh0cmFjdENvbnRlbnRzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydHMgcGFzc2VkIGNvbnRlbnQgYXQgY2FyZXQgcG9zaXRpb25cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnQgLSBjb250ZW50IHRvIGluc2VydFxuICAgKi9cbiAgaW5zZXJ0Q29udGVudEF0Q2FyZXRQb3NpdGlvbihlKSB7XG4gICAgY29uc3QgdCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSwgbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIGkgPSBiLmdldCgpLCBzID0gYi5yYW5nZTtcbiAgICBvLmlubmVySFRNTCA9IGUsIEFycmF5LmZyb20oby5jaGlsZE5vZGVzKS5mb3JFYWNoKChjKSA9PiB0LmFwcGVuZENoaWxkKGMpKSwgdC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMCAmJiB0LmFwcGVuZENoaWxkKG5ldyBUZXh0KCkpO1xuICAgIGNvbnN0IHIgPSB0Lmxhc3RDaGlsZDtcbiAgICBzLmRlbGV0ZUNvbnRlbnRzKCksIHMuaW5zZXJ0Tm9kZSh0KTtcbiAgICBjb25zdCBsID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKSwgYSA9IHIubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFID8gciA6IHIuZmlyc3RDaGlsZDtcbiAgICBhICE9PSBudWxsICYmIGEudGV4dENvbnRlbnQgIT09IG51bGwgJiYgbC5zZXRTdGFydChhLCBhLnRleHRDb250ZW50Lmxlbmd0aCksIGkucmVtb3ZlQWxsUmFuZ2VzKCksIGkuYWRkUmFuZ2UobCk7XG4gIH1cbn1cbmNsYXNzIG9zIGV4dGVuZHMgeSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMub25Nb3VzZVVwID0gKCkgPT4ge1xuICAgICAgdGhpcy5saXN0ZW5lcnMub2ZmKGRvY3VtZW50LCBcIm1vdXNlb3ZlclwiLCB0aGlzLm9uTW91c2VPdmVyKSwgdGhpcy5saXN0ZW5lcnMub2ZmKGRvY3VtZW50LCBcIm1vdXNldXBcIiwgdGhpcy5vbk1vdXNlVXApO1xuICAgIH0sIHRoaXMub25Nb3VzZU92ZXIgPSAoZSkgPT4ge1xuICAgICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IHQsIEJsb2NrU2VsZWN0aW9uOiBvIH0gPSB0aGlzLkVkaXRvcjtcbiAgICAgIGlmIChlLnJlbGF0ZWRUYXJnZXQgPT09IG51bGwgJiYgZS50YXJnZXQgPT09IG51bGwpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IGkgPSB0LmdldEJsb2NrQnlDaGlsZE5vZGUoZS5yZWxhdGVkVGFyZ2V0KSB8fCB0aGlzLmxhc3RTZWxlY3RlZEJsb2NrLCBzID0gdC5nZXRCbG9ja0J5Q2hpbGROb2RlKGUudGFyZ2V0KTtcbiAgICAgIGlmICghKCFpIHx8ICFzKSAmJiBzICE9PSBpKSB7XG4gICAgICAgIGlmIChpID09PSB0aGlzLmZpcnN0U2VsZWN0ZWRCbG9jaykge1xuICAgICAgICAgIGIuZ2V0KCkucmVtb3ZlQWxsUmFuZ2VzKCksIGkuc2VsZWN0ZWQgPSAhMCwgcy5zZWxlY3RlZCA9ICEwLCBvLmNsZWFyQ2FjaGUoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMgPT09IHRoaXMuZmlyc3RTZWxlY3RlZEJsb2NrKSB7XG4gICAgICAgICAgaS5zZWxlY3RlZCA9ICExLCBzLnNlbGVjdGVkID0gITEsIG8uY2xlYXJDYWNoZSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLkVkaXRvci5JbmxpbmVUb29sYmFyLmNsb3NlKCksIHRoaXMudG9nZ2xlQmxvY2tzU2VsZWN0ZWRTdGF0ZShpLCBzKSwgdGhpcy5sYXN0U2VsZWN0ZWRCbG9jayA9IHM7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogTW9kdWxlIHByZXBhcmF0aW9uXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgcHJlcGFyZSgpIHtcbiAgICB0aGlzLmxpc3RlbmVycy5vbihkb2N1bWVudCwgXCJtb3VzZWRvd25cIiwgKGUpID0+IHtcbiAgICAgIHRoaXMuZW5hYmxlQ3Jvc3NCbG9ja1NlbGVjdGlvbihlKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB1cCBsaXN0ZW5lcnNcbiAgICpcbiAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudCAtIG1vdXNlIGRvd24gZXZlbnRcbiAgICovXG4gIHdhdGNoU2VsZWN0aW9uKGUpIHtcbiAgICBpZiAoZS5idXR0b24gIT09IHdvLkxFRlQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IHQgfSA9IHRoaXMuRWRpdG9yO1xuICAgIHRoaXMuZmlyc3RTZWxlY3RlZEJsb2NrID0gdC5nZXRCbG9jayhlLnRhcmdldCksIHRoaXMubGFzdFNlbGVjdGVkQmxvY2sgPSB0aGlzLmZpcnN0U2VsZWN0ZWRCbG9jaywgdGhpcy5saXN0ZW5lcnMub24oZG9jdW1lbnQsIFwibW91c2VvdmVyXCIsIHRoaXMub25Nb3VzZU92ZXIpLCB0aGlzLmxpc3RlbmVycy5vbihkb2N1bWVudCwgXCJtb3VzZXVwXCIsIHRoaXMub25Nb3VzZVVwKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGJvb2xlYW4gaXMgY3Jvc3MgYmxvY2sgc2VsZWN0aW9uIHN0YXJ0ZWQ6XG4gICAqIHRoZXJlIHNob3VsZCBiZSBhdCBsZWFzdCAyIHNlbGVjdGVkIGJsb2Nrc1xuICAgKi9cbiAgZ2V0IGlzQ3Jvc3NCbG9ja1NlbGVjdGlvblN0YXJ0ZWQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5maXJzdFNlbGVjdGVkQmxvY2sgJiYgISF0aGlzLmxhc3RTZWxlY3RlZEJsb2NrICYmIHRoaXMuZmlyc3RTZWxlY3RlZEJsb2NrICE9PSB0aGlzLmxhc3RTZWxlY3RlZEJsb2NrO1xuICB9XG4gIC8qKlxuICAgKiBDaGFuZ2Ugc2VsZWN0aW9uIHN0YXRlIG9mIHRoZSBuZXh0IEJsb2NrXG4gICAqIFVzZWQgZm9yIENCUyB2aWEgU2hpZnQgKyBhcnJvdyBrZXlzXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gbmV4dCAtIGlmIHRydWUsIHRvZ2dsZSBuZXh0IGJsb2NrLiBQcmV2aW91cyBvdGhlcndpc2VcbiAgICovXG4gIHRvZ2dsZUJsb2NrU2VsZWN0ZWRTdGF0ZShlID0gITApIHtcbiAgICBjb25zdCB7IEJsb2NrTWFuYWdlcjogdCwgQmxvY2tTZWxlY3Rpb246IG8gfSA9IHRoaXMuRWRpdG9yO1xuICAgIHRoaXMubGFzdFNlbGVjdGVkQmxvY2sgfHwgKHRoaXMubGFzdFNlbGVjdGVkQmxvY2sgPSB0aGlzLmZpcnN0U2VsZWN0ZWRCbG9jayA9IHQuY3VycmVudEJsb2NrKSwgdGhpcy5maXJzdFNlbGVjdGVkQmxvY2sgPT09IHRoaXMubGFzdFNlbGVjdGVkQmxvY2sgJiYgKHRoaXMuZmlyc3RTZWxlY3RlZEJsb2NrLnNlbGVjdGVkID0gITAsIG8uY2xlYXJDYWNoZSgpLCBiLmdldCgpLnJlbW92ZUFsbFJhbmdlcygpKTtcbiAgICBjb25zdCBpID0gdC5ibG9ja3MuaW5kZXhPZih0aGlzLmxhc3RTZWxlY3RlZEJsb2NrKSArIChlID8gMSA6IC0xKSwgcyA9IHQuYmxvY2tzW2ldO1xuICAgIHMgJiYgKHRoaXMubGFzdFNlbGVjdGVkQmxvY2suc2VsZWN0ZWQgIT09IHMuc2VsZWN0ZWQgPyAocy5zZWxlY3RlZCA9ICEwLCBvLmNsZWFyQ2FjaGUoKSkgOiAodGhpcy5sYXN0U2VsZWN0ZWRCbG9jay5zZWxlY3RlZCA9ICExLCBvLmNsZWFyQ2FjaGUoKSksIHRoaXMubGFzdFNlbGVjdGVkQmxvY2sgPSBzLCB0aGlzLkVkaXRvci5JbmxpbmVUb29sYmFyLmNsb3NlKCksIHMuaG9sZGVyLnNjcm9sbEludG9WaWV3KHtcbiAgICAgIGJsb2NrOiBcIm5lYXJlc3RcIlxuICAgIH0pKTtcbiAgfVxuICAvKipcbiAgICogQ2xlYXIgc2F2ZWQgc3RhdGVcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gcmVhc29uIC0gZXZlbnQgY2F1c2VkIGNsZWFyIG9mIHNlbGVjdGlvblxuICAgKi9cbiAgY2xlYXIoZSkge1xuICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiB0LCBCbG9ja1NlbGVjdGlvbjogbywgQ2FyZXQ6IGkgfSA9IHRoaXMuRWRpdG9yLCBzID0gdC5ibG9ja3MuaW5kZXhPZih0aGlzLmZpcnN0U2VsZWN0ZWRCbG9jayksIHIgPSB0LmJsb2Nrcy5pbmRleE9mKHRoaXMubGFzdFNlbGVjdGVkQmxvY2spO1xuICAgIGlmIChvLmFueUJsb2NrU2VsZWN0ZWQgJiYgcyA+IC0xICYmIHIgPiAtMSAmJiBlICYmIGUgaW5zdGFuY2VvZiBLZXlib2FyZEV2ZW50KVxuICAgICAgc3dpdGNoIChlLmtleUNvZGUpIHtcbiAgICAgICAgY2FzZSB3LkRPV046XG4gICAgICAgIGNhc2Ugdy5SSUdIVDpcbiAgICAgICAgICBpLnNldFRvQmxvY2sodC5ibG9ja3NbTWF0aC5tYXgocywgcildLCBpLnBvc2l0aW9ucy5FTkQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHcuVVA6XG4gICAgICAgIGNhc2Ugdy5MRUZUOlxuICAgICAgICAgIGkuc2V0VG9CbG9jayh0LmJsb2Nrc1tNYXRoLm1pbihzLCByKV0sIGkucG9zaXRpb25zLlNUQVJUKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpLnNldFRvQmxvY2sodC5ibG9ja3NbTWF0aC5tYXgocywgcildLCBpLnBvc2l0aW9ucy5FTkQpO1xuICAgICAgfVxuICAgIHRoaXMuZmlyc3RTZWxlY3RlZEJsb2NrID0gdGhpcy5sYXN0U2VsZWN0ZWRCbG9jayA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZXMgQ3Jvc3MgQmxvY2sgU2VsZWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnQgLSBtb3VzZSBkb3duIGV2ZW50XG4gICAqL1xuICBlbmFibGVDcm9zc0Jsb2NrU2VsZWN0aW9uKGUpIHtcbiAgICBjb25zdCB7IFVJOiB0IH0gPSB0aGlzLkVkaXRvcjtcbiAgICBiLmlzQ29sbGFwc2VkIHx8IHRoaXMuRWRpdG9yLkJsb2NrU2VsZWN0aW9uLmNsZWFyU2VsZWN0aW9uKGUpLCB0Lm5vZGVzLnJlZGFjdG9yLmNvbnRhaW5zKGUudGFyZ2V0KSA/IHRoaXMud2F0Y2hTZWxlY3Rpb24oZSkgOiB0aGlzLkVkaXRvci5CbG9ja1NlbGVjdGlvbi5jbGVhclNlbGVjdGlvbihlKTtcbiAgfVxuICAvKipcbiAgICogQ2hhbmdlIGJsb2NrcyBzZWxlY3Rpb24gc3RhdGUgYmV0d2VlbiBwYXNzZWQgdHdvIGJsb2Nrcy5cbiAgICpcbiAgICogQHBhcmFtIHtCbG9ja30gZmlyc3RCbG9jayAtIGZpcnN0IGJsb2NrIGluIHJhbmdlXG4gICAqIEBwYXJhbSB7QmxvY2t9IGxhc3RCbG9jayAtIGxhc3QgYmxvY2sgaW4gcmFuZ2VcbiAgICovXG4gIHRvZ2dsZUJsb2Nrc1NlbGVjdGVkU3RhdGUoZSwgdCkge1xuICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiBvLCBCbG9ja1NlbGVjdGlvbjogaSB9ID0gdGhpcy5FZGl0b3IsIHMgPSBvLmJsb2Nrcy5pbmRleE9mKGUpLCByID0gby5ibG9ja3MuaW5kZXhPZih0KSwgbCA9IGUuc2VsZWN0ZWQgIT09IHQuc2VsZWN0ZWQ7XG4gICAgZm9yIChsZXQgYSA9IE1hdGgubWluKHMsIHIpOyBhIDw9IE1hdGgubWF4KHMsIHIpOyBhKyspIHtcbiAgICAgIGNvbnN0IGMgPSBvLmJsb2Nrc1thXTtcbiAgICAgIGMgIT09IHRoaXMuZmlyc3RTZWxlY3RlZEJsb2NrICYmIGMgIT09IChsID8gZSA6IHQpICYmIChvLmJsb2Nrc1thXS5zZWxlY3RlZCA9ICFvLmJsb2Nrc1thXS5zZWxlY3RlZCwgaS5jbGVhckNhY2hlKCkpO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgaXMgZXh0ZW5kcyB5IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy5pc1N0YXJ0ZWRBdEVkaXRvciA9ICExO1xuICB9XG4gIC8qKlxuICAgKiBUb2dnbGUgcmVhZC1vbmx5IHN0YXRlXG4gICAqXG4gICAqIGlmIHN0YXRlIGlzIHRydWU6XG4gICAqICAtIGRpc2FibGUgYWxsIGRyYWctbi1kcm9wIGV2ZW50IGhhbmRsZXJzXG4gICAqXG4gICAqIGlmIHN0YXRlIGlzIGZhbHNlOlxuICAgKiAgLSByZXN0b3JlIGRyYWctbi1kcm9wIGV2ZW50IGhhbmRsZXJzXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVhZE9ubHlFbmFibGVkIC0gXCJyZWFkIG9ubHlcIiBzdGF0ZVxuICAgKi9cbiAgdG9nZ2xlUmVhZE9ubHkoZSkge1xuICAgIGUgPyB0aGlzLmRpc2FibGVNb2R1bGVCaW5kaW5ncygpIDogdGhpcy5lbmFibGVNb2R1bGVCaW5kaW5ncygpO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgZHJhZyBldmVudHMgbGlzdGVuZXJzIHRvIGVkaXRvciB6b25lXG4gICAqL1xuICBlbmFibGVNb2R1bGVCaW5kaW5ncygpIHtcbiAgICBjb25zdCB7IFVJOiBlIH0gPSB0aGlzLkVkaXRvcjtcbiAgICB0aGlzLnJlYWRPbmx5TXV0YWJsZUxpc3RlbmVycy5vbihlLm5vZGVzLmhvbGRlciwgXCJkcm9wXCIsIGFzeW5jICh0KSA9PiB7XG4gICAgICBhd2FpdCB0aGlzLnByb2Nlc3NEcm9wKHQpO1xuICAgIH0sICEwKSwgdGhpcy5yZWFkT25seU11dGFibGVMaXN0ZW5lcnMub24oZS5ub2Rlcy5ob2xkZXIsIFwiZHJhZ3N0YXJ0XCIsICgpID0+IHtcbiAgICAgIHRoaXMucHJvY2Vzc0RyYWdTdGFydCgpO1xuICAgIH0pLCB0aGlzLnJlYWRPbmx5TXV0YWJsZUxpc3RlbmVycy5vbihlLm5vZGVzLmhvbGRlciwgXCJkcmFnb3ZlclwiLCAodCkgPT4ge1xuICAgICAgdGhpcy5wcm9jZXNzRHJhZ092ZXIodCk7XG4gICAgfSwgITApO1xuICB9XG4gIC8qKlxuICAgKiBVbmJpbmQgZHJhZy1uLWRyb3AgZXZlbnQgaGFuZGxlcnNcbiAgICovXG4gIGRpc2FibGVNb2R1bGVCaW5kaW5ncygpIHtcbiAgICB0aGlzLnJlYWRPbmx5TXV0YWJsZUxpc3RlbmVycy5jbGVhckFsbCgpO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGUgZHJvcCBldmVudFxuICAgKlxuICAgKiBAcGFyYW0ge0RyYWdFdmVudH0gZHJvcEV2ZW50IC0gZHJvcCBldmVudFxuICAgKi9cbiAgYXN5bmMgcHJvY2Vzc0Ryb3AoZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIEJsb2NrTWFuYWdlcjogdCxcbiAgICAgIFBhc3RlOiBvLFxuICAgICAgQ2FyZXQ6IGlcbiAgICB9ID0gdGhpcy5FZGl0b3I7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpLCB0LmJsb2Nrcy5mb3JFYWNoKChyKSA9PiB7XG4gICAgICByLmRyb3BUYXJnZXQgPSAhMTtcbiAgICB9KSwgYi5pc0F0RWRpdG9yICYmICFiLmlzQ29sbGFwc2VkICYmIHRoaXMuaXNTdGFydGVkQXRFZGl0b3IgJiYgZG9jdW1lbnQuZXhlY0NvbW1hbmQoXCJkZWxldGVcIiksIHRoaXMuaXNTdGFydGVkQXRFZGl0b3IgPSAhMTtcbiAgICBjb25zdCBzID0gdC5zZXRDdXJyZW50QmxvY2tCeUNoaWxkTm9kZShlLnRhcmdldCk7XG4gICAgaWYgKHMpXG4gICAgICB0aGlzLkVkaXRvci5DYXJldC5zZXRUb0Jsb2NrKHMsIGkucG9zaXRpb25zLkVORCk7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCByID0gdC5zZXRDdXJyZW50QmxvY2tCeUNoaWxkTm9kZSh0Lmxhc3RCbG9jay5ob2xkZXIpO1xuICAgICAgdGhpcy5FZGl0b3IuQ2FyZXQuc2V0VG9CbG9jayhyLCBpLnBvc2l0aW9ucy5FTkQpO1xuICAgIH1cbiAgICBhd2FpdCBvLnByb2Nlc3NEYXRhVHJhbnNmZXIoZS5kYXRhVHJhbnNmZXIsICEwKTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlIGRyYWcgc3RhcnQgZXZlbnRcbiAgICovXG4gIHByb2Nlc3NEcmFnU3RhcnQoKSB7XG4gICAgYi5pc0F0RWRpdG9yICYmICFiLmlzQ29sbGFwc2VkICYmICh0aGlzLmlzU3RhcnRlZEF0RWRpdG9yID0gITApLCB0aGlzLkVkaXRvci5JbmxpbmVUb29sYmFyLmNsb3NlKCk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7RHJhZ0V2ZW50fSBkcmFnRXZlbnQgLSBkcmFnIGV2ZW50XG4gICAqL1xuICBwcm9jZXNzRHJhZ092ZXIoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfVxufVxuY2xhc3Mgc3MgZXh0ZW5kcyB5IHtcbiAgLyoqXG4gICAqIFByZXBhcmUgdGhlIG1vZHVsZVxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIG9wdGlvbnMgdXNlZCBieSB0aGUgbW9kaWZpY2F0aW9uIG9ic2VydmVyIG1vZHVsZVxuICAgKiBAcGFyYW0gb3B0aW9ucy5jb25maWcgLSBFZGl0b3IgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICogQHBhcmFtIG9wdGlvbnMuZXZlbnRzRGlzcGF0Y2hlciAtIGNvbW1vbiBFZGl0b3IgZXZlbnQgYnVzXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGNvbmZpZzogZSwgZXZlbnRzRGlzcGF0Y2hlcjogdCB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgY29uZmlnOiBlLFxuICAgICAgZXZlbnRzRGlzcGF0Y2hlcjogdFxuICAgIH0pLCB0aGlzLmRpc2FibGVkID0gITEsIHRoaXMuYmF0Y2hpbmdUaW1lb3V0ID0gbnVsbCwgdGhpcy5iYXRjaGluZ09uQ2hhbmdlUXVldWUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCB0aGlzLmJhdGNoVGltZSA9IDQwMCwgdGhpcy5tdXRhdGlvbk9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKG8pID0+IHtcbiAgICAgIHRoaXMucmVkYWN0b3JDaGFuZ2VkKG8pO1xuICAgIH0pLCB0aGlzLmV2ZW50c0Rpc3BhdGNoZXIub24oUHQsIChvKSA9PiB7XG4gICAgICB0aGlzLnBhcnRpY3VsYXJCbG9ja0NoYW5nZWQoby5ldmVudCk7XG4gICAgfSksIHRoaXMuZXZlbnRzRGlzcGF0Y2hlci5vbihEdCwgKCkgPT4ge1xuICAgICAgdGhpcy5kaXNhYmxlKCk7XG4gICAgfSksIHRoaXMuZXZlbnRzRGlzcGF0Y2hlci5vbihSdCwgKCkgPT4ge1xuICAgICAgdGhpcy5lbmFibGUoKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRW5hYmxlcyBvbkNoYW5nZSBldmVudFxuICAgKi9cbiAgZW5hYmxlKCkge1xuICAgIHRoaXMubXV0YXRpb25PYnNlcnZlci5vYnNlcnZlKFxuICAgICAgdGhpcy5FZGl0b3IuVUkubm9kZXMucmVkYWN0b3IsXG4gICAgICB7XG4gICAgICAgIGNoaWxkTGlzdDogITAsXG4gICAgICAgIHN1YnRyZWU6ICEwLFxuICAgICAgICBjaGFyYWN0ZXJEYXRhOiAhMCxcbiAgICAgICAgYXR0cmlidXRlczogITBcbiAgICAgIH1cbiAgICApLCB0aGlzLmRpc2FibGVkID0gITE7XG4gIH1cbiAgLyoqXG4gICAqIERpc2FibGVzIG9uQ2hhbmdlIGV2ZW50XG4gICAqL1xuICBkaXNhYmxlKCkge1xuICAgIHRoaXMubXV0YXRpb25PYnNlcnZlci5kaXNjb25uZWN0KCksIHRoaXMuZGlzYWJsZWQgPSAhMDtcbiAgfVxuICAvKipcbiAgICogQ2FsbCBvbkNoYW5nZSBldmVudCBwYXNzZWQgdG8gRWRpdG9yLmpzIGNvbmZpZ3VyYXRpb25cbiAgICpcbiAgICogQHBhcmFtIGV2ZW50IC0gc29tZSBvZiBvdXIgY3VzdG9tIGNoYW5nZSBldmVudHNcbiAgICovXG4gIHBhcnRpY3VsYXJCbG9ja0NoYW5nZWQoZSkge1xuICAgIHRoaXMuZGlzYWJsZWQgfHwgIU8odGhpcy5jb25maWcub25DaGFuZ2UpIHx8ICh0aGlzLmJhdGNoaW5nT25DaGFuZ2VRdWV1ZS5zZXQoYGJsb2NrOiR7ZS5kZXRhaWwudGFyZ2V0LmlkfTpldmVudDoke2UudHlwZX1gLCBlKSwgdGhpcy5iYXRjaGluZ1RpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KHRoaXMuYmF0Y2hpbmdUaW1lb3V0KSwgdGhpcy5iYXRjaGluZ1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGxldCB0O1xuICAgICAgdGhpcy5iYXRjaGluZ09uQ2hhbmdlUXVldWUuc2l6ZSA9PT0gMSA/IHQgPSB0aGlzLmJhdGNoaW5nT25DaGFuZ2VRdWV1ZS52YWx1ZXMoKS5uZXh0KCkudmFsdWUgOiB0ID0gQXJyYXkuZnJvbSh0aGlzLmJhdGNoaW5nT25DaGFuZ2VRdWV1ZS52YWx1ZXMoKSksIHRoaXMuY29uZmlnLm9uQ2hhbmdlICYmIHRoaXMuY29uZmlnLm9uQ2hhbmdlKHRoaXMuRWRpdG9yLkFQSS5tZXRob2RzLCB0KSwgdGhpcy5iYXRjaGluZ09uQ2hhbmdlUXVldWUuY2xlYXIoKTtcbiAgICB9LCB0aGlzLmJhdGNoVGltZSkpO1xuICB9XG4gIC8qKlxuICAgKiBGaXJlZCBvbiBldmVyeSBibG9ja3Mgd3JhcHBlciBkb20gY2hhbmdlXG4gICAqXG4gICAqIEBwYXJhbSBtdXRhdGlvbnMgLSBtdXRhdGlvbnMgaGFwcGVuZWRcbiAgICovXG4gIHJlZGFjdG9yQ2hhbmdlZChlKSB7XG4gICAgdGhpcy5ldmVudHNEaXNwYXRjaGVyLmVtaXQoSmUsIHtcbiAgICAgIG11dGF0aW9uczogZVxuICAgIH0pO1xuICB9XG59XG5jb25zdCBybyA9IGNsYXNzIGxvIGV4dGVuZHMgeSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMuTUlNRV9UWVBFID0gXCJhcHBsaWNhdGlvbi94LWVkaXRvci1qc1wiLCB0aGlzLnRvb2xzVGFncyA9IHt9LCB0aGlzLnRhZ3NCeVRvb2wgPSB7fSwgdGhpcy50b29sc1BhdHRlcm5zID0gW10sIHRoaXMudG9vbHNGaWxlcyA9IHt9LCB0aGlzLmV4Y2VwdGlvbkxpc3QgPSBbXSwgdGhpcy5wcm9jZXNzVG9vbCA9IChlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB0ID0gZS5jcmVhdGUoe30sIHt9LCAhMSk7XG4gICAgICAgIGlmIChlLnBhc3RlQ29uZmlnID09PSAhMSkge1xuICAgICAgICAgIHRoaXMuZXhjZXB0aW9uTGlzdC5wdXNoKGUubmFtZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghTyh0Lm9uUGFzdGUpKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5nZXRUYWdzQ29uZmlnKGUpLCB0aGlzLmdldEZpbGVzQ29uZmlnKGUpLCB0aGlzLmdldFBhdHRlcm5zQ29uZmlnKGUpO1xuICAgICAgfSBjYXRjaCAodCkge1xuICAgICAgICBJKFxuICAgICAgICAgIGBQYXN0ZSBoYW5kbGluZyBmb3Igwqske2UubmFtZX3CuyBUb29sIGhhc24ndCBiZWVuIHNldCB1cCBiZWNhdXNlIG9mIHRoZSBlcnJvcmAsXG4gICAgICAgICAgXCJ3YXJuXCIsXG4gICAgICAgICAgdFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0sIHRoaXMuaGFuZGxlUGFzdGVFdmVudCA9IGFzeW5jIChlKSA9PiB7XG4gICAgICBjb25zdCB7IEJsb2NrTWFuYWdlcjogdCwgVG9vbGJhcjogbyB9ID0gdGhpcy5FZGl0b3IsIGkgPSB0LnNldEN1cnJlbnRCbG9ja0J5Q2hpbGROb2RlKGUudGFyZ2V0KTtcbiAgICAgICFpIHx8IHRoaXMuaXNOYXRpdmVCZWhhdmlvdXIoZS50YXJnZXQpICYmICFlLmNsaXBib2FyZERhdGEudHlwZXMuaW5jbHVkZXMoXCJGaWxlc1wiKSB8fCBpICYmIHRoaXMuZXhjZXB0aW9uTGlzdC5pbmNsdWRlcyhpLm5hbWUpIHx8IChlLnByZXZlbnREZWZhdWx0KCksIHRoaXMucHJvY2Vzc0RhdGFUcmFuc2ZlcihlLmNsaXBib2FyZERhdGEpLCBvLmNsb3NlKCkpO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFNldCBvblBhc3RlIGNhbGxiYWNrIGFuZCBjb2xsZWN0IHRvb2xzYCBwYXN0ZSBjb25maWd1cmF0aW9uc1xuICAgKi9cbiAgYXN5bmMgcHJlcGFyZSgpIHtcbiAgICB0aGlzLnByb2Nlc3NUb29scygpO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgcmVhZC1vbmx5IHN0YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVhZE9ubHlFbmFibGVkIC0gcmVhZCBvbmx5IGZsYWcgdmFsdWVcbiAgICovXG4gIHRvZ2dsZVJlYWRPbmx5KGUpIHtcbiAgICBlID8gdGhpcy51bnNldENhbGxiYWNrKCkgOiB0aGlzLnNldENhbGxiYWNrKCk7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZSBwYXN0ZWQgb3IgZHJvcHBlZCBkYXRhIHRyYW5zZmVyIG9iamVjdFxuICAgKlxuICAgKiBAcGFyYW0ge0RhdGFUcmFuc2Zlcn0gZGF0YVRyYW5zZmVyIC0gcGFzdGVkIG9yIGRyb3BwZWQgZGF0YSB0cmFuc2ZlciBvYmplY3RcbiAgICogQHBhcmFtIHtib29sZWFufSBpc0RyYWdORHJvcCAtIHRydWUgaWYgZGF0YSB0cmFuc2ZlciBjb21lcyBmcm9tIGRyYWcnbidkcm9wIGV2ZW50c1xuICAgKi9cbiAgYXN5bmMgcHJvY2Vzc0RhdGFUcmFuc2ZlcihlLCB0ID0gITEpIHtcbiAgICBjb25zdCB7IFRvb2xzOiBvIH0gPSB0aGlzLkVkaXRvciwgaSA9IGUudHlwZXM7XG4gICAgaWYgKChpLmluY2x1ZGVzID8gaS5pbmNsdWRlcyhcIkZpbGVzXCIpIDogaS5jb250YWlucyhcIkZpbGVzXCIpKSAmJiAhWCh0aGlzLnRvb2xzRmlsZXMpKSB7XG4gICAgICBhd2FpdCB0aGlzLnByb2Nlc3NGaWxlcyhlLmZpbGVzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgciA9IGUuZ2V0RGF0YSh0aGlzLk1JTUVfVFlQRSksIGwgPSBlLmdldERhdGEoXCJ0ZXh0L3BsYWluXCIpO1xuICAgIGxldCBhID0gZS5nZXREYXRhKFwidGV4dC9odG1sXCIpO1xuICAgIGlmIChyKVxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5pbnNlcnRFZGl0b3JKU0RhdGEoSlNPTi5wYXJzZShyKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgfVxuICAgIHQgJiYgbC50cmltKCkgJiYgYS50cmltKCkgJiYgKGEgPSBcIjxwPlwiICsgKGEudHJpbSgpID8gYSA6IGwpICsgXCI8L3A+XCIpO1xuICAgIGNvbnN0IGMgPSBPYmplY3Qua2V5cyh0aGlzLnRvb2xzVGFncykucmVkdWNlKChwLCBnKSA9PiAocFtnLnRvTG93ZXJDYXNlKCldID0gdGhpcy50b29sc1RhZ3NbZ10uc2FuaXRpemF0aW9uQ29uZmlnID8/IHt9LCBwKSwge30pLCB1ID0gT2JqZWN0LmFzc2lnbih7fSwgYywgby5nZXRBbGxJbmxpbmVUb29sc1Nhbml0aXplQ29uZmlnKCksIHsgYnI6IHt9IH0pLCBoID0gcShhLCB1KTtcbiAgICAhaC50cmltKCkgfHwgaC50cmltKCkgPT09IGwgfHwgIWQuaXNIVE1MU3RyaW5nKGgpID8gYXdhaXQgdGhpcy5wcm9jZXNzVGV4dChsKSA6IGF3YWl0IHRoaXMucHJvY2Vzc1RleHQoaCwgITApO1xuICB9XG4gIC8qKlxuICAgKiBQcm9jZXNzIHBhc3RlZCB0ZXh0IGFuZCBkaXZpZGUgdGhlbSBpbnRvIEJsb2Nrc1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YSAtIHRleHQgdG8gcHJvY2Vzcy4gQ2FuIGJlIEhUTUwgb3IgcGxhaW4uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNIVE1MIC0gaWYgcGFzc2VkIHN0cmluZyBpcyBIVE1MLCB0aGlzIHBhcmFtZXRlciBzaG91bGQgYmUgdHJ1ZVxuICAgKi9cbiAgYXN5bmMgcHJvY2Vzc1RleHQoZSwgdCA9ICExKSB7XG4gICAgY29uc3QgeyBDYXJldDogbywgQmxvY2tNYW5hZ2VyOiBpIH0gPSB0aGlzLkVkaXRvciwgcyA9IHQgPyB0aGlzLnByb2Nlc3NIVE1MKGUpIDogdGhpcy5wcm9jZXNzUGxhaW4oZSk7XG4gICAgaWYgKCFzLmxlbmd0aClcbiAgICAgIHJldHVybjtcbiAgICBpZiAocy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHNbMF0uaXNCbG9jayA/IHRoaXMucHJvY2Vzc1NpbmdsZUJsb2NrKHMucG9wKCkpIDogdGhpcy5wcm9jZXNzSW5saW5lUGFzdGUocy5wb3AoKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGwgPSBpLmN1cnJlbnRCbG9jayAmJiBpLmN1cnJlbnRCbG9jay50b29sLmlzRGVmYXVsdCAmJiBpLmN1cnJlbnRCbG9jay5pc0VtcHR5O1xuICAgIHMubWFwKFxuICAgICAgYXN5bmMgKGEsIGMpID0+IHRoaXMuaW5zZXJ0QmxvY2soYSwgYyA9PT0gMCAmJiBsKVxuICAgICksIGkuY3VycmVudEJsb2NrICYmIG8uc2V0VG9CbG9jayhpLmN1cnJlbnRCbG9jaywgby5wb3NpdGlvbnMuRU5EKTtcbiAgfVxuICAvKipcbiAgICogU2V0IG9uUGFzdGUgY2FsbGJhY2sgaGFuZGxlclxuICAgKi9cbiAgc2V0Q2FsbGJhY2soKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMub24odGhpcy5FZGl0b3IuVUkubm9kZXMuaG9sZGVyLCBcInBhc3RlXCIsIHRoaXMuaGFuZGxlUGFzdGVFdmVudCk7XG4gIH1cbiAgLyoqXG4gICAqIFVuc2V0IG9uUGFzdGUgY2FsbGJhY2sgaGFuZGxlclxuICAgKi9cbiAgdW5zZXRDYWxsYmFjaygpIHtcbiAgICB0aGlzLmxpc3RlbmVycy5vZmYodGhpcy5FZGl0b3IuVUkubm9kZXMuaG9sZGVyLCBcInBhc3RlXCIsIHRoaXMuaGFuZGxlUGFzdGVFdmVudCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhbmQgcHJvY2VzcyB0b29sYHMgcGFzdGUgY29uZmlnc1xuICAgKi9cbiAgcHJvY2Vzc1Rvb2xzKCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLkVkaXRvci5Ub29scy5ibG9ja1Rvb2xzO1xuICAgIEFycmF5LmZyb20oZS52YWx1ZXMoKSkuZm9yRWFjaCh0aGlzLnByb2Nlc3NUb29sKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRhZ3MgbmFtZSBsaXN0IGZyb20gZWl0aGVyIHRhZyBuYW1lIG9yIHNhbml0aXphdGlvbiBjb25maWcuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgb2JqZWN0fSB0YWdPclNhbml0aXplQ29uZmlnIC0gdGFnIG5hbWUgb3Igc2FuaXRpemUgY29uZmlnIG9iamVjdC5cbiAgICogQHJldHVybnMge3N0cmluZ1tdfSBhcnJheSBvZiB0YWdzLlxuICAgKi9cbiAgY29sbGVjdFRhZ05hbWVzKGUpIHtcbiAgICByZXR1cm4gUShlKSA/IFtlXSA6IFIoZSkgPyBPYmplY3Qua2V5cyhlKSA6IFtdO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGFncyB0byBzdWJzdGl0dXRlIGJ5IFRvb2xcbiAgICpcbiAgICogQHBhcmFtIHRvb2wgLSBCbG9ja1Rvb2wgb2JqZWN0XG4gICAqL1xuICBnZXRUYWdzQ29uZmlnKGUpIHtcbiAgICBpZiAoZS5wYXN0ZUNvbmZpZyA9PT0gITEpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IGUucGFzdGVDb25maWcudGFncyB8fCBbXSwgbyA9IFtdO1xuICAgIHQuZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgY29uc3QgcyA9IHRoaXMuY29sbGVjdFRhZ05hbWVzKGkpO1xuICAgICAgby5wdXNoKC4uLnMpLCBzLmZvckVhY2goKHIpID0+IHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLnRvb2xzVGFncywgcikpIHtcbiAgICAgICAgICBJKFxuICAgICAgICAgICAgYFBhc3RlIGhhbmRsZXIgZm9yIMKrJHtlLm5hbWV9wrsgVG9vbCBvbiDCqyR7cn3CuyB0YWcgaXMgc2tpcHBlZCBiZWNhdXNlIGl0IGlzIGFscmVhZHkgdXNlZCBieSDCqyR7dGhpcy50b29sc1RhZ3Nbcl0udG9vbC5uYW1lfcK7IFRvb2wuYCxcbiAgICAgICAgICAgIFwid2FyblwiXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbCA9IFIoaSkgPyBpW3JdIDogbnVsbDtcbiAgICAgICAgdGhpcy50b29sc1RhZ3Nbci50b1VwcGVyQ2FzZSgpXSA9IHtcbiAgICAgICAgICB0b29sOiBlLFxuICAgICAgICAgIHNhbml0aXphdGlvbkNvbmZpZzogbFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSksIHRoaXMudGFnc0J5VG9vbFtlLm5hbWVdID0gby5tYXAoKGkpID0+IGkudG9VcHBlckNhc2UoKSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBmaWxlc2AgdHlwZXMgYW5kIGV4dGVuc2lvbnMgdG8gc3Vic3RpdHV0ZSBieSBUb29sXG4gICAqXG4gICAqIEBwYXJhbSB0b29sIC0gQmxvY2tUb29sIG9iamVjdFxuICAgKi9cbiAgZ2V0RmlsZXNDb25maWcoZSkge1xuICAgIGlmIChlLnBhc3RlQ29uZmlnID09PSAhMSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IGZpbGVzOiB0ID0ge30gfSA9IGUucGFzdGVDb25maWc7XG4gICAgbGV0IHsgZXh0ZW5zaW9uczogbywgbWltZVR5cGVzOiBpIH0gPSB0O1xuICAgICFvICYmICFpIHx8IChvICYmICFBcnJheS5pc0FycmF5KG8pICYmIChJKGDCq2V4dGVuc2lvbnPCuyBwcm9wZXJ0eSBvZiB0aGUgb25Ecm9wIGNvbmZpZyBmb3Igwqske2UubmFtZX3CuyBUb29sIHNob3VsZCBiZSBhbiBhcnJheWApLCBvID0gW10pLCBpICYmICFBcnJheS5pc0FycmF5KGkpICYmIChJKGDCq21pbWVUeXBlc8K7IHByb3BlcnR5IG9mIHRoZSBvbkRyb3AgY29uZmlnIGZvciDCqyR7ZS5uYW1lfcK7IFRvb2wgc2hvdWxkIGJlIGFuIGFycmF5YCksIGkgPSBbXSksIGkgJiYgKGkgPSBpLmZpbHRlcigocykgPT4gVG8ocykgPyAhMCA6IChJKGBNSU1FIHR5cGUgdmFsdWUgwqske3N9wrsgZm9yIHRoZSDCqyR7ZS5uYW1lfcK7IFRvb2wgaXMgbm90IGEgdmFsaWQgTUlNRSB0eXBlYCwgXCJ3YXJuXCIpLCAhMSkpKSwgdGhpcy50b29sc0ZpbGVzW2UubmFtZV0gPSB7XG4gICAgICBleHRlbnNpb25zOiBvIHx8IFtdLFxuICAgICAgbWltZVR5cGVzOiBpIHx8IFtdXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBSZWdFeHAgcGF0dGVybnMgdG8gc3Vic3RpdHV0ZSBieSBUb29sXG4gICAqXG4gICAqIEBwYXJhbSB0b29sIC0gQmxvY2tUb29sIG9iamVjdFxuICAgKi9cbiAgZ2V0UGF0dGVybnNDb25maWcoZSkge1xuICAgIGUucGFzdGVDb25maWcgPT09ICExIHx8ICFlLnBhc3RlQ29uZmlnLnBhdHRlcm5zIHx8IFgoZS5wYXN0ZUNvbmZpZy5wYXR0ZXJucykgfHwgT2JqZWN0LmVudHJpZXMoZS5wYXN0ZUNvbmZpZy5wYXR0ZXJucykuZm9yRWFjaCgoW3QsIG9dKSA9PiB7XG4gICAgICBvIGluc3RhbmNlb2YgUmVnRXhwIHx8IEkoXG4gICAgICAgIGBQYXR0ZXJuICR7b30gZm9yIMKrJHtlLm5hbWV9wrsgVG9vbCBpcyBza2lwcGVkIGJlY2F1c2UgaXQgc2hvdWxkIGJlIGEgUmVnZXhwIGluc3RhbmNlLmAsXG4gICAgICAgIFwid2FyblwiXG4gICAgICApLCB0aGlzLnRvb2xzUGF0dGVybnMucHVzaCh7XG4gICAgICAgIGtleTogdCxcbiAgICAgICAgcGF0dGVybjogbyxcbiAgICAgICAgdG9vbDogZVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIGJyb3dzZXIgYmVoYXZpb3Igc3VpdHMgYmV0dGVyXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IGVsZW1lbnQgLSBlbGVtZW50IHdoZXJlIGNvbnRlbnQgaGFzIGJlZW4gcGFzdGVkXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgaXNOYXRpdmVCZWhhdmlvdXIoZSkge1xuICAgIHJldHVybiBkLmlzTmF0aXZlSW5wdXQoZSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBmaWxlcyBmcm9tIGRhdGEgdHJhbnNmZXIgb2JqZWN0IGFuZCBpbnNlcnQgcmVsYXRlZCBUb29sc1xuICAgKlxuICAgKiBAcGFyYW0ge0ZpbGVMaXN0fSBpdGVtcyAtIHBhc3RlZCBvciBkcm9wcGVkIGl0ZW1zXG4gICAqL1xuICBhc3luYyBwcm9jZXNzRmlsZXMoZSkge1xuICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiB0IH0gPSB0aGlzLkVkaXRvcjtcbiAgICBsZXQgbztcbiAgICBvID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICBBcnJheS5mcm9tKGUpLm1hcCgocikgPT4gdGhpcy5wcm9jZXNzRmlsZShyKSlcbiAgICApLCBvID0gby5maWx0ZXIoKHIpID0+ICEhcik7XG4gICAgY29uc3QgcyA9IHQuY3VycmVudEJsb2NrLnRvb2wuaXNEZWZhdWx0ICYmIHQuY3VycmVudEJsb2NrLmlzRW1wdHk7XG4gICAgby5mb3JFYWNoKFxuICAgICAgKHIsIGwpID0+IHtcbiAgICAgICAgdC5wYXN0ZShyLnR5cGUsIHIuZXZlbnQsIGwgPT09IDAgJiYgcyk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGluZm9ybWF0aW9uIGFib3V0IGZpbGUgYW5kIGZpbmQgVG9vbCB0byBoYW5kbGUgaXRcbiAgICpcbiAgICogQHBhcmFtIHtGaWxlfSBmaWxlIC0gZmlsZSB0byBwcm9jZXNzXG4gICAqL1xuICBhc3luYyBwcm9jZXNzRmlsZShlKSB7XG4gICAgY29uc3QgdCA9IEJvKGUpLCBvID0gT2JqZWN0LmVudHJpZXModGhpcy50b29sc0ZpbGVzKS5maW5kKChbciwgeyBtaW1lVHlwZXM6IGwsIGV4dGVuc2lvbnM6IGEgfV0pID0+IHtcbiAgICAgIGNvbnN0IFtjLCB1XSA9IGUudHlwZS5zcGxpdChcIi9cIiksIGggPSBhLmZpbmQoKGcpID0+IGcudG9Mb3dlckNhc2UoKSA9PT0gdC50b0xvd2VyQ2FzZSgpKSwgcCA9IGwuZmluZCgoZykgPT4ge1xuICAgICAgICBjb25zdCBbZiwga10gPSBnLnNwbGl0KFwiL1wiKTtcbiAgICAgICAgcmV0dXJuIGYgPT09IGMgJiYgKGsgPT09IHUgfHwgayA9PT0gXCIqXCIpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gISFoIHx8ICEhcDtcbiAgICB9KTtcbiAgICBpZiAoIW8pXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgW2ldID0gbztcbiAgICByZXR1cm4ge1xuICAgICAgZXZlbnQ6IHRoaXMuY29tcG9zZVBhc3RlRXZlbnQoXCJmaWxlXCIsIHtcbiAgICAgICAgZmlsZTogZVxuICAgICAgfSksXG4gICAgICB0eXBlOiBpXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogU3BsaXQgSFRNTCBzdHJpbmcgdG8gYmxvY2tzIGFuZCByZXR1cm4gaXQgYXMgYXJyYXkgb2YgQmxvY2sgZGF0YVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW5uZXJIVE1MIC0gaHRtbCBzdHJpbmcgdG8gcHJvY2Vzc1xuICAgKiBAcmV0dXJucyB7UGFzdGVEYXRhW119XG4gICAqL1xuICBwcm9jZXNzSFRNTChlKSB7XG4gICAgY29uc3QgeyBUb29sczogdCB9ID0gdGhpcy5FZGl0b3IsIG8gPSBkLm1ha2UoXCJESVZcIik7XG4gICAgcmV0dXJuIG8uaW5uZXJIVE1MID0gZSwgdGhpcy5nZXROb2RlcyhvKS5tYXAoKHMpID0+IHtcbiAgICAgIGxldCByLCBsID0gdC5kZWZhdWx0VG9vbCwgYSA9ICExO1xuICAgICAgc3dpdGNoIChzLm5vZGVUeXBlKSB7XG4gICAgICAgIGNhc2UgTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFOlxuICAgICAgICAgIHIgPSBkLm1ha2UoXCJkaXZcIiksIHIuYXBwZW5kQ2hpbGQocyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTm9kZS5FTEVNRU5UX05PREU6XG4gICAgICAgICAgciA9IHMsIGEgPSAhMCwgdGhpcy50b29sc1RhZ3Nbci50YWdOYW1lXSAmJiAobCA9IHRoaXMudG9vbHNUYWdzW3IudGFnTmFtZV0udG9vbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjb25zdCB7IHRhZ3M6IGMgfSA9IGwucGFzdGVDb25maWcgfHwgeyB0YWdzOiBbXSB9LCB1ID0gYy5yZWR1Y2UoKGcsIGYpID0+ICh0aGlzLmNvbGxlY3RUYWdOYW1lcyhmKS5mb3JFYWNoKChDKSA9PiB7XG4gICAgICAgIGNvbnN0IFMgPSBSKGYpID8gZltDXSA6IG51bGw7XG4gICAgICAgIGdbQy50b0xvd2VyQ2FzZSgpXSA9IFMgfHwge307XG4gICAgICB9KSwgZyksIHt9KSwgaCA9IE9iamVjdC5hc3NpZ24oe30sIHUsIGwuYmFzZVNhbml0aXplQ29uZmlnKTtcbiAgICAgIGlmIChyLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJ0YWJsZVwiKSB7XG4gICAgICAgIGNvbnN0IGcgPSBxKHIub3V0ZXJIVE1MLCBoKTtcbiAgICAgICAgciA9IGQubWFrZShcImRpdlwiLCB2b2lkIDAsIHtcbiAgICAgICAgICBpbm5lckhUTUw6IGdcbiAgICAgICAgfSkuZmlyc3RDaGlsZDtcbiAgICAgIH0gZWxzZVxuICAgICAgICByLmlubmVySFRNTCA9IHEoci5pbm5lckhUTUwsIGgpO1xuICAgICAgY29uc3QgcCA9IHRoaXMuY29tcG9zZVBhc3RlRXZlbnQoXCJ0YWdcIiwge1xuICAgICAgICBkYXRhOiByXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRlbnQ6IHIsXG4gICAgICAgIGlzQmxvY2s6IGEsXG4gICAgICAgIHRvb2w6IGwubmFtZSxcbiAgICAgICAgZXZlbnQ6IHBcbiAgICAgIH07XG4gICAgfSkuZmlsdGVyKChzKSA9PiB7XG4gICAgICBjb25zdCByID0gZC5pc0VtcHR5KHMuY29udGVudCksIGwgPSBkLmlzU2luZ2xlVGFnKHMuY29udGVudCk7XG4gICAgICByZXR1cm4gIXIgfHwgbDtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU3BsaXQgcGxhaW4gdGV4dCBieSBuZXcgbGluZSBzeW1ib2xzIGFuZCByZXR1cm4gaXQgYXMgYXJyYXkgb2YgQmxvY2sgZGF0YVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGxhaW4gLSBzdHJpbmcgdG8gcHJvY2Vzc1xuICAgKiBAcmV0dXJucyB7UGFzdGVEYXRhW119XG4gICAqL1xuICBwcm9jZXNzUGxhaW4oZSkge1xuICAgIGNvbnN0IHsgZGVmYXVsdEJsb2NrOiB0IH0gPSB0aGlzLmNvbmZpZztcbiAgICBpZiAoIWUpXG4gICAgICByZXR1cm4gW107XG4gICAgY29uc3QgbyA9IHQ7XG4gICAgcmV0dXJuIGUuc3BsaXQoL1xccj9cXG4vKS5maWx0ZXIoKGkpID0+IGkudHJpbSgpKS5tYXAoKGkpID0+IHtcbiAgICAgIGNvbnN0IHMgPSBkLm1ha2UoXCJkaXZcIik7XG4gICAgICBzLnRleHRDb250ZW50ID0gaTtcbiAgICAgIGNvbnN0IHIgPSB0aGlzLmNvbXBvc2VQYXN0ZUV2ZW50KFwidGFnXCIsIHtcbiAgICAgICAgZGF0YTogc1xuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb250ZW50OiBzLFxuICAgICAgICB0b29sOiBvLFxuICAgICAgICBpc0Jsb2NrOiAhMSxcbiAgICAgICAgZXZlbnQ6IHJcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFByb2Nlc3MgcGFzdGUgb2Ygc2luZ2xlIEJsb2NrIHRvb2wgY29udGVudFxuICAgKlxuICAgKiBAcGFyYW0ge1Bhc3RlRGF0YX0gZGF0YVRvSW5zZXJ0IC0gZGF0YSBvZiBCbG9jayB0byBpbnNlcnRcbiAgICovXG4gIGFzeW5jIHByb2Nlc3NTaW5nbGVCbG9jayhlKSB7XG4gICAgY29uc3QgeyBDYXJldDogdCwgQmxvY2tNYW5hZ2VyOiBvIH0gPSB0aGlzLkVkaXRvciwgeyBjdXJyZW50QmxvY2s6IGkgfSA9IG87XG4gICAgaWYgKCFpIHx8IGUudG9vbCAhPT0gaS5uYW1lIHx8ICFkLmNvbnRhaW5zT25seUlubGluZUVsZW1lbnRzKGUuY29udGVudC5pbm5lckhUTUwpKSB7XG4gICAgICB0aGlzLmluc2VydEJsb2NrKGUsIChpID09IG51bGwgPyB2b2lkIDAgOiBpLnRvb2wuaXNEZWZhdWx0KSAmJiBpLmlzRW1wdHkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0Lmluc2VydENvbnRlbnRBdENhcmV0UG9zaXRpb24oZS5jb250ZW50LmlubmVySFRNTCk7XG4gIH1cbiAgLyoqXG4gICAqIFByb2Nlc3MgcGFzdGUgdG8gc2luZ2xlIEJsb2NrOlxuICAgKiAxLiBGaW5kIHBhdHRlcm5zYCBtYXRjaGVzXG4gICAqIDIuIEluc2VydCBuZXcgYmxvY2sgaWYgaXQgaXMgbm90IHRoZSBzYW1lIHR5cGUgYXMgY3VycmVudCBvbmVcbiAgICogMy4gSnVzdCBpbnNlcnQgdGV4dCBpZiB0aGVyZSBpcyBubyBzdWJzdGl0dXRpb25zXG4gICAqXG4gICAqIEBwYXJhbSB7UGFzdGVEYXRhfSBkYXRhVG9JbnNlcnQgLSBkYXRhIG9mIEJsb2NrIHRvIGluc2VydFxuICAgKi9cbiAgYXN5bmMgcHJvY2Vzc0lubGluZVBhc3RlKGUpIHtcbiAgICBjb25zdCB7IEJsb2NrTWFuYWdlcjogdCwgQ2FyZXQ6IG8gfSA9IHRoaXMuRWRpdG9yLCB7IGNvbnRlbnQ6IGkgfSA9IGU7XG4gICAgaWYgKHQuY3VycmVudEJsb2NrICYmIHQuY3VycmVudEJsb2NrLnRvb2wuaXNEZWZhdWx0ICYmIGkudGV4dENvbnRlbnQubGVuZ3RoIDwgbG8uUEFUVEVSTl9QUk9DRVNTSU5HX01BWF9MRU5HVEgpIHtcbiAgICAgIGNvbnN0IHIgPSBhd2FpdCB0aGlzLnByb2Nlc3NQYXR0ZXJuKGkudGV4dENvbnRlbnQpO1xuICAgICAgaWYgKHIpIHtcbiAgICAgICAgY29uc3QgbCA9IHQuY3VycmVudEJsb2NrICYmIHQuY3VycmVudEJsb2NrLnRvb2wuaXNEZWZhdWx0ICYmIHQuY3VycmVudEJsb2NrLmlzRW1wdHksIGEgPSB0LnBhc3RlKHIudG9vbCwgci5ldmVudCwgbCk7XG4gICAgICAgIG8uc2V0VG9CbG9jayhhLCBvLnBvc2l0aW9ucy5FTkQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0LmN1cnJlbnRCbG9jayAmJiB0LmN1cnJlbnRCbG9jay5jdXJyZW50SW5wdXQpIHtcbiAgICAgIGNvbnN0IHIgPSB0LmN1cnJlbnRCbG9jay50b29sLmJhc2VTYW5pdGl6ZUNvbmZpZztcbiAgICAgIGRvY3VtZW50LmV4ZWNDb21tYW5kKFxuICAgICAgICBcImluc2VydEhUTUxcIixcbiAgICAgICAgITEsXG4gICAgICAgIHEoaS5pbm5lckhUTUwsIHIpXG4gICAgICApO1xuICAgIH0gZWxzZVxuICAgICAgdGhpcy5pbnNlcnRCbG9jayhlKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHBhdHRlcm5zYCBtYXRjaGVzXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGV4dCB0byBwcm9jZXNzXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHtldmVudDogUGFzdGVFdmVudCwgdG9vbDogc3RyaW5nfT59XG4gICAqL1xuICBhc3luYyBwcm9jZXNzUGF0dGVybihlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMudG9vbHNQYXR0ZXJucy5maW5kKChpKSA9PiB7XG4gICAgICBjb25zdCBzID0gaS5wYXR0ZXJuLmV4ZWMoZSk7XG4gICAgICByZXR1cm4gcyA/IGUgPT09IHMuc2hpZnQoKSA6ICExO1xuICAgIH0pO1xuICAgIHJldHVybiB0ID8ge1xuICAgICAgZXZlbnQ6IHRoaXMuY29tcG9zZVBhc3RlRXZlbnQoXCJwYXR0ZXJuXCIsIHtcbiAgICAgICAga2V5OiB0LmtleSxcbiAgICAgICAgZGF0YTogZVxuICAgICAgfSksXG4gICAgICB0b29sOiB0LnRvb2wubmFtZVxuICAgIH0gOiB2b2lkIDA7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydCBwYXN0ZWQgQmxvY2sgY29udGVudCB0byBFZGl0b3JcbiAgICpcbiAgICogQHBhcmFtIHtQYXN0ZURhdGF9IGRhdGEgLSBkYXRhIHRvIGluc2VydFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNhblJlcGxhY2VDdXJyZW50QmxvY2sgLSBpZiB0cnVlIGFuZCBpcyBjdXJyZW50IEJsb2NrIGlzIGVtcHR5LCB3aWxsIHJlcGxhY2UgY3VycmVudCBCbG9ja1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGluc2VydEJsb2NrKGUsIHQgPSAhMSkge1xuICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiBvLCBDYXJldDogaSB9ID0gdGhpcy5FZGl0b3IsIHsgY3VycmVudEJsb2NrOiBzIH0gPSBvO1xuICAgIGxldCByO1xuICAgIGlmICh0ICYmIHMgJiYgcy5pc0VtcHR5KSB7XG4gICAgICByID0gby5wYXN0ZShlLnRvb2wsIGUuZXZlbnQsICEwKSwgaS5zZXRUb0Jsb2NrKHIsIGkucG9zaXRpb25zLkVORCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHIgPSBvLnBhc3RlKGUudG9vbCwgZS5ldmVudCksIGkuc2V0VG9CbG9jayhyLCBpLnBvc2l0aW9ucy5FTkQpO1xuICB9XG4gIC8qKlxuICAgKiBJbnNlcnQgZGF0YSBwYXNzZWQgYXMgYXBwbGljYXRpb24veC1lZGl0b3ItanMgSlNPTlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBibG9ja3Mg4oCUIEJsb2NrcycgZGF0YSB0byBpbnNlcnRcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBpbnNlcnRFZGl0b3JKU0RhdGEoZSkge1xuICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiB0LCBDYXJldDogbywgVG9vbHM6IGkgfSA9IHRoaXMuRWRpdG9yO1xuICAgIG50KFxuICAgICAgZSxcbiAgICAgIChyKSA9PiBpLmJsb2NrVG9vbHMuZ2V0KHIpLnNhbml0aXplQ29uZmlnXG4gICAgKS5mb3JFYWNoKCh7IHRvb2w6IHIsIGRhdGE6IGwgfSwgYSkgPT4ge1xuICAgICAgbGV0IGMgPSAhMTtcbiAgICAgIGEgPT09IDAgJiYgKGMgPSB0LmN1cnJlbnRCbG9jayAmJiB0LmN1cnJlbnRCbG9jay50b29sLmlzRGVmYXVsdCAmJiB0LmN1cnJlbnRCbG9jay5pc0VtcHR5KTtcbiAgICAgIGNvbnN0IHUgPSB0Lmluc2VydCh7XG4gICAgICAgIHRvb2w6IHIsXG4gICAgICAgIGRhdGE6IGwsXG4gICAgICAgIHJlcGxhY2U6IGNcbiAgICAgIH0pO1xuICAgICAgby5zZXRUb0Jsb2NrKHUsIG8ucG9zaXRpb25zLkVORCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoIG5vZGVzIGZyb20gRWxlbWVudCBub2RlXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIGN1cnJlbnQgbm9kZVxuICAgKiBAcGFyYW0ge05vZGVbXX0gbm9kZXMgLSBwcm9jZXNzZWQgbm9kZXNcbiAgICogQHBhcmFtIHtOb2RlfSBkZXN0Tm9kZSAtIGRlc3RpbmF0aW9uIG5vZGVcbiAgICovXG4gIHByb2Nlc3NFbGVtZW50Tm9kZShlLCB0LCBvKSB7XG4gICAgY29uc3QgaSA9IE9iamVjdC5rZXlzKHRoaXMudG9vbHNUYWdzKSwgcyA9IGUsIHsgdG9vbDogciB9ID0gdGhpcy50b29sc1RhZ3Nbcy50YWdOYW1lXSB8fCB7fSwgbCA9IHRoaXMudGFnc0J5VG9vbFtyID09IG51bGwgPyB2b2lkIDAgOiByLm5hbWVdIHx8IFtdLCBhID0gaS5pbmNsdWRlcyhzLnRhZ05hbWUpLCBjID0gZC5ibG9ja0VsZW1lbnRzLmluY2x1ZGVzKHMudGFnTmFtZS50b0xvd2VyQ2FzZSgpKSwgdSA9IEFycmF5LmZyb20ocy5jaGlsZHJlbikuc29tZShcbiAgICAgICh7IHRhZ05hbWU6IHAgfSkgPT4gaS5pbmNsdWRlcyhwKSAmJiAhbC5pbmNsdWRlcyhwKVxuICAgICksIGggPSBBcnJheS5mcm9tKHMuY2hpbGRyZW4pLnNvbWUoXG4gICAgICAoeyB0YWdOYW1lOiBwIH0pID0+IGQuYmxvY2tFbGVtZW50cy5pbmNsdWRlcyhwLnRvTG93ZXJDYXNlKCkpXG4gICAgKTtcbiAgICBpZiAoIWMgJiYgIWEgJiYgIXUpXG4gICAgICByZXR1cm4gby5hcHBlbmRDaGlsZChzKSwgWy4uLnQsIG9dO1xuICAgIGlmIChhICYmICF1IHx8IGMgJiYgIWggJiYgIXUpXG4gICAgICByZXR1cm4gWy4uLnQsIG8sIHNdO1xuICB9XG4gIC8qKlxuICAgKiBSZWN1cnNpdmVseSBkaXZpZGUgSFRNTCBzdHJpbmcgdG8gdHdvIHR5cGVzIG9mIG5vZGVzOlxuICAgKiAxLiBCbG9jayBlbGVtZW50XG4gICAqIDIuIERvY3VtZW50IEZyYWdtZW50cyBjb250YWluZWQgdGV4dCBhbmQgbWFya3VwIHRhZ3MgbGlrZSBhLCBiLCBpIGV0Yy5cbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSB3cmFwcGVyIC0gd3JhcHBlciBvZiBwYXN0ZXIgSFRNTCBjb250ZW50XG4gICAqIEByZXR1cm5zIHtOb2RlW119XG4gICAqL1xuICBnZXROb2RlcyhlKSB7XG4gICAgY29uc3QgdCA9IEFycmF5LmZyb20oZS5jaGlsZE5vZGVzKTtcbiAgICBsZXQgbztcbiAgICBjb25zdCBpID0gKHMsIHIpID0+IHtcbiAgICAgIGlmIChkLmlzRW1wdHkocikgJiYgIWQuaXNTaW5nbGVUYWcocikpXG4gICAgICAgIHJldHVybiBzO1xuICAgICAgY29uc3QgbCA9IHNbcy5sZW5ndGggLSAxXTtcbiAgICAgIGxldCBhID0gbmV3IERvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgIHN3aXRjaCAobCAmJiBkLmlzRnJhZ21lbnQobCkgJiYgKGEgPSBzLnBvcCgpKSwgci5ub2RlVHlwZSkge1xuICAgICAgICBjYXNlIE5vZGUuRUxFTUVOVF9OT0RFOlxuICAgICAgICAgIGlmIChvID0gdGhpcy5wcm9jZXNzRWxlbWVudE5vZGUociwgcywgYSksIG8pXG4gICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBOb2RlLlRFWFRfTk9ERTpcbiAgICAgICAgICByZXR1cm4gYS5hcHBlbmRDaGlsZChyKSwgWy4uLnMsIGFdO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBbLi4ucywgYV07XG4gICAgICB9XG4gICAgICByZXR1cm4gWy4uLnMsIC4uLkFycmF5LmZyb20oci5jaGlsZE5vZGVzKS5yZWR1Y2UoaSwgW10pXTtcbiAgICB9O1xuICAgIHJldHVybiB0LnJlZHVjZShpLCBbXSk7XG4gIH1cbiAgLyoqXG4gICAqIENvbXBvc2UgcGFzdGUgZXZlbnQgd2l0aCBwYXNzZWQgdHlwZSBhbmQgZGV0YWlsXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gZXZlbnQgdHlwZVxuICAgKiBAcGFyYW0ge1Bhc3RlRXZlbnREZXRhaWx9IGRldGFpbCAtIGV2ZW50IGRldGFpbFxuICAgKi9cbiAgY29tcG9zZVBhc3RlRXZlbnQoZSwgdCkge1xuICAgIHJldHVybiBuZXcgQ3VzdG9tRXZlbnQoZSwge1xuICAgICAgZGV0YWlsOiB0XG4gICAgfSk7XG4gIH1cbn07XG5yby5QQVRURVJOX1BST0NFU1NJTkdfTUFYX0xFTkdUSCA9IDQ1MDtcbmxldCBucyA9IHJvO1xuY2xhc3MgcnMgZXh0ZW5kcyB5IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy50b29sc0RvbnRTdXBwb3J0UmVhZE9ubHkgPSBbXSwgdGhpcy5yZWFkT25seUVuYWJsZWQgPSAhMTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBzdGF0ZSBvZiByZWFkIG9ubHkgbW9kZVxuICAgKi9cbiAgZ2V0IGlzRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkT25seUVuYWJsZWQ7XG4gIH1cbiAgLyoqXG4gICAqIFNldCBpbml0aWFsIHN0YXRlXG4gICAqL1xuICBhc3luYyBwcmVwYXJlKCkge1xuICAgIGNvbnN0IHsgVG9vbHM6IGUgfSA9IHRoaXMuRWRpdG9yLCB7IGJsb2NrVG9vbHM6IHQgfSA9IGUsIG8gPSBbXTtcbiAgICBBcnJheS5mcm9tKHQuZW50cmllcygpKS5mb3JFYWNoKChbaSwgc10pID0+IHtcbiAgICAgIHMuaXNSZWFkT25seVN1cHBvcnRlZCB8fCBvLnB1c2goaSk7XG4gICAgfSksIHRoaXMudG9vbHNEb250U3VwcG9ydFJlYWRPbmx5ID0gbywgdGhpcy5jb25maWcucmVhZE9ubHkgJiYgby5sZW5ndGggPiAwICYmIHRoaXMudGhyb3dDcml0aWNhbEVycm9yKCksIHRoaXMudG9nZ2xlKHRoaXMuY29uZmlnLnJlYWRPbmx5KTtcbiAgfVxuICAvKipcbiAgICogU2V0IHJlYWQtb25seSBtb2RlIG9yIHRvZ2dsZSBjdXJyZW50IHN0YXRlXG4gICAqIENhbGwgYWxsIE1vZHVsZXMgYHRvZ2dsZVJlYWRPbmx5YCBtZXRob2QgYW5kIHJlLXJlbmRlciBFZGl0b3JcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBzdGF0ZSAtIChvcHRpb25hbCkgcmVhZC1vbmx5IHN0YXRlIG9yIHRvZ2dsZVxuICAgKi9cbiAgYXN5bmMgdG9nZ2xlKGUgPSAhdGhpcy5yZWFkT25seUVuYWJsZWQpIHtcbiAgICBlICYmIHRoaXMudG9vbHNEb250U3VwcG9ydFJlYWRPbmx5Lmxlbmd0aCA+IDAgJiYgdGhpcy50aHJvd0NyaXRpY2FsRXJyb3IoKTtcbiAgICBjb25zdCB0ID0gdGhpcy5yZWFkT25seUVuYWJsZWQ7XG4gICAgdGhpcy5yZWFkT25seUVuYWJsZWQgPSBlO1xuICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLkVkaXRvcilcbiAgICAgIHRoaXMuRWRpdG9yW2ldLnRvZ2dsZVJlYWRPbmx5ICYmIHRoaXMuRWRpdG9yW2ldLnRvZ2dsZVJlYWRPbmx5KGUpO1xuICAgIGlmICh0ID09PSBlKVxuICAgICAgcmV0dXJuIHRoaXMucmVhZE9ubHlFbmFibGVkO1xuICAgIGNvbnN0IG8gPSBhd2FpdCB0aGlzLkVkaXRvci5TYXZlci5zYXZlKCk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5jbGVhcigpLCBhd2FpdCB0aGlzLkVkaXRvci5SZW5kZXJlci5yZW5kZXIoby5ibG9ja3MpLCB0aGlzLnJlYWRPbmx5RW5hYmxlZDtcbiAgfVxuICAvKipcbiAgICogVGhyb3dzIGFuIGVycm9yIGFib3V0IHRvb2xzIHdoaWNoIGRvbid0IHN1cHBvcnQgcmVhZC1vbmx5IG1vZGVcbiAgICovXG4gIHRocm93Q3JpdGljYWxFcnJvcigpIHtcbiAgICB0aHJvdyBuZXcgTnQoXG4gICAgICBgVG8gZW5hYmxlIHJlYWQtb25seSBtb2RlIGFsbCBjb25uZWN0ZWQgdG9vbHMgc2hvdWxkIHN1cHBvcnQgaXQuIFRvb2xzICR7dGhpcy50b29sc0RvbnRTdXBwb3J0UmVhZE9ubHkuam9pbihcIiwgXCIpfSBkb24ndCBzdXBwb3J0IHJlYWQtb25seSBtb2RlLmBcbiAgICApO1xuICB9XG59XG5jbGFzcyB3ZSBleHRlbmRzIHkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLmlzUmVjdFNlbGVjdGlvbkFjdGl2YXRlZCA9ICExLCB0aGlzLlNDUk9MTF9TUEVFRCA9IDMsIHRoaXMuSEVJR0hUX09GX1NDUk9MTF9aT05FID0gNDAsIHRoaXMuQk9UVE9NX1NDUk9MTF9aT05FID0gMSwgdGhpcy5UT1BfU0NST0xMX1pPTkUgPSAyLCB0aGlzLk1BSU5fTU9VU0VfQlVUVE9OID0gMCwgdGhpcy5tb3VzZWRvd24gPSAhMSwgdGhpcy5pc1Njcm9sbGluZyA9ICExLCB0aGlzLmluU2Nyb2xsWm9uZSA9IG51bGwsIHRoaXMuc3RhcnRYID0gMCwgdGhpcy5zdGFydFkgPSAwLCB0aGlzLm1vdXNlWCA9IDAsIHRoaXMubW91c2VZID0gMCwgdGhpcy5zdGFja09mU2VsZWN0ZWQgPSBbXSwgdGhpcy5saXN0ZW5lcklkcyA9IFtdO1xuICB9XG4gIC8qKlxuICAgKiBDU1MgY2xhc3NlcyBmb3IgdGhlIEJsb2NrXG4gICAqXG4gICAqIEByZXR1cm5zIHt7d3JhcHBlcjogc3RyaW5nLCBjb250ZW50OiBzdHJpbmd9fVxuICAgKi9cbiAgc3RhdGljIGdldCBDU1MoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG92ZXJsYXk6IFwiY29kZXgtZWRpdG9yLW92ZXJsYXlcIixcbiAgICAgIG92ZXJsYXlDb250YWluZXI6IFwiY29kZXgtZWRpdG9yLW92ZXJsYXlfX2NvbnRhaW5lclwiLFxuICAgICAgcmVjdDogXCJjb2RleC1lZGl0b3Itb3ZlcmxheV9fcmVjdGFuZ2xlXCIsXG4gICAgICB0b3BTY3JvbGxab25lOiBcImNvZGV4LWVkaXRvci1vdmVybGF5X19zY3JvbGwtem9uZS0tdG9wXCIsXG4gICAgICBib3R0b21TY3JvbGxab25lOiBcImNvZGV4LWVkaXRvci1vdmVybGF5X19zY3JvbGwtem9uZS0tYm90dG9tXCJcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBNb2R1bGUgUHJlcGFyYXRpb25cbiAgICogQ3JlYXRpbmcgcmVjdCBhbmQgaGFuZyBoYW5kbGVyc1xuICAgKi9cbiAgcHJlcGFyZSgpIHtcbiAgICB0aGlzLmVuYWJsZU1vZHVsZUJpbmRpbmdzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEluaXQgcmVjdCBwYXJhbXNcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBhZ2VYIC0gWCBjb29yZCBvZiBtb3VzZVxuICAgKiBAcGFyYW0ge251bWJlcn0gcGFnZVkgLSBZIGNvb3JkIG9mIG1vdXNlXG4gICAqL1xuICBzdGFydFNlbGVjdGlvbihlLCB0KSB7XG4gICAgY29uc3QgbyA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoZSAtIHdpbmRvdy5wYWdlWE9mZnNldCwgdCAtIHdpbmRvdy5wYWdlWU9mZnNldCk7XG4gICAgby5jbG9zZXN0KGAuJHt0aGlzLkVkaXRvci5Ub29sYmFyLkNTUy50b29sYmFyfWApIHx8ICh0aGlzLkVkaXRvci5CbG9ja1NlbGVjdGlvbi5hbGxCbG9ja3NTZWxlY3RlZCA9ICExLCB0aGlzLmNsZWFyU2VsZWN0aW9uKCksIHRoaXMuc3RhY2tPZlNlbGVjdGVkID0gW10pO1xuICAgIGNvbnN0IHMgPSBbXG4gICAgICBgLiR7RC5DU1MuY29udGVudH1gLFxuICAgICAgYC4ke3RoaXMuRWRpdG9yLlRvb2xiYXIuQ1NTLnRvb2xiYXJ9YCxcbiAgICAgIGAuJHt0aGlzLkVkaXRvci5JbmxpbmVUb29sYmFyLkNTUy5pbmxpbmVUb29sYmFyfWBcbiAgICBdLCByID0gby5jbG9zZXN0KFwiLlwiICsgdGhpcy5FZGl0b3IuVUkuQ1NTLmVkaXRvcldyYXBwZXIpLCBsID0gcy5zb21lKChhKSA9PiAhIW8uY2xvc2VzdChhKSk7XG4gICAgIXIgfHwgbCB8fCAodGhpcy5tb3VzZWRvd24gPSAhMCwgdGhpcy5zdGFydFggPSBlLCB0aGlzLnN0YXJ0WSA9IHQpO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhciBhbGwgcGFyYW1zIHRvIGVuZCBzZWxlY3Rpb25cbiAgICovXG4gIGVuZFNlbGVjdGlvbigpIHtcbiAgICB0aGlzLm1vdXNlZG93biA9ICExLCB0aGlzLnN0YXJ0WCA9IDAsIHRoaXMuc3RhcnRZID0gMCwgdGhpcy5vdmVybGF5UmVjdGFuZ2xlLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgfVxuICAvKipcbiAgICogaXMgUmVjdFNlbGVjdGlvbiBBY3RpdmF0ZWRcbiAgICovXG4gIGlzUmVjdEFjdGl2YXRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1JlY3RTZWxlY3Rpb25BY3RpdmF0ZWQ7XG4gIH1cbiAgLyoqXG4gICAqIE1hcmsgdGhhdCBzZWxlY3Rpb24gaXMgZW5kXG4gICAqL1xuICBjbGVhclNlbGVjdGlvbigpIHtcbiAgICB0aGlzLmlzUmVjdFNlbGVjdGlvbkFjdGl2YXRlZCA9ICExO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIE1vZHVsZSBuZWNlc3NhcnkgZXZlbnQgaGFuZGxlcnNcbiAgICovXG4gIGVuYWJsZU1vZHVsZUJpbmRpbmdzKCkge1xuICAgIGNvbnN0IHsgY29udGFpbmVyOiBlIH0gPSB0aGlzLmdlbkhUTUwoKTtcbiAgICB0aGlzLmxpc3RlbmVycy5vbihlLCBcIm1vdXNlZG93blwiLCAodCkgPT4ge1xuICAgICAgdGhpcy5wcm9jZXNzTW91c2VEb3duKHQpO1xuICAgIH0sICExKSwgdGhpcy5saXN0ZW5lcnMub24oZG9jdW1lbnQuYm9keSwgXCJtb3VzZW1vdmVcIiwgVmUoKHQpID0+IHtcbiAgICAgIHRoaXMucHJvY2Vzc01vdXNlTW92ZSh0KTtcbiAgICB9LCAxMCksIHtcbiAgICAgIHBhc3NpdmU6ICEwXG4gICAgfSksIHRoaXMubGlzdGVuZXJzLm9uKGRvY3VtZW50LmJvZHksIFwibW91c2VsZWF2ZVwiLCAoKSA9PiB7XG4gICAgICB0aGlzLnByb2Nlc3NNb3VzZUxlYXZlKCk7XG4gICAgfSksIHRoaXMubGlzdGVuZXJzLm9uKHdpbmRvdywgXCJzY3JvbGxcIiwgVmUoKHQpID0+IHtcbiAgICAgIHRoaXMucHJvY2Vzc1Njcm9sbCh0KTtcbiAgICB9LCAxMCksIHtcbiAgICAgIHBhc3NpdmU6ICEwXG4gICAgfSksIHRoaXMubGlzdGVuZXJzLm9uKGRvY3VtZW50LmJvZHksIFwibW91c2V1cFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLnByb2Nlc3NNb3VzZVVwKCk7XG4gICAgfSwgITEpO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGUgbW91c2UgZG93biBldmVudHNcbiAgICpcbiAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBtb3VzZUV2ZW50IC0gbW91c2UgZXZlbnQgcGF5bG9hZFxuICAgKi9cbiAgcHJvY2Vzc01vdXNlRG93bihlKSB7XG4gICAgaWYgKGUuYnV0dG9uICE9PSB0aGlzLk1BSU5fTU9VU0VfQlVUVE9OKVxuICAgICAgcmV0dXJuO1xuICAgIGUudGFyZ2V0LmNsb3Nlc3QoZC5hbGxJbnB1dHNTZWxlY3RvcikgIT09IG51bGwgfHwgdGhpcy5zdGFydFNlbGVjdGlvbihlLnBhZ2VYLCBlLnBhZ2VZKTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlIG1vdXNlIG1vdmUgZXZlbnRzXG4gICAqXG4gICAqIEBwYXJhbSB7TW91c2VFdmVudH0gbW91c2VFdmVudCAtIG1vdXNlIGV2ZW50IHBheWxvYWRcbiAgICovXG4gIHByb2Nlc3NNb3VzZU1vdmUoZSkge1xuICAgIHRoaXMuY2hhbmdpbmdSZWN0YW5nbGUoZSksIHRoaXMuc2Nyb2xsQnlab25lcyhlLmNsaWVudFkpO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGUgbW91c2UgbGVhdmVcbiAgICovXG4gIHByb2Nlc3NNb3VzZUxlYXZlKCkge1xuICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKSwgdGhpcy5lbmRTZWxlY3Rpb24oKTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBtb3VzZUV2ZW50IC0gbW91c2UgZXZlbnQgcGF5bG9hZFxuICAgKi9cbiAgcHJvY2Vzc1Njcm9sbChlKSB7XG4gICAgdGhpcy5jaGFuZ2luZ1JlY3RhbmdsZShlKTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlIG1vdXNlIHVwXG4gICAqL1xuICBwcm9jZXNzTW91c2VVcCgpIHtcbiAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKCksIHRoaXMuZW5kU2VsZWN0aW9uKCk7XG4gIH1cbiAgLyoqXG4gICAqIFNjcm9sbCBJZiBtb3VzZSBpbiBzY3JvbGwgem9uZVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gY2xpZW50WSAtIFkgY29vcmQgb2YgbW91c2VcbiAgICovXG4gIHNjcm9sbEJ5Wm9uZXMoZSkge1xuICAgIGlmICh0aGlzLmluU2Nyb2xsWm9uZSA9IG51bGwsIGUgPD0gdGhpcy5IRUlHSFRfT0ZfU0NST0xMX1pPTkUgJiYgKHRoaXMuaW5TY3JvbGxab25lID0gdGhpcy5UT1BfU0NST0xMX1pPTkUpLCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0IC0gZSA8PSB0aGlzLkhFSUdIVF9PRl9TQ1JPTExfWk9ORSAmJiAodGhpcy5pblNjcm9sbFpvbmUgPSB0aGlzLkJPVFRPTV9TQ1JPTExfWk9ORSksICF0aGlzLmluU2Nyb2xsWm9uZSkge1xuICAgICAgdGhpcy5pc1Njcm9sbGluZyA9ICExO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmlzU2Nyb2xsaW5nIHx8ICh0aGlzLnNjcm9sbFZlcnRpY2FsKHRoaXMuaW5TY3JvbGxab25lID09PSB0aGlzLlRPUF9TQ1JPTExfWk9ORSA/IC10aGlzLlNDUk9MTF9TUEVFRCA6IHRoaXMuU0NST0xMX1NQRUVEKSwgdGhpcy5pc1Njcm9sbGluZyA9ICEwKTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIHJlcXVpcmVkIEhUTUwgZWxlbWVudHNcbiAgICpcbiAgICogQHJldHVybnMge09iamVjdDxzdHJpbmcsIEVsZW1lbnQ+fVxuICAgKi9cbiAgZ2VuSFRNTCgpIHtcbiAgICBjb25zdCB7IFVJOiBlIH0gPSB0aGlzLkVkaXRvciwgdCA9IGUubm9kZXMuaG9sZGVyLnF1ZXJ5U2VsZWN0b3IoXCIuXCIgKyBlLkNTUy5lZGl0b3JXcmFwcGVyKSwgbyA9IGQubWFrZShcImRpdlwiLCB3ZS5DU1Mub3ZlcmxheSwge30pLCBpID0gZC5tYWtlKFwiZGl2XCIsIHdlLkNTUy5vdmVybGF5Q29udGFpbmVyLCB7fSksIHMgPSBkLm1ha2UoXCJkaXZcIiwgd2UuQ1NTLnJlY3QsIHt9KTtcbiAgICByZXR1cm4gaS5hcHBlbmRDaGlsZChzKSwgby5hcHBlbmRDaGlsZChpKSwgdC5hcHBlbmRDaGlsZChvKSwgdGhpcy5vdmVybGF5UmVjdGFuZ2xlID0gcywge1xuICAgICAgY29udGFpbmVyOiB0LFxuICAgICAgb3ZlcmxheTogb1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEFjdGl2YXRlcyBzY3JvbGxpbmcgaWYgYmxvY2tTZWxlY3Rpb24gaXMgYWN0aXZlIGFuZCBtb3VzZSBpcyBpbiBzY3JvbGwgem9uZVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc3BlZWQgLSBzcGVlZCBvZiBzY3JvbGxpbmdcbiAgICovXG4gIHNjcm9sbFZlcnRpY2FsKGUpIHtcbiAgICBpZiAoISh0aGlzLmluU2Nyb2xsWm9uZSAmJiB0aGlzLm1vdXNlZG93bikpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IHdpbmRvdy5wYWdlWU9mZnNldDtcbiAgICB3aW5kb3cuc2Nyb2xsQnkoMCwgZSksIHRoaXMubW91c2VZICs9IHdpbmRvdy5wYWdlWU9mZnNldCAtIHQsIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5zY3JvbGxWZXJ0aWNhbChlKTtcbiAgICB9LCAwKTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlcyB0aGUgY2hhbmdlIGluIHRoZSByZWN0YW5nbGUgYW5kIGl0cyBlZmZlY3RcbiAgICpcbiAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudCAtIG1vdXNlIGV2ZW50XG4gICAqL1xuICBjaGFuZ2luZ1JlY3RhbmdsZShlKSB7XG4gICAgaWYgKCF0aGlzLm1vdXNlZG93bilcbiAgICAgIHJldHVybjtcbiAgICBlLnBhZ2VZICE9PSB2b2lkIDAgJiYgKHRoaXMubW91c2VYID0gZS5wYWdlWCwgdGhpcy5tb3VzZVkgPSBlLnBhZ2VZKTtcbiAgICBjb25zdCB7IHJpZ2h0UG9zOiB0LCBsZWZ0UG9zOiBvLCBpbmRleDogaSB9ID0gdGhpcy5nZW5JbmZvRm9yTW91c2VTZWxlY3Rpb24oKSwgcyA9IHRoaXMuc3RhcnRYID4gdCAmJiB0aGlzLm1vdXNlWCA+IHQsIHIgPSB0aGlzLnN0YXJ0WCA8IG8gJiYgdGhpcy5tb3VzZVggPCBvO1xuICAgIHRoaXMucmVjdENyb3NzZXNCbG9ja3MgPSAhKHMgfHwgciksIHRoaXMuaXNSZWN0U2VsZWN0aW9uQWN0aXZhdGVkIHx8ICh0aGlzLnJlY3RDcm9zc2VzQmxvY2tzID0gITEsIHRoaXMuaXNSZWN0U2VsZWN0aW9uQWN0aXZhdGVkID0gITAsIHRoaXMuc2hyaW5rUmVjdGFuZ2xlVG9Qb2ludCgpLCB0aGlzLm92ZXJsYXlSZWN0YW5nbGUuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIiksIHRoaXMudXBkYXRlUmVjdGFuZ2xlU2l6ZSgpLCB0aGlzLkVkaXRvci5Ub29sYmFyLmNsb3NlKCksIGkgIT09IHZvaWQgMCAmJiAodGhpcy50cnlTZWxlY3ROZXh0QmxvY2soaSksIHRoaXMuaW52ZXJzZVNlbGVjdGlvbigpLCBiLmdldCgpLnJlbW92ZUFsbFJhbmdlcygpKTtcbiAgfVxuICAvKipcbiAgICogU2hyaW5rIHJlY3QgdG8gc2luZ3VsYXIgcG9pbnRcbiAgICovXG4gIHNocmlua1JlY3RhbmdsZVRvUG9pbnQoKSB7XG4gICAgdGhpcy5vdmVybGF5UmVjdGFuZ2xlLnN0eWxlLmxlZnQgPSBgJHt0aGlzLnN0YXJ0WCAtIHdpbmRvdy5wYWdlWE9mZnNldH1weGAsIHRoaXMub3ZlcmxheVJlY3RhbmdsZS5zdHlsZS50b3AgPSBgJHt0aGlzLnN0YXJ0WSAtIHdpbmRvdy5wYWdlWU9mZnNldH1weGAsIHRoaXMub3ZlcmxheVJlY3RhbmdsZS5zdHlsZS5ib3R0b20gPSBgY2FsYygxMDAlIC0gJHt0aGlzLnN0YXJ0WSAtIHdpbmRvdy5wYWdlWU9mZnNldH1weGAsIHRoaXMub3ZlcmxheVJlY3RhbmdsZS5zdHlsZS5yaWdodCA9IGBjYWxjKDEwMCUgLSAke3RoaXMuc3RhcnRYIC0gd2luZG93LnBhZ2VYT2Zmc2V0fXB4YDtcbiAgfVxuICAvKipcbiAgICogU2VsZWN0IG9yIHVuc2VsZWN0IGFsbCBvZiBibG9ja3MgaW4gYXJyYXkgaWYgcmVjdCBpcyBvdXQgb3IgaW4gc2VsZWN0YWJsZSBhcmVhXG4gICAqL1xuICBpbnZlcnNlU2VsZWN0aW9uKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuZ2V0QmxvY2tCeUluZGV4KHRoaXMuc3RhY2tPZlNlbGVjdGVkWzBdKS5zZWxlY3RlZDtcbiAgICBpZiAodGhpcy5yZWN0Q3Jvc3Nlc0Jsb2NrcyAmJiAhdClcbiAgICAgIGZvciAoY29uc3QgbyBvZiB0aGlzLnN0YWNrT2ZTZWxlY3RlZClcbiAgICAgICAgdGhpcy5FZGl0b3IuQmxvY2tTZWxlY3Rpb24uc2VsZWN0QmxvY2tCeUluZGV4KG8pO1xuICAgIGlmICghdGhpcy5yZWN0Q3Jvc3Nlc0Jsb2NrcyAmJiB0KVxuICAgICAgZm9yIChjb25zdCBvIG9mIHRoaXMuc3RhY2tPZlNlbGVjdGVkKVxuICAgICAgICB0aGlzLkVkaXRvci5CbG9ja1NlbGVjdGlvbi51blNlbGVjdEJsb2NrQnlJbmRleChvKTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyBzaXplIG9mIHJlY3RhbmdsZVxuICAgKi9cbiAgdXBkYXRlUmVjdGFuZ2xlU2l6ZSgpIHtcbiAgICB0aGlzLm1vdXNlWSA+PSB0aGlzLnN0YXJ0WSA/ICh0aGlzLm92ZXJsYXlSZWN0YW5nbGUuc3R5bGUudG9wID0gYCR7dGhpcy5zdGFydFkgLSB3aW5kb3cucGFnZVlPZmZzZXR9cHhgLCB0aGlzLm92ZXJsYXlSZWN0YW5nbGUuc3R5bGUuYm90dG9tID0gYGNhbGMoMTAwJSAtICR7dGhpcy5tb3VzZVkgLSB3aW5kb3cucGFnZVlPZmZzZXR9cHhgKSA6ICh0aGlzLm92ZXJsYXlSZWN0YW5nbGUuc3R5bGUuYm90dG9tID0gYGNhbGMoMTAwJSAtICR7dGhpcy5zdGFydFkgLSB3aW5kb3cucGFnZVlPZmZzZXR9cHhgLCB0aGlzLm92ZXJsYXlSZWN0YW5nbGUuc3R5bGUudG9wID0gYCR7dGhpcy5tb3VzZVkgLSB3aW5kb3cucGFnZVlPZmZzZXR9cHhgKSwgdGhpcy5tb3VzZVggPj0gdGhpcy5zdGFydFggPyAodGhpcy5vdmVybGF5UmVjdGFuZ2xlLnN0eWxlLmxlZnQgPSBgJHt0aGlzLnN0YXJ0WCAtIHdpbmRvdy5wYWdlWE9mZnNldH1weGAsIHRoaXMub3ZlcmxheVJlY3RhbmdsZS5zdHlsZS5yaWdodCA9IGBjYWxjKDEwMCUgLSAke3RoaXMubW91c2VYIC0gd2luZG93LnBhZ2VYT2Zmc2V0fXB4YCkgOiAodGhpcy5vdmVybGF5UmVjdGFuZ2xlLnN0eWxlLnJpZ2h0ID0gYGNhbGMoMTAwJSAtICR7dGhpcy5zdGFydFggLSB3aW5kb3cucGFnZVhPZmZzZXR9cHhgLCB0aGlzLm92ZXJsYXlSZWN0YW5nbGUuc3R5bGUubGVmdCA9IGAke3RoaXMubW91c2VYIC0gd2luZG93LnBhZ2VYT2Zmc2V0fXB4YCk7XG4gIH1cbiAgLyoqXG4gICAqIENvbGxlY3RzIGluZm9ybWF0aW9uIG5lZWRlZCB0byBkZXRlcm1pbmUgdGhlIGJlaGF2aW9yIG9mIHRoZSByZWN0YW5nbGVcbiAgICpcbiAgICogQHJldHVybnMge29iamVjdH0gaW5kZXggLSBpbmRleCBuZXh0IEJsb2NrLCBsZWZ0UG9zIC0gc3RhcnQgb2YgbGVmdCBib3JkZXIgb2YgQmxvY2ssIHJpZ2h0UG9zIC0gcmlnaHQgYm9yZGVyXG4gICAqL1xuICBnZW5JbmZvRm9yTW91c2VTZWxlY3Rpb24oKSB7XG4gICAgY29uc3QgdCA9IGRvY3VtZW50LmJvZHkub2Zmc2V0V2lkdGggLyAyLCBvID0gdGhpcy5tb3VzZVkgLSB3aW5kb3cucGFnZVlPZmZzZXQsIGkgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHQsIG8pLCBzID0gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmdldEJsb2NrQnlDaGlsZE5vZGUoaSk7XG4gICAgbGV0IHI7XG4gICAgcyAhPT0gdm9pZCAwICYmIChyID0gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmJsb2Nrcy5maW5kSW5kZXgoKGgpID0+IGguaG9sZGVyID09PSBzLmhvbGRlcikpO1xuICAgIGNvbnN0IGwgPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIubGFzdEJsb2NrLmhvbGRlci5xdWVyeVNlbGVjdG9yKFwiLlwiICsgRC5DU1MuY29udGVudCksIGEgPSBOdW1iZXIucGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUobCkud2lkdGgsIDEwKSAvIDIsIGMgPSB0IC0gYSwgdSA9IHQgKyBhO1xuICAgIHJldHVybiB7XG4gICAgICBpbmRleDogcixcbiAgICAgIGxlZnRQb3M6IGMsXG4gICAgICByaWdodFBvczogdVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFNlbGVjdCBibG9jayB3aXRoIGluZGV4IGluZGV4XG4gICAqXG4gICAqIEBwYXJhbSBpbmRleCAtIGluZGV4IG9mIGJsb2NrIGluIHJlZGFjdG9yXG4gICAqL1xuICBhZGRCbG9ja0luU2VsZWN0aW9uKGUpIHtcbiAgICB0aGlzLnJlY3RDcm9zc2VzQmxvY2tzICYmIHRoaXMuRWRpdG9yLkJsb2NrU2VsZWN0aW9uLnNlbGVjdEJsb2NrQnlJbmRleChlKSwgdGhpcy5zdGFja09mU2VsZWN0ZWQucHVzaChlKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIGJsb2NrIHRvIHRoZSBzZWxlY3Rpb24gYW5kIGRldGVybWluZXMgd2hpY2ggYmxvY2tzIHNob3VsZCBiZSBzZWxlY3RlZFxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5kZXggLSBpbmRleCBvZiBuZXcgYmxvY2sgaW4gdGhlIHJlYWN0b3JcbiAgICovXG4gIHRyeVNlbGVjdE5leHRCbG9jayhlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuc3RhY2tPZlNlbGVjdGVkW3RoaXMuc3RhY2tPZlNlbGVjdGVkLmxlbmd0aCAtIDFdID09PSBlLCBvID0gdGhpcy5zdGFja09mU2VsZWN0ZWQubGVuZ3RoLCBpID0gMSwgcyA9IC0xLCByID0gMDtcbiAgICBpZiAodClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBsID0gdGhpcy5zdGFja09mU2VsZWN0ZWRbbyAtIDFdIC0gdGhpcy5zdGFja09mU2VsZWN0ZWRbbyAtIDJdID4gMDtcbiAgICBsZXQgYSA9IHI7XG4gICAgbyA+IDEgJiYgKGEgPSBsID8gaSA6IHMpO1xuICAgIGNvbnN0IGMgPSBlID4gdGhpcy5zdGFja09mU2VsZWN0ZWRbbyAtIDFdICYmIGEgPT09IGksIHUgPSBlIDwgdGhpcy5zdGFja09mU2VsZWN0ZWRbbyAtIDFdICYmIGEgPT09IHMsIHAgPSAhKGMgfHwgdSB8fCBhID09PSByKTtcbiAgICBpZiAoIXAgJiYgKGUgPiB0aGlzLnN0YWNrT2ZTZWxlY3RlZFtvIC0gMV0gfHwgdGhpcy5zdGFja09mU2VsZWN0ZWRbbyAtIDFdID09PSB2b2lkIDApKSB7XG4gICAgICBsZXQgayA9IHRoaXMuc3RhY2tPZlNlbGVjdGVkW28gLSAxXSArIDEgfHwgZTtcbiAgICAgIGZvciAoazsgayA8PSBlOyBrKyspXG4gICAgICAgIHRoaXMuYWRkQmxvY2tJblNlbGVjdGlvbihrKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFwICYmIGUgPCB0aGlzLnN0YWNrT2ZTZWxlY3RlZFtvIC0gMV0pIHtcbiAgICAgIGZvciAobGV0IGsgPSB0aGlzLnN0YWNrT2ZTZWxlY3RlZFtvIC0gMV0gLSAxOyBrID49IGU7IGstLSlcbiAgICAgICAgdGhpcy5hZGRCbG9ja0luU2VsZWN0aW9uKGspO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXApXG4gICAgICByZXR1cm47XG4gICAgbGV0IGcgPSBvIC0gMSwgZjtcbiAgICBmb3IgKGUgPiB0aGlzLnN0YWNrT2ZTZWxlY3RlZFtvIC0gMV0gPyBmID0gKCkgPT4gZSA+IHRoaXMuc3RhY2tPZlNlbGVjdGVkW2ddIDogZiA9ICgpID0+IGUgPCB0aGlzLnN0YWNrT2ZTZWxlY3RlZFtnXTsgZigpOyApXG4gICAgICB0aGlzLnJlY3RDcm9zc2VzQmxvY2tzICYmIHRoaXMuRWRpdG9yLkJsb2NrU2VsZWN0aW9uLnVuU2VsZWN0QmxvY2tCeUluZGV4KHRoaXMuc3RhY2tPZlNlbGVjdGVkW2ddKSwgdGhpcy5zdGFja09mU2VsZWN0ZWQucG9wKCksIGctLTtcbiAgfVxufVxuY2xhc3MgbHMgZXh0ZW5kcyB5IHtcbiAgLyoqXG4gICAqIFJlbmRlcnMgcGFzc2VkIGJsb2NrcyBhcyBvbmUgYmF0Y2hcbiAgICpcbiAgICogQHBhcmFtIGJsb2Nrc0RhdGEgLSBibG9ja3MgdG8gcmVuZGVyXG4gICAqL1xuICBhc3luYyByZW5kZXIoZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgodCkgPT4ge1xuICAgICAgY29uc3QgeyBUb29sczogbywgQmxvY2tNYW5hZ2VyOiBpIH0gPSB0aGlzLkVkaXRvcjtcbiAgICAgIGlmIChlLmxlbmd0aCA9PT0gMClcbiAgICAgICAgaS5pbnNlcnQoKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBzID0gZS5tYXAoKHsgdHlwZTogciwgZGF0YTogbCwgdHVuZXM6IGEsIGlkOiBjIH0pID0+IHtcbiAgICAgICAgICBvLmF2YWlsYWJsZS5oYXMocikgPT09ICExICYmIChLKGBUb29sIMKrJHtyfcK7IGlzIG5vdCBmb3VuZC4gQ2hlY2sgJ3Rvb2xzJyBwcm9wZXJ0eSBhdCB0aGUgRWRpdG9yLmpzIGNvbmZpZy5gLCBcIndhcm5cIiksIGwgPSB0aGlzLmNvbXBvc2VTdHViRGF0YUZvclRvb2wociwgbCwgYyksIHIgPSBvLnN0dWJUb29sKTtcbiAgICAgICAgICBsZXQgdTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdSA9IGkuY29tcG9zZUJsb2NrKHtcbiAgICAgICAgICAgICAgaWQ6IGMsXG4gICAgICAgICAgICAgIHRvb2w6IHIsXG4gICAgICAgICAgICAgIGRhdGE6IGwsXG4gICAgICAgICAgICAgIHR1bmVzOiBhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoIChoKSB7XG4gICAgICAgICAgICBJKGBCbG9jayDCqyR7cn3CuyBza2lwcGVkIGJlY2F1c2Ugb2YgcGx1Z2lucyBlcnJvcmAsIFwiZXJyb3JcIiwge1xuICAgICAgICAgICAgICBkYXRhOiBsLFxuICAgICAgICAgICAgICBlcnJvcjogaFxuICAgICAgICAgICAgfSksIGwgPSB0aGlzLmNvbXBvc2VTdHViRGF0YUZvclRvb2wociwgbCwgYyksIHIgPSBvLnN0dWJUb29sLCB1ID0gaS5jb21wb3NlQmxvY2soe1xuICAgICAgICAgICAgICBpZDogYyxcbiAgICAgICAgICAgICAgdG9vbDogcixcbiAgICAgICAgICAgICAgZGF0YTogbCxcbiAgICAgICAgICAgICAgdHVuZXM6IGFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdTtcbiAgICAgICAgfSk7XG4gICAgICAgIGkuaW5zZXJ0TWFueShzKTtcbiAgICAgIH1cbiAgICAgIHdpbmRvdy5yZXF1ZXN0SWRsZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgdCgpO1xuICAgICAgfSwgeyB0aW1lb3V0OiAyZTMgfSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBkYXRhIGZvciB0aGUgU3R1YiBUb29sIHRoYXQgd2lsbCBiZSB1c2VkIGluc3RlYWQgb2YgdW5hdmFpbGFibGUgdG9vbFxuICAgKlxuICAgKiBAcGFyYW0gdG9vbCAtIHVuYXZhaWxhYmxlIHRvb2wgbmFtZSB0byBzdHViXG4gICAqIEBwYXJhbSBkYXRhIC0gZGF0YSBvZiB1bmF2YWlsYWJsZSBibG9ja1xuICAgKiBAcGFyYW0gW2lkXSAtIGlkIG9mIHVuYXZhaWxhYmxlIGJsb2NrXG4gICAqL1xuICBjb21wb3NlU3R1YkRhdGFGb3JUb29sKGUsIHQsIG8pIHtcbiAgICBjb25zdCB7IFRvb2xzOiBpIH0gPSB0aGlzLkVkaXRvcjtcbiAgICBsZXQgcyA9IGU7XG4gICAgaWYgKGkudW5hdmFpbGFibGUuaGFzKGUpKSB7XG4gICAgICBjb25zdCByID0gaS51bmF2YWlsYWJsZS5nZXQoZSkudG9vbGJveDtcbiAgICAgIHIgIT09IHZvaWQgMCAmJiByWzBdLnRpdGxlICE9PSB2b2lkIDAgJiYgKHMgPSByWzBdLnRpdGxlKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHNhdmVkRGF0YToge1xuICAgICAgICBpZDogbyxcbiAgICAgICAgdHlwZTogZSxcbiAgICAgICAgZGF0YTogdFxuICAgICAgfSxcbiAgICAgIHRpdGxlOiBzXG4gICAgfTtcbiAgfVxufVxuY2xhc3MgYXMgZXh0ZW5kcyB5IHtcbiAgLyoqXG4gICAqIENvbXBvc2VzIG5ldyBjaGFpbiBvZiBQcm9taXNlcyB0byBmaXJlIHRoZW0gYWx0ZXJuYXRlbGx5XG4gICAqXG4gICAqIEByZXR1cm5zIHtPdXRwdXREYXRhfVxuICAgKi9cbiAgYXN5bmMgc2F2ZSgpIHtcbiAgICBjb25zdCB7IEJsb2NrTWFuYWdlcjogZSwgVG9vbHM6IHQgfSA9IHRoaXMuRWRpdG9yLCBvID0gZS5ibG9ja3MsIGkgPSBbXTtcbiAgICB0cnkge1xuICAgICAgby5mb3JFYWNoKChsKSA9PiB7XG4gICAgICAgIGkucHVzaCh0aGlzLmdldFNhdmVkRGF0YShsKSk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHMgPSBhd2FpdCBQcm9taXNlLmFsbChpKSwgciA9IGF3YWl0IG50KHMsIChsKSA9PiB0LmJsb2NrVG9vbHMuZ2V0KGwpLnNhbml0aXplQ29uZmlnKTtcbiAgICAgIHJldHVybiB0aGlzLm1ha2VPdXRwdXQocik7XG4gICAgfSBjYXRjaCAocykge1xuICAgICAgSyhcIlNhdmluZyBmYWlsZWQgZHVlIHRvIHRoZSBFcnJvciAlb1wiLCBcImVycm9yXCIsIHMpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2F2ZXMgYW5kIHZhbGlkYXRlc1xuICAgKlxuICAgKiBAcGFyYW0ge0Jsb2NrfSBibG9jayAtIEVkaXRvcidzIFRvb2xcbiAgICogQHJldHVybnMge1ZhbGlkYXRlZERhdGF9IC0gVG9vbCdzIHZhbGlkYXRlZCBkYXRhXG4gICAqL1xuICBhc3luYyBnZXRTYXZlZERhdGEoZSkge1xuICAgIGNvbnN0IHQgPSBhd2FpdCBlLnNhdmUoKSwgbyA9IHQgJiYgYXdhaXQgZS52YWxpZGF0ZSh0LmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi50LFxuICAgICAgaXNWYWxpZDogb1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgb3V0cHV0IG9iamVjdCB3aXRoIHNhdmVkIGRhdGEsIHRpbWUgYW5kIHZlcnNpb24gb2YgZWRpdG9yXG4gICAqXG4gICAqIEBwYXJhbSB7VmFsaWRhdGVkRGF0YX0gYWxsRXh0cmFjdGVkRGF0YSAtIGRhdGEgZXh0cmFjdGVkIGZyb20gQmxvY2tzXG4gICAqIEByZXR1cm5zIHtPdXRwdXREYXRhfVxuICAgKi9cbiAgbWFrZU91dHB1dChlKSB7XG4gICAgY29uc3QgdCA9IFtdO1xuICAgIHJldHVybiBlLmZvckVhY2goKHsgaWQ6IG8sIHRvb2w6IGksIGRhdGE6IHMsIHR1bmVzOiByLCBpc1ZhbGlkOiBsIH0pID0+IHtcbiAgICAgIGlmICghbCkge1xuICAgICAgICBJKGBCbG9jayDCqyR7aX3CuyBza2lwcGVkIGJlY2F1c2Ugc2F2ZWQgZGF0YSBpcyBpbnZhbGlkYCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpID09PSB0aGlzLkVkaXRvci5Ub29scy5zdHViVG9vbCkge1xuICAgICAgICB0LnB1c2gocyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGEgPSB7XG4gICAgICAgIGlkOiBvLFxuICAgICAgICB0eXBlOiBpLFxuICAgICAgICBkYXRhOiBzLFxuICAgICAgICAuLi4hWChyKSAmJiB7XG4gICAgICAgICAgdHVuZXM6IHJcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHQucHVzaChhKTtcbiAgICB9KSwge1xuICAgICAgdGltZTogKy8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLFxuICAgICAgYmxvY2tzOiB0LFxuICAgICAgdmVyc2lvbjogXCIyLjMwLjBcIlxuICAgIH07XG4gIH1cbn1cbihmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50IDwgXCJ1XCIpIHtcbiAgICAgIHZhciBuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgICAgbi5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIi5jZS1wYXJhZ3JhcGh7bGluZS1oZWlnaHQ6MS42ZW07b3V0bGluZTpub25lfS5jZS1ibG9jazpvbmx5LW9mLXR5cGUgLmNlLXBhcmFncmFwaFtkYXRhLXBsYWNlaG9sZGVyLWFjdGl2ZV06ZW1wdHk6YmVmb3JlLC5jZS1ibG9jazpvbmx5LW9mLXR5cGUgLmNlLXBhcmFncmFwaFtkYXRhLXBsYWNlaG9sZGVyLWFjdGl2ZV1bZGF0YS1lbXB0eT10cnVlXTpiZWZvcmV7Y29udGVudDphdHRyKGRhdGEtcGxhY2Vob2xkZXItYWN0aXZlKX0uY2UtcGFyYWdyYXBoIHA6Zmlyc3Qtb2YtdHlwZXttYXJnaW4tdG9wOjB9LmNlLXBhcmFncmFwaCBwOmxhc3Qtb2YtdHlwZXttYXJnaW4tYm90dG9tOjB9XCIpKSwgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChuKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLmVycm9yKFwidml0ZS1wbHVnaW4tY3NzLWluamVjdGVkLWJ5LWpzXCIsIGUpO1xuICB9XG59KSgpO1xuY29uc3QgY3MgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTggOVY3LjJDOCA3LjA4OTU0IDguMDg5NTQgNyA4LjIgN0wxMiA3TTE2IDlWNy4yQzE2IDcuMDg5NTQgMTUuOTEwNSA3IDE1LjggN0wxMiA3TTEyIDdMMTIgMTdNMTIgMTdIMTBNMTIgMTdIMTRcIi8+PC9zdmc+JztcbmZ1bmN0aW9uIGRzKG4pIHtcbiAgY29uc3QgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIGUuaW5uZXJIVE1MID0gbi50cmltKCk7XG4gIGNvbnN0IHQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gIHJldHVybiB0LmFwcGVuZCguLi5BcnJheS5mcm9tKGUuY2hpbGROb2RlcykpLCB0O1xufVxuLyoqXG4gKiBCYXNlIFBhcmFncmFwaCBCbG9jayBmb3IgdGhlIEVkaXRvci5qcy5cbiAqIFJlcHJlc2VudHMgYSByZWd1bGFyIHRleHQgYmxvY2tcbiAqXG4gKiBAYXV0aG9yIENvZGVYICh0ZWFtQGNvZGV4LnNvKVxuICogQGNvcHlyaWdodCBDb2RlWCAyMDE4XG4gKiBAbGljZW5zZSBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqL1xuY2xhc3MgZHQge1xuICAvKipcbiAgICogRGVmYXVsdCBwbGFjZWhvbGRlciBmb3IgUGFyYWdyYXBoIFRvb2xcbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICogQGNsYXNzXG4gICAqL1xuICBzdGF0aWMgZ2V0IERFRkFVTFRfUExBQ0VIT0xERVIoKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlciBwbHVnaW5gcyBtYWluIEVsZW1lbnQgYW5kIGZpbGwgaXQgd2l0aCBzYXZlZCBkYXRhXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBjb25zdHJ1Y3RvciBwYXJhbXNcbiAgICogQHBhcmFtIHtQYXJhZ3JhcGhEYXRhfSBwYXJhbXMuZGF0YSAtIHByZXZpb3VzbHkgc2F2ZWQgZGF0YVxuICAgKiBAcGFyYW0ge1BhcmFncmFwaENvbmZpZ30gcGFyYW1zLmNvbmZpZyAtIHVzZXIgY29uZmlnIGZvciBUb29sXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMuYXBpIC0gZWRpdG9yLmpzIGFwaVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlYWRPbmx5IC0gcmVhZCBvbmx5IG1vZGUgZmxhZ1xuICAgKi9cbiAgY29uc3RydWN0b3IoeyBkYXRhOiBlLCBjb25maWc6IHQsIGFwaTogbywgcmVhZE9ubHk6IGkgfSkge1xuICAgIHRoaXMuYXBpID0gbywgdGhpcy5yZWFkT25seSA9IGksIHRoaXMuX0NTUyA9IHtcbiAgICAgIGJsb2NrOiB0aGlzLmFwaS5zdHlsZXMuYmxvY2ssXG4gICAgICB3cmFwcGVyOiBcImNlLXBhcmFncmFwaFwiXG4gICAgfSwgdGhpcy5yZWFkT25seSB8fCAodGhpcy5vbktleVVwID0gdGhpcy5vbktleVVwLmJpbmQodGhpcykpLCB0aGlzLl9wbGFjZWhvbGRlciA9IHQucGxhY2Vob2xkZXIgPyB0LnBsYWNlaG9sZGVyIDogZHQuREVGQVVMVF9QTEFDRUhPTERFUiwgdGhpcy5fZGF0YSA9IGUgPz8ge30sIHRoaXMuX2VsZW1lbnQgPSBudWxsLCB0aGlzLl9wcmVzZXJ2ZUJsYW5rID0gdC5wcmVzZXJ2ZUJsYW5rID8/ICExO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiB0ZXh0IGNvbnRlbnQgaXMgZW1wdHkgYW5kIHNldCBlbXB0eSBzdHJpbmcgdG8gaW5uZXIgaHRtbC5cbiAgICogV2UgbmVlZCB0aGlzIGJlY2F1c2Ugc29tZSBicm93c2VycyAoZS5nLiBTYWZhcmkpIGluc2VydCA8YnI+IGludG8gZW1wdHkgY29udGVudGVkaXRhbmxlIGVsZW1lbnRzXG4gICAqXG4gICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZSAtIGtleSB1cCBldmVudFxuICAgKi9cbiAgb25LZXlVcChlKSB7XG4gICAgaWYgKGUuY29kZSAhPT0gXCJCYWNrc3BhY2VcIiAmJiBlLmNvZGUgIT09IFwiRGVsZXRlXCIgfHwgIXRoaXMuX2VsZW1lbnQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyB0ZXh0Q29udGVudDogdCB9ID0gdGhpcy5fZWxlbWVudDtcbiAgICB0ID09PSBcIlwiICYmICh0aGlzLl9lbGVtZW50LmlubmVySFRNTCA9IFwiXCIpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgVG9vbCdzIHZpZXdcbiAgICpcbiAgICogQHJldHVybnMge0hUTUxEaXZFbGVtZW50fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZHJhd1ZpZXcoKSB7XG4gICAgY29uc3QgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJESVZcIik7XG4gICAgcmV0dXJuIGUuY2xhc3NMaXN0LmFkZCh0aGlzLl9DU1Mud3JhcHBlciwgdGhpcy5fQ1NTLmJsb2NrKSwgZS5jb250ZW50RWRpdGFibGUgPSBcImZhbHNlXCIsIGUuZGF0YXNldC5wbGFjZWhvbGRlckFjdGl2ZSA9IHRoaXMuYXBpLmkxOG4udCh0aGlzLl9wbGFjZWhvbGRlciksIHRoaXMuX2RhdGEudGV4dCAmJiAoZS5pbm5lckhUTUwgPSB0aGlzLl9kYXRhLnRleHQpLCB0aGlzLnJlYWRPbmx5IHx8IChlLmNvbnRlbnRFZGl0YWJsZSA9IFwidHJ1ZVwiLCBlLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCB0aGlzLm9uS2V5VXApKSwgZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIFRvb2wncyB2aWV3XG4gICAqXG4gICAqIEByZXR1cm5zIHtIVE1MRGl2RWxlbWVudH1cbiAgICovXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fZWxlbWVudCA9IHRoaXMuZHJhd1ZpZXcoKSwgdGhpcy5fZWxlbWVudDtcbiAgfVxuICAvKipcbiAgICogTWV0aG9kIHRoYXQgc3BlY2lmaWVkIGhvdyB0byBtZXJnZSB0d28gVGV4dCBibG9ja3MuXG4gICAqIENhbGxlZCBieSBFZGl0b3IuanMgYnkgYmFja3NwYWNlIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIEJsb2NrXG4gICAqXG4gICAqIEBwYXJhbSB7UGFyYWdyYXBoRGF0YX0gZGF0YVxuICAgKiBAcHVibGljXG4gICAqL1xuICBtZXJnZShlKSB7XG4gICAgaWYgKCF0aGlzLl9lbGVtZW50KVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2RhdGEudGV4dCArPSBlLnRleHQ7XG4gICAgY29uc3QgdCA9IGRzKGUudGV4dCk7XG4gICAgdGhpcy5fZWxlbWVudC5hcHBlbmRDaGlsZCh0KSwgdGhpcy5fZWxlbWVudC5ub3JtYWxpemUoKTtcbiAgfVxuICAvKipcbiAgICogVmFsaWRhdGUgUGFyYWdyYXBoIGJsb2NrIGRhdGE6XG4gICAqIC0gY2hlY2sgZm9yIGVtcHRpbmVzc1xuICAgKlxuICAgKiBAcGFyYW0ge1BhcmFncmFwaERhdGF9IHNhdmVkRGF0YSDigJQgZGF0YSByZWNlaXZlZCBhZnRlciBzYXZpbmdcbiAgICogQHJldHVybnMge2Jvb2xlYW59IGZhbHNlIGlmIHNhdmVkIGRhdGEgaXMgbm90IGNvcnJlY3QsIG90aGVyd2lzZSB0cnVlXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHZhbGlkYXRlKGUpIHtcbiAgICByZXR1cm4gIShlLnRleHQudHJpbSgpID09PSBcIlwiICYmICF0aGlzLl9wcmVzZXJ2ZUJsYW5rKTtcbiAgfVxuICAvKipcbiAgICogRXh0cmFjdCBUb29sJ3MgZGF0YSBmcm9tIHRoZSB2aWV3XG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTERpdkVsZW1lbnR9IHRvb2xzQ29udGVudCAtIFBhcmFncmFwaCB0b29scyByZW5kZXJlZCB2aWV3XG4gICAqIEByZXR1cm5zIHtQYXJhZ3JhcGhEYXRhfSAtIHNhdmVkIGRhdGFcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgc2F2ZShlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHQ6IGUuaW5uZXJIVE1MXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogT24gcGFzdGUgY2FsbGJhY2sgZmlyZWQgZnJvbSBFZGl0b3IuXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTFBhc3RlRXZlbnR9IGV2ZW50IC0gZXZlbnQgd2l0aCBwYXN0ZWQgZGF0YVxuICAgKi9cbiAgb25QYXN0ZShlKSB7XG4gICAgY29uc3QgdCA9IHtcbiAgICAgIHRleHQ6IGUuZGV0YWlsLmRhdGEuaW5uZXJIVE1MXG4gICAgfTtcbiAgICB0aGlzLl9kYXRhID0gdCwgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLl9lbGVtZW50ICYmICh0aGlzLl9lbGVtZW50LmlubmVySFRNTCA9IHRoaXMuX2RhdGEudGV4dCB8fCBcIlwiKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRW5hYmxlIENvbnZlcnNpb24gVG9vbGJhci4gUGFyYWdyYXBoIGNhbiBiZSBjb252ZXJ0ZWQgdG8vZnJvbSBvdGhlciB0b29sc1xuICAgKiBAcmV0dXJucyB7Q29udmVyc2lvbkNvbmZpZ31cbiAgICovXG4gIHN0YXRpYyBnZXQgY29udmVyc2lvbkNvbmZpZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXhwb3J0OiBcInRleHRcIixcbiAgICAgIC8vIHRvIGNvbnZlcnQgUGFyYWdyYXBoIHRvIG90aGVyIGJsb2NrLCB1c2UgJ3RleHQnIHByb3BlcnR5IG9mIHNhdmVkIGRhdGFcbiAgICAgIGltcG9ydDogXCJ0ZXh0XCJcbiAgICAgIC8vIHRvIGNvdmVydCBvdGhlciBibG9jaydzIGV4cG9ydGVkIHN0cmluZyB0byBQYXJhZ3JhcGgsIGZpbGwgJ3RleHQnIHByb3BlcnR5IG9mIHRvb2wgZGF0YVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFNhbml0aXplciBydWxlc1xuICAgKiBAcmV0dXJucyB7U2FuaXRpemVyQ29uZmlnfSAtIEVkdGlvci5qcyBzYW5pdGl6ZXIgY29uZmlnXG4gICAqL1xuICBzdGF0aWMgZ2V0IHNhbml0aXplKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0ZXh0OiB7XG4gICAgICAgIGJyOiAhMFxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSB0byBub3RpZnkgdGhlIGNvcmUgdGhhdCByZWFkLW9ubHkgbW9kZSBpcyBzdXBwb3J0ZWRcbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgZ2V0IGlzUmVhZE9ubHlTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuICEwO1xuICB9XG4gIC8qKlxuICAgKiBVc2VkIGJ5IEVkaXRvciBwYXN0ZSBoYW5kbGluZyBBUEkuXG4gICAqIFByb3ZpZGVzIGNvbmZpZ3VyYXRpb24gdG8gaGFuZGxlIFAgdGFncy5cbiAgICpcbiAgICogQHJldHVybnMge1Bhc3RlQ29uZmlnfSAtIFBhcmFncmFwaCBQYXN0ZSBTZXR0aW5nXG4gICAqL1xuICBzdGF0aWMgZ2V0IHBhc3RlQ29uZmlnKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0YWdzOiBbXCJQXCJdXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogSWNvbiBhbmQgdGl0bGUgZm9yIGRpc3BsYXlpbmcgYXQgdGhlIFRvb2xib3hcbiAgICpcbiAgICogQHJldHVybnMge1Rvb2xib3hDb25maWd9IC0gUGFyYWdyYXBoIFRvb2xib3ggU2V0dGluZ1xuICAgKi9cbiAgc3RhdGljIGdldCB0b29sYm94KCkge1xuICAgIHJldHVybiB7XG4gICAgICBpY29uOiBjcyxcbiAgICAgIHRpdGxlOiBcIlRleHRcIlxuICAgIH07XG4gIH1cbn1cbmNsYXNzIGh0IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jb21tYW5kTmFtZSA9IFwiYm9sZFwiO1xuICB9XG4gIC8qKlxuICAgKiBTYW5pdGl6ZXIgUnVsZVxuICAgKiBMZWF2ZSA8Yj4gdGFnc1xuICAgKlxuICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBzYW5pdGl6ZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYjoge31cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYnV0dG9uIGZvciBJbmxpbmUgVG9vbGJhclxuICAgKi9cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpY29uOiB6byxcbiAgICAgIG5hbWU6IFwiYm9sZFwiLFxuICAgICAgb25BY3RpdmF0ZTogKCkgPT4ge1xuICAgICAgICBkb2N1bWVudC5leGVjQ29tbWFuZCh0aGlzLmNvbW1hbmROYW1lKTtcbiAgICAgIH0sXG4gICAgICBpc0FjdGl2ZTogKCkgPT4gZG9jdW1lbnQucXVlcnlDb21tYW5kU3RhdGUodGhpcy5jb21tYW5kTmFtZSlcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBTZXQgYSBzaG9ydGN1dFxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBzaG9ydGN1dCgpIHtcbiAgICByZXR1cm4gXCJDTUQrQlwiO1xuICB9XG59XG5odC5pc0lubGluZSA9ICEwO1xuaHQudGl0bGUgPSBcIkJvbGRcIjtcbmNsYXNzIHV0IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jb21tYW5kTmFtZSA9IFwiaXRhbGljXCIsIHRoaXMuQ1NTID0ge1xuICAgICAgYnV0dG9uOiBcImNlLWlubGluZS10b29sXCIsXG4gICAgICBidXR0b25BY3RpdmU6IFwiY2UtaW5saW5lLXRvb2wtLWFjdGl2ZVwiLFxuICAgICAgYnV0dG9uTW9kaWZpZXI6IFwiY2UtaW5saW5lLXRvb2wtLWl0YWxpY1wiXG4gICAgfSwgdGhpcy5ub2RlcyA9IHtcbiAgICAgIGJ1dHRvbjogbnVsbFxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFNhbml0aXplciBSdWxlXG4gICAqIExlYXZlIDxpPiB0YWdzXG4gICAqXG4gICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IHNhbml0aXplKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpOiB7fVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBidXR0b24gZm9yIElubGluZSBUb29sYmFyXG4gICAqL1xuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMuYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKSwgdGhpcy5ub2Rlcy5idXR0b24udHlwZSA9IFwiYnV0dG9uXCIsIHRoaXMubm9kZXMuYnV0dG9uLmNsYXNzTGlzdC5hZGQodGhpcy5DU1MuYnV0dG9uLCB0aGlzLkNTUy5idXR0b25Nb2RpZmllciksIHRoaXMubm9kZXMuYnV0dG9uLmlubmVySFRNTCA9IFhvLCB0aGlzLm5vZGVzLmJ1dHRvbjtcbiAgfVxuICAvKipcbiAgICogV3JhcCByYW5nZSB3aXRoIDxpPiB0YWdcbiAgICovXG4gIHN1cnJvdW5kKCkge1xuICAgIGRvY3VtZW50LmV4ZWNDb21tYW5kKHRoaXMuY29tbWFuZE5hbWUpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBzZWxlY3Rpb24gYW5kIHNldCBhY3RpdmF0ZWQgc3RhdGUgdG8gYnV0dG9uIGlmIHRoZXJlIGFyZSA8aT4gdGFnXG4gICAqL1xuICBjaGVja1N0YXRlKCkge1xuICAgIGNvbnN0IGUgPSBkb2N1bWVudC5xdWVyeUNvbW1hbmRTdGF0ZSh0aGlzLmNvbW1hbmROYW1lKTtcbiAgICByZXR1cm4gdGhpcy5ub2Rlcy5idXR0b24uY2xhc3NMaXN0LnRvZ2dsZSh0aGlzLkNTUy5idXR0b25BY3RpdmUsIGUpLCBlO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgYSBzaG9ydGN1dFxuICAgKi9cbiAgZ2V0IHNob3J0Y3V0KCkge1xuICAgIHJldHVybiBcIkNNRCtJXCI7XG4gIH1cbn1cbnV0LmlzSW5saW5lID0gITA7XG51dC50aXRsZSA9IFwiSXRhbGljXCI7XG5jbGFzcyBwdCB7XG4gIC8qKlxuICAgKiBAcGFyYW0gYXBpIC0gRWRpdG9yLmpzIEFQSVxuICAgKi9cbiAgY29uc3RydWN0b3IoeyBhcGk6IGUgfSkge1xuICAgIHRoaXMuY29tbWFuZExpbmsgPSBcImNyZWF0ZUxpbmtcIiwgdGhpcy5jb21tYW5kVW5saW5rID0gXCJ1bmxpbmtcIiwgdGhpcy5FTlRFUl9LRVkgPSAxMywgdGhpcy5DU1MgPSB7XG4gICAgICBidXR0b246IFwiY2UtaW5saW5lLXRvb2xcIixcbiAgICAgIGJ1dHRvbkFjdGl2ZTogXCJjZS1pbmxpbmUtdG9vbC0tYWN0aXZlXCIsXG4gICAgICBidXR0b25Nb2RpZmllcjogXCJjZS1pbmxpbmUtdG9vbC0tbGlua1wiLFxuICAgICAgYnV0dG9uVW5saW5rOiBcImNlLWlubGluZS10b29sLS11bmxpbmtcIixcbiAgICAgIGlucHV0OiBcImNlLWlubGluZS10b29sLWlucHV0XCIsXG4gICAgICBpbnB1dFNob3dlZDogXCJjZS1pbmxpbmUtdG9vbC1pbnB1dC0tc2hvd2VkXCJcbiAgICB9LCB0aGlzLm5vZGVzID0ge1xuICAgICAgYnV0dG9uOiBudWxsLFxuICAgICAgaW5wdXQ6IG51bGxcbiAgICB9LCB0aGlzLmlucHV0T3BlbmVkID0gITEsIHRoaXMudG9vbGJhciA9IGUudG9vbGJhciwgdGhpcy5pbmxpbmVUb29sYmFyID0gZS5pbmxpbmVUb29sYmFyLCB0aGlzLm5vdGlmaWVyID0gZS5ub3RpZmllciwgdGhpcy5pMThuID0gZS5pMThuLCB0aGlzLnNlbGVjdGlvbiA9IG5ldyBiKCk7XG4gIH1cbiAgLyoqXG4gICAqIFNhbml0aXplciBSdWxlXG4gICAqIExlYXZlIDxhPiB0YWdzXG4gICAqXG4gICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IHNhbml0aXplKCkge1xuICAgIHJldHVybiB7XG4gICAgICBhOiB7XG4gICAgICAgIGhyZWY6ICEwLFxuICAgICAgICB0YXJnZXQ6IFwiX2JsYW5rXCIsXG4gICAgICAgIHJlbDogXCJub2ZvbGxvd1wiXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGJ1dHRvbiBmb3IgSW5saW5lIFRvb2xiYXJcbiAgICovXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5ub2Rlcy5idXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpLCB0aGlzLm5vZGVzLmJ1dHRvbi50eXBlID0gXCJidXR0b25cIiwgdGhpcy5ub2Rlcy5idXR0b24uY2xhc3NMaXN0LmFkZCh0aGlzLkNTUy5idXR0b24sIHRoaXMuQ1NTLmJ1dHRvbk1vZGlmaWVyKSwgdGhpcy5ub2Rlcy5idXR0b24uaW5uZXJIVE1MID0geHQsIHRoaXMubm9kZXMuYnV0dG9uO1xuICB9XG4gIC8qKlxuICAgKiBJbnB1dCBmb3IgdGhlIGxpbmtcbiAgICovXG4gIHJlbmRlckFjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMuaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiksIHRoaXMubm9kZXMuaW5wdXQucGxhY2Vob2xkZXIgPSB0aGlzLmkxOG4udChcIkFkZCBhIGxpbmtcIiksIHRoaXMubm9kZXMuaW5wdXQuZW50ZXJLZXlIaW50ID0gXCJkb25lXCIsIHRoaXMubm9kZXMuaW5wdXQuY2xhc3NMaXN0LmFkZCh0aGlzLkNTUy5pbnB1dCksIHRoaXMubm9kZXMuaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgKGUpID0+IHtcbiAgICAgIGUua2V5Q29kZSA9PT0gdGhpcy5FTlRFUl9LRVkgJiYgdGhpcy5lbnRlclByZXNzZWQoZSk7XG4gICAgfSksIHRoaXMubm9kZXMuaW5wdXQ7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZSBjbGlja3Mgb24gdGhlIElubGluZSBUb29sYmFyIGljb25cbiAgICpcbiAgICogQHBhcmFtIHtSYW5nZX0gcmFuZ2UgLSByYW5nZSB0byB3cmFwIHdpdGggbGlua1xuICAgKi9cbiAgc3Vycm91bmQoZSkge1xuICAgIGlmIChlKSB7XG4gICAgICB0aGlzLmlucHV0T3BlbmVkID8gKHRoaXMuc2VsZWN0aW9uLnJlc3RvcmUoKSwgdGhpcy5zZWxlY3Rpb24ucmVtb3ZlRmFrZUJhY2tncm91bmQoKSkgOiAodGhpcy5zZWxlY3Rpb24uc2V0RmFrZUJhY2tncm91bmQoKSwgdGhpcy5zZWxlY3Rpb24uc2F2ZSgpKTtcbiAgICAgIGNvbnN0IHQgPSB0aGlzLnNlbGVjdGlvbi5maW5kUGFyZW50VGFnKFwiQVwiKTtcbiAgICAgIGlmICh0KSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLmV4cGFuZFRvVGFnKHQpLCB0aGlzLnVubGluaygpLCB0aGlzLmNsb3NlQWN0aW9ucygpLCB0aGlzLmNoZWNrU3RhdGUoKSwgdGhpcy50b29sYmFyLmNsb3NlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy50b2dnbGVBY3Rpb25zKCk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIHNlbGVjdGlvbiBhbmQgc2V0IGFjdGl2YXRlZCBzdGF0ZSB0byBidXR0b24gaWYgdGhlcmUgYXJlIDxhPiB0YWdcbiAgICovXG4gIGNoZWNrU3RhdGUoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuc2VsZWN0aW9uLmZpbmRQYXJlbnRUYWcoXCJBXCIpO1xuICAgIGlmIChlKSB7XG4gICAgICB0aGlzLm5vZGVzLmJ1dHRvbi5pbm5lckhUTUwgPSBHbywgdGhpcy5ub2Rlcy5idXR0b24uY2xhc3NMaXN0LmFkZCh0aGlzLkNTUy5idXR0b25VbmxpbmspLCB0aGlzLm5vZGVzLmJ1dHRvbi5jbGFzc0xpc3QuYWRkKHRoaXMuQ1NTLmJ1dHRvbkFjdGl2ZSksIHRoaXMub3BlbkFjdGlvbnMoKTtcbiAgICAgIGNvbnN0IHQgPSBlLmdldEF0dHJpYnV0ZShcImhyZWZcIik7XG4gICAgICB0aGlzLm5vZGVzLmlucHV0LnZhbHVlID0gdCAhPT0gXCJudWxsXCIgPyB0IDogXCJcIiwgdGhpcy5zZWxlY3Rpb24uc2F2ZSgpO1xuICAgIH0gZWxzZVxuICAgICAgdGhpcy5ub2Rlcy5idXR0b24uaW5uZXJIVE1MID0geHQsIHRoaXMubm9kZXMuYnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5DU1MuYnV0dG9uVW5saW5rKSwgdGhpcy5ub2Rlcy5idXR0b24uY2xhc3NMaXN0LnJlbW92ZSh0aGlzLkNTUy5idXR0b25BY3RpdmUpO1xuICAgIHJldHVybiAhIWU7XG4gIH1cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIGNhbGxlZCB3aXRoIElubGluZSBUb29sYmFyIGNsb3NpbmdcbiAgICovXG4gIGNsZWFyKCkge1xuICAgIHRoaXMuY2xvc2VBY3Rpb25zKCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldCBhIHNob3J0Y3V0XG4gICAqL1xuICBnZXQgc2hvcnRjdXQoKSB7XG4gICAgcmV0dXJuIFwiQ01EK0tcIjtcbiAgfVxuICAvKipcbiAgICogU2hvdy9jbG9zZSBsaW5rIGlucHV0XG4gICAqL1xuICB0b2dnbGVBY3Rpb25zKCkge1xuICAgIHRoaXMuaW5wdXRPcGVuZWQgPyB0aGlzLmNsb3NlQWN0aW9ucyghMSkgOiB0aGlzLm9wZW5BY3Rpb25zKCEwKTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtib29sZWFufSBuZWVkRm9jdXMgLSBvbiBsaW5rIGNyZWF0aW9uIHdlIG5lZWQgdG8gZm9jdXMgaW5wdXQuIE9uIGVkaXRpbmcgLSBub3BlLlxuICAgKi9cbiAgb3BlbkFjdGlvbnMoZSA9ICExKSB7XG4gICAgdGhpcy5ub2Rlcy5pbnB1dC5jbGFzc0xpc3QuYWRkKHRoaXMuQ1NTLmlucHV0U2hvd2VkKSwgZSAmJiB0aGlzLm5vZGVzLmlucHV0LmZvY3VzKCksIHRoaXMuaW5wdXRPcGVuZWQgPSAhMDtcbiAgfVxuICAvKipcbiAgICogQ2xvc2UgaW5wdXRcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBjbGVhclNhdmVkU2VsZWN0aW9uIOKAlCB3ZSBkb24ndCBuZWVkIHRvIGNsZWFyIHNhdmVkIHNlbGVjdGlvblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbiB0b2dnbGUtY2xpY2tzIG9uIHRoZSBpY29uIG9mIG9wZW5lZCBUb29sYmFyXG4gICAqL1xuICBjbG9zZUFjdGlvbnMoZSA9ICEwKSB7XG4gICAgaWYgKHRoaXMuc2VsZWN0aW9uLmlzRmFrZUJhY2tncm91bmRFbmFibGVkKSB7XG4gICAgICBjb25zdCB0ID0gbmV3IGIoKTtcbiAgICAgIHQuc2F2ZSgpLCB0aGlzLnNlbGVjdGlvbi5yZXN0b3JlKCksIHRoaXMuc2VsZWN0aW9uLnJlbW92ZUZha2VCYWNrZ3JvdW5kKCksIHQucmVzdG9yZSgpO1xuICAgIH1cbiAgICB0aGlzLm5vZGVzLmlucHV0LmNsYXNzTGlzdC5yZW1vdmUodGhpcy5DU1MuaW5wdXRTaG93ZWQpLCB0aGlzLm5vZGVzLmlucHV0LnZhbHVlID0gXCJcIiwgZSAmJiB0aGlzLnNlbGVjdGlvbi5jbGVhclNhdmVkKCksIHRoaXMuaW5wdXRPcGVuZWQgPSAhMTtcbiAgfVxuICAvKipcbiAgICogRW50ZXIgcHJlc3NlZCBvbiBpbnB1dFxuICAgKlxuICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2ZW50IC0gZW50ZXIga2V5ZG93biBldmVudFxuICAgKi9cbiAgZW50ZXJQcmVzc2VkKGUpIHtcbiAgICBsZXQgdCA9IHRoaXMubm9kZXMuaW5wdXQudmFsdWUgfHwgXCJcIjtcbiAgICBpZiAoIXQudHJpbSgpKSB7XG4gICAgICB0aGlzLnNlbGVjdGlvbi5yZXN0b3JlKCksIHRoaXMudW5saW5rKCksIGUucHJldmVudERlZmF1bHQoKSwgdGhpcy5jbG9zZUFjdGlvbnMoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnZhbGlkYXRlVVJMKHQpKSB7XG4gICAgICB0aGlzLm5vdGlmaWVyLnNob3coe1xuICAgICAgICBtZXNzYWdlOiBcIlBhc3RlZCBsaW5rIGlzIG5vdCB2YWxpZC5cIixcbiAgICAgICAgc3R5bGU6IFwiZXJyb3JcIlxuICAgICAgfSksIEkoXCJJbmNvcnJlY3QgTGluayBwYXN0ZWRcIiwgXCJ3YXJuXCIsIHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0ID0gdGhpcy5wcmVwYXJlTGluayh0KSwgdGhpcy5zZWxlY3Rpb24ucmVzdG9yZSgpLCB0aGlzLnNlbGVjdGlvbi5yZW1vdmVGYWtlQmFja2dyb3VuZCgpLCB0aGlzLmluc2VydExpbmsodCksIGUucHJldmVudERlZmF1bHQoKSwgZS5zdG9wUHJvcGFnYXRpb24oKSwgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSwgdGhpcy5zZWxlY3Rpb24uY29sbGFwc2VUb0VuZCgpLCB0aGlzLmlubGluZVRvb2xiYXIuY2xvc2UoKTtcbiAgfVxuICAvKipcbiAgICogRGV0ZWN0cyBpZiBwYXNzZWQgc3RyaW5nIGlzIFVSTFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIC0gc3RyaW5nIHRvIHZhbGlkYXRlXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgdmFsaWRhdGVVUkwoZSkge1xuICAgIHJldHVybiAhL1xccy8udGVzdChlKTtcbiAgfVxuICAvKipcbiAgICogUHJvY2VzcyBsaW5rIGJlZm9yZSBpbmplY3Rpb25cbiAgICogLSBzYW5pdGl6ZVxuICAgKiAtIGFkZCBwcm90b2NvbCBmb3IgbGlua3MgbGlrZSAnZ29vZ2xlLmNvbSdcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxpbmsgLSByYXcgdXNlciBpbnB1dFxuICAgKi9cbiAgcHJlcGFyZUxpbmsoZSkge1xuICAgIHJldHVybiBlID0gZS50cmltKCksIGUgPSB0aGlzLmFkZFByb3RvY29sKGUpLCBlO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgJ2h0dHAnIHByb3RvY29sIHRvIHRoZSBsaW5rcyBsaWtlICd2Yy5ydScsICdnb29nbGUuY29tJ1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGluayAtIHN0cmluZyB0byBwcm9jZXNzXG4gICAqL1xuICBhZGRQcm90b2NvbChlKSB7XG4gICAgaWYgKC9eKFxcdyspOihcXC9cXC8pPy8udGVzdChlKSlcbiAgICAgIHJldHVybiBlO1xuICAgIGNvbnN0IHQgPSAvXlxcL1teL1xcc10vLnRlc3QoZSksIG8gPSBlLnN1YnN0cmluZygwLCAxKSA9PT0gXCIjXCIsIGkgPSAvXlxcL1xcL1teL1xcc10vLnRlc3QoZSk7XG4gICAgcmV0dXJuICF0ICYmICFvICYmICFpICYmIChlID0gXCJodHRwOi8vXCIgKyBlKSwgZTtcbiAgfVxuICAvKipcbiAgICogSW5zZXJ0cyA8YT4gdGFnIHdpdGggXCJocmVmXCJcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxpbmsgLSBcImhyZWZcIiB2YWx1ZVxuICAgKi9cbiAgaW5zZXJ0TGluayhlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuc2VsZWN0aW9uLmZpbmRQYXJlbnRUYWcoXCJBXCIpO1xuICAgIHQgJiYgdGhpcy5zZWxlY3Rpb24uZXhwYW5kVG9UYWcodCksIGRvY3VtZW50LmV4ZWNDb21tYW5kKHRoaXMuY29tbWFuZExpbmssICExLCBlKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyA8YT4gdGFnXG4gICAqL1xuICB1bmxpbmsoKSB7XG4gICAgZG9jdW1lbnQuZXhlY0NvbW1hbmQodGhpcy5jb21tYW5kVW5saW5rKTtcbiAgfVxufVxucHQuaXNJbmxpbmUgPSAhMDtcbnB0LnRpdGxlID0gXCJMaW5rXCI7XG5jbGFzcyBhbyB7XG4gIC8qKlxuICAgKiBAcGFyYW0gYXBpIC0gRWRpdG9yLmpzIEFQSVxuICAgKi9cbiAgY29uc3RydWN0b3IoeyBhcGk6IGUgfSkge1xuICAgIHRoaXMuaTE4bkFQSSA9IGUuaTE4biwgdGhpcy5ibG9ja3NBUEkgPSBlLmJsb2NrcywgdGhpcy5zZWxlY3Rpb25BUEkgPSBlLnNlbGVjdGlvbiwgdGhpcy50b29sc0FQSSA9IGUudG9vbHMsIHRoaXMuY2FyZXRBUEkgPSBlLmNhcmV0O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRvb2wncyBVSSBjb25maWdcbiAgICovXG4gIGFzeW5jIHJlbmRlcigpIHtcbiAgICBjb25zdCBlID0gYi5nZXQoKSwgdCA9IHRoaXMuYmxvY2tzQVBJLmdldEJsb2NrQnlFbGVtZW50KGUuYW5jaG9yTm9kZSk7XG4gICAgaWYgKHQgPT09IHZvaWQgMClcbiAgICAgIHJldHVybiBbXTtcbiAgICBjb25zdCBvID0gdGhpcy50b29sc0FQSS5nZXRCbG9ja1Rvb2xzKCksIGkgPSBhd2FpdCB6dCh0LCBvKTtcbiAgICBpZiAoaS5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gW107XG4gICAgY29uc3QgcyA9IGkucmVkdWNlKChjLCB1KSA9PiB7XG4gICAgICB2YXIgaDtcbiAgICAgIHJldHVybiAoaCA9IHUudG9vbGJveCkgPT0gbnVsbCB8fCBoLmZvckVhY2goKHApID0+IHtcbiAgICAgICAgYy5wdXNoKHtcbiAgICAgICAgICBpY29uOiBwLmljb24sXG4gICAgICAgICAgdGl0bGU6IHAudGl0bGUsXG4gICAgICAgICAgbmFtZTogdS5uYW1lLFxuICAgICAgICAgIGNsb3NlT25BY3RpdmF0ZTogITAsXG4gICAgICAgICAgb25BY3RpdmF0ZTogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZyA9IGF3YWl0IHRoaXMuYmxvY2tzQVBJLmNvbnZlcnQodC5pZCwgdS5uYW1lLCBwLmRhdGEpO1xuICAgICAgICAgICAgdGhpcy5jYXJldEFQSS5zZXRUb0Jsb2NrKGcsIFwiZW5kXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KSwgYztcbiAgICB9LCBbXSksIHIgPSBhd2FpdCB0LmdldEFjdGl2ZVRvb2xib3hFbnRyeSgpLCBsID0gciAhPT0gdm9pZCAwID8gci5pY29uIDoganQsIGEgPSAhdWUoKTtcbiAgICByZXR1cm4ge1xuICAgICAgaWNvbjogbCxcbiAgICAgIG5hbWU6IFwiY29udmVydC10b1wiLFxuICAgICAgaGludDoge1xuICAgICAgICB0aXRsZTogdGhpcy5pMThuQVBJLnQoXCJDb252ZXJ0IHRvXCIpXG4gICAgICB9LFxuICAgICAgY2hpbGRyZW46IHtcbiAgICAgICAgc2VhcmNoYWJsZTogYSxcbiAgICAgICAgaXRlbXM6IHMsXG4gICAgICAgIG9uT3BlbjogKCkgPT4ge1xuICAgICAgICAgIGEgJiYgKHRoaXMuc2VsZWN0aW9uQVBJLnNldEZha2VCYWNrZ3JvdW5kKCksIHRoaXMuc2VsZWN0aW9uQVBJLnNhdmUoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQ2xvc2U6ICgpID0+IHtcbiAgICAgICAgICBhICYmICh0aGlzLnNlbGVjdGlvbkFQSS5yZXN0b3JlKCksIHRoaXMuc2VsZWN0aW9uQVBJLnJlbW92ZUZha2VCYWNrZ3JvdW5kKCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuYW8uaXNJbmxpbmUgPSAhMDtcbmNsYXNzIGNvIHtcbiAgLyoqXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gY29uc3RydWN0b3Igb3B0aW9uc1xuICAgKiBAcGFyYW0gb3B0aW9ucy5kYXRhIC0gc3R1YiB0b29sIGRhdGFcbiAgICogQHBhcmFtIG9wdGlvbnMuYXBpIC0gRWRpdG9yLmpzIEFQSVxuICAgKi9cbiAgY29uc3RydWN0b3IoeyBkYXRhOiBlLCBhcGk6IHQgfSkge1xuICAgIHRoaXMuQ1NTID0ge1xuICAgICAgd3JhcHBlcjogXCJjZS1zdHViXCIsXG4gICAgICBpbmZvOiBcImNlLXN0dWJfX2luZm9cIixcbiAgICAgIHRpdGxlOiBcImNlLXN0dWJfX3RpdGxlXCIsXG4gICAgICBzdWJ0aXRsZTogXCJjZS1zdHViX19zdWJ0aXRsZVwiXG4gICAgfSwgdGhpcy5hcGkgPSB0LCB0aGlzLnRpdGxlID0gZS50aXRsZSB8fCB0aGlzLmFwaS5pMThuLnQoXCJFcnJvclwiKSwgdGhpcy5zdWJ0aXRsZSA9IHRoaXMuYXBpLmkxOG4udChcIlRoZSBibG9jayBjYW4gbm90IGJlIGRpc3BsYXllZCBjb3JyZWN0bHkuXCIpLCB0aGlzLnNhdmVkRGF0YSA9IGUuc2F2ZWREYXRhLCB0aGlzLndyYXBwZXIgPSB0aGlzLm1ha2UoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBzdHViIGhvbGRlclxuICAgKlxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMud3JhcHBlcjtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIG9yaWdpbmFsIFRvb2wgZGF0YVxuICAgKlxuICAgKiBAcmV0dXJucyB7QmxvY2tUb29sRGF0YX1cbiAgICovXG4gIHNhdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2F2ZWREYXRhO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgVG9vbCBodG1sIG1hcmt1cFxuICAgKlxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICBtYWtlKCkge1xuICAgIGNvbnN0IGUgPSBkLm1ha2UoXCJkaXZcIiwgdGhpcy5DU1Mud3JhcHBlciksIHQgPSBKbywgbyA9IGQubWFrZShcImRpdlwiLCB0aGlzLkNTUy5pbmZvKSwgaSA9IGQubWFrZShcImRpdlwiLCB0aGlzLkNTUy50aXRsZSwge1xuICAgICAgdGV4dENvbnRlbnQ6IHRoaXMudGl0bGVcbiAgICB9KSwgcyA9IGQubWFrZShcImRpdlwiLCB0aGlzLkNTUy5zdWJ0aXRsZSwge1xuICAgICAgdGV4dENvbnRlbnQ6IHRoaXMuc3VidGl0bGVcbiAgICB9KTtcbiAgICByZXR1cm4gZS5pbm5lckhUTUwgPSB0LCBvLmFwcGVuZENoaWxkKGkpLCBvLmFwcGVuZENoaWxkKHMpLCBlLmFwcGVuZENoaWxkKG8pLCBlO1xuICB9XG59XG5jby5pc1JlYWRPbmx5U3VwcG9ydGVkID0gITA7XG5jbGFzcyBocyBleHRlbmRzIGN0IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy50eXBlID0gRmUuSW5saW5lO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRpdGxlIGZvciBJbmxpbmUgVG9vbCBpZiBzcGVjaWZpZWQgYnkgdXNlclxuICAgKi9cbiAgZ2V0IHRpdGxlKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdGFibGVbYXQuVGl0bGVdO1xuICB9XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIG5ldyBJbmxpbmVUb29sIGluc3RhbmNlIGZyb20gY29uc3RydWN0YWJsZVxuICAgKi9cbiAgY3JlYXRlKCkge1xuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RhYmxlKHtcbiAgICAgIGFwaTogdGhpcy5hcGksXG4gICAgICBjb25maWc6IHRoaXMuc2V0dGluZ3NcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgdXMgZXh0ZW5kcyBjdCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMudHlwZSA9IEZlLlR1bmU7XG4gIH1cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgbmV3IEJsb2NrVHVuZSBpbnN0YW5jZSBmcm9tIGNvbnN0cnVjdGFibGVcbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBUdW5lIGRhdGFcbiAgICogQHBhcmFtIGJsb2NrIC0gQmxvY2sgQVBJIG9iamVjdFxuICAgKi9cbiAgY3JlYXRlKGUsIHQpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0YWJsZSh7XG4gICAgICBhcGk6IHRoaXMuYXBpLFxuICAgICAgY29uZmlnOiB0aGlzLnNldHRpbmdzLFxuICAgICAgYmxvY2s6IHQsXG4gICAgICBkYXRhOiBlXG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIEYgZXh0ZW5kcyBNYXAge1xuICAvKipcbiAgICogUmV0dXJucyBCbG9jayBUb29scyBjb2xsZWN0aW9uXG4gICAqL1xuICBnZXQgYmxvY2tUb29scygpIHtcbiAgICBjb25zdCBlID0gQXJyYXkuZnJvbSh0aGlzLmVudHJpZXMoKSkuZmlsdGVyKChbLCB0XSkgPT4gdC5pc0Jsb2NrKCkpO1xuICAgIHJldHVybiBuZXcgRihlKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBJbmxpbmUgVG9vbHMgY29sbGVjdGlvblxuICAgKi9cbiAgZ2V0IGlubGluZVRvb2xzKCkge1xuICAgIGNvbnN0IGUgPSBBcnJheS5mcm9tKHRoaXMuZW50cmllcygpKS5maWx0ZXIoKFssIHRdKSA9PiB0LmlzSW5saW5lKCkpO1xuICAgIHJldHVybiBuZXcgRihlKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBCbG9jayBUdW5lcyBjb2xsZWN0aW9uXG4gICAqL1xuICBnZXQgYmxvY2tUdW5lcygpIHtcbiAgICBjb25zdCBlID0gQXJyYXkuZnJvbSh0aGlzLmVudHJpZXMoKSkuZmlsdGVyKChbLCB0XSkgPT4gdC5pc1R1bmUoKSk7XG4gICAgcmV0dXJuIG5ldyBGKGUpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGludGVybmFsIFRvb2xzIGNvbGxlY3Rpb25cbiAgICovXG4gIGdldCBpbnRlcm5hbFRvb2xzKCkge1xuICAgIGNvbnN0IGUgPSBBcnJheS5mcm9tKHRoaXMuZW50cmllcygpKS5maWx0ZXIoKFssIHRdKSA9PiB0LmlzSW50ZXJuYWwpO1xuICAgIHJldHVybiBuZXcgRihlKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBUb29scyBjb2xsZWN0aW9uIHByb3ZpZGVkIGJ5IHVzZXJcbiAgICovXG4gIGdldCBleHRlcm5hbFRvb2xzKCkge1xuICAgIGNvbnN0IGUgPSBBcnJheS5mcm9tKHRoaXMuZW50cmllcygpKS5maWx0ZXIoKFssIHRdKSA9PiAhdC5pc0ludGVybmFsKTtcbiAgICByZXR1cm4gbmV3IEYoZSk7XG4gIH1cbn1cbnZhciBwcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgZnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLCBobyA9IChuLCBlLCB0LCBvKSA9PiB7XG4gIGZvciAodmFyIGkgPSBvID4gMSA/IHZvaWQgMCA6IG8gPyBmcyhlLCB0KSA6IGUsIHMgPSBuLmxlbmd0aCAtIDEsIHI7IHMgPj0gMDsgcy0tKVxuICAgIChyID0gbltzXSkgJiYgKGkgPSAobyA/IHIoZSwgdCwgaSkgOiByKGkpKSB8fCBpKTtcbiAgcmV0dXJuIG8gJiYgaSAmJiBwcyhlLCB0LCBpKSwgaTtcbn07XG5jbGFzcyBmdCBleHRlbmRzIGN0IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy50eXBlID0gRmUuQmxvY2ssIHRoaXMuaW5saW5lVG9vbHMgPSBuZXcgRigpLCB0aGlzLnR1bmVzID0gbmV3IEYoKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBuZXcgVG9vbCBpbnN0YW5jZVxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIFRvb2wgZGF0YVxuICAgKiBAcGFyYW0gYmxvY2sgLSBCbG9ja0FQSSBmb3IgY3VycmVudCBCbG9ja1xuICAgKiBAcGFyYW0gcmVhZE9ubHkgLSBUcnVlIGlmIEVkaXRvciBpcyBpbiByZWFkLW9ubHkgbW9kZVxuICAgKi9cbiAgY3JlYXRlKGUsIHQsIG8pIHtcbiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0YWJsZSh7XG4gICAgICBkYXRhOiBlLFxuICAgICAgYmxvY2s6IHQsXG4gICAgICByZWFkT25seTogbyxcbiAgICAgIGFwaTogdGhpcy5hcGksXG4gICAgICBjb25maWc6IHRoaXMuc2V0dGluZ3NcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHJlYWQtb25seSBtb2RlIGlzIHN1cHBvcnRlZCBieSBUb29sXG4gICAqL1xuICBnZXQgaXNSZWFkT25seVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3RhYmxlW2FlLklzUmVhZE9ubHlTdXBwb3J0ZWRdID09PSAhMDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIFRvb2wgc3VwcG9ydHMgbGluZWJyZWFrc1xuICAgKi9cbiAgZ2V0IGlzTGluZUJyZWFrc0VuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0YWJsZVthZS5Jc0VuYWJsZWRMaW5lQnJlYWtzXTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBUb29sIHRvb2xib3ggY29uZmlndXJhdGlvbiAoaW50ZXJuYWwgb3IgdXNlci1zcGVjaWZpZWQpLlxuICAgKlxuICAgKiBNZXJnZXMgaW50ZXJuYWwgYW5kIHVzZXItZGVmaW5lZCB0b29sYm94IGNvbmZpZ3MgYmFzZWQgb24gdGhlIGZvbGxvd2luZyBydWxlczpcbiAgICpcbiAgICogLSBJZiBib3RoIGludGVybmFsIGFuZCB1c2VyLWRlZmluZWQgdG9vbGJveCBjb25maWdzIGFyZSBhcnJheXMgdGhlaXIgaXRlbXMgYXJlIG1lcmdlZC5cbiAgICogTGVuZ3RoIG9mIHRoZSBzZWNvbmQgb25lIGlzIGtlcHQuXG4gICAqXG4gICAqIC0gSWYgYm90aCBhcmUgb2JqZWN0cyB0aGVpciBwcm9wZXJ0aWVzIGFyZSBtZXJnZWQuXG4gICAqXG4gICAqIC0gSWYgb25lIGlzIGFuIG9iamVjdCBhbmQgYW5vdGhlciBpcyBhbiBhcnJheSB0aGFuIGludGVybmFsIGNvbmZpZyBpcyByZXBsYWNlZCB3aXRoIHVzZXItZGVmaW5lZFxuICAgKiBjb25maWcuIFRoaXMgaXMgbWFkZSB0byBhbGxvdyB1c2VyIHRvIG92ZXJyaWRlIGRlZmF1bHQgdG9vbCdzIHRvb2xib3ggcmVwcmVzZW50YXRpb24gKHNpbmdsZS9tdWx0aXBsZSBlbnRyaWVzKVxuICAgKi9cbiAgZ2V0IHRvb2xib3goKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuY29uc3RydWN0YWJsZVthZS5Ub29sYm94XSwgdCA9IHRoaXMuY29uZmlnW1NlLlRvb2xib3hdO1xuICAgIGlmICghWChlKSAmJiB0ICE9PSAhMSlcbiAgICAgIHJldHVybiB0ID8gQXJyYXkuaXNBcnJheShlKSA/IEFycmF5LmlzQXJyYXkodCkgPyB0Lm1hcCgobywgaSkgPT4ge1xuICAgICAgICBjb25zdCBzID0gZVtpXTtcbiAgICAgICAgcmV0dXJuIHMgPyB7XG4gICAgICAgICAgLi4ucyxcbiAgICAgICAgICAuLi5vXG4gICAgICAgIH0gOiBvO1xuICAgICAgfSkgOiBbdF0gOiBBcnJheS5pc0FycmF5KHQpID8gdCA6IFtcbiAgICAgICAge1xuICAgICAgICAgIC4uLmUsXG4gICAgICAgICAgLi4udFxuICAgICAgICB9XG4gICAgICBdIDogQXJyYXkuaXNBcnJheShlKSA/IGUgOiBbZV07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgVG9vbCBjb252ZXJzaW9uIGNvbmZpZ3VyYXRpb25cbiAgICovXG4gIGdldCBjb252ZXJzaW9uQ29uZmlnKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdGFibGVbYWUuQ29udmVyc2lvbkNvbmZpZ107XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgZW5hYmxlZCBpbmxpbmUgdG9vbHMgZm9yIFRvb2xcbiAgICovXG4gIGdldCBlbmFibGVkSW5saW5lVG9vbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnW1NlLkVuYWJsZWRJbmxpbmVUb29sc10gfHwgITE7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgZW5hYmxlZCB0dW5lcyBmb3IgVG9vbFxuICAgKi9cbiAgZ2V0IGVuYWJsZWRCbG9ja1R1bmVzKCkge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZ1tTZS5FbmFibGVkQmxvY2tUdW5lc107XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgVG9vbCBwYXN0ZSBjb25maWd1cmF0aW9uXG4gICAqL1xuICBnZXQgcGFzdGVDb25maWcoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0YWJsZVthZS5QYXN0ZUNvbmZpZ10gPz8ge307XG4gIH1cbiAgZ2V0IHNhbml0aXplQ29uZmlnKCkge1xuICAgIGNvbnN0IGUgPSBzdXBlci5zYW5pdGl6ZUNvbmZpZywgdCA9IHRoaXMuYmFzZVNhbml0aXplQ29uZmlnO1xuICAgIGlmIChYKGUpKVxuICAgICAgcmV0dXJuIHQ7XG4gICAgY29uc3QgbyA9IHt9O1xuICAgIGZvciAoY29uc3QgaSBpbiBlKVxuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLCBpKSkge1xuICAgICAgICBjb25zdCBzID0gZVtpXTtcbiAgICAgICAgUihzKSA/IG9baV0gPSBPYmplY3QuYXNzaWduKHt9LCB0LCBzKSA6IG9baV0gPSBzO1xuICAgICAgfVxuICAgIHJldHVybiBvO1xuICB9XG4gIGdldCBiYXNlU2FuaXRpemVDb25maWcoKSB7XG4gICAgY29uc3QgZSA9IHt9O1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuaW5saW5lVG9vbHMudmFsdWVzKCkpLmZvckVhY2goKHQpID0+IE9iamVjdC5hc3NpZ24oZSwgdC5zYW5pdGl6ZUNvbmZpZykpLCBBcnJheS5mcm9tKHRoaXMudHVuZXMudmFsdWVzKCkpLmZvckVhY2goKHQpID0+IE9iamVjdC5hc3NpZ24oZSwgdC5zYW5pdGl6ZUNvbmZpZykpLCBlO1xuICB9XG59XG5obyhbXG4gIGhlXG5dLCBmdC5wcm90b3R5cGUsIFwic2FuaXRpemVDb25maWdcIiwgMSk7XG5obyhbXG4gIGhlXG5dLCBmdC5wcm90b3R5cGUsIFwiYmFzZVNhbml0aXplQ29uZmlnXCIsIDEpO1xuY2xhc3MgZ3Mge1xuICAvKipcbiAgICogQGNsYXNzXG4gICAqIEBwYXJhbSBjb25maWcgLSB0b29scyBjb25maWdcbiAgICogQHBhcmFtIGVkaXRvckNvbmZpZyAtIEVkaXRvckpTIGNvbmZpZ1xuICAgKiBAcGFyYW0gYXBpIC0gRWRpdG9ySlMgQVBJIG1vZHVsZVxuICAgKi9cbiAgY29uc3RydWN0b3IoZSwgdCwgbykge1xuICAgIHRoaXMuYXBpID0gbywgdGhpcy5jb25maWcgPSBlLCB0aGlzLmVkaXRvckNvbmZpZyA9IHQ7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgVG9vbCBvYmplY3QgYmFzZWQgb24gaXQncyB0eXBlXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIC0gdG9vbCBuYW1lXG4gICAqL1xuICBnZXQoZSkge1xuICAgIGNvbnN0IHsgY2xhc3M6IHQsIGlzSW50ZXJuYWw6IG8gPSAhMSwgLi4uaSB9ID0gdGhpcy5jb25maWdbZV0sIHMgPSB0aGlzLmdldENvbnN0cnVjdG9yKHQpLCByID0gdFtRZS5Jc1R1bmVdO1xuICAgIHJldHVybiBuZXcgcyh7XG4gICAgICBuYW1lOiBlLFxuICAgICAgY29uc3RydWN0YWJsZTogdCxcbiAgICAgIGNvbmZpZzogaSxcbiAgICAgIGFwaTogdGhpcy5hcGkuZ2V0TWV0aG9kc0ZvclRvb2woZSwgciksXG4gICAgICBpc0RlZmF1bHQ6IGUgPT09IHRoaXMuZWRpdG9yQ29uZmlnLmRlZmF1bHRCbG9jayxcbiAgICAgIGRlZmF1bHRQbGFjZWhvbGRlcjogdGhpcy5lZGl0b3JDb25maWcucGxhY2Vob2xkZXIsXG4gICAgICBpc0ludGVybmFsOiBvXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEZpbmQgYXBwcm9wcmlhdGUgVG9vbCBvYmplY3QgY29uc3RydWN0b3IgZm9yIFRvb2wgY29uc3RydWN0YWJsZVxuICAgKlxuICAgKiBAcGFyYW0gY29uc3RydWN0YWJsZSAtIFRvb2xzIGNvbnN0cnVjdGFibGVcbiAgICovXG4gIGdldENvbnN0cnVjdG9yKGUpIHtcbiAgICBzd2l0Y2ggKCEwKSB7XG4gICAgICBjYXNlIGVbYXQuSXNJbmxpbmVdOlxuICAgICAgICByZXR1cm4gaHM7XG4gICAgICBjYXNlIGVbUWUuSXNUdW5lXTpcbiAgICAgICAgcmV0dXJuIHVzO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZ0O1xuICAgIH1cbiAgfVxufVxuY2xhc3MgdW8ge1xuICAvKipcbiAgICogTW92ZURvd25UdW5lIGNvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBwYXJhbSB7QVBJfSBhcGkg4oCUIEVkaXRvcidzIEFQSVxuICAgKi9cbiAgY29uc3RydWN0b3IoeyBhcGk6IGUgfSkge1xuICAgIHRoaXMuQ1NTID0ge1xuICAgICAgYW5pbWF0aW9uOiBcIndvYmJsZVwiXG4gICAgfSwgdGhpcy5hcGkgPSBlO1xuICB9XG4gIC8qKlxuICAgKiBUdW5lJ3MgYXBwZWFyYW5jZSBpbiBibG9jayBzZXR0aW5ncyBtZW51XG4gICAqL1xuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGljb246IFVvLFxuICAgICAgdGl0bGU6IHRoaXMuYXBpLmkxOG4udChcIk1vdmUgZG93blwiKSxcbiAgICAgIG9uQWN0aXZhdGU6ICgpID0+IHRoaXMuaGFuZGxlQ2xpY2soKSxcbiAgICAgIG5hbWU6IFwibW92ZS1kb3duXCJcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGUgY2xpY2tzIG9uICdtb3ZlIGRvd24nIGJ1dHRvblxuICAgKi9cbiAgaGFuZGxlQ2xpY2soKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuYXBpLmJsb2Nrcy5nZXRDdXJyZW50QmxvY2tJbmRleCgpLCB0ID0gdGhpcy5hcGkuYmxvY2tzLmdldEJsb2NrQnlJbmRleChlICsgMSk7XG4gICAgaWYgKCF0KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIG1vdmUgQmxvY2sgZG93biBzaW5jZSBpdCBpcyBhbHJlYWR5IHRoZSBsYXN0XCIpO1xuICAgIGNvbnN0IG8gPSB0LmhvbGRlciwgaSA9IG8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IHMgPSBNYXRoLmFicyh3aW5kb3cuaW5uZXJIZWlnaHQgLSBvLm9mZnNldEhlaWdodCk7XG4gICAgaS50b3AgPCB3aW5kb3cuaW5uZXJIZWlnaHQgJiYgKHMgPSB3aW5kb3cuc2Nyb2xsWSArIG8ub2Zmc2V0SGVpZ2h0KSwgd2luZG93LnNjcm9sbFRvKDAsIHMpLCB0aGlzLmFwaS5ibG9ja3MubW92ZShlICsgMSksIHRoaXMuYXBpLnRvb2xiYXIudG9nZ2xlQmxvY2tTZXR0aW5ncyghMCk7XG4gIH1cbn1cbnVvLmlzVHVuZSA9ICEwO1xuY2xhc3MgcG8ge1xuICAvKipcbiAgICogRGVsZXRlVHVuZSBjb25zdHJ1Y3RvclxuICAgKlxuICAgKiBAcGFyYW0ge0FQSX0gYXBpIC0gRWRpdG9yJ3MgQVBJXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGFwaTogZSB9KSB7XG4gICAgdGhpcy5hcGkgPSBlO1xuICB9XG4gIC8qKlxuICAgKiBUdW5lJ3MgYXBwZWFyYW5jZSBpbiBibG9jayBzZXR0aW5ncyBtZW51XG4gICAqL1xuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGljb246IFdvLFxuICAgICAgdGl0bGU6IHRoaXMuYXBpLmkxOG4udChcIkRlbGV0ZVwiKSxcbiAgICAgIG5hbWU6IFwiZGVsZXRlXCIsXG4gICAgICBjb25maXJtYXRpb246IHtcbiAgICAgICAgdGl0bGU6IHRoaXMuYXBpLmkxOG4udChcIkNsaWNrIHRvIGRlbGV0ZVwiKSxcbiAgICAgICAgb25BY3RpdmF0ZTogKCkgPT4gdGhpcy5oYW5kbGVDbGljaygpXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlIGJsb2NrIGNvbmRpdGlvbnMgcGFzc2VkXG4gICAqL1xuICBoYW5kbGVDbGljaygpIHtcbiAgICB0aGlzLmFwaS5ibG9ja3MuZGVsZXRlKCk7XG4gIH1cbn1cbnBvLmlzVHVuZSA9ICEwO1xuY2xhc3MgZm8ge1xuICAvKipcbiAgICogTW92ZVVwVHVuZSBjb25zdHJ1Y3RvclxuICAgKlxuICAgKiBAcGFyYW0ge0FQSX0gYXBpIC0gRWRpdG9yJ3MgQVBJXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGFwaTogZSB9KSB7XG4gICAgdGhpcy5DU1MgPSB7XG4gICAgICBhbmltYXRpb246IFwid29iYmxlXCJcbiAgICB9LCB0aGlzLmFwaSA9IGU7XG4gIH1cbiAgLyoqXG4gICAqIFR1bmUncyBhcHBlYXJhbmNlIGluIGJsb2NrIHNldHRpbmdzIG1lbnVcbiAgICovXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaWNvbjogWW8sXG4gICAgICB0aXRsZTogdGhpcy5hcGkuaTE4bi50KFwiTW92ZSB1cFwiKSxcbiAgICAgIG9uQWN0aXZhdGU6ICgpID0+IHRoaXMuaGFuZGxlQ2xpY2soKSxcbiAgICAgIG5hbWU6IFwibW92ZS11cFwiXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogTW92ZSBjdXJyZW50IGJsb2NrIHVwXG4gICAqL1xuICBoYW5kbGVDbGljaygpIHtcbiAgICBjb25zdCBlID0gdGhpcy5hcGkuYmxvY2tzLmdldEN1cnJlbnRCbG9ja0luZGV4KCksIHQgPSB0aGlzLmFwaS5ibG9ja3MuZ2V0QmxvY2tCeUluZGV4KGUpLCBvID0gdGhpcy5hcGkuYmxvY2tzLmdldEJsb2NrQnlJbmRleChlIC0gMSk7XG4gICAgaWYgKGUgPT09IDAgfHwgIXQgfHwgIW8pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gbW92ZSBCbG9jayB1cCBzaW5jZSBpdCBpcyBhbHJlYWR5IHRoZSBmaXJzdFwiKTtcbiAgICBjb25zdCBpID0gdC5ob2xkZXIsIHMgPSBvLmhvbGRlciwgciA9IGkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGwgPSBzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCBhO1xuICAgIGwudG9wID4gMCA/IGEgPSBNYXRoLmFicyhyLnRvcCkgLSBNYXRoLmFicyhsLnRvcCkgOiBhID0gTWF0aC5hYnMoci50b3ApICsgbC5oZWlnaHQsIHdpbmRvdy5zY3JvbGxCeSgwLCAtMSAqIGEpLCB0aGlzLmFwaS5ibG9ja3MubW92ZShlIC0gMSksIHRoaXMuYXBpLnRvb2xiYXIudG9nZ2xlQmxvY2tTZXR0aW5ncyghMCk7XG4gIH1cbn1cbmZvLmlzVHVuZSA9ICEwO1xudmFyIG1zID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCBicyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsIGtzID0gKG4sIGUsIHQsIG8pID0+IHtcbiAgZm9yICh2YXIgaSA9IG8gPiAxID8gdm9pZCAwIDogbyA/IGJzKGUsIHQpIDogZSwgcyA9IG4ubGVuZ3RoIC0gMSwgcjsgcyA+PSAwOyBzLS0pXG4gICAgKHIgPSBuW3NdKSAmJiAoaSA9IChvID8gcihlLCB0LCBpKSA6IHIoaSkpIHx8IGkpO1xuICByZXR1cm4gbyAmJiBpICYmIG1zKGUsIHQsIGkpLCBpO1xufTtcbmNsYXNzIGdvIGV4dGVuZHMgeSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMuc3R1YlRvb2wgPSBcInN0dWJcIiwgdGhpcy50b29sc0F2YWlsYWJsZSA9IG5ldyBGKCksIHRoaXMudG9vbHNVbmF2YWlsYWJsZSA9IG5ldyBGKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYXZhaWxhYmxlIFRvb2xzXG4gICAqL1xuICBnZXQgYXZhaWxhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLnRvb2xzQXZhaWxhYmxlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHVuYXZhaWxhYmxlIFRvb2xzXG4gICAqL1xuICBnZXQgdW5hdmFpbGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9vbHNVbmF2YWlsYWJsZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIFRvb2xzIGZvciB0aGUgSW5saW5lIFRvb2xiYXJcbiAgICovXG4gIGdldCBpbmxpbmVUb29scygpIHtcbiAgICByZXR1cm4gdGhpcy5hdmFpbGFibGUuaW5saW5lVG9vbHM7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBlZGl0b3IgYmxvY2sgdG9vbHNcbiAgICovXG4gIGdldCBibG9ja1Rvb2xzKCkge1xuICAgIHJldHVybiB0aGlzLmF2YWlsYWJsZS5ibG9ja1Rvb2xzO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gYXZhaWxhYmxlIEJsb2NrIFR1bmVzXG4gICAqXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IC0gb2JqZWN0IG9mIElubGluZSBUb29sJ3MgY2xhc3Nlc1xuICAgKi9cbiAgZ2V0IGJsb2NrVHVuZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXZhaWxhYmxlLmJsb2NrVHVuZXM7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgZGVmYXVsdCBUb29sIG9iamVjdFxuICAgKi9cbiAgZ2V0IGRlZmF1bHRUb29sKCkge1xuICAgIHJldHVybiB0aGlzLmJsb2NrVG9vbHMuZ2V0KHRoaXMuY29uZmlnLmRlZmF1bHRCbG9jayk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgaW50ZXJuYWwgdG9vbHNcbiAgICovXG4gIGdldCBpbnRlcm5hbCgpIHtcbiAgICByZXR1cm4gdGhpcy5hdmFpbGFibGUuaW50ZXJuYWxUb29scztcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBpbnN0YW5jZXMgdmlhIHBhc3NlZCBvciBkZWZhdWx0IGNvbmZpZ3VyYXRpb25cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICBhc3luYyBwcmVwYXJlKCkge1xuICAgIGlmICh0aGlzLnZhbGlkYXRlVG9vbHMoKSwgdGhpcy5jb25maWcudG9vbHMgPSBxZSh7fSwgdGhpcy5pbnRlcm5hbFRvb2xzLCB0aGlzLmNvbmZpZy50b29scyksICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5jb25maWcsIFwidG9vbHNcIikgfHwgT2JqZWN0LmtleXModGhpcy5jb25maWcudG9vbHMpLmxlbmd0aCA9PT0gMClcbiAgICAgIHRocm93IEVycm9yKFwiQ2FuJ3Qgc3RhcnQgd2l0aG91dCB0b29sc1wiKTtcbiAgICBjb25zdCBlID0gdGhpcy5wcmVwYXJlQ29uZmlnKCk7XG4gICAgdGhpcy5mYWN0b3J5ID0gbmV3IGdzKGUsIHRoaXMuY29uZmlnLCB0aGlzLkVkaXRvci5BUEkpO1xuICAgIGNvbnN0IHQgPSB0aGlzLmdldExpc3RPZlByZXBhcmVGdW5jdGlvbnMoZSk7XG4gICAgaWYgKHQubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIGF3YWl0IEVvKHQsIChvKSA9PiB7XG4gICAgICB0aGlzLnRvb2xQcmVwYXJlTWV0aG9kU3VjY2VzcyhvKTtcbiAgICB9LCAobykgPT4ge1xuICAgICAgdGhpcy50b29sUHJlcGFyZU1ldGhvZEZhbGxiYWNrKG8pO1xuICAgIH0pLCB0aGlzLnByZXBhcmVCbG9ja1Rvb2xzKCk7XG4gIH1cbiAgZ2V0QWxsSW5saW5lVG9vbHNTYW5pdGl6ZUNvbmZpZygpIHtcbiAgICBjb25zdCBlID0ge307XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5pbmxpbmVUb29scy52YWx1ZXMoKSkuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgT2JqZWN0LmFzc2lnbihlLCB0LnNhbml0aXplQ29uZmlnKTtcbiAgICB9KSwgZTtcbiAgfVxuICAvKipcbiAgICogQ2FsbHMgZWFjaCBUb29sIHJlc2V0IG1ldGhvZCB0byBjbGVhbiB1cCBhbnl0aGluZyBzZXQgYnkgVG9vbFxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICBPYmplY3QudmFsdWVzKHRoaXMuYXZhaWxhYmxlKS5mb3JFYWNoKGFzeW5jIChlKSA9PiB7XG4gICAgICBPKGUucmVzZXQpICYmIGF3YWl0IGUucmVzZXQoKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBpbnRlcm5hbCB0b29sc1xuICAgKiBJbmNsdWRlcyBCb2xkLCBJdGFsaWMsIExpbmsgYW5kIFBhcmFncmFwaFxuICAgKi9cbiAgZ2V0IGludGVybmFsVG9vbHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnZlcnRUbzoge1xuICAgICAgICBjbGFzczogYW8sXG4gICAgICAgIGlzSW50ZXJuYWw6ICEwXG4gICAgICB9LFxuICAgICAgbGluazoge1xuICAgICAgICBjbGFzczogcHQsXG4gICAgICAgIGlzSW50ZXJuYWw6ICEwXG4gICAgICB9LFxuICAgICAgYm9sZDoge1xuICAgICAgICBjbGFzczogaHQsXG4gICAgICAgIGlzSW50ZXJuYWw6ICEwXG4gICAgICB9LFxuICAgICAgaXRhbGljOiB7XG4gICAgICAgIGNsYXNzOiB1dCxcbiAgICAgICAgaXNJbnRlcm5hbDogITBcbiAgICAgIH0sXG4gICAgICBwYXJhZ3JhcGg6IHtcbiAgICAgICAgY2xhc3M6IGR0LFxuICAgICAgICBpbmxpbmVUb29sYmFyOiAhMCxcbiAgICAgICAgaXNJbnRlcm5hbDogITBcbiAgICAgIH0sXG4gICAgICBzdHViOiB7XG4gICAgICAgIGNsYXNzOiBjbyxcbiAgICAgICAgaXNJbnRlcm5hbDogITBcbiAgICAgIH0sXG4gICAgICBtb3ZlVXA6IHtcbiAgICAgICAgY2xhc3M6IGZvLFxuICAgICAgICBpc0ludGVybmFsOiAhMFxuICAgICAgfSxcbiAgICAgIGRlbGV0ZToge1xuICAgICAgICBjbGFzczogcG8sXG4gICAgICAgIGlzSW50ZXJuYWw6ICEwXG4gICAgICB9LFxuICAgICAgbW92ZURvd246IHtcbiAgICAgICAgY2xhc3M6IHVvLFxuICAgICAgICBpc0ludGVybmFsOiAhMFxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFRvb2wgcHJlcGFyZSBtZXRob2Qgc3VjY2VzcyBjYWxsYmFja1xuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSAtIGFwcGVuZCB0b29sIHRvIGF2YWlsYWJsZSBsaXN0XG4gICAqL1xuICB0b29sUHJlcGFyZU1ldGhvZFN1Y2Nlc3MoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmZhY3RvcnkuZ2V0KGUudG9vbE5hbWUpO1xuICAgIGlmICh0LmlzSW5saW5lKCkpIHtcbiAgICAgIGNvbnN0IGkgPSBbXCJyZW5kZXJcIl0uZmlsdGVyKChzKSA9PiAhdC5jcmVhdGUoKVtzXSk7XG4gICAgICBpZiAoaS5sZW5ndGgpIHtcbiAgICAgICAgSShcbiAgICAgICAgICBgSW5jb3JyZWN0IElubGluZSBUb29sOiAke3QubmFtZX0uIFNvbWUgb2YgcmVxdWlyZWQgbWV0aG9kcyBpcyBub3QgaW1wbGVtZW50ZWQgJW9gLFxuICAgICAgICAgIFwid2FyblwiLFxuICAgICAgICAgIGlcbiAgICAgICAgKSwgdGhpcy50b29sc1VuYXZhaWxhYmxlLnNldCh0Lm5hbWUsIHQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudG9vbHNBdmFpbGFibGUuc2V0KHQubmFtZSwgdCk7XG4gIH1cbiAgLyoqXG4gICAqIFRvb2wgcHJlcGFyZSBtZXRob2QgZmFpbCBjYWxsYmFja1xuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSAtIGFwcGVuZCB0b29sIHRvIHVuYXZhaWxhYmxlIGxpc3RcbiAgICovXG4gIHRvb2xQcmVwYXJlTWV0aG9kRmFsbGJhY2soZSkge1xuICAgIHRoaXMudG9vbHNVbmF2YWlsYWJsZS5zZXQoZS50b29sTmFtZSwgdGhpcy5mYWN0b3J5LmdldChlLnRvb2xOYW1lKSk7XG4gIH1cbiAgLyoqXG4gICAqIEJpbmRzIHByZXBhcmUgZnVuY3Rpb24gb2YgcGx1Z2lucyB3aXRoIHVzZXIgb3IgZGVmYXVsdCBjb25maWdcbiAgICpcbiAgICogQHJldHVybnMge0FycmF5fSBsaXN0IG9mIGZ1bmN0aW9ucyB0aGF0IG5lZWRzIHRvIGJlIGZpcmVkIHNlcXVlbnRpYWxseVxuICAgKiBAcGFyYW0gY29uZmlnIC0gdG9vbHMgY29uZmlnXG4gICAqL1xuICBnZXRMaXN0T2ZQcmVwYXJlRnVuY3Rpb25zKGUpIHtcbiAgICBjb25zdCB0ID0gW107XG4gICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGUpLmZvckVhY2goKFtvLCBpXSkgPT4ge1xuICAgICAgdC5wdXNoKHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvblxuICAgICAgICBmdW5jdGlvbjogTyhpLmNsYXNzLnByZXBhcmUpID8gaS5jbGFzcy5wcmVwYXJlIDogKCkgPT4ge1xuICAgICAgICB9LFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgdG9vbE5hbWU6IG8sXG4gICAgICAgICAgY29uZmlnOiBpLmNvbmZpZ1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KSwgdDtcbiAgfVxuICAvKipcbiAgICogQXNzaWduIGVuYWJsZWQgSW5saW5lIFRvb2xzIGFuZCBCbG9jayBUdW5lcyBmb3IgQmxvY2sgVG9vbFxuICAgKi9cbiAgcHJlcGFyZUJsb2NrVG9vbHMoKSB7XG4gICAgQXJyYXkuZnJvbSh0aGlzLmJsb2NrVG9vbHMudmFsdWVzKCkpLmZvckVhY2goKGUpID0+IHtcbiAgICAgIHRoaXMuYXNzaWduSW5saW5lVG9vbHNUb0Jsb2NrVG9vbChlKSwgdGhpcy5hc3NpZ25CbG9ja1R1bmVzVG9CbG9ja1Rvb2woZSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEFzc2lnbiBlbmFibGVkIElubGluZSBUb29scyBmb3IgQmxvY2sgVG9vbFxuICAgKlxuICAgKiBAcGFyYW0gdG9vbCAtIEJsb2NrIFRvb2xcbiAgICovXG4gIGFzc2lnbklubGluZVRvb2xzVG9CbG9ja1Rvb2woZSkge1xuICAgIGlmICh0aGlzLmNvbmZpZy5pbmxpbmVUb29sYmFyICE9PSAhMSkge1xuICAgICAgaWYgKGUuZW5hYmxlZElubGluZVRvb2xzID09PSAhMCkge1xuICAgICAgICBlLmlubGluZVRvb2xzID0gbmV3IEYoXG4gICAgICAgICAgQXJyYXkuaXNBcnJheSh0aGlzLmNvbmZpZy5pbmxpbmVUb29sYmFyKSA/IHRoaXMuY29uZmlnLmlubGluZVRvb2xiYXIubWFwKCh0KSA9PiBbdCwgdGhpcy5pbmxpbmVUb29scy5nZXQodCldKSA6IEFycmF5LmZyb20odGhpcy5pbmxpbmVUb29scy5lbnRyaWVzKCkpXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIEFycmF5LmlzQXJyYXkoZS5lbmFibGVkSW5saW5lVG9vbHMpICYmIChlLmlubGluZVRvb2xzID0gbmV3IEYoXG4gICAgICAgIC8qKiBQcmVwZW5kIENvbnZlcnRUbyBJbmxpbmUgVG9vbCAqL1xuICAgICAgICBbXCJjb252ZXJ0VG9cIiwgLi4uZS5lbmFibGVkSW5saW5lVG9vbHNdLm1hcCgodCkgPT4gW3QsIHRoaXMuaW5saW5lVG9vbHMuZ2V0KHQpXSlcbiAgICAgICkpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQXNzaWduIGVuYWJsZWQgQmxvY2sgVHVuZXMgZm9yIEJsb2NrIFRvb2xcbiAgICpcbiAgICogQHBhcmFtIHRvb2wg4oCUIEJsb2NrIFRvb2xcbiAgICovXG4gIGFzc2lnbkJsb2NrVHVuZXNUb0Jsb2NrVG9vbChlKSB7XG4gICAgaWYgKGUuZW5hYmxlZEJsb2NrVHVuZXMgIT09ICExKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShlLmVuYWJsZWRCbG9ja1R1bmVzKSkge1xuICAgICAgICBjb25zdCB0ID0gbmV3IEYoXG4gICAgICAgICAgZS5lbmFibGVkQmxvY2tUdW5lcy5tYXAoKG8pID0+IFtvLCB0aGlzLmJsb2NrVHVuZXMuZ2V0KG8pXSlcbiAgICAgICAgKTtcbiAgICAgICAgZS50dW5lcyA9IG5ldyBGKFsuLi50LCAuLi50aGlzLmJsb2NrVHVuZXMuaW50ZXJuYWxUb29sc10pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLmNvbmZpZy50dW5lcykpIHtcbiAgICAgICAgY29uc3QgdCA9IG5ldyBGKFxuICAgICAgICAgIHRoaXMuY29uZmlnLnR1bmVzLm1hcCgobykgPT4gW28sIHRoaXMuYmxvY2tUdW5lcy5nZXQobyldKVxuICAgICAgICApO1xuICAgICAgICBlLnR1bmVzID0gbmV3IEYoWy4uLnQsIC4uLnRoaXMuYmxvY2tUdW5lcy5pbnRlcm5hbFRvb2xzXSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGUudHVuZXMgPSB0aGlzLmJsb2NrVHVuZXMuaW50ZXJuYWxUb29scztcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFZhbGlkYXRlIFRvb2xzIGNvbmZpZ3VyYXRpb24gb2JqZWN0cyBhbmQgdGhyb3cgRXJyb3IgZm9yIHVzZXIgaWYgaXQgaXMgaW52YWxpZFxuICAgKi9cbiAgdmFsaWRhdGVUb29scygpIHtcbiAgICBmb3IgKGNvbnN0IGUgaW4gdGhpcy5jb25maWcudG9vbHMpXG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuY29uZmlnLnRvb2xzLCBlKSkge1xuICAgICAgICBpZiAoZSBpbiB0aGlzLmludGVybmFsVG9vbHMpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB0ID0gdGhpcy5jb25maWcudG9vbHNbZV07XG4gICAgICAgIGlmICghTyh0KSAmJiAhTyh0LmNsYXNzKSlcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIGBUb29sIMKrJHtlfcK7IG11c3QgYmUgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBvciBhbiBvYmplY3Qgd2l0aCBmdW5jdGlvbiBpbiB0aGUgwqtjbGFzc8K7IHByb3BlcnR5YFxuICAgICAgICAgICk7XG4gICAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFVuaWZ5IHRvb2xzIGNvbmZpZ1xuICAgKi9cbiAgcHJlcGFyZUNvbmZpZygpIHtcbiAgICBjb25zdCBlID0ge307XG4gICAgZm9yIChjb25zdCB0IGluIHRoaXMuY29uZmlnLnRvb2xzKVxuICAgICAgUih0aGlzLmNvbmZpZy50b29sc1t0XSkgPyBlW3RdID0gdGhpcy5jb25maWcudG9vbHNbdF0gOiBlW3RdID0geyBjbGFzczogdGhpcy5jb25maWcudG9vbHNbdF0gfTtcbiAgICByZXR1cm4gZTtcbiAgfVxufVxua3MoW1xuICBoZVxuXSwgZ28ucHJvdG90eXBlLCBcImdldEFsbElubGluZVRvb2xzU2FuaXRpemVDb25maWdcIiwgMSk7XG5jb25zdCB2cyA9IGA6cm9vdHstLXNlbGVjdGlvbkNvbG9yOiAjZTFmMmZmOy0taW5saW5lU2VsZWN0aW9uQ29sb3I6ICNkNGVjZmY7LS1iZy1saWdodDogI2VmZjJmNTstLWdyYXlUZXh0OiAjNzA3Njg0Oy0tY29sb3ItZGFyazogIzFEMjAyQjstLWNvbG9yLWFjdGl2ZS1pY29uOiAjMzg4QUU1Oy0tY29sb3ItZ3JheS1ib3JkZXI6IHJnYmEoMjAxLCAyMDEsIDIwNCwgLjQ4KTstLWNvbnRlbnQtd2lkdGg6IDY1MHB4Oy0tbmFycm93LW1vZGUtcmlnaHQtcGFkZGluZzogNTBweDstLXRvb2xib3gtYnV0dG9ucy1zaXplOiAyNnB4Oy0tdG9vbGJveC1idXR0b25zLXNpemUtLW1vYmlsZTogMzZweDstLWljb24tc2l6ZTogMjBweDstLWljb24tc2l6ZS0tbW9iaWxlOiAyOHB4Oy0tYmxvY2stcGFkZGluZy12ZXJ0aWNhbDogLjRlbTstLWNvbG9yLWxpbmUtZ3JheTogI0VGRjBGMSB9LmNvZGV4LWVkaXRvcntwb3NpdGlvbjpyZWxhdGl2ZTstd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3g7ei1pbmRleDoxfS5jb2RleC1lZGl0b3IgLmhpZGV7ZGlzcGxheTpub25lfS5jb2RleC1lZGl0b3JfX3JlZGFjdG9yIFtjb250ZW50ZWRpdGFibGVdOmVtcHR5OmFmdGVye2NvbnRlbnQ6XCJcXFxcZmVmZlwifUBtZWRpYSAobWluLXdpZHRoOiA2NTFweCl7LmNvZGV4LWVkaXRvci0tbmFycm93IC5jb2RleC1lZGl0b3JfX3JlZGFjdG9ye21hcmdpbi1yaWdodDo1MHB4fX1AbWVkaWEgKG1pbi13aWR0aDogNjUxcHgpey5jb2RleC1lZGl0b3ItLW5hcnJvdy5jb2RleC1lZGl0b3ItLXJ0bCAuY29kZXgtZWRpdG9yX19yZWRhY3RvcnttYXJnaW4tbGVmdDo1MHB4O21hcmdpbi1yaWdodDowfX1AbWVkaWEgKG1pbi13aWR0aDogNjUxcHgpey5jb2RleC1lZGl0b3ItLW5hcnJvdyAuY2UtdG9vbGJhcl9fYWN0aW9uc3tyaWdodDotNXB4fX0uY29kZXgtZWRpdG9yLWNvcHlhYmxle3Bvc2l0aW9uOmFic29sdXRlO2hlaWdodDoxcHg7d2lkdGg6MXB4O3RvcDotNDAwJTtvcGFjaXR5Oi4wMDF9LmNvZGV4LWVkaXRvci1vdmVybGF5e3Bvc2l0aW9uOmZpeGVkO3RvcDowO2xlZnQ6MDtyaWdodDowO2JvdHRvbTowO3otaW5kZXg6OTk5O3BvaW50ZXItZXZlbnRzOm5vbmU7b3ZlcmZsb3c6aGlkZGVufS5jb2RleC1lZGl0b3Itb3ZlcmxheV9fY29udGFpbmVye3Bvc2l0aW9uOnJlbGF0aXZlO3BvaW50ZXItZXZlbnRzOmF1dG87ei1pbmRleDowfS5jb2RleC1lZGl0b3Itb3ZlcmxheV9fcmVjdGFuZ2xle3Bvc2l0aW9uOmFic29sdXRlO3BvaW50ZXItZXZlbnRzOm5vbmU7YmFja2dyb3VuZC1jb2xvcjojMmVhYWRjMzM7Ym9yZGVyOjFweCBzb2xpZCB0cmFuc3BhcmVudH0uY29kZXgtZWRpdG9yIHN2Z3ttYXgtaGVpZ2h0OjEwMCV9LmNvZGV4LWVkaXRvciBwYXRoe3N0cm9rZTpjdXJyZW50Q29sb3J9LmNvZGV4LWVkaXRvciA6Oi1tb3otc2VsZWN0aW9ue2JhY2tncm91bmQtY29sb3I6I2Q0ZWNmZn0uY29kZXgtZWRpdG9yIDo6c2VsZWN0aW9ue2JhY2tncm91bmQtY29sb3I6I2Q0ZWNmZn0uY29kZXgtZWRpdG9yLS10b29sYm94LW9wZW5lZCBbY29udGVudEVkaXRhYmxlPXRydWVdW2RhdGEtcGxhY2Vob2xkZXJdOmZvY3VzOmJlZm9yZXtvcGFjaXR5OjAhaW1wb3J0YW50fS5jZS1zY3JvbGwtbG9ja2Vke292ZXJmbG93OmhpZGRlbn0uY2Utc2Nyb2xsLWxvY2tlZC0taGFyZHtvdmVyZmxvdzpoaWRkZW47dG9wOmNhbGMoLTEgKiB2YXIoLS13aW5kb3ctc2Nyb2xsLW9mZnNldCkpO3Bvc2l0aW9uOmZpeGVkO3dpZHRoOjEwMCV9LmNlLXRvb2xiYXJ7cG9zaXRpb246YWJzb2x1dGU7bGVmdDowO3JpZ2h0OjA7dG9wOjA7LXdlYmtpdC10cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGVhc2U7dHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBlYXNlO3dpbGwtY2hhbmdlOm9wYWNpdHksdG9wO2Rpc3BsYXk6bm9uZX0uY2UtdG9vbGJhci0tb3BlbmVke2Rpc3BsYXk6YmxvY2t9LmNlLXRvb2xiYXJfX2NvbnRlbnR7bWF4LXdpZHRoOjY1MHB4O21hcmdpbjowIGF1dG87cG9zaXRpb246cmVsYXRpdmV9LmNlLXRvb2xiYXJfX3BsdXN7Y29sb3I6IzFkMjAyYjtjdXJzb3I6cG9pbnRlcjt3aWR0aDoyNnB4O2hlaWdodDoyNnB4O2JvcmRlci1yYWRpdXM6N3B4O2Rpc3BsYXk6LXdlYmtpdC1pbmxpbmUtYm94O2Rpc3BsYXk6LW1zLWlubGluZS1mbGV4Ym94O2Rpc3BsYXk6aW5saW5lLWZsZXg7LXdlYmtpdC1ib3gtcGFjazpjZW50ZXI7LW1zLWZsZXgtcGFjazpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjstd2Via2l0LWJveC1hbGlnbjpjZW50ZXI7LW1zLWZsZXgtYWxpZ246Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lOy1tcy11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmU7LW1zLWZsZXgtbmVnYXRpdmU6MDtmbGV4LXNocmluazowfUBtZWRpYSAobWF4LXdpZHRoOiA2NTBweCl7LmNlLXRvb2xiYXJfX3BsdXN7d2lkdGg6MzZweDtoZWlnaHQ6MzZweH19QG1lZGlhIChob3ZlcjogaG92ZXIpey5jZS10b29sYmFyX19wbHVzOmhvdmVye2JhY2tncm91bmQtY29sb3I6I2VmZjJmNX19LmNlLXRvb2xiYXJfX3BsdXMtLWFjdGl2ZXtiYWNrZ3JvdW5kLWNvbG9yOiNlZmYyZjU7LXdlYmtpdC1hbmltYXRpb246Ym91bmNlSW4gLjc1cyAxO2FuaW1hdGlvbjpib3VuY2VJbiAuNzVzIDE7LXdlYmtpdC1hbmltYXRpb24tZmlsbC1tb2RlOmZvcndhcmRzO2FuaW1hdGlvbi1maWxsLW1vZGU6Zm9yd2FyZHN9LmNlLXRvb2xiYXJfX3BsdXMtc2hvcnRjdXR7b3BhY2l0eTouNjt3b3JkLXNwYWNpbmc6LTJweDttYXJnaW4tdG9wOjVweH1AbWVkaWEgKG1heC13aWR0aDogNjUwcHgpey5jZS10b29sYmFyX19wbHVze3Bvc2l0aW9uOmFic29sdXRlO2JhY2tncm91bmQtY29sb3I6I2ZmZjtib3JkZXI6MXB4IHNvbGlkICNFOEU4RUI7LXdlYmtpdC1ib3gtc2hhZG93OjAgM3B4IDE1cHggLTNweCByZ2JhKDEzLDIwLDMzLC4xMyk7Ym94LXNoYWRvdzowIDNweCAxNXB4IC0zcHggIzBkMTQyMTIxO2JvcmRlci1yYWRpdXM6NnB4O3otaW5kZXg6Mjtwb3NpdGlvbjpzdGF0aWN9LmNlLXRvb2xiYXJfX3BsdXMtLWxlZnQtb3JpZW50ZWQ6YmVmb3Jle2xlZnQ6MTVweDttYXJnaW4tbGVmdDowfS5jZS10b29sYmFyX19wbHVzLS1yaWdodC1vcmllbnRlZDpiZWZvcmV7bGVmdDphdXRvO3JpZ2h0OjE1cHg7bWFyZ2luLWxlZnQ6MH19LmNlLXRvb2xiYXJfX2FjdGlvbnN7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MTAwJTtvcGFjaXR5OjA7ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDtwYWRkaW5nLXJpZ2h0OjVweH0uY2UtdG9vbGJhcl9fYWN0aW9ucy0tb3BlbmVke29wYWNpdHk6MX1AbWVkaWEgKG1heC13aWR0aDogNjUwcHgpey5jZS10b29sYmFyX19hY3Rpb25ze3JpZ2h0OmF1dG99fS5jZS10b29sYmFyX19zZXR0aW5ncy1idG57Y29sb3I6IzFkMjAyYjt3aWR0aDoyNnB4O2hlaWdodDoyNnB4O2JvcmRlci1yYWRpdXM6N3B4O2Rpc3BsYXk6LXdlYmtpdC1pbmxpbmUtYm94O2Rpc3BsYXk6LW1zLWlubGluZS1mbGV4Ym94O2Rpc3BsYXk6aW5saW5lLWZsZXg7LXdlYmtpdC1ib3gtcGFjazpjZW50ZXI7LW1zLWZsZXgtcGFjazpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjstd2Via2l0LWJveC1hbGlnbjpjZW50ZXI7LW1zLWZsZXgtYWxpZ246Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lOy1tcy11c2VyLXNlbGVjdDpub25lO21hcmdpbi1sZWZ0OjNweDtjdXJzb3I6cG9pbnRlcjt1c2VyLXNlbGVjdDpub25lfUBtZWRpYSAobWF4LXdpZHRoOiA2NTBweCl7LmNlLXRvb2xiYXJfX3NldHRpbmdzLWJ0bnt3aWR0aDozNnB4O2hlaWdodDozNnB4fX1AbWVkaWEgKGhvdmVyOiBob3Zlcil7LmNlLXRvb2xiYXJfX3NldHRpbmdzLWJ0bjpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiNlZmYyZjV9fS5jZS10b29sYmFyX19zZXR0aW5ncy1idG4tLWFjdGl2ZXtiYWNrZ3JvdW5kLWNvbG9yOiNlZmYyZjU7LXdlYmtpdC1hbmltYXRpb246Ym91bmNlSW4gLjc1cyAxO2FuaW1hdGlvbjpib3VuY2VJbiAuNzVzIDE7LXdlYmtpdC1hbmltYXRpb24tZmlsbC1tb2RlOmZvcndhcmRzO2FuaW1hdGlvbi1maWxsLW1vZGU6Zm9yd2FyZHN9QG1lZGlhIChtaW4td2lkdGg6IDY1MXB4KXsuY2UtdG9vbGJhcl9fc2V0dGluZ3MtYnRue3dpZHRoOjI0cHh9fS5jZS10b29sYmFyX19zZXR0aW5ncy1idG4tLWhpZGRlbntkaXNwbGF5Om5vbmV9QG1lZGlhIChtYXgtd2lkdGg6IDY1MHB4KXsuY2UtdG9vbGJhcl9fc2V0dGluZ3MtYnRue3Bvc2l0aW9uOmFic29sdXRlO2JhY2tncm91bmQtY29sb3I6I2ZmZjtib3JkZXI6MXB4IHNvbGlkICNFOEU4RUI7LXdlYmtpdC1ib3gtc2hhZG93OjAgM3B4IDE1cHggLTNweCByZ2JhKDEzLDIwLDMzLC4xMyk7Ym94LXNoYWRvdzowIDNweCAxNXB4IC0zcHggIzBkMTQyMTIxO2JvcmRlci1yYWRpdXM6NnB4O3otaW5kZXg6Mjtwb3NpdGlvbjpzdGF0aWN9LmNlLXRvb2xiYXJfX3NldHRpbmdzLWJ0bi0tbGVmdC1vcmllbnRlZDpiZWZvcmV7bGVmdDoxNXB4O21hcmdpbi1sZWZ0OjB9LmNlLXRvb2xiYXJfX3NldHRpbmdzLWJ0bi0tcmlnaHQtb3JpZW50ZWQ6YmVmb3Jle2xlZnQ6YXV0bztyaWdodDoxNXB4O21hcmdpbi1sZWZ0OjB9fS5jZS10b29sYmFyX19wbHVzIHN2ZywuY2UtdG9vbGJhcl9fc2V0dGluZ3MtYnRuIHN2Z3t3aWR0aDoyNHB4O2hlaWdodDoyNHB4fUBtZWRpYSAobWluLXdpZHRoOiA2NTFweCl7LmNvZGV4LWVkaXRvci0tbmFycm93IC5jZS10b29sYmFyX19wbHVze2xlZnQ6NXB4fX1AbWVkaWEgKG1pbi13aWR0aDogNjUxcHgpey5jb2RleC1lZGl0b3ItLW5hcnJvdyAuY2UtdG9vbGJveCAuY2UtcG9wb3ZlcntyaWdodDowO2xlZnQ6YXV0bztsZWZ0OmluaXRpYWx9fS5jZS1pbmxpbmUtdG9vbGJhcnstLXktb2Zmc2V0OiA4cHg7LS1jb2xvci1iYWNrZ3JvdW5kLWljb24tYWN0aXZlOiByZ2JhKDU2LCAxMzgsIDIyOSwgLjEpOy0tY29sb3ItdGV4dC1pY29uLWFjdGl2ZTogIzM4OEFFNTstLWNvbG9yLXRleHQtcHJpbWFyeTogYmxhY2s7cG9zaXRpb246YWJzb2x1dGU7dmlzaWJpbGl0eTpoaWRkZW47LXdlYmtpdC10cmFuc2l0aW9uOm9wYWNpdHkgLjI1cyBlYXNlO3RyYW5zaXRpb246b3BhY2l0eSAuMjVzIGVhc2U7d2lsbC1jaGFuZ2U6b3BhY2l0eSxsZWZ0LHRvcDt0b3A6MDtsZWZ0OjA7ei1pbmRleDozO29wYWNpdHk6MTt2aXNpYmlsaXR5OnZpc2libGV9LmNlLWlubGluZS10b29sYmFyIFtoaWRkZW5de2Rpc3BsYXk6bm9uZSFpbXBvcnRhbnR9LmNlLWlubGluZS10b29sYmFyX190b2dnbGVyLWFuZC1idXR0b24td3JhcHBlcntkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4O3dpZHRoOjEwMCU7cGFkZGluZzowIDZweH0uY2UtaW5saW5lLXRvb2xiYXJfX2J1dHRvbnN7ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleH0uY2UtaW5saW5lLXRvb2xiYXJfX2Ryb3Bkb3due2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7cGFkZGluZzo2cHg7bWFyZ2luOjAgNnB4IDAgLTZweDstd2Via2l0LWJveC1hbGlnbjpjZW50ZXI7LW1zLWZsZXgtYWxpZ246Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjtjdXJzb3I6cG9pbnRlcjtib3JkZXItcmlnaHQ6MXB4IHNvbGlkIHJnYmEoMjAxLDIwMSwyMDQsLjQ4KTstd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3h9QG1lZGlhIChob3ZlcjogaG92ZXIpey5jZS1pbmxpbmUtdG9vbGJhcl9fZHJvcGRvd246aG92ZXJ7YmFja2dyb3VuZDojZWZmMmY1fX0uY2UtaW5saW5lLXRvb2xiYXJfX2Ryb3Bkb3duLS1oaWRkZW57ZGlzcGxheTpub25lfS5jZS1pbmxpbmUtdG9vbGJhcl9fZHJvcGRvd24tY29udGVudCwuY2UtaW5saW5lLXRvb2xiYXJfX2Ryb3Bkb3duLWFycm93e2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXh9LmNlLWlubGluZS10b29sYmFyX19kcm9wZG93bi1jb250ZW50IHN2ZywuY2UtaW5saW5lLXRvb2xiYXJfX2Ryb3Bkb3duLWFycm93IHN2Z3t3aWR0aDoyMHB4O2hlaWdodDoyMHB4fS5jZS1pbmxpbmUtdG9vbGJhcl9fc2hvcnRjdXR7b3BhY2l0eTouNjt3b3JkLXNwYWNpbmc6LTNweDttYXJnaW4tdG9wOjNweH0uY2UtaW5saW5lLXRvb2x7Y29sb3I6dmFyKC0tY29sb3ItdGV4dC1wcmltYXJ5KTtkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4Oy13ZWJraXQtYm94LXBhY2s6Y2VudGVyOy1tcy1mbGV4LXBhY2s6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7LXdlYmtpdC1ib3gtYWxpZ246Y2VudGVyOy1tcy1mbGV4LWFsaWduOmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXI7Ym9yZGVyOjA7Ym9yZGVyLXJhZGl1czo0cHg7bGluZS1oZWlnaHQ6bm9ybWFsO2hlaWdodDoxMDAlO3BhZGRpbmc6MDt3aWR0aDoyOHB4O2JhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnQ7Y3Vyc29yOnBvaW50ZXJ9QG1lZGlhIChtYXgtd2lkdGg6IDY1MHB4KXsuY2UtaW5saW5lLXRvb2x7d2lkdGg6MzZweDtoZWlnaHQ6MzZweH19QG1lZGlhIChob3ZlcjogaG92ZXIpey5jZS1pbmxpbmUtdG9vbDpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiNmOGY4Zjh9fS5jZS1pbmxpbmUtdG9vbCBzdmd7ZGlzcGxheTpibG9jazt3aWR0aDoyMHB4O2hlaWdodDoyMHB4fUBtZWRpYSAobWF4LXdpZHRoOiA2NTBweCl7LmNlLWlubGluZS10b29sIHN2Z3t3aWR0aDoyOHB4O2hlaWdodDoyOHB4fX0uY2UtaW5saW5lLXRvb2wtLWxpbmsgLmljb24tLXVubGluaywuY2UtaW5saW5lLXRvb2wtLXVubGluayAuaWNvbi0tbGlua3tkaXNwbGF5Om5vbmV9LmNlLWlubGluZS10b29sLS11bmxpbmsgLmljb24tLXVubGlua3tkaXNwbGF5OmlubGluZS1ibG9jazttYXJnaW4tYm90dG9tOi0xcHh9LmNlLWlubGluZS10b29sLWlucHV0e2JhY2tncm91bmQ6I0Y4RjhGODtib3JkZXI6MXB4IHNvbGlkIHJnYmEoMjI2LDIyNiwyMjksLjIpO2JvcmRlci1yYWRpdXM6NnB4O3BhZGRpbmc6NHB4IDhweDtmb250LXNpemU6MTRweDtsaW5lLWhlaWdodDoyMnB4O291dGxpbmU6bm9uZTttYXJnaW46MDt3aWR0aDoxMDAlOy13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveDtkaXNwbGF5Om5vbmU7Zm9udC13ZWlnaHQ6NTAwOy13ZWJraXQtYXBwZWFyYW5jZTpub25lO2ZvbnQtZmFtaWx5OmluaGVyaXR9QG1lZGlhIChtYXgtd2lkdGg6IDY1MHB4KXsuY2UtaW5saW5lLXRvb2wtaW5wdXR7Zm9udC1zaXplOjE1cHg7Zm9udC13ZWlnaHQ6NTAwfX0uY2UtaW5saW5lLXRvb2wtaW5wdXQ6Oi13ZWJraXQtaW5wdXQtcGxhY2Vob2xkZXJ7Y29sb3I6IzcwNzY4NH0uY2UtaW5saW5lLXRvb2wtaW5wdXQ6Oi1tb3otcGxhY2Vob2xkZXJ7Y29sb3I6IzcwNzY4NH0uY2UtaW5saW5lLXRvb2wtaW5wdXQ6LW1zLWlucHV0LXBsYWNlaG9sZGVye2NvbG9yOiM3MDc2ODR9LmNlLWlubGluZS10b29sLWlucHV0OjotbXMtaW5wdXQtcGxhY2Vob2xkZXJ7Y29sb3I6IzcwNzY4NH0uY2UtaW5saW5lLXRvb2wtaW5wdXQ6OnBsYWNlaG9sZGVye2NvbG9yOiM3MDc2ODR9LmNlLWlubGluZS10b29sLWlucHV0LS1zaG93ZWR7ZGlzcGxheTpibG9ja30uY2UtaW5saW5lLXRvb2wtLWFjdGl2ZXtiYWNrZ3JvdW5kOnZhcigtLWNvbG9yLWJhY2tncm91bmQtaWNvbi1hY3RpdmUpO2NvbG9yOnZhcigtLWNvbG9yLXRleHQtaWNvbi1hY3RpdmUpfUAtd2Via2l0LWtleWZyYW1lcyBmYWRlLWluezAle29wYWNpdHk6MH10b3tvcGFjaXR5OjF9fUBrZXlmcmFtZXMgZmFkZS1pbnswJXtvcGFjaXR5OjB9dG97b3BhY2l0eToxfX0uY2UtYmxvY2t7LXdlYmtpdC1hbmltYXRpb246ZmFkZS1pbiAuM3MgZWFzZTthbmltYXRpb246ZmFkZS1pbiAuM3MgZWFzZTstd2Via2l0LWFuaW1hdGlvbi1maWxsLW1vZGU6bm9uZTthbmltYXRpb24tZmlsbC1tb2RlOm5vbmU7LXdlYmtpdC1hbmltYXRpb24tZmlsbC1tb2RlOmluaXRpYWw7YW5pbWF0aW9uLWZpbGwtbW9kZTppbml0aWFsfS5jZS1ibG9jazpmaXJzdC1vZi10eXBle21hcmdpbi10b3A6MH0uY2UtYmxvY2stLXNlbGVjdGVkIC5jZS1ibG9ja19fY29udGVudHtiYWNrZ3JvdW5kOiNlMWYyZmZ9LmNlLWJsb2NrLS1zZWxlY3RlZCAuY2UtYmxvY2tfX2NvbnRlbnQgW2NvbnRlbnRlZGl0YWJsZV17LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lfS5jZS1ibG9jay0tc2VsZWN0ZWQgLmNlLWJsb2NrX19jb250ZW50IGltZywuY2UtYmxvY2stLXNlbGVjdGVkIC5jZS1ibG9ja19fY29udGVudCAuY2Utc3R1YntvcGFjaXR5Oi41NX0uY2UtYmxvY2stLXN0cmV0Y2hlZCAuY2UtYmxvY2tfX2NvbnRlbnR7bWF4LXdpZHRoOm5vbmV9LmNlLWJsb2NrX19jb250ZW50e3Bvc2l0aW9uOnJlbGF0aXZlO21heC13aWR0aDo2NTBweDttYXJnaW46MCBhdXRvOy13ZWJraXQtdHJhbnNpdGlvbjpiYWNrZ3JvdW5kLWNvbG9yIC4xNXMgZWFzZTt0cmFuc2l0aW9uOmJhY2tncm91bmQtY29sb3IgLjE1cyBlYXNlfS5jZS1ibG9jay0tZHJvcC10YXJnZXQgLmNlLWJsb2NrX19jb250ZW50OmJlZm9yZXtjb250ZW50OlwiXCI7cG9zaXRpb246YWJzb2x1dGU7dG9wOjEwMCU7bGVmdDotMjBweDttYXJnaW4tdG9wOi0xcHg7aGVpZ2h0OjhweDt3aWR0aDo4cHg7Ym9yZGVyOnNvbGlkICMzODhBRTU7Ym9yZGVyLXdpZHRoOjFweCAxcHggMCAwOy13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjpyaWdodDt0cmFuc2Zvcm0tb3JpZ2luOnJpZ2h0Oy13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSg0NWRlZyk7dHJhbnNmb3JtOnJvdGF0ZSg0NWRlZyl9LmNlLWJsb2NrLS1kcm9wLXRhcmdldCAuY2UtYmxvY2tfX2NvbnRlbnQ6YWZ0ZXJ7Y29udGVudDpcIlwiO3Bvc2l0aW9uOmFic29sdXRlO3RvcDoxMDAlO2hlaWdodDoxcHg7d2lkdGg6MTAwJTtjb2xvcjojMzg4YWU1O2JhY2tncm91bmQ6cmVwZWF0aW5nLWxpbmVhci1ncmFkaWVudCg5MGRlZywjMzg4QUU1LCMzODhBRTUgMXB4LCNmZmYgMXB4LCNmZmYgNnB4KX0uY2UtYmxvY2sgYXtjdXJzb3I6cG9pbnRlcjstd2Via2l0LXRleHQtZGVjb3JhdGlvbjp1bmRlcmxpbmU7dGV4dC1kZWNvcmF0aW9uOnVuZGVybGluZX0uY2UtYmxvY2sgYntmb250LXdlaWdodDo3MDB9LmNlLWJsb2NrIGl7Zm9udC1zdHlsZTppdGFsaWN9QC13ZWJraXQta2V5ZnJhbWVzIGJvdW5jZUluezAlLDIwJSw0MCUsNjAlLDgwJSx0b3std2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKC4yMTUsLjYxLC4zNTUsMSk7YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoLjIxNSwuNjEsLjM1NSwxKX0wJXstd2Via2l0LXRyYW5zZm9ybTpzY2FsZTNkKC45LC45LC45KTt0cmFuc2Zvcm06c2NhbGUzZCguOSwuOSwuOSl9MjAley13ZWJraXQtdHJhbnNmb3JtOnNjYWxlM2QoMS4wMywxLjAzLDEuMDMpO3RyYW5zZm9ybTpzY2FsZTNkKDEuMDMsMS4wMywxLjAzKX02MCV7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUzZCgxLDEsMSk7dHJhbnNmb3JtOnNjYWxlWigxKX19QGtleWZyYW1lcyBib3VuY2VJbnswJSwyMCUsNDAlLDYwJSw4MCUsdG97LXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllciguMjE1LC42MSwuMzU1LDEpO2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKC4yMTUsLjYxLC4zNTUsMSl9MCV7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUzZCguOSwuOSwuOSk7dHJhbnNmb3JtOnNjYWxlM2QoLjksLjksLjkpfTIwJXstd2Via2l0LXRyYW5zZm9ybTpzY2FsZTNkKDEuMDMsMS4wMywxLjAzKTt0cmFuc2Zvcm06c2NhbGUzZCgxLjAzLDEuMDMsMS4wMyl9NjAley13ZWJraXQtdHJhbnNmb3JtOnNjYWxlM2QoMSwxLDEpO3RyYW5zZm9ybTpzY2FsZVooMSl9fUAtd2Via2l0LWtleWZyYW1lcyBzZWxlY3Rpb25Cb3VuY2V7MCUsMjAlLDQwJSw2MCUsODAlLHRvey13ZWJraXQtYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoLjIxNSwuNjEsLjM1NSwxKTthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllciguMjE1LC42MSwuMzU1LDEpfTUwJXstd2Via2l0LXRyYW5zZm9ybTpzY2FsZTNkKDEuMDEsMS4wMSwxLjAxKTt0cmFuc2Zvcm06c2NhbGUzZCgxLjAxLDEuMDEsMS4wMSl9NzAley13ZWJraXQtdHJhbnNmb3JtOnNjYWxlM2QoMSwxLDEpO3RyYW5zZm9ybTpzY2FsZVooMSl9fUBrZXlmcmFtZXMgc2VsZWN0aW9uQm91bmNlezAlLDIwJSw0MCUsNjAlLDgwJSx0b3std2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKC4yMTUsLjYxLC4zNTUsMSk7YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoLjIxNSwuNjEsLjM1NSwxKX01MCV7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUzZCgxLjAxLDEuMDEsMS4wMSk7dHJhbnNmb3JtOnNjYWxlM2QoMS4wMSwxLjAxLDEuMDEpfTcwJXstd2Via2l0LXRyYW5zZm9ybTpzY2FsZTNkKDEsMSwxKTt0cmFuc2Zvcm06c2NhbGVaKDEpfX1ALXdlYmtpdC1rZXlmcmFtZXMgYnV0dG9uQ2xpY2tlZHswJSwyMCUsNDAlLDYwJSw4MCUsdG97LXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllciguMjE1LC42MSwuMzU1LDEpO2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKC4yMTUsLjYxLC4zNTUsMSl9MCV7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUzZCguOTUsLjk1LC45NSk7dHJhbnNmb3JtOnNjYWxlM2QoLjk1LC45NSwuOTUpfTYwJXstd2Via2l0LXRyYW5zZm9ybTpzY2FsZTNkKDEuMDIsMS4wMiwxLjAyKTt0cmFuc2Zvcm06c2NhbGUzZCgxLjAyLDEuMDIsMS4wMil9ODAley13ZWJraXQtdHJhbnNmb3JtOnNjYWxlM2QoMSwxLDEpO3RyYW5zZm9ybTpzY2FsZVooMSl9fUBrZXlmcmFtZXMgYnV0dG9uQ2xpY2tlZHswJSwyMCUsNDAlLDYwJSw4MCUsdG97LXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllciguMjE1LC42MSwuMzU1LDEpO2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKC4yMTUsLjYxLC4zNTUsMSl9MCV7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUzZCguOTUsLjk1LC45NSk7dHJhbnNmb3JtOnNjYWxlM2QoLjk1LC45NSwuOTUpfTYwJXstd2Via2l0LXRyYW5zZm9ybTpzY2FsZTNkKDEuMDIsMS4wMiwxLjAyKTt0cmFuc2Zvcm06c2NhbGUzZCgxLjAyLDEuMDIsMS4wMil9ODAley13ZWJraXQtdHJhbnNmb3JtOnNjYWxlM2QoMSwxLDEpO3RyYW5zZm9ybTpzY2FsZVooMSl9fS5jZHgtYmxvY2t7cGFkZGluZzouNGVtIDB9LmNkeC1ibG9jazo6LXdlYmtpdC1pbnB1dC1wbGFjZWhvbGRlcntsaW5lLWhlaWdodDpub3JtYWwhaW1wb3J0YW50fS5jZHgtaW5wdXR7Ym9yZGVyOjFweCBzb2xpZCByZ2JhKDIwMSwyMDEsMjA0LC40OCk7LXdlYmtpdC1ib3gtc2hhZG93Omluc2V0IDAgMXB4IDJweCAwIHJnYmEoMzUsNDQsNzIsLjA2KTtib3gtc2hhZG93Omluc2V0IDAgMXB4IDJweCAjMjMyYzQ4MGY7Ym9yZGVyLXJhZGl1czozcHg7cGFkZGluZzoxMHB4IDEycHg7b3V0bGluZTpub25lO3dpZHRoOjEwMCU7LXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7Ym94LXNpemluZzpib3JkZXItYm94fS5jZHgtaW5wdXRbZGF0YS1wbGFjZWhvbGRlcl06YmVmb3Jle3Bvc2l0aW9uOnN0YXRpYyFpbXBvcnRhbnR9LmNkeC1pbnB1dFtkYXRhLXBsYWNlaG9sZGVyXTpiZWZvcmV7ZGlzcGxheTppbmxpbmUtYmxvY2s7d2lkdGg6MDt3aGl0ZS1zcGFjZTpub3dyYXA7cG9pbnRlci1ldmVudHM6bm9uZX0uY2R4LXNldHRpbmdzLWJ1dHRvbntkaXNwbGF5Oi13ZWJraXQtaW5saW5lLWJveDtkaXNwbGF5Oi1tcy1pbmxpbmUtZmxleGJveDtkaXNwbGF5OmlubGluZS1mbGV4Oy13ZWJraXQtYm94LWFsaWduOmNlbnRlcjstbXMtZmxleC1hbGlnbjpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyOy13ZWJraXQtYm94LXBhY2s6Y2VudGVyOy1tcy1mbGV4LXBhY2s6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7Ym9yZGVyLXJhZGl1czozcHg7Y3Vyc29yOnBvaW50ZXI7Ym9yZGVyOjA7b3V0bGluZTpub25lO2JhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnQ7dmVydGljYWwtYWxpZ246Ym90dG9tO2NvbG9yOmluaGVyaXQ7bWFyZ2luOjA7bWluLXdpZHRoOjI2cHg7bWluLWhlaWdodDoyNnB4fS5jZHgtc2V0dGluZ3MtYnV0dG9uLS1mb2N1c2Vke2JhY2tncm91bmQ6cmdiYSgzNCwxODYsMjU1LC4wOCkhaW1wb3J0YW50fS5jZHgtc2V0dGluZ3MtYnV0dG9uLS1mb2N1c2Vkey13ZWJraXQtYm94LXNoYWRvdzppbnNldCAwIDAgMHB4IDFweCByZ2JhKDcsMTYxLDIyNywuMDgpO2JveC1zaGFkb3c6aW5zZXQgMCAwIDAgMXB4ICMwN2ExZTMxNH0uY2R4LXNldHRpbmdzLWJ1dHRvbi0tZm9jdXNlZC1hbmltYXRlZHstd2Via2l0LWFuaW1hdGlvbi1uYW1lOmJ1dHRvbkNsaWNrZWQ7YW5pbWF0aW9uLW5hbWU6YnV0dG9uQ2xpY2tlZDstd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjouMjVzO2FuaW1hdGlvbi1kdXJhdGlvbjouMjVzfS5jZHgtc2V0dGluZ3MtYnV0dG9uLS1hY3RpdmV7Y29sb3I6IzM4OGFlNX0uY2R4LXNldHRpbmdzLWJ1dHRvbiBzdmd7d2lkdGg6YXV0bztoZWlnaHQ6YXV0b31AbWVkaWEgKG1heC13aWR0aDogNjUwcHgpey5jZHgtc2V0dGluZ3MtYnV0dG9uIHN2Z3t3aWR0aDoyOHB4O2hlaWdodDoyOHB4fX1AbWVkaWEgKG1heC13aWR0aDogNjUwcHgpey5jZHgtc2V0dGluZ3MtYnV0dG9ue3dpZHRoOjM2cHg7aGVpZ2h0OjM2cHg7Ym9yZGVyLXJhZGl1czo4cHh9fUBtZWRpYSAoaG92ZXI6IGhvdmVyKXsuY2R4LXNldHRpbmdzLWJ1dHRvbjpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiNlZmYyZjV9fS5jZHgtbG9hZGVye3Bvc2l0aW9uOnJlbGF0aXZlO2JvcmRlcjoxcHggc29saWQgcmdiYSgyMDEsMjAxLDIwNCwuNDgpfS5jZHgtbG9hZGVyOmJlZm9yZXtjb250ZW50OlwiXCI7cG9zaXRpb246YWJzb2x1dGU7bGVmdDo1MCU7dG9wOjUwJTt3aWR0aDoxOHB4O2hlaWdodDoxOHB4O21hcmdpbjotMTFweCAwIDAgLTExcHg7Ym9yZGVyOjJweCBzb2xpZCByZ2JhKDIwMSwyMDEsMjA0LC40OCk7Ym9yZGVyLWxlZnQtY29sb3I6IzM4OGFlNTtib3JkZXItcmFkaXVzOjUwJTstd2Via2l0LWFuaW1hdGlvbjpjZHhSb3RhdGlvbiAxLjJzIGluZmluaXRlIGxpbmVhcjthbmltYXRpb246Y2R4Um90YXRpb24gMS4ycyBpbmZpbml0ZSBsaW5lYXJ9QC13ZWJraXQta2V5ZnJhbWVzIGNkeFJvdGF0aW9uezAley13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgwZGVnKTt0cmFuc2Zvcm06cm90YXRlKDApfXRvey13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgzNjBkZWcpO3RyYW5zZm9ybTpyb3RhdGUoMzYwZGVnKX19QGtleWZyYW1lcyBjZHhSb3RhdGlvbnswJXstd2Via2l0LXRyYW5zZm9ybTpyb3RhdGUoMGRlZyk7dHJhbnNmb3JtOnJvdGF0ZSgwKX10b3std2Via2l0LXRyYW5zZm9ybTpyb3RhdGUoMzYwZGVnKTt0cmFuc2Zvcm06cm90YXRlKDM2MGRlZyl9fS5jZHgtYnV0dG9ue3BhZGRpbmc6MTNweDtib3JkZXItcmFkaXVzOjNweDtib3JkZXI6MXB4IHNvbGlkIHJnYmEoMjAxLDIwMSwyMDQsLjQ4KTtmb250LXNpemU6MTQuOXB4O2JhY2tncm91bmQ6I2ZmZjstd2Via2l0LWJveC1zaGFkb3c6MCAycHggMnB4IDAgcmdiYSgxOCwzMCw1NywuMDQpO2JveC1zaGFkb3c6MCAycHggMnB4ICMxMjFlMzkwYTtjb2xvcjojNzA3Njg0O3RleHQtYWxpZ246Y2VudGVyO2N1cnNvcjpwb2ludGVyfUBtZWRpYSAoaG92ZXI6IGhvdmVyKXsuY2R4LWJ1dHRvbjpob3ZlcntiYWNrZ3JvdW5kOiNGQkZDRkU7LXdlYmtpdC1ib3gtc2hhZG93OjAgMXB4IDNweCAwIHJnYmEoMTgsMzAsNTcsLjA4KTtib3gtc2hhZG93OjAgMXB4IDNweCAjMTIxZTM5MTR9fS5jZHgtYnV0dG9uIHN2Z3toZWlnaHQ6MjBweDttYXJnaW4tcmlnaHQ6LjJlbTttYXJnaW4tdG9wOi0ycHh9LmNlLXN0dWJ7ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDstd2Via2l0LWJveC1hbGlnbjpjZW50ZXI7LW1zLWZsZXgtYWxpZ246Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjtwYWRkaW5nOjEycHggMThweDttYXJnaW46MTBweCAwO2JvcmRlci1yYWRpdXM6MTBweDtiYWNrZ3JvdW5kOiNlZmYyZjU7Ym9yZGVyOjFweCBzb2xpZCAjRUZGMEYxO2NvbG9yOiM3MDc2ODQ7Zm9udC1zaXplOjE0cHh9LmNlLXN0dWIgc3Zne3dpZHRoOjIwcHg7aGVpZ2h0OjIwcHh9LmNlLXN0dWJfX2luZm97bWFyZ2luLWxlZnQ6MTRweH0uY2Utc3R1Yl9fdGl0bGV7Zm9udC13ZWlnaHQ6NTAwO3RleHQtdHJhbnNmb3JtOmNhcGl0YWxpemV9LmNvZGV4LWVkaXRvci5jb2RleC1lZGl0b3ItLXJ0bHtkaXJlY3Rpb246cnRsfS5jb2RleC1lZGl0b3IuY29kZXgtZWRpdG9yLS1ydGwgLmNkeC1saXN0e3BhZGRpbmctbGVmdDowO3BhZGRpbmctcmlnaHQ6NDBweH0uY29kZXgtZWRpdG9yLmNvZGV4LWVkaXRvci0tcnRsIC5jZS10b29sYmFyX19wbHVze3JpZ2h0Oi0yNnB4O2xlZnQ6YXV0b30uY29kZXgtZWRpdG9yLmNvZGV4LWVkaXRvci0tcnRsIC5jZS10b29sYmFyX19hY3Rpb25ze3JpZ2h0OmF1dG87bGVmdDotMjZweH1AbWVkaWEgKG1heC13aWR0aDogNjUwcHgpey5jb2RleC1lZGl0b3IuY29kZXgtZWRpdG9yLS1ydGwgLmNlLXRvb2xiYXJfX2FjdGlvbnN7bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6YXV0bztwYWRkaW5nLXJpZ2h0OjA7cGFkZGluZy1sZWZ0OjEwcHh9fS5jb2RleC1lZGl0b3IuY29kZXgtZWRpdG9yLS1ydGwgLmNlLXNldHRpbmdze2xlZnQ6NXB4O3JpZ2h0OmF1dG99LmNvZGV4LWVkaXRvci5jb2RleC1lZGl0b3ItLXJ0bCAuY2Utc2V0dGluZ3M6YmVmb3Jle3JpZ2h0OmF1dG87bGVmdDoyNXB4fS5jb2RleC1lZGl0b3IuY29kZXgtZWRpdG9yLS1ydGwgLmNlLXNldHRpbmdzX19idXR0b246bm90KDpudGgtY2hpbGQoM24rMykpe21hcmdpbi1sZWZ0OjNweDttYXJnaW4tcmlnaHQ6MH0uY29kZXgtZWRpdG9yLmNvZGV4LWVkaXRvci0tcnRsIC5jZS1jb252ZXJzaW9uLXRvb2xfX2ljb257bWFyZ2luLXJpZ2h0OjA7bWFyZ2luLWxlZnQ6MTBweH0uY29kZXgtZWRpdG9yLmNvZGV4LWVkaXRvci0tcnRsIC5jZS1pbmxpbmUtdG9vbGJhcl9fZHJvcGRvd257Ym9yZGVyLXJpZ2h0OjBweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItbGVmdDoxcHggc29saWQgcmdiYSgyMDEsMjAxLDIwNCwuNDgpO21hcmdpbjowIC02cHggMCA2cHh9LmNvZGV4LWVkaXRvci5jb2RleC1lZGl0b3ItLXJ0bCAuY2UtaW5saW5lLXRvb2xiYXJfX2Ryb3Bkb3duIC5pY29uLS10b2dnbGVyLWRvd257bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6NHB4fUBtZWRpYSAobWluLXdpZHRoOiA2NTFweCl7LmNvZGV4LWVkaXRvci0tbmFycm93LmNvZGV4LWVkaXRvci0tcnRsIC5jZS10b29sYmFyX19wbHVze2xlZnQ6MDtyaWdodDo1cHh9fUBtZWRpYSAobWluLXdpZHRoOiA2NTFweCl7LmNvZGV4LWVkaXRvci0tbmFycm93LmNvZGV4LWVkaXRvci0tcnRsIC5jZS10b29sYmFyX19hY3Rpb25ze2xlZnQ6LTVweH19LmNkeC1zZWFyY2gtZmllbGR7LS1pY29uLW1hcmdpbi1yaWdodDogMTBweDtiYWNrZ3JvdW5kOiNGOEY4Rjg7Ym9yZGVyOjFweCBzb2xpZCByZ2JhKDIyNiwyMjYsMjI5LC4yKTtib3JkZXItcmFkaXVzOjZweDtwYWRkaW5nOjJweDtkaXNwbGF5OmdyaWQ7Z3JpZC10ZW1wbGF0ZS1jb2x1bW5zOmF1dG8gYXV0byAxZnI7Z3JpZC10ZW1wbGF0ZS1yb3dzOmF1dG99LmNkeC1zZWFyY2gtZmllbGRfX2ljb257d2lkdGg6MjZweDtoZWlnaHQ6MjZweDtkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4Oy13ZWJraXQtYm94LWFsaWduOmNlbnRlcjstbXMtZmxleC1hbGlnbjpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyOy13ZWJraXQtYm94LXBhY2s6Y2VudGVyOy1tcy1mbGV4LXBhY2s6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7bWFyZ2luLXJpZ2h0OnZhcigtLWljb24tbWFyZ2luLXJpZ2h0KX0uY2R4LXNlYXJjaC1maWVsZF9faWNvbiBzdmd7d2lkdGg6MjBweDtoZWlnaHQ6MjBweDtjb2xvcjojNzA3Njg0fS5jZHgtc2VhcmNoLWZpZWxkX19pbnB1dHtmb250LXNpemU6MTRweDtvdXRsaW5lOm5vbmU7Zm9udC13ZWlnaHQ6NTAwO2ZvbnQtZmFtaWx5OmluaGVyaXQ7Ym9yZGVyOjA7YmFja2dyb3VuZDp0cmFuc3BhcmVudDttYXJnaW46MDtwYWRkaW5nOjA7bGluZS1oZWlnaHQ6MjJweDttaW4td2lkdGg6Y2FsYygxMDAlIC0gMjZweCAtIHZhcigtLWljb24tbWFyZ2luLXJpZ2h0KSl9LmNkeC1zZWFyY2gtZmllbGRfX2lucHV0Ojotd2Via2l0LWlucHV0LXBsYWNlaG9sZGVye2NvbG9yOiM3MDc2ODQ7Zm9udC13ZWlnaHQ6NTAwfS5jZHgtc2VhcmNoLWZpZWxkX19pbnB1dDo6LW1vei1wbGFjZWhvbGRlcntjb2xvcjojNzA3Njg0O2ZvbnQtd2VpZ2h0OjUwMH0uY2R4LXNlYXJjaC1maWVsZF9faW5wdXQ6LW1zLWlucHV0LXBsYWNlaG9sZGVye2NvbG9yOiM3MDc2ODQ7Zm9udC13ZWlnaHQ6NTAwfS5jZHgtc2VhcmNoLWZpZWxkX19pbnB1dDo6LW1zLWlucHV0LXBsYWNlaG9sZGVye2NvbG9yOiM3MDc2ODQ7Zm9udC13ZWlnaHQ6NTAwfS5jZHgtc2VhcmNoLWZpZWxkX19pbnB1dDo6cGxhY2Vob2xkZXJ7Y29sb3I6IzcwNzY4NDtmb250LXdlaWdodDo1MDB9LmNlLXBvcG92ZXJ7LS1ib3JkZXItcmFkaXVzOiA2cHg7LS13aWR0aDogMjAwcHg7LS1tYXgtaGVpZ2h0OiAyNzBweDstLXBhZGRpbmc6IDZweDstLW9mZnNldC1mcm9tLXRhcmdldDogOHB4Oy0tY29sb3ItYm9yZGVyOiAjRUZGMEYxOy0tY29sb3Itc2hhZG93OiByZ2JhKDEzLCAyMCwgMzMsIC4xKTstLWNvbG9yLWJhY2tncm91bmQ6IHdoaXRlOy0tY29sb3ItdGV4dC1wcmltYXJ5OiBibGFjazstLWNvbG9yLXRleHQtc2Vjb25kYXJ5OiAjNzA3Njg0Oy0tY29sb3ItYm9yZGVyLWljb246IHJnYmEoMjAxLCAyMDEsIDIwNCwgLjQ4KTstLWNvbG9yLWJvcmRlci1pY29uLWRpc2FibGVkOiAjRUZGMEYxOy0tY29sb3ItdGV4dC1pY29uLWFjdGl2ZTogIzM4OEFFNTstLWNvbG9yLWJhY2tncm91bmQtaWNvbi1hY3RpdmU6IHJnYmEoNTYsIDEzOCwgMjI5LCAuMSk7LS1jb2xvci1iYWNrZ3JvdW5kLWl0ZW0tZm9jdXM6IHJnYmEoMzQsIDE4NiwgMjU1LCAuMDgpOy0tY29sb3Itc2hhZG93LWl0ZW0tZm9jdXM6IHJnYmEoNywgMTYxLCAyMjcsIC4wOCk7LS1jb2xvci1iYWNrZ3JvdW5kLWl0ZW0taG92ZXI6ICNGOEY4Rjg7LS1jb2xvci1iYWNrZ3JvdW5kLWl0ZW0tY29uZmlybTogI0UyNEE0QTstLWNvbG9yLWJhY2tncm91bmQtaXRlbS1jb25maXJtLWhvdmVyOiAjQ0U0MzQzOy0tcG9wb3Zlci10b3A6IGNhbGMoMTAwJSArIHZhcigtLW9mZnNldC1mcm9tLXRhcmdldCkpOy0tcG9wb3Zlci1sZWZ0OiAwOy0tbmVzdGVkLXBvcG92ZXItb3ZlcmxhcDogNHB4Oy0taWNvbi1zaXplOiAyMHB4Oy0taXRlbS1wYWRkaW5nOiAzcHg7LS1pdGVtLWhlaWdodDogY2FsYyh2YXIoLS1pY29uLXNpemUpICsgMiAqIHZhcigtLWl0ZW0tcGFkZGluZykpfS5jZS1wb3BvdmVyX19jb250YWluZXJ7bWluLXdpZHRoOnZhcigtLXdpZHRoKTt3aWR0aDp2YXIoLS13aWR0aCk7bWF4LWhlaWdodDp2YXIoLS1tYXgtaGVpZ2h0KTtib3JkZXItcmFkaXVzOnZhcigtLWJvcmRlci1yYWRpdXMpO292ZXJmbG93OmhpZGRlbjstd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3g7LXdlYmtpdC1ib3gtc2hhZG93OjBweCAzcHggMTVweCAtM3B4IHZhcigtLWNvbG9yLXNoYWRvdyk7Ym94LXNoYWRvdzowIDNweCAxNXB4IC0zcHggdmFyKC0tY29sb3Itc2hhZG93KTtwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OnZhcigtLXBvcG92ZXItbGVmdCk7dG9wOnZhcigtLXBvcG92ZXItdG9wKTtiYWNrZ3JvdW5kOnZhcigtLWNvbG9yLWJhY2tncm91bmQpO2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7LXdlYmtpdC1ib3gtb3JpZW50OnZlcnRpY2FsOy13ZWJraXQtYm94LWRpcmVjdGlvbjpub3JtYWw7LW1zLWZsZXgtZGlyZWN0aW9uOmNvbHVtbjtmbGV4LWRpcmVjdGlvbjpjb2x1bW47ei1pbmRleDo0O29wYWNpdHk6MDttYXgtaGVpZ2h0OjA7cG9pbnRlci1ldmVudHM6bm9uZTtwYWRkaW5nOjA7Ym9yZGVyOm5vbmV9LmNlLXBvcG92ZXItLW9wZW5lZD4uY2UtcG9wb3Zlcl9fY29udGFpbmVye29wYWNpdHk6MTtwYWRkaW5nOnZhcigtLXBhZGRpbmcpO21heC1oZWlnaHQ6dmFyKC0tbWF4LWhlaWdodCk7cG9pbnRlci1ldmVudHM6YXV0bzstd2Via2l0LWFuaW1hdGlvbjpwYW5lbFNob3dpbmcgLjFzIGVhc2U7YW5pbWF0aW9uOnBhbmVsU2hvd2luZyAuMXMgZWFzZTtib3JkZXI6MXB4IHNvbGlkIHZhcigtLWNvbG9yLWJvcmRlcil9QG1lZGlhIChtYXgtd2lkdGg6IDY1MHB4KXsuY2UtcG9wb3Zlci0tb3BlbmVkPi5jZS1wb3BvdmVyX19jb250YWluZXJ7LXdlYmtpdC1hbmltYXRpb246cGFuZWxTaG93aW5nTW9iaWxlIC4yNXMgZWFzZTthbmltYXRpb246cGFuZWxTaG93aW5nTW9iaWxlIC4yNXMgZWFzZX19LmNlLXBvcG92ZXItLW9wZW4tdG9wIC5jZS1wb3BvdmVyX19jb250YWluZXJ7LS1wb3BvdmVyLXRvcDogY2FsYygtMSAqICh2YXIoLS1vZmZzZXQtZnJvbS10YXJnZXQpICsgdmFyKC0tcG9wb3Zlci1oZWlnaHQpKSl9LmNlLXBvcG92ZXItLW9wZW4tbGVmdCAuY2UtcG9wb3Zlcl9fY29udGFpbmVyey0tcG9wb3Zlci1sZWZ0OiBjYWxjKC0xICogdmFyKC0td2lkdGgpICsgMTAwJSl9LmNlLXBvcG92ZXJfX2l0ZW1ze292ZXJmbG93LXk6YXV0bzstbXMtc2Nyb2xsLWNoYWluaW5nOm5vbmU7b3ZlcnNjcm9sbC1iZWhhdmlvcjpjb250YWlufUBtZWRpYSAobWF4LXdpZHRoOiA2NTBweCl7LmNlLXBvcG92ZXJfX292ZXJsYXl7cG9zaXRpb246Zml4ZWQ7dG9wOjA7Ym90dG9tOjA7bGVmdDowO3JpZ2h0OjA7YmFja2dyb3VuZDojMUQyMDJCO3otaW5kZXg6MztvcGFjaXR5Oi41Oy13ZWJraXQtdHJhbnNpdGlvbjpvcGFjaXR5IC4xMnMgZWFzZS1pbjt0cmFuc2l0aW9uOm9wYWNpdHkgLjEycyBlYXNlLWluO3dpbGwtY2hhbmdlOm9wYWNpdHk7dmlzaWJpbGl0eTp2aXNpYmxlfX0uY2UtcG9wb3Zlcl9fb3ZlcmxheS0taGlkZGVue2Rpc3BsYXk6bm9uZX1AbWVkaWEgKG1heC13aWR0aDogNjUwcHgpey5jZS1wb3BvdmVyIC5jZS1wb3BvdmVyX19jb250YWluZXJ7LS1vZmZzZXQ6IDVweDtwb3NpdGlvbjpmaXhlZDttYXgtd2lkdGg6bm9uZTttaW4td2lkdGg6Y2FsYygxMDAlIC0gdmFyKC0tb2Zmc2V0KSAqIDIpO2xlZnQ6dmFyKC0tb2Zmc2V0KTtyaWdodDp2YXIoLS1vZmZzZXQpO2JvdHRvbTpjYWxjKHZhcigtLW9mZnNldCkgKyBlbnYoc2FmZS1hcmVhLWluc2V0LWJvdHRvbSkpO3RvcDphdXRvO2JvcmRlci1yYWRpdXM6MTBweH19LmNlLXBvcG92ZXJfX3NlYXJjaHttYXJnaW4tYm90dG9tOjVweH0uY2UtcG9wb3Zlcl9fbm90aGluZy1mb3VuZC1tZXNzYWdle2NvbG9yOiM3MDc2ODQ7ZGlzcGxheTpub25lO2N1cnNvcjpkZWZhdWx0O3BhZGRpbmc6M3B4O2ZvbnQtc2l6ZToxNHB4O2xpbmUtaGVpZ2h0OjIwcHg7Zm9udC13ZWlnaHQ6NTAwO3doaXRlLXNwYWNlOm5vd3JhcDtvdmVyZmxvdzpoaWRkZW47dGV4dC1vdmVyZmxvdzplbGxpcHNpc30uY2UtcG9wb3Zlcl9fbm90aGluZy1mb3VuZC1tZXNzYWdlLS1kaXNwbGF5ZWR7ZGlzcGxheTpibG9ja30uY2UtcG9wb3Zlci0tbmVzdGVkIC5jZS1wb3BvdmVyX19jb250YWluZXJ7LS1wb3BvdmVyLWxlZnQ6IGNhbGModmFyKC0tbmVzdGluZy1sZXZlbCkgKiAodmFyKC0td2lkdGgpIC0gdmFyKC0tbmVzdGVkLXBvcG92ZXItb3ZlcmxhcCkpKTt0b3A6Y2FsYyh2YXIoLS10cmlnZ2VyLWl0ZW0tdG9wKSAtIHZhcigtLW5lc3RlZC1wb3BvdmVyLW92ZXJsYXApKTtwb3NpdGlvbjphYnNvbHV0ZX0uY2UtcG9wb3Zlci0tb3Blbi10b3AuY2UtcG9wb3Zlci0tbmVzdGVkIC5jZS1wb3BvdmVyX19jb250YWluZXJ7dG9wOmNhbGModmFyKC0tdHJpZ2dlci1pdGVtLXRvcCkgLSB2YXIoLS1wb3BvdmVyLWhlaWdodCkgKyB2YXIoLS1pdGVtLWhlaWdodCkgKyB2YXIoLS1vZmZzZXQtZnJvbS10YXJnZXQpICsgdmFyKC0tbmVzdGVkLXBvcG92ZXItb3ZlcmxhcCkpfS5jZS1wb3BvdmVyLS1vcGVuLWxlZnQgLmNlLXBvcG92ZXItLW5lc3RlZCAuY2UtcG9wb3Zlcl9fY29udGFpbmVyey0tcG9wb3Zlci1sZWZ0OiBjYWxjKC0xICogKHZhcigtLW5lc3RpbmctbGV2ZWwpICsgMSkgKiB2YXIoLS13aWR0aCkgKyAxMDAlKX0uY2UtcG9wb3Zlci1pdGVtLXNlcGFyYXRvcntwYWRkaW5nOjRweCAzcHh9LmNlLXBvcG92ZXItaXRlbS1zZXBhcmF0b3ItLWhpZGRlbntkaXNwbGF5Om5vbmV9LmNlLXBvcG92ZXItaXRlbS1zZXBhcmF0b3JfX2xpbmV7aGVpZ2h0OjFweDtiYWNrZ3JvdW5kOnZhcigtLWNvbG9yLWJvcmRlcik7d2lkdGg6MTAwJX0uY2UtcG9wb3Zlci1pdGVtLWh0bWwtLWhpZGRlbntkaXNwbGF5Om5vbmV9LmNlLXBvcG92ZXItaXRlbXstLWJvcmRlci1yYWRpdXM6IDZweDtib3JkZXItcmFkaXVzOnZhcigtLWJvcmRlci1yYWRpdXMpO2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7LXdlYmtpdC1ib3gtYWxpZ246Y2VudGVyOy1tcy1mbGV4LWFsaWduOmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXI7cGFkZGluZzp2YXIoLS1pdGVtLXBhZGRpbmcpO2NvbG9yOnZhcigtLWNvbG9yLXRleHQtcHJpbWFyeSk7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lO2JvcmRlcjpub25lO2JhY2tncm91bmQ6dHJhbnNwYXJlbnR9QG1lZGlhIChtYXgtd2lkdGg6IDY1MHB4KXsuY2UtcG9wb3Zlci1pdGVte3BhZGRpbmc6NHB4fX0uY2UtcG9wb3Zlci1pdGVtOm5vdCg6bGFzdC1vZi10eXBlKXttYXJnaW4tYm90dG9tOjFweH0uY2UtcG9wb3Zlci1pdGVtX19pY29ue3dpZHRoOjI2cHg7aGVpZ2h0OjI2cHg7ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDstd2Via2l0LWJveC1hbGlnbjpjZW50ZXI7LW1zLWZsZXgtYWxpZ246Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjstd2Via2l0LWJveC1wYWNrOmNlbnRlcjstbXMtZmxleC1wYWNrOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyfS5jZS1wb3BvdmVyLWl0ZW1fX2ljb24gc3Zne3dpZHRoOjIwcHg7aGVpZ2h0OjIwcHh9QG1lZGlhIChtYXgtd2lkdGg6IDY1MHB4KXsuY2UtcG9wb3Zlci1pdGVtX19pY29ue3dpZHRoOjM2cHg7aGVpZ2h0OjM2cHg7Ym9yZGVyLXJhZGl1czo4cHh9LmNlLXBvcG92ZXItaXRlbV9faWNvbiBzdmd7d2lkdGg6MjhweDtoZWlnaHQ6MjhweH19LmNlLXBvcG92ZXItaXRlbV9faWNvbi0tdG9vbHttYXJnaW4tcmlnaHQ6NHB4fS5jZS1wb3BvdmVyLWl0ZW1fX3RpdGxle2ZvbnQtc2l6ZToxNHB4O2xpbmUtaGVpZ2h0OjIwcHg7Zm9udC13ZWlnaHQ6NTAwO292ZXJmbG93OmhpZGRlbjt3aGl0ZS1zcGFjZTpub3dyYXA7dGV4dC1vdmVyZmxvdzplbGxpcHNpczttYXJnaW4tcmlnaHQ6YXV0b31AbWVkaWEgKG1heC13aWR0aDogNjUwcHgpey5jZS1wb3BvdmVyLWl0ZW1fX3RpdGxle2ZvbnQtc2l6ZToxNnB4fX0uY2UtcG9wb3Zlci1pdGVtX19zZWNvbmRhcnktdGl0bGV7Y29sb3I6dmFyKC0tY29sb3ItdGV4dC1zZWNvbmRhcnkpO2ZvbnQtc2l6ZToxMnB4O3doaXRlLXNwYWNlOm5vd3JhcDtsZXR0ZXItc3BhY2luZzotLjFlbTtwYWRkaW5nLXJpZ2h0OjVweDtvcGFjaXR5Oi42fUBtZWRpYSAobWF4LXdpZHRoOiA2NTBweCl7LmNlLXBvcG92ZXItaXRlbV9fc2Vjb25kYXJ5LXRpdGxle2Rpc3BsYXk6bm9uZX19LmNlLXBvcG92ZXItaXRlbS0tYWN0aXZle2JhY2tncm91bmQ6dmFyKC0tY29sb3ItYmFja2dyb3VuZC1pY29uLWFjdGl2ZSk7Y29sb3I6dmFyKC0tY29sb3ItdGV4dC1pY29uLWFjdGl2ZSl9LmNlLXBvcG92ZXItaXRlbS0tZGlzYWJsZWR7Y29sb3I6dmFyKC0tY29sb3ItdGV4dC1zZWNvbmRhcnkpO2N1cnNvcjpkZWZhdWx0O3BvaW50ZXItZXZlbnRzOm5vbmV9LmNlLXBvcG92ZXItaXRlbS0tZm9jdXNlZDpub3QoLmNlLXBvcG92ZXItaXRlbS0tbm8tZm9jdXMpe2JhY2tncm91bmQ6dmFyKC0tY29sb3ItYmFja2dyb3VuZC1pdGVtLWZvY3VzKSFpbXBvcnRhbnR9LmNlLXBvcG92ZXItaXRlbS0taGlkZGVue2Rpc3BsYXk6bm9uZX1AbWVkaWEgKGhvdmVyOiBob3Zlcil7LmNlLXBvcG92ZXItaXRlbTpob3ZlcntjdXJzb3I6cG9pbnRlcn0uY2UtcG9wb3Zlci1pdGVtOmhvdmVyOm5vdCguY2UtcG9wb3Zlci1pdGVtLS1uby1ob3Zlcil7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1jb2xvci1iYWNrZ3JvdW5kLWl0ZW0taG92ZXIpfX0uY2UtcG9wb3Zlci1pdGVtLS1jb25maXJtYXRpb257YmFja2dyb3VuZDp2YXIoLS1jb2xvci1iYWNrZ3JvdW5kLWl0ZW0tY29uZmlybSl9LmNlLXBvcG92ZXItaXRlbS0tY29uZmlybWF0aW9uIC5jZS1wb3BvdmVyLWl0ZW1fX3RpdGxlLC5jZS1wb3BvdmVyLWl0ZW0tLWNvbmZpcm1hdGlvbiAuY2UtcG9wb3Zlci1pdGVtX19pY29ue2NvbG9yOiNmZmZ9QG1lZGlhIChob3ZlcjogaG92ZXIpey5jZS1wb3BvdmVyLWl0ZW0tLWNvbmZpcm1hdGlvbjpub3QoLmNlLXBvcG92ZXItaXRlbS0tbm8taG92ZXIpOmhvdmVye2JhY2tncm91bmQ6dmFyKC0tY29sb3ItYmFja2dyb3VuZC1pdGVtLWNvbmZpcm0taG92ZXIpfX0uY2UtcG9wb3Zlci1pdGVtLS1jb25maXJtYXRpb246bm90KC5jZS1wb3BvdmVyLWl0ZW0tLW5vLWZvY3VzKS5jZS1wb3BvdmVyLWl0ZW0tLWZvY3VzZWR7YmFja2dyb3VuZDp2YXIoLS1jb2xvci1iYWNrZ3JvdW5kLWl0ZW0tY29uZmlybS1ob3ZlcikhaW1wb3J0YW50fUAtd2Via2l0LWtleWZyYW1lcyBwYW5lbFNob3dpbmd7MCV7b3BhY2l0eTowOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoLThweCkgc2NhbGUoLjkpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC04cHgpIHNjYWxlKC45KX03MCV7b3BhY2l0eToxOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoMnB4KTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgycHgpfXRvey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoMCl9fUBrZXlmcmFtZXMgcGFuZWxTaG93aW5nezAle29wYWNpdHk6MDstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKC04cHgpIHNjYWxlKC45KTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtOHB4KSBzY2FsZSguOSl9NzAle29wYWNpdHk6MTstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKDJweCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoMnB4KX10b3std2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKDApO3RyYW5zZm9ybTp0cmFuc2xhdGVZKDApfX1ALXdlYmtpdC1rZXlmcmFtZXMgcGFuZWxTaG93aW5nTW9iaWxlezAle29wYWNpdHk6MDstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKDE0cHgpIHNjYWxlKC45OCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoMTRweCkgc2NhbGUoLjk4KX03MCV7b3BhY2l0eToxOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTRweCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTRweCl9dG97LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgwKTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgwKX19QGtleWZyYW1lcyBwYW5lbFNob3dpbmdNb2JpbGV7MCV7b3BhY2l0eTowOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoMTRweCkgc2NhbGUoLjk4KTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgxNHB4KSBzY2FsZSguOTgpfTcwJXtvcGFjaXR5OjE7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgtNHB4KTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtNHB4KX10b3std2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKDApO3RyYW5zZm9ybTp0cmFuc2xhdGVZKDApfX0ud29iYmxley13ZWJraXQtYW5pbWF0aW9uLW5hbWU6d29iYmxlO2FuaW1hdGlvbi1uYW1lOndvYmJsZTstd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjouNHM7YW5pbWF0aW9uLWR1cmF0aW9uOi40c31ALXdlYmtpdC1rZXlmcmFtZXMgd29iYmxlezAley13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsMCwwKTt0cmFuc2Zvcm06dHJhbnNsYXRlWigwKX0xNSV7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlM2QoLTklLDAsMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKC05JSwwLDApfTMwJXstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGUzZCg5JSwwLDApO3RyYW5zZm9ybTp0cmFuc2xhdGUzZCg5JSwwLDApfTQ1JXstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGUzZCgtNCUsMCwwKTt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoLTQlLDAsMCl9NjAley13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDQlLDAsMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDQlLDAsMCl9NzUley13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZTNkKC0xJSwwLDApO3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgtMSUsMCwwKX10b3std2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLDAsMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVooMCl9fUBrZXlmcmFtZXMgd29iYmxlezAley13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsMCwwKTt0cmFuc2Zvcm06dHJhbnNsYXRlWigwKX0xNSV7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlM2QoLTklLDAsMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKC05JSwwLDApfTMwJXstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGUzZCg5JSwwLDApO3RyYW5zZm9ybTp0cmFuc2xhdGUzZCg5JSwwLDApfTQ1JXstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGUzZCgtNCUsMCwwKTt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoLTQlLDAsMCl9NjAley13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDQlLDAsMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDQlLDAsMCl9NzUley13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZTNkKC0xJSwwLDApO3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgtMSUsMCwwKX10b3std2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLDAsMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVooMCl9fS5jZS1wb3BvdmVyLWhlYWRlcnttYXJnaW4tYm90dG9tOjhweDttYXJnaW4tdG9wOjRweDtkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4Oy13ZWJraXQtYm94LWFsaWduOmNlbnRlcjstbXMtZmxleC1hbGlnbjpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyfS5jZS1wb3BvdmVyLWhlYWRlcl9fdGV4dHtmb250LXNpemU6MThweDtmb250LXdlaWdodDo2MDB9LmNlLXBvcG92ZXItaGVhZGVyX19iYWNrLWJ1dHRvbntib3JkZXI6MDtiYWNrZ3JvdW5kOnRyYW5zcGFyZW50O3dpZHRoOjM2cHg7aGVpZ2h0OjM2cHg7Y29sb3I6dmFyKC0tY29sb3ItdGV4dC1wcmltYXJ5KX0uY2UtcG9wb3Zlci1oZWFkZXJfX2JhY2stYnV0dG9uIHN2Z3tkaXNwbGF5OmJsb2NrO3dpZHRoOjI4cHg7aGVpZ2h0OjI4cHh9LmNlLXBvcG92ZXItLWlubGluZXstLWhlaWdodDogMzhweDstLWhlaWdodC1tb2JpbGU6IDQ2cHg7LS1jb250YWluZXItcGFkZGluZzogNHB4O3Bvc2l0aW9uOnJlbGF0aXZlfS5jZS1wb3BvdmVyLS1pbmxpbmUgLmNlLXBvcG92ZXJfX2N1c3RvbS1jb250ZW50e21hcmdpbi1ib3R0b206MH0uY2UtcG9wb3Zlci0taW5saW5lIC5jZS1wb3BvdmVyX19pdGVtc3tkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4fS5jZS1wb3BvdmVyLS1pbmxpbmUgLmNlLXBvcG92ZXJfX2NvbnRhaW5lcnstd2Via2l0LWJveC1vcmllbnQ6aG9yaXpvbnRhbDstd2Via2l0LWJveC1kaXJlY3Rpb246bm9ybWFsOy1tcy1mbGV4LWRpcmVjdGlvbjpyb3c7ZmxleC1kaXJlY3Rpb246cm93O3BhZGRpbmc6dmFyKC0tY29udGFpbmVyLXBhZGRpbmcpO2hlaWdodDp2YXIoLS1oZWlnaHQpO3RvcDowO21pbi13aWR0aDotd2Via2l0LW1heC1jb250ZW50O21pbi13aWR0aDotbW96LW1heC1jb250ZW50O21pbi13aWR0aDptYXgtY29udGVudDt3aWR0aDotd2Via2l0LW1heC1jb250ZW50O3dpZHRoOi1tb3otbWF4LWNvbnRlbnQ7d2lkdGg6bWF4LWNvbnRlbnQ7LXdlYmtpdC1hbmltYXRpb246bm9uZTthbmltYXRpb246bm9uZX1AbWVkaWEgKG1heC13aWR0aDogNjUwcHgpey5jZS1wb3BvdmVyLS1pbmxpbmUgLmNlLXBvcG92ZXJfX2NvbnRhaW5lcntoZWlnaHQ6dmFyKC0taGVpZ2h0LW1vYmlsZSk7cG9zaXRpb246YWJzb2x1dGV9fS5jZS1wb3BvdmVyLS1pbmxpbmUgLmNlLXBvcG92ZXItaXRlbS1zZXBhcmF0b3J7cGFkZGluZzowIDRweH0uY2UtcG9wb3Zlci0taW5saW5lIC5jZS1wb3BvdmVyLWl0ZW0tc2VwYXJhdG9yX19saW5le2hlaWdodDoxMDAlO3dpZHRoOjFweH0uY2UtcG9wb3Zlci0taW5saW5lIC5jZS1wb3BvdmVyLWl0ZW17Ym9yZGVyLXJhZGl1czo0cHg7cGFkZGluZzo0cHh9LmNlLXBvcG92ZXItLWlubGluZSAuY2UtcG9wb3Zlci1pdGVtX19pY29uLS10b29sey13ZWJraXQtYm94LXNoYWRvdzpub25lO2JveC1zaGFkb3c6bm9uZTtiYWNrZ3JvdW5kOnRyYW5zcGFyZW50O21hcmdpbi1yaWdodDowfS5jZS1wb3BvdmVyLS1pbmxpbmUgLmNlLXBvcG92ZXItaXRlbV9faWNvbnt3aWR0aDphdXRvO3dpZHRoOmluaXRpYWw7aGVpZ2h0OmF1dG87aGVpZ2h0OmluaXRpYWx9LmNlLXBvcG92ZXItLWlubGluZSAuY2UtcG9wb3Zlci1pdGVtX19pY29uIHN2Z3t3aWR0aDoyMHB4O2hlaWdodDoyMHB4fUBtZWRpYSAobWF4LXdpZHRoOiA2NTBweCl7LmNlLXBvcG92ZXItLWlubGluZSAuY2UtcG9wb3Zlci1pdGVtX19pY29uIHN2Z3t3aWR0aDoyOHB4O2hlaWdodDoyOHB4fX0uY2UtcG9wb3Zlci0taW5saW5lIC5jZS1wb3BvdmVyLWl0ZW06bm90KDpsYXN0LW9mLXR5cGUpe21hcmdpbi1ib3R0b206MDttYXJnaW4tYm90dG9tOmluaXRpYWx9LmNlLXBvcG92ZXItLWlubGluZSAuY2UtcG9wb3Zlci1pdGVtLWh0bWx7ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDstd2Via2l0LWJveC1hbGlnbjpjZW50ZXI7LW1zLWZsZXgtYWxpZ246Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcn0uY2UtcG9wb3Zlci0taW5saW5lIC5jZS1wb3BvdmVyLWl0ZW1fX2ljb24tLWNoZXZyb24tcmlnaHR7LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDkwZGVnKTt0cmFuc2Zvcm06cm90YXRlKDkwZGVnKX0uY2UtcG9wb3Zlci0taW5saW5lIC5jZS1wb3BvdmVyLS1uZXN0ZWQtbGV2ZWwtMSAuY2UtcG9wb3Zlcl9fY29udGFpbmVyey0tb2Zmc2V0OiAzcHg7bGVmdDowO3RvcDpjYWxjKHZhcigtLWhlaWdodCkgKyB2YXIoLS1vZmZzZXQpKX1AbWVkaWEgKG1heC13aWR0aDogNjUwcHgpey5jZS1wb3BvdmVyLS1pbmxpbmUgLmNlLXBvcG92ZXItLW5lc3RlZC1sZXZlbC0xIC5jZS1wb3BvdmVyX19jb250YWluZXJ7dG9wOmNhbGModmFyKC0taGVpZ2h0LW1vYmlsZSkgKyB2YXIoLS1vZmZzZXQpKX19LmNlLXBvcG92ZXItLWlubGluZSAuY2UtcG9wb3Zlci0tbmVzdGVkIC5jZS1wb3BvdmVyX19jb250YWluZXJ7bWluLXdpZHRoOnZhcigtLXdpZHRoKTt3aWR0aDp2YXIoLS13aWR0aCk7aGVpZ2h0Oi13ZWJraXQtZml0LWNvbnRlbnQ7aGVpZ2h0Oi1tb3otZml0LWNvbnRlbnQ7aGVpZ2h0OmZpdC1jb250ZW50O3BhZGRpbmc6NnB4Oy13ZWJraXQtYm94LW9yaWVudDp2ZXJ0aWNhbDstd2Via2l0LWJveC1kaXJlY3Rpb246bm9ybWFsOy1tcy1mbGV4LWRpcmVjdGlvbjpjb2x1bW47ZmxleC1kaXJlY3Rpb246Y29sdW1ufS5jZS1wb3BvdmVyLS1pbmxpbmUgLmNlLXBvcG92ZXItLW5lc3RlZCAuY2UtcG9wb3Zlcl9faXRlbXN7ZGlzcGxheTpibG9jazt3aWR0aDoxMDAlfS5jZS1wb3BvdmVyLS1pbmxpbmUgLmNlLXBvcG92ZXItLW5lc3RlZCAuY2UtcG9wb3Zlci1pdGVte2JvcmRlci1yYWRpdXM6NnB4O3BhZGRpbmc6M3B4fUBtZWRpYSAobWF4LXdpZHRoOiA2NTBweCl7LmNlLXBvcG92ZXItLWlubGluZSAuY2UtcG9wb3Zlci0tbmVzdGVkIC5jZS1wb3BvdmVyLWl0ZW17cGFkZGluZzo0cHh9fS5jZS1wb3BvdmVyLS1pbmxpbmUgLmNlLXBvcG92ZXItLW5lc3RlZCAuY2UtcG9wb3Zlci1pdGVtX19pY29uLS10b29se21hcmdpbi1yaWdodDo0cHh9LmNlLXBvcG92ZXItLWlubGluZSAuY2UtcG9wb3Zlci0tbmVzdGVkIC5jZS1wb3BvdmVyLWl0ZW1fX2ljb257d2lkdGg6MjZweDtoZWlnaHQ6MjZweH0uY2UtcG9wb3Zlci0taW5saW5lIC5jZS1wb3BvdmVyLS1uZXN0ZWQgLmNlLXBvcG92ZXItaXRlbS1zZXBhcmF0b3J7cGFkZGluZzo0cHggM3B4fS5jZS1wb3BvdmVyLS1pbmxpbmUgLmNlLXBvcG92ZXItLW5lc3RlZCAuY2UtcG9wb3Zlci1pdGVtLXNlcGFyYXRvcl9fbGluZXt3aWR0aDoxMDAlO2hlaWdodDoxcHh9LmNvZGV4LWVkaXRvciBbZGF0YS1wbGFjZWhvbGRlcl06ZW1wdHk6YmVmb3JlLC5jb2RleC1lZGl0b3IgW2RhdGEtcGxhY2Vob2xkZXJdW2RhdGEtZW1wdHk9dHJ1ZV06YmVmb3Jle3BvaW50ZXItZXZlbnRzOm5vbmU7Y29sb3I6IzcwNzY4NDtjdXJzb3I6dGV4dDtjb250ZW50OmF0dHIoZGF0YS1wbGFjZWhvbGRlcil9LmNvZGV4LWVkaXRvciBbZGF0YS1wbGFjZWhvbGRlci1hY3RpdmVdOmVtcHR5OmJlZm9yZSwuY29kZXgtZWRpdG9yIFtkYXRhLXBsYWNlaG9sZGVyLWFjdGl2ZV1bZGF0YS1lbXB0eT10cnVlXTpiZWZvcmV7cG9pbnRlci1ldmVudHM6bm9uZTtjb2xvcjojNzA3Njg0O2N1cnNvcjp0ZXh0fS5jb2RleC1lZGl0b3IgW2RhdGEtcGxhY2Vob2xkZXItYWN0aXZlXTplbXB0eTpmb2N1czpiZWZvcmUsLmNvZGV4LWVkaXRvciBbZGF0YS1wbGFjZWhvbGRlci1hY3RpdmVdW2RhdGEtZW1wdHk9dHJ1ZV06Zm9jdXM6YmVmb3Jle2NvbnRlbnQ6YXR0cihkYXRhLXBsYWNlaG9sZGVyLWFjdGl2ZSl9XG5gLCB3cyA9IDE4MDtcbmNsYXNzIHhzIGV4dGVuZHMgeSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMuaXNNb2JpbGUgPSAhMSwgdGhpcy5jb250ZW50UmVjdENhY2hlID0gdm9pZCAwLCB0aGlzLnJlc2l6ZURlYm91bmNlciA9IGt0KCgpID0+IHtcbiAgICAgIHRoaXMud2luZG93UmVzaXplKCk7XG4gICAgfSwgMjAwKTtcbiAgfVxuICAvKipcbiAgICogRWRpdG9yLmpzIFVJIENTUyBjbGFzcyBuYW1lc1xuICAgKlxuICAgKiBAcmV0dXJucyB7e2VkaXRvcldyYXBwZXI6IHN0cmluZywgZWRpdG9yWm9uZTogc3RyaW5nfX1cbiAgICovXG4gIGdldCBDU1MoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVkaXRvcldyYXBwZXI6IFwiY29kZXgtZWRpdG9yXCIsXG4gICAgICBlZGl0b3JXcmFwcGVyTmFycm93OiBcImNvZGV4LWVkaXRvci0tbmFycm93XCIsXG4gICAgICBlZGl0b3Jab25lOiBcImNvZGV4LWVkaXRvcl9fcmVkYWN0b3JcIixcbiAgICAgIGVkaXRvclpvbmVIaWRkZW46IFwiY29kZXgtZWRpdG9yX19yZWRhY3Rvci0taGlkZGVuXCIsXG4gICAgICBlZGl0b3JFbXB0eTogXCJjb2RleC1lZGl0b3ItLWVtcHR5XCIsXG4gICAgICBlZGl0b3JSdGxGaXg6IFwiY29kZXgtZWRpdG9yLS1ydGxcIlxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBXaWR0aCBvZiBjZW50ZXIgY29sdW1uIG9mIEVkaXRvclxuICAgKlxuICAgKiBAcmV0dXJucyB7RE9NUmVjdH1cbiAgICovXG4gIGdldCBjb250ZW50UmVjdCgpIHtcbiAgICBpZiAodGhpcy5jb250ZW50UmVjdENhY2hlKVxuICAgICAgcmV0dXJuIHRoaXMuY29udGVudFJlY3RDYWNoZTtcbiAgICBjb25zdCBlID0gdGhpcy5ub2Rlcy53cmFwcGVyLnF1ZXJ5U2VsZWN0b3IoYC4ke0QuQ1NTLmNvbnRlbnR9YCk7XG4gICAgcmV0dXJuIGUgPyAodGhpcy5jb250ZW50UmVjdENhY2hlID0gZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgdGhpcy5jb250ZW50UmVjdENhY2hlKSA6IHtcbiAgICAgIHdpZHRoOiA2NTAsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgcmlnaHQ6IDBcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBNYWtpbmcgbWFpbiBpbnRlcmZhY2VcbiAgICovXG4gIGFzeW5jIHByZXBhcmUoKSB7XG4gICAgdGhpcy5zZXRJc01vYmlsZSgpLCB0aGlzLm1ha2UoKSwgdGhpcy5sb2FkU3R5bGVzKCk7XG4gIH1cbiAgLyoqXG4gICAqIFRvZ2dsZSByZWFkLW9ubHkgc3RhdGVcbiAgICpcbiAgICogSWYgcmVhZE9ubHkgaXMgdHJ1ZTpcbiAgICogIC0gcmVtb3ZlcyBhbGwgbGlzdGVuZXJzIGZyb20gbWFpbiBVSSBtb2R1bGUgZWxlbWVudHNcbiAgICpcbiAgICogaWYgcmVhZE9ubHkgaXMgZmFsc2U6XG4gICAqICAtIGVuYWJsZXMgYWxsIGxpc3RlbmVycyB0byBVSSBtb2R1bGUgZWxlbWVudHNcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSByZWFkT25seUVuYWJsZWQgLSBcInJlYWQgb25seVwiIHN0YXRlXG4gICAqL1xuICB0b2dnbGVSZWFkT25seShlKSB7XG4gICAgZSA/IHRoaXMuZGlzYWJsZU1vZHVsZUJpbmRpbmdzKCkgOiB3aW5kb3cucmVxdWVzdElkbGVDYWxsYmFjaygoKSA9PiB7XG4gICAgICB0aGlzLmVuYWJsZU1vZHVsZUJpbmRpbmdzKCk7XG4gICAgfSwge1xuICAgICAgdGltZW91dDogMmUzXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIEVkaXRvciBpcyBlbXB0eSBhbmQgc2V0IENTUyBjbGFzcyB0byB3cmFwcGVyXG4gICAqL1xuICBjaGVja0VtcHRpbmVzcygpIHtcbiAgICBjb25zdCB7IEJsb2NrTWFuYWdlcjogZSB9ID0gdGhpcy5FZGl0b3I7XG4gICAgdGhpcy5ub2Rlcy53cmFwcGVyLmNsYXNzTGlzdC50b2dnbGUodGhpcy5DU1MuZWRpdG9yRW1wdHksIGUuaXNFZGl0b3JFbXB0eSk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIG9uZSBvZiBUb29sYmFyIGlzIG9wZW5lZFxuICAgKiBVc2VkIHRvIHByZXZlbnQgZ2xvYmFsIGtleWRvd25zIChmb3IgZXhhbXBsZSwgRW50ZXIpIGNvbmZsaWN0cyB3aXRoIEVudGVyLW9uLXRvb2xiYXJcbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgc29tZVRvb2xiYXJPcGVuZWQoKSB7XG4gICAgY29uc3QgeyBUb29sYmFyOiBlLCBCbG9ja1NldHRpbmdzOiB0LCBJbmxpbmVUb29sYmFyOiBvIH0gPSB0aGlzLkVkaXRvcjtcbiAgICByZXR1cm4gISEodC5vcGVuZWQgfHwgby5vcGVuZWQgfHwgZS50b29sYm94Lm9wZW5lZCk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGZvciBzb21lIEZsaXBwZXItYnV0dG9ucyBpcyB1bmRlciBmb2N1c1xuICAgKi9cbiAgZ2V0IHNvbWVGbGlwcGVyQnV0dG9uRm9jdXNlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5FZGl0b3IuVG9vbGJhci50b29sYm94Lmhhc0ZvY3VzKCkgPyAhMCA6IE9iamVjdC5lbnRyaWVzKHRoaXMuRWRpdG9yKS5maWx0ZXIoKFtlLCB0XSkgPT4gdC5mbGlwcGVyIGluc3RhbmNlb2YgcmUpLnNvbWUoKFtlLCB0XSkgPT4gdC5mbGlwcGVyLmhhc0ZvY3VzKCkpO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhbiBlZGl0b3JgcyBVSVxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLm5vZGVzLmhvbGRlci5pbm5lckhUTUwgPSBcIlwiO1xuICB9XG4gIC8qKlxuICAgKiBDbG9zZSBhbGwgRWRpdG9yJ3MgdG9vbGJhcnNcbiAgICovXG4gIGNsb3NlQWxsVG9vbGJhcnMoKSB7XG4gICAgY29uc3QgeyBUb29sYmFyOiBlLCBCbG9ja1NldHRpbmdzOiB0LCBJbmxpbmVUb29sYmFyOiBvIH0gPSB0aGlzLkVkaXRvcjtcbiAgICB0LmNsb3NlKCksIG8uY2xvc2UoKSwgZS50b29sYm94LmNsb3NlKCk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGZvciBtb2JpbGUgbW9kZSBhbmQgc2F2ZSB0aGUgcmVzdWx0XG4gICAqL1xuICBzZXRJc01vYmlsZSgpIHtcbiAgICBjb25zdCBlID0gd2luZG93LmlubmVyV2lkdGggPCBBdDtcbiAgICBlICE9PSB0aGlzLmlzTW9iaWxlICYmIHRoaXMuZXZlbnRzRGlzcGF0Y2hlci5lbWl0KHhlLCB7XG4gICAgICBpc0VuYWJsZWQ6IHRoaXMuaXNNb2JpbGVcbiAgICB9KSwgdGhpcy5pc01vYmlsZSA9IGU7XG4gIH1cbiAgLyoqXG4gICAqIE1ha2VzIEVkaXRvci5qcyBpbnRlcmZhY2VcbiAgICovXG4gIG1ha2UoKSB7XG4gICAgdGhpcy5ub2Rlcy5ob2xkZXIgPSBkLmdldEhvbGRlcih0aGlzLmNvbmZpZy5ob2xkZXIpLCB0aGlzLm5vZGVzLndyYXBwZXIgPSBkLm1ha2UoXCJkaXZcIiwgW1xuICAgICAgdGhpcy5DU1MuZWRpdG9yV3JhcHBlcixcbiAgICAgIC4uLnRoaXMuaXNSdGwgPyBbdGhpcy5DU1MuZWRpdG9yUnRsRml4XSA6IFtdXG4gICAgXSksIHRoaXMubm9kZXMucmVkYWN0b3IgPSBkLm1ha2UoXCJkaXZcIiwgdGhpcy5DU1MuZWRpdG9yWm9uZSksIHRoaXMubm9kZXMuaG9sZGVyLm9mZnNldFdpZHRoIDwgdGhpcy5jb250ZW50UmVjdC53aWR0aCAmJiB0aGlzLm5vZGVzLndyYXBwZXIuY2xhc3NMaXN0LmFkZCh0aGlzLkNTUy5lZGl0b3JXcmFwcGVyTmFycm93KSwgdGhpcy5ub2Rlcy5yZWRhY3Rvci5zdHlsZS5wYWRkaW5nQm90dG9tID0gdGhpcy5jb25maWcubWluSGVpZ2h0ICsgXCJweFwiLCB0aGlzLm5vZGVzLndyYXBwZXIuYXBwZW5kQ2hpbGQodGhpcy5ub2Rlcy5yZWRhY3RvciksIHRoaXMubm9kZXMuaG9sZGVyLmFwcGVuZENoaWxkKHRoaXMubm9kZXMud3JhcHBlcik7XG4gIH1cbiAgLyoqXG4gICAqIEFwcGVuZHMgQ1NTXG4gICAqL1xuICBsb2FkU3R5bGVzKCkge1xuICAgIGNvbnN0IGUgPSBcImVkaXRvci1qcy1zdHlsZXNcIjtcbiAgICBpZiAoZC5nZXQoZSkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IGQubWFrZShcInN0eWxlXCIsIG51bGwsIHtcbiAgICAgIGlkOiBlLFxuICAgICAgdGV4dENvbnRlbnQ6IHZzLnRvU3RyaW5nKClcbiAgICB9KTtcbiAgICB0aGlzLmNvbmZpZy5zdHlsZSAmJiAhWCh0aGlzLmNvbmZpZy5zdHlsZSkgJiYgdGhpcy5jb25maWcuc3R5bGUubm9uY2UgJiYgdC5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLCB0aGlzLmNvbmZpZy5zdHlsZS5ub25jZSksIGQucHJlcGVuZChkb2N1bWVudC5oZWFkLCB0KTtcbiAgfVxuICAvKipcbiAgICogQmluZCBldmVudHMgb24gdGhlIEVkaXRvci5qcyBpbnRlcmZhY2VcbiAgICovXG4gIGVuYWJsZU1vZHVsZUJpbmRpbmdzKCkge1xuICAgIHRoaXMucmVhZE9ubHlNdXRhYmxlTGlzdGVuZXJzLm9uKHRoaXMubm9kZXMucmVkYWN0b3IsIFwiY2xpY2tcIiwgKHQpID0+IHtcbiAgICAgIHRoaXMucmVkYWN0b3JDbGlja2VkKHQpO1xuICAgIH0sICExKSwgdGhpcy5yZWFkT25seU11dGFibGVMaXN0ZW5lcnMub24odGhpcy5ub2Rlcy5yZWRhY3RvciwgXCJtb3VzZWRvd25cIiwgKHQpID0+IHtcbiAgICAgIHRoaXMuZG9jdW1lbnRUb3VjaGVkKHQpO1xuICAgIH0sIHtcbiAgICAgIGNhcHR1cmU6ICEwLFxuICAgICAgcGFzc2l2ZTogITBcbiAgICB9KSwgdGhpcy5yZWFkT25seU11dGFibGVMaXN0ZW5lcnMub24odGhpcy5ub2Rlcy5yZWRhY3RvciwgXCJ0b3VjaHN0YXJ0XCIsICh0KSA9PiB7XG4gICAgICB0aGlzLmRvY3VtZW50VG91Y2hlZCh0KTtcbiAgICB9LCB7XG4gICAgICBjYXB0dXJlOiAhMCxcbiAgICAgIHBhc3NpdmU6ICEwXG4gICAgfSksIHRoaXMucmVhZE9ubHlNdXRhYmxlTGlzdGVuZXJzLm9uKGRvY3VtZW50LCBcImtleWRvd25cIiwgKHQpID0+IHtcbiAgICAgIHRoaXMuZG9jdW1lbnRLZXlkb3duKHQpO1xuICAgIH0sICEwKSwgdGhpcy5yZWFkT25seU11dGFibGVMaXN0ZW5lcnMub24oZG9jdW1lbnQsIFwibW91c2Vkb3duXCIsICh0KSA9PiB7XG4gICAgICB0aGlzLmRvY3VtZW50Q2xpY2tlZCh0KTtcbiAgICB9LCAhMCk7XG4gICAgY29uc3QgZSA9IGt0KCgpID0+IHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlZCgpO1xuICAgIH0sIHdzKTtcbiAgICB0aGlzLnJlYWRPbmx5TXV0YWJsZUxpc3RlbmVycy5vbihkb2N1bWVudCwgXCJzZWxlY3Rpb25jaGFuZ2VcIiwgZSwgITApLCB0aGlzLnJlYWRPbmx5TXV0YWJsZUxpc3RlbmVycy5vbih3aW5kb3csIFwicmVzaXplXCIsICgpID0+IHtcbiAgICAgIHRoaXMucmVzaXplRGVib3VuY2VyKCk7XG4gICAgfSwge1xuICAgICAgcGFzc2l2ZTogITBcbiAgICB9KSwgdGhpcy53YXRjaEJsb2NrSG92ZXJlZEV2ZW50cygpLCB0aGlzLmVuYWJsZUlucHV0c0VtcHR5TWFyaygpO1xuICB9XG4gIC8qKlxuICAgKiBMaXN0ZW4gcmVkYWN0b3IgbW91c2Vtb3ZlIHRvIGVtaXQgJ2Jsb2NrLWhvdmVyZWQnIGV2ZW50XG4gICAqL1xuICB3YXRjaEJsb2NrSG92ZXJlZEV2ZW50cygpIHtcbiAgICBsZXQgZTtcbiAgICB0aGlzLnJlYWRPbmx5TXV0YWJsZUxpc3RlbmVycy5vbih0aGlzLm5vZGVzLnJlZGFjdG9yLCBcIm1vdXNlbW92ZVwiLCBWZSgodCkgPT4ge1xuICAgICAgY29uc3QgbyA9IHQudGFyZ2V0LmNsb3Nlc3QoXCIuY2UtYmxvY2tcIik7XG4gICAgICB0aGlzLkVkaXRvci5CbG9ja1NlbGVjdGlvbi5hbnlCbG9ja1NlbGVjdGVkIHx8IG8gJiYgZSAhPT0gbyAmJiAoZSA9IG8sIHRoaXMuZXZlbnRzRGlzcGF0Y2hlci5lbWl0KG9vLCB7XG4gICAgICAgIGJsb2NrOiB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuZ2V0QmxvY2tCeUNoaWxkTm9kZShvKVxuICAgICAgfSkpO1xuICAgIH0sIDIwKSwge1xuICAgICAgcGFzc2l2ZTogITBcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogVW5iaW5kIGV2ZW50cyBvbiB0aGUgRWRpdG9yLmpzIGludGVyZmFjZVxuICAgKi9cbiAgZGlzYWJsZU1vZHVsZUJpbmRpbmdzKCkge1xuICAgIHRoaXMucmVhZE9ubHlNdXRhYmxlTGlzdGVuZXJzLmNsZWFyQWxsKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJlc2l6ZSB3aW5kb3cgaGFuZGxlclxuICAgKi9cbiAgd2luZG93UmVzaXplKCkge1xuICAgIHRoaXMuY29udGVudFJlY3RDYWNoZSA9IG51bGwsIHRoaXMuc2V0SXNNb2JpbGUoKTtcbiAgfVxuICAvKipcbiAgICogQWxsIGtleWRvd25zIG9uIGRvY3VtZW50XG4gICAqXG4gICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnQgLSBrZXlib2FyZCBldmVudFxuICAgKi9cbiAgZG9jdW1lbnRLZXlkb3duKGUpIHtcbiAgICBzd2l0Y2ggKGUua2V5Q29kZSkge1xuICAgICAgY2FzZSB3LkVOVEVSOlxuICAgICAgICB0aGlzLmVudGVyUHJlc3NlZChlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHcuQkFDS1NQQUNFOlxuICAgICAgY2FzZSB3LkRFTEVURTpcbiAgICAgICAgdGhpcy5iYWNrc3BhY2VQcmVzc2VkKGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugdy5FU0M6XG4gICAgICAgIHRoaXMuZXNjYXBlUHJlc3NlZChlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmRlZmF1bHRCZWhhdmlvdXIoZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSWdub3JlIGFsbCBvdGhlciBkb2N1bWVudCdzIGtleWRvd24gZXZlbnRzXG4gICAqXG4gICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnQgLSBrZXlib2FyZCBldmVudFxuICAgKi9cbiAgZGVmYXVsdEJlaGF2aW91cihlKSB7XG4gICAgY29uc3QgeyBjdXJyZW50QmxvY2s6IHQgfSA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlciwgbyA9IGUudGFyZ2V0LmNsb3Nlc3QoYC4ke3RoaXMuQ1NTLmVkaXRvcldyYXBwZXJ9YCksIGkgPSBlLmFsdEtleSB8fCBlLmN0cmxLZXkgfHwgZS5tZXRhS2V5IHx8IGUuc2hpZnRLZXk7XG4gICAgaWYgKHQgIT09IHZvaWQgMCAmJiBvID09PSBudWxsKSB7XG4gICAgICB0aGlzLkVkaXRvci5CbG9ja0V2ZW50cy5rZXlkb3duKGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBvIHx8IHQgJiYgaSB8fCAodGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLnVuc2V0Q3VycmVudEJsb2NrKCksIHRoaXMuRWRpdG9yLlRvb2xiYXIuY2xvc2UoKSk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnQgLSBrZXlib2FyZCBldmVudFxuICAgKi9cbiAgYmFja3NwYWNlUHJlc3NlZChlKSB7XG4gICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IHQsIEJsb2NrU2VsZWN0aW9uOiBvLCBDYXJldDogaSB9ID0gdGhpcy5FZGl0b3I7XG4gICAgaWYgKG8uYW55QmxvY2tTZWxlY3RlZCAmJiAhYi5pc1NlbGVjdGlvbkV4aXN0cykge1xuICAgICAgY29uc3QgcyA9IHQucmVtb3ZlU2VsZWN0ZWRCbG9ja3MoKSwgciA9IHQuaW5zZXJ0RGVmYXVsdEJsb2NrQXRJbmRleChzLCAhMCk7XG4gICAgICBpLnNldFRvQmxvY2sociwgaS5wb3NpdGlvbnMuU1RBUlQpLCBvLmNsZWFyU2VsZWN0aW9uKGUpLCBlLnByZXZlbnREZWZhdWx0KCksIGUuc3RvcFByb3BhZ2F0aW9uKCksIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBFc2NhcGUgcHJlc3NlZFxuICAgKiBJZiBzb21lIG9mIFRvb2xiYXIgY29tcG9uZW50cyBhcmUgb3BlbmVkLCB0aGVuIGNsb3NlIGl0IG90aGVyd2lzZSBjbG9zZSBUb29sYmFyXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gZXNjYXBlIGtleWRvd24gZXZlbnRcbiAgICovXG4gIGVzY2FwZVByZXNzZWQoZSkge1xuICAgIHRoaXMuRWRpdG9yLkJsb2NrU2VsZWN0aW9uLmNsZWFyU2VsZWN0aW9uKGUpLCB0aGlzLkVkaXRvci5Ub29sYmFyLnRvb2xib3gub3BlbmVkID8gKHRoaXMuRWRpdG9yLlRvb2xiYXIudG9vbGJveC5jbG9zZSgpLCB0aGlzLkVkaXRvci5DYXJldC5zZXRUb0Jsb2NrKHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5jdXJyZW50QmxvY2ssIHRoaXMuRWRpdG9yLkNhcmV0LnBvc2l0aW9ucy5FTkQpKSA6IHRoaXMuRWRpdG9yLkJsb2NrU2V0dGluZ3Mub3BlbmVkID8gdGhpcy5FZGl0b3IuQmxvY2tTZXR0aW5ncy5jbG9zZSgpIDogdGhpcy5FZGl0b3IuSW5saW5lVG9vbGJhci5vcGVuZWQgPyB0aGlzLkVkaXRvci5JbmxpbmVUb29sYmFyLmNsb3NlKCkgOiB0aGlzLkVkaXRvci5Ub29sYmFyLmNsb3NlKCk7XG4gIH1cbiAgLyoqXG4gICAqIEVudGVyIHByZXNzZWQgb24gZG9jdW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudCAtIGtleWJvYXJkIGV2ZW50XG4gICAqL1xuICBlbnRlclByZXNzZWQoZSkge1xuICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiB0LCBCbG9ja1NlbGVjdGlvbjogbyB9ID0gdGhpcy5FZGl0b3I7XG4gICAgaWYgKHRoaXMuc29tZVRvb2xiYXJPcGVuZWQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgaSA9IHQuY3VycmVudEJsb2NrSW5kZXggPj0gMDtcbiAgICBpZiAoby5hbnlCbG9ja1NlbGVjdGVkICYmICFiLmlzU2VsZWN0aW9uRXhpc3RzKSB7XG4gICAgICBvLmNsZWFyU2VsZWN0aW9uKGUpLCBlLnByZXZlbnREZWZhdWx0KCksIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCksIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5zb21lVG9vbGJhck9wZW5lZCAmJiBpICYmIGUudGFyZ2V0LnRhZ05hbWUgPT09IFwiQk9EWVwiKSB7XG4gICAgICBjb25zdCBzID0gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmluc2VydCgpO1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLkVkaXRvci5DYXJldC5zZXRUb0Jsb2NrKHMpLCB0aGlzLkVkaXRvci5Ub29sYmFyLm1vdmVBbmRPcGVuKHMpO1xuICAgIH1cbiAgICB0aGlzLkVkaXRvci5CbG9ja1NlbGVjdGlvbi5jbGVhclNlbGVjdGlvbihlKTtcbiAgfVxuICAvKipcbiAgICogQWxsIGNsaWNrcyBvbiBkb2N1bWVudFxuICAgKlxuICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50IC0gQ2xpY2sgZXZlbnRcbiAgICovXG4gIGRvY3VtZW50Q2xpY2tlZChlKSB7XG4gICAgdmFyIGwsIGE7XG4gICAgaWYgKCFlLmlzVHJ1c3RlZClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0gZS50YXJnZXQ7XG4gICAgdGhpcy5ub2Rlcy5ob2xkZXIuY29udGFpbnModCkgfHwgYi5pc0F0RWRpdG9yIHx8ICh0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIudW5zZXRDdXJyZW50QmxvY2soKSwgdGhpcy5FZGl0b3IuVG9vbGJhci5jbG9zZSgpKTtcbiAgICBjb25zdCBpID0gKGwgPSB0aGlzLkVkaXRvci5CbG9ja1NldHRpbmdzLm5vZGVzLndyYXBwZXIpID09IG51bGwgPyB2b2lkIDAgOiBsLmNvbnRhaW5zKHQpLCBzID0gKGEgPSB0aGlzLkVkaXRvci5Ub29sYmFyLm5vZGVzLnNldHRpbmdzVG9nZ2xlcikgPT0gbnVsbCA/IHZvaWQgMCA6IGEuY29udGFpbnModCksIHIgPSBpIHx8IHM7XG4gICAgaWYgKHRoaXMuRWRpdG9yLkJsb2NrU2V0dGluZ3Mub3BlbmVkICYmICFyKSB7XG4gICAgICB0aGlzLkVkaXRvci5CbG9ja1NldHRpbmdzLmNsb3NlKCk7XG4gICAgICBjb25zdCBjID0gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmdldEJsb2NrQnlDaGlsZE5vZGUodCk7XG4gICAgICB0aGlzLkVkaXRvci5Ub29sYmFyLm1vdmVBbmRPcGVuKGMpO1xuICAgIH1cbiAgICB0aGlzLkVkaXRvci5CbG9ja1NlbGVjdGlvbi5jbGVhclNlbGVjdGlvbihlKTtcbiAgfVxuICAvKipcbiAgICogRmlyc3QgdG91Y2ggb24gZWRpdG9yXG4gICAqIEZpcmVkIGJlZm9yZSBjbGlja1xuICAgKlxuICAgKiBVc2VkIHRvIGNoYW5nZSBjdXJyZW50IGJsb2NrIOKAlCB3ZSBuZWVkIHRvIGRvIGl0IGJlZm9yZSAnc2VsZWN0aW9uQ2hhbmdlJyBldmVudC5cbiAgICogQWxzbzpcbiAgICogLSBNb3ZlIGFuZCBzaG93IHRoZSBUb29sYmFyXG4gICAqIC0gU2V0IGEgQ2FyZXRcbiAgICpcbiAgICogQHBhcmFtIHtNb3VzZUV2ZW50IHwgVG91Y2hFdmVudH0gZXZlbnQgLSB0b3VjaCBvciBtb3VzZSBldmVudFxuICAgKi9cbiAgZG9jdW1lbnRUb3VjaGVkKGUpIHtcbiAgICBsZXQgdCA9IGUudGFyZ2V0O1xuICAgIGlmICh0ID09PSB0aGlzLm5vZGVzLnJlZGFjdG9yKSB7XG4gICAgICBjb25zdCBvID0gZSBpbnN0YW5jZW9mIE1vdXNlRXZlbnQgPyBlLmNsaWVudFggOiBlLnRvdWNoZXNbMF0uY2xpZW50WCwgaSA9IGUgaW5zdGFuY2VvZiBNb3VzZUV2ZW50ID8gZS5jbGllbnRZIDogZS50b3VjaGVzWzBdLmNsaWVudFk7XG4gICAgICB0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChvLCBpKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5zZXRDdXJyZW50QmxvY2tCeUNoaWxkTm9kZSh0KTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHRoaXMuRWRpdG9yLlJlY3RhbmdsZVNlbGVjdGlvbi5pc1JlY3RBY3RpdmF0ZWQoKSB8fCB0aGlzLkVkaXRvci5DYXJldC5zZXRUb1RoZUxhc3RCbG9jaygpO1xuICAgIH1cbiAgICB0aGlzLkVkaXRvci5Ub29sYmFyLm1vdmVBbmRPcGVuKCk7XG4gIH1cbiAgLyoqXG4gICAqIEFsbCBjbGlja3Mgb24gdGhlIHJlZGFjdG9yIHpvbmVcbiAgICpcbiAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudCAtIGNsaWNrIGV2ZW50XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAtIEJ5IGNsaWNrcyBvbiB0aGUgRWRpdG9yJ3MgYm90dG9tIHpvbmU6XG4gICAqICAgICAgLSBpZiBsYXN0IEJsb2NrIGlzIGVtcHR5LCBzZXQgYSBDYXJldCB0byB0aGlzXG4gICAqICAgICAgLSBvdGhlcndpc2UsIGFkZCBhIG5ldyBlbXB0eSBCbG9jayBhbmQgc2V0IGEgQ2FyZXQgdG8gdGhhdFxuICAgKi9cbiAgcmVkYWN0b3JDbGlja2VkKGUpIHtcbiAgICBpZiAoIWIuaXNDb2xsYXBzZWQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IGUudGFyZ2V0LCBvID0gZS5tZXRhS2V5IHx8IGUuY3RybEtleTtcbiAgICBpZiAoZC5pc0FuY2hvcih0KSAmJiBvKSB7XG4gICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpLCBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgY29uc3QgaSA9IHQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSwgcyA9IFNvKGkpO1xuICAgICAgTW8ocyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucHJvY2Vzc0JvdHRvbVpvbmVDbGljayhlKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgdXNlciBjbGlja3Mgb24gdGhlIEVkaXRvcidzIGJvdHRvbSB6b25lOlxuICAgKiAgLSBzZXQgY2FyZXQgdG8gdGhlIGxhc3QgYmxvY2tcbiAgICogIC0gb3IgYWRkIG5ldyBlbXB0eSBibG9ja1xuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgLSBjbGljayBldmVudFxuICAgKi9cbiAgcHJvY2Vzc0JvdHRvbVpvbmVDbGljayhlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5nZXRCbG9ja0J5SW5kZXgoLTEpLCBvID0gZC5vZmZzZXQodC5ob2xkZXIpLmJvdHRvbSwgaSA9IGUucGFnZVksIHsgQmxvY2tTZWxlY3Rpb246IHMgfSA9IHRoaXMuRWRpdG9yO1xuICAgIGlmIChlLnRhcmdldCBpbnN0YW5jZW9mIEVsZW1lbnQgJiYgZS50YXJnZXQuaXNFcXVhbE5vZGUodGhpcy5ub2Rlcy5yZWRhY3RvcikgJiYgLyoqXG4gICAgKiBJZiB0aGVyZSBpcyBjcm9zcyBibG9jayBzZWxlY3Rpb24gc3RhcnRlZCwgdGFyZ2V0IHdpbGwgYmUgZXF1YWwgdG8gcmVkYWN0b3Igc28gd2UgbmVlZCBhZGRpdGlvbmFsIGNoZWNrXG4gICAgKi9cbiAgICAhcy5hbnlCbG9ja1NlbGVjdGVkICYmIC8qKlxuICAgICogUHJldmVudCBjYXJldCBqdW1waW5nICh0byBsYXN0IGJsb2NrKSB3aGVuIGNsaWNraW5nIGJldHdlZW4gYmxvY2tzXG4gICAgKi9cbiAgICBvIDwgaSkge1xuICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSwgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiBsLCBDYXJldDogYSwgVG9vbGJhcjogYyB9ID0gdGhpcy5FZGl0b3I7XG4gICAgICAoIWwubGFzdEJsb2NrLnRvb2wuaXNEZWZhdWx0IHx8ICFsLmxhc3RCbG9jay5pc0VtcHR5KSAmJiBsLmluc2VydEF0RW5kKCksIGEuc2V0VG9UaGVMYXN0QmxvY2soKSwgYy5tb3ZlQW5kT3BlbihsLmxhc3RCbG9jayk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBIYW5kbGUgc2VsZWN0aW9uIGNoYW5nZXMgb24gbW9iaWxlIGRldmljZXNcbiAgICogVXNlcyBmb3Igc2hvd2luZyB0aGUgSW5saW5lIFRvb2xiYXJcbiAgICovXG4gIHNlbGVjdGlvbkNoYW5nZWQoKSB7XG4gICAgY29uc3QgeyBDcm9zc0Jsb2NrU2VsZWN0aW9uOiBlLCBCbG9ja1NlbGVjdGlvbjogdCB9ID0gdGhpcy5FZGl0b3IsIG8gPSBiLmFuY2hvckVsZW1lbnQ7XG4gICAgaWYgKGUuaXNDcm9zc0Jsb2NrU2VsZWN0aW9uU3RhcnRlZCAmJiB0LmFueUJsb2NrU2VsZWN0ZWQgJiYgYi5nZXQoKS5yZW1vdmVBbGxSYW5nZXMoKSwgIW8pIHtcbiAgICAgIGIucmFuZ2UgfHwgdGhpcy5FZGl0b3IuSW5saW5lVG9vbGJhci5jbG9zZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBvLmNsb3Nlc3QoYC4ke0QuQ1NTLmNvbnRlbnR9YCkgPT09IG51bGwgJiYgKHRoaXMuRWRpdG9yLklubGluZVRvb2xiYXIuY29udGFpbnNOb2RlKG8pIHx8IHRoaXMuRWRpdG9yLklubGluZVRvb2xiYXIuY2xvc2UoKSwgIShvLmRhdGFzZXQuaW5saW5lVG9vbGJhciA9PT0gXCJ0cnVlXCIpKSB8fCAodGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmN1cnJlbnRCbG9jayB8fCB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuc2V0Q3VycmVudEJsb2NrQnlDaGlsZE5vZGUobyksIHRoaXMuRWRpdG9yLklubGluZVRvb2xiYXIudHJ5VG9TaG93KCEwKSk7XG4gIH1cbiAgLyoqXG4gICAqIEVkaXRvci5qcyBwcm92aWRlcyBhbmQgYWJpbGl0eSB0byBzaG93IHBsYWNlaG9sZGVycyBmb3IgZW1wdHkgY29udGVudGVkaXRhYmxlIGVsZW1lbnRzXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIHdhdGNoZXMgZm9yIGlucHV0IGFuZCBmb2N1cyBldmVudHMgYW5kIHRvZ2dsZXMgJ2RhdGEtZW1wdHknIGF0dHJpYnV0ZVxuICAgKiB0byB3b3JrYXJvdWQgdGhlIGNhc2UsIHdoZW4gaW5wdXRzIGNvbnRhaW5zIG9ubHkgPGJyPnMgYW5kIGhhcyBubyB2aXNpYmxlIGNvbnRlbnRcbiAgICogVGhlbiwgQ1NTIGNvdWxkIHJlbHkgb24gdGhpcyBhdHRyaWJ1dGUgdG8gc2hvdyBwbGFjZWhvbGRlcnNcbiAgICovXG4gIGVuYWJsZUlucHV0c0VtcHR5TWFyaygpIHtcbiAgICBmdW5jdGlvbiBlKHQpIHtcbiAgICAgIGNvbnN0IG8gPSB0LnRhcmdldDtcbiAgICAgIE90KG8pO1xuICAgIH1cbiAgICB0aGlzLnJlYWRPbmx5TXV0YWJsZUxpc3RlbmVycy5vbih0aGlzLm5vZGVzLndyYXBwZXIsIFwiaW5wdXRcIiwgZSksIHRoaXMucmVhZE9ubHlNdXRhYmxlTGlzdGVuZXJzLm9uKHRoaXMubm9kZXMud3JhcHBlciwgXCJmb2N1c2luXCIsIGUpLCB0aGlzLnJlYWRPbmx5TXV0YWJsZUxpc3RlbmVycy5vbih0aGlzLm5vZGVzLndyYXBwZXIsIFwiZm9jdXNvdXRcIiwgZSk7XG4gIH1cbn1cbmNvbnN0IHlzID0ge1xuICAvLyBBUEkgTW9kdWxlc1xuICBCbG9ja3NBUEk6IGZpLFxuICBDYXJldEFQSTogbWksXG4gIEV2ZW50c0FQSTogYmksXG4gIEkxOG5BUEk6IHN0LFxuICBBUEk6IGtpLFxuICBJbmxpbmVUb29sYmFyQVBJOiB2aSxcbiAgTGlzdGVuZXJzQVBJOiB3aSxcbiAgTm90aWZpZXJBUEk6IEJpLFxuICBSZWFkT25seUFQSTogVGksXG4gIFNhbml0aXplckFQSTogTGksXG4gIFNhdmVyQVBJOiBfaSxcbiAgU2VsZWN0aW9uQVBJOiBOaSxcbiAgVG9vbHNBUEk6IFBpLFxuICBTdHlsZXNBUEk6IERpLFxuICBUb29sYmFyQVBJOiBSaSxcbiAgVG9vbHRpcEFQSTogRmksXG4gIFVpQVBJOiBIaSxcbiAgLy8gVG9vbGJhciBNb2R1bGVzXG4gIEJsb2NrU2V0dGluZ3M6IFVpLFxuICBUb29sYmFyOiBxaSxcbiAgSW5saW5lVG9vbGJhcjogWmksXG4gIC8vIE1vZHVsZXNcbiAgQmxvY2tFdmVudHM6IEdpLFxuICBCbG9ja01hbmFnZXI6IGVzLFxuICBCbG9ja1NlbGVjdGlvbjogdHMsXG4gIENhcmV0OiBEZSxcbiAgQ3Jvc3NCbG9ja1NlbGVjdGlvbjogb3MsXG4gIERyYWdORHJvcDogaXMsXG4gIE1vZGlmaWNhdGlvbnNPYnNlcnZlcjogc3MsXG4gIFBhc3RlOiBucyxcbiAgUmVhZE9ubHk6IHJzLFxuICBSZWN0YW5nbGVTZWxlY3Rpb246IHdlLFxuICBSZW5kZXJlcjogbHMsXG4gIFNhdmVyOiBhcyxcbiAgVG9vbHM6IGdvLFxuICBVSTogeHNcbn07XG5jbGFzcyBFcyB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0VkaXRvckNvbmZpZ30gY29uZmlnIC0gdXNlciBjb25maWd1cmF0aW9uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy5tb2R1bGVJbnN0YW5jZXMgPSB7fSwgdGhpcy5ldmVudHNEaXNwYXRjaGVyID0gbmV3IEJlKCk7XG4gICAgbGV0IHQsIG87XG4gICAgdGhpcy5pc1JlYWR5ID0gbmV3IFByb21pc2UoKGksIHMpID0+IHtcbiAgICAgIHQgPSBpLCBvID0gcztcbiAgICB9KSwgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihhc3luYyAoKSA9PiB7XG4gICAgICB0aGlzLmNvbmZpZ3VyYXRpb24gPSBlLCB0aGlzLnZhbGlkYXRlKCksIHRoaXMuaW5pdCgpLCBhd2FpdCB0aGlzLnN0YXJ0KCksIGF3YWl0IHRoaXMucmVuZGVyKCk7XG4gICAgICBjb25zdCB7IEJsb2NrTWFuYWdlcjogaSwgQ2FyZXQ6IHMsIFVJOiByLCBNb2RpZmljYXRpb25zT2JzZXJ2ZXI6IGwgfSA9IHRoaXMubW9kdWxlSW5zdGFuY2VzO1xuICAgICAgci5jaGVja0VtcHRpbmVzcygpLCBsLmVuYWJsZSgpLCB0aGlzLmNvbmZpZ3VyYXRpb24uYXV0b2ZvY3VzICYmIHMuc2V0VG9CbG9jayhpLmJsb2Nrc1swXSwgcy5wb3NpdGlvbnMuU1RBUlQpLCB0KCk7XG4gICAgfSkuY2F0Y2goKGkpID0+IHtcbiAgICAgIEkoYEVkaXRvci5qcyBpcyBub3QgcmVhZHkgYmVjYXVzZSBvZiAke2l9YCwgXCJlcnJvclwiKSwgbyhpKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU2V0dGluZyBmb3IgY29uZmlndXJhdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge0VkaXRvckNvbmZpZ3xzdHJpbmd9IGNvbmZpZyAtIEVkaXRvcidzIGNvbmZpZyB0byBzZXRcbiAgICovXG4gIHNldCBjb25maWd1cmF0aW9uKGUpIHtcbiAgICB2YXIgbywgaTtcbiAgICBSKGUpID8gdGhpcy5jb25maWcgPSB7XG4gICAgICAuLi5lXG4gICAgfSA6IHRoaXMuY29uZmlnID0ge1xuICAgICAgaG9sZGVyOiBlXG4gICAgfSwgWmUoISF0aGlzLmNvbmZpZy5ob2xkZXJJZCwgXCJjb25maWcuaG9sZGVySWRcIiwgXCJjb25maWcuaG9sZGVyXCIpLCB0aGlzLmNvbmZpZy5ob2xkZXJJZCAmJiAhdGhpcy5jb25maWcuaG9sZGVyICYmICh0aGlzLmNvbmZpZy5ob2xkZXIgPSB0aGlzLmNvbmZpZy5ob2xkZXJJZCwgdGhpcy5jb25maWcuaG9sZGVySWQgPSBudWxsKSwgdGhpcy5jb25maWcuaG9sZGVyID09IG51bGwgJiYgKHRoaXMuY29uZmlnLmhvbGRlciA9IFwiZWRpdG9yanNcIiksIHRoaXMuY29uZmlnLmxvZ0xldmVsIHx8ICh0aGlzLmNvbmZpZy5sb2dMZXZlbCA9IFN0LlZFUkJPU0UpLCB4byh0aGlzLmNvbmZpZy5sb2dMZXZlbCksIFplKCEhdGhpcy5jb25maWcuaW5pdGlhbEJsb2NrLCBcImNvbmZpZy5pbml0aWFsQmxvY2tcIiwgXCJjb25maWcuZGVmYXVsdEJsb2NrXCIpLCB0aGlzLmNvbmZpZy5kZWZhdWx0QmxvY2sgPSB0aGlzLmNvbmZpZy5kZWZhdWx0QmxvY2sgfHwgdGhpcy5jb25maWcuaW5pdGlhbEJsb2NrIHx8IFwicGFyYWdyYXBoXCIsIHRoaXMuY29uZmlnLm1pbkhlaWdodCA9IHRoaXMuY29uZmlnLm1pbkhlaWdodCAhPT0gdm9pZCAwID8gdGhpcy5jb25maWcubWluSGVpZ2h0IDogMzAwO1xuICAgIGNvbnN0IHQgPSB7XG4gICAgICB0eXBlOiB0aGlzLmNvbmZpZy5kZWZhdWx0QmxvY2ssXG4gICAgICBkYXRhOiB7fVxuICAgIH07XG4gICAgdGhpcy5jb25maWcucGxhY2Vob2xkZXIgPSB0aGlzLmNvbmZpZy5wbGFjZWhvbGRlciB8fCAhMSwgdGhpcy5jb25maWcuc2FuaXRpemVyID0gdGhpcy5jb25maWcuc2FuaXRpemVyIHx8IHtcbiAgICAgIHA6ICEwLFxuICAgICAgYjogITAsXG4gICAgICBhOiAhMFxuICAgIH0sIHRoaXMuY29uZmlnLmhpZGVUb29sYmFyID0gdGhpcy5jb25maWcuaGlkZVRvb2xiYXIgPyB0aGlzLmNvbmZpZy5oaWRlVG9vbGJhciA6ICExLCB0aGlzLmNvbmZpZy50b29scyA9IHRoaXMuY29uZmlnLnRvb2xzIHx8IHt9LCB0aGlzLmNvbmZpZy5pMThuID0gdGhpcy5jb25maWcuaTE4biB8fCB7fSwgdGhpcy5jb25maWcuZGF0YSA9IHRoaXMuY29uZmlnLmRhdGEgfHwgeyBibG9ja3M6IFtdIH0sIHRoaXMuY29uZmlnLm9uUmVhZHkgPSB0aGlzLmNvbmZpZy5vblJlYWR5IHx8ICgoKSA9PiB7XG4gICAgfSksIHRoaXMuY29uZmlnLm9uQ2hhbmdlID0gdGhpcy5jb25maWcub25DaGFuZ2UgfHwgKCgpID0+IHtcbiAgICB9KSwgdGhpcy5jb25maWcuaW5saW5lVG9vbGJhciA9IHRoaXMuY29uZmlnLmlubGluZVRvb2xiYXIgIT09IHZvaWQgMCA/IHRoaXMuY29uZmlnLmlubGluZVRvb2xiYXIgOiAhMCwgKFgodGhpcy5jb25maWcuZGF0YSkgfHwgIXRoaXMuY29uZmlnLmRhdGEuYmxvY2tzIHx8IHRoaXMuY29uZmlnLmRhdGEuYmxvY2tzLmxlbmd0aCA9PT0gMCkgJiYgKHRoaXMuY29uZmlnLmRhdGEgPSB7IGJsb2NrczogW3RdIH0pLCB0aGlzLmNvbmZpZy5yZWFkT25seSA9IHRoaXMuY29uZmlnLnJlYWRPbmx5IHx8ICExLCAobyA9IHRoaXMuY29uZmlnLmkxOG4pICE9IG51bGwgJiYgby5tZXNzYWdlcyAmJiBXLnNldERpY3Rpb25hcnkodGhpcy5jb25maWcuaTE4bi5tZXNzYWdlcyksIHRoaXMuY29uZmlnLmkxOG4uZGlyZWN0aW9uID0gKChpID0gdGhpcy5jb25maWcuaTE4bikgPT0gbnVsbCA/IHZvaWQgMCA6IGkuZGlyZWN0aW9uKSB8fCBcImx0clwiO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHByaXZhdGUgcHJvcGVydHlcbiAgICpcbiAgICogQHJldHVybnMge0VkaXRvckNvbmZpZ31cbiAgICovXG4gIGdldCBjb25maWd1cmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZztcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGZvciByZXF1aXJlZCBmaWVsZHMgaW4gRWRpdG9yJ3MgY29uZmlnXG4gICAqL1xuICB2YWxpZGF0ZSgpIHtcbiAgICBjb25zdCB7IGhvbGRlcklkOiBlLCBob2xkZXI6IHQgfSA9IHRoaXMuY29uZmlnO1xuICAgIGlmIChlICYmIHQpXG4gICAgICB0aHJvdyBFcnJvcihcIsKraG9sZGVySWTCuyBhbmQgwqtob2xkZXLCuyBwYXJhbSBjYW4ndCBhc3NpZ24gYXQgdGhlIHNhbWUgdGltZS5cIik7XG4gICAgaWYgKFEodCkgJiYgIWQuZ2V0KHQpKVxuICAgICAgdGhyb3cgRXJyb3IoYGVsZW1lbnQgd2l0aCBJRCDCqyR7dH3CuyBpcyBtaXNzaW5nLiBQYXNzIGNvcnJlY3QgaG9sZGVyJ3MgSUQuYCk7XG4gICAgaWYgKHQgJiYgUih0KSAmJiAhZC5pc0VsZW1lbnQodCkpXG4gICAgICB0aHJvdyBFcnJvcihcIsKraG9sZGVywrsgdmFsdWUgbXVzdCBiZSBhbiBFbGVtZW50IG5vZGVcIik7XG4gIH1cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIG1vZHVsZXM6XG4gICAqICAtIG1ha2UgYW5kIHNhdmUgaW5zdGFuY2VzXG4gICAqICAtIGNvbmZpZ3VyZVxuICAgKi9cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmNvbnN0cnVjdE1vZHVsZXMoKSwgdGhpcy5jb25maWd1cmVNb2R1bGVzKCk7XG4gIH1cbiAgLyoqXG4gICAqIFN0YXJ0IEVkaXRvciFcbiAgICpcbiAgICogR2V0IGxpc3Qgb2YgbW9kdWxlcyB0aGF0IG5lZWRzIHRvIGJlIHByZXBhcmVkIGFuZCByZXR1cm4gYSBzZXF1ZW5jZSAoUHJvbWlzZSlcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICBhc3luYyBzdGFydCgpIHtcbiAgICBhd2FpdCBbXG4gICAgICBcIlRvb2xzXCIsXG4gICAgICBcIlVJXCIsXG4gICAgICBcIkJsb2NrTWFuYWdlclwiLFxuICAgICAgXCJQYXN0ZVwiLFxuICAgICAgXCJCbG9ja1NlbGVjdGlvblwiLFxuICAgICAgXCJSZWN0YW5nbGVTZWxlY3Rpb25cIixcbiAgICAgIFwiQ3Jvc3NCbG9ja1NlbGVjdGlvblwiLFxuICAgICAgXCJSZWFkT25seVwiXG4gICAgXS5yZWR1Y2UoXG4gICAgICAodCwgbykgPT4gdC50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCB0aGlzLm1vZHVsZUluc3RhbmNlc1tvXS5wcmVwYXJlKCk7XG4gICAgICAgIH0gY2F0Y2ggKGkpIHtcbiAgICAgICAgICBpZiAoaSBpbnN0YW5jZW9mIE50KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGkubWVzc2FnZSk7XG4gICAgICAgICAgSShgTW9kdWxlICR7b30gd2FzIHNraXBwZWQgYmVjYXVzZSBvZiAlb2AsIFwid2FyblwiLCBpKTtcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICBQcm9taXNlLnJlc29sdmUoKVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlciBpbml0aWFsIGRhdGFcbiAgICovXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5tb2R1bGVJbnN0YW5jZXMuUmVuZGVyZXIucmVuZGVyKHRoaXMuY29uZmlnLmRhdGEuYmxvY2tzKTtcbiAgfVxuICAvKipcbiAgICogTWFrZSBtb2R1bGVzIGluc3RhbmNlcyBhbmQgc2F2ZSBpdCB0byB0aGUgQHByb3BlcnR5IHRoaXMubW9kdWxlSW5zdGFuY2VzXG4gICAqL1xuICBjb25zdHJ1Y3RNb2R1bGVzKCkge1xuICAgIE9iamVjdC5lbnRyaWVzKHlzKS5mb3JFYWNoKChbZSwgdF0pID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMubW9kdWxlSW5zdGFuY2VzW2VdID0gbmV3IHQoe1xuICAgICAgICAgIGNvbmZpZzogdGhpcy5jb25maWd1cmF0aW9uLFxuICAgICAgICAgIGV2ZW50c0Rpc3BhdGNoZXI6IHRoaXMuZXZlbnRzRGlzcGF0Y2hlclxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKG8pIHtcbiAgICAgICAgSShcIltjb25zdHJ1Y3RNb2R1bGVzXVwiLCBgTW9kdWxlICR7ZX0gc2tpcHBlZCBiZWNhdXNlYCwgXCJlcnJvclwiLCBvKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogTW9kdWxlcyBpbnN0YW5jZXMgY29uZmlndXJhdGlvbjpcbiAgICogIC0gcGFzcyBvdGhlciBtb2R1bGVzIHRvIHRoZSAnc3RhdGUnIHByb3BlcnR5XG4gICAqICAtIC4uLlxuICAgKi9cbiAgY29uZmlndXJlTW9kdWxlcygpIHtcbiAgICBmb3IgKGNvbnN0IGUgaW4gdGhpcy5tb2R1bGVJbnN0YW5jZXMpXG4gICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5tb2R1bGVJbnN0YW5jZXMsIGUpICYmICh0aGlzLm1vZHVsZUluc3RhbmNlc1tlXS5zdGF0ZSA9IHRoaXMuZ2V0TW9kdWxlc0RpZmYoZSkpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gbW9kdWxlcyB3aXRob3V0IHBhc3NlZCBuYW1lXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gbW9kdWxlIGZvciB3aXRjaCBtb2R1bGVzIGRpZmZlcmVuY2Ugc2hvdWxkIGJlIGNhbGN1bGF0ZWRcbiAgICovXG4gIGdldE1vZHVsZXNEaWZmKGUpIHtcbiAgICBjb25zdCB0ID0ge307XG4gICAgZm9yIChjb25zdCBvIGluIHRoaXMubW9kdWxlSW5zdGFuY2VzKVxuICAgICAgbyAhPT0gZSAmJiAodFtvXSA9IHRoaXMubW9kdWxlSW5zdGFuY2VzW29dKTtcbiAgICByZXR1cm4gdDtcbiAgfVxufVxuLyoqXG4gKiBFZGl0b3IuanNcbiAqXG4gKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4gKiBAc2VlIEVkaXRvci5qcyA8aHR0cHM6Ly9lZGl0b3Jqcy5pbz5cbiAqIEBhdXRob3IgQ29kZVggVGVhbSA8aHR0cHM6Ly9jb2RleC5zbz5cbiAqL1xuY2xhc3MgQnMge1xuICAvKiogRWRpdG9yIHZlcnNpb24gKi9cbiAgc3RhdGljIGdldCB2ZXJzaW9uKCkge1xuICAgIHJldHVybiBcIjIuMzAuMFwiO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge0VkaXRvckNvbmZpZ3xzdHJpbmd8dW5kZWZpbmVkfSBbY29uZmlndXJhdGlvbl0gLSB1c2VyIGNvbmZpZ3VyYXRpb25cbiAgICovXG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBsZXQgdCA9ICgpID0+IHtcbiAgICB9O1xuICAgIFIoZSkgJiYgTyhlLm9uUmVhZHkpICYmICh0ID0gZS5vblJlYWR5KTtcbiAgICBjb25zdCBvID0gbmV3IEVzKGUpO1xuICAgIHRoaXMuaXNSZWFkeSA9IG8uaXNSZWFkeS50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMuZXhwb3J0QVBJKG8pLCB0KCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEV4cG9ydCBleHRlcm5hbCBBUEkgbWV0aG9kc1xuICAgKlxuICAgKiBAcGFyYW0ge0NvcmV9IGVkaXRvciDigJQgRWRpdG9yJ3MgaW5zdGFuY2VcbiAgICovXG4gIGV4cG9ydEFQSShlKSB7XG4gICAgY29uc3QgdCA9IFtcImNvbmZpZ3VyYXRpb25cIl0sIG8gPSAoKSA9PiB7XG4gICAgICBPYmplY3QudmFsdWVzKGUubW9kdWxlSW5zdGFuY2VzKS5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgIE8ocy5kZXN0cm95KSAmJiBzLmRlc3Ryb3koKSwgcy5saXN0ZW5lcnMucmVtb3ZlQWxsKCk7XG4gICAgICB9KSwgb2koKSwgZSA9IG51bGw7XG4gICAgICBmb3IgKGNvbnN0IHMgaW4gdGhpcylcbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsIHMpICYmIGRlbGV0ZSB0aGlzW3NdO1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIG51bGwpO1xuICAgIH07XG4gICAgdC5mb3JFYWNoKChzKSA9PiB7XG4gICAgICB0aGlzW3NdID0gZVtzXTtcbiAgICB9KSwgdGhpcy5kZXN0cm95ID0gbywgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIGUubW9kdWxlSW5zdGFuY2VzLkFQSS5tZXRob2RzKSwgZGVsZXRlIHRoaXMuZXhwb3J0QVBJLCBPYmplY3QuZW50cmllcyh7XG4gICAgICBibG9ja3M6IHtcbiAgICAgICAgY2xlYXI6IFwiY2xlYXJcIixcbiAgICAgICAgcmVuZGVyOiBcInJlbmRlclwiXG4gICAgICB9LFxuICAgICAgY2FyZXQ6IHtcbiAgICAgICAgZm9jdXM6IFwiZm9jdXNcIlxuICAgICAgfSxcbiAgICAgIGV2ZW50czoge1xuICAgICAgICBvbjogXCJvblwiLFxuICAgICAgICBvZmY6IFwib2ZmXCIsXG4gICAgICAgIGVtaXQ6IFwiZW1pdFwiXG4gICAgICB9LFxuICAgICAgc2F2ZXI6IHtcbiAgICAgICAgc2F2ZTogXCJzYXZlXCJcbiAgICAgIH1cbiAgICB9KS5mb3JFYWNoKChbcywgcl0pID0+IHtcbiAgICAgIE9iamVjdC5lbnRyaWVzKHIpLmZvckVhY2goKFtsLCBhXSkgPT4ge1xuICAgICAgICB0aGlzW2FdID0gZS5tb2R1bGVJbnN0YW5jZXMuQVBJLm1ldGhvZHNbc11bbF07XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuZXhwb3J0IHtcbiAgQnMgYXMgZGVmYXVsdFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@editorjs/editorjs/dist/editorjs.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@editorjs/header/dist/header.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@editorjs/header/dist/header.mjs ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ c; }\n/* harmony export */ });\n(function(){\"use strict\";try{if(typeof document<\"u\"){var e=document.createElement(\"style\");e.appendChild(document.createTextNode(\".ce-header{padding:.6em 0 3px;margin:0;line-height:1.25em;outline:none}.ce-header p,.ce-header div{padding:0!important;margin:0!important}.ce-header[contentEditable=true][data-placeholder]:before{position:absolute;content:attr(data-placeholder);color:#707684;font-weight:400;display:none;cursor:text}.ce-header[contentEditable=true][data-placeholder]:empty:before{display:block}.ce-header[contentEditable=true][data-placeholder]:empty:focus:before{display:none}\")),document.head.appendChild(e)}}catch(t){console.error(\"vite-plugin-css-injected-by-js\",t)}})();\nconst a = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M6 7L6 12M6 17L6 12M6 12L12 12M12 7V12M12 17L12 12\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M19 17V10.2135C19 10.1287 18.9011 10.0824 18.836 10.1367L16 12.5\"/></svg>', l = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M6 7L6 12M6 17L6 12M6 12L12 12M12 7V12M12 17L12 12\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M16 11C16 10 19 9.5 19 12C19 13.9771 16.0684 13.9997 16.0012 16.8981C15.9999 16.9533 16.0448 17 16.1 17L19.3 17\"/></svg>', o = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M6 7L6 12M6 17L6 12M6 12L12 12M12 7V12M12 17L12 12\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M16 11C16 10.5 16.8323 10 17.6 10C18.3677 10 19.5 10.311 19.5 11.5C19.5 12.5315 18.7474 12.9022 18.548 12.9823C18.5378 12.9864 18.5395 13.0047 18.5503 13.0063C18.8115 13.0456 20 13.3065 20 14.8C20 16 19.5 17 17.8 17C17.8 17 16 17 16 16.3\"/></svg>', h = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M6 7L6 12M6 17L6 12M6 12L12 12M12 7V12M12 17L12 12\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M18 10L15.2834 14.8511C15.246 14.9178 15.294 15 15.3704 15C16.8489 15 18.7561 15 20.2 15M19 17C19 15.7187 19 14.8813 19 13.6\"/></svg>', d = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M6 7L6 12M6 17L6 12M6 12L12 12M12 7V12M12 17L12 12\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M16 15.9C16 15.9 16.3768 17 17.8 17C19.5 17 20 15.6199 20 14.7C20 12.7323 17.6745 12.0486 16.1635 12.9894C16.094 13.0327 16 12.9846 16 12.9027V10.1C16 10.0448 16.0448 10 16.1 10H19.8\"/></svg>', u = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M6 7L6 12M6 17L6 12M6 12L12 12M12 7V12M12 17L12 12\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M19.5 10C16.5 10.5 16 13.3285 16 15M16 15V15C16 16.1046 16.8954 17 18 17H18.3246C19.3251 17 20.3191 16.3492 20.2522 15.3509C20.0612 12.4958 16 12.6611 16 15Z\"/></svg>', g = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M9 7L9 12M9 17V12M9 12L15 12M15 7V12M15 17L15 12\"/></svg>';\n/**\n * Header block for the Editor.js.\n *\n * @author CodeX (team@ifmo.su)\n * @copyright CodeX 2018\n * @license MIT\n * @version 2.0.0\n */\nclass c {\n  constructor({ data: e, config: t, api: s, readOnly: r }) {\n    this.api = s, this.readOnly = r, this._settings = t, this._data = this.normalizeData(e), this._element = this.getTag();\n  }\n  /**\n   * Styles\n   */\n  get _CSS() {\n    return {\n      block: this.api.styles.block,\n      wrapper: \"ce-header\"\n    };\n  }\n  /**\n   * Check if data is valid\n   * \n   * @param {any} data - data to check\n   * @returns {data is HeaderData}\n   * @private\n   */\n  isHeaderData(e) {\n    return e.text !== void 0 && e.level !== void 0;\n  }\n  /**\n   * Normalize input data\n   *\n   * @param {HeaderData} data - saved data to process\n   *\n   * @returns {HeaderData}\n   * @private\n   */\n  normalizeData(e) {\n    const t = { text: \"\", level: this.defaultLevel.number };\n    return this.isHeaderData(e) ? (t.text = e.text || \"\", t.level = parseInt(e.level.toString()) || this.defaultLevel.number, t) : { text: \"\", level: this.defaultLevel.number };\n  }\n  /**\n   * Return Tool's view\n   *\n   * @returns {HTMLHeadingElement}\n   * @public\n   */\n  render() {\n    return this._element;\n  }\n  /**\n   * Returns header block tunes config\n   *\n   * @returns {Array}\n   */\n  renderSettings() {\n    return this.levels.map((e) => ({\n      icon: e.svg,\n      label: this.api.i18n.t(`Heading ${e.number}`),\n      onActivate: () => this.setLevel(e.number),\n      closeOnActivate: !0,\n      isActive: this.currentLevel.number === e.number,\n      render: () => document.createElement(\"div\")\n    }));\n  }\n  /**\n   * Callback for Block's settings buttons\n   *\n   * @param {number} level - level to set\n   */\n  setLevel(e) {\n    this.data = {\n      level: e,\n      text: this.data.text\n    };\n  }\n  /**\n   * Method that specified how to merge two Text blocks.\n   * Called by Editor.js by backspace at the beginning of the Block\n   *\n   * @param {HeaderData} data - saved data to merger with current block\n   * @public\n   */\n  merge(e) {\n    const t = {\n      text: this.data.text + e.text,\n      level: this.data.level\n    };\n    this.data = t;\n  }\n  /**\n   * Validate Text block data:\n   * - check for emptiness\n   *\n   * @param {HeaderData} blockData  data received after saving\n   * @returns {boolean} false if saved data is not correct, otherwise true\n   * @public\n   */\n  validate(e) {\n    return e.text.trim() !== \"\";\n  }\n  /**\n   * Extract Tool's data from the view\n   *\n   * @param {HTMLHeadingElement} toolsContent - Text tools rendered view\n   * @returns {HeaderData} - saved data\n   * @public\n   */\n  save(e) {\n    return {\n      text: e.innerHTML,\n      level: this.currentLevel.number\n    };\n  }\n  /**\n   * Allow Header to be converted to/from other blocks\n   */\n  static get conversionConfig() {\n    return {\n      export: \"text\",\n      // use 'text' property for other blocks\n      import: \"text\"\n      // fill 'text' property from other block's export string\n    };\n  }\n  /**\n   * Sanitizer Rules\n   */\n  static get sanitize() {\n    return {\n      level: !1,\n      text: {}\n    };\n  }\n  /**\n   * Returns true to notify core that read-only is supported\n   *\n   * @returns {boolean}\n   */\n  static get isReadOnlySupported() {\n    return !0;\n  }\n  /**\n   * Get current Tools`s data\n   *\n   * @returns {HeaderData} Current data\n   * @private\n   */\n  get data() {\n    return this._data.text = this._element.innerHTML, this._data.level = this.currentLevel.number, this._data;\n  }\n  /**\n   * Store data in plugin:\n   * - at the this._data property\n   * - at the HTML\n   *\n   * @param {HeaderData} data  data to set\n   * @private\n   */\n  set data(e) {\n    if (this._data = this.normalizeData(e), e.level !== void 0 && this._element.parentNode) {\n      const t = this.getTag();\n      t.innerHTML = this._element.innerHTML, this._element.parentNode.replaceChild(t, this._element), this._element = t;\n    }\n    e.text !== void 0 && (this._element.innerHTML = this._data.text || \"\");\n  }\n  /**\n   * Get tag for target level\n   * By default returns second-leveled header\n   *\n   * @returns {HTMLElement}\n   */\n  getTag() {\n    const e = document.createElement(this.currentLevel.tag);\n    return e.innerHTML = this._data.text || \"\", e.classList.add(this._CSS.wrapper), e.contentEditable = this.readOnly ? \"false\" : \"true\", e.dataset.placeholder = this.api.i18n.t(this._settings.placeholder || \"\"), e;\n  }\n  /**\n   * Get current level\n   *\n   * @returns {level}\n   */\n  get currentLevel() {\n    let e = this.levels.find((t) => t.number === this._data.level);\n    return e || (e = this.defaultLevel), e;\n  }\n  /**\n   * Return default level\n   *\n   * @returns {level}\n   */\n  get defaultLevel() {\n    if (this._settings.defaultLevel) {\n      const e = this.levels.find((t) => t.number === this._settings.defaultLevel);\n      if (e)\n        return e;\n      console.warn(\"('-') Heading Tool: the default level specified was not found in available levels\");\n    }\n    return this.levels[1];\n  }\n  /**\n   * @typedef {object} level\n   * @property {number} number - level number\n   * @property {string} tag - tag corresponds with level number\n   * @property {string} svg - icon\n   */\n  /**\n   * Available header levels\n   *\n   * @returns {level[]}\n   */\n  get levels() {\n    const e = [\n      {\n        number: 1,\n        tag: \"H1\",\n        svg: a\n      },\n      {\n        number: 2,\n        tag: \"H2\",\n        svg: l\n      },\n      {\n        number: 3,\n        tag: \"H3\",\n        svg: o\n      },\n      {\n        number: 4,\n        tag: \"H4\",\n        svg: h\n      },\n      {\n        number: 5,\n        tag: \"H5\",\n        svg: d\n      },\n      {\n        number: 6,\n        tag: \"H6\",\n        svg: u\n      }\n    ];\n    return this._settings.levels ? e.filter(\n      (t) => this._settings.levels.includes(t.number)\n    ) : e;\n  }\n  /**\n   * Handle H1-H6 tags on paste to substitute it with header Tool\n   *\n   * @param {PasteEvent} event - event with pasted content\n   */\n  onPaste(e) {\n    const t = e.detail;\n    if (\"data\" in t) {\n      const s = t.data;\n      let r = this.defaultLevel.number;\n      switch (s.tagName) {\n        case \"H1\":\n          r = 1;\n          break;\n        case \"H2\":\n          r = 2;\n          break;\n        case \"H3\":\n          r = 3;\n          break;\n        case \"H4\":\n          r = 4;\n          break;\n        case \"H5\":\n          r = 5;\n          break;\n        case \"H6\":\n          r = 6;\n          break;\n      }\n      this._settings.levels && (r = this._settings.levels.reduce((n, i) => Math.abs(i - r) < Math.abs(n - r) ? i : n)), this.data = {\n        level: r,\n        text: s.innerHTML\n      };\n    }\n  }\n  /**\n   * Used by Editor.js paste handling API.\n   * Provides configuration to handle H1-H6 tags.\n   *\n   * @returns {{handler: (function(HTMLElement): {text: string}), tags: string[]}}\n   */\n  static get pasteConfig() {\n    return {\n      tags: [\"H1\", \"H2\", \"H3\", \"H4\", \"H5\", \"H6\"]\n    };\n  }\n  /**\n   * Get Tool toolbox settings\n   * icon - Tool icon's SVG\n   * title - title to show in toolbox\n   *\n   * @returns {{icon: string, title: string}}\n   */\n  static get toolbox() {\n    return {\n      icon: g,\n      title: \"Heading\"\n    };\n  }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZWRpdG9yanMvaGVhZGVyL2Rpc3QvaGVhZGVyLm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsWUFBWSxhQUFhLElBQUksd0JBQXdCLHNDQUFzQyxrREFBa0QsbUJBQW1CLFNBQVMsbUJBQW1CLGFBQWEsNEJBQTRCLG9CQUFvQixtQkFBbUIsMERBQTBELGtCQUFrQiwrQkFBK0IsY0FBYyxnQkFBZ0IsYUFBYSxZQUFZLGdFQUFnRSxjQUFjLHNFQUFzRSxhQUFhLGtDQUFrQyxTQUFTLG1EQUFtRDtBQUM3cUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUNBQXlDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLHFJQUFxSTtBQUNySTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0NBQWtDLGFBQWE7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BlZGl0b3Jqcy9oZWFkZXIvZGlzdC9oZWFkZXIubWpzP2ExMWQiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7dHJ5e2lmKHR5cGVvZiBkb2N1bWVudDxcInVcIil7dmFyIGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO2UuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCIuY2UtaGVhZGVye3BhZGRpbmc6LjZlbSAwIDNweDttYXJnaW46MDtsaW5lLWhlaWdodDoxLjI1ZW07b3V0bGluZTpub25lfS5jZS1oZWFkZXIgcCwuY2UtaGVhZGVyIGRpdntwYWRkaW5nOjAhaW1wb3J0YW50O21hcmdpbjowIWltcG9ydGFudH0uY2UtaGVhZGVyW2NvbnRlbnRFZGl0YWJsZT10cnVlXVtkYXRhLXBsYWNlaG9sZGVyXTpiZWZvcmV7cG9zaXRpb246YWJzb2x1dGU7Y29udGVudDphdHRyKGRhdGEtcGxhY2Vob2xkZXIpO2NvbG9yOiM3MDc2ODQ7Zm9udC13ZWlnaHQ6NDAwO2Rpc3BsYXk6bm9uZTtjdXJzb3I6dGV4dH0uY2UtaGVhZGVyW2NvbnRlbnRFZGl0YWJsZT10cnVlXVtkYXRhLXBsYWNlaG9sZGVyXTplbXB0eTpiZWZvcmV7ZGlzcGxheTpibG9ja30uY2UtaGVhZGVyW2NvbnRlbnRFZGl0YWJsZT10cnVlXVtkYXRhLXBsYWNlaG9sZGVyXTplbXB0eTpmb2N1czpiZWZvcmV7ZGlzcGxheTpub25lfVwiKSksZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChlKX19Y2F0Y2godCl7Y29uc29sZS5lcnJvcihcInZpdGUtcGx1Z2luLWNzcy1pbmplY3RlZC1ieS1qc1wiLHQpfX0pKCk7XG5jb25zdCBhID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk02IDdMNiAxMk02IDE3TDYgMTJNNiAxMkwxMiAxMk0xMiA3VjEyTTEyIDE3TDEyIDEyXCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk0xOSAxN1YxMC4yMTM1QzE5IDEwLjEyODcgMTguOTAxMSAxMC4wODI0IDE4LjgzNiAxMC4xMzY3TDE2IDEyLjVcIi8+PC9zdmc+JywgbCA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNNiA3TDYgMTJNNiAxN0w2IDEyTTYgMTJMMTIgMTJNMTIgN1YxMk0xMiAxN0wxMiAxMlwiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNMTYgMTFDMTYgMTAgMTkgOS41IDE5IDEyQzE5IDEzLjk3NzEgMTYuMDY4NCAxMy45OTk3IDE2LjAwMTIgMTYuODk4MUMxNS45OTk5IDE2Ljk1MzMgMTYuMDQ0OCAxNyAxNi4xIDE3TDE5LjMgMTdcIi8+PC9zdmc+JywgbyA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNNiA3TDYgMTJNNiAxN0w2IDEyTTYgMTJMMTIgMTJNMTIgN1YxMk0xMiAxN0wxMiAxMlwiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNMTYgMTFDMTYgMTAuNSAxNi44MzIzIDEwIDE3LjYgMTBDMTguMzY3NyAxMCAxOS41IDEwLjMxMSAxOS41IDExLjVDMTkuNSAxMi41MzE1IDE4Ljc0NzQgMTIuOTAyMiAxOC41NDggMTIuOTgyM0MxOC41Mzc4IDEyLjk4NjQgMTguNTM5NSAxMy4wMDQ3IDE4LjU1MDMgMTMuMDA2M0MxOC44MTE1IDEzLjA0NTYgMjAgMTMuMzA2NSAyMCAxNC44QzIwIDE2IDE5LjUgMTcgMTcuOCAxN0MxNy44IDE3IDE2IDE3IDE2IDE2LjNcIi8+PC9zdmc+JywgaCA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNNiA3TDYgMTJNNiAxN0w2IDEyTTYgMTJMMTIgMTJNMTIgN1YxMk0xMiAxN0wxMiAxMlwiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNMTggMTBMMTUuMjgzNCAxNC44NTExQzE1LjI0NiAxNC45MTc4IDE1LjI5NCAxNSAxNS4zNzA0IDE1QzE2Ljg0ODkgMTUgMTguNzU2MSAxNSAyMC4yIDE1TTE5IDE3QzE5IDE1LjcxODcgMTkgMTQuODgxMyAxOSAxMy42XCIvPjwvc3ZnPicsIGQgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTYgN0w2IDEyTTYgMTdMNiAxMk02IDEyTDEyIDEyTTEyIDdWMTJNMTIgMTdMMTIgMTJcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTE2IDE1LjlDMTYgMTUuOSAxNi4zNzY4IDE3IDE3LjggMTdDMTkuNSAxNyAyMCAxNS42MTk5IDIwIDE0LjdDMjAgMTIuNzMyMyAxNy42NzQ1IDEyLjA0ODYgMTYuMTYzNSAxMi45ODk0QzE2LjA5NCAxMy4wMzI3IDE2IDEyLjk4NDYgMTYgMTIuOTAyN1YxMC4xQzE2IDEwLjA0NDggMTYuMDQ0OCAxMCAxNi4xIDEwSDE5LjhcIi8+PC9zdmc+JywgdSA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNNiA3TDYgMTJNNiAxN0w2IDEyTTYgMTJMMTIgMTJNMTIgN1YxMk0xMiAxN0wxMiAxMlwiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNMTkuNSAxMEMxNi41IDEwLjUgMTYgMTMuMzI4NSAxNiAxNU0xNiAxNVYxNUMxNiAxNi4xMDQ2IDE2Ljg5NTQgMTcgMTggMTdIMTguMzI0NkMxOS4zMjUxIDE3IDIwLjMxOTEgMTYuMzQ5MiAyMC4yNTIyIDE1LjM1MDlDMjAuMDYxMiAxMi40OTU4IDE2IDEyLjY2MTEgMTYgMTVaXCIvPjwvc3ZnPicsIGcgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTkgN0w5IDEyTTkgMTdWMTJNOSAxMkwxNSAxMk0xNSA3VjEyTTE1IDE3TDE1IDEyXCIvPjwvc3ZnPic7XG4vKipcbiAqIEhlYWRlciBibG9jayBmb3IgdGhlIEVkaXRvci5qcy5cbiAqXG4gKiBAYXV0aG9yIENvZGVYICh0ZWFtQGlmbW8uc3UpXG4gKiBAY29weXJpZ2h0IENvZGVYIDIwMThcbiAqIEBsaWNlbnNlIE1JVFxuICogQHZlcnNpb24gMi4wLjBcbiAqL1xuY2xhc3MgYyB7XG4gIGNvbnN0cnVjdG9yKHsgZGF0YTogZSwgY29uZmlnOiB0LCBhcGk6IHMsIHJlYWRPbmx5OiByIH0pIHtcbiAgICB0aGlzLmFwaSA9IHMsIHRoaXMucmVhZE9ubHkgPSByLCB0aGlzLl9zZXR0aW5ncyA9IHQsIHRoaXMuX2RhdGEgPSB0aGlzLm5vcm1hbGl6ZURhdGEoZSksIHRoaXMuX2VsZW1lbnQgPSB0aGlzLmdldFRhZygpO1xuICB9XG4gIC8qKlxuICAgKiBTdHlsZXNcbiAgICovXG4gIGdldCBfQ1NTKCkge1xuICAgIHJldHVybiB7XG4gICAgICBibG9jazogdGhpcy5hcGkuc3R5bGVzLmJsb2NrLFxuICAgICAgd3JhcHBlcjogXCJjZS1oZWFkZXJcIlxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIGRhdGEgaXMgdmFsaWRcbiAgICogXG4gICAqIEBwYXJhbSB7YW55fSBkYXRhIC0gZGF0YSB0byBjaGVja1xuICAgKiBAcmV0dXJucyB7ZGF0YSBpcyBIZWFkZXJEYXRhfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaXNIZWFkZXJEYXRhKGUpIHtcbiAgICByZXR1cm4gZS50ZXh0ICE9PSB2b2lkIDAgJiYgZS5sZXZlbCAhPT0gdm9pZCAwO1xuICB9XG4gIC8qKlxuICAgKiBOb3JtYWxpemUgaW5wdXQgZGF0YVxuICAgKlxuICAgKiBAcGFyYW0ge0hlYWRlckRhdGF9IGRhdGEgLSBzYXZlZCBkYXRhIHRvIHByb2Nlc3NcbiAgICpcbiAgICogQHJldHVybnMge0hlYWRlckRhdGF9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBub3JtYWxpemVEYXRhKGUpIHtcbiAgICBjb25zdCB0ID0geyB0ZXh0OiBcIlwiLCBsZXZlbDogdGhpcy5kZWZhdWx0TGV2ZWwubnVtYmVyIH07XG4gICAgcmV0dXJuIHRoaXMuaXNIZWFkZXJEYXRhKGUpID8gKHQudGV4dCA9IGUudGV4dCB8fCBcIlwiLCB0LmxldmVsID0gcGFyc2VJbnQoZS5sZXZlbC50b1N0cmluZygpKSB8fCB0aGlzLmRlZmF1bHRMZXZlbC5udW1iZXIsIHQpIDogeyB0ZXh0OiBcIlwiLCBsZXZlbDogdGhpcy5kZWZhdWx0TGV2ZWwubnVtYmVyIH07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBUb29sJ3Mgdmlld1xuICAgKlxuICAgKiBAcmV0dXJucyB7SFRNTEhlYWRpbmdFbGVtZW50fVxuICAgKiBAcHVibGljXG4gICAqL1xuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQ7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgaGVhZGVyIGJsb2NrIHR1bmVzIGNvbmZpZ1xuICAgKlxuICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAqL1xuICByZW5kZXJTZXR0aW5ncygpIHtcbiAgICByZXR1cm4gdGhpcy5sZXZlbHMubWFwKChlKSA9PiAoe1xuICAgICAgaWNvbjogZS5zdmcsXG4gICAgICBsYWJlbDogdGhpcy5hcGkuaTE4bi50KGBIZWFkaW5nICR7ZS5udW1iZXJ9YCksXG4gICAgICBvbkFjdGl2YXRlOiAoKSA9PiB0aGlzLnNldExldmVsKGUubnVtYmVyKSxcbiAgICAgIGNsb3NlT25BY3RpdmF0ZTogITAsXG4gICAgICBpc0FjdGl2ZTogdGhpcy5jdXJyZW50TGV2ZWwubnVtYmVyID09PSBlLm51bWJlcixcbiAgICAgIHJlbmRlcjogKCkgPT4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKVxuICAgIH0pKTtcbiAgfVxuICAvKipcbiAgICogQ2FsbGJhY2sgZm9yIEJsb2NrJ3Mgc2V0dGluZ3MgYnV0dG9uc1xuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbGV2ZWwgLSBsZXZlbCB0byBzZXRcbiAgICovXG4gIHNldExldmVsKGUpIHtcbiAgICB0aGlzLmRhdGEgPSB7XG4gICAgICBsZXZlbDogZSxcbiAgICAgIHRleHQ6IHRoaXMuZGF0YS50ZXh0XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogTWV0aG9kIHRoYXQgc3BlY2lmaWVkIGhvdyB0byBtZXJnZSB0d28gVGV4dCBibG9ja3MuXG4gICAqIENhbGxlZCBieSBFZGl0b3IuanMgYnkgYmFja3NwYWNlIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIEJsb2NrXG4gICAqXG4gICAqIEBwYXJhbSB7SGVhZGVyRGF0YX0gZGF0YSAtIHNhdmVkIGRhdGEgdG8gbWVyZ2VyIHdpdGggY3VycmVudCBibG9ja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBtZXJnZShlKSB7XG4gICAgY29uc3QgdCA9IHtcbiAgICAgIHRleHQ6IHRoaXMuZGF0YS50ZXh0ICsgZS50ZXh0LFxuICAgICAgbGV2ZWw6IHRoaXMuZGF0YS5sZXZlbFxuICAgIH07XG4gICAgdGhpcy5kYXRhID0gdDtcbiAgfVxuICAvKipcbiAgICogVmFsaWRhdGUgVGV4dCBibG9jayBkYXRhOlxuICAgKiAtIGNoZWNrIGZvciBlbXB0aW5lc3NcbiAgICpcbiAgICogQHBhcmFtIHtIZWFkZXJEYXRhfSBibG9ja0RhdGEg4oCUIGRhdGEgcmVjZWl2ZWQgYWZ0ZXIgc2F2aW5nXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBmYWxzZSBpZiBzYXZlZCBkYXRhIGlzIG5vdCBjb3JyZWN0LCBvdGhlcndpc2UgdHJ1ZVxuICAgKiBAcHVibGljXG4gICAqL1xuICB2YWxpZGF0ZShlKSB7XG4gICAgcmV0dXJuIGUudGV4dC50cmltKCkgIT09IFwiXCI7XG4gIH1cbiAgLyoqXG4gICAqIEV4dHJhY3QgVG9vbCdzIGRhdGEgZnJvbSB0aGUgdmlld1xuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxIZWFkaW5nRWxlbWVudH0gdG9vbHNDb250ZW50IC0gVGV4dCB0b29scyByZW5kZXJlZCB2aWV3XG4gICAqIEByZXR1cm5zIHtIZWFkZXJEYXRhfSAtIHNhdmVkIGRhdGFcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgc2F2ZShlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHQ6IGUuaW5uZXJIVE1MLFxuICAgICAgbGV2ZWw6IHRoaXMuY3VycmVudExldmVsLm51bWJlclxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEFsbG93IEhlYWRlciB0byBiZSBjb252ZXJ0ZWQgdG8vZnJvbSBvdGhlciBibG9ja3NcbiAgICovXG4gIHN0YXRpYyBnZXQgY29udmVyc2lvbkNvbmZpZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXhwb3J0OiBcInRleHRcIixcbiAgICAgIC8vIHVzZSAndGV4dCcgcHJvcGVydHkgZm9yIG90aGVyIGJsb2Nrc1xuICAgICAgaW1wb3J0OiBcInRleHRcIlxuICAgICAgLy8gZmlsbCAndGV4dCcgcHJvcGVydHkgZnJvbSBvdGhlciBibG9jaydzIGV4cG9ydCBzdHJpbmdcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBTYW5pdGl6ZXIgUnVsZXNcbiAgICovXG4gIHN0YXRpYyBnZXQgc2FuaXRpemUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxldmVsOiAhMSxcbiAgICAgIHRleHQ6IHt9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIHRvIG5vdGlmeSBjb3JlIHRoYXQgcmVhZC1vbmx5IGlzIHN1cHBvcnRlZFxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBnZXQgaXNSZWFkT25seVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gITA7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBjdXJyZW50IFRvb2xzYHMgZGF0YVxuICAgKlxuICAgKiBAcmV0dXJucyB7SGVhZGVyRGF0YX0gQ3VycmVudCBkYXRhXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS50ZXh0ID0gdGhpcy5fZWxlbWVudC5pbm5lckhUTUwsIHRoaXMuX2RhdGEubGV2ZWwgPSB0aGlzLmN1cnJlbnRMZXZlbC5udW1iZXIsIHRoaXMuX2RhdGE7XG4gIH1cbiAgLyoqXG4gICAqIFN0b3JlIGRhdGEgaW4gcGx1Z2luOlxuICAgKiAtIGF0IHRoZSB0aGlzLl9kYXRhIHByb3BlcnR5XG4gICAqIC0gYXQgdGhlIEhUTUxcbiAgICpcbiAgICogQHBhcmFtIHtIZWFkZXJEYXRhfSBkYXRhIOKAlCBkYXRhIHRvIHNldFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2V0IGRhdGEoZSkge1xuICAgIGlmICh0aGlzLl9kYXRhID0gdGhpcy5ub3JtYWxpemVEYXRhKGUpLCBlLmxldmVsICE9PSB2b2lkIDAgJiYgdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICBjb25zdCB0ID0gdGhpcy5nZXRUYWcoKTtcbiAgICAgIHQuaW5uZXJIVE1MID0gdGhpcy5fZWxlbWVudC5pbm5lckhUTUwsIHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQodCwgdGhpcy5fZWxlbWVudCksIHRoaXMuX2VsZW1lbnQgPSB0O1xuICAgIH1cbiAgICBlLnRleHQgIT09IHZvaWQgMCAmJiAodGhpcy5fZWxlbWVudC5pbm5lckhUTUwgPSB0aGlzLl9kYXRhLnRleHQgfHwgXCJcIik7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0YWcgZm9yIHRhcmdldCBsZXZlbFxuICAgKiBCeSBkZWZhdWx0IHJldHVybnMgc2Vjb25kLWxldmVsZWQgaGVhZGVyXG4gICAqXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIGdldFRhZygpIHtcbiAgICBjb25zdCBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLmN1cnJlbnRMZXZlbC50YWcpO1xuICAgIHJldHVybiBlLmlubmVySFRNTCA9IHRoaXMuX2RhdGEudGV4dCB8fCBcIlwiLCBlLmNsYXNzTGlzdC5hZGQodGhpcy5fQ1NTLndyYXBwZXIpLCBlLmNvbnRlbnRFZGl0YWJsZSA9IHRoaXMucmVhZE9ubHkgPyBcImZhbHNlXCIgOiBcInRydWVcIiwgZS5kYXRhc2V0LnBsYWNlaG9sZGVyID0gdGhpcy5hcGkuaTE4bi50KHRoaXMuX3NldHRpbmdzLnBsYWNlaG9sZGVyIHx8IFwiXCIpLCBlO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgY3VycmVudCBsZXZlbFxuICAgKlxuICAgKiBAcmV0dXJucyB7bGV2ZWx9XG4gICAqL1xuICBnZXQgY3VycmVudExldmVsKCkge1xuICAgIGxldCBlID0gdGhpcy5sZXZlbHMuZmluZCgodCkgPT4gdC5udW1iZXIgPT09IHRoaXMuX2RhdGEubGV2ZWwpO1xuICAgIHJldHVybiBlIHx8IChlID0gdGhpcy5kZWZhdWx0TGV2ZWwpLCBlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gZGVmYXVsdCBsZXZlbFxuICAgKlxuICAgKiBAcmV0dXJucyB7bGV2ZWx9XG4gICAqL1xuICBnZXQgZGVmYXVsdExldmVsKCkge1xuICAgIGlmICh0aGlzLl9zZXR0aW5ncy5kZWZhdWx0TGV2ZWwpIHtcbiAgICAgIGNvbnN0IGUgPSB0aGlzLmxldmVscy5maW5kKCh0KSA9PiB0Lm51bWJlciA9PT0gdGhpcy5fc2V0dGluZ3MuZGVmYXVsdExldmVsKTtcbiAgICAgIGlmIChlKVxuICAgICAgICByZXR1cm4gZTtcbiAgICAgIGNvbnNvbGUud2FybihcIijguIcnzIAtJ8yBKeC4hyBIZWFkaW5nIFRvb2w6IHRoZSBkZWZhdWx0IGxldmVsIHNwZWNpZmllZCB3YXMgbm90IGZvdW5kIGluIGF2YWlsYWJsZSBsZXZlbHNcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxldmVsc1sxXTtcbiAgfVxuICAvKipcbiAgICogQHR5cGVkZWYge29iamVjdH0gbGV2ZWxcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IG51bWJlciAtIGxldmVsIG51bWJlclxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gdGFnIC0gdGFnIGNvcnJlc3BvbmRzIHdpdGggbGV2ZWwgbnVtYmVyXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzdmcgLSBpY29uXG4gICAqL1xuICAvKipcbiAgICogQXZhaWxhYmxlIGhlYWRlciBsZXZlbHNcbiAgICpcbiAgICogQHJldHVybnMge2xldmVsW119XG4gICAqL1xuICBnZXQgbGV2ZWxzKCkge1xuICAgIGNvbnN0IGUgPSBbXG4gICAgICB7XG4gICAgICAgIG51bWJlcjogMSxcbiAgICAgICAgdGFnOiBcIkgxXCIsXG4gICAgICAgIHN2ZzogYVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbnVtYmVyOiAyLFxuICAgICAgICB0YWc6IFwiSDJcIixcbiAgICAgICAgc3ZnOiBsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBudW1iZXI6IDMsXG4gICAgICAgIHRhZzogXCJIM1wiLFxuICAgICAgICBzdmc6IG9cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG51bWJlcjogNCxcbiAgICAgICAgdGFnOiBcIkg0XCIsXG4gICAgICAgIHN2ZzogaFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbnVtYmVyOiA1LFxuICAgICAgICB0YWc6IFwiSDVcIixcbiAgICAgICAgc3ZnOiBkXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBudW1iZXI6IDYsXG4gICAgICAgIHRhZzogXCJINlwiLFxuICAgICAgICBzdmc6IHVcbiAgICAgIH1cbiAgICBdO1xuICAgIHJldHVybiB0aGlzLl9zZXR0aW5ncy5sZXZlbHMgPyBlLmZpbHRlcihcbiAgICAgICh0KSA9PiB0aGlzLl9zZXR0aW5ncy5sZXZlbHMuaW5jbHVkZXModC5udW1iZXIpXG4gICAgKSA6IGU7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZSBIMS1INiB0YWdzIG9uIHBhc3RlIHRvIHN1YnN0aXR1dGUgaXQgd2l0aCBoZWFkZXIgVG9vbFxuICAgKlxuICAgKiBAcGFyYW0ge1Bhc3RlRXZlbnR9IGV2ZW50IC0gZXZlbnQgd2l0aCBwYXN0ZWQgY29udGVudFxuICAgKi9cbiAgb25QYXN0ZShlKSB7XG4gICAgY29uc3QgdCA9IGUuZGV0YWlsO1xuICAgIGlmIChcImRhdGFcIiBpbiB0KSB7XG4gICAgICBjb25zdCBzID0gdC5kYXRhO1xuICAgICAgbGV0IHIgPSB0aGlzLmRlZmF1bHRMZXZlbC5udW1iZXI7XG4gICAgICBzd2l0Y2ggKHMudGFnTmFtZSkge1xuICAgICAgICBjYXNlIFwiSDFcIjpcbiAgICAgICAgICByID0gMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkgyXCI6XG4gICAgICAgICAgciA9IDI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJIM1wiOlxuICAgICAgICAgIHIgPSAzO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiSDRcIjpcbiAgICAgICAgICByID0gNDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkg1XCI6XG4gICAgICAgICAgciA9IDU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJINlwiOlxuICAgICAgICAgIHIgPSA2O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2V0dGluZ3MubGV2ZWxzICYmIChyID0gdGhpcy5fc2V0dGluZ3MubGV2ZWxzLnJlZHVjZSgobiwgaSkgPT4gTWF0aC5hYnMoaSAtIHIpIDwgTWF0aC5hYnMobiAtIHIpID8gaSA6IG4pKSwgdGhpcy5kYXRhID0ge1xuICAgICAgICBsZXZlbDogcixcbiAgICAgICAgdGV4dDogcy5pbm5lckhUTUxcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBVc2VkIGJ5IEVkaXRvci5qcyBwYXN0ZSBoYW5kbGluZyBBUEkuXG4gICAqIFByb3ZpZGVzIGNvbmZpZ3VyYXRpb24gdG8gaGFuZGxlIEgxLUg2IHRhZ3MuXG4gICAqXG4gICAqIEByZXR1cm5zIHt7aGFuZGxlcjogKGZ1bmN0aW9uKEhUTUxFbGVtZW50KToge3RleHQ6IHN0cmluZ30pLCB0YWdzOiBzdHJpbmdbXX19XG4gICAqL1xuICBzdGF0aWMgZ2V0IHBhc3RlQ29uZmlnKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0YWdzOiBbXCJIMVwiLCBcIkgyXCIsIFwiSDNcIiwgXCJINFwiLCBcIkg1XCIsIFwiSDZcIl1cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBHZXQgVG9vbCB0b29sYm94IHNldHRpbmdzXG4gICAqIGljb24gLSBUb29sIGljb24ncyBTVkdcbiAgICogdGl0bGUgLSB0aXRsZSB0byBzaG93IGluIHRvb2xib3hcbiAgICpcbiAgICogQHJldHVybnMge3tpY29uOiBzdHJpbmcsIHRpdGxlOiBzdHJpbmd9fVxuICAgKi9cbiAgc3RhdGljIGdldCB0b29sYm94KCkge1xuICAgIHJldHVybiB7XG4gICAgICBpY29uOiBnLFxuICAgICAgdGl0bGU6IFwiSGVhZGluZ1wiXG4gICAgfTtcbiAgfVxufVxuZXhwb3J0IHtcbiAgYyBhcyBkZWZhdWx0XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@editorjs/header/dist/header.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@editorjs/list/dist/list.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@editorjs/list/dist/list.mjs ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ d; }\n/* harmony export */ });\n(function(){\"use strict\";try{if(typeof document<\"u\"){var e=document.createElement(\"style\");e.appendChild(document.createTextNode(\".cdx-list{margin:0;padding-left:40px;outline:none}.cdx-list__item{padding:5.5px 0 5.5px 3px;line-height:1.6em}.cdx-list--unordered{list-style:disc}.cdx-list--ordered{list-style:decimal}.cdx-list-settings{display:flex}.cdx-list-settings .cdx-settings-button{width:50%}\")),document.head.appendChild(e)}}catch(t){console.error(\"vite-plugin-css-injected-by-js\",t)}})();\nconst a = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><line x1=\"9\" x2=\"19\" y1=\"7\" y2=\"7\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\"/><line x1=\"9\" x2=\"19\" y1=\"12\" y2=\"12\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\"/><line x1=\"9\" x2=\"19\" y1=\"17\" y2=\"17\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M5.00001 17H4.99002\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M5.00001 12H4.99002\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M5.00001 7H4.99002\"/></svg>', o = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><line x1=\"12\" x2=\"19\" y1=\"7\" y2=\"7\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\"/><line x1=\"12\" x2=\"19\" y1=\"12\" y2=\"12\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\"/><line x1=\"12\" x2=\"19\" y1=\"17\" y2=\"17\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M7.79999 14L7.79999 7.2135C7.79999 7.12872 7.7011 7.0824 7.63597 7.13668L4.79999 9.5\"/></svg>';\nclass d {\n  /**\n   * Notify core that read-only mode is supported\n   *\n   * @returns {boolean}\n   */\n  static get isReadOnlySupported() {\n    return !0;\n  }\n  /**\n   * Allow to use native Enter behaviour\n   *\n   * @returns {boolean}\n   * @public\n   */\n  static get enableLineBreaks() {\n    return !0;\n  }\n  /**\n   * Get Tool toolbox settings\n   * icon - Tool icon's SVG\n   * title - title to show in toolbox\n   *\n   * @returns {{icon: string, title: string}}\n   */\n  static get toolbox() {\n    return {\n      icon: a,\n      title: \"List\"\n    };\n  }\n  /**\n   * Render plugin`s main Element and fill it with saved data\n   *\n   * @param {object} params - tool constructor options\n   * @param {ListData} params.data - previously saved data\n   * @param {object} params.config - user config for Tool\n   * @param {object} params.api - Editor.js API\n   * @param {boolean} params.readOnly - read-only mode flag\n   */\n  constructor({ data: e, config: t, api: r, readOnly: s }) {\n    this._elements = {\n      wrapper: null\n    }, this.api = r, this.readOnly = s, this.settings = [\n      {\n        name: \"unordered\",\n        label: this.api.i18n.t(\"Unordered\"),\n        icon: a,\n        default: t.defaultStyle === \"unordered\" || !1\n      },\n      {\n        name: \"ordered\",\n        label: this.api.i18n.t(\"Ordered\"),\n        icon: o,\n        default: t.defaultStyle === \"ordered\" || !0\n      }\n    ], this._data = {\n      style: this.settings.find((i) => i.default === !0).name,\n      items: []\n    }, this.data = e;\n  }\n  /**\n   * Returns list tag with items\n   *\n   * @returns {Element}\n   * @public\n   */\n  render() {\n    return this._elements.wrapper = this.makeMainTag(this._data.style), this._data.items.length ? this._data.items.forEach((e) => {\n      this._elements.wrapper.appendChild(this._make(\"li\", this.CSS.item, {\n        innerHTML: e\n      }));\n    }) : this._elements.wrapper.appendChild(this._make(\"li\", this.CSS.item)), this.readOnly || this._elements.wrapper.addEventListener(\"keydown\", (e) => {\n      const [t, r] = [13, 8];\n      switch (e.keyCode) {\n        case t:\n          this.getOutofList(e);\n          break;\n        case r:\n          this.backspace(e);\n          break;\n      }\n    }, !1), this._elements.wrapper;\n  }\n  /**\n   * @returns {ListData}\n   * @public\n   */\n  save() {\n    return this.data;\n  }\n  /**\n   * Allow List Tool to be converted to/from other block\n   *\n   * @returns {{export: Function, import: Function}}\n   */\n  static get conversionConfig() {\n    return {\n      /**\n       * To create exported string from list, concatenate items by dot-symbol.\n       *\n       * @param {ListData} data - list data to create a string from thats\n       * @returns {string}\n       */\n      export: (e) => e.items.join(\". \"),\n      /**\n       * To create a list from other block's string, just put it at the first item\n       *\n       * @param {string} string - string to create list tool data from that\n       * @returns {ListData}\n       */\n      import: (e) => ({\n        items: [e],\n        style: \"unordered\"\n      })\n    };\n  }\n  /**\n   * Sanitizer rules\n   *\n   * @returns {object}\n   */\n  static get sanitize() {\n    return {\n      style: {},\n      items: {\n        br: !0\n      }\n    };\n  }\n  /**\n   * Settings\n   *\n   * @public\n   * @returns {Array}\n   */\n  renderSettings() {\n    return this.settings.map((e) => ({\n      ...e,\n      isActive: this._data.style === e.name,\n      closeOnActivate: !0,\n      onActivate: () => this.toggleTune(e.name)\n    }));\n  }\n  /**\n   * On paste callback that is fired from Editor\n   *\n   * @param {PasteEvent} event - event with pasted data\n   */\n  onPaste(e) {\n    const t = e.detail.data;\n    this.data = this.pasteHandler(t);\n  }\n  /**\n   * List Tool on paste configuration\n   *\n   * @public\n   */\n  static get pasteConfig() {\n    return {\n      tags: [\"OL\", \"UL\", \"LI\"]\n    };\n  }\n  /**\n   * Creates main <ul> or <ol> tag depended on style\n   *\n   * @param {string} style - 'ordered' or 'unordered'\n   * @returns {HTMLOListElement|HTMLUListElement}\n   */\n  makeMainTag(e) {\n    const t = e === \"ordered\" ? this.CSS.wrapperOrdered : this.CSS.wrapperUnordered, r = e === \"ordered\" ? \"ol\" : \"ul\";\n    return this._make(r, [this.CSS.baseBlock, this.CSS.wrapper, t], {\n      contentEditable: !this.readOnly\n    });\n  }\n  /**\n   * Toggles List style\n   *\n   * @param {string} style - 'ordered'|'unordered'\n   */\n  toggleTune(e) {\n    const t = this.makeMainTag(e);\n    for (; this._elements.wrapper.hasChildNodes(); )\n      t.appendChild(this._elements.wrapper.firstChild);\n    this._elements.wrapper.replaceWith(t), this._elements.wrapper = t, this._data.style = e;\n  }\n  /**\n   * Styles\n   *\n   * @private\n   */\n  get CSS() {\n    return {\n      baseBlock: this.api.styles.block,\n      wrapper: \"cdx-list\",\n      wrapperOrdered: \"cdx-list--ordered\",\n      wrapperUnordered: \"cdx-list--unordered\",\n      item: \"cdx-list__item\"\n    };\n  }\n  /**\n   * List data setter\n   *\n   * @param {ListData} listData\n   */\n  set data(e) {\n    e || (e = {}), this._data.style = e.style || this.settings.find((r) => r.default === !0).name, this._data.items = e.items || [];\n    const t = this._elements.wrapper;\n    t && t.parentNode.replaceChild(this.render(), t);\n  }\n  /**\n   * Return List data\n   *\n   * @returns {ListData}\n   */\n  get data() {\n    this._data.items = [];\n    const e = this._elements.wrapper.querySelectorAll(`.${this.CSS.item}`);\n    for (let t = 0; t < e.length; t++)\n      e[t].innerHTML.replace(\"<br>\", \" \").trim() && this._data.items.push(e[t].innerHTML);\n    return this._data;\n  }\n  /**\n   * Helper for making Elements with attributes\n   *\n   * @param  {string} tagName           - new Element tag name\n   * @param  {Array|string} classNames  - list or name of CSS classname(s)\n   * @param  {object} attributes        - any attributes\n   * @returns {Element}\n   */\n  _make(e, t = null, r = {}) {\n    const s = document.createElement(e);\n    Array.isArray(t) ? s.classList.add(...t) : t && s.classList.add(t);\n    for (const i in r)\n      s[i] = r[i];\n    return s;\n  }\n  /**\n   * Returns current List item by the caret position\n   *\n   * @returns {Element}\n   */\n  get currentItem() {\n    let e = window.getSelection().anchorNode;\n    return e.nodeType !== Node.ELEMENT_NODE && (e = e.parentNode), e.closest(`.${this.CSS.item}`);\n  }\n  /**\n   * Get out from List Tool\n   * by Enter on the empty last item\n   *\n   * @param {KeyboardEvent} event\n   */\n  getOutofList(e) {\n    const t = this._elements.wrapper.querySelectorAll(\".\" + this.CSS.item);\n    if (t.length < 2)\n      return;\n    const r = t[t.length - 1], s = this.currentItem;\n    s === r && !r.textContent.trim().length && (s.parentElement.removeChild(s), this.api.blocks.insert(), this.api.caret.setToBlock(this.api.blocks.getCurrentBlockIndex()), e.preventDefault(), e.stopPropagation());\n  }\n  /**\n   * Handle backspace\n   *\n   * @param {KeyboardEvent} event\n   */\n  backspace(e) {\n    const t = this._elements.wrapper.querySelectorAll(\".\" + this.CSS.item), r = t[0];\n    r && t.length < 2 && !r.innerHTML.replace(\"<br>\", \" \").trim() && e.preventDefault();\n  }\n  /**\n   * Select LI content by CMD+A\n   *\n   * @param {KeyboardEvent} event\n   */\n  selectItem(e) {\n    e.preventDefault();\n    const t = window.getSelection(), r = t.anchorNode.parentNode, s = r.closest(\".\" + this.CSS.item), i = new Range();\n    i.selectNodeContents(s), t.removeAllRanges(), t.addRange(i);\n  }\n  /**\n   * Handle UL, OL and LI tags paste and returns List data\n   *\n   * @param {HTMLUListElement|HTMLOListElement|HTMLLIElement} element\n   * @returns {ListData}\n   */\n  pasteHandler(e) {\n    const { tagName: t } = e;\n    let r;\n    switch (t) {\n      case \"OL\":\n        r = \"ordered\";\n        break;\n      case \"UL\":\n      case \"LI\":\n        r = \"unordered\";\n    }\n    const s = {\n      style: r,\n      items: []\n    };\n    if (t === \"LI\")\n      s.items = [e.innerHTML];\n    else {\n      const i = Array.from(e.querySelectorAll(\"LI\"));\n      s.items = i.map((n) => n.innerHTML).filter((n) => !!n.trim());\n    }\n    return s;\n  }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZWRpdG9yanMvbGlzdC9kaXN0L2xpc3QubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxZQUFZLGFBQWEsSUFBSSx3QkFBd0Isc0NBQXNDLGlEQUFpRCxTQUFTLGtCQUFrQixhQUFhLGdCQUFnQiwwQkFBMEIsa0JBQWtCLHFCQUFxQixnQkFBZ0IsbUJBQW1CLG1CQUFtQixtQkFBbUIsYUFBYSx3Q0FBd0MsVUFBVSxrQ0FBa0MsU0FBUyxtREFBbUQ7QUFDM2U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQSxnQkFBZ0IseUNBQXlDO0FBQ3pEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixVQUFVO0FBQzNCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekIsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0EsV0FBVyx3Q0FBd0M7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsY0FBYztBQUN4RSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxjQUFjO0FBQzVCLGNBQWMsUUFBUTtBQUN0QixlQUFlO0FBQ2Y7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRixjQUFjO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaURBQWlEO0FBQzlELGVBQWU7QUFDZjtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BlZGl0b3Jqcy9saXN0L2Rpc3QvbGlzdC5tanM/MjU1OCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt0cnl7aWYodHlwZW9mIGRvY3VtZW50PFwidVwiKXt2YXIgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7ZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIi5jZHgtbGlzdHttYXJnaW46MDtwYWRkaW5nLWxlZnQ6NDBweDtvdXRsaW5lOm5vbmV9LmNkeC1saXN0X19pdGVte3BhZGRpbmc6NS41cHggMCA1LjVweCAzcHg7bGluZS1oZWlnaHQ6MS42ZW19LmNkeC1saXN0LS11bm9yZGVyZWR7bGlzdC1zdHlsZTpkaXNjfS5jZHgtbGlzdC0tb3JkZXJlZHtsaXN0LXN0eWxlOmRlY2ltYWx9LmNkeC1saXN0LXNldHRpbmdze2Rpc3BsYXk6ZmxleH0uY2R4LWxpc3Qtc2V0dGluZ3MgLmNkeC1zZXR0aW5ncy1idXR0b257d2lkdGg6NTAlfVwiKSksZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChlKX19Y2F0Y2godCl7Y29uc29sZS5lcnJvcihcInZpdGUtcGx1Z2luLWNzcy1pbmplY3RlZC1ieS1qc1wiLHQpfX0pKCk7XG5jb25zdCBhID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxsaW5lIHgxPVwiOVwiIHgyPVwiMTlcIiB5MT1cIjdcIiB5Mj1cIjdcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiLz48bGluZSB4MT1cIjlcIiB4Mj1cIjE5XCIgeTE9XCIxMlwiIHkyPVwiMTJcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiLz48bGluZSB4MT1cIjlcIiB4Mj1cIjE5XCIgeTE9XCIxN1wiIHkyPVwiMTdcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNNS4wMDAwMSAxN0g0Ljk5MDAyXCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk01LjAwMDAxIDEySDQuOTkwMDJcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTUuMDAwMDEgN0g0Ljk5MDAyXCIvPjwvc3ZnPicsIG8gPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PGxpbmUgeDE9XCIxMlwiIHgyPVwiMTlcIiB5MT1cIjdcIiB5Mj1cIjdcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiLz48bGluZSB4MT1cIjEyXCIgeDI9XCIxOVwiIHkxPVwiMTJcIiB5Mj1cIjEyXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIi8+PGxpbmUgeDE9XCIxMlwiIHgyPVwiMTlcIiB5MT1cIjE3XCIgeTI9XCIxN1wiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk03Ljc5OTk5IDE0TDcuNzk5OTkgNy4yMTM1QzcuNzk5OTkgNy4xMjg3MiA3LjcwMTEgNy4wODI0IDcuNjM1OTcgNy4xMzY2OEw0Ljc5OTk5IDkuNVwiLz48L3N2Zz4nO1xuY2xhc3MgZCB7XG4gIC8qKlxuICAgKiBOb3RpZnkgY29yZSB0aGF0IHJlYWQtb25seSBtb2RlIGlzIHN1cHBvcnRlZFxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBnZXQgaXNSZWFkT25seVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gITA7XG4gIH1cbiAgLyoqXG4gICAqIEFsbG93IHRvIHVzZSBuYXRpdmUgRW50ZXIgYmVoYXZpb3VyXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKiBAcHVibGljXG4gICAqL1xuICBzdGF0aWMgZ2V0IGVuYWJsZUxpbmVCcmVha3MoKSB7XG4gICAgcmV0dXJuICEwO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgVG9vbCB0b29sYm94IHNldHRpbmdzXG4gICAqIGljb24gLSBUb29sIGljb24ncyBTVkdcbiAgICogdGl0bGUgLSB0aXRsZSB0byBzaG93IGluIHRvb2xib3hcbiAgICpcbiAgICogQHJldHVybnMge3tpY29uOiBzdHJpbmcsIHRpdGxlOiBzdHJpbmd9fVxuICAgKi9cbiAgc3RhdGljIGdldCB0b29sYm94KCkge1xuICAgIHJldHVybiB7XG4gICAgICBpY29uOiBhLFxuICAgICAgdGl0bGU6IFwiTGlzdFwiXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmVuZGVyIHBsdWdpbmBzIG1haW4gRWxlbWVudCBhbmQgZmlsbCBpdCB3aXRoIHNhdmVkIGRhdGFcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIHRvb2wgY29uc3RydWN0b3Igb3B0aW9uc1xuICAgKiBAcGFyYW0ge0xpc3REYXRhfSBwYXJhbXMuZGF0YSAtIHByZXZpb3VzbHkgc2F2ZWQgZGF0YVxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zLmNvbmZpZyAtIHVzZXIgY29uZmlnIGZvciBUb29sXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMuYXBpIC0gRWRpdG9yLmpzIEFQSVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5yZWFkT25seSAtIHJlYWQtb25seSBtb2RlIGZsYWdcbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgZGF0YTogZSwgY29uZmlnOiB0LCBhcGk6IHIsIHJlYWRPbmx5OiBzIH0pIHtcbiAgICB0aGlzLl9lbGVtZW50cyA9IHtcbiAgICAgIHdyYXBwZXI6IG51bGxcbiAgICB9LCB0aGlzLmFwaSA9IHIsIHRoaXMucmVhZE9ubHkgPSBzLCB0aGlzLnNldHRpbmdzID0gW1xuICAgICAge1xuICAgICAgICBuYW1lOiBcInVub3JkZXJlZFwiLFxuICAgICAgICBsYWJlbDogdGhpcy5hcGkuaTE4bi50KFwiVW5vcmRlcmVkXCIpLFxuICAgICAgICBpY29uOiBhLFxuICAgICAgICBkZWZhdWx0OiB0LmRlZmF1bHRTdHlsZSA9PT0gXCJ1bm9yZGVyZWRcIiB8fCAhMVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJvcmRlcmVkXCIsXG4gICAgICAgIGxhYmVsOiB0aGlzLmFwaS5pMThuLnQoXCJPcmRlcmVkXCIpLFxuICAgICAgICBpY29uOiBvLFxuICAgICAgICBkZWZhdWx0OiB0LmRlZmF1bHRTdHlsZSA9PT0gXCJvcmRlcmVkXCIgfHwgITBcbiAgICAgIH1cbiAgICBdLCB0aGlzLl9kYXRhID0ge1xuICAgICAgc3R5bGU6IHRoaXMuc2V0dGluZ3MuZmluZCgoaSkgPT4gaS5kZWZhdWx0ID09PSAhMCkubmFtZSxcbiAgICAgIGl0ZW1zOiBbXVxuICAgIH0sIHRoaXMuZGF0YSA9IGU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgbGlzdCB0YWcgd2l0aCBpdGVtc1xuICAgKlxuICAgKiBAcmV0dXJucyB7RWxlbWVudH1cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9lbGVtZW50cy53cmFwcGVyID0gdGhpcy5tYWtlTWFpblRhZyh0aGlzLl9kYXRhLnN0eWxlKSwgdGhpcy5fZGF0YS5pdGVtcy5sZW5ndGggPyB0aGlzLl9kYXRhLml0ZW1zLmZvckVhY2goKGUpID0+IHtcbiAgICAgIHRoaXMuX2VsZW1lbnRzLndyYXBwZXIuYXBwZW5kQ2hpbGQodGhpcy5fbWFrZShcImxpXCIsIHRoaXMuQ1NTLml0ZW0sIHtcbiAgICAgICAgaW5uZXJIVE1MOiBlXG4gICAgICB9KSk7XG4gICAgfSkgOiB0aGlzLl9lbGVtZW50cy53cmFwcGVyLmFwcGVuZENoaWxkKHRoaXMuX21ha2UoXCJsaVwiLCB0aGlzLkNTUy5pdGVtKSksIHRoaXMucmVhZE9ubHkgfHwgdGhpcy5fZWxlbWVudHMud3JhcHBlci5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCAoZSkgPT4ge1xuICAgICAgY29uc3QgW3QsIHJdID0gWzEzLCA4XTtcbiAgICAgIHN3aXRjaCAoZS5rZXlDb2RlKSB7XG4gICAgICAgIGNhc2UgdDpcbiAgICAgICAgICB0aGlzLmdldE91dG9mTGlzdChlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSByOlxuICAgICAgICAgIHRoaXMuYmFja3NwYWNlKGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0sICExKSwgdGhpcy5fZWxlbWVudHMud3JhcHBlcjtcbiAgfVxuICAvKipcbiAgICogQHJldHVybnMge0xpc3REYXRhfVxuICAgKiBAcHVibGljXG4gICAqL1xuICBzYXZlKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGE7XG4gIH1cbiAgLyoqXG4gICAqIEFsbG93IExpc3QgVG9vbCB0byBiZSBjb252ZXJ0ZWQgdG8vZnJvbSBvdGhlciBibG9ja1xuICAgKlxuICAgKiBAcmV0dXJucyB7e2V4cG9ydDogRnVuY3Rpb24sIGltcG9ydDogRnVuY3Rpb259fVxuICAgKi9cbiAgc3RhdGljIGdldCBjb252ZXJzaW9uQ29uZmlnKCkge1xuICAgIHJldHVybiB7XG4gICAgICAvKipcbiAgICAgICAqIFRvIGNyZWF0ZSBleHBvcnRlZCBzdHJpbmcgZnJvbSBsaXN0LCBjb25jYXRlbmF0ZSBpdGVtcyBieSBkb3Qtc3ltYm9sLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7TGlzdERhdGF9IGRhdGEgLSBsaXN0IGRhdGEgdG8gY3JlYXRlIGEgc3RyaW5nIGZyb20gdGhhdHNcbiAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICAgKi9cbiAgICAgIGV4cG9ydDogKGUpID0+IGUuaXRlbXMuam9pbihcIi4gXCIpLFxuICAgICAgLyoqXG4gICAgICAgKiBUbyBjcmVhdGUgYSBsaXN0IGZyb20gb3RoZXIgYmxvY2sncyBzdHJpbmcsIGp1c3QgcHV0IGl0IGF0IHRoZSBmaXJzdCBpdGVtXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyAtIHN0cmluZyB0byBjcmVhdGUgbGlzdCB0b29sIGRhdGEgZnJvbSB0aGF0XG4gICAgICAgKiBAcmV0dXJucyB7TGlzdERhdGF9XG4gICAgICAgKi9cbiAgICAgIGltcG9ydDogKGUpID0+ICh7XG4gICAgICAgIGl0ZW1zOiBbZV0sXG4gICAgICAgIHN0eWxlOiBcInVub3JkZXJlZFwiXG4gICAgICB9KVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFNhbml0aXplciBydWxlc1xuICAgKlxuICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBzYW5pdGl6ZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3R5bGU6IHt9LFxuICAgICAgaXRlbXM6IHtcbiAgICAgICAgYnI6ICEwXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogU2V0dGluZ3NcbiAgICpcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAqL1xuICByZW5kZXJTZXR0aW5ncygpIHtcbiAgICByZXR1cm4gdGhpcy5zZXR0aW5ncy5tYXAoKGUpID0+ICh7XG4gICAgICAuLi5lLFxuICAgICAgaXNBY3RpdmU6IHRoaXMuX2RhdGEuc3R5bGUgPT09IGUubmFtZSxcbiAgICAgIGNsb3NlT25BY3RpdmF0ZTogITAsXG4gICAgICBvbkFjdGl2YXRlOiAoKSA9PiB0aGlzLnRvZ2dsZVR1bmUoZS5uYW1lKVxuICAgIH0pKTtcbiAgfVxuICAvKipcbiAgICogT24gcGFzdGUgY2FsbGJhY2sgdGhhdCBpcyBmaXJlZCBmcm9tIEVkaXRvclxuICAgKlxuICAgKiBAcGFyYW0ge1Bhc3RlRXZlbnR9IGV2ZW50IC0gZXZlbnQgd2l0aCBwYXN0ZWQgZGF0YVxuICAgKi9cbiAgb25QYXN0ZShlKSB7XG4gICAgY29uc3QgdCA9IGUuZGV0YWlsLmRhdGE7XG4gICAgdGhpcy5kYXRhID0gdGhpcy5wYXN0ZUhhbmRsZXIodCk7XG4gIH1cbiAgLyoqXG4gICAqIExpc3QgVG9vbCBvbiBwYXN0ZSBjb25maWd1cmF0aW9uXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHN0YXRpYyBnZXQgcGFzdGVDb25maWcoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRhZ3M6IFtcIk9MXCIsIFwiVUxcIiwgXCJMSVwiXVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFpbiA8dWw+IG9yIDxvbD4gdGFnIGRlcGVuZGVkIG9uIHN0eWxlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHlsZSAtICdvcmRlcmVkJyBvciAndW5vcmRlcmVkJ1xuICAgKiBAcmV0dXJucyB7SFRNTE9MaXN0RWxlbWVudHxIVE1MVUxpc3RFbGVtZW50fVxuICAgKi9cbiAgbWFrZU1haW5UYWcoZSkge1xuICAgIGNvbnN0IHQgPSBlID09PSBcIm9yZGVyZWRcIiA/IHRoaXMuQ1NTLndyYXBwZXJPcmRlcmVkIDogdGhpcy5DU1Mud3JhcHBlclVub3JkZXJlZCwgciA9IGUgPT09IFwib3JkZXJlZFwiID8gXCJvbFwiIDogXCJ1bFwiO1xuICAgIHJldHVybiB0aGlzLl9tYWtlKHIsIFt0aGlzLkNTUy5iYXNlQmxvY2ssIHRoaXMuQ1NTLndyYXBwZXIsIHRdLCB7XG4gICAgICBjb250ZW50RWRpdGFibGU6ICF0aGlzLnJlYWRPbmx5XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFRvZ2dsZXMgTGlzdCBzdHlsZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3R5bGUgLSAnb3JkZXJlZCd8J3Vub3JkZXJlZCdcbiAgICovXG4gIHRvZ2dsZVR1bmUoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLm1ha2VNYWluVGFnKGUpO1xuICAgIGZvciAoOyB0aGlzLl9lbGVtZW50cy53cmFwcGVyLmhhc0NoaWxkTm9kZXMoKTsgKVxuICAgICAgdC5hcHBlbmRDaGlsZCh0aGlzLl9lbGVtZW50cy53cmFwcGVyLmZpcnN0Q2hpbGQpO1xuICAgIHRoaXMuX2VsZW1lbnRzLndyYXBwZXIucmVwbGFjZVdpdGgodCksIHRoaXMuX2VsZW1lbnRzLndyYXBwZXIgPSB0LCB0aGlzLl9kYXRhLnN0eWxlID0gZTtcbiAgfVxuICAvKipcbiAgICogU3R5bGVzXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXQgQ1NTKCkge1xuICAgIHJldHVybiB7XG4gICAgICBiYXNlQmxvY2s6IHRoaXMuYXBpLnN0eWxlcy5ibG9jayxcbiAgICAgIHdyYXBwZXI6IFwiY2R4LWxpc3RcIixcbiAgICAgIHdyYXBwZXJPcmRlcmVkOiBcImNkeC1saXN0LS1vcmRlcmVkXCIsXG4gICAgICB3cmFwcGVyVW5vcmRlcmVkOiBcImNkeC1saXN0LS11bm9yZGVyZWRcIixcbiAgICAgIGl0ZW06IFwiY2R4LWxpc3RfX2l0ZW1cIlxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIExpc3QgZGF0YSBzZXR0ZXJcbiAgICpcbiAgICogQHBhcmFtIHtMaXN0RGF0YX0gbGlzdERhdGFcbiAgICovXG4gIHNldCBkYXRhKGUpIHtcbiAgICBlIHx8IChlID0ge30pLCB0aGlzLl9kYXRhLnN0eWxlID0gZS5zdHlsZSB8fCB0aGlzLnNldHRpbmdzLmZpbmQoKHIpID0+IHIuZGVmYXVsdCA9PT0gITApLm5hbWUsIHRoaXMuX2RhdGEuaXRlbXMgPSBlLml0ZW1zIHx8IFtdO1xuICAgIGNvbnN0IHQgPSB0aGlzLl9lbGVtZW50cy53cmFwcGVyO1xuICAgIHQgJiYgdC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCB0KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIExpc3QgZGF0YVxuICAgKlxuICAgKiBAcmV0dXJucyB7TGlzdERhdGF9XG4gICAqL1xuICBnZXQgZGF0YSgpIHtcbiAgICB0aGlzLl9kYXRhLml0ZW1zID0gW107XG4gICAgY29uc3QgZSA9IHRoaXMuX2VsZW1lbnRzLndyYXBwZXIucXVlcnlTZWxlY3RvckFsbChgLiR7dGhpcy5DU1MuaXRlbX1gKTtcbiAgICBmb3IgKGxldCB0ID0gMDsgdCA8IGUubGVuZ3RoOyB0KyspXG4gICAgICBlW3RdLmlubmVySFRNTC5yZXBsYWNlKFwiPGJyPlwiLCBcIiBcIikudHJpbSgpICYmIHRoaXMuX2RhdGEuaXRlbXMucHVzaChlW3RdLmlubmVySFRNTCk7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gIH1cbiAgLyoqXG4gICAqIEhlbHBlciBmb3IgbWFraW5nIEVsZW1lbnRzIHdpdGggYXR0cmlidXRlc1xuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHRhZ05hbWUgICAgICAgICAgIC0gbmV3IEVsZW1lbnQgdGFnIG5hbWVcbiAgICogQHBhcmFtICB7QXJyYXl8c3RyaW5nfSBjbGFzc05hbWVzICAtIGxpc3Qgb3IgbmFtZSBvZiBDU1MgY2xhc3NuYW1lKHMpXG4gICAqIEBwYXJhbSAge29iamVjdH0gYXR0cmlidXRlcyAgICAgICAgLSBhbnkgYXR0cmlidXRlc1xuICAgKiBAcmV0dXJucyB7RWxlbWVudH1cbiAgICovXG4gIF9tYWtlKGUsIHQgPSBudWxsLCByID0ge30pIHtcbiAgICBjb25zdCBzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChlKTtcbiAgICBBcnJheS5pc0FycmF5KHQpID8gcy5jbGFzc0xpc3QuYWRkKC4uLnQpIDogdCAmJiBzLmNsYXNzTGlzdC5hZGQodCk7XG4gICAgZm9yIChjb25zdCBpIGluIHIpXG4gICAgICBzW2ldID0gcltpXTtcbiAgICByZXR1cm4gcztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBjdXJyZW50IExpc3QgaXRlbSBieSB0aGUgY2FyZXQgcG9zaXRpb25cbiAgICpcbiAgICogQHJldHVybnMge0VsZW1lbnR9XG4gICAqL1xuICBnZXQgY3VycmVudEl0ZW0oKSB7XG4gICAgbGV0IGUgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCkuYW5jaG9yTm9kZTtcbiAgICByZXR1cm4gZS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUgJiYgKGUgPSBlLnBhcmVudE5vZGUpLCBlLmNsb3Nlc3QoYC4ke3RoaXMuQ1NTLml0ZW19YCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBvdXQgZnJvbSBMaXN0IFRvb2xcbiAgICogYnkgRW50ZXIgb24gdGhlIGVtcHR5IGxhc3QgaXRlbVxuICAgKlxuICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2ZW50XG4gICAqL1xuICBnZXRPdXRvZkxpc3QoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9lbGVtZW50cy53cmFwcGVyLnF1ZXJ5U2VsZWN0b3JBbGwoXCIuXCIgKyB0aGlzLkNTUy5pdGVtKTtcbiAgICBpZiAodC5sZW5ndGggPCAyKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHIgPSB0W3QubGVuZ3RoIC0gMV0sIHMgPSB0aGlzLmN1cnJlbnRJdGVtO1xuICAgIHMgPT09IHIgJiYgIXIudGV4dENvbnRlbnQudHJpbSgpLmxlbmd0aCAmJiAocy5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKHMpLCB0aGlzLmFwaS5ibG9ja3MuaW5zZXJ0KCksIHRoaXMuYXBpLmNhcmV0LnNldFRvQmxvY2sodGhpcy5hcGkuYmxvY2tzLmdldEN1cnJlbnRCbG9ja0luZGV4KCkpLCBlLnByZXZlbnREZWZhdWx0KCksIGUuc3RvcFByb3BhZ2F0aW9uKCkpO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGUgYmFja3NwYWNlXG4gICAqXG4gICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnRcbiAgICovXG4gIGJhY2tzcGFjZShlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2VsZW1lbnRzLndyYXBwZXIucXVlcnlTZWxlY3RvckFsbChcIi5cIiArIHRoaXMuQ1NTLml0ZW0pLCByID0gdFswXTtcbiAgICByICYmIHQubGVuZ3RoIDwgMiAmJiAhci5pbm5lckhUTUwucmVwbGFjZShcIjxicj5cIiwgXCIgXCIpLnRyaW0oKSAmJiBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgLyoqXG4gICAqIFNlbGVjdCBMSSBjb250ZW50IGJ5IENNRCtBXG4gICAqXG4gICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnRcbiAgICovXG4gIHNlbGVjdEl0ZW0oZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBjb25zdCB0ID0gd2luZG93LmdldFNlbGVjdGlvbigpLCByID0gdC5hbmNob3JOb2RlLnBhcmVudE5vZGUsIHMgPSByLmNsb3Nlc3QoXCIuXCIgKyB0aGlzLkNTUy5pdGVtKSwgaSA9IG5ldyBSYW5nZSgpO1xuICAgIGkuc2VsZWN0Tm9kZUNvbnRlbnRzKHMpLCB0LnJlbW92ZUFsbFJhbmdlcygpLCB0LmFkZFJhbmdlKGkpO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGUgVUwsIE9MIGFuZCBMSSB0YWdzIHBhc3RlIGFuZCByZXR1cm5zIExpc3QgZGF0YVxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxVTGlzdEVsZW1lbnR8SFRNTE9MaXN0RWxlbWVudHxIVE1MTElFbGVtZW50fSBlbGVtZW50XG4gICAqIEByZXR1cm5zIHtMaXN0RGF0YX1cbiAgICovXG4gIHBhc3RlSGFuZGxlcihlKSB7XG4gICAgY29uc3QgeyB0YWdOYW1lOiB0IH0gPSBlO1xuICAgIGxldCByO1xuICAgIHN3aXRjaCAodCkge1xuICAgICAgY2FzZSBcIk9MXCI6XG4gICAgICAgIHIgPSBcIm9yZGVyZWRcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiVUxcIjpcbiAgICAgIGNhc2UgXCJMSVwiOlxuICAgICAgICByID0gXCJ1bm9yZGVyZWRcIjtcbiAgICB9XG4gICAgY29uc3QgcyA9IHtcbiAgICAgIHN0eWxlOiByLFxuICAgICAgaXRlbXM6IFtdXG4gICAgfTtcbiAgICBpZiAodCA9PT0gXCJMSVwiKVxuICAgICAgcy5pdGVtcyA9IFtlLmlubmVySFRNTF07XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBpID0gQXJyYXkuZnJvbShlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJMSVwiKSk7XG4gICAgICBzLml0ZW1zID0gaS5tYXAoKG4pID0+IG4uaW5uZXJIVE1MKS5maWx0ZXIoKG4pID0+ICEhbi50cmltKCkpO1xuICAgIH1cbiAgICByZXR1cm4gcztcbiAgfVxufVxuZXhwb3J0IHtcbiAgZCBhcyBkZWZhdWx0XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@editorjs/list/dist/list.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@editorjs/marker/dist/marker.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@editorjs/marker/dist/marker.mjs ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ s; }\n/* harmony export */ });\n(function(){\"use strict\";try{if(typeof document<\"u\"){var e=document.createElement(\"style\");e.appendChild(document.createTextNode(\".cdx-marker{background:rgba(245,235,111,.29);padding:3px 0}\")),document.head.appendChild(e)}}catch(d){console.error(\"vite-plugin-css-injected-by-js\",d)}})();\nconst o = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-width=\"2\" d=\"M11.3536 9.31802L12.7678 7.90381C13.5488 7.12276 14.8151 7.12276 15.5962 7.90381C16.3772 8.68486 16.3772 9.95119 15.5962 10.7322L14.182 12.1464M11.3536 9.31802L7.96729 12.7043C7.40889 13.2627 7.02827 13.9739 6.8734 14.7482L6.69798 15.6253C6.55804 16.325 7.17496 16.942 7.87468 16.802L8.75176 16.6266C9.52612 16.4717 10.2373 16.0911 10.7957 15.5327L14.182 12.1464M11.3536 9.31802L14.182 12.1464\"/><line x1=\"15\" x2=\"19\" y1=\"17\" y2=\"17\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\"/></svg>';\nclass s {\n  /**\n   * Class name for term-tag\n   *\n   * @type {string}\n   */\n  static get CSS() {\n    return \"cdx-marker\";\n  }\n  /**\n   * @param {{api: object}}  - Editor.js API\n   */\n  constructor({ api: t }) {\n    this.api = t, this.button = null, this.tag = \"MARK\", this.iconClasses = {\n      base: this.api.styles.inlineToolButton,\n      active: this.api.styles.inlineToolButtonActive\n    };\n  }\n  /**\n   * Specifies Tool as Inline Toolbar Tool\n   *\n   * @return {boolean}\n   */\n  static get isInline() {\n    return !0;\n  }\n  /**\n   * Create button element for Toolbar\n   *\n   * @return {HTMLElement}\n   */\n  render() {\n    return this.button = document.createElement(\"button\"), this.button.type = \"button\", this.button.classList.add(this.iconClasses.base), this.button.innerHTML = this.toolboxIcon, this.button;\n  }\n  /**\n   * Wrap/Unwrap selected fragment\n   *\n   * @param {Range} range - selected fragment\n   */\n  surround(t) {\n    if (!t)\n      return;\n    let e = this.api.selection.findParentTag(this.tag, s.CSS);\n    e ? this.unwrap(e) : this.wrap(t);\n  }\n  /**\n   * Wrap selection with term-tag\n   *\n   * @param {Range} range - selected fragment\n   */\n  wrap(t) {\n    let e = document.createElement(this.tag);\n    e.classList.add(s.CSS), e.appendChild(t.extractContents()), t.insertNode(e), this.api.selection.expandToTag(e);\n  }\n  /**\n   * Unwrap term-tag\n   *\n   * @param {HTMLElement} termWrapper - term wrapper tag\n   */\n  unwrap(t) {\n    this.api.selection.expandToTag(t);\n    let e = window.getSelection(), n = e.getRangeAt(0), i = n.extractContents();\n    t.parentNode.removeChild(t), n.insertNode(i), e.removeAllRanges(), e.addRange(n);\n  }\n  /**\n   * Check and change Term's state for current selection\n   */\n  checkState() {\n    const t = this.api.selection.findParentTag(this.tag, s.CSS);\n    this.button.classList.toggle(this.iconClasses.active, !!t);\n  }\n  /**\n   * Get Tool icon's SVG\n   * @return {string}\n   */\n  get toolboxIcon() {\n    return o;\n  }\n  /**\n   * Sanitizer rule\n   * @return {{mark: {class: string}}}\n   */\n  static get sanitize() {\n    return {\n      mark: {\n        class: s.CSS\n      }\n    };\n  }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZWRpdG9yanMvbWFya2VyL2Rpc3QvbWFya2VyLm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsWUFBWSxhQUFhLElBQUksd0JBQXdCLHNDQUFzQyxtREFBbUQsaUNBQWlDLGNBQWMsa0NBQWtDLFNBQVMsbURBQW1EO0FBQzNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZUFBZTtBQUM3QjtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AZWRpdG9yanMvbWFya2VyL2Rpc3QvbWFya2VyLm1qcz81NWY3Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO3RyeXtpZih0eXBlb2YgZG9jdW1lbnQ8XCJ1XCIpe3ZhciBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiLmNkeC1tYXJrZXJ7YmFja2dyb3VuZDpyZ2JhKDI0NSwyMzUsMTExLC4yOSk7cGFkZGluZzozcHggMH1cIikpLGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoZSl9fWNhdGNoKGQpe2NvbnNvbGUuZXJyb3IoXCJ2aXRlLXBsdWdpbi1jc3MtaW5qZWN0ZWQtYnktanNcIixkKX19KSgpO1xuY29uc3QgbyA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk0xMS4zNTM2IDkuMzE4MDJMMTIuNzY3OCA3LjkwMzgxQzEzLjU0ODggNy4xMjI3NiAxNC44MTUxIDcuMTIyNzYgMTUuNTk2MiA3LjkwMzgxQzE2LjM3NzIgOC42ODQ4NiAxNi4zNzcyIDkuOTUxMTkgMTUuNTk2MiAxMC43MzIyTDE0LjE4MiAxMi4xNDY0TTExLjM1MzYgOS4zMTgwMkw3Ljk2NzI5IDEyLjcwNDNDNy40MDg4OSAxMy4yNjI3IDcuMDI4MjcgMTMuOTczOSA2Ljg3MzQgMTQuNzQ4Mkw2LjY5Nzk4IDE1LjYyNTNDNi41NTgwNCAxNi4zMjUgNy4xNzQ5NiAxNi45NDIgNy44NzQ2OCAxNi44MDJMOC43NTE3NiAxNi42MjY2QzkuNTI2MTIgMTYuNDcxNyAxMC4yMzczIDE2LjA5MTEgMTAuNzk1NyAxNS41MzI3TDE0LjE4MiAxMi4xNDY0TTExLjM1MzYgOS4zMTgwMkwxNC4xODIgMTIuMTQ2NFwiLz48bGluZSB4MT1cIjE1XCIgeDI9XCIxOVwiIHkxPVwiMTdcIiB5Mj1cIjE3XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIi8+PC9zdmc+JztcbmNsYXNzIHMge1xuICAvKipcbiAgICogQ2xhc3MgbmFtZSBmb3IgdGVybS10YWdcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBnZXQgQ1NTKCkge1xuICAgIHJldHVybiBcImNkeC1tYXJrZXJcIjtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHt7YXBpOiBvYmplY3R9fSAgLSBFZGl0b3IuanMgQVBJXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGFwaTogdCB9KSB7XG4gICAgdGhpcy5hcGkgPSB0LCB0aGlzLmJ1dHRvbiA9IG51bGwsIHRoaXMudGFnID0gXCJNQVJLXCIsIHRoaXMuaWNvbkNsYXNzZXMgPSB7XG4gICAgICBiYXNlOiB0aGlzLmFwaS5zdHlsZXMuaW5saW5lVG9vbEJ1dHRvbixcbiAgICAgIGFjdGl2ZTogdGhpcy5hcGkuc3R5bGVzLmlubGluZVRvb2xCdXR0b25BY3RpdmVcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgVG9vbCBhcyBJbmxpbmUgVG9vbGJhciBUb29sXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgZ2V0IGlzSW5saW5lKCkge1xuICAgIHJldHVybiAhMDtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGJ1dHRvbiBlbGVtZW50IGZvciBUb29sYmFyXG4gICAqXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLmJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiksIHRoaXMuYnV0dG9uLnR5cGUgPSBcImJ1dHRvblwiLCB0aGlzLmJ1dHRvbi5jbGFzc0xpc3QuYWRkKHRoaXMuaWNvbkNsYXNzZXMuYmFzZSksIHRoaXMuYnV0dG9uLmlubmVySFRNTCA9IHRoaXMudG9vbGJveEljb24sIHRoaXMuYnV0dG9uO1xuICB9XG4gIC8qKlxuICAgKiBXcmFwL1Vud3JhcCBzZWxlY3RlZCBmcmFnbWVudFxuICAgKlxuICAgKiBAcGFyYW0ge1JhbmdlfSByYW5nZSAtIHNlbGVjdGVkIGZyYWdtZW50XG4gICAqL1xuICBzdXJyb3VuZCh0KSB7XG4gICAgaWYgKCF0KVxuICAgICAgcmV0dXJuO1xuICAgIGxldCBlID0gdGhpcy5hcGkuc2VsZWN0aW9uLmZpbmRQYXJlbnRUYWcodGhpcy50YWcsIHMuQ1NTKTtcbiAgICBlID8gdGhpcy51bndyYXAoZSkgOiB0aGlzLndyYXAodCk7XG4gIH1cbiAgLyoqXG4gICAqIFdyYXAgc2VsZWN0aW9uIHdpdGggdGVybS10YWdcbiAgICpcbiAgICogQHBhcmFtIHtSYW5nZX0gcmFuZ2UgLSBzZWxlY3RlZCBmcmFnbWVudFxuICAgKi9cbiAgd3JhcCh0KSB7XG4gICAgbGV0IGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMudGFnKTtcbiAgICBlLmNsYXNzTGlzdC5hZGQocy5DU1MpLCBlLmFwcGVuZENoaWxkKHQuZXh0cmFjdENvbnRlbnRzKCkpLCB0Lmluc2VydE5vZGUoZSksIHRoaXMuYXBpLnNlbGVjdGlvbi5leHBhbmRUb1RhZyhlKTtcbiAgfVxuICAvKipcbiAgICogVW53cmFwIHRlcm0tdGFnXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRlcm1XcmFwcGVyIC0gdGVybSB3cmFwcGVyIHRhZ1xuICAgKi9cbiAgdW53cmFwKHQpIHtcbiAgICB0aGlzLmFwaS5zZWxlY3Rpb24uZXhwYW5kVG9UYWcodCk7XG4gICAgbGV0IGUgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCksIG4gPSBlLmdldFJhbmdlQXQoMCksIGkgPSBuLmV4dHJhY3RDb250ZW50cygpO1xuICAgIHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0KSwgbi5pbnNlcnROb2RlKGkpLCBlLnJlbW92ZUFsbFJhbmdlcygpLCBlLmFkZFJhbmdlKG4pO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBhbmQgY2hhbmdlIFRlcm0ncyBzdGF0ZSBmb3IgY3VycmVudCBzZWxlY3Rpb25cbiAgICovXG4gIGNoZWNrU3RhdGUoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuYXBpLnNlbGVjdGlvbi5maW5kUGFyZW50VGFnKHRoaXMudGFnLCBzLkNTUyk7XG4gICAgdGhpcy5idXR0b24uY2xhc3NMaXN0LnRvZ2dsZSh0aGlzLmljb25DbGFzc2VzLmFjdGl2ZSwgISF0KTtcbiAgfVxuICAvKipcbiAgICogR2V0IFRvb2wgaWNvbidzIFNWR1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgdG9vbGJveEljb24oKSB7XG4gICAgcmV0dXJuIG87XG4gIH1cbiAgLyoqXG4gICAqIFNhbml0aXplciBydWxlXG4gICAqIEByZXR1cm4ge3ttYXJrOiB7Y2xhc3M6IHN0cmluZ319fVxuICAgKi9cbiAgc3RhdGljIGdldCBzYW5pdGl6ZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWFyazoge1xuICAgICAgICBjbGFzczogcy5DU1NcbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG5leHBvcnQge1xuICBzIGFzIGRlZmF1bHRcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@editorjs/marker/dist/marker.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@editorjs/nested-list/dist/nested-list.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@editorjs/nested-list/dist/nested-list.mjs ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ u; }\n/* harmony export */ });\n(function(){\"use strict\";try{if(typeof document<\"u\"){var e=document.createElement(\"style\");e.appendChild(document.createTextNode('.cdx-nested-list{margin:0;padding:0;outline:none;counter-reset:item;list-style:none}.cdx-nested-list__item{line-height:1.6em;display:flex;margin:2px 0}.cdx-nested-list__item [contenteditable]{outline:none}.cdx-nested-list__item-body{flex-grow:2}.cdx-nested-list__item-content,.cdx-nested-list__item-children{flex-basis:100%}.cdx-nested-list__item-content{word-break:break-word;white-space:pre-wrap}.cdx-nested-list__item:before{counter-increment:item;margin-right:5px;white-space:nowrap}.cdx-nested-list--ordered>.cdx-nested-list__item:before{content:counters(item,\".\") \". \"}.cdx-nested-list--unordered>.cdx-nested-list__item:before{content:\"\"}.cdx-nested-list__settings{display:flex}.cdx-nested-list__settings .cdx-settings-button{width:50%}')),document.head.appendChild(e)}}catch(t){console.error(\"vite-plugin-css-injected-by-js\",t)}})();\nfunction p(d, e = null, t = {}) {\n  const r = document.createElement(d);\n  Array.isArray(e) ? r.classList.add(...e) : e && r.classList.add(e);\n  for (const s in t)\n    r[s] = t[s];\n  return r;\n}\nfunction g(d) {\n  const e = p(\"div\");\n  return e.appendChild(d), e.innerHTML;\n}\nfunction C(d) {\n  let e;\n  return d.nodeType !== Node.ELEMENT_NODE ? e = d.textContent : (e = d.innerHTML, e = e.replaceAll(\"<br>\", \"\")), e.trim().length === 0;\n}\nclass c {\n  /**\n   * Store internal properties\n   */\n  constructor() {\n    this.savedFakeCaret = void 0;\n  }\n  /**\n   * Saves caret position using hidden <span>\n   *\n   * @returns {void}\n   */\n  save() {\n    const e = c.range, t = p(\"span\");\n    t.hidden = !0, e.insertNode(t), this.savedFakeCaret = t;\n  }\n  /**\n   * Restores the caret position saved by the save() method\n   *\n   * @returns {void}\n   */\n  restore() {\n    if (!this.savedFakeCaret)\n      return;\n    const e = window.getSelection(), t = new Range();\n    t.setStartAfter(this.savedFakeCaret), t.setEndAfter(this.savedFakeCaret), e.removeAllRanges(), e.addRange(t), setTimeout(() => {\n      this.savedFakeCaret.remove();\n    }, 150);\n  }\n  /**\n   * Returns the first range\n   *\n   * @returns {Range|null}\n   */\n  static get range() {\n    const e = window.getSelection();\n    return e && e.rangeCount ? e.getRangeAt(0) : null;\n  }\n  /**\n   * Extract content fragment from Caret position to the end of contenteditable element\n   *\n   * @returns {DocumentFragment|void}\n   */\n  static extractFragmentFromCaretPositionTillTheEnd() {\n    const e = window.getSelection();\n    if (!e.rangeCount)\n      return;\n    const t = e.getRangeAt(0);\n    let r = t.startContainer;\n    r.nodeType !== Node.ELEMENT_NODE && (r = r.parentNode);\n    const s = r.closest(\"[contenteditable]\");\n    t.deleteContents();\n    const n = t.cloneRange();\n    return n.selectNodeContents(s), n.setStart(t.endContainer, t.endOffset), n.extractContents();\n  }\n  /**\n   * Set focus to contenteditable or native input element\n   *\n   * @param {HTMLElement} element - element where to set focus\n   * @param {boolean} atStart - where to set focus: at the start or at the end\n   * @returns {void}\n   */\n  static focus(e, t = !0) {\n    const r = document.createRange(), s = window.getSelection();\n    r.selectNodeContents(e), r.collapse(t), s.removeAllRanges(), s.addRange(r);\n  }\n  /**\n   * Check if the caret placed at the start of the contenteditable element\n   *\n   * @returns {void}\n   */\n  static isAtStart() {\n    const e = window.getSelection();\n    if (e.focusOffset > 0)\n      return !1;\n    const t = e.focusNode;\n    return c.getHigherLevelSiblings(t, \"left\").every((n) => C(n));\n  }\n  /**\n   * Get all first-level (first child of [contenteditabel]) siblings from passed node\n   * Then you can check it for emptiness\n   *\n   * @example\n   * <div contenteditable>\n   * <p></p>                            |\n   * <p></p>                            | left first-level siblings\n   * <p></p>                            |\n   * <blockquote><a><b>adaddad</b><a><blockquote>       <-- passed node for example <b>\n   * <p></p>                            |\n   * <p></p>                            | right first-level siblings\n   * <p></p>                            |\n   * </div>\n   * @param {HTMLElement} from - element from which siblings should be searched\n   * @param {'left' | 'right'} direction - direction of search\n   * @returns {HTMLElement[]}\n   */\n  static getHigherLevelSiblings(e, t = \"left\") {\n    let r = e;\n    const s = [];\n    for (; r.parentNode && r.parentNode.contentEditable !== \"true\"; )\n      r = r.parentNode;\n    const n = t === \"left\" ? \"previousSibling\" : \"nextSibling\";\n    for (; r[n]; )\n      r = r[n], s.push(r);\n    return s;\n  }\n}\nconst y = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><line x1=\"9\" x2=\"19\" y1=\"7\" y2=\"7\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\"/><line x1=\"9\" x2=\"19\" y1=\"12\" y2=\"12\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\"/><line x1=\"9\" x2=\"19\" y1=\"17\" y2=\"17\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M5.00001 17H4.99002\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M5.00001 12H4.99002\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M5.00001 7H4.99002\"/></svg>', S = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><line x1=\"12\" x2=\"19\" y1=\"7\" y2=\"7\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\"/><line x1=\"12\" x2=\"19\" y1=\"12\" y2=\"12\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\"/><line x1=\"12\" x2=\"19\" y1=\"17\" y2=\"17\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M7.79999 14L7.79999 7.2135C7.79999 7.12872 7.7011 7.0824 7.63597 7.13668L4.79999 9.5\"/></svg>';\nclass u {\n  /**\n   * Notify core that read-only mode is supported\n   *\n   * @returns {boolean}\n   */\n  static get isReadOnlySupported() {\n    return !0;\n  }\n  /**\n   * Allow to use native Enter behaviour\n   *\n   * @returns {boolean}\n   * @public\n   */\n  static get enableLineBreaks() {\n    return !0;\n  }\n  /**\n   * Get Tool toolbox settings\n   * icon - Tool icon's SVG\n   * title - title to show in toolbox\n   *\n   * @returns {{icon: string, title: string}}\n   */\n  static get toolbox() {\n    return {\n      icon: S,\n      title: \"List\"\n    };\n  }\n  /**\n   * Render plugin`s main Element and fill it with saved data\n   *\n   * @param {object} params - tool constructor options\n   * @param {ListData} params.data - previously saved data\n   * @param {object} params.config - user config for Tool\n   * @param {object} params.api - Editor.js API\n   * @param {boolean} params.readOnly - read-only mode flag\n   */\n  constructor({ data: e, config: t, api: r, readOnly: s }) {\n    this.nodes = {\n      wrapper: null\n    }, this.api = r, this.readOnly = s, this.config = t, this.defaultListStyle = this.config.defaultStyle === \"ordered\" ? \"ordered\" : \"unordered\";\n    const n = {\n      style: this.defaultListStyle,\n      items: []\n    };\n    this.data = e && Object.keys(e).length ? e : n, this.caret = new c();\n  }\n  /**\n   * Returns list tag with items\n   *\n   * @returns {Element}\n   * @public\n   */\n  render() {\n    return this.nodes.wrapper = this.makeListWrapper(this.data.style, [this.CSS.baseBlock]), this.data.items.length ? this.appendItems(this.data.items, this.nodes.wrapper) : this.appendItems([{\n      content: \"\",\n      items: []\n    }], this.nodes.wrapper), this.readOnly || this.nodes.wrapper.addEventListener(\"keydown\", (e) => {\n      switch (e.key) {\n        case \"Enter\":\n          this.enterPressed(e);\n          break;\n        case \"Backspace\":\n          this.backspace(e);\n          break;\n        case \"Tab\":\n          e.shiftKey ? this.shiftTab(e) : this.addTab(e);\n          break;\n      }\n    }, !1), this.nodes.wrapper;\n  }\n  /**\n   * Creates Block Tune allowing to change the list style\n   *\n   * @public\n   * @returns {Array}\n   */\n  renderSettings() {\n    return [\n      {\n        name: \"unordered\",\n        label: this.api.i18n.t(\"Unordered\"),\n        icon: y\n      },\n      {\n        name: \"ordered\",\n        label: this.api.i18n.t(\"Ordered\"),\n        icon: S\n      }\n    ].map((t) => ({\n      name: t.name,\n      icon: t.icon,\n      label: t.label,\n      isActive: this.data.style === t.name,\n      closeOnActivate: !0,\n      onActivate: () => {\n        this.listStyle = t.name;\n      }\n    }));\n  }\n  /**\n   * On paste sanitzation config. Allow only tags that are allowed in the Tool.\n   *\n   * @returns {PasteConfig} - paste config.\n   */\n  static get pasteConfig() {\n    return {\n      tags: [\"OL\", \"UL\", \"LI\"]\n    };\n  }\n  /**\n   * On paste callback that is fired from Editor.\n   *\n   * @param {PasteEvent} event - event with pasted data\n   */\n  onPaste(e) {\n    const t = e.detail.data;\n    this.data = this.pasteHandler(t);\n    const r = this.nodes.wrapper;\n    r && r.parentNode.replaceChild(this.render(), r);\n  }\n  /**\n   * Handle UL, OL and LI tags paste and returns List data\n   *\n   * @param {HTMLUListElement|HTMLOListElement|HTMLLIElement} element\n   * @returns {ListData}\n   */\n  pasteHandler(e) {\n    const { tagName: t } = e;\n    let r, s;\n    switch (t) {\n      case \"OL\":\n        r = \"ordered\", s = \"ol\";\n        break;\n      case \"UL\":\n      case \"LI\":\n        r = \"unordered\", s = \"ul\";\n    }\n    const n = {\n      style: r,\n      items: []\n    }, o = (l) => Array.from(l.querySelectorAll(\":scope > li\")).map((i) => {\n      var m;\n      const a = i.querySelector(`:scope > ${s}`), f = a ? o(a) : [];\n      return {\n        content: ((m = i == null ? void 0 : i.firstChild) == null ? void 0 : m.textContent) || \"\",\n        items: f\n      };\n    });\n    return n.items = o(e), n;\n  }\n  /**\n   * Renders children list\n   *\n   * @param {ListItem[]} items - items data to append\n   * @param {Element} parentItem - where to append\n   * @returns {void}\n   */\n  appendItems(e, t) {\n    e.forEach((r) => {\n      const s = this.createItem(r.content, r.items);\n      t.appendChild(s);\n    });\n  }\n  /**\n   * Renders the single item\n   *\n   * @param {string} content - item content to render\n   * @param {ListItem[]} [items] - children\n   * @returns {Element}\n   */\n  createItem(e, t = []) {\n    const r = p(\"li\", this.CSS.item), s = p(\"div\", this.CSS.itemBody), n = p(\"div\", this.CSS.itemContent, {\n      innerHTML: e,\n      contentEditable: !this.readOnly\n    });\n    return s.appendChild(n), r.appendChild(s), t && t.length > 0 && this.addChildrenList(r, t), r;\n  }\n  /**\n   * Extracts tool's data from the DOM\n   *\n   * @returns {ListData}\n   */\n  save() {\n    const e = (t) => Array.from(t.querySelectorAll(`:scope > .${this.CSS.item}`)).map((s) => {\n      const n = s.querySelector(`.${this.CSS.itemChildren}`), o = this.getItemContent(s), l = n ? e(n) : [];\n      return {\n        content: o,\n        items: l\n      };\n    });\n    return {\n      style: this.data.style,\n      items: e(this.nodes.wrapper)\n    };\n  }\n  /**\n   * Append children list to passed item\n   *\n   * @param {Element} parentItem - item that should contain passed sub-items\n   * @param {ListItem[]} items - sub items to append\n   */\n  addChildrenList(e, t) {\n    const r = e.querySelector(`.${this.CSS.itemBody}`), s = this.makeListWrapper(void 0, [this.CSS.itemChildren]);\n    this.appendItems(t, s), r.appendChild(s);\n  }\n  /**\n   * Creates main <ul> or <ol> tag depended on style\n   *\n   * @param {string} [style] - 'ordered' or 'unordered'\n   * @param {string[]} [classes] - additional classes to append\n   * @returns {HTMLOListElement|HTMLUListElement}\n   */\n  makeListWrapper(e = this.listStyle, t = []) {\n    const r = e === \"ordered\" ? \"ol\" : \"ul\", s = e === \"ordered\" ? this.CSS.wrapperOrdered : this.CSS.wrapperUnordered;\n    return t.push(s), p(r, [this.CSS.wrapper, ...t]);\n  }\n  /**\n   * Styles\n   *\n   * @returns {object} - CSS classes names by keys\n   * @private\n   */\n  get CSS() {\n    return {\n      baseBlock: this.api.styles.block,\n      wrapper: \"cdx-nested-list\",\n      wrapperOrdered: \"cdx-nested-list--ordered\",\n      wrapperUnordered: \"cdx-nested-list--unordered\",\n      item: \"cdx-nested-list__item\",\n      itemBody: \"cdx-nested-list__item-body\",\n      itemContent: \"cdx-nested-list__item-content\",\n      itemChildren: \"cdx-nested-list__item-children\",\n      settingsWrapper: \"cdx-nested-list__settings\",\n      settingsButton: this.api.styles.settingsButton,\n      settingsButtonActive: this.api.styles.settingsButtonActive\n    };\n  }\n  /**\n   * Get list style name\n   *\n   * @returns {string}\n   */\n  get listStyle() {\n    return this.data.style || this.defaultListStyle;\n  }\n  /**\n   * Set list style\n   *\n   * @param {string} style - new style to set\n   */\n  set listStyle(e) {\n    const t = Array.from(this.nodes.wrapper.querySelectorAll(`.${this.CSS.wrapper}`));\n    t.push(this.nodes.wrapper), t.forEach((r) => {\n      r.classList.toggle(this.CSS.wrapperUnordered, e === \"unordered\"), r.classList.toggle(this.CSS.wrapperOrdered, e === \"ordered\");\n    }), this.data.style = e;\n  }\n  /**\n   * Returns current List item by the caret position\n   *\n   * @returns {Element}\n   */\n  get currentItem() {\n    let e = window.getSelection().anchorNode;\n    return e.nodeType !== Node.ELEMENT_NODE && (e = e.parentNode), e.closest(`.${this.CSS.item}`);\n  }\n  /**\n   * Handles Enter keypress\n   *\n   * @param {KeyboardEvent} event - keydown\n   * @returns {void}\n   */\n  enterPressed(e) {\n    const t = this.currentItem;\n    if (e.stopPropagation(), e.preventDefault(), e.isComposing)\n      return;\n    const r = this.getItemContent(t).trim().length === 0, s = t.parentNode === this.nodes.wrapper, n = t.nextElementSibling === null;\n    if (s && n && r) {\n      this.getOutOfList();\n      return;\n    } else if (n && r) {\n      this.unshiftItem();\n      return;\n    }\n    const o = c.extractFragmentFromCaretPositionTillTheEnd(), l = g(o), h = t.querySelector(`.${this.CSS.itemChildren}`), i = this.createItem(l, void 0);\n    h && Array.from(h.querySelectorAll(`.${this.CSS.item}`)).length > 0 ? h.prepend(i) : t.after(i), this.focusItem(i);\n  }\n  /**\n   * Decrease indentation of the current item\n   *\n   * @returns {void}\n   */\n  unshiftItem() {\n    const e = this.currentItem, t = e.parentNode.closest(`.${this.CSS.item}`);\n    if (!t)\n      return;\n    this.caret.save(), t.after(e), this.caret.restore();\n    const r = t.querySelector(`.${this.CSS.itemChildren}`);\n    r.children.length === 0 && r.remove();\n  }\n  /**\n   * Return the item content\n   *\n   * @param {Element} item - item wrapper (<li>)\n   * @returns {string}\n   */\n  getItemContent(e) {\n    const t = e.querySelector(`.${this.CSS.itemContent}`);\n    return C(t) ? \"\" : t.innerHTML;\n  }\n  /**\n   * Sets focus to the item's content\n   *\n   * @param {Element} item - item (<li>) to select\n   * @param {boolean} atStart - where to set focus: at the start or at the end\n   * @returns {void}\n   */\n  focusItem(e, t = !0) {\n    const r = e.querySelector(`.${this.CSS.itemContent}`);\n    c.focus(r, t);\n  }\n  /**\n   * Get out from List Tool by Enter on the empty last item\n   *\n   * @returns {void}\n   */\n  getOutOfList() {\n    this.currentItem.remove(), this.api.blocks.insert(), this.api.caret.setToBlock(this.api.blocks.getCurrentBlockIndex());\n  }\n  /**\n   * Handle backspace\n   *\n   * @param {KeyboardEvent} event - keydown\n   */\n  backspace(e) {\n    if (!c.isAtStart())\n      return;\n    e.preventDefault();\n    const t = this.currentItem, r = t.previousSibling, s = t.parentNode.closest(`.${this.CSS.item}`);\n    if (!r && !s)\n      return;\n    e.stopPropagation();\n    let n;\n    if (r) {\n      const a = r.querySelectorAll(`.${this.CSS.item}`);\n      n = Array.from(a).pop() || r;\n    } else\n      n = s;\n    const o = c.extractFragmentFromCaretPositionTillTheEnd(), l = g(o), h = n.querySelector(`.${this.CSS.itemContent}`);\n    c.focus(h, !1), this.caret.save(), h.insertAdjacentHTML(\"beforeend\", l);\n    let i = t.querySelectorAll(`.${this.CSS.itemChildren} > .${this.CSS.item}`);\n    i = Array.from(i), i = i.filter((a) => a.parentNode.closest(`.${this.CSS.item}`) === t), i.reverse().forEach((a) => {\n      r ? n.after(a) : t.after(a);\n    }), t.remove(), this.caret.restore();\n  }\n  /**\n   * Add indentation to current item\n   *\n   * @param {KeyboardEvent} event - keydown\n   */\n  addTab(e) {\n    e.stopPropagation(), e.preventDefault();\n    const t = this.currentItem, r = t.previousSibling;\n    if (!r)\n      return;\n    const n = r.querySelector(`.${this.CSS.itemChildren}`);\n    if (this.caret.save(), n)\n      n.appendChild(t);\n    else {\n      const o = this.makeListWrapper(void 0, [this.CSS.itemChildren]), l = r.querySelector(`.${this.CSS.itemBody}`);\n      o.appendChild(t), l.appendChild(o);\n    }\n    this.caret.restore();\n  }\n  /**\n   * Reduce indentation for current item\n   *\n   * @param {KeyboardEvent} event - keydown\n   * @returns {void}\n   */\n  shiftTab(e) {\n    e.stopPropagation(), e.preventDefault(), this.unshiftItem();\n  }\n  /**\n   * Convert from list to text for conversionConfig\n   *\n   * @param {ListData} data\n   * @returns {string}\n   */\n  static joinRecursive(e) {\n    return e.items.map((t) => `${t.content} ${u.joinRecursive(t)}`).join(\"\");\n  }\n  /**\n   * Convert from text to list with import and export list to text\n   */\n  static get conversionConfig() {\n    return {\n      export: (e) => u.joinRecursive(e),\n      import: (e) => ({\n        items: [{\n          content: e,\n          items: []\n        }],\n        style: \"unordered\"\n      })\n    };\n  }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZWRpdG9yanMvbmVzdGVkLWxpc3QvZGlzdC9uZXN0ZWQtbGlzdC5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLFlBQVksYUFBYSxJQUFJLHdCQUF3QixzQ0FBc0Msd0RBQXdELFNBQVMsVUFBVSxhQUFhLG1CQUFtQixnQkFBZ0IsdUJBQXVCLGtCQUFrQixhQUFhLGFBQWEseUNBQXlDLGFBQWEsNEJBQTRCLFlBQVksK0RBQStELGdCQUFnQiwrQkFBK0Isc0JBQXNCLHFCQUFxQiw4QkFBOEIsdUJBQXVCLGlCQUFpQixtQkFBbUIsd0RBQXdELGdDQUFnQywwREFBMEQsWUFBWSwyQkFBMkIsYUFBYSxnREFBZ0QsVUFBVSxrQ0FBa0MsU0FBUyxtREFBbUQ7QUFDdjhCLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGFBQWEsU0FBUztBQUN0QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHNCQUFzQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQSwrRkFBK0Ysa0JBQWtCO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QixlQUFlO0FBQ2Y7QUFDQTtBQUNBLGlDQUFpQyxXQUFXLEVBQUUsbUJBQW1CO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BlZGl0b3Jqcy9uZXN0ZWQtbGlzdC9kaXN0L25lc3RlZC1saXN0Lm1qcz82YzQ5Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO3RyeXtpZih0eXBlb2YgZG9jdW1lbnQ8XCJ1XCIpe3ZhciBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcuY2R4LW5lc3RlZC1saXN0e21hcmdpbjowO3BhZGRpbmc6MDtvdXRsaW5lOm5vbmU7Y291bnRlci1yZXNldDppdGVtO2xpc3Qtc3R5bGU6bm9uZX0uY2R4LW5lc3RlZC1saXN0X19pdGVte2xpbmUtaGVpZ2h0OjEuNmVtO2Rpc3BsYXk6ZmxleDttYXJnaW46MnB4IDB9LmNkeC1uZXN0ZWQtbGlzdF9faXRlbSBbY29udGVudGVkaXRhYmxlXXtvdXRsaW5lOm5vbmV9LmNkeC1uZXN0ZWQtbGlzdF9faXRlbS1ib2R5e2ZsZXgtZ3JvdzoyfS5jZHgtbmVzdGVkLWxpc3RfX2l0ZW0tY29udGVudCwuY2R4LW5lc3RlZC1saXN0X19pdGVtLWNoaWxkcmVue2ZsZXgtYmFzaXM6MTAwJX0uY2R4LW5lc3RlZC1saXN0X19pdGVtLWNvbnRlbnR7d29yZC1icmVhazpicmVhay13b3JkO3doaXRlLXNwYWNlOnByZS13cmFwfS5jZHgtbmVzdGVkLWxpc3RfX2l0ZW06YmVmb3Jle2NvdW50ZXItaW5jcmVtZW50Oml0ZW07bWFyZ2luLXJpZ2h0OjVweDt3aGl0ZS1zcGFjZTpub3dyYXB9LmNkeC1uZXN0ZWQtbGlzdC0tb3JkZXJlZD4uY2R4LW5lc3RlZC1saXN0X19pdGVtOmJlZm9yZXtjb250ZW50OmNvdW50ZXJzKGl0ZW0sXCIuXCIpIFwiLiBcIn0uY2R4LW5lc3RlZC1saXN0LS11bm9yZGVyZWQ+LmNkeC1uZXN0ZWQtbGlzdF9faXRlbTpiZWZvcmV7Y29udGVudDpcIuKAolwifS5jZHgtbmVzdGVkLWxpc3RfX3NldHRpbmdze2Rpc3BsYXk6ZmxleH0uY2R4LW5lc3RlZC1saXN0X19zZXR0aW5ncyAuY2R4LXNldHRpbmdzLWJ1dHRvbnt3aWR0aDo1MCV9JykpLGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoZSl9fWNhdGNoKHQpe2NvbnNvbGUuZXJyb3IoXCJ2aXRlLXBsdWdpbi1jc3MtaW5qZWN0ZWQtYnktanNcIix0KX19KSgpO1xuZnVuY3Rpb24gcChkLCBlID0gbnVsbCwgdCA9IHt9KSB7XG4gIGNvbnN0IHIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGQpO1xuICBBcnJheS5pc0FycmF5KGUpID8gci5jbGFzc0xpc3QuYWRkKC4uLmUpIDogZSAmJiByLmNsYXNzTGlzdC5hZGQoZSk7XG4gIGZvciAoY29uc3QgcyBpbiB0KVxuICAgIHJbc10gPSB0W3NdO1xuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIGcoZCkge1xuICBjb25zdCBlID0gcChcImRpdlwiKTtcbiAgcmV0dXJuIGUuYXBwZW5kQ2hpbGQoZCksIGUuaW5uZXJIVE1MO1xufVxuZnVuY3Rpb24gQyhkKSB7XG4gIGxldCBlO1xuICByZXR1cm4gZC5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUgPyBlID0gZC50ZXh0Q29udGVudCA6IChlID0gZC5pbm5lckhUTUwsIGUgPSBlLnJlcGxhY2VBbGwoXCI8YnI+XCIsIFwiXCIpKSwgZS50cmltKCkubGVuZ3RoID09PSAwO1xufVxuY2xhc3MgYyB7XG4gIC8qKlxuICAgKiBTdG9yZSBpbnRlcm5hbCBwcm9wZXJ0aWVzXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnNhdmVkRmFrZUNhcmV0ID0gdm9pZCAwO1xuICB9XG4gIC8qKlxuICAgKiBTYXZlcyBjYXJldCBwb3NpdGlvbiB1c2luZyBoaWRkZW4gPHNwYW4+XG4gICAqXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgc2F2ZSgpIHtcbiAgICBjb25zdCBlID0gYy5yYW5nZSwgdCA9IHAoXCJzcGFuXCIpO1xuICAgIHQuaGlkZGVuID0gITAsIGUuaW5zZXJ0Tm9kZSh0KSwgdGhpcy5zYXZlZEZha2VDYXJldCA9IHQ7XG4gIH1cbiAgLyoqXG4gICAqIFJlc3RvcmVzIHRoZSBjYXJldCBwb3NpdGlvbiBzYXZlZCBieSB0aGUgc2F2ZSgpIG1ldGhvZFxuICAgKlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIHJlc3RvcmUoKSB7XG4gICAgaWYgKCF0aGlzLnNhdmVkRmFrZUNhcmV0KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGUgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCksIHQgPSBuZXcgUmFuZ2UoKTtcbiAgICB0LnNldFN0YXJ0QWZ0ZXIodGhpcy5zYXZlZEZha2VDYXJldCksIHQuc2V0RW5kQWZ0ZXIodGhpcy5zYXZlZEZha2VDYXJldCksIGUucmVtb3ZlQWxsUmFuZ2VzKCksIGUuYWRkUmFuZ2UodCksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5zYXZlZEZha2VDYXJldC5yZW1vdmUoKTtcbiAgICB9LCAxNTApO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaXJzdCByYW5nZVxuICAgKlxuICAgKiBAcmV0dXJucyB7UmFuZ2V8bnVsbH1cbiAgICovXG4gIHN0YXRpYyBnZXQgcmFuZ2UoKSB7XG4gICAgY29uc3QgZSA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICByZXR1cm4gZSAmJiBlLnJhbmdlQ291bnQgPyBlLmdldFJhbmdlQXQoMCkgOiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBFeHRyYWN0IGNvbnRlbnQgZnJhZ21lbnQgZnJvbSBDYXJldCBwb3NpdGlvbiB0byB0aGUgZW5kIG9mIGNvbnRlbnRlZGl0YWJsZSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm5zIHtEb2N1bWVudEZyYWdtZW50fHZvaWR9XG4gICAqL1xuICBzdGF0aWMgZXh0cmFjdEZyYWdtZW50RnJvbUNhcmV0UG9zaXRpb25UaWxsVGhlRW5kKCkge1xuICAgIGNvbnN0IGUgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCFlLnJhbmdlQ291bnQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IGUuZ2V0UmFuZ2VBdCgwKTtcbiAgICBsZXQgciA9IHQuc3RhcnRDb250YWluZXI7XG4gICAgci5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUgJiYgKHIgPSByLnBhcmVudE5vZGUpO1xuICAgIGNvbnN0IHMgPSByLmNsb3Nlc3QoXCJbY29udGVudGVkaXRhYmxlXVwiKTtcbiAgICB0LmRlbGV0ZUNvbnRlbnRzKCk7XG4gICAgY29uc3QgbiA9IHQuY2xvbmVSYW5nZSgpO1xuICAgIHJldHVybiBuLnNlbGVjdE5vZGVDb250ZW50cyhzKSwgbi5zZXRTdGFydCh0LmVuZENvbnRhaW5lciwgdC5lbmRPZmZzZXQpLCBuLmV4dHJhY3RDb250ZW50cygpO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgZm9jdXMgdG8gY29udGVudGVkaXRhYmxlIG9yIG5hdGl2ZSBpbnB1dCBlbGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBlbGVtZW50IHdoZXJlIHRvIHNldCBmb2N1c1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGF0U3RhcnQgLSB3aGVyZSB0byBzZXQgZm9jdXM6IGF0IHRoZSBzdGFydCBvciBhdCB0aGUgZW5kXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgc3RhdGljIGZvY3VzKGUsIHQgPSAhMCkge1xuICAgIGNvbnN0IHIgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpLCBzID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgIHIuc2VsZWN0Tm9kZUNvbnRlbnRzKGUpLCByLmNvbGxhcHNlKHQpLCBzLnJlbW92ZUFsbFJhbmdlcygpLCBzLmFkZFJhbmdlKHIpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgY2FyZXQgcGxhY2VkIGF0IHRoZSBzdGFydCBvZiB0aGUgY29udGVudGVkaXRhYmxlIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBzdGF0aWMgaXNBdFN0YXJ0KCkge1xuICAgIGNvbnN0IGUgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKGUuZm9jdXNPZmZzZXQgPiAwKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IHQgPSBlLmZvY3VzTm9kZTtcbiAgICByZXR1cm4gYy5nZXRIaWdoZXJMZXZlbFNpYmxpbmdzKHQsIFwibGVmdFwiKS5ldmVyeSgobikgPT4gQyhuKSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhbGwgZmlyc3QtbGV2ZWwgKGZpcnN0IGNoaWxkIG9mIFtjb250ZW50ZWRpdGFiZWxdKSBzaWJsaW5ncyBmcm9tIHBhc3NlZCBub2RlXG4gICAqIFRoZW4geW91IGNhbiBjaGVjayBpdCBmb3IgZW1wdGluZXNzXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIDxkaXYgY29udGVudGVkaXRhYmxlPlxuICAgKiA8cD48L3A+ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICogPHA+PC9wPiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGxlZnQgZmlyc3QtbGV2ZWwgc2libGluZ3NcbiAgICogPHA+PC9wPiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAqIDxibG9ja3F1b3RlPjxhPjxiPmFkYWRkYWQ8L2I+PGE+PGJsb2NrcXVvdGU+ICAgICAgIDwtLSBwYXNzZWQgbm9kZSBmb3IgZXhhbXBsZSA8Yj5cbiAgICogPHA+PC9wPiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAqIDxwPjwvcD4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfCByaWdodCBmaXJzdC1sZXZlbCBzaWJsaW5nc1xuICAgKiA8cD48L3A+ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICogPC9kaXY+XG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGZyb20gLSBlbGVtZW50IGZyb20gd2hpY2ggc2libGluZ3Mgc2hvdWxkIGJlIHNlYXJjaGVkXG4gICAqIEBwYXJhbSB7J2xlZnQnIHwgJ3JpZ2h0J30gZGlyZWN0aW9uIC0gZGlyZWN0aW9uIG9mIHNlYXJjaFxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnRbXX1cbiAgICovXG4gIHN0YXRpYyBnZXRIaWdoZXJMZXZlbFNpYmxpbmdzKGUsIHQgPSBcImxlZnRcIikge1xuICAgIGxldCByID0gZTtcbiAgICBjb25zdCBzID0gW107XG4gICAgZm9yICg7IHIucGFyZW50Tm9kZSAmJiByLnBhcmVudE5vZGUuY29udGVudEVkaXRhYmxlICE9PSBcInRydWVcIjsgKVxuICAgICAgciA9IHIucGFyZW50Tm9kZTtcbiAgICBjb25zdCBuID0gdCA9PT0gXCJsZWZ0XCIgPyBcInByZXZpb3VzU2libGluZ1wiIDogXCJuZXh0U2libGluZ1wiO1xuICAgIGZvciAoOyByW25dOyApXG4gICAgICByID0gcltuXSwgcy5wdXNoKHIpO1xuICAgIHJldHVybiBzO1xuICB9XG59XG5jb25zdCB5ID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxsaW5lIHgxPVwiOVwiIHgyPVwiMTlcIiB5MT1cIjdcIiB5Mj1cIjdcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiLz48bGluZSB4MT1cIjlcIiB4Mj1cIjE5XCIgeTE9XCIxMlwiIHkyPVwiMTJcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiLz48bGluZSB4MT1cIjlcIiB4Mj1cIjE5XCIgeTE9XCIxN1wiIHkyPVwiMTdcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNNS4wMDAwMSAxN0g0Ljk5MDAyXCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk01LjAwMDAxIDEySDQuOTkwMDJcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTUuMDAwMDEgN0g0Ljk5MDAyXCIvPjwvc3ZnPicsIFMgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PGxpbmUgeDE9XCIxMlwiIHgyPVwiMTlcIiB5MT1cIjdcIiB5Mj1cIjdcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiLz48bGluZSB4MT1cIjEyXCIgeDI9XCIxOVwiIHkxPVwiMTJcIiB5Mj1cIjEyXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIi8+PGxpbmUgeDE9XCIxMlwiIHgyPVwiMTlcIiB5MT1cIjE3XCIgeTI9XCIxN1wiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk03Ljc5OTk5IDE0TDcuNzk5OTkgNy4yMTM1QzcuNzk5OTkgNy4xMjg3MiA3LjcwMTEgNy4wODI0IDcuNjM1OTcgNy4xMzY2OEw0Ljc5OTk5IDkuNVwiLz48L3N2Zz4nO1xuY2xhc3MgdSB7XG4gIC8qKlxuICAgKiBOb3RpZnkgY29yZSB0aGF0IHJlYWQtb25seSBtb2RlIGlzIHN1cHBvcnRlZFxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBnZXQgaXNSZWFkT25seVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gITA7XG4gIH1cbiAgLyoqXG4gICAqIEFsbG93IHRvIHVzZSBuYXRpdmUgRW50ZXIgYmVoYXZpb3VyXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKiBAcHVibGljXG4gICAqL1xuICBzdGF0aWMgZ2V0IGVuYWJsZUxpbmVCcmVha3MoKSB7XG4gICAgcmV0dXJuICEwO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgVG9vbCB0b29sYm94IHNldHRpbmdzXG4gICAqIGljb24gLSBUb29sIGljb24ncyBTVkdcbiAgICogdGl0bGUgLSB0aXRsZSB0byBzaG93IGluIHRvb2xib3hcbiAgICpcbiAgICogQHJldHVybnMge3tpY29uOiBzdHJpbmcsIHRpdGxlOiBzdHJpbmd9fVxuICAgKi9cbiAgc3RhdGljIGdldCB0b29sYm94KCkge1xuICAgIHJldHVybiB7XG4gICAgICBpY29uOiBTLFxuICAgICAgdGl0bGU6IFwiTGlzdFwiXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmVuZGVyIHBsdWdpbmBzIG1haW4gRWxlbWVudCBhbmQgZmlsbCBpdCB3aXRoIHNhdmVkIGRhdGFcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIHRvb2wgY29uc3RydWN0b3Igb3B0aW9uc1xuICAgKiBAcGFyYW0ge0xpc3REYXRhfSBwYXJhbXMuZGF0YSAtIHByZXZpb3VzbHkgc2F2ZWQgZGF0YVxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zLmNvbmZpZyAtIHVzZXIgY29uZmlnIGZvciBUb29sXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMuYXBpIC0gRWRpdG9yLmpzIEFQSVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5yZWFkT25seSAtIHJlYWQtb25seSBtb2RlIGZsYWdcbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgZGF0YTogZSwgY29uZmlnOiB0LCBhcGk6IHIsIHJlYWRPbmx5OiBzIH0pIHtcbiAgICB0aGlzLm5vZGVzID0ge1xuICAgICAgd3JhcHBlcjogbnVsbFxuICAgIH0sIHRoaXMuYXBpID0gciwgdGhpcy5yZWFkT25seSA9IHMsIHRoaXMuY29uZmlnID0gdCwgdGhpcy5kZWZhdWx0TGlzdFN0eWxlID0gdGhpcy5jb25maWcuZGVmYXVsdFN0eWxlID09PSBcIm9yZGVyZWRcIiA/IFwib3JkZXJlZFwiIDogXCJ1bm9yZGVyZWRcIjtcbiAgICBjb25zdCBuID0ge1xuICAgICAgc3R5bGU6IHRoaXMuZGVmYXVsdExpc3RTdHlsZSxcbiAgICAgIGl0ZW1zOiBbXVxuICAgIH07XG4gICAgdGhpcy5kYXRhID0gZSAmJiBPYmplY3Qua2V5cyhlKS5sZW5ndGggPyBlIDogbiwgdGhpcy5jYXJldCA9IG5ldyBjKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgbGlzdCB0YWcgd2l0aCBpdGVtc1xuICAgKlxuICAgKiBAcmV0dXJucyB7RWxlbWVudH1cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVzLndyYXBwZXIgPSB0aGlzLm1ha2VMaXN0V3JhcHBlcih0aGlzLmRhdGEuc3R5bGUsIFt0aGlzLkNTUy5iYXNlQmxvY2tdKSwgdGhpcy5kYXRhLml0ZW1zLmxlbmd0aCA/IHRoaXMuYXBwZW5kSXRlbXModGhpcy5kYXRhLml0ZW1zLCB0aGlzLm5vZGVzLndyYXBwZXIpIDogdGhpcy5hcHBlbmRJdGVtcyhbe1xuICAgICAgY29udGVudDogXCJcIixcbiAgICAgIGl0ZW1zOiBbXVxuICAgIH1dLCB0aGlzLm5vZGVzLndyYXBwZXIpLCB0aGlzLnJlYWRPbmx5IHx8IHRoaXMubm9kZXMud3JhcHBlci5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCAoZSkgPT4ge1xuICAgICAgc3dpdGNoIChlLmtleSkge1xuICAgICAgICBjYXNlIFwiRW50ZXJcIjpcbiAgICAgICAgICB0aGlzLmVudGVyUHJlc3NlZChlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkJhY2tzcGFjZVwiOlxuICAgICAgICAgIHRoaXMuYmFja3NwYWNlKGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiVGFiXCI6XG4gICAgICAgICAgZS5zaGlmdEtleSA/IHRoaXMuc2hpZnRUYWIoZSkgOiB0aGlzLmFkZFRhYihlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9LCAhMSksIHRoaXMubm9kZXMud3JhcHBlcjtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBCbG9jayBUdW5lIGFsbG93aW5nIHRvIGNoYW5nZSB0aGUgbGlzdCBzdHlsZVxuICAgKlxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICovXG4gIHJlbmRlclNldHRpbmdzKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwidW5vcmRlcmVkXCIsXG4gICAgICAgIGxhYmVsOiB0aGlzLmFwaS5pMThuLnQoXCJVbm9yZGVyZWRcIiksXG4gICAgICAgIGljb246IHlcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwib3JkZXJlZFwiLFxuICAgICAgICBsYWJlbDogdGhpcy5hcGkuaTE4bi50KFwiT3JkZXJlZFwiKSxcbiAgICAgICAgaWNvbjogU1xuICAgICAgfVxuICAgIF0ubWFwKCh0KSA9PiAoe1xuICAgICAgbmFtZTogdC5uYW1lLFxuICAgICAgaWNvbjogdC5pY29uLFxuICAgICAgbGFiZWw6IHQubGFiZWwsXG4gICAgICBpc0FjdGl2ZTogdGhpcy5kYXRhLnN0eWxlID09PSB0Lm5hbWUsXG4gICAgICBjbG9zZU9uQWN0aXZhdGU6ICEwLFxuICAgICAgb25BY3RpdmF0ZTogKCkgPT4ge1xuICAgICAgICB0aGlzLmxpc3RTdHlsZSA9IHQubmFtZTtcbiAgICAgIH1cbiAgICB9KSk7XG4gIH1cbiAgLyoqXG4gICAqIE9uIHBhc3RlIHNhbml0emF0aW9uIGNvbmZpZy4gQWxsb3cgb25seSB0YWdzIHRoYXQgYXJlIGFsbG93ZWQgaW4gdGhlIFRvb2wuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQYXN0ZUNvbmZpZ30gLSBwYXN0ZSBjb25maWcuXG4gICAqL1xuICBzdGF0aWMgZ2V0IHBhc3RlQ29uZmlnKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0YWdzOiBbXCJPTFwiLCBcIlVMXCIsIFwiTElcIl1cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBPbiBwYXN0ZSBjYWxsYmFjayB0aGF0IGlzIGZpcmVkIGZyb20gRWRpdG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge1Bhc3RlRXZlbnR9IGV2ZW50IC0gZXZlbnQgd2l0aCBwYXN0ZWQgZGF0YVxuICAgKi9cbiAgb25QYXN0ZShlKSB7XG4gICAgY29uc3QgdCA9IGUuZGV0YWlsLmRhdGE7XG4gICAgdGhpcy5kYXRhID0gdGhpcy5wYXN0ZUhhbmRsZXIodCk7XG4gICAgY29uc3QgciA9IHRoaXMubm9kZXMud3JhcHBlcjtcbiAgICByICYmIHIucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgcik7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZSBVTCwgT0wgYW5kIExJIHRhZ3MgcGFzdGUgYW5kIHJldHVybnMgTGlzdCBkYXRhXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTFVMaXN0RWxlbWVudHxIVE1MT0xpc3RFbGVtZW50fEhUTUxMSUVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHJldHVybnMge0xpc3REYXRhfVxuICAgKi9cbiAgcGFzdGVIYW5kbGVyKGUpIHtcbiAgICBjb25zdCB7IHRhZ05hbWU6IHQgfSA9IGU7XG4gICAgbGV0IHIsIHM7XG4gICAgc3dpdGNoICh0KSB7XG4gICAgICBjYXNlIFwiT0xcIjpcbiAgICAgICAgciA9IFwib3JkZXJlZFwiLCBzID0gXCJvbFwiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJVTFwiOlxuICAgICAgY2FzZSBcIkxJXCI6XG4gICAgICAgIHIgPSBcInVub3JkZXJlZFwiLCBzID0gXCJ1bFwiO1xuICAgIH1cbiAgICBjb25zdCBuID0ge1xuICAgICAgc3R5bGU6IHIsXG4gICAgICBpdGVtczogW11cbiAgICB9LCBvID0gKGwpID0+IEFycmF5LmZyb20obC5xdWVyeVNlbGVjdG9yQWxsKFwiOnNjb3BlID4gbGlcIikpLm1hcCgoaSkgPT4ge1xuICAgICAgdmFyIG07XG4gICAgICBjb25zdCBhID0gaS5xdWVyeVNlbGVjdG9yKGA6c2NvcGUgPiAke3N9YCksIGYgPSBhID8gbyhhKSA6IFtdO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29udGVudDogKChtID0gaSA9PSBudWxsID8gdm9pZCAwIDogaS5maXJzdENoaWxkKSA9PSBudWxsID8gdm9pZCAwIDogbS50ZXh0Q29udGVudCkgfHwgXCJcIixcbiAgICAgICAgaXRlbXM6IGZcbiAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIG4uaXRlbXMgPSBvKGUpLCBuO1xuICB9XG4gIC8qKlxuICAgKiBSZW5kZXJzIGNoaWxkcmVuIGxpc3RcbiAgICpcbiAgICogQHBhcmFtIHtMaXN0SXRlbVtdfSBpdGVtcyAtIGl0ZW1zIGRhdGEgdG8gYXBwZW5kXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gcGFyZW50SXRlbSAtIHdoZXJlIHRvIGFwcGVuZFxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGFwcGVuZEl0ZW1zKGUsIHQpIHtcbiAgICBlLmZvckVhY2goKHIpID0+IHtcbiAgICAgIGNvbnN0IHMgPSB0aGlzLmNyZWF0ZUl0ZW0oci5jb250ZW50LCByLml0ZW1zKTtcbiAgICAgIHQuYXBwZW5kQ2hpbGQocyk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIHNpbmdsZSBpdGVtXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50IC0gaXRlbSBjb250ZW50IHRvIHJlbmRlclxuICAgKiBAcGFyYW0ge0xpc3RJdGVtW119IFtpdGVtc10gLSBjaGlsZHJlblxuICAgKiBAcmV0dXJucyB7RWxlbWVudH1cbiAgICovXG4gIGNyZWF0ZUl0ZW0oZSwgdCA9IFtdKSB7XG4gICAgY29uc3QgciA9IHAoXCJsaVwiLCB0aGlzLkNTUy5pdGVtKSwgcyA9IHAoXCJkaXZcIiwgdGhpcy5DU1MuaXRlbUJvZHkpLCBuID0gcChcImRpdlwiLCB0aGlzLkNTUy5pdGVtQ29udGVudCwge1xuICAgICAgaW5uZXJIVE1MOiBlLFxuICAgICAgY29udGVudEVkaXRhYmxlOiAhdGhpcy5yZWFkT25seVxuICAgIH0pO1xuICAgIHJldHVybiBzLmFwcGVuZENoaWxkKG4pLCByLmFwcGVuZENoaWxkKHMpLCB0ICYmIHQubGVuZ3RoID4gMCAmJiB0aGlzLmFkZENoaWxkcmVuTGlzdChyLCB0KSwgcjtcbiAgfVxuICAvKipcbiAgICogRXh0cmFjdHMgdG9vbCdzIGRhdGEgZnJvbSB0aGUgRE9NXG4gICAqXG4gICAqIEByZXR1cm5zIHtMaXN0RGF0YX1cbiAgICovXG4gIHNhdmUoKSB7XG4gICAgY29uc3QgZSA9ICh0KSA9PiBBcnJheS5mcm9tKHQucXVlcnlTZWxlY3RvckFsbChgOnNjb3BlID4gLiR7dGhpcy5DU1MuaXRlbX1gKSkubWFwKChzKSA9PiB7XG4gICAgICBjb25zdCBuID0gcy5xdWVyeVNlbGVjdG9yKGAuJHt0aGlzLkNTUy5pdGVtQ2hpbGRyZW59YCksIG8gPSB0aGlzLmdldEl0ZW1Db250ZW50KHMpLCBsID0gbiA/IGUobikgOiBbXTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRlbnQ6IG8sXG4gICAgICAgIGl0ZW1zOiBsXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBzdHlsZTogdGhpcy5kYXRhLnN0eWxlLFxuICAgICAgaXRlbXM6IGUodGhpcy5ub2Rlcy53cmFwcGVyKVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEFwcGVuZCBjaGlsZHJlbiBsaXN0IHRvIHBhc3NlZCBpdGVtXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gcGFyZW50SXRlbSAtIGl0ZW0gdGhhdCBzaG91bGQgY29udGFpbiBwYXNzZWQgc3ViLWl0ZW1zXG4gICAqIEBwYXJhbSB7TGlzdEl0ZW1bXX0gaXRlbXMgLSBzdWIgaXRlbXMgdG8gYXBwZW5kXG4gICAqL1xuICBhZGRDaGlsZHJlbkxpc3QoZSwgdCkge1xuICAgIGNvbnN0IHIgPSBlLnF1ZXJ5U2VsZWN0b3IoYC4ke3RoaXMuQ1NTLml0ZW1Cb2R5fWApLCBzID0gdGhpcy5tYWtlTGlzdFdyYXBwZXIodm9pZCAwLCBbdGhpcy5DU1MuaXRlbUNoaWxkcmVuXSk7XG4gICAgdGhpcy5hcHBlbmRJdGVtcyh0LCBzKSwgci5hcHBlbmRDaGlsZChzKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBtYWluIDx1bD4gb3IgPG9sPiB0YWcgZGVwZW5kZWQgb24gc3R5bGVcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHlsZV0gLSAnb3JkZXJlZCcgb3IgJ3Vub3JkZXJlZCdcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gW2NsYXNzZXNdIC0gYWRkaXRpb25hbCBjbGFzc2VzIHRvIGFwcGVuZFxuICAgKiBAcmV0dXJucyB7SFRNTE9MaXN0RWxlbWVudHxIVE1MVUxpc3RFbGVtZW50fVxuICAgKi9cbiAgbWFrZUxpc3RXcmFwcGVyKGUgPSB0aGlzLmxpc3RTdHlsZSwgdCA9IFtdKSB7XG4gICAgY29uc3QgciA9IGUgPT09IFwib3JkZXJlZFwiID8gXCJvbFwiIDogXCJ1bFwiLCBzID0gZSA9PT0gXCJvcmRlcmVkXCIgPyB0aGlzLkNTUy53cmFwcGVyT3JkZXJlZCA6IHRoaXMuQ1NTLndyYXBwZXJVbm9yZGVyZWQ7XG4gICAgcmV0dXJuIHQucHVzaChzKSwgcChyLCBbdGhpcy5DU1Mud3JhcHBlciwgLi4udF0pO1xuICB9XG4gIC8qKlxuICAgKiBTdHlsZXNcbiAgICpcbiAgICogQHJldHVybnMge29iamVjdH0gLSBDU1MgY2xhc3NlcyBuYW1lcyBieSBrZXlzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXQgQ1NTKCkge1xuICAgIHJldHVybiB7XG4gICAgICBiYXNlQmxvY2s6IHRoaXMuYXBpLnN0eWxlcy5ibG9jayxcbiAgICAgIHdyYXBwZXI6IFwiY2R4LW5lc3RlZC1saXN0XCIsXG4gICAgICB3cmFwcGVyT3JkZXJlZDogXCJjZHgtbmVzdGVkLWxpc3QtLW9yZGVyZWRcIixcbiAgICAgIHdyYXBwZXJVbm9yZGVyZWQ6IFwiY2R4LW5lc3RlZC1saXN0LS11bm9yZGVyZWRcIixcbiAgICAgIGl0ZW06IFwiY2R4LW5lc3RlZC1saXN0X19pdGVtXCIsXG4gICAgICBpdGVtQm9keTogXCJjZHgtbmVzdGVkLWxpc3RfX2l0ZW0tYm9keVwiLFxuICAgICAgaXRlbUNvbnRlbnQ6IFwiY2R4LW5lc3RlZC1saXN0X19pdGVtLWNvbnRlbnRcIixcbiAgICAgIGl0ZW1DaGlsZHJlbjogXCJjZHgtbmVzdGVkLWxpc3RfX2l0ZW0tY2hpbGRyZW5cIixcbiAgICAgIHNldHRpbmdzV3JhcHBlcjogXCJjZHgtbmVzdGVkLWxpc3RfX3NldHRpbmdzXCIsXG4gICAgICBzZXR0aW5nc0J1dHRvbjogdGhpcy5hcGkuc3R5bGVzLnNldHRpbmdzQnV0dG9uLFxuICAgICAgc2V0dGluZ3NCdXR0b25BY3RpdmU6IHRoaXMuYXBpLnN0eWxlcy5zZXR0aW5nc0J1dHRvbkFjdGl2ZVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEdldCBsaXN0IHN0eWxlIG5hbWVcbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGdldCBsaXN0U3R5bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5zdHlsZSB8fCB0aGlzLmRlZmF1bHRMaXN0U3R5bGU7XG4gIH1cbiAgLyoqXG4gICAqIFNldCBsaXN0IHN0eWxlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHlsZSAtIG5ldyBzdHlsZSB0byBzZXRcbiAgICovXG4gIHNldCBsaXN0U3R5bGUoZSkge1xuICAgIGNvbnN0IHQgPSBBcnJheS5mcm9tKHRoaXMubm9kZXMud3JhcHBlci5xdWVyeVNlbGVjdG9yQWxsKGAuJHt0aGlzLkNTUy53cmFwcGVyfWApKTtcbiAgICB0LnB1c2godGhpcy5ub2Rlcy53cmFwcGVyKSwgdC5mb3JFYWNoKChyKSA9PiB7XG4gICAgICByLmNsYXNzTGlzdC50b2dnbGUodGhpcy5DU1Mud3JhcHBlclVub3JkZXJlZCwgZSA9PT0gXCJ1bm9yZGVyZWRcIiksIHIuY2xhc3NMaXN0LnRvZ2dsZSh0aGlzLkNTUy53cmFwcGVyT3JkZXJlZCwgZSA9PT0gXCJvcmRlcmVkXCIpO1xuICAgIH0pLCB0aGlzLmRhdGEuc3R5bGUgPSBlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGN1cnJlbnQgTGlzdCBpdGVtIGJ5IHRoZSBjYXJldCBwb3NpdGlvblxuICAgKlxuICAgKiBAcmV0dXJucyB7RWxlbWVudH1cbiAgICovXG4gIGdldCBjdXJyZW50SXRlbSgpIHtcbiAgICBsZXQgZSA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKS5hbmNob3JOb2RlO1xuICAgIHJldHVybiBlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSAmJiAoZSA9IGUucGFyZW50Tm9kZSksIGUuY2xvc2VzdChgLiR7dGhpcy5DU1MuaXRlbX1gKTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlcyBFbnRlciBrZXlwcmVzc1xuICAgKlxuICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2ZW50IC0ga2V5ZG93blxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGVudGVyUHJlc3NlZChlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuY3VycmVudEl0ZW07XG4gICAgaWYgKGUuc3RvcFByb3BhZ2F0aW9uKCksIGUucHJldmVudERlZmF1bHQoKSwgZS5pc0NvbXBvc2luZylcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCByID0gdGhpcy5nZXRJdGVtQ29udGVudCh0KS50cmltKCkubGVuZ3RoID09PSAwLCBzID0gdC5wYXJlbnROb2RlID09PSB0aGlzLm5vZGVzLndyYXBwZXIsIG4gPSB0Lm5leHRFbGVtZW50U2libGluZyA9PT0gbnVsbDtcbiAgICBpZiAocyAmJiBuICYmIHIpIHtcbiAgICAgIHRoaXMuZ2V0T3V0T2ZMaXN0KCk7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChuICYmIHIpIHtcbiAgICAgIHRoaXMudW5zaGlmdEl0ZW0oKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbyA9IGMuZXh0cmFjdEZyYWdtZW50RnJvbUNhcmV0UG9zaXRpb25UaWxsVGhlRW5kKCksIGwgPSBnKG8pLCBoID0gdC5xdWVyeVNlbGVjdG9yKGAuJHt0aGlzLkNTUy5pdGVtQ2hpbGRyZW59YCksIGkgPSB0aGlzLmNyZWF0ZUl0ZW0obCwgdm9pZCAwKTtcbiAgICBoICYmIEFycmF5LmZyb20oaC5xdWVyeVNlbGVjdG9yQWxsKGAuJHt0aGlzLkNTUy5pdGVtfWApKS5sZW5ndGggPiAwID8gaC5wcmVwZW5kKGkpIDogdC5hZnRlcihpKSwgdGhpcy5mb2N1c0l0ZW0oaSk7XG4gIH1cbiAgLyoqXG4gICAqIERlY3JlYXNlIGluZGVudGF0aW9uIG9mIHRoZSBjdXJyZW50IGl0ZW1cbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICB1bnNoaWZ0SXRlbSgpIHtcbiAgICBjb25zdCBlID0gdGhpcy5jdXJyZW50SXRlbSwgdCA9IGUucGFyZW50Tm9kZS5jbG9zZXN0KGAuJHt0aGlzLkNTUy5pdGVtfWApO1xuICAgIGlmICghdClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmNhcmV0LnNhdmUoKSwgdC5hZnRlcihlKSwgdGhpcy5jYXJldC5yZXN0b3JlKCk7XG4gICAgY29uc3QgciA9IHQucXVlcnlTZWxlY3RvcihgLiR7dGhpcy5DU1MuaXRlbUNoaWxkcmVufWApO1xuICAgIHIuY2hpbGRyZW4ubGVuZ3RoID09PSAwICYmIHIucmVtb3ZlKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgaXRlbSBjb250ZW50XG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gaXRlbSAtIGl0ZW0gd3JhcHBlciAoPGxpPilcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGdldEl0ZW1Db250ZW50KGUpIHtcbiAgICBjb25zdCB0ID0gZS5xdWVyeVNlbGVjdG9yKGAuJHt0aGlzLkNTUy5pdGVtQ29udGVudH1gKTtcbiAgICByZXR1cm4gQyh0KSA/IFwiXCIgOiB0LmlubmVySFRNTDtcbiAgfVxuICAvKipcbiAgICogU2V0cyBmb2N1cyB0byB0aGUgaXRlbSdzIGNvbnRlbnRcbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSBpdGVtIC0gaXRlbSAoPGxpPikgdG8gc2VsZWN0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gYXRTdGFydCAtIHdoZXJlIHRvIHNldCBmb2N1czogYXQgdGhlIHN0YXJ0IG9yIGF0IHRoZSBlbmRcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBmb2N1c0l0ZW0oZSwgdCA9ICEwKSB7XG4gICAgY29uc3QgciA9IGUucXVlcnlTZWxlY3RvcihgLiR7dGhpcy5DU1MuaXRlbUNvbnRlbnR9YCk7XG4gICAgYy5mb2N1cyhyLCB0KTtcbiAgfVxuICAvKipcbiAgICogR2V0IG91dCBmcm9tIExpc3QgVG9vbCBieSBFbnRlciBvbiB0aGUgZW1wdHkgbGFzdCBpdGVtXG4gICAqXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgZ2V0T3V0T2ZMaXN0KCkge1xuICAgIHRoaXMuY3VycmVudEl0ZW0ucmVtb3ZlKCksIHRoaXMuYXBpLmJsb2Nrcy5pbnNlcnQoKSwgdGhpcy5hcGkuY2FyZXQuc2V0VG9CbG9jayh0aGlzLmFwaS5ibG9ja3MuZ2V0Q3VycmVudEJsb2NrSW5kZXgoKSk7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZSBiYWNrc3BhY2VcbiAgICpcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudCAtIGtleWRvd25cbiAgICovXG4gIGJhY2tzcGFjZShlKSB7XG4gICAgaWYgKCFjLmlzQXRTdGFydCgpKVxuICAgICAgcmV0dXJuO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBjb25zdCB0ID0gdGhpcy5jdXJyZW50SXRlbSwgciA9IHQucHJldmlvdXNTaWJsaW5nLCBzID0gdC5wYXJlbnROb2RlLmNsb3Nlc3QoYC4ke3RoaXMuQ1NTLml0ZW19YCk7XG4gICAgaWYgKCFyICYmICFzKVxuICAgICAgcmV0dXJuO1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgbGV0IG47XG4gICAgaWYgKHIpIHtcbiAgICAgIGNvbnN0IGEgPSByLnF1ZXJ5U2VsZWN0b3JBbGwoYC4ke3RoaXMuQ1NTLml0ZW19YCk7XG4gICAgICBuID0gQXJyYXkuZnJvbShhKS5wb3AoKSB8fCByO1xuICAgIH0gZWxzZVxuICAgICAgbiA9IHM7XG4gICAgY29uc3QgbyA9IGMuZXh0cmFjdEZyYWdtZW50RnJvbUNhcmV0UG9zaXRpb25UaWxsVGhlRW5kKCksIGwgPSBnKG8pLCBoID0gbi5xdWVyeVNlbGVjdG9yKGAuJHt0aGlzLkNTUy5pdGVtQ29udGVudH1gKTtcbiAgICBjLmZvY3VzKGgsICExKSwgdGhpcy5jYXJldC5zYXZlKCksIGguaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlZW5kXCIsIGwpO1xuICAgIGxldCBpID0gdC5xdWVyeVNlbGVjdG9yQWxsKGAuJHt0aGlzLkNTUy5pdGVtQ2hpbGRyZW59ID4gLiR7dGhpcy5DU1MuaXRlbX1gKTtcbiAgICBpID0gQXJyYXkuZnJvbShpKSwgaSA9IGkuZmlsdGVyKChhKSA9PiBhLnBhcmVudE5vZGUuY2xvc2VzdChgLiR7dGhpcy5DU1MuaXRlbX1gKSA9PT0gdCksIGkucmV2ZXJzZSgpLmZvckVhY2goKGEpID0+IHtcbiAgICAgIHIgPyBuLmFmdGVyKGEpIDogdC5hZnRlcihhKTtcbiAgICB9KSwgdC5yZW1vdmUoKSwgdGhpcy5jYXJldC5yZXN0b3JlKCk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBpbmRlbnRhdGlvbiB0byBjdXJyZW50IGl0ZW1cbiAgICpcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudCAtIGtleWRvd25cbiAgICovXG4gIGFkZFRhYihlKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKSwgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IHQgPSB0aGlzLmN1cnJlbnRJdGVtLCByID0gdC5wcmV2aW91c1NpYmxpbmc7XG4gICAgaWYgKCFyKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG4gPSByLnF1ZXJ5U2VsZWN0b3IoYC4ke3RoaXMuQ1NTLml0ZW1DaGlsZHJlbn1gKTtcbiAgICBpZiAodGhpcy5jYXJldC5zYXZlKCksIG4pXG4gICAgICBuLmFwcGVuZENoaWxkKHQpO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgbyA9IHRoaXMubWFrZUxpc3RXcmFwcGVyKHZvaWQgMCwgW3RoaXMuQ1NTLml0ZW1DaGlsZHJlbl0pLCBsID0gci5xdWVyeVNlbGVjdG9yKGAuJHt0aGlzLkNTUy5pdGVtQm9keX1gKTtcbiAgICAgIG8uYXBwZW5kQ2hpbGQodCksIGwuYXBwZW5kQ2hpbGQobyk7XG4gICAgfVxuICAgIHRoaXMuY2FyZXQucmVzdG9yZSgpO1xuICB9XG4gIC8qKlxuICAgKiBSZWR1Y2UgaW5kZW50YXRpb24gZm9yIGN1cnJlbnQgaXRlbVxuICAgKlxuICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2ZW50IC0ga2V5ZG93blxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIHNoaWZ0VGFiKGUpIHtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpLCBlLnByZXZlbnREZWZhdWx0KCksIHRoaXMudW5zaGlmdEl0ZW0oKTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydCBmcm9tIGxpc3QgdG8gdGV4dCBmb3IgY29udmVyc2lvbkNvbmZpZ1xuICAgKlxuICAgKiBAcGFyYW0ge0xpc3REYXRhfSBkYXRhXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgam9pblJlY3Vyc2l2ZShlKSB7XG4gICAgcmV0dXJuIGUuaXRlbXMubWFwKCh0KSA9PiBgJHt0LmNvbnRlbnR9ICR7dS5qb2luUmVjdXJzaXZlKHQpfWApLmpvaW4oXCJcIik7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnQgZnJvbSB0ZXh0IHRvIGxpc3Qgd2l0aCBpbXBvcnQgYW5kIGV4cG9ydCBsaXN0IHRvIHRleHRcbiAgICovXG4gIHN0YXRpYyBnZXQgY29udmVyc2lvbkNvbmZpZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXhwb3J0OiAoZSkgPT4gdS5qb2luUmVjdXJzaXZlKGUpLFxuICAgICAgaW1wb3J0OiAoZSkgPT4gKHtcbiAgICAgICAgaXRlbXM6IFt7XG4gICAgICAgICAgY29udGVudDogZSxcbiAgICAgICAgICBpdGVtczogW11cbiAgICAgICAgfV0sXG4gICAgICAgIHN0eWxlOiBcInVub3JkZXJlZFwiXG4gICAgICB9KVxuICAgIH07XG4gIH1cbn1cbmV4cG9ydCB7XG4gIHUgYXMgZGVmYXVsdFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@editorjs/nested-list/dist/nested-list.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@editorjs/paragraph/dist/paragraph.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@editorjs/paragraph/dist/paragraph.mjs ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ n; }\n/* harmony export */ });\n(function(){\"use strict\";try{if(typeof document<\"u\"){var e=document.createElement(\"style\");e.appendChild(document.createTextNode(\".ce-paragraph{line-height:1.6em;outline:none}.ce-block:only-of-type .ce-paragraph[data-placeholder-active]:empty:before,.ce-block:only-of-type .ce-paragraph[data-placeholder-active][data-empty=true]:before{content:attr(data-placeholder-active)}.ce-paragraph p:first-of-type{margin-top:0}.ce-paragraph p:last-of-type{margin-bottom:0}\")),document.head.appendChild(e)}}catch(a){console.error(\"vite-plugin-css-injected-by-js\",a)}})();\nconst a = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M8 9V7.2C8 7.08954 8.08954 7 8.2 7L12 7M16 9V7.2C16 7.08954 15.9105 7 15.8 7L12 7M12 7L12 17M12 17H10M12 17H14\"/></svg>';\nfunction l(r) {\n  const t = document.createElement(\"div\");\n  t.innerHTML = r.trim();\n  const e = document.createDocumentFragment();\n  return e.append(...Array.from(t.childNodes)), e;\n}\n/**\n * Base Paragraph Block for the Editor.js.\n * Represents a regular text block\n *\n * @author CodeX (team@codex.so)\n * @copyright CodeX 2018\n * @license The MIT License (MIT)\n */\nclass n {\n  /**\n   * Default placeholder for Paragraph Tool\n   *\n   * @returns {string}\n   * @class\n   */\n  static get DEFAULT_PLACEHOLDER() {\n    return \"\";\n  }\n  /**\n   * Render plugin`s main Element and fill it with saved data\n   *\n   * @param {object} params - constructor params\n   * @param {ParagraphData} params.data - previously saved data\n   * @param {ParagraphConfig} params.config - user config for Tool\n   * @param {object} params.api - editor.js api\n   * @param {boolean} readOnly - read only mode flag\n   */\n  constructor({ data: t, config: e, api: i, readOnly: s }) {\n    this.api = i, this.readOnly = s, this._CSS = {\n      block: this.api.styles.block,\n      wrapper: \"ce-paragraph\"\n    }, this.readOnly || (this.onKeyUp = this.onKeyUp.bind(this)), this._placeholder = e.placeholder ? e.placeholder : n.DEFAULT_PLACEHOLDER, this._data = t ?? {}, this._element = null, this._preserveBlank = e.preserveBlank ?? !1;\n  }\n  /**\n   * Check if text content is empty and set empty string to inner html.\n   * We need this because some browsers (e.g. Safari) insert <br> into empty contenteditanle elements\n   *\n   * @param {KeyboardEvent} e - key up event\n   */\n  onKeyUp(t) {\n    if (t.code !== \"Backspace\" && t.code !== \"Delete\" || !this._element)\n      return;\n    const { textContent: e } = this._element;\n    e === \"\" && (this._element.innerHTML = \"\");\n  }\n  /**\n   * Create Tool's view\n   *\n   * @returns {HTMLDivElement}\n   * @private\n   */\n  drawView() {\n    const t = document.createElement(\"DIV\");\n    return t.classList.add(this._CSS.wrapper, this._CSS.block), t.contentEditable = \"false\", t.dataset.placeholderActive = this.api.i18n.t(this._placeholder), this._data.text && (t.innerHTML = this._data.text), this.readOnly || (t.contentEditable = \"true\", t.addEventListener(\"keyup\", this.onKeyUp)), t;\n  }\n  /**\n   * Return Tool's view\n   *\n   * @returns {HTMLDivElement}\n   */\n  render() {\n    return this._element = this.drawView(), this._element;\n  }\n  /**\n   * Method that specified how to merge two Text blocks.\n   * Called by Editor.js by backspace at the beginning of the Block\n   *\n   * @param {ParagraphData} data\n   * @public\n   */\n  merge(t) {\n    if (!this._element)\n      return;\n    this._data.text += t.text;\n    const e = l(t.text);\n    this._element.appendChild(e), this._element.normalize();\n  }\n  /**\n   * Validate Paragraph block data:\n   * - check for emptiness\n   *\n   * @param {ParagraphData} savedData  data received after saving\n   * @returns {boolean} false if saved data is not correct, otherwise true\n   * @public\n   */\n  validate(t) {\n    return !(t.text.trim() === \"\" && !this._preserveBlank);\n  }\n  /**\n   * Extract Tool's data from the view\n   *\n   * @param {HTMLDivElement} toolsContent - Paragraph tools rendered view\n   * @returns {ParagraphData} - saved data\n   * @public\n   */\n  save(t) {\n    return {\n      text: t.innerHTML\n    };\n  }\n  /**\n   * On paste callback fired from Editor.\n   *\n   * @param {HTMLPasteEvent} event - event with pasted data\n   */\n  onPaste(t) {\n    const e = {\n      text: t.detail.data.innerHTML\n    };\n    this._data = e, window.requestAnimationFrame(() => {\n      this._element && (this._element.innerHTML = this._data.text || \"\");\n    });\n  }\n  /**\n   * Enable Conversion Toolbar. Paragraph can be converted to/from other tools\n   * @returns {ConversionConfig}\n   */\n  static get conversionConfig() {\n    return {\n      export: \"text\",\n      // to convert Paragraph to other block, use 'text' property of saved data\n      import: \"text\"\n      // to covert other block's exported string to Paragraph, fill 'text' property of tool data\n    };\n  }\n  /**\n   * Sanitizer rules\n   * @returns {SanitizerConfig} - Edtior.js sanitizer config\n   */\n  static get sanitize() {\n    return {\n      text: {\n        br: !0\n      }\n    };\n  }\n  /**\n   * Returns true to notify the core that read-only mode is supported\n   *\n   * @returns {boolean}\n   */\n  static get isReadOnlySupported() {\n    return !0;\n  }\n  /**\n   * Used by Editor paste handling API.\n   * Provides configuration to handle P tags.\n   *\n   * @returns {PasteConfig} - Paragraph Paste Setting\n   */\n  static get pasteConfig() {\n    return {\n      tags: [\"P\"]\n    };\n  }\n  /**\n   * Icon and title for displaying at the Toolbox\n   *\n   * @returns {ToolboxConfig} - Paragraph Toolbox Setting\n   */\n  static get toolbox() {\n    return {\n      icon: a,\n      title: \"Text\"\n    };\n  }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZWRpdG9yanMvcGFyYWdyYXBoL2Rpc3QvcGFyYWdyYXBoLm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsWUFBWSxhQUFhLElBQUksd0JBQXdCLHNDQUFzQyxxREFBcUQsa0JBQWtCLGFBQWEsaUtBQWlLLHNDQUFzQyw4QkFBOEIsYUFBYSw2QkFBNkIsZ0JBQWdCLGtDQUFrQyxTQUFTLG1EQUFtRDtBQUM1aUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLGVBQWU7QUFDNUIsYUFBYSxpQkFBaUI7QUFDOUIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBLGdCQUFnQix5Q0FBeUM7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsS0FBSyw0SkFBNEo7QUFDaks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QixlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AZWRpdG9yanMvcGFyYWdyYXBoL2Rpc3QvcGFyYWdyYXBoLm1qcz80MzM5Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO3RyeXtpZih0eXBlb2YgZG9jdW1lbnQ8XCJ1XCIpe3ZhciBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiLmNlLXBhcmFncmFwaHtsaW5lLWhlaWdodDoxLjZlbTtvdXRsaW5lOm5vbmV9LmNlLWJsb2NrOm9ubHktb2YtdHlwZSAuY2UtcGFyYWdyYXBoW2RhdGEtcGxhY2Vob2xkZXItYWN0aXZlXTplbXB0eTpiZWZvcmUsLmNlLWJsb2NrOm9ubHktb2YtdHlwZSAuY2UtcGFyYWdyYXBoW2RhdGEtcGxhY2Vob2xkZXItYWN0aXZlXVtkYXRhLWVtcHR5PXRydWVdOmJlZm9yZXtjb250ZW50OmF0dHIoZGF0YS1wbGFjZWhvbGRlci1hY3RpdmUpfS5jZS1wYXJhZ3JhcGggcDpmaXJzdC1vZi10eXBle21hcmdpbi10b3A6MH0uY2UtcGFyYWdyYXBoIHA6bGFzdC1vZi10eXBle21hcmdpbi1ib3R0b206MH1cIikpLGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoZSl9fWNhdGNoKGEpe2NvbnNvbGUuZXJyb3IoXCJ2aXRlLXBsdWdpbi1jc3MtaW5qZWN0ZWQtYnktanNcIixhKX19KSgpO1xuY29uc3QgYSA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNOCA5VjcuMkM4IDcuMDg5NTQgOC4wODk1NCA3IDguMiA3TDEyIDdNMTYgOVY3LjJDMTYgNy4wODk1NCAxNS45MTA1IDcgMTUuOCA3TDEyIDdNMTIgN0wxMiAxN00xMiAxN0gxME0xMiAxN0gxNFwiLz48L3N2Zz4nO1xuZnVuY3Rpb24gbChyKSB7XG4gIGNvbnN0IHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICB0LmlubmVySFRNTCA9IHIudHJpbSgpO1xuICBjb25zdCBlID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICByZXR1cm4gZS5hcHBlbmQoLi4uQXJyYXkuZnJvbSh0LmNoaWxkTm9kZXMpKSwgZTtcbn1cbi8qKlxuICogQmFzZSBQYXJhZ3JhcGggQmxvY2sgZm9yIHRoZSBFZGl0b3IuanMuXG4gKiBSZXByZXNlbnRzIGEgcmVndWxhciB0ZXh0IGJsb2NrXG4gKlxuICogQGF1dGhvciBDb2RlWCAodGVhbUBjb2RleC5zbylcbiAqIEBjb3B5cmlnaHQgQ29kZVggMjAxOFxuICogQGxpY2Vuc2UgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKi9cbmNsYXNzIG4ge1xuICAvKipcbiAgICogRGVmYXVsdCBwbGFjZWhvbGRlciBmb3IgUGFyYWdyYXBoIFRvb2xcbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICogQGNsYXNzXG4gICAqL1xuICBzdGF0aWMgZ2V0IERFRkFVTFRfUExBQ0VIT0xERVIoKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlciBwbHVnaW5gcyBtYWluIEVsZW1lbnQgYW5kIGZpbGwgaXQgd2l0aCBzYXZlZCBkYXRhXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBjb25zdHJ1Y3RvciBwYXJhbXNcbiAgICogQHBhcmFtIHtQYXJhZ3JhcGhEYXRhfSBwYXJhbXMuZGF0YSAtIHByZXZpb3VzbHkgc2F2ZWQgZGF0YVxuICAgKiBAcGFyYW0ge1BhcmFncmFwaENvbmZpZ30gcGFyYW1zLmNvbmZpZyAtIHVzZXIgY29uZmlnIGZvciBUb29sXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMuYXBpIC0gZWRpdG9yLmpzIGFwaVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlYWRPbmx5IC0gcmVhZCBvbmx5IG1vZGUgZmxhZ1xuICAgKi9cbiAgY29uc3RydWN0b3IoeyBkYXRhOiB0LCBjb25maWc6IGUsIGFwaTogaSwgcmVhZE9ubHk6IHMgfSkge1xuICAgIHRoaXMuYXBpID0gaSwgdGhpcy5yZWFkT25seSA9IHMsIHRoaXMuX0NTUyA9IHtcbiAgICAgIGJsb2NrOiB0aGlzLmFwaS5zdHlsZXMuYmxvY2ssXG4gICAgICB3cmFwcGVyOiBcImNlLXBhcmFncmFwaFwiXG4gICAgfSwgdGhpcy5yZWFkT25seSB8fCAodGhpcy5vbktleVVwID0gdGhpcy5vbktleVVwLmJpbmQodGhpcykpLCB0aGlzLl9wbGFjZWhvbGRlciA9IGUucGxhY2Vob2xkZXIgPyBlLnBsYWNlaG9sZGVyIDogbi5ERUZBVUxUX1BMQUNFSE9MREVSLCB0aGlzLl9kYXRhID0gdCA/PyB7fSwgdGhpcy5fZWxlbWVudCA9IG51bGwsIHRoaXMuX3ByZXNlcnZlQmxhbmsgPSBlLnByZXNlcnZlQmxhbmsgPz8gITE7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRleHQgY29udGVudCBpcyBlbXB0eSBhbmQgc2V0IGVtcHR5IHN0cmluZyB0byBpbm5lciBodG1sLlxuICAgKiBXZSBuZWVkIHRoaXMgYmVjYXVzZSBzb21lIGJyb3dzZXJzIChlLmcuIFNhZmFyaSkgaW5zZXJ0IDxicj4gaW50byBlbXB0eSBjb250ZW50ZWRpdGFubGUgZWxlbWVudHNcbiAgICpcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBlIC0ga2V5IHVwIGV2ZW50XG4gICAqL1xuICBvbktleVVwKHQpIHtcbiAgICBpZiAodC5jb2RlICE9PSBcIkJhY2tzcGFjZVwiICYmIHQuY29kZSAhPT0gXCJEZWxldGVcIiB8fCAhdGhpcy5fZWxlbWVudClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IHRleHRDb250ZW50OiBlIH0gPSB0aGlzLl9lbGVtZW50O1xuICAgIGUgPT09IFwiXCIgJiYgKHRoaXMuX2VsZW1lbnQuaW5uZXJIVE1MID0gXCJcIik7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBUb29sJ3Mgdmlld1xuICAgKlxuICAgKiBAcmV0dXJucyB7SFRNTERpdkVsZW1lbnR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkcmF3VmlldygpIHtcbiAgICBjb25zdCB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkRJVlwiKTtcbiAgICByZXR1cm4gdC5jbGFzc0xpc3QuYWRkKHRoaXMuX0NTUy53cmFwcGVyLCB0aGlzLl9DU1MuYmxvY2spLCB0LmNvbnRlbnRFZGl0YWJsZSA9IFwiZmFsc2VcIiwgdC5kYXRhc2V0LnBsYWNlaG9sZGVyQWN0aXZlID0gdGhpcy5hcGkuaTE4bi50KHRoaXMuX3BsYWNlaG9sZGVyKSwgdGhpcy5fZGF0YS50ZXh0ICYmICh0LmlubmVySFRNTCA9IHRoaXMuX2RhdGEudGV4dCksIHRoaXMucmVhZE9ubHkgfHwgKHQuY29udGVudEVkaXRhYmxlID0gXCJ0cnVlXCIsIHQuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIHRoaXMub25LZXlVcCkpLCB0O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gVG9vbCdzIHZpZXdcbiAgICpcbiAgICogQHJldHVybnMge0hUTUxEaXZFbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9lbGVtZW50ID0gdGhpcy5kcmF3VmlldygpLCB0aGlzLl9lbGVtZW50O1xuICB9XG4gIC8qKlxuICAgKiBNZXRob2QgdGhhdCBzcGVjaWZpZWQgaG93IHRvIG1lcmdlIHR3byBUZXh0IGJsb2Nrcy5cbiAgICogQ2FsbGVkIGJ5IEVkaXRvci5qcyBieSBiYWNrc3BhY2UgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgQmxvY2tcbiAgICpcbiAgICogQHBhcmFtIHtQYXJhZ3JhcGhEYXRhfSBkYXRhXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIG1lcmdlKHQpIHtcbiAgICBpZiAoIXRoaXMuX2VsZW1lbnQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fZGF0YS50ZXh0ICs9IHQudGV4dDtcbiAgICBjb25zdCBlID0gbCh0LnRleHQpO1xuICAgIHRoaXMuX2VsZW1lbnQuYXBwZW5kQ2hpbGQoZSksIHRoaXMuX2VsZW1lbnQubm9ybWFsaXplKCk7XG4gIH1cbiAgLyoqXG4gICAqIFZhbGlkYXRlIFBhcmFncmFwaCBibG9jayBkYXRhOlxuICAgKiAtIGNoZWNrIGZvciBlbXB0aW5lc3NcbiAgICpcbiAgICogQHBhcmFtIHtQYXJhZ3JhcGhEYXRhfSBzYXZlZERhdGEg4oCUIGRhdGEgcmVjZWl2ZWQgYWZ0ZXIgc2F2aW5nXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBmYWxzZSBpZiBzYXZlZCBkYXRhIGlzIG5vdCBjb3JyZWN0LCBvdGhlcndpc2UgdHJ1ZVxuICAgKiBAcHVibGljXG4gICAqL1xuICB2YWxpZGF0ZSh0KSB7XG4gICAgcmV0dXJuICEodC50ZXh0LnRyaW0oKSA9PT0gXCJcIiAmJiAhdGhpcy5fcHJlc2VydmVCbGFuayk7XG4gIH1cbiAgLyoqXG4gICAqIEV4dHJhY3QgVG9vbCdzIGRhdGEgZnJvbSB0aGUgdmlld1xuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxEaXZFbGVtZW50fSB0b29sc0NvbnRlbnQgLSBQYXJhZ3JhcGggdG9vbHMgcmVuZGVyZWQgdmlld1xuICAgKiBAcmV0dXJucyB7UGFyYWdyYXBoRGF0YX0gLSBzYXZlZCBkYXRhXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHNhdmUodCkge1xuICAgIHJldHVybiB7XG4gICAgICB0ZXh0OiB0LmlubmVySFRNTFxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIE9uIHBhc3RlIGNhbGxiYWNrIGZpcmVkIGZyb20gRWRpdG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxQYXN0ZUV2ZW50fSBldmVudCAtIGV2ZW50IHdpdGggcGFzdGVkIGRhdGFcbiAgICovXG4gIG9uUGFzdGUodCkge1xuICAgIGNvbnN0IGUgPSB7XG4gICAgICB0ZXh0OiB0LmRldGFpbC5kYXRhLmlubmVySFRNTFxuICAgIH07XG4gICAgdGhpcy5fZGF0YSA9IGUsIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgdGhpcy5fZWxlbWVudCAmJiAodGhpcy5fZWxlbWVudC5pbm5lckhUTUwgPSB0aGlzLl9kYXRhLnRleHQgfHwgXCJcIik7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZSBDb252ZXJzaW9uIFRvb2xiYXIuIFBhcmFncmFwaCBjYW4gYmUgY29udmVydGVkIHRvL2Zyb20gb3RoZXIgdG9vbHNcbiAgICogQHJldHVybnMge0NvbnZlcnNpb25Db25maWd9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGNvbnZlcnNpb25Db25maWcoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGV4cG9ydDogXCJ0ZXh0XCIsXG4gICAgICAvLyB0byBjb252ZXJ0IFBhcmFncmFwaCB0byBvdGhlciBibG9jaywgdXNlICd0ZXh0JyBwcm9wZXJ0eSBvZiBzYXZlZCBkYXRhXG4gICAgICBpbXBvcnQ6IFwidGV4dFwiXG4gICAgICAvLyB0byBjb3ZlcnQgb3RoZXIgYmxvY2sncyBleHBvcnRlZCBzdHJpbmcgdG8gUGFyYWdyYXBoLCBmaWxsICd0ZXh0JyBwcm9wZXJ0eSBvZiB0b29sIGRhdGFcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBTYW5pdGl6ZXIgcnVsZXNcbiAgICogQHJldHVybnMge1Nhbml0aXplckNvbmZpZ30gLSBFZHRpb3IuanMgc2FuaXRpemVyIGNvbmZpZ1xuICAgKi9cbiAgc3RhdGljIGdldCBzYW5pdGl6ZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGV4dDoge1xuICAgICAgICBicjogITBcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgdG8gbm90aWZ5IHRoZSBjb3JlIHRoYXQgcmVhZC1vbmx5IG1vZGUgaXMgc3VwcG9ydGVkXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGdldCBpc1JlYWRPbmx5U3VwcG9ydGVkKCkge1xuICAgIHJldHVybiAhMDtcbiAgfVxuICAvKipcbiAgICogVXNlZCBieSBFZGl0b3IgcGFzdGUgaGFuZGxpbmcgQVBJLlxuICAgKiBQcm92aWRlcyBjb25maWd1cmF0aW9uIHRvIGhhbmRsZSBQIHRhZ3MuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQYXN0ZUNvbmZpZ30gLSBQYXJhZ3JhcGggUGFzdGUgU2V0dGluZ1xuICAgKi9cbiAgc3RhdGljIGdldCBwYXN0ZUNvbmZpZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGFnczogW1wiUFwiXVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEljb24gYW5kIHRpdGxlIGZvciBkaXNwbGF5aW5nIGF0IHRoZSBUb29sYm94XG4gICAqXG4gICAqIEByZXR1cm5zIHtUb29sYm94Q29uZmlnfSAtIFBhcmFncmFwaCBUb29sYm94IFNldHRpbmdcbiAgICovXG4gIHN0YXRpYyBnZXQgdG9vbGJveCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaWNvbjogYSxcbiAgICAgIHRpdGxlOiBcIlRleHRcIlxuICAgIH07XG4gIH1cbn1cbmV4cG9ydCB7XG4gIG4gYXMgZGVmYXVsdFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@editorjs/paragraph/dist/paragraph.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@editorjs/table/dist/table.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/@editorjs/table/dist/table.mjs ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ I; }\n/* harmony export */ });\n(function(){\"use strict\";try{if(typeof document<\"u\"){var o=document.createElement(\"style\");o.appendChild(document.createTextNode('.tc-wrap{--color-background:#f9f9fb;--color-text-secondary:#7b7e89;--color-border:#e8e8eb;--cell-size:34px;--toolbox-icon-size:18px;--toolbox-padding:6px;--toolbox-aiming-field-size:calc(var(--toolbox-icon-size) + var(--toolbox-padding)*2);border-left:0;position:relative;height:100%;width:100%;margin-top:var(--toolbox-icon-size);box-sizing:border-box;display:grid;grid-template-columns:calc(100% - var(--cell-size)) var(--cell-size)}.tc-wrap--readonly{grid-template-columns:100% var(--cell-size)}.tc-wrap svg{vertical-align:top}@media print{.tc-wrap{border-left-color:var(--color-border);border-left-style:solid;border-left-width:1px;grid-template-columns:100% var(--cell-size)}}@media print{.tc-wrap .tc-row:after{display:none}}.tc-table{position:relative;width:100%;height:100%;display:grid;font-size:14px;border-top:1px solid var(--color-border);line-height:1.4}.tc-table:after{width:calc(var(--cell-size));height:100%;left:calc(var(--cell-size)*-1);top:0}.tc-table:after,.tc-table:before{position:absolute;content:\"\"}.tc-table:before{width:100%;height:var(--toolbox-aiming-field-size);top:calc(var(--toolbox-aiming-field-size)*-1);left:0}.tc-table--heading .tc-row:first-child{font-weight:600;border-bottom:2px solid var(--color-border)}.tc-table--heading .tc-row:first-child [contenteditable]:empty:before{content:attr(heading);color:var(--color-text-secondary)}.tc-table--heading .tc-row:first-child:after{bottom:-2px;border-bottom:2px solid var(--color-border)}.tc-add-column,.tc-add-row{display:flex;color:var(--color-text-secondary)}@media print{.tc-add{display:none}}.tc-add-column{padding:4px 0;justify-content:center;border-top:1px solid var(--color-border)}@media print{.tc-add-column{display:none}}.tc-add-row{height:var(--cell-size);align-items:center;padding-left:4px;position:relative}.tc-add-row:before{content:\"\";position:absolute;right:calc(var(--cell-size)*-1);width:var(--cell-size);height:100%}@media print{.tc-add-row{display:none}}.tc-add-column,.tc-add-row{transition:0s;cursor:pointer;will-change:background-color}.tc-add-column:hover,.tc-add-row:hover{transition:background-color .1s ease;background-color:var(--color-background)}.tc-add-row{margin-top:1px}.tc-add-row:hover:before{transition:.1s;background-color:var(--color-background)}.tc-row{display:grid;grid-template-columns:repeat(auto-fit,minmax(10px,1fr));position:relative;border-bottom:1px solid var(--color-border)}.tc-row:after{content:\"\";pointer-events:none;position:absolute;width:var(--cell-size);height:100%;bottom:-1px;right:calc(var(--cell-size)*-1);border-bottom:1px solid var(--color-border)}.tc-row--selected{background:var(--color-background)}.tc-row--selected:after{background:var(--color-background)}.tc-cell{border-right:1px solid var(--color-border);padding:6px 12px;overflow:hidden;outline:none;line-break:normal}.tc-cell--selected{background:var(--color-background)}.tc-wrap--readonly .tc-row:after{display:none}.tc-toolbox{--toolbox-padding:6px;--popover-margin:30px;--toggler-click-zone-size:30px;--toggler-dots-color:#7b7e89;--toggler-dots-color-hovered:#1d202b;position:absolute;cursor:pointer;z-index:1;opacity:0;transition:opacity .1s;will-change:left,opacity}.tc-toolbox--column{top:calc(var(--toggler-click-zone-size)*-1);transform:translate(calc(var(--toggler-click-zone-size)*-1/2));will-change:left,opacity}.tc-toolbox--row{left:calc(var(--popover-margin)*-1);transform:translateY(calc(var(--toggler-click-zone-size)*-1/2));margin-top:-1px;will-change:top,opacity}.tc-toolbox--showed{opacity:1}.tc-toolbox .tc-popover{position:absolute;top:0;left:var(--popover-margin)}.tc-toolbox__toggler{display:flex;align-items:center;justify-content:center;width:var(--toggler-click-zone-size);height:var(--toggler-click-zone-size);color:var(--toggler-dots-color);opacity:0;transition:opacity .15s ease;will-change:opacity}.tc-toolbox__toggler:hover{color:var(--toggler-dots-color-hovered)}.tc-toolbox__toggler svg{fill:currentColor}.tc-wrap:hover .tc-toolbox__toggler{opacity:1}.tc-settings .cdx-settings-button{width:50%;margin:0}.tc-popover{--color-border:#eaeaea;--color-background:#fff;--color-background-hover:rgba(232,232,235,.49);--color-background-confirm:#e24a4a;--color-background-confirm-hover:#d54040;--color-text-confirm:#fff;background:var(--color-background);border:1px solid var(--color-border);box-shadow:0 3px 15px -3px #0d142121;border-radius:6px;padding:6px;display:none;will-change:opacity,transform}.tc-popover--opened{display:block;animation:menuShowing .1s cubic-bezier(.215,.61,.355,1) forwards}.tc-popover__item{display:flex;align-items:center;padding:2px 14px 2px 2px;border-radius:5px;cursor:pointer;white-space:nowrap;-webkit-user-select:none;-moz-user-select:none;user-select:none}.tc-popover__item:hover{background:var(--color-background-hover)}.tc-popover__item:not(:last-of-type){margin-bottom:2px}.tc-popover__item-icon{display:inline-flex;width:26px;height:26px;align-items:center;justify-content:center;background:var(--color-background);border-radius:5px;border:1px solid var(--color-border);margin-right:8px}.tc-popover__item-label{line-height:22px;font-size:14px;font-weight:500}.tc-popover__item--confirm{background:var(--color-background-confirm);color:var(--color-text-confirm)}.tc-popover__item--confirm:hover{background-color:var(--color-background-confirm-hover)}.tc-popover__item--confirm .tc-popover__item-icon{background:var(--color-background-confirm);border-color:#0000001a}.tc-popover__item--confirm .tc-popover__item-icon svg{transition:transform .2s ease-in;transform:rotate(90deg) scale(1.2)}.tc-popover__item--hidden{display:none}@keyframes menuShowing{0%{opacity:0;transform:translateY(-8px) scale(.9)}70%{opacity:1;transform:translateY(2px)}to{transform:translateY(0)}}')),document.head.appendChild(o)}}catch(r){console.error(\"vite-plugin-css-injected-by-js\",r)}})();\nfunction c(d, t, e = {}) {\n  const o = document.createElement(d);\n  Array.isArray(t) ? o.classList.add(...t) : t && o.classList.add(t);\n  for (const i in e)\n    Object.prototype.hasOwnProperty.call(e, i) && (o[i] = e[i]);\n  return o;\n}\nfunction f(d) {\n  const t = d.getBoundingClientRect();\n  return {\n    y1: Math.floor(t.top + window.pageYOffset),\n    x1: Math.floor(t.left + window.pageXOffset),\n    x2: Math.floor(t.right + window.pageXOffset),\n    y2: Math.floor(t.bottom + window.pageYOffset)\n  };\n}\nfunction g(d, t) {\n  const e = f(d), o = f(t);\n  return {\n    fromTopBorder: o.y1 - e.y1,\n    fromLeftBorder: o.x1 - e.x1,\n    fromRightBorder: e.x2 - o.x2,\n    fromBottomBorder: e.y2 - o.y2\n  };\n}\nfunction R(d, t) {\n  const e = d.getBoundingClientRect(), { width: o, height: i, x: s, y: n } = e, { clientX: h, clientY: l } = t;\n  return {\n    width: o,\n    height: i,\n    x: h - s,\n    y: l - n\n  };\n}\nfunction C(d, t) {\n  return t.parentNode.insertBefore(d, t);\n}\nfunction m(d, t = !0) {\n  const e = document.createRange(), o = window.getSelection();\n  e.selectNodeContents(d), e.collapse(t), o.removeAllRanges(), o.addRange(e);\n}\nclass a {\n  /**\n   * @param {object} options - constructor options\n   * @param {PopoverItem[]} options.items - constructor options\n   */\n  constructor({ items: t }) {\n    this.items = t, this.wrapper = void 0, this.itemEls = [];\n  }\n  /**\n   * Set of CSS classnames used in popover\n   *\n   * @returns {object}\n   */\n  static get CSS() {\n    return {\n      popover: \"tc-popover\",\n      popoverOpened: \"tc-popover--opened\",\n      item: \"tc-popover__item\",\n      itemHidden: \"tc-popover__item--hidden\",\n      itemConfirmState: \"tc-popover__item--confirm\",\n      itemIcon: \"tc-popover__item-icon\",\n      itemLabel: \"tc-popover__item-label\"\n    };\n  }\n  /**\n   * Returns the popover element\n   *\n   * @returns {Element}\n   */\n  render() {\n    return this.wrapper = c(\"div\", a.CSS.popover), this.items.forEach((t, e) => {\n      const o = c(\"div\", a.CSS.item), i = c(\"div\", a.CSS.itemIcon, {\n        innerHTML: t.icon\n      }), s = c(\"div\", a.CSS.itemLabel, {\n        textContent: t.label\n      });\n      o.dataset.index = e, o.appendChild(i), o.appendChild(s), this.wrapper.appendChild(o), this.itemEls.push(o);\n    }), this.wrapper.addEventListener(\"click\", (t) => {\n      this.popoverClicked(t);\n    }), this.wrapper;\n  }\n  /**\n   * Popover wrapper click listener\n   * Used to delegate clicks in items\n   *\n   * @returns {void}\n   */\n  popoverClicked(t) {\n    const e = t.target.closest(`.${a.CSS.item}`);\n    if (!e)\n      return;\n    const o = e.dataset.index, i = this.items[o];\n    if (i.confirmationRequired && !this.hasConfirmationState(e)) {\n      this.setConfirmationState(e);\n      return;\n    }\n    i.onClick();\n  }\n  /**\n   * Enable the confirmation state on passed item\n   *\n   * @returns {void}\n   */\n  setConfirmationState(t) {\n    t.classList.add(a.CSS.itemConfirmState);\n  }\n  /**\n   * Disable the confirmation state on passed item\n   *\n   * @returns {void}\n   */\n  clearConfirmationState(t) {\n    t.classList.remove(a.CSS.itemConfirmState);\n  }\n  /**\n   * Check if passed item has the confirmation state\n   *\n   * @returns {boolean}\n   */\n  hasConfirmationState(t) {\n    return t.classList.contains(a.CSS.itemConfirmState);\n  }\n  /**\n   * Return an opening state\n   *\n   * @returns {boolean}\n   */\n  get opened() {\n    return this.wrapper.classList.contains(a.CSS.popoverOpened);\n  }\n  /**\n   * Opens the popover\n   *\n   * @returns {void}\n   */\n  open() {\n    this.items.forEach((t, e) => {\n      typeof t.hideIf == \"function\" && this.itemEls[e].classList.toggle(a.CSS.itemHidden, t.hideIf());\n    }), this.wrapper.classList.add(a.CSS.popoverOpened);\n  }\n  /**\n   * Closes the popover\n   *\n   * @returns {void}\n   */\n  close() {\n    this.wrapper.classList.remove(a.CSS.popoverOpened), this.itemEls.forEach((t) => {\n      this.clearConfirmationState(t);\n    });\n  }\n}\nconst b = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M8 8L12 12M12 12L16 16M12 12L16 8M12 12L8 16\"/></svg>', k = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M14.8833 9.16666L18.2167 12.5M18.2167 12.5L14.8833 15.8333M18.2167 12.5H10.05C9.16594 12.5 8.31809 12.1488 7.69297 11.5237C7.06785 10.8986 6.71666 10.0507 6.71666 9.16666\"/></svg>', S = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M14.9167 14.9167L11.5833 18.25M11.5833 18.25L8.25 14.9167M11.5833 18.25L11.5833 10.0833C11.5833 9.19928 11.9345 8.35143 12.5596 7.72631C13.1848 7.10119 14.0326 6.75 14.9167 6.75\"/></svg>', x = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M9.13333 14.9167L12.4667 18.25M12.4667 18.25L15.8 14.9167M12.4667 18.25L12.4667 10.0833C12.4667 9.19928 12.1155 8.35143 11.4904 7.72631C10.8652 7.10119 10.0174 6.75 9.13333 6.75\"/></svg>', y = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M14.8833 15.8333L18.2167 12.5M18.2167 12.5L14.8833 9.16667M18.2167 12.5L10.05 12.5C9.16595 12.5 8.31811 12.8512 7.69299 13.4763C7.06787 14.1014 6.71667 14.9493 6.71667 15.8333\"/></svg>', T = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2.6\" d=\"M9.41 9.66H9.4\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2.6\" d=\"M14.6 9.66H14.59\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2.6\" d=\"M9.31 14.36H9.3\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2.6\" d=\"M14.6 14.36H14.59\"/></svg>', v = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M12 7V12M12 17V12M17 12H12M12 12H7\"/></svg>', L = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-width=\"2\" d=\"M5 10H19\"/><rect width=\"14\" height=\"14\" x=\"5\" y=\"5\" stroke=\"currentColor\" stroke-width=\"2\" rx=\"4\"/></svg>', M = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-width=\"2\" d=\"M10 5V18.5\"/><path stroke=\"currentColor\" stroke-width=\"2\" d=\"M14 5V18.5\"/><path stroke=\"currentColor\" stroke-width=\"2\" d=\"M5 10H19\"/><path stroke=\"currentColor\" stroke-width=\"2\" d=\"M5 14H19\"/><rect width=\"14\" height=\"14\" x=\"5\" y=\"5\" stroke=\"currentColor\" stroke-width=\"2\" rx=\"4\"/></svg>', O = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-width=\"2\" d=\"M10 5V18.5\"/><path stroke=\"currentColor\" stroke-width=\"2\" d=\"M5 10H19\"/><rect width=\"14\" height=\"14\" x=\"5\" y=\"5\" stroke=\"currentColor\" stroke-width=\"2\" rx=\"4\"/></svg>';\nclass u {\n  /**\n   * Creates toolbox buttons and toolbox menus\n   *\n   * @param {object} api - Editor.js api\n   * @param {PopoverItem[]} items - Editor.js api\n   * @param {function} onOpen - callback fired when the Popover is opening\n   * @param {function} onClose - callback fired when the Popover is closing\n   * @param {string} [cssModifier] - the modifier for the Toolbox. Allows to add some specific styles.\n   */\n  constructor({ api: t, items: e, onOpen: o, onClose: i, cssModifier: s = \"\" }) {\n    this.api = t, this.items = e, this.onOpen = o, this.onClose = i, this.cssModifier = s, this.popover = null, this.wrapper = this.createToolbox();\n  }\n  /**\n   * Style classes\n   */\n  static get CSS() {\n    return {\n      toolbox: \"tc-toolbox\",\n      toolboxShowed: \"tc-toolbox--showed\",\n      toggler: \"tc-toolbox__toggler\"\n    };\n  }\n  /**\n   * Returns rendered Toolbox element\n   */\n  get element() {\n    return this.wrapper;\n  }\n  /**\n   * Creating a toolbox to open menu for a manipulating columns\n   *\n   * @returns {Element}\n   */\n  createToolbox() {\n    const t = c(\"div\", [\n      u.CSS.toolbox,\n      this.cssModifier ? `${u.CSS.toolbox}--${this.cssModifier}` : \"\"\n    ]);\n    t.dataset.mutationFree = \"true\";\n    const e = this.createPopover(), o = this.createToggler();\n    return t.appendChild(o), t.appendChild(e), t;\n  }\n  /**\n   * Creates the Toggler\n   *\n   * @returns {Element}\n   */\n  createToggler() {\n    const t = c(\"div\", u.CSS.toggler, {\n      innerHTML: T\n    });\n    return t.addEventListener(\"click\", () => {\n      this.togglerClicked();\n    }), t;\n  }\n  /**\n   * Creates the Popover instance and render it\n   *\n   * @returns {Element}\n   */\n  createPopover() {\n    return this.popover = new a({\n      items: this.items\n    }), this.popover.render();\n  }\n  /**\n   * Toggler click handler. Opens/Closes the popover\n   *\n   * @returns {void}\n   */\n  togglerClicked() {\n    this.popover.opened ? (this.popover.close(), this.onClose()) : (this.popover.open(), this.onOpen());\n  }\n  /**\n   * Shows the Toolbox\n   *\n   * @param {function} computePositionMethod - method that returns the position coordinate\n   * @returns {void}\n   */\n  show(t) {\n    const e = t();\n    Object.entries(e).forEach(([o, i]) => {\n      this.wrapper.style[o] = i;\n    }), this.wrapper.classList.add(u.CSS.toolboxShowed);\n  }\n  /**\n   * Hides the Toolbox\n   *\n   * @returns {void}\n   */\n  hide() {\n    this.popover.close(), this.wrapper.classList.remove(u.CSS.toolboxShowed);\n  }\n}\nfunction H(d, t) {\n  let e = 0;\n  return function(...o) {\n    const i = (/* @__PURE__ */ new Date()).getTime();\n    if (!(i - e < d))\n      return e = i, t(...o);\n  };\n}\nconst r = {\n  wrapper: \"tc-wrap\",\n  wrapperReadOnly: \"tc-wrap--readonly\",\n  table: \"tc-table\",\n  row: \"tc-row\",\n  withHeadings: \"tc-table--heading\",\n  rowSelected: \"tc-row--selected\",\n  cell: \"tc-cell\",\n  cellSelected: \"tc-cell--selected\",\n  addRow: \"tc-add-row\",\n  addColumn: \"tc-add-column\"\n};\nclass A {\n  /**\n   * Creates\n   *\n   * @constructor\n   * @param {boolean} readOnly - read-only mode flag\n   * @param {object} api - Editor.js API\n   * @param {TableData} data - Editor.js API\n   * @param {TableConfig} config - Editor.js API\n   */\n  constructor(t, e, o, i) {\n    this.readOnly = t, this.api = e, this.data = o, this.config = i, this.wrapper = null, this.table = null, this.toolboxColumn = this.createColumnToolbox(), this.toolboxRow = this.createRowToolbox(), this.createTableWrapper(), this.hoveredRow = 0, this.hoveredColumn = 0, this.selectedRow = 0, this.selectedColumn = 0, this.tunes = {\n      withHeadings: !1\n    }, this.resize(), this.fill(), this.focusedCell = {\n      row: 0,\n      column: 0\n    }, this.documentClicked = (s) => {\n      const n = s.target.closest(`.${r.table}`) !== null, h = s.target.closest(`.${r.wrapper}`) === null;\n      (n || h) && this.hideToolboxes();\n      const w = s.target.closest(`.${r.addRow}`), p = s.target.closest(`.${r.addColumn}`);\n      w && w.parentNode === this.wrapper ? (this.addRow(void 0, !0), this.hideToolboxes()) : p && p.parentNode === this.wrapper && (this.addColumn(void 0, !0), this.hideToolboxes());\n    }, this.readOnly || this.bindEvents();\n  }\n  /**\n   * Returns the rendered table wrapper\n   *\n   * @returns {Element}\n   */\n  getWrapper() {\n    return this.wrapper;\n  }\n  /**\n   * Hangs the necessary handlers to events\n   */\n  bindEvents() {\n    document.addEventListener(\"click\", this.documentClicked), this.table.addEventListener(\"mousemove\", H(150, (t) => this.onMouseMoveInTable(t)), { passive: !0 }), this.table.onkeypress = (t) => this.onKeyPressListener(t), this.table.addEventListener(\"keydown\", (t) => this.onKeyDownListener(t)), this.table.addEventListener(\"focusin\", (t) => this.focusInTableListener(t));\n  }\n  /**\n   * Configures and creates the toolbox for manipulating with columns\n   *\n   * @returns {Toolbox}\n   */\n  createColumnToolbox() {\n    return new u({\n      api: this.api,\n      cssModifier: \"column\",\n      items: [\n        {\n          label: this.api.i18n.t(\"Add column to left\"),\n          icon: S,\n          onClick: () => {\n            this.addColumn(this.selectedColumn, !0), this.hideToolboxes();\n          }\n        },\n        {\n          label: this.api.i18n.t(\"Add column to right\"),\n          icon: x,\n          onClick: () => {\n            this.addColumn(this.selectedColumn + 1, !0), this.hideToolboxes();\n          }\n        },\n        {\n          label: this.api.i18n.t(\"Delete column\"),\n          icon: b,\n          hideIf: () => this.numberOfColumns === 1,\n          confirmationRequired: !0,\n          onClick: () => {\n            this.deleteColumn(this.selectedColumn), this.hideToolboxes();\n          }\n        }\n      ],\n      onOpen: () => {\n        this.selectColumn(this.hoveredColumn), this.hideRowToolbox();\n      },\n      onClose: () => {\n        this.unselectColumn();\n      }\n    });\n  }\n  /**\n   * Configures and creates the toolbox for manipulating with rows\n   *\n   * @returns {Toolbox}\n   */\n  createRowToolbox() {\n    return new u({\n      api: this.api,\n      cssModifier: \"row\",\n      items: [\n        {\n          label: this.api.i18n.t(\"Add row above\"),\n          icon: y,\n          onClick: () => {\n            this.addRow(this.selectedRow, !0), this.hideToolboxes();\n          }\n        },\n        {\n          label: this.api.i18n.t(\"Add row below\"),\n          icon: k,\n          onClick: () => {\n            this.addRow(this.selectedRow + 1, !0), this.hideToolboxes();\n          }\n        },\n        {\n          label: this.api.i18n.t(\"Delete row\"),\n          icon: b,\n          hideIf: () => this.numberOfRows === 1,\n          confirmationRequired: !0,\n          onClick: () => {\n            this.deleteRow(this.selectedRow), this.hideToolboxes();\n          }\n        }\n      ],\n      onOpen: () => {\n        this.selectRow(this.hoveredRow), this.hideColumnToolbox();\n      },\n      onClose: () => {\n        this.unselectRow();\n      }\n    });\n  }\n  /**\n   * When you press enter it moves the cursor down to the next row\n   * or creates it if the click occurred on the last one\n   */\n  moveCursorToNextRow() {\n    this.focusedCell.row !== this.numberOfRows ? (this.focusedCell.row += 1, this.focusCell(this.focusedCell)) : (this.addRow(), this.focusedCell.row += 1, this.focusCell(this.focusedCell), this.updateToolboxesPosition(0, 0));\n  }\n  /**\n   * Get table cell by row and col index\n   *\n   * @param {number} row - cell row coordinate\n   * @param {number} column - cell column coordinate\n   * @returns {HTMLElement}\n   */\n  getCell(t, e) {\n    return this.table.querySelectorAll(`.${r.row}:nth-child(${t}) .${r.cell}`)[e - 1];\n  }\n  /**\n   * Get table row by index\n   *\n   * @param {number} row - row coordinate\n   * @returns {HTMLElement}\n   */\n  getRow(t) {\n    return this.table.querySelector(`.${r.row}:nth-child(${t})`);\n  }\n  /**\n   * The parent of the cell which is the row\n   *\n   * @param {HTMLElement} cell - cell element\n   * @returns {HTMLElement}\n   */\n  getRowByCell(t) {\n    return t.parentElement;\n  }\n  /**\n   * Ger row's first cell\n   *\n   * @param {Element} row - row to find its first cell\n   * @returns {Element}\n   */\n  getRowFirstCell(t) {\n    return t.querySelector(`.${r.cell}:first-child`);\n  }\n  /**\n   * Set the sell's content by row and column numbers\n   *\n   * @param {number} row - cell row coordinate\n   * @param {number} column - cell column coordinate\n   * @param {string} content - cell HTML content\n   */\n  setCellContent(t, e, o) {\n    const i = this.getCell(t, e);\n    i.innerHTML = o;\n  }\n  /**\n   * Add column in table on index place\n   * Add cells in each row\n   *\n   * @param {number} columnIndex - number in the array of columns, where new column to insert, -1 if insert at the end\n   * @param {boolean} [setFocus] - pass true to focus the first cell\n   */\n  addColumn(t = -1, e = !1) {\n    let o = this.numberOfColumns;\n    for (let i = 1; i <= this.numberOfRows; i++) {\n      let s;\n      const n = this.createCell();\n      if (t > 0 && t <= o ? (s = this.getCell(i, t), C(n, s)) : s = this.getRow(i).appendChild(n), i === 1) {\n        const h = this.getCell(i, t > 0 ? t : o + 1);\n        h && e && m(h);\n      }\n    }\n    this.addHeadingAttrToFirstRow();\n  }\n  /**\n   * Add row in table on index place\n   *\n   * @param {number} index - number in the array of rows, where new column to insert, -1 if insert at the end\n   * @param {boolean} [setFocus] - pass true to focus the inserted row\n   * @returns {HTMLElement} row\n   */\n  addRow(t = -1, e = !1) {\n    let o, i = c(\"div\", r.row);\n    this.tunes.withHeadings && this.removeHeadingAttrFromFirstRow();\n    let s = this.numberOfColumns;\n    if (t > 0 && t <= this.numberOfRows) {\n      let h = this.getRow(t);\n      o = C(i, h);\n    } else\n      o = this.table.appendChild(i);\n    this.fillRow(o, s), this.tunes.withHeadings && this.addHeadingAttrToFirstRow();\n    const n = this.getRowFirstCell(o);\n    return n && e && m(n), o;\n  }\n  /**\n   * Delete a column by index\n   *\n   * @param {number} index\n   */\n  deleteColumn(t) {\n    for (let e = 1; e <= this.numberOfRows; e++) {\n      const o = this.getCell(e, t);\n      if (!o)\n        return;\n      o.remove();\n    }\n  }\n  /**\n   * Delete a row by index\n   *\n   * @param {number} index\n   */\n  deleteRow(t) {\n    this.getRow(t).remove(), this.addHeadingAttrToFirstRow();\n  }\n  /**\n   * Create a wrapper containing a table, toolboxes\n   * and buttons for adding rows and columns\n   *\n   * @returns {HTMLElement} wrapper - where all buttons for a table and the table itself will be\n   */\n  createTableWrapper() {\n    if (this.wrapper = c(\"div\", r.wrapper), this.table = c(\"div\", r.table), this.readOnly && this.wrapper.classList.add(r.wrapperReadOnly), this.wrapper.appendChild(this.toolboxRow.element), this.wrapper.appendChild(this.toolboxColumn.element), this.wrapper.appendChild(this.table), !this.readOnly) {\n      const t = c(\"div\", r.addColumn, {\n        innerHTML: v\n      }), e = c(\"div\", r.addRow, {\n        innerHTML: v\n      });\n      this.wrapper.appendChild(t), this.wrapper.appendChild(e);\n    }\n  }\n  /**\n   * Returns the size of the table based on initial data or config \"size\" property\n   *\n   * @return {{rows: number, cols: number}} - number of cols and rows\n   */\n  computeInitialSize() {\n    const t = this.data && this.data.content, e = Array.isArray(t), o = e ? t.length : !1, i = e ? t.length : void 0, s = o ? t[0].length : void 0, n = Number.parseInt(this.config && this.config.rows), h = Number.parseInt(this.config && this.config.cols), l = !isNaN(n) && n > 0 ? n : void 0, w = !isNaN(h) && h > 0 ? h : void 0;\n    return {\n      rows: i || l || 2,\n      cols: s || w || 2\n    };\n  }\n  /**\n   * Resize table to match config size or transmitted data size\n   *\n   * @return {{rows: number, cols: number}} - number of cols and rows\n   */\n  resize() {\n    const { rows: t, cols: e } = this.computeInitialSize();\n    for (let o = 0; o < t; o++)\n      this.addRow();\n    for (let o = 0; o < e; o++)\n      this.addColumn();\n  }\n  /**\n   * Fills the table with data passed to the constructor\n   *\n   * @returns {void}\n   */\n  fill() {\n    const t = this.data;\n    if (t && t.content)\n      for (let e = 0; e < t.content.length; e++)\n        for (let o = 0; o < t.content[e].length; o++)\n          this.setCellContent(e + 1, o + 1, t.content[e][o]);\n  }\n  /**\n   * Fills a row with cells\n   *\n   * @param {HTMLElement} row - row to fill\n   * @param {number} numberOfColumns - how many cells should be in a row\n   */\n  fillRow(t, e) {\n    for (let o = 1; o <= e; o++) {\n      const i = this.createCell();\n      t.appendChild(i);\n    }\n  }\n  /**\n   * Creating a cell element\n   *\n   * @return {Element}\n   */\n  createCell() {\n    return c(\"div\", r.cell, {\n      contentEditable: !this.readOnly\n    });\n  }\n  /**\n   * Get number of rows in the table\n   */\n  get numberOfRows() {\n    return this.table.childElementCount;\n  }\n  /**\n   * Get number of columns in the table\n   */\n  get numberOfColumns() {\n    return this.numberOfRows ? this.table.querySelectorAll(`.${r.row}:first-child .${r.cell}`).length : 0;\n  }\n  /**\n   * Is the column toolbox menu displayed or not\n   *\n   * @returns {boolean}\n   */\n  get isColumnMenuShowing() {\n    return this.selectedColumn !== 0;\n  }\n  /**\n   * Is the row toolbox menu displayed or not\n   *\n   * @returns {boolean}\n   */\n  get isRowMenuShowing() {\n    return this.selectedRow !== 0;\n  }\n  /**\n   * Recalculate position of toolbox icons\n   *\n   * @param {Event} event - mouse move event\n   */\n  onMouseMoveInTable(t) {\n    const { row: e, column: o } = this.getHoveredCell(t);\n    this.hoveredColumn = o, this.hoveredRow = e, this.updateToolboxesPosition();\n  }\n  /**\n   * Prevents default Enter behaviors\n   * Adds Shift+Enter processing\n   *\n   * @param {KeyboardEvent} event - keypress event\n   */\n  onKeyPressListener(t) {\n    if (t.key === \"Enter\") {\n      if (t.shiftKey)\n        return !0;\n      this.moveCursorToNextRow();\n    }\n    return t.key !== \"Enter\";\n  }\n  /**\n   * Prevents tab keydown event from bubbling\n   * so that it only works inside the table\n   *\n   * @param {KeyboardEvent} event - keydown event\n   */\n  onKeyDownListener(t) {\n    t.key === \"Tab\" && t.stopPropagation();\n  }\n  /**\n   * Set the coordinates of the cell that the focus has moved to\n   *\n   * @param {FocusEvent} event - focusin event\n   */\n  focusInTableListener(t) {\n    const e = t.target, o = this.getRowByCell(e);\n    this.focusedCell = {\n      row: Array.from(this.table.querySelectorAll(`.${r.row}`)).indexOf(o) + 1,\n      column: Array.from(o.querySelectorAll(`.${r.cell}`)).indexOf(e) + 1\n    };\n  }\n  /**\n   * Unselect row/column\n   * Close toolbox menu\n   * Hide toolboxes\n   *\n   * @returns {void}\n   */\n  hideToolboxes() {\n    this.hideRowToolbox(), this.hideColumnToolbox(), this.updateToolboxesPosition();\n  }\n  /**\n   * Unselect row, close toolbox\n   *\n   * @returns {void}\n   */\n  hideRowToolbox() {\n    this.unselectRow(), this.toolboxRow.hide();\n  }\n  /**\n   * Unselect column, close toolbox\n   *\n   * @returns {void}\n   */\n  hideColumnToolbox() {\n    this.unselectColumn(), this.toolboxColumn.hide();\n  }\n  /**\n   * Set the cursor focus to the focused cell\n   *\n   * @returns {void}\n   */\n  focusCell() {\n    this.focusedCellElem.focus();\n  }\n  /**\n   * Get current focused element\n   *\n   * @returns {HTMLElement} - focused cell\n   */\n  get focusedCellElem() {\n    const { row: t, column: e } = this.focusedCell;\n    return this.getCell(t, e);\n  }\n  /**\n   * Update toolboxes position\n   *\n   * @param {number} row - hovered row\n   * @param {number} column - hovered column\n   */\n  updateToolboxesPosition(t = this.hoveredRow, e = this.hoveredColumn) {\n    this.isColumnMenuShowing || e > 0 && e <= this.numberOfColumns && this.toolboxColumn.show(() => ({\n      left: `calc((100% - var(--cell-size)) / (${this.numberOfColumns} * 2) * (1 + (${e} - 1) * 2))`\n    })), this.isRowMenuShowing || t > 0 && t <= this.numberOfRows && this.toolboxRow.show(() => {\n      const o = this.getRow(t), { fromTopBorder: i } = g(this.table, o), { height: s } = o.getBoundingClientRect();\n      return {\n        top: `${Math.ceil(i + s / 2)}px`\n      };\n    });\n  }\n  /**\n   * Makes the first row headings\n   *\n   * @param {boolean} withHeadings - use headings row or not\n   */\n  setHeadingsSetting(t) {\n    this.tunes.withHeadings = t, t ? (this.table.classList.add(r.withHeadings), this.addHeadingAttrToFirstRow()) : (this.table.classList.remove(r.withHeadings), this.removeHeadingAttrFromFirstRow());\n  }\n  /**\n   * Adds an attribute for displaying the placeholder in the cell\n   */\n  addHeadingAttrToFirstRow() {\n    for (let t = 1; t <= this.numberOfColumns; t++) {\n      let e = this.getCell(1, t);\n      e && e.setAttribute(\"heading\", this.api.i18n.t(\"Heading\"));\n    }\n  }\n  /**\n   * Removes an attribute for displaying the placeholder in the cell\n   */\n  removeHeadingAttrFromFirstRow() {\n    for (let t = 1; t <= this.numberOfColumns; t++) {\n      let e = this.getCell(1, t);\n      e && e.removeAttribute(\"heading\");\n    }\n  }\n  /**\n   * Add effect of a selected row\n   *\n   * @param {number} index\n   */\n  selectRow(t) {\n    const e = this.getRow(t);\n    e && (this.selectedRow = t, e.classList.add(r.rowSelected));\n  }\n  /**\n   * Remove effect of a selected row\n   */\n  unselectRow() {\n    if (this.selectedRow <= 0)\n      return;\n    const t = this.table.querySelector(`.${r.rowSelected}`);\n    t && t.classList.remove(r.rowSelected), this.selectedRow = 0;\n  }\n  /**\n   * Add effect of a selected column\n   *\n   * @param {number} index\n   */\n  selectColumn(t) {\n    for (let e = 1; e <= this.numberOfRows; e++) {\n      const o = this.getCell(e, t);\n      o && o.classList.add(r.cellSelected);\n    }\n    this.selectedColumn = t;\n  }\n  /**\n   * Remove effect of a selected column\n   */\n  unselectColumn() {\n    if (this.selectedColumn <= 0)\n      return;\n    let t = this.table.querySelectorAll(`.${r.cellSelected}`);\n    Array.from(t).forEach((e) => {\n      e.classList.remove(r.cellSelected);\n    }), this.selectedColumn = 0;\n  }\n  /**\n   * Calculates the row and column that the cursor is currently hovering over\n   * The search was optimized from O(n) to O (log n) via bin search to reduce the number of calculations\n   *\n   * @param {Event} event - mousemove event\n   * @returns hovered cell coordinates as an integer row and column\n   */\n  getHoveredCell(t) {\n    let e = this.hoveredRow, o = this.hoveredColumn;\n    const { width: i, height: s, x: n, y: h } = R(this.table, t);\n    return n >= 0 && (o = this.binSearch(\n      this.numberOfColumns,\n      (l) => this.getCell(1, l),\n      ({ fromLeftBorder: l }) => n < l,\n      ({ fromRightBorder: l }) => n > i - l\n    )), h >= 0 && (e = this.binSearch(\n      this.numberOfRows,\n      (l) => this.getCell(l, 1),\n      ({ fromTopBorder: l }) => h < l,\n      ({ fromBottomBorder: l }) => h > s - l\n    )), {\n      row: e || this.hoveredRow,\n      column: o || this.hoveredColumn\n    };\n  }\n  /**\n   * Looks for the index of the cell the mouse is hovering over.\n   * Cells can be represented as ordered intervals with left and\n   * right (upper and lower for rows) borders inside the table, if the mouse enters it, then this is our index\n   *\n   * @param {number} numberOfCells - upper bound of binary search\n   * @param {function} getCell - function to take the currently viewed cell\n   * @param {function} beforeTheLeftBorder - determines the cursor position, to the left of the cell or not\n   * @param {function} afterTheRightBorder - determines the cursor position, to the right of the cell or not\n   * @returns {number}\n   */\n  binSearch(t, e, o, i) {\n    let s = 0, n = t + 1, h = 0, l;\n    for (; s < n - 1 && h < 10; ) {\n      l = Math.ceil((s + n) / 2);\n      const w = e(l), p = g(this.table, w);\n      if (o(p))\n        n = l;\n      else if (i(p))\n        s = l;\n      else\n        break;\n      h++;\n    }\n    return l;\n  }\n  /**\n   * Collects data from cells into a two-dimensional array\n   *\n   * @returns {string[][]}\n   */\n  getData() {\n    const t = [];\n    for (let e = 1; e <= this.numberOfRows; e++) {\n      const o = this.table.querySelector(`.${r.row}:nth-child(${e})`), i = Array.from(o.querySelectorAll(`.${r.cell}`));\n      i.every((n) => !n.textContent.trim()) || t.push(i.map((n) => n.innerHTML));\n    }\n    return t;\n  }\n  /**\n   * Remove listeners on the document\n   */\n  destroy() {\n    document.removeEventListener(\"click\", this.documentClicked);\n  }\n}\nclass I {\n  /**\n   * Notify core that read-only mode is supported\n   *\n   * @returns {boolean}\n   */\n  static get isReadOnlySupported() {\n    return !0;\n  }\n  /**\n   * Allow to press Enter inside the CodeTool textarea\n   *\n   * @returns {boolean}\n   * @public\n   */\n  static get enableLineBreaks() {\n    return !0;\n  }\n  /**\n   * Render plugin`s main Element and fill it with saved data\n   *\n   * @param {TableData} data  previously saved data\n   * @param {TableConfig} config - user config for Tool\n   * @param {object} api - Editor.js API\n   * @param {boolean} readOnly - read-only mode flag\n   */\n  constructor({ data: t, config: e, api: o, readOnly: i }) {\n    this.api = o, this.readOnly = i, this.config = e, this.data = {\n      withHeadings: this.getConfig(\"withHeadings\", !1, t),\n      content: t && t.content ? t.content : []\n    }, this.table = null;\n  }\n  /**\n   * Get Tool toolbox settings\n   * icon - Tool icon's SVG\n   * title - title to show in toolbox\n   *\n   * @returns {{icon: string, title: string}}\n   */\n  static get toolbox() {\n    return {\n      icon: O,\n      title: \"Table\"\n    };\n  }\n  /**\n   * Return Tool's view\n   *\n   * @returns {HTMLDivElement}\n   */\n  render() {\n    return this.table = new A(this.readOnly, this.api, this.data, this.config), this.container = c(\"div\", this.api.styles.block), this.container.appendChild(this.table.getWrapper()), this.table.setHeadingsSetting(this.data.withHeadings), this.container;\n  }\n  /**\n   * Returns plugin settings\n   *\n   * @returns {Array}\n   */\n  renderSettings() {\n    return [\n      {\n        label: this.api.i18n.t(\"With headings\"),\n        icon: L,\n        isActive: this.data.withHeadings,\n        closeOnActivate: !0,\n        toggle: !0,\n        onActivate: () => {\n          this.data.withHeadings = !0, this.table.setHeadingsSetting(this.data.withHeadings);\n        }\n      },\n      {\n        label: this.api.i18n.t(\"Without headings\"),\n        icon: M,\n        isActive: !this.data.withHeadings,\n        closeOnActivate: !0,\n        toggle: !0,\n        onActivate: () => {\n          this.data.withHeadings = !1, this.table.setHeadingsSetting(this.data.withHeadings);\n        }\n      }\n    ];\n  }\n  /**\n   * Extract table data from the view\n   *\n   * @returns {TableData} - saved data\n   */\n  save() {\n    const t = this.table.getData();\n    return {\n      withHeadings: this.data.withHeadings,\n      content: t\n    };\n  }\n  /**\n   * Plugin destroyer\n   *\n   * @returns {void}\n   */\n  destroy() {\n    this.table.destroy();\n  }\n  /**\n   * A helper to get config value.\n   * \n   * @param {string} configName - the key to get from the config. \n   * @param {any} defaultValue - default value if config doesn't have passed key\n   * @param {object} savedData - previously saved data. If passed, the key will be got from there, otherwise from the config\n   * @returns {any} - config value.\n   */\n  getConfig(t, e = void 0, o = void 0) {\n    const i = this.data || o;\n    return i ? i[t] ? i[t] : e : this.config && this.config[t] ? this.config[t] : e;\n  }\n  /**  \n   * Table onPaste configuration\n   *\n   * @public\n   */\n  static get pasteConfig() {\n    return { tags: [\"TABLE\", \"TR\", \"TH\", \"TD\"] };\n  }\n  /**\n   * On paste callback that is fired from Editor\n   *\n   * @param {PasteEvent} event - event with pasted data\n   */\n  onPaste(t) {\n    const e = t.detail.data, o = e.querySelector(\":scope > thead, tr:first-of-type th\"), s = Array.from(e.querySelectorAll(\"tr\")).map((n) => Array.from(n.querySelectorAll(\"th, td\")).map((l) => l.innerHTML));\n    this.data = {\n      withHeadings: o !== null,\n      content: s\n    }, this.table.wrapper && this.table.wrapper.replaceWith(this.render());\n  }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZWRpdG9yanMvdGFibGUvZGlzdC90YWJsZS5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLFlBQVksYUFBYSxJQUFJLHdCQUF3QixzQ0FBc0MsZ0RBQWdELDJCQUEyQiwrQkFBK0IsdUJBQXVCLGlCQUFpQix5QkFBeUIsc0JBQXNCLHNGQUFzRixjQUFjLGtCQUFrQixZQUFZLFdBQVcsb0NBQW9DLHNCQUFzQixhQUFhLHFFQUFxRSxtQkFBbUIsNENBQTRDLGFBQWEsbUJBQW1CLGFBQWEsU0FBUyxzQ0FBc0Msd0JBQXdCLHNCQUFzQiw2Q0FBNkMsYUFBYSx1QkFBdUIsY0FBYyxVQUFVLGtCQUFrQixXQUFXLFlBQVksYUFBYSxlQUFlLHlDQUF5QyxnQkFBZ0IsZ0JBQWdCLDZCQUE2QixZQUFZLCtCQUErQixNQUFNLGlDQUFpQyxrQkFBa0IsV0FBVyxpQkFBaUIsV0FBVyx3Q0FBd0MsOENBQThDLE9BQU8sdUNBQXVDLGdCQUFnQiw0Q0FBNEMsc0VBQXNFLHNCQUFzQixrQ0FBa0MsNkNBQTZDLFlBQVksNENBQTRDLDJCQUEyQixhQUFhLGtDQUFrQyxhQUFhLFFBQVEsY0FBYyxlQUFlLGNBQWMsdUJBQXVCLHlDQUF5QyxhQUFhLGVBQWUsY0FBYyxZQUFZLHdCQUF3QixtQkFBbUIsaUJBQWlCLGtCQUFrQixtQkFBbUIsV0FBVyxrQkFBa0IsZ0NBQWdDLHVCQUF1QixZQUFZLGFBQWEsWUFBWSxjQUFjLDJCQUEyQixjQUFjLGVBQWUsNkJBQTZCLHVDQUF1QyxxQ0FBcUMseUNBQXlDLFlBQVksZUFBZSx5QkFBeUIsZUFBZSx5Q0FBeUMsUUFBUSxhQUFhLHdEQUF3RCxrQkFBa0IsNENBQTRDLGNBQWMsV0FBVyxvQkFBb0Isa0JBQWtCLHVCQUF1QixZQUFZLFlBQVksZ0NBQWdDLDRDQUE0QyxrQkFBa0IsbUNBQW1DLHdCQUF3QixtQ0FBbUMsU0FBUywyQ0FBMkMsaUJBQWlCLGdCQUFnQixhQUFhLGtCQUFrQixtQkFB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LGFBQWEsUUFBUTtBQUNyQixlQUFlLEtBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AZWRpdG9yanMvdGFibGUvZGlzdC90YWJsZS5tanM/MzM5YiJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt0cnl7aWYodHlwZW9mIGRvY3VtZW50PFwidVwiKXt2YXIgbz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7by5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnLnRjLXdyYXB7LS1jb2xvci1iYWNrZ3JvdW5kOiNmOWY5ZmI7LS1jb2xvci10ZXh0LXNlY29uZGFyeTojN2I3ZTg5Oy0tY29sb3ItYm9yZGVyOiNlOGU4ZWI7LS1jZWxsLXNpemU6MzRweDstLXRvb2xib3gtaWNvbi1zaXplOjE4cHg7LS10b29sYm94LXBhZGRpbmc6NnB4Oy0tdG9vbGJveC1haW1pbmctZmllbGQtc2l6ZTpjYWxjKHZhcigtLXRvb2xib3gtaWNvbi1zaXplKSArIHZhcigtLXRvb2xib3gtcGFkZGluZykqMik7Ym9yZGVyLWxlZnQ6MDtwb3NpdGlvbjpyZWxhdGl2ZTtoZWlnaHQ6MTAwJTt3aWR0aDoxMDAlO21hcmdpbi10b3A6dmFyKC0tdG9vbGJveC1pY29uLXNpemUpO2JveC1zaXppbmc6Ym9yZGVyLWJveDtkaXNwbGF5OmdyaWQ7Z3JpZC10ZW1wbGF0ZS1jb2x1bW5zOmNhbGMoMTAwJSAtIHZhcigtLWNlbGwtc2l6ZSkpIHZhcigtLWNlbGwtc2l6ZSl9LnRjLXdyYXAtLXJlYWRvbmx5e2dyaWQtdGVtcGxhdGUtY29sdW1uczoxMDAlIHZhcigtLWNlbGwtc2l6ZSl9LnRjLXdyYXAgc3Zne3ZlcnRpY2FsLWFsaWduOnRvcH1AbWVkaWEgcHJpbnR7LnRjLXdyYXB7Ym9yZGVyLWxlZnQtY29sb3I6dmFyKC0tY29sb3ItYm9yZGVyKTtib3JkZXItbGVmdC1zdHlsZTpzb2xpZDtib3JkZXItbGVmdC13aWR0aDoxcHg7Z3JpZC10ZW1wbGF0ZS1jb2x1bW5zOjEwMCUgdmFyKC0tY2VsbC1zaXplKX19QG1lZGlhIHByaW50ey50Yy13cmFwIC50Yy1yb3c6YWZ0ZXJ7ZGlzcGxheTpub25lfX0udGMtdGFibGV7cG9zaXRpb246cmVsYXRpdmU7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtkaXNwbGF5OmdyaWQ7Zm9udC1zaXplOjE0cHg7Ym9yZGVyLXRvcDoxcHggc29saWQgdmFyKC0tY29sb3ItYm9yZGVyKTtsaW5lLWhlaWdodDoxLjR9LnRjLXRhYmxlOmFmdGVye3dpZHRoOmNhbGModmFyKC0tY2VsbC1zaXplKSk7aGVpZ2h0OjEwMCU7bGVmdDpjYWxjKHZhcigtLWNlbGwtc2l6ZSkqLTEpO3RvcDowfS50Yy10YWJsZTphZnRlciwudGMtdGFibGU6YmVmb3Jle3Bvc2l0aW9uOmFic29sdXRlO2NvbnRlbnQ6XCJcIn0udGMtdGFibGU6YmVmb3Jle3dpZHRoOjEwMCU7aGVpZ2h0OnZhcigtLXRvb2xib3gtYWltaW5nLWZpZWxkLXNpemUpO3RvcDpjYWxjKHZhcigtLXRvb2xib3gtYWltaW5nLWZpZWxkLXNpemUpKi0xKTtsZWZ0OjB9LnRjLXRhYmxlLS1oZWFkaW5nIC50Yy1yb3c6Zmlyc3QtY2hpbGR7Zm9udC13ZWlnaHQ6NjAwO2JvcmRlci1ib3R0b206MnB4IHNvbGlkIHZhcigtLWNvbG9yLWJvcmRlcil9LnRjLXRhYmxlLS1oZWFkaW5nIC50Yy1yb3c6Zmlyc3QtY2hpbGQgW2NvbnRlbnRlZGl0YWJsZV06ZW1wdHk6YmVmb3Jle2NvbnRlbnQ6YXR0cihoZWFkaW5nKTtjb2xvcjp2YXIoLS1jb2xvci10ZXh0LXNlY29uZGFyeSl9LnRjLXRhYmxlLS1oZWFkaW5nIC50Yy1yb3c6Zmlyc3QtY2hpbGQ6YWZ0ZXJ7Ym90dG9tOi0ycHg7Ym9yZGVyLWJvdHRvbToycHggc29saWQgdmFyKC0tY29sb3ItYm9yZGVyKX0udGMtYWRkLWNvbHVtbiwudGMtYWRkLXJvd3tkaXNwbGF5OmZsZXg7Y29sb3I6dmFyKC0tY29sb3ItdGV4dC1zZWNvbmRhcnkpfUBtZWRpYSBwcmludHsudGMtYWRke2Rpc3BsYXk6bm9uZX19LnRjLWFkZC1jb2x1bW57cGFkZGluZzo0cHggMDtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO2JvcmRlci10b3A6MXB4IHNvbGlkIHZhcigtLWNvbG9yLWJvcmRlcil9QG1lZGlhIHByaW50ey50Yy1hZGQtY29sdW1ue2Rpc3BsYXk6bm9uZX19LnRjLWFkZC1yb3d7aGVpZ2h0OnZhcigtLWNlbGwtc2l6ZSk7YWxpZ24taXRlbXM6Y2VudGVyO3BhZGRpbmctbGVmdDo0cHg7cG9zaXRpb246cmVsYXRpdmV9LnRjLWFkZC1yb3c6YmVmb3Jle2NvbnRlbnQ6XCJcIjtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDpjYWxjKHZhcigtLWNlbGwtc2l6ZSkqLTEpO3dpZHRoOnZhcigtLWNlbGwtc2l6ZSk7aGVpZ2h0OjEwMCV9QG1lZGlhIHByaW50ey50Yy1hZGQtcm93e2Rpc3BsYXk6bm9uZX19LnRjLWFkZC1jb2x1bW4sLnRjLWFkZC1yb3d7dHJhbnNpdGlvbjowcztjdXJzb3I6cG9pbnRlcjt3aWxsLWNoYW5nZTpiYWNrZ3JvdW5kLWNvbG9yfS50Yy1hZGQtY29sdW1uOmhvdmVyLC50Yy1hZGQtcm93OmhvdmVye3RyYW5zaXRpb246YmFja2dyb3VuZC1jb2xvciAuMXMgZWFzZTtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWNvbG9yLWJhY2tncm91bmQpfS50Yy1hZGQtcm93e21hcmdpbi10b3A6MXB4fS50Yy1hZGQtcm93OmhvdmVyOmJlZm9yZXt0cmFuc2l0aW9uOi4xcztiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWNvbG9yLWJhY2tncm91bmQpfS50Yy1yb3d7ZGlzcGxheTpncmlkO2dyaWQtdGVtcGxhdGUtY29sdW1uczpyZXBlYXQoYXV0by1maXQsbWlubWF4KDEwcHgsMWZyKSk7cG9zaXRpb246cmVsYXRpdmU7Ym9yZGVyLWJvdHRvbToxcHggc29saWQgdmFyKC0tY29sb3ItYm9yZGVyKX0udGMtcm93OmFmdGVye2NvbnRlbnQ6XCJcIjtwb2ludGVyLWV2ZW50czpub25lO3Bvc2l0aW9uOmFic29sdXRlO3dpZHRoOnZhcigtLWNlbGwtc2l6ZSk7aGVpZ2h0OjEwMCU7Ym90dG9tOi0xcHg7cmlnaHQ6Y2FsYyh2YXIoLS1jZWxsLXNpemUpKi0xKTtib3JkZXItYm90dG9tOjFweCBzb2xpZCB2YXIoLS1jb2xvci1ib3JkZXIpfS50Yy1yb3ctLXNlbGVjdGVke2JhY2tncm91bmQ6dmFyKC0tY29sb3ItYmFja2dyb3VuZCl9LnRjLXJvdy0tc2VsZWN0ZWQ6YWZ0ZXJ7YmFja2dyb3VuZDp2YXIoLS1jb2xvci1iYWNrZ3JvdW5kKX0udGMtY2VsbHtib3JkZXItcmlnaHQ6MXB4IHNvbGlkIHZhcigtLWNvbG9yLWJvcmRlcik7cGFkZGluZzo2cHggMTJweDtvdmVyZmxvdzpoaWRkZW47b3V0bGluZTpub25lO2xpbmUtYnJlYWs6bm9ybWFsfS50Yy1jZWxsLS1zZWxlY3RlZHtiYWNrZ3JvdW5kOnZhcigtLWNvbG9yLWJhY2tncm91bmQpfS50Yy13cmFwLS1yZWFkb25seSAudGMtcm93OmFmdGVye2Rpc3BsYXk6bm9uZX0udGMtdG9vbGJveHstLXRvb2xib3gtcGFkZGluZzo2cHg7LS1wb3BvdmVyLW1hcmdpbjozMHB4Oy0tdG9nZ2xlci1jbGljay16b25lLXNpemU6MzBweDstLXRvZ2dsZXItZG90cy1jb2xvcjojN2I3ZTg5Oy0tdG9nZ2xlci1kb3RzLWNvbG9yLWhvdmVyZWQ6IzFkMjAyYjtwb3NpdGlvbjphYnNvbHV0ZTtjdXJzb3I6cG9pbnRlcjt6LWluZGV4OjE7b3BhY2l0eTowO3RyYW5zaXRpb246b3BhY2l0eSAuMXM7d2lsbC1jaGFuZ2U6bGVmdCxvcGFjaXR5fS50Yy10b29sYm94LS1jb2x1bW57dG9wOmNhbGModmFyKC0tdG9nZ2xlci1jbGljay16b25lLXNpemUpKi0xKTt0cmFuc2Zvcm06dHJhbnNsYXRlKGNhbGModmFyKC0tdG9nZ2xlci1jbGljay16b25lLXNpemUpKi0xLzIpKTt3aWxsLWNoYW5nZTpsZWZ0LG9wYWNpdHl9LnRjLXRvb2xib3gtLXJvd3tsZWZ0OmNhbGModmFyKC0tcG9wb3Zlci1tYXJnaW4pKi0xKTt0cmFuc2Zvcm06dHJhbnNsYXRlWShjYWxjKHZhcigtLXRvZ2dsZXItY2xpY2stem9uZS1zaXplKSotMS8yKSk7bWFyZ2luLXRvcDotMXB4O3dpbGwtY2hhbmdlOnRvcCxvcGFjaXR5fS50Yy10b29sYm94LS1zaG93ZWR7b3BhY2l0eToxfS50Yy10b29sYm94IC50Yy1wb3BvdmVye3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6dmFyKC0tcG9wb3Zlci1tYXJnaW4pfS50Yy10b29sYm94X190b2dnbGVye2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjt3aWR0aDp2YXIoLS10b2dnbGVyLWNsaWNrLXpvbmUtc2l6ZSk7aGVpZ2h0OnZhcigtLXRvZ2dsZXItY2xpY2stem9uZS1zaXplKTtjb2xvcjp2YXIoLS10b2dnbGVyLWRvdHMtY29sb3IpO29wYWNpdHk6MDt0cmFuc2l0aW9uOm9wYWNpdHkgLjE1cyBlYXNlO3dpbGwtY2hhbmdlOm9wYWNpdHl9LnRjLXRvb2xib3hfX3RvZ2dsZXI6aG92ZXJ7Y29sb3I6dmFyKC0tdG9nZ2xlci1kb3RzLWNvbG9yLWhvdmVyZWQpfS50Yy10b29sYm94X190b2dnbGVyIHN2Z3tmaWxsOmN1cnJlbnRDb2xvcn0udGMtd3JhcDpob3ZlciAudGMtdG9vbGJveF9fdG9nZ2xlcntvcGFjaXR5OjF9LnRjLXNldHRpbmdzIC5jZHgtc2V0dGluZ3MtYnV0dG9ue3dpZHRoOjUwJTttYXJnaW46MH0udGMtcG9wb3ZlcnstLWNvbG9yLWJvcmRlcjojZWFlYWVhOy0tY29sb3ItYmFja2dyb3VuZDojZmZmOy0tY29sb3ItYmFja2dyb3VuZC1ob3ZlcjpyZ2JhKDIzMiwyMzIsMjM1LC40OSk7LS1jb2xvci1iYWNrZ3JvdW5kLWNvbmZpcm06I2UyNGE0YTstLWNvbG9yLWJhY2tncm91bmQtY29uZmlybS1ob3ZlcjojZDU0MDQwOy0tY29sb3ItdGV4dC1jb25maXJtOiNmZmY7YmFja2dyb3VuZDp2YXIoLS1jb2xvci1iYWNrZ3JvdW5kKTtib3JkZXI6MXB4IHNvbGlkIHZhcigtLWNvbG9yLWJvcmRlcik7Ym94LXNoYWRvdzowIDNweCAxNXB4IC0zcHggIzBkMTQyMTIxO2JvcmRlci1yYWRpdXM6NnB4O3BhZGRpbmc6NnB4O2Rpc3BsYXk6bm9uZTt3aWxsLWNoYW5nZTpvcGFjaXR5LHRyYW5zZm9ybX0udGMtcG9wb3Zlci0tb3BlbmVke2Rpc3BsYXk6YmxvY2s7YW5pbWF0aW9uOm1lbnVTaG93aW5nIC4xcyBjdWJpYy1iZXppZXIoLjIxNSwuNjEsLjM1NSwxKSBmb3J3YXJkc30udGMtcG9wb3Zlcl9faXRlbXtkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6Y2VudGVyO3BhZGRpbmc6MnB4IDE0cHggMnB4IDJweDtib3JkZXItcmFkaXVzOjVweDtjdXJzb3I6cG9pbnRlcjt3aGl0ZS1zcGFjZTpub3dyYXA7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lfS50Yy1wb3BvdmVyX19pdGVtOmhvdmVye2JhY2tncm91bmQ6dmFyKC0tY29sb3ItYmFja2dyb3VuZC1ob3Zlcil9LnRjLXBvcG92ZXJfX2l0ZW06bm90KDpsYXN0LW9mLXR5cGUpe21hcmdpbi1ib3R0b206MnB4fS50Yy1wb3BvdmVyX19pdGVtLWljb257ZGlzcGxheTppbmxpbmUtZmxleDt3aWR0aDoyNnB4O2hlaWdodDoyNnB4O2FsaWduLWl0ZW1zOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO2JhY2tncm91bmQ6dmFyKC0tY29sb3ItYmFja2dyb3VuZCk7Ym9yZGVyLXJhZGl1czo1cHg7Ym9yZGVyOjFweCBzb2xpZCB2YXIoLS1jb2xvci1ib3JkZXIpO21hcmdpbi1yaWdodDo4cHh9LnRjLXBvcG92ZXJfX2l0ZW0tbGFiZWx7bGluZS1oZWlnaHQ6MjJweDtmb250LXNpemU6MTRweDtmb250LXdlaWdodDo1MDB9LnRjLXBvcG92ZXJfX2l0ZW0tLWNvbmZpcm17YmFja2dyb3VuZDp2YXIoLS1jb2xvci1iYWNrZ3JvdW5kLWNvbmZpcm0pO2NvbG9yOnZhcigtLWNvbG9yLXRleHQtY29uZmlybSl9LnRjLXBvcG92ZXJfX2l0ZW0tLWNvbmZpcm06aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1jb2xvci1iYWNrZ3JvdW5kLWNvbmZpcm0taG92ZXIpfS50Yy1wb3BvdmVyX19pdGVtLS1jb25maXJtIC50Yy1wb3BvdmVyX19pdGVtLWljb257YmFja2dyb3VuZDp2YXIoLS1jb2xvci1iYWNrZ3JvdW5kLWNvbmZpcm0pO2JvcmRlci1jb2xvcjojMDAwMDAwMWF9LnRjLXBvcG92ZXJfX2l0ZW0tLWNvbmZpcm0gLnRjLXBvcG92ZXJfX2l0ZW0taWNvbiBzdmd7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gLjJzIGVhc2UtaW47dHJhbnNmb3JtOnJvdGF0ZSg5MGRlZykgc2NhbGUoMS4yKX0udGMtcG9wb3Zlcl9faXRlbS0taGlkZGVue2Rpc3BsYXk6bm9uZX1Aa2V5ZnJhbWVzIG1lbnVTaG93aW5nezAle29wYWNpdHk6MDt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtOHB4KSBzY2FsZSguOSl9NzAle29wYWNpdHk6MTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgycHgpfXRve3RyYW5zZm9ybTp0cmFuc2xhdGVZKDApfX0nKSksZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChvKX19Y2F0Y2gocil7Y29uc29sZS5lcnJvcihcInZpdGUtcGx1Z2luLWNzcy1pbmplY3RlZC1ieS1qc1wiLHIpfX0pKCk7XG5mdW5jdGlvbiBjKGQsIHQsIGUgPSB7fSkge1xuICBjb25zdCBvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChkKTtcbiAgQXJyYXkuaXNBcnJheSh0KSA/IG8uY2xhc3NMaXN0LmFkZCguLi50KSA6IHQgJiYgby5jbGFzc0xpc3QuYWRkKHQpO1xuICBmb3IgKGNvbnN0IGkgaW4gZSlcbiAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSwgaSkgJiYgKG9baV0gPSBlW2ldKTtcbiAgcmV0dXJuIG87XG59XG5mdW5jdGlvbiBmKGQpIHtcbiAgY29uc3QgdCA9IGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHJldHVybiB7XG4gICAgeTE6IE1hdGguZmxvb3IodC50b3AgKyB3aW5kb3cucGFnZVlPZmZzZXQpLFxuICAgIHgxOiBNYXRoLmZsb29yKHQubGVmdCArIHdpbmRvdy5wYWdlWE9mZnNldCksXG4gICAgeDI6IE1hdGguZmxvb3IodC5yaWdodCArIHdpbmRvdy5wYWdlWE9mZnNldCksXG4gICAgeTI6IE1hdGguZmxvb3IodC5ib3R0b20gKyB3aW5kb3cucGFnZVlPZmZzZXQpXG4gIH07XG59XG5mdW5jdGlvbiBnKGQsIHQpIHtcbiAgY29uc3QgZSA9IGYoZCksIG8gPSBmKHQpO1xuICByZXR1cm4ge1xuICAgIGZyb21Ub3BCb3JkZXI6IG8ueTEgLSBlLnkxLFxuICAgIGZyb21MZWZ0Qm9yZGVyOiBvLngxIC0gZS54MSxcbiAgICBmcm9tUmlnaHRCb3JkZXI6IGUueDIgLSBvLngyLFxuICAgIGZyb21Cb3R0b21Cb3JkZXI6IGUueTIgLSBvLnkyXG4gIH07XG59XG5mdW5jdGlvbiBSKGQsIHQpIHtcbiAgY29uc3QgZSA9IGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHsgd2lkdGg6IG8sIGhlaWdodDogaSwgeDogcywgeTogbiB9ID0gZSwgeyBjbGllbnRYOiBoLCBjbGllbnRZOiBsIH0gPSB0O1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiBvLFxuICAgIGhlaWdodDogaSxcbiAgICB4OiBoIC0gcyxcbiAgICB5OiBsIC0gblxuICB9O1xufVxuZnVuY3Rpb24gQyhkLCB0KSB7XG4gIHJldHVybiB0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGQsIHQpO1xufVxuZnVuY3Rpb24gbShkLCB0ID0gITApIHtcbiAgY29uc3QgZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCksIG8gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gIGUuc2VsZWN0Tm9kZUNvbnRlbnRzKGQpLCBlLmNvbGxhcHNlKHQpLCBvLnJlbW92ZUFsbFJhbmdlcygpLCBvLmFkZFJhbmdlKGUpO1xufVxuY2xhc3MgYSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIGNvbnN0cnVjdG9yIG9wdGlvbnNcbiAgICogQHBhcmFtIHtQb3BvdmVySXRlbVtdfSBvcHRpb25zLml0ZW1zIC0gY29uc3RydWN0b3Igb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3IoeyBpdGVtczogdCB9KSB7XG4gICAgdGhpcy5pdGVtcyA9IHQsIHRoaXMud3JhcHBlciA9IHZvaWQgMCwgdGhpcy5pdGVtRWxzID0gW107XG4gIH1cbiAgLyoqXG4gICAqIFNldCBvZiBDU1MgY2xhc3NuYW1lcyB1c2VkIGluIHBvcG92ZXJcbiAgICpcbiAgICogQHJldHVybnMge29iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgQ1NTKCkge1xuICAgIHJldHVybiB7XG4gICAgICBwb3BvdmVyOiBcInRjLXBvcG92ZXJcIixcbiAgICAgIHBvcG92ZXJPcGVuZWQ6IFwidGMtcG9wb3Zlci0tb3BlbmVkXCIsXG4gICAgICBpdGVtOiBcInRjLXBvcG92ZXJfX2l0ZW1cIixcbiAgICAgIGl0ZW1IaWRkZW46IFwidGMtcG9wb3Zlcl9faXRlbS0taGlkZGVuXCIsXG4gICAgICBpdGVtQ29uZmlybVN0YXRlOiBcInRjLXBvcG92ZXJfX2l0ZW0tLWNvbmZpcm1cIixcbiAgICAgIGl0ZW1JY29uOiBcInRjLXBvcG92ZXJfX2l0ZW0taWNvblwiLFxuICAgICAgaXRlbUxhYmVsOiBcInRjLXBvcG92ZXJfX2l0ZW0tbGFiZWxcIlxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBvcG92ZXIgZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJucyB7RWxlbWVudH1cbiAgICovXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy53cmFwcGVyID0gYyhcImRpdlwiLCBhLkNTUy5wb3BvdmVyKSwgdGhpcy5pdGVtcy5mb3JFYWNoKCh0LCBlKSA9PiB7XG4gICAgICBjb25zdCBvID0gYyhcImRpdlwiLCBhLkNTUy5pdGVtKSwgaSA9IGMoXCJkaXZcIiwgYS5DU1MuaXRlbUljb24sIHtcbiAgICAgICAgaW5uZXJIVE1MOiB0Lmljb25cbiAgICAgIH0pLCBzID0gYyhcImRpdlwiLCBhLkNTUy5pdGVtTGFiZWwsIHtcbiAgICAgICAgdGV4dENvbnRlbnQ6IHQubGFiZWxcbiAgICAgIH0pO1xuICAgICAgby5kYXRhc2V0LmluZGV4ID0gZSwgby5hcHBlbmRDaGlsZChpKSwgby5hcHBlbmRDaGlsZChzKSwgdGhpcy53cmFwcGVyLmFwcGVuZENoaWxkKG8pLCB0aGlzLml0ZW1FbHMucHVzaChvKTtcbiAgICB9KSwgdGhpcy53cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAodCkgPT4ge1xuICAgICAgdGhpcy5wb3BvdmVyQ2xpY2tlZCh0KTtcbiAgICB9KSwgdGhpcy53cmFwcGVyO1xuICB9XG4gIC8qKlxuICAgKiBQb3BvdmVyIHdyYXBwZXIgY2xpY2sgbGlzdGVuZXJcbiAgICogVXNlZCB0byBkZWxlZ2F0ZSBjbGlja3MgaW4gaXRlbXNcbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBwb3BvdmVyQ2xpY2tlZCh0KSB7XG4gICAgY29uc3QgZSA9IHQudGFyZ2V0LmNsb3Nlc3QoYC4ke2EuQ1NTLml0ZW19YCk7XG4gICAgaWYgKCFlKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG8gPSBlLmRhdGFzZXQuaW5kZXgsIGkgPSB0aGlzLml0ZW1zW29dO1xuICAgIGlmIChpLmNvbmZpcm1hdGlvblJlcXVpcmVkICYmICF0aGlzLmhhc0NvbmZpcm1hdGlvblN0YXRlKGUpKSB7XG4gICAgICB0aGlzLnNldENvbmZpcm1hdGlvblN0YXRlKGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpLm9uQ2xpY2soKTtcbiAgfVxuICAvKipcbiAgICogRW5hYmxlIHRoZSBjb25maXJtYXRpb24gc3RhdGUgb24gcGFzc2VkIGl0ZW1cbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBzZXRDb25maXJtYXRpb25TdGF0ZSh0KSB7XG4gICAgdC5jbGFzc0xpc3QuYWRkKGEuQ1NTLml0ZW1Db25maXJtU3RhdGUpO1xuICB9XG4gIC8qKlxuICAgKiBEaXNhYmxlIHRoZSBjb25maXJtYXRpb24gc3RhdGUgb24gcGFzc2VkIGl0ZW1cbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBjbGVhckNvbmZpcm1hdGlvblN0YXRlKHQpIHtcbiAgICB0LmNsYXNzTGlzdC5yZW1vdmUoYS5DU1MuaXRlbUNvbmZpcm1TdGF0ZSk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIHBhc3NlZCBpdGVtIGhhcyB0aGUgY29uZmlybWF0aW9uIHN0YXRlXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgaGFzQ29uZmlybWF0aW9uU3RhdGUodCkge1xuICAgIHJldHVybiB0LmNsYXNzTGlzdC5jb250YWlucyhhLkNTUy5pdGVtQ29uZmlybVN0YXRlKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGFuIG9wZW5pbmcgc3RhdGVcbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgb3BlbmVkKCkge1xuICAgIHJldHVybiB0aGlzLndyYXBwZXIuY2xhc3NMaXN0LmNvbnRhaW5zKGEuQ1NTLnBvcG92ZXJPcGVuZWQpO1xuICB9XG4gIC8qKlxuICAgKiBPcGVucyB0aGUgcG9wb3ZlclxuICAgKlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIG9wZW4oKSB7XG4gICAgdGhpcy5pdGVtcy5mb3JFYWNoKCh0LCBlKSA9PiB7XG4gICAgICB0eXBlb2YgdC5oaWRlSWYgPT0gXCJmdW5jdGlvblwiICYmIHRoaXMuaXRlbUVsc1tlXS5jbGFzc0xpc3QudG9nZ2xlKGEuQ1NTLml0ZW1IaWRkZW4sIHQuaGlkZUlmKCkpO1xuICAgIH0pLCB0aGlzLndyYXBwZXIuY2xhc3NMaXN0LmFkZChhLkNTUy5wb3BvdmVyT3BlbmVkKTtcbiAgfVxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBwb3BvdmVyXG4gICAqXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy53cmFwcGVyLmNsYXNzTGlzdC5yZW1vdmUoYS5DU1MucG9wb3Zlck9wZW5lZCksIHRoaXMuaXRlbUVscy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICB0aGlzLmNsZWFyQ29uZmlybWF0aW9uU3RhdGUodCk7XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IGIgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTggOEwxMiAxMk0xMiAxMkwxNiAxNk0xMiAxMkwxNiA4TTEyIDEyTDggMTZcIi8+PC9zdmc+JywgayA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk0xNC44ODMzIDkuMTY2NjZMMTguMjE2NyAxMi41TTE4LjIxNjcgMTIuNUwxNC44ODMzIDE1LjgzMzNNMTguMjE2NyAxMi41SDEwLjA1QzkuMTY1OTQgMTIuNSA4LjMxODA5IDEyLjE0ODggNy42OTI5NyAxMS41MjM3QzcuMDY3ODUgMTAuODk4NiA2LjcxNjY2IDEwLjA1MDcgNi43MTY2NiA5LjE2NjY2XCIvPjwvc3ZnPicsIFMgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNMTQuOTE2NyAxNC45MTY3TDExLjU4MzMgMTguMjVNMTEuNTgzMyAxOC4yNUw4LjI1IDE0LjkxNjdNMTEuNTgzMyAxOC4yNUwxMS41ODMzIDEwLjA4MzNDMTEuNTgzMyA5LjE5OTI4IDExLjkzNDUgOC4zNTE0MyAxMi41NTk2IDcuNzI2MzFDMTMuMTg0OCA3LjEwMTE5IDE0LjAzMjYgNi43NSAxNC45MTY3IDYuNzVcIi8+PC9zdmc+JywgeCA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk05LjEzMzMzIDE0LjkxNjdMMTIuNDY2NyAxOC4yNU0xMi40NjY3IDE4LjI1TDE1LjggMTQuOTE2N00xMi40NjY3IDE4LjI1TDEyLjQ2NjcgMTAuMDgzM0MxMi40NjY3IDkuMTk5MjggMTIuMTE1NSA4LjM1MTQzIDExLjQ5MDQgNy43MjYzMUMxMC44NjUyIDcuMTAxMTkgMTAuMDE3NCA2Ljc1IDkuMTMzMzMgNi43NVwiLz48L3N2Zz4nLCB5ID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTE0Ljg4MzMgMTUuODMzM0wxOC4yMTY3IDEyLjVNMTguMjE2NyAxMi41TDE0Ljg4MzMgOS4xNjY2N00xOC4yMTY3IDEyLjVMMTAuMDUgMTIuNUM5LjE2NTk1IDEyLjUgOC4zMTgxMSAxMi44NTEyIDcuNjkyOTkgMTMuNDc2M0M3LjA2Nzg3IDE0LjEwMTQgNi43MTY2NyAxNC45NDkzIDYuNzE2NjcgMTUuODMzM1wiLz48L3N2Zz4nLCBUID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyLjZcIiBkPVwiTTkuNDEgOS42Nkg5LjRcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjIuNlwiIGQ9XCJNMTQuNiA5LjY2SDE0LjU5XCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyLjZcIiBkPVwiTTkuMzEgMTQuMzZIOS4zXCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyLjZcIiBkPVwiTTE0LjYgMTQuMzZIMTQuNTlcIi8+PC9zdmc+JywgdiA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNMTIgN1YxMk0xMiAxN1YxMk0xNyAxMkgxMk0xMiAxMkg3XCIvPjwvc3ZnPicsIEwgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNNSAxMEgxOVwiLz48cmVjdCB3aWR0aD1cIjE0XCIgaGVpZ2h0PVwiMTRcIiB4PVwiNVwiIHk9XCI1XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHJ4PVwiNFwiLz48L3N2Zz4nLCBNID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTEwIDVWMTguNVwiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk0xNCA1VjE4LjVcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNNSAxMEgxOVwiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk01IDE0SDE5XCIvPjxyZWN0IHdpZHRoPVwiMTRcIiBoZWlnaHQ9XCIxNFwiIHg9XCI1XCIgeT1cIjVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2Utd2lkdGg9XCIyXCIgcng9XCI0XCIvPjwvc3ZnPicsIE8gPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNMTAgNVYxOC41XCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTUgMTBIMTlcIi8+PHJlY3Qgd2lkdGg9XCIxNFwiIGhlaWdodD1cIjE0XCIgeD1cIjVcIiB5PVwiNVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS13aWR0aD1cIjJcIiByeD1cIjRcIi8+PC9zdmc+JztcbmNsYXNzIHUge1xuICAvKipcbiAgICogQ3JlYXRlcyB0b29sYm94IGJ1dHRvbnMgYW5kIHRvb2xib3ggbWVudXNcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGFwaSAtIEVkaXRvci5qcyBhcGlcbiAgICogQHBhcmFtIHtQb3BvdmVySXRlbVtdfSBpdGVtcyAtIEVkaXRvci5qcyBhcGlcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gb25PcGVuIC0gY2FsbGJhY2sgZmlyZWQgd2hlbiB0aGUgUG9wb3ZlciBpcyBvcGVuaW5nXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uQ2xvc2UgLSBjYWxsYmFjayBmaXJlZCB3aGVuIHRoZSBQb3BvdmVyIGlzIGNsb3NpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtjc3NNb2RpZmllcl0gLSB0aGUgbW9kaWZpZXIgZm9yIHRoZSBUb29sYm94LiBBbGxvd3MgdG8gYWRkIHNvbWUgc3BlY2lmaWMgc3R5bGVzLlxuICAgKi9cbiAgY29uc3RydWN0b3IoeyBhcGk6IHQsIGl0ZW1zOiBlLCBvbk9wZW46IG8sIG9uQ2xvc2U6IGksIGNzc01vZGlmaWVyOiBzID0gXCJcIiB9KSB7XG4gICAgdGhpcy5hcGkgPSB0LCB0aGlzLml0ZW1zID0gZSwgdGhpcy5vbk9wZW4gPSBvLCB0aGlzLm9uQ2xvc2UgPSBpLCB0aGlzLmNzc01vZGlmaWVyID0gcywgdGhpcy5wb3BvdmVyID0gbnVsbCwgdGhpcy53cmFwcGVyID0gdGhpcy5jcmVhdGVUb29sYm94KCk7XG4gIH1cbiAgLyoqXG4gICAqIFN0eWxlIGNsYXNzZXNcbiAgICovXG4gIHN0YXRpYyBnZXQgQ1NTKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0b29sYm94OiBcInRjLXRvb2xib3hcIixcbiAgICAgIHRvb2xib3hTaG93ZWQ6IFwidGMtdG9vbGJveC0tc2hvd2VkXCIsXG4gICAgICB0b2dnbGVyOiBcInRjLXRvb2xib3hfX3RvZ2dsZXJcIlxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgcmVuZGVyZWQgVG9vbGJveCBlbGVtZW50XG4gICAqL1xuICBnZXQgZWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy53cmFwcGVyO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGluZyBhIHRvb2xib3ggdG8gb3BlbiBtZW51IGZvciBhIG1hbmlwdWxhdGluZyBjb2x1bW5zXG4gICAqXG4gICAqIEByZXR1cm5zIHtFbGVtZW50fVxuICAgKi9cbiAgY3JlYXRlVG9vbGJveCgpIHtcbiAgICBjb25zdCB0ID0gYyhcImRpdlwiLCBbXG4gICAgICB1LkNTUy50b29sYm94LFxuICAgICAgdGhpcy5jc3NNb2RpZmllciA/IGAke3UuQ1NTLnRvb2xib3h9LS0ke3RoaXMuY3NzTW9kaWZpZXJ9YCA6IFwiXCJcbiAgICBdKTtcbiAgICB0LmRhdGFzZXQubXV0YXRpb25GcmVlID0gXCJ0cnVlXCI7XG4gICAgY29uc3QgZSA9IHRoaXMuY3JlYXRlUG9wb3ZlcigpLCBvID0gdGhpcy5jcmVhdGVUb2dnbGVyKCk7XG4gICAgcmV0dXJuIHQuYXBwZW5kQ2hpbGQobyksIHQuYXBwZW5kQ2hpbGQoZSksIHQ7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIFRvZ2dsZXJcbiAgICpcbiAgICogQHJldHVybnMge0VsZW1lbnR9XG4gICAqL1xuICBjcmVhdGVUb2dnbGVyKCkge1xuICAgIGNvbnN0IHQgPSBjKFwiZGl2XCIsIHUuQ1NTLnRvZ2dsZXIsIHtcbiAgICAgIGlubmVySFRNTDogVFxuICAgIH0pO1xuICAgIHJldHVybiB0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiB7XG4gICAgICB0aGlzLnRvZ2dsZXJDbGlja2VkKCk7XG4gICAgfSksIHQ7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIFBvcG92ZXIgaW5zdGFuY2UgYW5kIHJlbmRlciBpdFxuICAgKlxuICAgKiBAcmV0dXJucyB7RWxlbWVudH1cbiAgICovXG4gIGNyZWF0ZVBvcG92ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMucG9wb3ZlciA9IG5ldyBhKHtcbiAgICAgIGl0ZW1zOiB0aGlzLml0ZW1zXG4gICAgfSksIHRoaXMucG9wb3Zlci5yZW5kZXIoKTtcbiAgfVxuICAvKipcbiAgICogVG9nZ2xlciBjbGljayBoYW5kbGVyLiBPcGVucy9DbG9zZXMgdGhlIHBvcG92ZXJcbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICB0b2dnbGVyQ2xpY2tlZCgpIHtcbiAgICB0aGlzLnBvcG92ZXIub3BlbmVkID8gKHRoaXMucG9wb3Zlci5jbG9zZSgpLCB0aGlzLm9uQ2xvc2UoKSkgOiAodGhpcy5wb3BvdmVyLm9wZW4oKSwgdGhpcy5vbk9wZW4oKSk7XG4gIH1cbiAgLyoqXG4gICAqIFNob3dzIHRoZSBUb29sYm94XG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbXB1dGVQb3NpdGlvbk1ldGhvZCAtIG1ldGhvZCB0aGF0IHJldHVybnMgdGhlIHBvc2l0aW9uIGNvb3JkaW5hdGVcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBzaG93KHQpIHtcbiAgICBjb25zdCBlID0gdCgpO1xuICAgIE9iamVjdC5lbnRyaWVzKGUpLmZvckVhY2goKFtvLCBpXSkgPT4ge1xuICAgICAgdGhpcy53cmFwcGVyLnN0eWxlW29dID0gaTtcbiAgICB9KSwgdGhpcy53cmFwcGVyLmNsYXNzTGlzdC5hZGQodS5DU1MudG9vbGJveFNob3dlZCk7XG4gIH1cbiAgLyoqXG4gICAqIEhpZGVzIHRoZSBUb29sYm94XG4gICAqXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgaGlkZSgpIHtcbiAgICB0aGlzLnBvcG92ZXIuY2xvc2UoKSwgdGhpcy53cmFwcGVyLmNsYXNzTGlzdC5yZW1vdmUodS5DU1MudG9vbGJveFNob3dlZCk7XG4gIH1cbn1cbmZ1bmN0aW9uIEgoZCwgdCkge1xuICBsZXQgZSA9IDA7XG4gIHJldHVybiBmdW5jdGlvbiguLi5vKSB7XG4gICAgY29uc3QgaSA9ICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICAgIGlmICghKGkgLSBlIDwgZCkpXG4gICAgICByZXR1cm4gZSA9IGksIHQoLi4ubyk7XG4gIH07XG59XG5jb25zdCByID0ge1xuICB3cmFwcGVyOiBcInRjLXdyYXBcIixcbiAgd3JhcHBlclJlYWRPbmx5OiBcInRjLXdyYXAtLXJlYWRvbmx5XCIsXG4gIHRhYmxlOiBcInRjLXRhYmxlXCIsXG4gIHJvdzogXCJ0Yy1yb3dcIixcbiAgd2l0aEhlYWRpbmdzOiBcInRjLXRhYmxlLS1oZWFkaW5nXCIsXG4gIHJvd1NlbGVjdGVkOiBcInRjLXJvdy0tc2VsZWN0ZWRcIixcbiAgY2VsbDogXCJ0Yy1jZWxsXCIsXG4gIGNlbGxTZWxlY3RlZDogXCJ0Yy1jZWxsLS1zZWxlY3RlZFwiLFxuICBhZGRSb3c6IFwidGMtYWRkLXJvd1wiLFxuICBhZGRDb2x1bW46IFwidGMtYWRkLWNvbHVtblwiXG59O1xuY2xhc3MgQSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzXG4gICAqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlYWRPbmx5IC0gcmVhZC1vbmx5IG1vZGUgZmxhZ1xuICAgKiBAcGFyYW0ge29iamVjdH0gYXBpIC0gRWRpdG9yLmpzIEFQSVxuICAgKiBAcGFyYW0ge1RhYmxlRGF0YX0gZGF0YSAtIEVkaXRvci5qcyBBUElcbiAgICogQHBhcmFtIHtUYWJsZUNvbmZpZ30gY29uZmlnIC0gRWRpdG9yLmpzIEFQSVxuICAgKi9cbiAgY29uc3RydWN0b3IodCwgZSwgbywgaSkge1xuICAgIHRoaXMucmVhZE9ubHkgPSB0LCB0aGlzLmFwaSA9IGUsIHRoaXMuZGF0YSA9IG8sIHRoaXMuY29uZmlnID0gaSwgdGhpcy53cmFwcGVyID0gbnVsbCwgdGhpcy50YWJsZSA9IG51bGwsIHRoaXMudG9vbGJveENvbHVtbiA9IHRoaXMuY3JlYXRlQ29sdW1uVG9vbGJveCgpLCB0aGlzLnRvb2xib3hSb3cgPSB0aGlzLmNyZWF0ZVJvd1Rvb2xib3goKSwgdGhpcy5jcmVhdGVUYWJsZVdyYXBwZXIoKSwgdGhpcy5ob3ZlcmVkUm93ID0gMCwgdGhpcy5ob3ZlcmVkQ29sdW1uID0gMCwgdGhpcy5zZWxlY3RlZFJvdyA9IDAsIHRoaXMuc2VsZWN0ZWRDb2x1bW4gPSAwLCB0aGlzLnR1bmVzID0ge1xuICAgICAgd2l0aEhlYWRpbmdzOiAhMVxuICAgIH0sIHRoaXMucmVzaXplKCksIHRoaXMuZmlsbCgpLCB0aGlzLmZvY3VzZWRDZWxsID0ge1xuICAgICAgcm93OiAwLFxuICAgICAgY29sdW1uOiAwXG4gICAgfSwgdGhpcy5kb2N1bWVudENsaWNrZWQgPSAocykgPT4ge1xuICAgICAgY29uc3QgbiA9IHMudGFyZ2V0LmNsb3Nlc3QoYC4ke3IudGFibGV9YCkgIT09IG51bGwsIGggPSBzLnRhcmdldC5jbG9zZXN0KGAuJHtyLndyYXBwZXJ9YCkgPT09IG51bGw7XG4gICAgICAobiB8fCBoKSAmJiB0aGlzLmhpZGVUb29sYm94ZXMoKTtcbiAgICAgIGNvbnN0IHcgPSBzLnRhcmdldC5jbG9zZXN0KGAuJHtyLmFkZFJvd31gKSwgcCA9IHMudGFyZ2V0LmNsb3Nlc3QoYC4ke3IuYWRkQ29sdW1ufWApO1xuICAgICAgdyAmJiB3LnBhcmVudE5vZGUgPT09IHRoaXMud3JhcHBlciA/ICh0aGlzLmFkZFJvdyh2b2lkIDAsICEwKSwgdGhpcy5oaWRlVG9vbGJveGVzKCkpIDogcCAmJiBwLnBhcmVudE5vZGUgPT09IHRoaXMud3JhcHBlciAmJiAodGhpcy5hZGRDb2x1bW4odm9pZCAwLCAhMCksIHRoaXMuaGlkZVRvb2xib3hlcygpKTtcbiAgICB9LCB0aGlzLnJlYWRPbmx5IHx8IHRoaXMuYmluZEV2ZW50cygpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZW5kZXJlZCB0YWJsZSB3cmFwcGVyXG4gICAqXG4gICAqIEByZXR1cm5zIHtFbGVtZW50fVxuICAgKi9cbiAgZ2V0V3JhcHBlcigpIHtcbiAgICByZXR1cm4gdGhpcy53cmFwcGVyO1xuICB9XG4gIC8qKlxuICAgKiBIYW5ncyB0aGUgbmVjZXNzYXJ5IGhhbmRsZXJzIHRvIGV2ZW50c1xuICAgKi9cbiAgYmluZEV2ZW50cygpIHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5kb2N1bWVudENsaWNrZWQpLCB0aGlzLnRhYmxlLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgSCgxNTAsICh0KSA9PiB0aGlzLm9uTW91c2VNb3ZlSW5UYWJsZSh0KSksIHsgcGFzc2l2ZTogITAgfSksIHRoaXMudGFibGUub25rZXlwcmVzcyA9ICh0KSA9PiB0aGlzLm9uS2V5UHJlc3NMaXN0ZW5lcih0KSwgdGhpcy50YWJsZS5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCAodCkgPT4gdGhpcy5vbktleURvd25MaXN0ZW5lcih0KSksIHRoaXMudGFibGUuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgKHQpID0+IHRoaXMuZm9jdXNJblRhYmxlTGlzdGVuZXIodCkpO1xuICB9XG4gIC8qKlxuICAgKiBDb25maWd1cmVzIGFuZCBjcmVhdGVzIHRoZSB0b29sYm94IGZvciBtYW5pcHVsYXRpbmcgd2l0aCBjb2x1bW5zXG4gICAqXG4gICAqIEByZXR1cm5zIHtUb29sYm94fVxuICAgKi9cbiAgY3JlYXRlQ29sdW1uVG9vbGJveCgpIHtcbiAgICByZXR1cm4gbmV3IHUoe1xuICAgICAgYXBpOiB0aGlzLmFwaSxcbiAgICAgIGNzc01vZGlmaWVyOiBcImNvbHVtblwiLFxuICAgICAgaXRlbXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIGxhYmVsOiB0aGlzLmFwaS5pMThuLnQoXCJBZGQgY29sdW1uIHRvIGxlZnRcIiksXG4gICAgICAgICAgaWNvbjogUyxcbiAgICAgICAgICBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFkZENvbHVtbih0aGlzLnNlbGVjdGVkQ29sdW1uLCAhMCksIHRoaXMuaGlkZVRvb2xib3hlcygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGxhYmVsOiB0aGlzLmFwaS5pMThuLnQoXCJBZGQgY29sdW1uIHRvIHJpZ2h0XCIpLFxuICAgICAgICAgIGljb246IHgsXG4gICAgICAgICAgb25DbGljazogKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hZGRDb2x1bW4odGhpcy5zZWxlY3RlZENvbHVtbiArIDEsICEwKSwgdGhpcy5oaWRlVG9vbGJveGVzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbGFiZWw6IHRoaXMuYXBpLmkxOG4udChcIkRlbGV0ZSBjb2x1bW5cIiksXG4gICAgICAgICAgaWNvbjogYixcbiAgICAgICAgICBoaWRlSWY6ICgpID0+IHRoaXMubnVtYmVyT2ZDb2x1bW5zID09PSAxLFxuICAgICAgICAgIGNvbmZpcm1hdGlvblJlcXVpcmVkOiAhMCxcbiAgICAgICAgICBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRlbGV0ZUNvbHVtbih0aGlzLnNlbGVjdGVkQ29sdW1uKSwgdGhpcy5oaWRlVG9vbGJveGVzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgb25PcGVuOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuc2VsZWN0Q29sdW1uKHRoaXMuaG92ZXJlZENvbHVtbiksIHRoaXMuaGlkZVJvd1Rvb2xib3goKTtcbiAgICAgIH0sXG4gICAgICBvbkNsb3NlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMudW5zZWxlY3RDb2x1bW4oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ29uZmlndXJlcyBhbmQgY3JlYXRlcyB0aGUgdG9vbGJveCBmb3IgbWFuaXB1bGF0aW5nIHdpdGggcm93c1xuICAgKlxuICAgKiBAcmV0dXJucyB7VG9vbGJveH1cbiAgICovXG4gIGNyZWF0ZVJvd1Rvb2xib3goKSB7XG4gICAgcmV0dXJuIG5ldyB1KHtcbiAgICAgIGFwaTogdGhpcy5hcGksXG4gICAgICBjc3NNb2RpZmllcjogXCJyb3dcIixcbiAgICAgIGl0ZW1zOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBsYWJlbDogdGhpcy5hcGkuaTE4bi50KFwiQWRkIHJvdyBhYm92ZVwiKSxcbiAgICAgICAgICBpY29uOiB5LFxuICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWRkUm93KHRoaXMuc2VsZWN0ZWRSb3csICEwKSwgdGhpcy5oaWRlVG9vbGJveGVzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbGFiZWw6IHRoaXMuYXBpLmkxOG4udChcIkFkZCByb3cgYmVsb3dcIiksXG4gICAgICAgICAgaWNvbjogayxcbiAgICAgICAgICBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFkZFJvdyh0aGlzLnNlbGVjdGVkUm93ICsgMSwgITApLCB0aGlzLmhpZGVUb29sYm94ZXMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBsYWJlbDogdGhpcy5hcGkuaTE4bi50KFwiRGVsZXRlIHJvd1wiKSxcbiAgICAgICAgICBpY29uOiBiLFxuICAgICAgICAgIGhpZGVJZjogKCkgPT4gdGhpcy5udW1iZXJPZlJvd3MgPT09IDEsXG4gICAgICAgICAgY29uZmlybWF0aW9uUmVxdWlyZWQ6ICEwLFxuICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGVsZXRlUm93KHRoaXMuc2VsZWN0ZWRSb3cpLCB0aGlzLmhpZGVUb29sYm94ZXMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICBvbk9wZW46ICgpID0+IHtcbiAgICAgICAgdGhpcy5zZWxlY3RSb3codGhpcy5ob3ZlcmVkUm93KSwgdGhpcy5oaWRlQ29sdW1uVG9vbGJveCgpO1xuICAgICAgfSxcbiAgICAgIG9uQ2xvc2U6ICgpID0+IHtcbiAgICAgICAgdGhpcy51bnNlbGVjdFJvdygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBXaGVuIHlvdSBwcmVzcyBlbnRlciBpdCBtb3ZlcyB0aGUgY3Vyc29yIGRvd24gdG8gdGhlIG5leHQgcm93XG4gICAqIG9yIGNyZWF0ZXMgaXQgaWYgdGhlIGNsaWNrIG9jY3VycmVkIG9uIHRoZSBsYXN0IG9uZVxuICAgKi9cbiAgbW92ZUN1cnNvclRvTmV4dFJvdygpIHtcbiAgICB0aGlzLmZvY3VzZWRDZWxsLnJvdyAhPT0gdGhpcy5udW1iZXJPZlJvd3MgPyAodGhpcy5mb2N1c2VkQ2VsbC5yb3cgKz0gMSwgdGhpcy5mb2N1c0NlbGwodGhpcy5mb2N1c2VkQ2VsbCkpIDogKHRoaXMuYWRkUm93KCksIHRoaXMuZm9jdXNlZENlbGwucm93ICs9IDEsIHRoaXMuZm9jdXNDZWxsKHRoaXMuZm9jdXNlZENlbGwpLCB0aGlzLnVwZGF0ZVRvb2xib3hlc1Bvc2l0aW9uKDAsIDApKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRhYmxlIGNlbGwgYnkgcm93IGFuZCBjb2wgaW5kZXhcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHJvdyAtIGNlbGwgcm93IGNvb3JkaW5hdGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbiAtIGNlbGwgY29sdW1uIGNvb3JkaW5hdGVcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgZ2V0Q2VsbCh0LCBlKSB7XG4gICAgcmV0dXJuIHRoaXMudGFibGUucXVlcnlTZWxlY3RvckFsbChgLiR7ci5yb3d9Om50aC1jaGlsZCgke3R9KSAuJHtyLmNlbGx9YClbZSAtIDFdO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGFibGUgcm93IGJ5IGluZGV4XG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByb3cgLSByb3cgY29vcmRpbmF0ZVxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICBnZXRSb3codCkge1xuICAgIHJldHVybiB0aGlzLnRhYmxlLnF1ZXJ5U2VsZWN0b3IoYC4ke3Iucm93fTpudGgtY2hpbGQoJHt0fSlgKTtcbiAgfVxuICAvKipcbiAgICogVGhlIHBhcmVudCBvZiB0aGUgY2VsbCB3aGljaCBpcyB0aGUgcm93XG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNlbGwgLSBjZWxsIGVsZW1lbnRcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgZ2V0Um93QnlDZWxsKHQpIHtcbiAgICByZXR1cm4gdC5wYXJlbnRFbGVtZW50O1xuICB9XG4gIC8qKlxuICAgKiBHZXIgcm93J3MgZmlyc3QgY2VsbFxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHJvdyAtIHJvdyB0byBmaW5kIGl0cyBmaXJzdCBjZWxsXG4gICAqIEByZXR1cm5zIHtFbGVtZW50fVxuICAgKi9cbiAgZ2V0Um93Rmlyc3RDZWxsKHQpIHtcbiAgICByZXR1cm4gdC5xdWVyeVNlbGVjdG9yKGAuJHtyLmNlbGx9OmZpcnN0LWNoaWxkYCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgc2VsbCdzIGNvbnRlbnQgYnkgcm93IGFuZCBjb2x1bW4gbnVtYmVyc1xuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gcm93IC0gY2VsbCByb3cgY29vcmRpbmF0ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uIC0gY2VsbCBjb2x1bW4gY29vcmRpbmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGVudCAtIGNlbGwgSFRNTCBjb250ZW50XG4gICAqL1xuICBzZXRDZWxsQ29udGVudCh0LCBlLCBvKSB7XG4gICAgY29uc3QgaSA9IHRoaXMuZ2V0Q2VsbCh0LCBlKTtcbiAgICBpLmlubmVySFRNTCA9IG87XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBjb2x1bW4gaW4gdGFibGUgb24gaW5kZXggcGxhY2VcbiAgICogQWRkIGNlbGxzIGluIGVhY2ggcm93XG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5JbmRleCAtIG51bWJlciBpbiB0aGUgYXJyYXkgb2YgY29sdW1ucywgd2hlcmUgbmV3IGNvbHVtbiB0byBpbnNlcnQsIC0xIGlmIGluc2VydCBhdCB0aGUgZW5kXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NldEZvY3VzXSAtIHBhc3MgdHJ1ZSB0byBmb2N1cyB0aGUgZmlyc3QgY2VsbFxuICAgKi9cbiAgYWRkQ29sdW1uKHQgPSAtMSwgZSA9ICExKSB7XG4gICAgbGV0IG8gPSB0aGlzLm51bWJlck9mQ29sdW1ucztcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSB0aGlzLm51bWJlck9mUm93czsgaSsrKSB7XG4gICAgICBsZXQgcztcbiAgICAgIGNvbnN0IG4gPSB0aGlzLmNyZWF0ZUNlbGwoKTtcbiAgICAgIGlmICh0ID4gMCAmJiB0IDw9IG8gPyAocyA9IHRoaXMuZ2V0Q2VsbChpLCB0KSwgQyhuLCBzKSkgOiBzID0gdGhpcy5nZXRSb3coaSkuYXBwZW5kQ2hpbGQobiksIGkgPT09IDEpIHtcbiAgICAgICAgY29uc3QgaCA9IHRoaXMuZ2V0Q2VsbChpLCB0ID4gMCA/IHQgOiBvICsgMSk7XG4gICAgICAgIGggJiYgZSAmJiBtKGgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmFkZEhlYWRpbmdBdHRyVG9GaXJzdFJvdygpO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgcm93IGluIHRhYmxlIG9uIGluZGV4IHBsYWNlXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIG51bWJlciBpbiB0aGUgYXJyYXkgb2Ygcm93cywgd2hlcmUgbmV3IGNvbHVtbiB0byBpbnNlcnQsIC0xIGlmIGluc2VydCBhdCB0aGUgZW5kXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NldEZvY3VzXSAtIHBhc3MgdHJ1ZSB0byBmb2N1cyB0aGUgaW5zZXJ0ZWQgcm93XG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gcm93XG4gICAqL1xuICBhZGRSb3codCA9IC0xLCBlID0gITEpIHtcbiAgICBsZXQgbywgaSA9IGMoXCJkaXZcIiwgci5yb3cpO1xuICAgIHRoaXMudHVuZXMud2l0aEhlYWRpbmdzICYmIHRoaXMucmVtb3ZlSGVhZGluZ0F0dHJGcm9tRmlyc3RSb3coKTtcbiAgICBsZXQgcyA9IHRoaXMubnVtYmVyT2ZDb2x1bW5zO1xuICAgIGlmICh0ID4gMCAmJiB0IDw9IHRoaXMubnVtYmVyT2ZSb3dzKSB7XG4gICAgICBsZXQgaCA9IHRoaXMuZ2V0Um93KHQpO1xuICAgICAgbyA9IEMoaSwgaCk7XG4gICAgfSBlbHNlXG4gICAgICBvID0gdGhpcy50YWJsZS5hcHBlbmRDaGlsZChpKTtcbiAgICB0aGlzLmZpbGxSb3cobywgcyksIHRoaXMudHVuZXMud2l0aEhlYWRpbmdzICYmIHRoaXMuYWRkSGVhZGluZ0F0dHJUb0ZpcnN0Um93KCk7XG4gICAgY29uc3QgbiA9IHRoaXMuZ2V0Um93Rmlyc3RDZWxsKG8pO1xuICAgIHJldHVybiBuICYmIGUgJiYgbShuKSwgbztcbiAgfVxuICAvKipcbiAgICogRGVsZXRlIGEgY29sdW1uIGJ5IGluZGV4XG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKi9cbiAgZGVsZXRlQ29sdW1uKHQpIHtcbiAgICBmb3IgKGxldCBlID0gMTsgZSA8PSB0aGlzLm51bWJlck9mUm93czsgZSsrKSB7XG4gICAgICBjb25zdCBvID0gdGhpcy5nZXRDZWxsKGUsIHQpO1xuICAgICAgaWYgKCFvKVxuICAgICAgICByZXR1cm47XG4gICAgICBvLnJlbW92ZSgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRGVsZXRlIGEgcm93IGJ5IGluZGV4XG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKi9cbiAgZGVsZXRlUm93KHQpIHtcbiAgICB0aGlzLmdldFJvdyh0KS5yZW1vdmUoKSwgdGhpcy5hZGRIZWFkaW5nQXR0clRvRmlyc3RSb3coKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgd3JhcHBlciBjb250YWluaW5nIGEgdGFibGUsIHRvb2xib3hlc1xuICAgKiBhbmQgYnV0dG9ucyBmb3IgYWRkaW5nIHJvd3MgYW5kIGNvbHVtbnNcbiAgICpcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50fSB3cmFwcGVyIC0gd2hlcmUgYWxsIGJ1dHRvbnMgZm9yIGEgdGFibGUgYW5kIHRoZSB0YWJsZSBpdHNlbGYgd2lsbCBiZVxuICAgKi9cbiAgY3JlYXRlVGFibGVXcmFwcGVyKCkge1xuICAgIGlmICh0aGlzLndyYXBwZXIgPSBjKFwiZGl2XCIsIHIud3JhcHBlciksIHRoaXMudGFibGUgPSBjKFwiZGl2XCIsIHIudGFibGUpLCB0aGlzLnJlYWRPbmx5ICYmIHRoaXMud3JhcHBlci5jbGFzc0xpc3QuYWRkKHIud3JhcHBlclJlYWRPbmx5KSwgdGhpcy53cmFwcGVyLmFwcGVuZENoaWxkKHRoaXMudG9vbGJveFJvdy5lbGVtZW50KSwgdGhpcy53cmFwcGVyLmFwcGVuZENoaWxkKHRoaXMudG9vbGJveENvbHVtbi5lbGVtZW50KSwgdGhpcy53cmFwcGVyLmFwcGVuZENoaWxkKHRoaXMudGFibGUpLCAhdGhpcy5yZWFkT25seSkge1xuICAgICAgY29uc3QgdCA9IGMoXCJkaXZcIiwgci5hZGRDb2x1bW4sIHtcbiAgICAgICAgaW5uZXJIVE1MOiB2XG4gICAgICB9KSwgZSA9IGMoXCJkaXZcIiwgci5hZGRSb3csIHtcbiAgICAgICAgaW5uZXJIVE1MOiB2XG4gICAgICB9KTtcbiAgICAgIHRoaXMud3JhcHBlci5hcHBlbmRDaGlsZCh0KSwgdGhpcy53cmFwcGVyLmFwcGVuZENoaWxkKGUpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc2l6ZSBvZiB0aGUgdGFibGUgYmFzZWQgb24gaW5pdGlhbCBkYXRhIG9yIGNvbmZpZyBcInNpemVcIiBwcm9wZXJ0eVxuICAgKlxuICAgKiBAcmV0dXJuIHt7cm93czogbnVtYmVyLCBjb2xzOiBudW1iZXJ9fSAtIG51bWJlciBvZiBjb2xzIGFuZCByb3dzXG4gICAqL1xuICBjb21wdXRlSW5pdGlhbFNpemUoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZGF0YSAmJiB0aGlzLmRhdGEuY29udGVudCwgZSA9IEFycmF5LmlzQXJyYXkodCksIG8gPSBlID8gdC5sZW5ndGggOiAhMSwgaSA9IGUgPyB0Lmxlbmd0aCA6IHZvaWQgMCwgcyA9IG8gPyB0WzBdLmxlbmd0aCA6IHZvaWQgMCwgbiA9IE51bWJlci5wYXJzZUludCh0aGlzLmNvbmZpZyAmJiB0aGlzLmNvbmZpZy5yb3dzKSwgaCA9IE51bWJlci5wYXJzZUludCh0aGlzLmNvbmZpZyAmJiB0aGlzLmNvbmZpZy5jb2xzKSwgbCA9ICFpc05hTihuKSAmJiBuID4gMCA/IG4gOiB2b2lkIDAsIHcgPSAhaXNOYU4oaCkgJiYgaCA+IDAgPyBoIDogdm9pZCAwO1xuICAgIHJldHVybiB7XG4gICAgICByb3dzOiBpIHx8IGwgfHwgMixcbiAgICAgIGNvbHM6IHMgfHwgdyB8fCAyXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmVzaXplIHRhYmxlIHRvIG1hdGNoIGNvbmZpZyBzaXplIG9yIHRyYW5zbWl0dGVkIGRhdGEgc2l6ZVxuICAgKlxuICAgKiBAcmV0dXJuIHt7cm93czogbnVtYmVyLCBjb2xzOiBudW1iZXJ9fSAtIG51bWJlciBvZiBjb2xzIGFuZCByb3dzXG4gICAqL1xuICByZXNpemUoKSB7XG4gICAgY29uc3QgeyByb3dzOiB0LCBjb2xzOiBlIH0gPSB0aGlzLmNvbXB1dGVJbml0aWFsU2l6ZSgpO1xuICAgIGZvciAobGV0IG8gPSAwOyBvIDwgdDsgbysrKVxuICAgICAgdGhpcy5hZGRSb3coKTtcbiAgICBmb3IgKGxldCBvID0gMDsgbyA8IGU7IG8rKylcbiAgICAgIHRoaXMuYWRkQ29sdW1uKCk7XG4gIH1cbiAgLyoqXG4gICAqIEZpbGxzIHRoZSB0YWJsZSB3aXRoIGRhdGEgcGFzc2VkIHRvIHRoZSBjb25zdHJ1Y3RvclxuICAgKlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGZpbGwoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZGF0YTtcbiAgICBpZiAodCAmJiB0LmNvbnRlbnQpXG4gICAgICBmb3IgKGxldCBlID0gMDsgZSA8IHQuY29udGVudC5sZW5ndGg7IGUrKylcbiAgICAgICAgZm9yIChsZXQgbyA9IDA7IG8gPCB0LmNvbnRlbnRbZV0ubGVuZ3RoOyBvKyspXG4gICAgICAgICAgdGhpcy5zZXRDZWxsQ29udGVudChlICsgMSwgbyArIDEsIHQuY29udGVudFtlXVtvXSk7XG4gIH1cbiAgLyoqXG4gICAqIEZpbGxzIGEgcm93IHdpdGggY2VsbHNcbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcm93IC0gcm93IHRvIGZpbGxcbiAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlck9mQ29sdW1ucyAtIGhvdyBtYW55IGNlbGxzIHNob3VsZCBiZSBpbiBhIHJvd1xuICAgKi9cbiAgZmlsbFJvdyh0LCBlKSB7XG4gICAgZm9yIChsZXQgbyA9IDE7IG8gPD0gZTsgbysrKSB7XG4gICAgICBjb25zdCBpID0gdGhpcy5jcmVhdGVDZWxsKCk7XG4gICAgICB0LmFwcGVuZENoaWxkKGkpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ3JlYXRpbmcgYSBjZWxsIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICovXG4gIGNyZWF0ZUNlbGwoKSB7XG4gICAgcmV0dXJuIGMoXCJkaXZcIiwgci5jZWxsLCB7XG4gICAgICBjb250ZW50RWRpdGFibGU6ICF0aGlzLnJlYWRPbmx5XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBudW1iZXIgb2Ygcm93cyBpbiB0aGUgdGFibGVcbiAgICovXG4gIGdldCBudW1iZXJPZlJvd3MoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFibGUuY2hpbGRFbGVtZW50Q291bnQ7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBudW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgdGFibGVcbiAgICovXG4gIGdldCBudW1iZXJPZkNvbHVtbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMubnVtYmVyT2ZSb3dzID8gdGhpcy50YWJsZS5xdWVyeVNlbGVjdG9yQWxsKGAuJHtyLnJvd306Zmlyc3QtY2hpbGQgLiR7ci5jZWxsfWApLmxlbmd0aCA6IDA7XG4gIH1cbiAgLyoqXG4gICAqIElzIHRoZSBjb2x1bW4gdG9vbGJveCBtZW51IGRpc3BsYXllZCBvciBub3RcbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNDb2x1bW5NZW51U2hvd2luZygpIHtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3RlZENvbHVtbiAhPT0gMDtcbiAgfVxuICAvKipcbiAgICogSXMgdGhlIHJvdyB0b29sYm94IG1lbnUgZGlzcGxheWVkIG9yIG5vdFxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc1Jvd01lbnVTaG93aW5nKCkge1xuICAgIHJldHVybiB0aGlzLnNlbGVjdGVkUm93ICE9PSAwO1xuICB9XG4gIC8qKlxuICAgKiBSZWNhbGN1bGF0ZSBwb3NpdGlvbiBvZiB0b29sYm94IGljb25zXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gbW91c2UgbW92ZSBldmVudFxuICAgKi9cbiAgb25Nb3VzZU1vdmVJblRhYmxlKHQpIHtcbiAgICBjb25zdCB7IHJvdzogZSwgY29sdW1uOiBvIH0gPSB0aGlzLmdldEhvdmVyZWRDZWxsKHQpO1xuICAgIHRoaXMuaG92ZXJlZENvbHVtbiA9IG8sIHRoaXMuaG92ZXJlZFJvdyA9IGUsIHRoaXMudXBkYXRlVG9vbGJveGVzUG9zaXRpb24oKTtcbiAgfVxuICAvKipcbiAgICogUHJldmVudHMgZGVmYXVsdCBFbnRlciBiZWhhdmlvcnNcbiAgICogQWRkcyBTaGlmdCtFbnRlciBwcm9jZXNzaW5nXG4gICAqXG4gICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnQgLSBrZXlwcmVzcyBldmVudFxuICAgKi9cbiAgb25LZXlQcmVzc0xpc3RlbmVyKHQpIHtcbiAgICBpZiAodC5rZXkgPT09IFwiRW50ZXJcIikge1xuICAgICAgaWYgKHQuc2hpZnRLZXkpXG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIHRoaXMubW92ZUN1cnNvclRvTmV4dFJvdygpO1xuICAgIH1cbiAgICByZXR1cm4gdC5rZXkgIT09IFwiRW50ZXJcIjtcbiAgfVxuICAvKipcbiAgICogUHJldmVudHMgdGFiIGtleWRvd24gZXZlbnQgZnJvbSBidWJibGluZ1xuICAgKiBzbyB0aGF0IGl0IG9ubHkgd29ya3MgaW5zaWRlIHRoZSB0YWJsZVxuICAgKlxuICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2ZW50IC0ga2V5ZG93biBldmVudFxuICAgKi9cbiAgb25LZXlEb3duTGlzdGVuZXIodCkge1xuICAgIHQua2V5ID09PSBcIlRhYlwiICYmIHQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIGNlbGwgdGhhdCB0aGUgZm9jdXMgaGFzIG1vdmVkIHRvXG4gICAqXG4gICAqIEBwYXJhbSB7Rm9jdXNFdmVudH0gZXZlbnQgLSBmb2N1c2luIGV2ZW50XG4gICAqL1xuICBmb2N1c0luVGFibGVMaXN0ZW5lcih0KSB7XG4gICAgY29uc3QgZSA9IHQudGFyZ2V0LCBvID0gdGhpcy5nZXRSb3dCeUNlbGwoZSk7XG4gICAgdGhpcy5mb2N1c2VkQ2VsbCA9IHtcbiAgICAgIHJvdzogQXJyYXkuZnJvbSh0aGlzLnRhYmxlLnF1ZXJ5U2VsZWN0b3JBbGwoYC4ke3Iucm93fWApKS5pbmRleE9mKG8pICsgMSxcbiAgICAgIGNvbHVtbjogQXJyYXkuZnJvbShvLnF1ZXJ5U2VsZWN0b3JBbGwoYC4ke3IuY2VsbH1gKSkuaW5kZXhPZihlKSArIDFcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBVbnNlbGVjdCByb3cvY29sdW1uXG4gICAqIENsb3NlIHRvb2xib3ggbWVudVxuICAgKiBIaWRlIHRvb2xib3hlc1xuICAgKlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGhpZGVUb29sYm94ZXMoKSB7XG4gICAgdGhpcy5oaWRlUm93VG9vbGJveCgpLCB0aGlzLmhpZGVDb2x1bW5Ub29sYm94KCksIHRoaXMudXBkYXRlVG9vbGJveGVzUG9zaXRpb24oKTtcbiAgfVxuICAvKipcbiAgICogVW5zZWxlY3Qgcm93LCBjbG9zZSB0b29sYm94XG4gICAqXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgaGlkZVJvd1Rvb2xib3goKSB7XG4gICAgdGhpcy51bnNlbGVjdFJvdygpLCB0aGlzLnRvb2xib3hSb3cuaGlkZSgpO1xuICB9XG4gIC8qKlxuICAgKiBVbnNlbGVjdCBjb2x1bW4sIGNsb3NlIHRvb2xib3hcbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBoaWRlQ29sdW1uVG9vbGJveCgpIHtcbiAgICB0aGlzLnVuc2VsZWN0Q29sdW1uKCksIHRoaXMudG9vbGJveENvbHVtbi5oaWRlKCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgY3Vyc29yIGZvY3VzIHRvIHRoZSBmb2N1c2VkIGNlbGxcbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBmb2N1c0NlbGwoKSB7XG4gICAgdGhpcy5mb2N1c2VkQ2VsbEVsZW0uZm9jdXMoKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGN1cnJlbnQgZm9jdXNlZCBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gLSBmb2N1c2VkIGNlbGxcbiAgICovXG4gIGdldCBmb2N1c2VkQ2VsbEVsZW0oKSB7XG4gICAgY29uc3QgeyByb3c6IHQsIGNvbHVtbjogZSB9ID0gdGhpcy5mb2N1c2VkQ2VsbDtcbiAgICByZXR1cm4gdGhpcy5nZXRDZWxsKHQsIGUpO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGUgdG9vbGJveGVzIHBvc2l0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByb3cgLSBob3ZlcmVkIHJvd1xuICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uIC0gaG92ZXJlZCBjb2x1bW5cbiAgICovXG4gIHVwZGF0ZVRvb2xib3hlc1Bvc2l0aW9uKHQgPSB0aGlzLmhvdmVyZWRSb3csIGUgPSB0aGlzLmhvdmVyZWRDb2x1bW4pIHtcbiAgICB0aGlzLmlzQ29sdW1uTWVudVNob3dpbmcgfHwgZSA+IDAgJiYgZSA8PSB0aGlzLm51bWJlck9mQ29sdW1ucyAmJiB0aGlzLnRvb2xib3hDb2x1bW4uc2hvdygoKSA9PiAoe1xuICAgICAgbGVmdDogYGNhbGMoKDEwMCUgLSB2YXIoLS1jZWxsLXNpemUpKSAvICgke3RoaXMubnVtYmVyT2ZDb2x1bW5zfSAqIDIpICogKDEgKyAoJHtlfSAtIDEpICogMikpYFxuICAgIH0pKSwgdGhpcy5pc1Jvd01lbnVTaG93aW5nIHx8IHQgPiAwICYmIHQgPD0gdGhpcy5udW1iZXJPZlJvd3MgJiYgdGhpcy50b29sYm94Um93LnNob3coKCkgPT4ge1xuICAgICAgY29uc3QgbyA9IHRoaXMuZ2V0Um93KHQpLCB7IGZyb21Ub3BCb3JkZXI6IGkgfSA9IGcodGhpcy50YWJsZSwgbyksIHsgaGVpZ2h0OiBzIH0gPSBvLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiBgJHtNYXRoLmNlaWwoaSArIHMgLyAyKX1weGBcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIE1ha2VzIHRoZSBmaXJzdCByb3cgaGVhZGluZ3NcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSB3aXRoSGVhZGluZ3MgLSB1c2UgaGVhZGluZ3Mgcm93IG9yIG5vdFxuICAgKi9cbiAgc2V0SGVhZGluZ3NTZXR0aW5nKHQpIHtcbiAgICB0aGlzLnR1bmVzLndpdGhIZWFkaW5ncyA9IHQsIHQgPyAodGhpcy50YWJsZS5jbGFzc0xpc3QuYWRkKHIud2l0aEhlYWRpbmdzKSwgdGhpcy5hZGRIZWFkaW5nQXR0clRvRmlyc3RSb3coKSkgOiAodGhpcy50YWJsZS5jbGFzc0xpc3QucmVtb3ZlKHIud2l0aEhlYWRpbmdzKSwgdGhpcy5yZW1vdmVIZWFkaW5nQXR0ckZyb21GaXJzdFJvdygpKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhbiBhdHRyaWJ1dGUgZm9yIGRpc3BsYXlpbmcgdGhlIHBsYWNlaG9sZGVyIGluIHRoZSBjZWxsXG4gICAqL1xuICBhZGRIZWFkaW5nQXR0clRvRmlyc3RSb3coKSB7XG4gICAgZm9yIChsZXQgdCA9IDE7IHQgPD0gdGhpcy5udW1iZXJPZkNvbHVtbnM7IHQrKykge1xuICAgICAgbGV0IGUgPSB0aGlzLmdldENlbGwoMSwgdCk7XG4gICAgICBlICYmIGUuc2V0QXR0cmlidXRlKFwiaGVhZGluZ1wiLCB0aGlzLmFwaS5pMThuLnQoXCJIZWFkaW5nXCIpKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYW4gYXR0cmlidXRlIGZvciBkaXNwbGF5aW5nIHRoZSBwbGFjZWhvbGRlciBpbiB0aGUgY2VsbFxuICAgKi9cbiAgcmVtb3ZlSGVhZGluZ0F0dHJGcm9tRmlyc3RSb3coKSB7XG4gICAgZm9yIChsZXQgdCA9IDE7IHQgPD0gdGhpcy5udW1iZXJPZkNvbHVtbnM7IHQrKykge1xuICAgICAgbGV0IGUgPSB0aGlzLmdldENlbGwoMSwgdCk7XG4gICAgICBlICYmIGUucmVtb3ZlQXR0cmlidXRlKFwiaGVhZGluZ1wiKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBlZmZlY3Qgb2YgYSBzZWxlY3RlZCByb3dcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAqL1xuICBzZWxlY3RSb3codCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmdldFJvdyh0KTtcbiAgICBlICYmICh0aGlzLnNlbGVjdGVkUm93ID0gdCwgZS5jbGFzc0xpc3QuYWRkKHIucm93U2VsZWN0ZWQpKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIGVmZmVjdCBvZiBhIHNlbGVjdGVkIHJvd1xuICAgKi9cbiAgdW5zZWxlY3RSb3coKSB7XG4gICAgaWYgKHRoaXMuc2VsZWN0ZWRSb3cgPD0gMClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0gdGhpcy50YWJsZS5xdWVyeVNlbGVjdG9yKGAuJHtyLnJvd1NlbGVjdGVkfWApO1xuICAgIHQgJiYgdC5jbGFzc0xpc3QucmVtb3ZlKHIucm93U2VsZWN0ZWQpLCB0aGlzLnNlbGVjdGVkUm93ID0gMDtcbiAgfVxuICAvKipcbiAgICogQWRkIGVmZmVjdCBvZiBhIHNlbGVjdGVkIGNvbHVtblxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICovXG4gIHNlbGVjdENvbHVtbih0KSB7XG4gICAgZm9yIChsZXQgZSA9IDE7IGUgPD0gdGhpcy5udW1iZXJPZlJvd3M7IGUrKykge1xuICAgICAgY29uc3QgbyA9IHRoaXMuZ2V0Q2VsbChlLCB0KTtcbiAgICAgIG8gJiYgby5jbGFzc0xpc3QuYWRkKHIuY2VsbFNlbGVjdGVkKTtcbiAgICB9XG4gICAgdGhpcy5zZWxlY3RlZENvbHVtbiA9IHQ7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBlZmZlY3Qgb2YgYSBzZWxlY3RlZCBjb2x1bW5cbiAgICovXG4gIHVuc2VsZWN0Q29sdW1uKCkge1xuICAgIGlmICh0aGlzLnNlbGVjdGVkQ29sdW1uIDw9IDApXG4gICAgICByZXR1cm47XG4gICAgbGV0IHQgPSB0aGlzLnRhYmxlLnF1ZXJ5U2VsZWN0b3JBbGwoYC4ke3IuY2VsbFNlbGVjdGVkfWApO1xuICAgIEFycmF5LmZyb20odCkuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgZS5jbGFzc0xpc3QucmVtb3ZlKHIuY2VsbFNlbGVjdGVkKTtcbiAgICB9KSwgdGhpcy5zZWxlY3RlZENvbHVtbiA9IDA7XG4gIH1cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIHJvdyBhbmQgY29sdW1uIHRoYXQgdGhlIGN1cnNvciBpcyBjdXJyZW50bHkgaG92ZXJpbmcgb3ZlclxuICAgKiBUaGUgc2VhcmNoIHdhcyBvcHRpbWl6ZWQgZnJvbSBPKG4pIHRvIE8gKGxvZyBuKSB2aWEgYmluIHNlYXJjaCB0byByZWR1Y2UgdGhlIG51bWJlciBvZiBjYWxjdWxhdGlvbnNcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBtb3VzZW1vdmUgZXZlbnRcbiAgICogQHJldHVybnMgaG92ZXJlZCBjZWxsIGNvb3JkaW5hdGVzIGFzIGFuIGludGVnZXIgcm93IGFuZCBjb2x1bW5cbiAgICovXG4gIGdldEhvdmVyZWRDZWxsKHQpIHtcbiAgICBsZXQgZSA9IHRoaXMuaG92ZXJlZFJvdywgbyA9IHRoaXMuaG92ZXJlZENvbHVtbjtcbiAgICBjb25zdCB7IHdpZHRoOiBpLCBoZWlnaHQ6IHMsIHg6IG4sIHk6IGggfSA9IFIodGhpcy50YWJsZSwgdCk7XG4gICAgcmV0dXJuIG4gPj0gMCAmJiAobyA9IHRoaXMuYmluU2VhcmNoKFxuICAgICAgdGhpcy5udW1iZXJPZkNvbHVtbnMsXG4gICAgICAobCkgPT4gdGhpcy5nZXRDZWxsKDEsIGwpLFxuICAgICAgKHsgZnJvbUxlZnRCb3JkZXI6IGwgfSkgPT4gbiA8IGwsXG4gICAgICAoeyBmcm9tUmlnaHRCb3JkZXI6IGwgfSkgPT4gbiA+IGkgLSBsXG4gICAgKSksIGggPj0gMCAmJiAoZSA9IHRoaXMuYmluU2VhcmNoKFxuICAgICAgdGhpcy5udW1iZXJPZlJvd3MsXG4gICAgICAobCkgPT4gdGhpcy5nZXRDZWxsKGwsIDEpLFxuICAgICAgKHsgZnJvbVRvcEJvcmRlcjogbCB9KSA9PiBoIDwgbCxcbiAgICAgICh7IGZyb21Cb3R0b21Cb3JkZXI6IGwgfSkgPT4gaCA+IHMgLSBsXG4gICAgKSksIHtcbiAgICAgIHJvdzogZSB8fCB0aGlzLmhvdmVyZWRSb3csXG4gICAgICBjb2x1bW46IG8gfHwgdGhpcy5ob3ZlcmVkQ29sdW1uXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogTG9va3MgZm9yIHRoZSBpbmRleCBvZiB0aGUgY2VsbCB0aGUgbW91c2UgaXMgaG92ZXJpbmcgb3Zlci5cbiAgICogQ2VsbHMgY2FuIGJlIHJlcHJlc2VudGVkIGFzIG9yZGVyZWQgaW50ZXJ2YWxzIHdpdGggbGVmdCBhbmRcbiAgICogcmlnaHQgKHVwcGVyIGFuZCBsb3dlciBmb3Igcm93cykgYm9yZGVycyBpbnNpZGUgdGhlIHRhYmxlLCBpZiB0aGUgbW91c2UgZW50ZXJzIGl0LCB0aGVuIHRoaXMgaXMgb3VyIGluZGV4XG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXJPZkNlbGxzIC0gdXBwZXIgYm91bmQgb2YgYmluYXJ5IHNlYXJjaFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBnZXRDZWxsIC0gZnVuY3Rpb24gdG8gdGFrZSB0aGUgY3VycmVudGx5IHZpZXdlZCBjZWxsXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGJlZm9yZVRoZUxlZnRCb3JkZXIgLSBkZXRlcm1pbmVzIHRoZSBjdXJzb3IgcG9zaXRpb24sIHRvIHRoZSBsZWZ0IG9mIHRoZSBjZWxsIG9yIG5vdFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBhZnRlclRoZVJpZ2h0Qm9yZGVyIC0gZGV0ZXJtaW5lcyB0aGUgY3Vyc29yIHBvc2l0aW9uLCB0byB0aGUgcmlnaHQgb2YgdGhlIGNlbGwgb3Igbm90XG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBiaW5TZWFyY2godCwgZSwgbywgaSkge1xuICAgIGxldCBzID0gMCwgbiA9IHQgKyAxLCBoID0gMCwgbDtcbiAgICBmb3IgKDsgcyA8IG4gLSAxICYmIGggPCAxMDsgKSB7XG4gICAgICBsID0gTWF0aC5jZWlsKChzICsgbikgLyAyKTtcbiAgICAgIGNvbnN0IHcgPSBlKGwpLCBwID0gZyh0aGlzLnRhYmxlLCB3KTtcbiAgICAgIGlmIChvKHApKVxuICAgICAgICBuID0gbDtcbiAgICAgIGVsc2UgaWYgKGkocCkpXG4gICAgICAgIHMgPSBsO1xuICAgICAgZWxzZVxuICAgICAgICBicmVhaztcbiAgICAgIGgrKztcbiAgICB9XG4gICAgcmV0dXJuIGw7XG4gIH1cbiAgLyoqXG4gICAqIENvbGxlY3RzIGRhdGEgZnJvbSBjZWxscyBpbnRvIGEgdHdvLWRpbWVuc2lvbmFsIGFycmF5XG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmdbXVtdfVxuICAgKi9cbiAgZ2V0RGF0YSgpIHtcbiAgICBjb25zdCB0ID0gW107XG4gICAgZm9yIChsZXQgZSA9IDE7IGUgPD0gdGhpcy5udW1iZXJPZlJvd3M7IGUrKykge1xuICAgICAgY29uc3QgbyA9IHRoaXMudGFibGUucXVlcnlTZWxlY3RvcihgLiR7ci5yb3d9Om50aC1jaGlsZCgke2V9KWApLCBpID0gQXJyYXkuZnJvbShvLnF1ZXJ5U2VsZWN0b3JBbGwoYC4ke3IuY2VsbH1gKSk7XG4gICAgICBpLmV2ZXJ5KChuKSA9PiAhbi50ZXh0Q29udGVudC50cmltKCkpIHx8IHQucHVzaChpLm1hcCgobikgPT4gbi5pbm5lckhUTUwpKTtcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBsaXN0ZW5lcnMgb24gdGhlIGRvY3VtZW50XG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLmRvY3VtZW50Q2xpY2tlZCk7XG4gIH1cbn1cbmNsYXNzIEkge1xuICAvKipcbiAgICogTm90aWZ5IGNvcmUgdGhhdCByZWFkLW9ubHkgbW9kZSBpcyBzdXBwb3J0ZWRcbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgZ2V0IGlzUmVhZE9ubHlTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuICEwO1xuICB9XG4gIC8qKlxuICAgKiBBbGxvdyB0byBwcmVzcyBFbnRlciBpbnNpZGUgdGhlIENvZGVUb29sIHRleHRhcmVhXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKiBAcHVibGljXG4gICAqL1xuICBzdGF0aWMgZ2V0IGVuYWJsZUxpbmVCcmVha3MoKSB7XG4gICAgcmV0dXJuICEwO1xuICB9XG4gIC8qKlxuICAgKiBSZW5kZXIgcGx1Z2luYHMgbWFpbiBFbGVtZW50IGFuZCBmaWxsIGl0IHdpdGggc2F2ZWQgZGF0YVxuICAgKlxuICAgKiBAcGFyYW0ge1RhYmxlRGF0YX0gZGF0YSDigJQgcHJldmlvdXNseSBzYXZlZCBkYXRhXG4gICAqIEBwYXJhbSB7VGFibGVDb25maWd9IGNvbmZpZyAtIHVzZXIgY29uZmlnIGZvciBUb29sXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBhcGkgLSBFZGl0b3IuanMgQVBJXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVhZE9ubHkgLSByZWFkLW9ubHkgbW9kZSBmbGFnXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGRhdGE6IHQsIGNvbmZpZzogZSwgYXBpOiBvLCByZWFkT25seTogaSB9KSB7XG4gICAgdGhpcy5hcGkgPSBvLCB0aGlzLnJlYWRPbmx5ID0gaSwgdGhpcy5jb25maWcgPSBlLCB0aGlzLmRhdGEgPSB7XG4gICAgICB3aXRoSGVhZGluZ3M6IHRoaXMuZ2V0Q29uZmlnKFwid2l0aEhlYWRpbmdzXCIsICExLCB0KSxcbiAgICAgIGNvbnRlbnQ6IHQgJiYgdC5jb250ZW50ID8gdC5jb250ZW50IDogW11cbiAgICB9LCB0aGlzLnRhYmxlID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogR2V0IFRvb2wgdG9vbGJveCBzZXR0aW5nc1xuICAgKiBpY29uIC0gVG9vbCBpY29uJ3MgU1ZHXG4gICAqIHRpdGxlIC0gdGl0bGUgdG8gc2hvdyBpbiB0b29sYm94XG4gICAqXG4gICAqIEByZXR1cm5zIHt7aWNvbjogc3RyaW5nLCB0aXRsZTogc3RyaW5nfX1cbiAgICovXG4gIHN0YXRpYyBnZXQgdG9vbGJveCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaWNvbjogTyxcbiAgICAgIHRpdGxlOiBcIlRhYmxlXCJcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gVG9vbCdzIHZpZXdcbiAgICpcbiAgICogQHJldHVybnMge0hUTUxEaXZFbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLnRhYmxlID0gbmV3IEEodGhpcy5yZWFkT25seSwgdGhpcy5hcGksIHRoaXMuZGF0YSwgdGhpcy5jb25maWcpLCB0aGlzLmNvbnRhaW5lciA9IGMoXCJkaXZcIiwgdGhpcy5hcGkuc3R5bGVzLmJsb2NrKSwgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy50YWJsZS5nZXRXcmFwcGVyKCkpLCB0aGlzLnRhYmxlLnNldEhlYWRpbmdzU2V0dGluZyh0aGlzLmRhdGEud2l0aEhlYWRpbmdzKSwgdGhpcy5jb250YWluZXI7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgcGx1Z2luIHNldHRpbmdzXG4gICAqXG4gICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICovXG4gIHJlbmRlclNldHRpbmdzKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIGxhYmVsOiB0aGlzLmFwaS5pMThuLnQoXCJXaXRoIGhlYWRpbmdzXCIpLFxuICAgICAgICBpY29uOiBMLFxuICAgICAgICBpc0FjdGl2ZTogdGhpcy5kYXRhLndpdGhIZWFkaW5ncyxcbiAgICAgICAgY2xvc2VPbkFjdGl2YXRlOiAhMCxcbiAgICAgICAgdG9nZ2xlOiAhMCxcbiAgICAgICAgb25BY3RpdmF0ZTogKCkgPT4ge1xuICAgICAgICAgIHRoaXMuZGF0YS53aXRoSGVhZGluZ3MgPSAhMCwgdGhpcy50YWJsZS5zZXRIZWFkaW5nc1NldHRpbmcodGhpcy5kYXRhLndpdGhIZWFkaW5ncyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGxhYmVsOiB0aGlzLmFwaS5pMThuLnQoXCJXaXRob3V0IGhlYWRpbmdzXCIpLFxuICAgICAgICBpY29uOiBNLFxuICAgICAgICBpc0FjdGl2ZTogIXRoaXMuZGF0YS53aXRoSGVhZGluZ3MsXG4gICAgICAgIGNsb3NlT25BY3RpdmF0ZTogITAsXG4gICAgICAgIHRvZ2dsZTogITAsXG4gICAgICAgIG9uQWN0aXZhdGU6ICgpID0+IHtcbiAgICAgICAgICB0aGlzLmRhdGEud2l0aEhlYWRpbmdzID0gITEsIHRoaXMudGFibGUuc2V0SGVhZGluZ3NTZXR0aW5nKHRoaXMuZGF0YS53aXRoSGVhZGluZ3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgXTtcbiAgfVxuICAvKipcbiAgICogRXh0cmFjdCB0YWJsZSBkYXRhIGZyb20gdGhlIHZpZXdcbiAgICpcbiAgICogQHJldHVybnMge1RhYmxlRGF0YX0gLSBzYXZlZCBkYXRhXG4gICAqL1xuICBzYXZlKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLnRhYmxlLmdldERhdGEoKTtcbiAgICByZXR1cm4ge1xuICAgICAgd2l0aEhlYWRpbmdzOiB0aGlzLmRhdGEud2l0aEhlYWRpbmdzLFxuICAgICAgY29udGVudDogdFxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFBsdWdpbiBkZXN0cm95ZXJcbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMudGFibGUuZGVzdHJveSgpO1xuICB9XG4gIC8qKlxuICAgKiBBIGhlbHBlciB0byBnZXQgY29uZmlnIHZhbHVlLlxuICAgKiBcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbmZpZ05hbWUgLSB0aGUga2V5IHRvIGdldCBmcm9tIHRoZSBjb25maWcuIFxuICAgKiBAcGFyYW0ge2FueX0gZGVmYXVsdFZhbHVlIC0gZGVmYXVsdCB2YWx1ZSBpZiBjb25maWcgZG9lc24ndCBoYXZlIHBhc3NlZCBrZXlcbiAgICogQHBhcmFtIHtvYmplY3R9IHNhdmVkRGF0YSAtIHByZXZpb3VzbHkgc2F2ZWQgZGF0YS4gSWYgcGFzc2VkLCB0aGUga2V5IHdpbGwgYmUgZ290IGZyb20gdGhlcmUsIG90aGVyd2lzZSBmcm9tIHRoZSBjb25maWdcbiAgICogQHJldHVybnMge2FueX0gLSBjb25maWcgdmFsdWUuXG4gICAqL1xuICBnZXRDb25maWcodCwgZSA9IHZvaWQgMCwgbyA9IHZvaWQgMCkge1xuICAgIGNvbnN0IGkgPSB0aGlzLmRhdGEgfHwgbztcbiAgICByZXR1cm4gaSA/IGlbdF0gPyBpW3RdIDogZSA6IHRoaXMuY29uZmlnICYmIHRoaXMuY29uZmlnW3RdID8gdGhpcy5jb25maWdbdF0gOiBlO1xuICB9XG4gIC8qKiAgXG4gICAqIFRhYmxlIG9uUGFzdGUgY29uZmlndXJhdGlvblxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBzdGF0aWMgZ2V0IHBhc3RlQ29uZmlnKCkge1xuICAgIHJldHVybiB7IHRhZ3M6IFtcIlRBQkxFXCIsIFwiVFJcIiwgXCJUSFwiLCBcIlREXCJdIH07XG4gIH1cbiAgLyoqXG4gICAqIE9uIHBhc3RlIGNhbGxiYWNrIHRoYXQgaXMgZmlyZWQgZnJvbSBFZGl0b3JcbiAgICpcbiAgICogQHBhcmFtIHtQYXN0ZUV2ZW50fSBldmVudCAtIGV2ZW50IHdpdGggcGFzdGVkIGRhdGFcbiAgICovXG4gIG9uUGFzdGUodCkge1xuICAgIGNvbnN0IGUgPSB0LmRldGFpbC5kYXRhLCBvID0gZS5xdWVyeVNlbGVjdG9yKFwiOnNjb3BlID4gdGhlYWQsIHRyOmZpcnN0LW9mLXR5cGUgdGhcIiksIHMgPSBBcnJheS5mcm9tKGUucXVlcnlTZWxlY3RvckFsbChcInRyXCIpKS5tYXAoKG4pID0+IEFycmF5LmZyb20obi5xdWVyeVNlbGVjdG9yQWxsKFwidGgsIHRkXCIpKS5tYXAoKGwpID0+IGwuaW5uZXJIVE1MKSk7XG4gICAgdGhpcy5kYXRhID0ge1xuICAgICAgd2l0aEhlYWRpbmdzOiBvICE9PSBudWxsLFxuICAgICAgY29udGVudDogc1xuICAgIH0sIHRoaXMudGFibGUud3JhcHBlciAmJiB0aGlzLnRhYmxlLndyYXBwZXIucmVwbGFjZVdpdGgodGhpcy5yZW5kZXIoKSk7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIEkgYXMgZGVmYXVsdFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@editorjs/table/dist/table.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@editorjs/warning/dist/warning.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@editorjs/warning/dist/warning.mjs ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ r; }\n/* harmony export */ });\n(function(){\"use strict\";try{if(typeof document<\"u\"){var e=document.createElement(\"style\");e.appendChild(document.createTextNode(`.cdx-warning{position:relative}@media all and (min-width: 736px){.cdx-warning{padding-left:36px}}.cdx-warning [contentEditable=true][data-placeholder]:before{position:absolute;content:attr(data-placeholder);color:#707684;font-weight:400;opacity:0}.cdx-warning [contentEditable=true][data-placeholder]:empty:before{opacity:1}.cdx-warning [contentEditable=true][data-placeholder]:empty:focus:before{opacity:0}.cdx-warning:before{content:\"\";background-image:url(\"data:image/svg+xml,%3Csvg width='24' height='24' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Crect x='5' y='5' width='14' height='14' rx='4' stroke='black' stroke-width='2'/%3E%3Cline x1='12' y1='9' x2='12' y2='12' stroke='black' stroke-width='2' stroke-linecap='round'/%3E%3Cpath d='M12 15.02V15.01' stroke='black' stroke-width='2' stroke-linecap='round'/%3E%3C/svg%3E\");width:24px;height:24px;background-size:24px 24px;position:absolute;margin-top:8px;left:0}@media all and (max-width: 735px){.cdx-warning:before{display:none}}.cdx-warning__message{min-height:85px}.cdx-warning__title{margin-bottom:6px}`)),document.head.appendChild(e)}}catch(t){console.error(\"vite-plugin-css-injected-by-js\",t)}})();\nconst n = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><rect width=\"14\" height=\"14\" x=\"5\" y=\"5\" stroke=\"currentColor\" stroke-width=\"2\" rx=\"4\"/><line x1=\"12\" x2=\"12\" y1=\"9\" y2=\"12\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M12 15.02V15.01\"/></svg>';\nclass r {\n  /**\n   * Notify core that read-only mode is supported\n   */\n  static get isReadOnlySupported() {\n    return !0;\n  }\n  /**\n   * Get Toolbox settings\n   *\n   * @public\n   * @returns {string}\n   */\n  static get toolbox() {\n    return {\n      icon: n,\n      title: \"Warning\"\n    };\n  }\n  /**\n   * Allow to press Enter inside the Warning\n   *\n   * @public\n   * @returns {boolean}\n   */\n  static get enableLineBreaks() {\n    return !0;\n  }\n  /**\n   * Default placeholder for warning title\n   *\n   * @public\n   * @returns {string}\n   */\n  static get DEFAULT_TITLE_PLACEHOLDER() {\n    return \"Title\";\n  }\n  /**\n   * Default placeholder for warning message\n   *\n   * @public\n   * @returns {string}\n   */\n  static get DEFAULT_MESSAGE_PLACEHOLDER() {\n    return \"Message\";\n  }\n  /**\n   * Warning Tool`s styles\n   *\n   * @returns {object}\n   */\n  get CSS() {\n    return {\n      baseClass: this.api.styles.block,\n      wrapper: \"cdx-warning\",\n      title: \"cdx-warning__title\",\n      input: this.api.styles.input,\n      message: \"cdx-warning__message\"\n    };\n  }\n  /**\n   * Render plugin`s main Element and fill it with saved data\n   *\n   * @param {WarningData} data  previously saved data\n   * @param {WarningConfig} config  user config for Tool\n   * @param {object} api - Editor.js API\n   * @param {boolean} readOnly - read-only mode flag\n   */\n  constructor({ data: e, config: t, api: s, readOnly: i }) {\n    this.api = s, this.readOnly = i, this.titlePlaceholder = t.titlePlaceholder || r.DEFAULT_TITLE_PLACEHOLDER, this.messagePlaceholder = t.messagePlaceholder || r.DEFAULT_MESSAGE_PLACEHOLDER, this.data = {\n      title: e.title || \"\",\n      message: e.message || \"\"\n    };\n  }\n  /**\n   * Create Warning Tool container with inputs\n   *\n   * @returns {Element}\n   */\n  render() {\n    const e = this._make(\"div\", [this.CSS.baseClass, this.CSS.wrapper]), t = this._make(\"div\", [this.CSS.input, this.CSS.title], {\n      contentEditable: !this.readOnly,\n      innerHTML: this.data.title\n    }), s = this._make(\"div\", [this.CSS.input, this.CSS.message], {\n      contentEditable: !this.readOnly,\n      innerHTML: this.data.message\n    });\n    return t.dataset.placeholder = this.titlePlaceholder, s.dataset.placeholder = this.messagePlaceholder, e.appendChild(t), e.appendChild(s), e;\n  }\n  /**\n   * Extract Warning data from Warning Tool element\n   *\n   * @param {HTMLDivElement} warningElement - element to save\n   * @returns {WarningData}\n   */\n  save(e) {\n    const t = e.querySelector(`.${this.CSS.title}`), s = e.querySelector(`.${this.CSS.message}`);\n    return Object.assign(this.data, {\n      title: t.innerHTML,\n      message: s.innerHTML\n    });\n  }\n  /**\n   * Helper for making Elements with attributes\n   *\n   * @param  {string} tagName           - new Element tag name\n   * @param  {Array|string} classNames  - list or name of CSS classname(s)\n   * @param  {object} attributes        - any attributes\n   * @returns {Element}\n   */\n  _make(e, t = null, s = {}) {\n    const i = document.createElement(e);\n    Array.isArray(t) ? i.classList.add(...t) : t && i.classList.add(t);\n    for (const a in s)\n      i[a] = s[a];\n    return i;\n  }\n  /**\n   * Sanitizer config for Warning Tool saved data\n   *\n   * @returns {object}\n   */\n  static get sanitize() {\n    return {\n      title: {},\n      message: {}\n    };\n  }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZWRpdG9yanMvd2FybmluZy9kaXN0L3dhcm5pbmcubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxZQUFZLGFBQWEsSUFBSSx3QkFBd0Isc0NBQXNDLG9EQUFvRCxrQkFBa0Isa0NBQWtDLGFBQWEsbUJBQW1CLDZEQUE2RCxrQkFBa0IsK0JBQStCLGNBQWMsZ0JBQWdCLFVBQVUsbUVBQW1FLFVBQVUseUVBQXlFLFVBQVUsb0JBQW9CLFdBQVcscWFBQXFhLFdBQVcsWUFBWSwwQkFBMEIsa0JBQWtCLGVBQWUsT0FBTyxrQ0FBa0Msb0JBQW9CLGNBQWMsc0JBQXNCLGdCQUFnQixvQkFBb0Isa0JBQWtCLGtDQUFrQyxTQUFTLG1EQUFtRDtBQUNweUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGFBQWEsZUFBZTtBQUM1QixhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsZ0JBQWdCLHlDQUF5QztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0IsZUFBZTtBQUNmO0FBQ0E7QUFDQSxrQ0FBa0MsZUFBZSw0QkFBNEIsaUJBQWlCO0FBQzlGO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLGNBQWM7QUFDNUIsY0FBYyxRQUFRO0FBQ3RCLGVBQWU7QUFDZjtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BlZGl0b3Jqcy93YXJuaW5nL2Rpc3Qvd2FybmluZy5tanM/MDBiOSJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt0cnl7aWYodHlwZW9mIGRvY3VtZW50PFwidVwiKXt2YXIgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7ZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShgLmNkeC13YXJuaW5ne3Bvc2l0aW9uOnJlbGF0aXZlfUBtZWRpYSBhbGwgYW5kIChtaW4td2lkdGg6IDczNnB4KXsuY2R4LXdhcm5pbmd7cGFkZGluZy1sZWZ0OjM2cHh9fS5jZHgtd2FybmluZyBbY29udGVudEVkaXRhYmxlPXRydWVdW2RhdGEtcGxhY2Vob2xkZXJdOmJlZm9yZXtwb3NpdGlvbjphYnNvbHV0ZTtjb250ZW50OmF0dHIoZGF0YS1wbGFjZWhvbGRlcik7Y29sb3I6IzcwNzY4NDtmb250LXdlaWdodDo0MDA7b3BhY2l0eTowfS5jZHgtd2FybmluZyBbY29udGVudEVkaXRhYmxlPXRydWVdW2RhdGEtcGxhY2Vob2xkZXJdOmVtcHR5OmJlZm9yZXtvcGFjaXR5OjF9LmNkeC13YXJuaW5nIFtjb250ZW50RWRpdGFibGU9dHJ1ZV1bZGF0YS1wbGFjZWhvbGRlcl06ZW1wdHk6Zm9jdXM6YmVmb3Jle29wYWNpdHk6MH0uY2R4LXdhcm5pbmc6YmVmb3Jle2NvbnRlbnQ6XCJcIjtiYWNrZ3JvdW5kLWltYWdlOnVybChcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0Nzdmcgd2lkdGg9JzI0JyBoZWlnaHQ9JzI0JyB2aWV3Qm94PScwIDAgMjQgMjQnIGZpbGw9J25vbmUnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyclM0UlM0NyZWN0IHg9JzUnIHk9JzUnIHdpZHRoPScxNCcgaGVpZ2h0PScxNCcgcng9JzQnIHN0cm9rZT0nYmxhY2snIHN0cm9rZS13aWR0aD0nMicvJTNFJTNDbGluZSB4MT0nMTInIHkxPSc5JyB4Mj0nMTInIHkyPScxMicgc3Ryb2tlPSdibGFjaycgc3Ryb2tlLXdpZHRoPScyJyBzdHJva2UtbGluZWNhcD0ncm91bmQnLyUzRSUzQ3BhdGggZD0nTTEyIDE1LjAyVjE1LjAxJyBzdHJva2U9J2JsYWNrJyBzdHJva2Utd2lkdGg9JzInIHN0cm9rZS1saW5lY2FwPSdyb3VuZCcvJTNFJTNDL3N2ZyUzRVwiKTt3aWR0aDoyNHB4O2hlaWdodDoyNHB4O2JhY2tncm91bmQtc2l6ZToyNHB4IDI0cHg7cG9zaXRpb246YWJzb2x1dGU7bWFyZ2luLXRvcDo4cHg7bGVmdDowfUBtZWRpYSBhbGwgYW5kIChtYXgtd2lkdGg6IDczNXB4KXsuY2R4LXdhcm5pbmc6YmVmb3Jle2Rpc3BsYXk6bm9uZX19LmNkeC13YXJuaW5nX19tZXNzYWdle21pbi1oZWlnaHQ6ODVweH0uY2R4LXdhcm5pbmdfX3RpdGxle21hcmdpbi1ib3R0b206NnB4fWApKSxkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGUpfX1jYXRjaCh0KXtjb25zb2xlLmVycm9yKFwidml0ZS1wbHVnaW4tY3NzLWluamVjdGVkLWJ5LWpzXCIsdCl9fSkoKTtcbmNvbnN0IG4gPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHJlY3Qgd2lkdGg9XCIxNFwiIGhlaWdodD1cIjE0XCIgeD1cIjVcIiB5PVwiNVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS13aWR0aD1cIjJcIiByeD1cIjRcIi8+PGxpbmUgeDE9XCIxMlwiIHgyPVwiMTJcIiB5MT1cIjlcIiB5Mj1cIjEyXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTEyIDE1LjAyVjE1LjAxXCIvPjwvc3ZnPic7XG5jbGFzcyByIHtcbiAgLyoqXG4gICAqIE5vdGlmeSBjb3JlIHRoYXQgcmVhZC1vbmx5IG1vZGUgaXMgc3VwcG9ydGVkXG4gICAqL1xuICBzdGF0aWMgZ2V0IGlzUmVhZE9ubHlTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuICEwO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgVG9vbGJveCBzZXR0aW5nc1xuICAgKlxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZ2V0IHRvb2xib3goKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGljb246IG4sXG4gICAgICB0aXRsZTogXCJXYXJuaW5nXCJcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBBbGxvdyB0byBwcmVzcyBFbnRlciBpbnNpZGUgdGhlIFdhcm5pbmdcbiAgICpcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBnZXQgZW5hYmxlTGluZUJyZWFrcygpIHtcbiAgICByZXR1cm4gITA7XG4gIH1cbiAgLyoqXG4gICAqIERlZmF1bHQgcGxhY2Vob2xkZXIgZm9yIHdhcm5pbmcgdGl0bGVcbiAgICpcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldCBERUZBVUxUX1RJVExFX1BMQUNFSE9MREVSKCkge1xuICAgIHJldHVybiBcIlRpdGxlXCI7XG4gIH1cbiAgLyoqXG4gICAqIERlZmF1bHQgcGxhY2Vob2xkZXIgZm9yIHdhcm5pbmcgbWVzc2FnZVxuICAgKlxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERFRkFVTFRfTUVTU0FHRV9QTEFDRUhPTERFUigpIHtcbiAgICByZXR1cm4gXCJNZXNzYWdlXCI7XG4gIH1cbiAgLyoqXG4gICAqIFdhcm5pbmcgVG9vbGBzIHN0eWxlc1xuICAgKlxuICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgKi9cbiAgZ2V0IENTUygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYmFzZUNsYXNzOiB0aGlzLmFwaS5zdHlsZXMuYmxvY2ssXG4gICAgICB3cmFwcGVyOiBcImNkeC13YXJuaW5nXCIsXG4gICAgICB0aXRsZTogXCJjZHgtd2FybmluZ19fdGl0bGVcIixcbiAgICAgIGlucHV0OiB0aGlzLmFwaS5zdHlsZXMuaW5wdXQsXG4gICAgICBtZXNzYWdlOiBcImNkeC13YXJuaW5nX19tZXNzYWdlXCJcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZW5kZXIgcGx1Z2luYHMgbWFpbiBFbGVtZW50IGFuZCBmaWxsIGl0IHdpdGggc2F2ZWQgZGF0YVxuICAgKlxuICAgKiBAcGFyYW0ge1dhcm5pbmdEYXRhfSBkYXRhIOKAlCBwcmV2aW91c2x5IHNhdmVkIGRhdGFcbiAgICogQHBhcmFtIHtXYXJuaW5nQ29uZmlnfSBjb25maWcg4oCUIHVzZXIgY29uZmlnIGZvciBUb29sXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBhcGkgLSBFZGl0b3IuanMgQVBJXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVhZE9ubHkgLSByZWFkLW9ubHkgbW9kZSBmbGFnXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGRhdGE6IGUsIGNvbmZpZzogdCwgYXBpOiBzLCByZWFkT25seTogaSB9KSB7XG4gICAgdGhpcy5hcGkgPSBzLCB0aGlzLnJlYWRPbmx5ID0gaSwgdGhpcy50aXRsZVBsYWNlaG9sZGVyID0gdC50aXRsZVBsYWNlaG9sZGVyIHx8IHIuREVGQVVMVF9USVRMRV9QTEFDRUhPTERFUiwgdGhpcy5tZXNzYWdlUGxhY2Vob2xkZXIgPSB0Lm1lc3NhZ2VQbGFjZWhvbGRlciB8fCByLkRFRkFVTFRfTUVTU0FHRV9QTEFDRUhPTERFUiwgdGhpcy5kYXRhID0ge1xuICAgICAgdGl0bGU6IGUudGl0bGUgfHwgXCJcIixcbiAgICAgIG1lc3NhZ2U6IGUubWVzc2FnZSB8fCBcIlwiXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIFdhcm5pbmcgVG9vbCBjb250YWluZXIgd2l0aCBpbnB1dHNcbiAgICpcbiAgICogQHJldHVybnMge0VsZW1lbnR9XG4gICAqL1xuICByZW5kZXIoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX21ha2UoXCJkaXZcIiwgW3RoaXMuQ1NTLmJhc2VDbGFzcywgdGhpcy5DU1Mud3JhcHBlcl0pLCB0ID0gdGhpcy5fbWFrZShcImRpdlwiLCBbdGhpcy5DU1MuaW5wdXQsIHRoaXMuQ1NTLnRpdGxlXSwge1xuICAgICAgY29udGVudEVkaXRhYmxlOiAhdGhpcy5yZWFkT25seSxcbiAgICAgIGlubmVySFRNTDogdGhpcy5kYXRhLnRpdGxlXG4gICAgfSksIHMgPSB0aGlzLl9tYWtlKFwiZGl2XCIsIFt0aGlzLkNTUy5pbnB1dCwgdGhpcy5DU1MubWVzc2FnZV0sIHtcbiAgICAgIGNvbnRlbnRFZGl0YWJsZTogIXRoaXMucmVhZE9ubHksXG4gICAgICBpbm5lckhUTUw6IHRoaXMuZGF0YS5tZXNzYWdlXG4gICAgfSk7XG4gICAgcmV0dXJuIHQuZGF0YXNldC5wbGFjZWhvbGRlciA9IHRoaXMudGl0bGVQbGFjZWhvbGRlciwgcy5kYXRhc2V0LnBsYWNlaG9sZGVyID0gdGhpcy5tZXNzYWdlUGxhY2Vob2xkZXIsIGUuYXBwZW5kQ2hpbGQodCksIGUuYXBwZW5kQ2hpbGQocyksIGU7XG4gIH1cbiAgLyoqXG4gICAqIEV4dHJhY3QgV2FybmluZyBkYXRhIGZyb20gV2FybmluZyBUb29sIGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRGl2RWxlbWVudH0gd2FybmluZ0VsZW1lbnQgLSBlbGVtZW50IHRvIHNhdmVcbiAgICogQHJldHVybnMge1dhcm5pbmdEYXRhfVxuICAgKi9cbiAgc2F2ZShlKSB7XG4gICAgY29uc3QgdCA9IGUucXVlcnlTZWxlY3RvcihgLiR7dGhpcy5DU1MudGl0bGV9YCksIHMgPSBlLnF1ZXJ5U2VsZWN0b3IoYC4ke3RoaXMuQ1NTLm1lc3NhZ2V9YCk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24odGhpcy5kYXRhLCB7XG4gICAgICB0aXRsZTogdC5pbm5lckhUTUwsXG4gICAgICBtZXNzYWdlOiBzLmlubmVySFRNTFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBIZWxwZXIgZm9yIG1ha2luZyBFbGVtZW50cyB3aXRoIGF0dHJpYnV0ZXNcbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSB0YWdOYW1lICAgICAgICAgICAtIG5ldyBFbGVtZW50IHRhZyBuYW1lXG4gICAqIEBwYXJhbSAge0FycmF5fHN0cmluZ30gY2xhc3NOYW1lcyAgLSBsaXN0IG9yIG5hbWUgb2YgQ1NTIGNsYXNzbmFtZShzKVxuICAgKiBAcGFyYW0gIHtvYmplY3R9IGF0dHJpYnV0ZXMgICAgICAgIC0gYW55IGF0dHJpYnV0ZXNcbiAgICogQHJldHVybnMge0VsZW1lbnR9XG4gICAqL1xuICBfbWFrZShlLCB0ID0gbnVsbCwgcyA9IHt9KSB7XG4gICAgY29uc3QgaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZSk7XG4gICAgQXJyYXkuaXNBcnJheSh0KSA/IGkuY2xhc3NMaXN0LmFkZCguLi50KSA6IHQgJiYgaS5jbGFzc0xpc3QuYWRkKHQpO1xuICAgIGZvciAoY29uc3QgYSBpbiBzKVxuICAgICAgaVthXSA9IHNbYV07XG4gICAgcmV0dXJuIGk7XG4gIH1cbiAgLyoqXG4gICAqIFNhbml0aXplciBjb25maWcgZm9yIFdhcm5pbmcgVG9vbCBzYXZlZCBkYXRhXG4gICAqXG4gICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IHNhbml0aXplKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0aXRsZToge30sXG4gICAgICBtZXNzYWdlOiB7fVxuICAgIH07XG4gIH1cbn1cbmV4cG9ydCB7XG4gIHIgYXMgZGVmYXVsdFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@editorjs/warning/dist/warning.mjs\n"));

/***/ })

}]);